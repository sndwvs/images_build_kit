From b308597caef9ad23c9c4358baae526f7167627b9 Mon Sep 17 00:00:00 2001
From: Jack Ma <jack@radxa.com>
Date: Fri, 2 Jul 2021 11:23:03 +0800
Subject: [PATCH] fastboot custom flash support offset

Add support for fastboot offset writing

On PC:

    fastboot flash 0x200 u-boot.bin

write to eMMC user partition 0x200 offset

Signed-off-by: Jack Ma <jack@radxa.com>
---
 arch/arm/mach-meson/board-common.c | 37 +++++++++++++++++++++---------
 1 file changed, 26 insertions(+), 11 deletions(-)

diff --git a/arch/arm/mach-meson/board-common.c b/arch/arm/mach-meson/board-common.c
index ca632e200df..9a7924b1abe 100644
--- a/arch/arm/mach-meson/board-common.c
+++ b/arch/arm/mach-meson/board-common.c
@@ -211,6 +211,7 @@ static bool fastboot_board_hwpart_process(const char *cmd, void *buffer,
 	struct blk_desc *desc;
 	void *blk_ptr = NULL;
 	int offset, length;
+	bool hw_part;
 	struct mmc *mmc;
 	lbaint_t blkcnt;
 	lbaint_t blk;
@@ -219,42 +220,55 @@ static bool fastboot_board_hwpart_process(const char *cmd, void *buffer,
 	lbaint_t blks = 0;
 	int ret, i;
 
+	mmc = find_mmc_device(FASBOOT_HWPART_MMC_ENV_DEV);
+	if (!mmc) {
+		pr_err("invalid mmc device\n");
+		fastboot_fail("invalid mmc device", response);
+		return true;
+	}
+
 	/* Check if we handle these partitions */
 	if (strcmp(cmd, "bootloader") == 0) {
 		offset = FASBOOT_HWPART_BOOTLOADER_OFFSET;
 		length = FASBOOT_HWPART_BOOTLOADER_LENGTH;
+		hw_part = true;
 	} else if (strcmp(cmd, "bootenv") == 0) {
 		offset = FASBOOT_HWPART_BOOTENV_OFFSET;
 		length = FASBOOT_HWPART_BOOTENV_LENGTH;
-	} else
+		hw_part = true;
+	} else if (0 == strict_strtoul(cmd, 16, (unsigned long *)&offset)) {
+		hw_part = false;
+		length = mmc->capacity - offset;
+	} else {
+		fastboot_fail("Unknown partition or offset", response);
 		return false;
+	}
 
-	if (buffer && is_sparse_image(buffer)) {
+	/*if (buffer && is_sparse_image(buffer)) {
 		pr_err("sparse buffer not supported");
 		fastboot_fail("sparse buffer not supported", response);
 		return true;
 	}
+	*/
 
-	mmc = find_mmc_device(FASBOOT_HWPART_MMC_ENV_DEV);
-	if (!mmc) {
-		pr_err("invalid mmc device\n");
-		fastboot_fail("invalid mmc device", response);
-		return true;
-	}
+	if (hw_part)
+		ret = mmc_switch_part(mmc, FASBOOT_HWPART_MMC_ENV_PART);
+	else
+		ret = mmc_switch_part(mmc, 0);
 
-	ret = mmc_switch_part(mmc, FASBOOT_HWPART_MMC_ENV_PART);
 	if (ret) {
 		pr_err("invalid mmc hwpart\n");
 		fastboot_fail("invalid mmc hwpart", response);
 		return true;
 	}
 
+
 	desc = mmc_get_blk_desc(mmc);
 
 	if (offset < 0)
 		offset += mmc->capacity;
 
-	printf("using custom hwpart %s at offset 0x%x and length %d bytes\n",
+	printf("using custom offset %s at offset 0x%x and length %d bytes\n",
 	       cmd, offset, length);
 
 	/* Use full length in erase mode */
@@ -340,4 +354,5 @@ bool fastboot_board_erase(const char *cmd, char *response)
 {
 	return fastboot_board_hwpart_process(cmd, NULL, 0, response);
 }
-#endif
\ No newline at end of file
+
+#endif
