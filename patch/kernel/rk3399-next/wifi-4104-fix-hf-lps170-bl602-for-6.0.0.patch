--- a/drivers/net/wireless/hflps170/fullmac/bl_main.c	2022-10-09 15:25:01.534050736 +0300
+++ b/drivers/net/wireless/hflps170/fullmac/bl_main.c	2022-10-09 15:29:39.186759911 +0300
@@ -1353,8 +1353,13 @@ static int bl_cfg80211_add_station(struc
             sta->vif_idx = bl_vif->vif_index;
             sta->vlan_idx = sta->vif_idx;
             sta->qos = (params->sta_flags_set & BIT(NL80211_STA_FLAG_WME)) != 0;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 2))
+            sta->ht = params->ext_capab ? 1 : 0;
+            sta->vht = params->ext_capab ? 1 : 0;
+#else
             sta->ht = params->ht_capa ? 1 : 0;
             sta->vht = params->vht_capa ? 1 : 0;
+#endif
             sta->acm = 0;
             for (tid = 0; tid < NX_NB_TXQ_PER_STA; tid++) {
                 int uapsd_bit = bl_hwq2uapsd[bl_tid2hwq[tid]];
@@ -1525,8 +1530,13 @@ static int bl_cfg80211_change_station(st
                     sta->vif_idx = bl_vif->vif_index;
                     sta->vlan_idx = sta->vif_idx;
                     sta->qos = (params->sta_flags_set & BIT(NL80211_STA_FLAG_WME)) != 0;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 2))
+                    sta->ht = params->ext_capab ? 1 : 0;
+                    sta->vht = params->ext_capab ? 1 : 0;
+#else
                     sta->ht = params->ht_capa ? 1 : 0;
                     sta->vht = params->vht_capa ? 1 : 0;
+#endif
                     sta->acm = 0;
                     for (tid = 0; tid < NX_NB_TXQ_PER_STA; tid++) {
                         int uapsd_bit = bl_hwq2uapsd[bl_tid2hwq[tid]];
--- a/drivers/net/wireless/hflps170/bl_msg_tx.c	2022-10-09 14:50:45.288650044 +0300
+++ b/drivers/net/wireless/hflps170/bl_msg_tx.c	2022-10-09 15:24:25.297958488 +0300
@@ -713,7 +713,11 @@ int bl_send_me_sta_add(struct bl_hw *bl_
                          const u8 *mac, u8 inst_nbr, struct me_sta_add_cfm *cfm)
 {
     struct me_sta_add_req *req;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 2))
+    u8 *ht_mcs = (u8 *)&params->ext_capab;
+#else
     u8 *ht_mcs = (u8 *)&params->ht_capa->mcs;
+#endif
     int i;
 
     BL_DBG(BL_FN_ENTRY_STR);
@@ -727,13 +731,24 @@ int bl_send_me_sta_add(struct bl_hw *bl_
     /* Set parameters for the MM_STA_ADD_REQ message */
     memcpy(&(req->mac_addr.array[0]), mac, ETH_ALEN);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 2))
+    req->rate_set.length = params->supported_channels_len;
+    for (i = 0; i < params->supported_channels_len; i++)
+        req->rate_set.array[i] = params->supported_channels[i];
+#else
     req->rate_set.length = params->supported_rates_len;
     for (i = 0; i < params->supported_rates_len; i++)
         req->rate_set.array[i] = params->supported_rates[i];
+#endif
 
     req->flags = 0;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 2))
+    if (params->ext_capab) {
+        const struct ieee80211_ht_cap *ht_capa;
+#else
     if (params->ht_capa) {
         const struct ieee80211_ht_cap *ht_capa = params->ht_capa;
+#endif
 
         req->flags |= STA_HT_CAPA;
         req->ht_cap.ht_capa_info = cpu_to_le16(ht_capa->cap_info);
@@ -745,8 +760,13 @@ int bl_send_me_sta_add(struct bl_hw *bl_
         req->ht_cap.asel_capa = ht_capa->antenna_selection_info;
     }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 2))
+    if (params->ext_capab) {
+        const struct ieee80211_vht_cap *vht_capa;
+#else
     if (params->vht_capa) {
         const struct ieee80211_vht_cap *vht_capa = params->vht_capa;
+#endif
 
         req->flags |= STA_VHT_CAPA;
         req->vht_cap.vht_capa_info = cpu_to_le32(vht_capa->vht_cap_info);
@@ -762,10 +782,12 @@ int bl_send_me_sta_add(struct bl_hw *bl_
     if (params->sta_flags_set & BIT(NL80211_STA_FLAG_MFP))
         req->flags |= STA_MFP_CAPA;
 
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(5, 19, 2))
     if (params->opmode_notif_used) {
         req->flags |= STA_OPMOD_NOTIF;
         req->opmode = params->opmode_notif;
     }
+#endif
 
     req->aid = cpu_to_le16(params->aid);
     req->uapsd_queues = params->uapsd_queues;
