--- a/drivers/soc/rockchip/iomux.c	2022-07-09 21:34:18.921102204 +0300
+++ b/drivers/soc/rockchip/iomux.c	2022-07-09 21:34:38.585174074 +0300
@@ -9,6 +9,7 @@
 #include <linux/fs.h>
 #include <linux/list.h>
 #include <linux/uaccess.h>
+#include <linux/module.h>
 #include <linux/ioctl.h>
 #include <linux/types.h>
 #include <linux/miscdevice.h>
@@ -63,7 +64,7 @@ static const struct file_operations rk_i
 	.compat_ioctl	= compat_ptr_ioctl,
 };
 
-static __init int rk_iomux_device_create(void)
+static int __init rk_iomux_device_create(void)
 {
 	struct rk_iomux_device *cdev;
 	int ret;
@@ -85,3 +86,5 @@ static __init int rk_iomux_device_create
 	return 0;
 }
 late_initcall(rk_iomux_device_create);
+
+MODULE_LICENSE("GPL v2");
--- a/drivers/video/rockchip/rga3/rga_policy.c	2022-07-09 19:46:32.603441066 +0300
+++ b/drivers/video/rockchip/rga3/rga_policy.c	2022-07-09 19:48:13.523875863 +0300
@@ -244,7 +244,8 @@ int rga_job_assign(struct rga_job *job)
 		    job->flags & RGA_JOB_UNSUPPORT_RGA2) {
 			if (DEBUGGER_EN(MSG))
 				pr_info("RGA2 only support under 4G memory!\n");
-				continue;
+			continue;
+			
 		}
 
 		if (feature > 0) {
@@ -266,6 +267,7 @@ int rga_job_assign(struct rga_job *job)
 						pr_info("core = %d, ABC break on rd_mode",
 							scheduler->core);
 					continue;
+					
 				}
 			} else {
 				if ((!(src0->rd_mode & data->win[0].rd_mode)) ||
--- a/drivers/video/rockchip/dvbm/rockchip_dvbm.c	2022-07-09 20:05:56.640442957 +0300
+++ b/drivers/video/rockchip/dvbm/rockchip_dvbm.c	2022-07-09 20:30:29.202589491 +0300
@@ -252,7 +252,7 @@ static int rk_dvbm_setup_iobuf(struct dv
 	ctx->isp_frm_info.line_cnt = 0;
 	ctx->isp_frm_info.max_line_cnt = ALIGN(ctx->isp_max_lcnt, 32);
 	ctx->isp_frm_info.wrap_line = ctx->wrap_line;
-	dvbm_debug("dma_addr 0x%08x y_lstd %d y_fstd %d\n",
+	dvbm_debug("dma_addr 0x%08llu y_lstd %d y_fstd %d\n",
 		   cfg->dma_addr, cfg->ybuf_lstd, cfg->ybuf_fstd);
 	dvbm_debug("ybot 0x%x top 0x%x cbuf bot 0x%x top 0x%x\n",
 		   addr_base->ybuf_bot, addr_base->ybuf_top,
--- a/drivers/video/rockchip/rve/rve_drv.c	2022-07-09 19:52:27.952970998 +0300
+++ b/drivers/video/rockchip/rve/rve_drv.c	2022-07-09 19:53:38.945276316 +0300
@@ -582,7 +582,7 @@ static irqreturn_t rve_irq_thread(int ir
 		(!(error_flag & RVE_LLP_DONE))) {
 		if (DEBUGGER_EN(INT_FLAG))
 			pr_err("irq: llp mode need to skip rve_job_done");
-			goto skip_job_done;
+		goto skip_job_done;
 	}
 
 	rve_job_done(scheduler, 0);
--- a/drivers/media/platform/rockchip/cif/capture.c	2022-07-09 23:16:13.726064557 +0300
+++ b/drivers/media/platform/rockchip/cif/capture.c	2022-07-09 23:17:15.774326616 +0300
@@ -6230,7 +6230,8 @@ static int rkcif_dvp_g_ch_id(struct v4l2
 		if ((frm_stat & DVP_CHANNEL2_FRM_READ) ==
 		    DVP_CHANNEL2_FRM_READ)
 			v4l2_warn(v4l2_dev, "frame0/1 trigger simultaneously in DVP ID2\n");
-			*intstat &= ~DVP_FRAME_END_ID2;
+
+		*intstat &= ~DVP_FRAME_END_ID2;
 		return RKCIF_STREAM_MIPI_ID2;
 	}
 
@@ -6238,7 +6239,8 @@ static int rkcif_dvp_g_ch_id(struct v4l2
 		if ((frm_stat & DVP_CHANNEL3_FRM_READ) ==
 		    DVP_CHANNEL3_FRM_READ)
 			v4l2_warn(v4l2_dev, "frame0/1 trigger simultaneously in DVP ID3\n");
-			*intstat &= ~DVP_FRAME_END_ID3;
+
+		*intstat &= ~DVP_FRAME_END_ID3;
 		return RKCIF_STREAM_MIPI_ID3;
 	}
 
--- a/drivers/net/phy/rk630phy.c	2022-07-09 22:08:49.329154260 +0300
+++ b/drivers/net/phy/rk630phy.c	2022-07-09 23:36:44.519264529 +0300
@@ -86,7 +86,7 @@ static void rk630_phy_t22_get_tx_level_f
 	unsigned int tx_level_10M = T22_TX_LEVEL_10M;
 	unsigned char *efuse_buf;
 	struct nvmem_cell *cell;
-	int len;
+	size_t len;
 
 	cell = nvmem_cell_get(&phydev->mdio.dev, "txlevel");
 	if (IS_ERR(cell)) {
@@ -378,7 +378,7 @@ static struct mdio_device_id __maybe_unu
 	{ }
 };
 
-MODULE_DEVICE_TABLE(mdio, rockchip_phy_tbl);
+MODULE_DEVICE_TABLE(mdio, rk630_phy_tbl);
 
 module_phy_driver(rk630_phy_driver);
 
--- a/drivers/rtc/rtc-rockchip.c	2022-07-09 22:36:59.056058794 +0300
+++ b/drivers/rtc/rtc-rockchip.c	2022-07-09 23:04:06.706975407 +0300
@@ -666,7 +666,7 @@ static int rockchip_rtc_probe(struct pla
 		return dev_err_probe(dev, PTR_ERR(rtc->regmap),
 				     "no regmap available\n");
 
-	rtc->mode = (unsigned int)of_device_get_match_data(&pdev->dev);
+	rtc->mode = (long unsigned int)of_device_get_match_data(&pdev->dev);
 	rtc->grf = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
 	if (IS_ERR(rtc->grf)) {
 		dev_warn(dev, "Missing rockchip,grf property\n");
--- a/drivers/media/platform/rockchip/isp/capture_v30.c	2022-07-10 15:25:03.201087117 +0300
+++ b/drivers/media/platform/rockchip/isp/capture_v30.c	2022-07-10 15:24:49.149020117 +0300
@@ -15,6 +15,10 @@
 
 #define CIF_ISP_REQ_BUFS_MIN 0
 
+int rkisp_dvbm_get(struct rkisp_device *dev) { return -EINVAL; }
+int rkisp_dvbm_init(struct rkisp_stream *stream) { return -EINVAL; }
+void rkisp_dvbm_deinit(void) {}
+
 static int mi_frame_end(struct rkisp_stream *stream);
 
 static const struct capture_fmt fbc_fmts[] = {
--- a/drivers/media/platform/rockchip/isp/rkisp.c	2022-07-10 14:14:58.422525802 +0300
+++ a/drivers/media/platform/rockchip/isp/rkisp.c	2022-07-10 15:01:06.766536928 +0300
@@ -87,6 +87,8 @@
 
 static void rkisp_config_cmsk(struct rkisp_device *dev);
 
+int rkisp_dvbm_event(struct rkisp_device *dev, u32 event) { return -EINVAL; }
+
 struct backup_reg {
 	const u32 base;
 	const u32 shd;
