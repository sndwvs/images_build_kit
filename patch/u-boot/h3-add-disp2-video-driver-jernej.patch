commit 6b19f528f7650c659806f0b100e155337d3b37b3
Author: Jernej Skrabec <jernej.skrabec@siol.net>
Date:   Tue Nov 8 01:04:32 2016 +0100

    sunxi: video: Add video driver for H3 SoC
    
    Signed-off-by: Jernej Skrabec <jernej.skrabec@siol.net>

diff --git a/arch/arm/include/asm/arch-sunxi/clock_sun6i.h b/arch/arm/include/asm/arch-sunxi/clock_sun6i.h
index be9fcfd..02d4a8c 100644
--- a/arch/arm/include/asm/arch-sunxi/clock_sun6i.h
+++ b/arch/arm/include/asm/arch-sunxi/clock_sun6i.h
@@ -67,12 +67,20 @@ struct sunxi_ccm_reg {
 	u32 dram_pll_cfg;	/* 0xf8 PLL_DDR cfg register, A33 only */
 	u32 mbus_reset;		/* 0xfc MBUS reset control, A33 only */
 	u32 dram_clk_gate;	/* 0x100 DRAM module gating */
+#ifdef CONFIG_SUNXI_DE2
+	u32 de_clk_cfg;		/* 0x104 DE module clock */
+#else
 	u32 be0_clk_cfg;	/* 0x104 BE0 module clock */
+#endif
 	u32 be1_clk_cfg;	/* 0x108 BE1 module clock */
 	u32 fe0_clk_cfg;	/* 0x10c FE0 module clock */
 	u32 fe1_clk_cfg;	/* 0x110 FE1 module clock */
 	u32 mp_clk_cfg;		/* 0x114 MP module clock */
+#ifdef CONFIG_SUNXI_DE2
+	u32 tcon0_clk_cfg;	/* 0x118 TCON0 module clock */
+#else
 	u32 lcd0_ch0_clk_cfg;	/* 0x118 LCD0 CH0 module clock */
+#endif
 	u32 lcd1_ch0_clk_cfg;	/* 0x11c LCD1 CH0 module clock */
 	u32 reserved14[3];
 	u32 lcd0_ch1_clk_cfg;	/* 0x12c LCD0 CH1 module clock */
@@ -85,7 +93,11 @@ struct sunxi_ccm_reg {
 	u32 dmic_clk_cfg;	/* 0x148 Digital Mic module clock*/
 	u32 reserved15;
 	u32 hdmi_clk_cfg;	/* 0x150 HDMI module clock */
+#ifdef CONFIG_SUNXI_DE2
+	u32 hdmi_slow_clk_cfg;	/* 0x154 HDMI slow module clock */
+#else
 	u32 ps_clk_cfg;		/* 0x154 PS module clock */
+#endif
 	u32 mtc_clk_cfg;	/* 0x158 MTC module clock */
 	u32 mbus0_clk_cfg;	/* 0x15c MBUS0 module clock */
 	u32 mbus1_clk_cfg;	/* 0x160 MBUS1 module clock */
@@ -220,6 +232,15 @@ struct sunxi_ccm_reg {
 #define CCM_MIPI_PLL_CTRL_LDO_EN	(0x3 << 22)
 #define CCM_MIPI_PLL_CTRL_EN		(0x1 << 31)
 
+#define CCM_PLL10_CTRL_M_SHIFT		0
+#define CCM_PLL10_CTRL_M_MASK		(0xf << CCM_PLL10_CTRL_M_SHIFT)
+#define CCM_PLL10_CTRL_M(n)		((((n) - 1) & 0xf) << 0)
+#define CCM_PLL10_CTRL_N_SHIFT		8
+#define CCM_PLL10_CTRL_N_MASK		(0x7f << CCM_PLL10_CTRL_N_SHIFT)
+#define CCM_PLL10_CTRL_N(n)		((((n) - 1) & 0x7f) << 8)
+#define CCM_PLL10_CTRL_INTEGER_MODE	(0x1 << 24)
+#define CCM_PLL10_CTRL_EN		(0x1 << 31)
+
 #define CCM_PLL11_CTRL_N(n)		((((n) - 1) & 0x3f) << 8)
 #define CCM_PLL11_CTRL_SIGMA_DELTA_EN	(0x1 << 24)
 #define CCM_PLL11_CTRL_UPD		(0x1 << 30)
@@ -271,9 +292,12 @@ struct sunxi_ccm_reg {
 #define AHB_GATE_OFFSET_DRC0		25
 #define AHB_GATE_OFFSET_DE_FE0		14
 #define AHB_GATE_OFFSET_DE_BE0		12
+#define AHB_GATE_OFFSET_DE		12
 #define AHB_GATE_OFFSET_HDMI		11
 #define AHB_GATE_OFFSET_LCD1		5
 #define AHB_GATE_OFFSET_LCD0		4
+#define AHB_GATE_OFFSET_TCON1		4
+#define AHB_GATE_OFFSET_TCON0		3
 
 #define CCM_MMC_CTRL_M(x)		((x) - 1)
 #define CCM_MMC_CTRL_OCLK_DLY(x)	((x) << 8)
@@ -346,6 +370,9 @@ struct sunxi_ccm_reg {
 #define CCM_LCD_CH0_CTRL_RST		0
 #define CCM_LCD_CH0_CTRL_GATE		(0x1 << 31)
 
+#define CCM_TCON0_CTRL_GATE		(0x1 << 31)
+#define CCM_TCON0_CTRL_M(n)		((((n) - 1) & 0xf) << 0)
+
 #define CCM_LCD_CH1_CTRL_M(n)		((((n) - 1) & 0xf) << 0)
 #define CCM_LCD_CH1_CTRL_HALF_SCLK1	0 /* no seperate sclk1 & 2 on sun6i */
 #define CCM_LCD_CH1_CTRL_PLL3		(0 << 24)
@@ -355,6 +382,7 @@ struct sunxi_ccm_reg {
 #define CCM_LCD_CH1_CTRL_GATE		(0x1 << 31)
 
 #define CCM_HDMI_CTRL_M(n)		((((n) - 1) & 0xf) << 0)
+#define CCM_HDMI_CTRL_M_MASK		(0xf << 0)
 #define CCM_HDMI_CTRL_PLL_MASK		(3 << 24)
 #define CCM_HDMI_CTRL_PLL3		(0 << 24)
 #define CCM_HDMI_CTRL_PLL7		(1 << 24)
@@ -363,6 +391,8 @@ struct sunxi_ccm_reg {
 #define CCM_HDMI_CTRL_DDC_GATE		(0x1 << 30)
 #define CCM_HDMI_CTRL_GATE		(0x1 << 31)
 
+#define CCM_HDMI_SLOW_CTRL_DDC_GATE	(1 << 31)
+
 #if defined(CONFIG_MACH_SUN50I)
 #define MBUS_CLK_DEFAULT		0x81000002 /* PLL6x2 / 3 */
 #elif defined(CONFIG_MACH_SUN8I)
@@ -390,9 +420,13 @@ struct sunxi_ccm_reg {
 #define AHB_RESET_OFFSET_DRC0		25
 #define AHB_RESET_OFFSET_DE_FE0		14
 #define AHB_RESET_OFFSET_DE_BE0		12
+#define AHB_RESET_OFFSET_DE		12
 #define AHB_RESET_OFFSET_HDMI		11
+#define AHB_RESET_OFFSET_HDMI2		10
 #define AHB_RESET_OFFSET_LCD1		5
 #define AHB_RESET_OFFSET_LCD0		4
+#define AHB_RESET_OFFSET_TCON1		4
+#define AHB_RESET_OFFSET_TCON0		3
 
 /* ahb_reset2 offsets */
 #define AHB_RESET_OFFSET_EPHY		2
@@ -406,6 +440,7 @@ struct sunxi_ccm_reg {
 
 /* CCM bits common to all Display Engine (and IEP) clock ctrl regs */
 #define CCM_DE_CTRL_M(n)		((((n) - 1) & 0xf) << 0)
+#ifndef CONFIG_SUNXI_DE2
 #define CCM_DE_CTRL_PLL_MASK		(0xf << 24)
 #define CCM_DE_CTRL_PLL3		(0 << 24)
 #define CCM_DE_CTRL_PLL7		(1 << 24)
@@ -413,6 +448,11 @@ struct sunxi_ccm_reg {
 #define CCM_DE_CTRL_PLL8		(3 << 24)
 #define CCM_DE_CTRL_PLL9		(4 << 24)
 #define CCM_DE_CTRL_PLL10		(5 << 24)
+#else
+#define CCM_DE_CTRL_PLL_MASK		(3 << 24)
+#define CCM_DE_CTRL_PLL6_2X		(0 << 24)
+#define CCM_DE_CTRL_PLL10		(1 << 24)
+#endif
 #define CCM_DE_CTRL_GATE		(1 << 31)
 
 /* CCU security switch, H3 only */
@@ -423,7 +463,9 @@ struct sunxi_ccm_reg {
 #ifndef __ASSEMBLY__
 void clock_set_pll1(unsigned int hz);
 void clock_set_pll3(unsigned int hz);
+void clock_set_pll3_factors(int m, int n);
 void clock_set_pll5(unsigned int clk, bool sigma_delta_enable);
+void clock_set_pll10(unsigned int hz);
 void clock_set_pll11(unsigned int clk, bool sigma_delta_enable);
 void clock_set_mipi_pll(unsigned int hz);
 unsigned int clock_get_pll3(void);
diff --git a/arch/arm/include/asm/arch-sunxi/cpu_sun4i.h b/arch/arm/include/asm/arch-sunxi/cpu_sun4i.h
--- a/arch/arm/include/asm/arch-sunxi/cpu_sun4i.h
+++ b/arch/arm/include/asm/arch-sunxi/cpu_sun4i.h
@@ -18,6 +18,8 @@
 #define SUNXI_SRAM_D_BASE		0x00010000	/* 4 kiB */
 #define SUNXI_SRAM_B_BASE		0x00020000	/* 64 kiB (secure) */
 
+#define SUNXI_DE2_BASE			0x01000000
+
 #ifdef CONFIG_MACH_SUN8I_A83T
 #define SUNXI_CPUCFG_BASE		0x01700000
 #endif
@@ -46,7 +48,9 @@
 #define SUNXI_USB1_BASE			0x01c14000
 #endif
 #define SUNXI_SS_BASE			0x01c15000
+#ifndef CONFIG_SUNXI_DE2
 #define SUNXI_HDMI_BASE			0x01c16000
+#endif
 #define SUNXI_SPI2_BASE			0x01c17000
 #define SUNXI_SATA_BASE			0x01c18000
 #ifdef CONFIG_SUNXI_GEN_SUN4I
@@ -163,6 +167,10 @@ defined(CONFIG_MACH_SUN50I)
 #define SUNXI_MP_BASE			0x01e80000
 #define SUNXI_AVG_BASE			0x01ea0000
 
+#ifdef CONFIG_SUNXI_DE2
+#define SUNXI_HDMI_BASE			0x01ee0000
+#endif
+
 #define SUNXI_RTC_BASE			0x01f00000
 #define SUNXI_PRCM_BASE			0x01f01400
 
diff --git a/arch/arm/include/asm/arch-sunxi/display2.h b/arch/arm/include/asm/arch-sunxi/display2.h
new file mode 100644
--- /dev/null
+++ b/arch/arm/include/asm/arch-sunxi/display2.h
@@ -0,0 +1,282 @@
+/*
+ * Sunxi platform display controller register and constant defines
+ *
+ * (C) Copyright 2016 Jernej Skrabec <jernej.skrabec@siol.net>
+ *
+ * Based on Linux DRM driver defines:
+ * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
+ * Copyright (c) 2016 Allwinnertech Co., Ltd.
+ * 
+ * Based on display.h:
+ * (C) Copyright 2014 Hans de Goede <hdegoede@redhat.com>
+ * 
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _SUNXI_DISPLAY2_H
+#define _SUNXI_DISPLAY2_H
+
+struct sunxi_lcdc_reg {
+	u32 ctrl;			/* 0x00 */
+	u32 int0;			/* 0x04 */
+	u32 int1;			/* 0x08 */
+	u8 res0[0x04];			/* 0x0c */
+	u32 tcon0_frm_ctrl;		/* 0x10 */
+	u32 tcon0_frm_seed[6];		/* 0x14 */
+	u32 tcon0_frm_table[4];		/* 0x2c */
+	u8 res1[4];			/* 0x3c */
+	u32 tcon0_ctrl;			/* 0x40 */
+	u32 tcon0_dclk;			/* 0x44 */
+	u32 tcon0_timing_active;	/* 0x48 */
+	u32 tcon0_timing_h;		/* 0x4c */
+	u32 tcon0_timing_v;		/* 0x50 */
+	u32 tcon0_timing_sync;		/* 0x54 */
+	u32 tcon0_hv_intf;		/* 0x58 */
+	u8 res2[0x04];			/* 0x5c */
+	u32 tcon0_cpu_intf;		/* 0x60 */
+	u32 tcon0_cpu_wr_dat;		/* 0x64 */
+	u32 tcon0_cpu_rd_dat0;		/* 0x68 */
+	u32 tcon0_cpu_rd_dat1;		/* 0x6c */
+	u32 tcon0_ttl_timing0;		/* 0x70 */
+	u32 tcon0_ttl_timing1;		/* 0x74 */
+	u32 tcon0_ttl_timing2;		/* 0x78 */
+	u32 tcon0_ttl_timing3;		/* 0x7c */
+	u32 tcon0_ttl_timing4;		/* 0x80 */
+	u32 tcon0_lvds_intf;		/* 0x84 */
+	u32 tcon0_io_polarity;		/* 0x88 */
+	u32 tcon0_io_tristate;		/* 0x8c */
+	u32 tcon1_ctrl;			/* 0x90 */
+	u32 tcon1_timing_source;	/* 0x94 */
+	u32 tcon1_timing_scale;		/* 0x98 */
+	u32 tcon1_timing_out;		/* 0x9c */
+	u32 tcon1_timing_h;		/* 0xa0 */
+	u32 tcon1_timing_v;		/* 0xa4 */
+	u32 tcon1_timing_sync;		/* 0xa8 */
+	u8 res3[0x44];			/* 0xac */
+	u32 tcon1_io_polarity;		/* 0xf0 */
+	u32 tcon1_io_tristate;		/* 0xf4 */
+	u8 res4[0x108];			/* 0xf8 */
+	u32 mux_ctrl;			/* 0x200 */
+};
+
+/* internal clock settings */
+struct de_clk {
+	u32 gate_cfg;
+	u32 bus_cfg;
+	u32 rst_cfg;
+	u32 div_cfg;
+	u32 sel_cfg;
+};
+
+/* global control */
+struct de_glb {
+	u32 ctl;
+#define		DE_MUX_GLB_CTL_rt_en BIT(0)
+	u32 status;
+	u32 dbuff;
+	u32 size;
+};
+
+/* alpha blending */
+struct de_bld {
+	u32 fcolor_ctl;			/* 00 */
+	struct {
+		u32 fcolor;
+		u32 insize;
+		u32 offset;
+		u32 dum;
+	} attr[4];
+	u32 dum0[15];			/* (end of clear offset) */
+	u32 route;			/* 80 */
+	u32 premultiply;
+	u32 bkcolor;
+	u32 output_size;
+	u32 bld_mode[4];
+	u32 dum1[4];
+	u32 ck_ctl;			/* b0 */
+	u32 ck_cfg;
+	u32 dum2[2];
+	u32 ck_max[4];			/* c0 */
+	u32 dum3[4];
+	u32 ck_min[4];			/* e0 */
+	u32 dum4[3];
+	u32 out_ctl;			/* fc */
+};
+
+/* VI channel */
+struct de_vi {
+	struct {
+		u32 attr;
+		u32 size;
+		u32 coord;
+		u32 pitch[3];
+		u32 top_laddr[3];
+		u32 bot_laddr[3];
+	} cfg[4];
+	u32 fcolor[4];			/* c0 */
+	u32 top_haddr[3];		/* d0 */
+	u32 bot_haddr[3];		/* dc */
+	u32 ovl_size[2];		/* e8 */
+	u32 hori[2];			/* f0 */
+	u32 vert[2];			/* f8 */
+};
+
+struct de_ui {
+	struct {
+		u32 attr;
+#define			UI_CFG_ATTR_en BIT(0)
+#define			UI_CFG_ATTR_alpmod_SHIFT 1
+#define			UI_CFG_ATTR_alpmod_MASK GENMASK(2, 1)
+#define			UI_CFG_ATTR_fcolor_en BIT(4)
+#define			UI_CFG_ATTR_fmt_SHIFT 8
+#define			UI_CFG_ATTR_fmt_MASK GENMASK(12, 8)
+#define			UI_CFG_ATTR_alpha_SHIFT 24
+#define			UI_CFG_ATTR_alpha_MASK GENMASK(31, 24)
+		u32 size;
+		u32 coord;
+		u32 pitch;
+		u32 top_laddr;
+		u32 bot_laddr;
+		u32 fcolor;
+		u32 dum;
+	} cfg[4];			/* 00 */
+	u32 top_haddr;			/* 80 */
+	u32 bot_haddr;
+	u32 ovl_size;			/* 88 */
+};
+
+struct sunxi_phy_hdmi_reg {
+	u32 pol;
+	u32 dum0[3];
+	u32 read_en;
+	u32 dum1[3];
+	u32 ctrl;
+	u32 unk1;
+	u32 unk2;
+	u32 pll;
+	u32 clk;
+	u32 unk3;
+	u32 status;
+};
+
+/*
+ * HDMI register addresses
+ */
+#define SUNXI_HDMI_PHY_BASE			(u32*)(SUNXI_HDMI_BASE + 0x10000)
+
+/* Naming is taken from Linux, drivers/gpu/drm/bridge/dw-hdmi.h */
+#define SUNXI_HDMI_IH_I2CM_STAT0		(u8*)(SUNXI_HDMI_BASE + 0x0013)
+#define SUNXI_HDMI_IH_MUTE			(u8*)(SUNXI_HDMI_BASE + 0xF01F)
+
+#define SUNXI_HDMI_TX_INVID0			(u8*)(SUNXI_HDMI_BASE + 0x0800)
+#define SUNXI_HDMI_TX_INSTUFFING		(u8*)(SUNXI_HDMI_BASE + 0x0801)
+#define SUNXI_HDMI_TX_GYDATA0			(u8*)(SUNXI_HDMI_BASE + 0x8800)
+#define SUNXI_HDMI_TX_GYDATA1			(u8*)(SUNXI_HDMI_BASE + 0x8801)
+#define SUNXI_HDMI_TX_RCRDATA0			(u8*)(SUNXI_HDMI_BASE + 0x0802)
+#define SUNXI_HDMI_TX_RCRDATA1			(u8*)(SUNXI_HDMI_BASE + 0x0803)
+#define SUNXI_HDMI_TX_BCBDATA0			(u8*)(SUNXI_HDMI_BASE + 0x8802)
+#define SUNXI_HDMI_TX_BCBDATA1			(u8*)(SUNXI_HDMI_BASE + 0x8803)
+
+#define SUNXI_HDMI_VP_PR_CD			(u8*)(SUNXI_HDMI_BASE + 0x0401)
+#define SUNXI_HDMI_VP_STUFF			(u8*)(SUNXI_HDMI_BASE + 0x8400)
+#define SUNXI_HDMI_VP_REMAP			(u8*)(SUNXI_HDMI_BASE + 0x8401)
+#define SUNXI_HDMI_VP_CONF			(u8*)(SUNXI_HDMI_BASE + 0x0402)
+
+#define SUNXI_HDMI_FC_INVIDCONF			(u8*)(SUNXI_HDMI_BASE + 0x0040)
+#define SUNXI_HDMI_FC_INHACTV0			(u8*)(SUNXI_HDMI_BASE + 0x0041)
+#define SUNXI_HDMI_FC_INHACTV1			(u8*)(SUNXI_HDMI_BASE + 0x8040)
+#define SUNXI_HDMI_FC_INHBLANK0			(u8*)(SUNXI_HDMI_BASE + 0x8041)
+#define SUNXI_HDMI_FC_INHBLANK1			(u8*)(SUNXI_HDMI_BASE + 0x0042)
+#define SUNXI_HDMI_FC_INVACTV0			(u8*)(SUNXI_HDMI_BASE + 0x0043)
+#define SUNXI_HDMI_FC_INVACTV1			(u8*)(SUNXI_HDMI_BASE + 0x8042)
+#define SUNXI_HDMI_FC_INVBLANK			(u8*)(SUNXI_HDMI_BASE + 0x8043)
+#define SUNXI_HDMI_FC_HSYNCINDELAY0		(u8*)(SUNXI_HDMI_BASE + 0x4040)
+#define SUNXI_HDMI_FC_HSYNCINDELAY1		(u8*)(SUNXI_HDMI_BASE + 0x4041)
+#define SUNXI_HDMI_FC_HSYNCINWIDTH0		(u8*)(SUNXI_HDMI_BASE + 0xC040)
+#define SUNXI_HDMI_FC_HSYNCINWIDTH1		(u8*)(SUNXI_HDMI_BASE + 0xC041)
+#define SUNXI_HDMI_FC_VSYNCINDELAY		(u8*)(SUNXI_HDMI_BASE + 0x4042)
+#define SUNXI_HDMI_FC_VSYNCINWIDTH		(u8*)(SUNXI_HDMI_BASE + 0x4043)
+#define SUNXI_HDMI_FC_CTRLDUR			(u8*)(SUNXI_HDMI_BASE + 0x0045)
+#define SUNXI_HDMI_FC_EXCTRLDUR			(u8*)(SUNXI_HDMI_BASE + 0x8044)
+#define SUNXI_HDMI_FC_EXCTRLSPAC		(u8*)(SUNXI_HDMI_BASE + 0x8045)
+#define SUNXI_HDMI_FC_CH0PREAM			(u8*)(SUNXI_HDMI_BASE + 0x0046)
+#define SUNXI_HDMI_FC_CH1PREAM 			(u8*)(SUNXI_HDMI_BASE + 0x0047)
+#define SUNXI_HDMI_FC_CH2PREAM			(u8*)(SUNXI_HDMI_BASE + 0x8046)
+#define SUNXI_HDMI_FC_AVICONF0			(u8*)(SUNXI_HDMI_BASE + 0x4045)
+#define SUNXI_HDMI_FC_AVICONF1			(u8*)(SUNXI_HDMI_BASE + 0xC044)
+#define SUNXI_HDMI_FC_AVICONF2			(u8*)(SUNXI_HDMI_BASE + 0xC045)
+
+#define SUNXI_HDMI_MC_CLKDIS			(u8*)(SUNXI_HDMI_BASE + 0x0081)
+#define SUNXI_HDMI_MC_SWRSTZ			(u8*)(SUNXI_HDMI_BASE + 0x8080)
+#define SUNXI_HDMI_MC_FLOWCTRL			(u8*)(SUNXI_HDMI_BASE + 0x0082)
+
+#define SUNXI_HDMI_I2CM_SLAVE			(u8*)(SUNXI_HDMI_BASE + 0x0EE0)
+#define SUNXI_HDMI_I2CM_ADDRESS			(u8*)(SUNXI_HDMI_BASE + 0x0EE1)
+#define SUNXI_HDMI_I2CM_DATAI			(u8*)(SUNXI_HDMI_BASE + 0x8EE1)
+#define SUNXI_HDMI_I2CM_OPERATION		(u8*)(SUNXI_HDMI_BASE + 0x0EE2)
+#define SUNXI_HDMI_I2CM_INT			(u8*)(SUNXI_HDMI_BASE + 0x0EE3)
+#define SUNXI_HDMI_I2CM_CTLINT			(u8*)(SUNXI_HDMI_BASE + 0x8EE2)
+#define SUNXI_HDMI_I2CM_DIV			(u8*)(SUNXI_HDMI_BASE + 0x8EE3)
+#define SUNXI_HDMI_I2CM_SEGADDR			(u8*)(SUNXI_HDMI_BASE + 0x4EE0)
+#define SUNXI_HDMI_I2CM_SOFTRSTZ		(u8*)(SUNXI_HDMI_BASE + 0x4EE1)
+#define SUNXI_HDMI_I2CM_SEGPTR			(u8*)(SUNXI_HDMI_BASE + 0xCEE0)
+#define SUNXI_HDMI_I2CM_SS_SCL_HCNT_0_ADDR	(u8*)(SUNXI_HDMI_BASE + 0x4EE2)
+#define SUNXI_HDMI_I2CM_SS_SCL_LCNT_0_ADDR	(u8*)(SUNXI_HDMI_BASE + 0xCEE2)
+
+/*
+ * DE register constants.
+ */
+#define SUNXI_DE2_MUX0_BASE 			(u8*)(SUNXI_DE2_BASE + 0x00100000)
+/* MUX registers (addr / MUX base) */
+#define SUNXI_DE2_MUX_GLB_REGS			0x00000
+#define SUNXI_DE2_MUX_BLD_REGS			0x01000
+#define SUNXI_DE2_MUX_CHAN_REGS			0x02000
+#define	SUNXI_DE2_MUX_CHAN_SZ			0x1000
+#define SUNXI_DE2_MUX_VSU_REGS			0x20000
+#define SUNXI_DE2_MUX_GSU1_REGS			0x30000
+#define SUNXI_DE2_MUX_GSU2_REGS			0x40000
+#define SUNXI_DE2_MUX_GSU3_REGS			0x50000
+#define SUNXI_DE2_MUX_FCE_REGS			0xa0000
+#define SUNXI_DE2_MUX_BWS_REGS			0xa2000
+#define SUNXI_DE2_MUX_LTI_REGS			0xa4000
+#define SUNXI_DE2_MUX_PEAK_REGS			0xa6000
+#define SUNXI_DE2_MUX_ASE_REGS			0xa8000
+#define SUNXI_DE2_MUX_FCC_REGS			0xaa000
+#define SUNXI_DE2_MUX_DCSC_REGS			0xb0000
+
+#define SUNXI_DE2_FORMAT_ARGB_8888 0
+#define SUNXI_DE2_FORMAT_BGRA_8888 3
+#define SUNXI_DE2_FORMAT_XRGB_8888 4
+#define SUNXI_DE2_FORMAT_RGB_888 8
+#define SUNXI_DE2_FORMAT_BGR_888 9
+
+/* coordinates and sizes */
+#define XY(x, y) (((y) << 16) | (x))
+#define WH(w, h) (((h - 1) << 16) | (w - 1))
+
+/*
+ * LCDC register constants.
+ */
+#define SUNXI_LCDC_X(x)				(((x) - 1) << 16)
+#define SUNXI_LCDC_Y(y)				(((y) - 1) << 0)
+#define SUNXI_LCDC_CTRL_TCON_ENABLE		(1 << 31)
+#define SUNXI_LCDC_TCON0_CTRL_ENABLE		(1 << 31)
+#define SUNXI_LCDC_TCON1_CTRL_CLK_DELAY(n)	(((n) & 0x1f) << 4)
+#define SUNXI_LCDC_TCON1_CTRL_INTERLACE_ENABLE	(1 << 20)
+#define SUNXI_LCDC_TCON1_CTRL_ENABLE		(1 << 31)
+#define SUNXI_LCDC_TCON1_TIMING_H_BP(n)		(((n) - 1) << 0)
+#define SUNXI_LCDC_TCON1_TIMING_H_TOTAL(n)	(((n) - 1) << 16)
+#define SUNXI_LCDC_TCON1_TIMING_V_BP(n)		(((n) - 1) << 0)
+#define SUNXI_LCDC_TCON1_TIMING_V_TOTAL(n)	((n) << 16)
+
+/*
+ * HDMI register constants.
+ */
+#define SUNXI_HDMI_HPD_DETECT			(1 << 19)
+
+#define SUN8I_HMDI_DDC_CTRL_RESET		(1 << 0)
+#define SUN8I_HMDI_DDC_ADDR_SLAVE_ADDR		(0x50 << 0)
+#define SUN8I_HMDI_DDC_ADDR_SEG_ADDR		(0x30 << 0)
+
+
+#endif /* _SUNXI_DISPLAY_H */
diff --git a/arch/arm/mach-sunxi/clock_sun6i.c b/arch/arm/mach-sunxi/clock_sun6i.c
--- a/arch/arm/mach-sunxi/clock_sun6i.c
+++ b/arch/arm/mach-sunxi/clock_sun6i.c
@@ -141,6 +141,17 @@ void clock_set_pll3(unsigned int clk)
 	       &ccm->pll3_cfg);
 }
 
+void clock_set_pll3_factors(int m, int n)
+{
+	struct sunxi_ccm_reg * const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+
+	/* PLL3 rate = 24000000 * n / m */
+	writel(CCM_PLL3_CTRL_EN | CCM_PLL3_CTRL_INTEGER_MODE |
+	       CCM_PLL3_CTRL_N(n) | CCM_PLL3_CTRL_M(m),
+	       &ccm->pll3_cfg);
+}
+
 void clock_set_pll5(unsigned int clk, bool sigma_delta_enable)
 {
 	struct sunxi_ccm_reg * const ccm =
@@ -213,6 +224,23 @@ done:
 }
 #endif
 
+void clock_set_pll10(unsigned int clk)
+{
+	struct sunxi_ccm_reg * const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	const int m = 2; /* 12 MHz steps */
+
+	if (clk == 0) {
+		clrbits_le32(&ccm->pll10_cfg, CCM_PLL10_CTRL_EN);
+		return;
+	}
+
+	/* PLL10 rate = 24000000 * n / m */
+	writel(CCM_PLL10_CTRL_EN | CCM_PLL10_CTRL_INTEGER_MODE |
+	       CCM_PLL10_CTRL_N(clk / (24000000 / m)) | CCM_PLL10_CTRL_M(m),
+	       &ccm->pll10_cfg);
+}
+
 #ifdef CONFIG_MACH_SUN8I_A33
 void clock_set_pll11(unsigned int clk, bool sigma_delta_enable)
 {
@@ -267,6 +295,7 @@ unsigned int clock_get_mipi_pll(void)
 	return ((src / 1000) * n * k / m) * 1000;
 }
 
+#ifndef CONFIG_SUNXI_DE2
 void clock_set_de_mod_clock(u32 *clk_cfg, unsigned int hz)
 {
 	int pll = clock_get_pll6() * 2;
@@ -278,3 +307,4 @@ void clock_set_de_mod_clock(u32 *clk_cfg, unsigned int hz)
 	writel(CCM_DE_CTRL_GATE | CCM_DE_CTRL_PLL6_2X | CCM_DE_CTRL_M(div),
 	       clk_cfg);
 }
+#endif
diff --git a/board/sunxi/Kconfig b/board/sunxi/Kconfig
--- a/board/sunxi/Kconfig
+++ b/board/sunxi/Kconfig
@@ -458,7 +458,7 @@ config AXP_GPIO
 
 config VIDEO
 	bool "Enable graphical uboot console on HDMI, LCD or VGA"
-	depends on !MACH_SUN8I_A83T && !MACH_SUN8I_H3 && !MACH_SUN9I && !MACH_SUN50I
+	depends on !MACH_SUN8I_A83T && !MACH_SUN9I && !MACH_SUN50I
 	default y
 	---help---
 	Say Y here to add support for using a cfb console on the HDMI, LCD
@@ -467,7 +467,7 @@ config VIDEO
 
 config VIDEO_HDMI
 	bool "HDMI output support"
-	depends on VIDEO && !MACH_SUN8I
+	depends on VIDEO && !MACH_SUN8I_A23 && !MACH_SUN8I_A33
 	default y
 	---help---
 	Say Y here to add support for outputting video over HDMI.
diff --git a/configs/orangepi_2_defconfig b/configs/orangepi_2_defconfig
--- a/configs/orangepi_2_defconfig
+++ b/configs/orangepi_2_defconfig
@@ -16,3 +16,4 @@ CONFIG_SPL=y
 CONFIG_SUN8I_EMAC=y
 CONFIG_SY8106A_POWER=y
 CONFIG_USB_EHCI_HCD=y
+CONFIG_VIDEO=y
diff --git a/configs/orangepi_lite_defconfig b/configs/orangepi_lite_defconfig
--- a/configs/orangepi_lite_defconfig
+++ b/configs/orangepi_lite_defconfig
@@ -12,3 +12,4 @@ CONFIG_SPL=y
 # CONFIG_CMD_FLASH is not set
 # CONFIG_CMD_FPGA is not set
 CONFIG_USB_EHCI_HCD=y
+CONFIG_VIDEO=y
diff --git a/configs/orangepi_one_defconfig b/configs/orangepi_one_defconfig
--- a/configs/orangepi_one_defconfig
+++ b/configs/orangepi_one_defconfig
@@ -13,3 +13,4 @@ CONFIG_SPL=y
 # CONFIG_CMD_FPGA is not set
 CONFIG_SUN8I_EMAC=y
 CONFIG_USB_EHCI_HCD=y
+CONFIG_VIDEO=y
diff --git a/configs/orangepi_pc_defconfig b/configs/orangepi_pc_defconfig
--- a/configs/orangepi_pc_defconfig
+++ b/configs/orangepi_pc_defconfig
@@ -15,3 +15,4 @@ CONFIG_SPL=y
 CONFIG_SUN8I_EMAC=y
 CONFIG_SY8106A_POWER=y
 CONFIG_USB_EHCI_HCD=y
+CONFIG_VIDEO=y
diff --git a/configs/orangepi_pc_plus_defconfig b/configs/orangepi_pc_plus_defconfig
--- a/configs/orangepi_pc_plus_defconfig
+++ b/configs/orangepi_pc_plus_defconfig
@@ -16,3 +16,4 @@ CONFIG_SPL=y
 CONFIG_SUN8I_EMAC=y
 CONFIG_SY8106A_POWER=y
 CONFIG_USB_EHCI_HCD=y
+CONFIG_VIDEO=y
diff --git a/configs/orangepi_plus2e_defconfig b/configs/orangepi_plus2e_defconfig
--- a/configs/orangepi_plus2e_defconfig
+++ b/configs/orangepi_plus2e_defconfig
@@ -17,3 +17,4 @@ CONFIG_SPL=y
 CONFIG_SUN8I_EMAC=y
 CONFIG_SY8106A_POWER=y
 CONFIG_USB_EHCI_HCD=y
+CONFIG_VIDEO=y
diff --git a/configs/orangepi_plus_defconfig b/configs/orangepi_plus_defconfig
--- a/configs/orangepi_plus_defconfig
+++ b/configs/orangepi_plus_defconfig
@@ -18,3 +18,4 @@ CONFIG_SPL=y
 CONFIG_SUN8I_EMAC=y
 CONFIG_SY8106A_POWER=y
 CONFIG_USB_EHCI_HCD=y
+CONFIG_VIDEO=y
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -52,6 +52,7 @@ obj-$(CONFIG_VIDEO_OMAP3) += omap3_dss.o
 obj-$(CONFIG_VIDEO_SANDBOX_SDL) += sandbox_sdl.o
 obj-$(CONFIG_VIDEO_SM501) += sm501.o
 obj-$(CONFIG_VIDEO_SUNXI) += sunxi_display.o videomodes.o
+obj-$(CONFIG_VIDEO_SUNXI2) += sunxi_display2.o videomodes.o
 obj-$(CONFIG_VIDEO_TEGRA20) += tegra.o
 obj-$(CONFIG_VIDEO_VCXK) += bus_vcxk.o
 obj-$(CONFIG_VIDEO_VESA) += vesa.o
diff --git a/drivers/video/sunxi_display2.c b/drivers/video/sunxi_display2.c
new file mode 100644
--- /dev/null
+++ b/drivers/video/sunxi_display2.c
@@ -0,0 +1,982 @@
+/*
+ * Display driver for sunxi Allwinner SoCs with DE2.
+ * 
+ * Copyright (C) 2016 Jernej Skrabec <jernej.skrabec@siol.net>
+ *
+ * Based on sunxi_display.c:
+ * (C) Copyright 2013-2014 Luc Verhaegen <libv@skynet.be>
+ * (C) Copyright 2014-2015 Hans de Goede <hdegoede@redhat.com>
+ * 
+ * Based on Linux DRM driver:
+ * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
+ * Copyright (c) 2016 Allwinnertech Co., Ltd.
+ *
+ * Based on rk_hdmi.c:
+ * Copyright (c) 2015 Google, Inc
+ * Copyright 2014 Rockchip Inc.
+ * 
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+
+#include <asm/arch/clock.h>
+#include <asm/arch/display2.h>
+#include <asm/global_data.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <fdt_support.h>
+#include <malloc.h>
+#include <video_fb.h>
+#include "videomodes.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+enum sunxi_monitor {
+	sunxi_monitor_none,
+	sunxi_monitor_dvi,
+	sunxi_monitor_hdmi,
+};
+#define SUNXI_MONITOR_LAST sunxi_monitor_hdmi
+
+struct sunxi_display {
+	GraphicDevice graphic_device;
+	enum sunxi_monitor monitor;
+	unsigned int depth;
+	unsigned int fb_addr;
+	unsigned int fb_size;
+} sunxi_display;
+
+#ifdef CONFIG_VIDEO_HDMI
+
+static void sunxi_hdmi_phy_init(void)
+{
+	struct sunxi_phy_hdmi_reg * const phy =
+		(struct sunxi_phy_hdmi_reg *)SUNXI_HDMI_PHY_BASE;
+	unsigned long tmo;
+	u32 tmp;
+
+	/*
+	 * HDMI PHY settings are taken as-is from Allwinner BSP code.
+	 * There is no documentation.
+	 */
+	writel(0, &phy->ctrl);
+	setbits_le32(&phy->ctrl, BIT(0));
+	udelay(5);
+	setbits_le32(&phy->ctrl, BIT(16));
+	setbits_le32(&phy->ctrl, BIT(1));
+	udelay(10);
+	setbits_le32(&phy->ctrl, BIT(2));
+	udelay(5);
+	setbits_le32(&phy->ctrl, BIT(3));
+	udelay(40);
+	setbits_le32(&phy->ctrl, BIT(19));
+	udelay(100);
+	setbits_le32(&phy->ctrl, BIT(18));
+	setbits_le32(&phy->ctrl, 7 << 4);
+
+	/* Note that Allwinner code doesn't fail in case of timeout */
+	tmo = timer_get_us() + 2000;
+	while ((readl(&phy->status) & 0x80) == 0) {
+		if (timer_get_us() > tmo) {
+			printf("Warning: HDMI PHY init timeout!\n");
+			break;
+		}
+	}
+
+	setbits_le32(&phy->ctrl, 0xf << 8);
+	setbits_le32(&phy->ctrl, BIT(7));
+
+	writel(0x39dc5040, &phy->pll);
+	writel(0x80084343, &phy->clk);
+	udelay(10000);
+	writel(1, &phy->unk3);
+	setbits_le32(&phy->pll, BIT(25));
+	udelay(100000);
+	tmp = (readl(&phy->status) & 0x1f800) >> 11;
+	setbits_le32(&phy->pll, BIT(31) | BIT(30));
+	setbits_le32(&phy->pll, tmp);
+	writel(0x01FF0F7F, &phy->ctrl);
+	writel(0x80639000, &phy->unk1);
+	writel(0x0F81C405, &phy->unk2);
+
+	/* enable read access to HDMI controller */
+	writel(0x54524545, &phy->read_en);
+}
+
+static void sunxi_hdmi_ctrl_init(void)
+{
+	/* soft reset HDMI controller */
+	writeb(0x00, SUNXI_HDMI_MC_SWRSTZ);
+	udelay(1);
+	writeb(0x03, SUNXI_HDMI_IH_MUTE);
+	writeb(0xff, SUNXI_HDMI_I2CM_CTLINT);
+	writeb(0xfd, SUNXI_HDMI_MC_CLKDIS);
+}
+
+static int sunxi_hdmi_hpd_detect(int hpd_delay)
+{
+	struct sunxi_ccm_reg * const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	struct sunxi_phy_hdmi_reg * const phy =
+		(struct sunxi_phy_hdmi_reg *)SUNXI_HDMI_PHY_BASE;
+	unsigned long tmo = timer_get_us() + hpd_delay * 1000;
+	int status = 0;
+
+	/* Set pll3 to 297 MHz */
+	clock_set_pll3(297000000);
+
+	/* Set hdmi parent to pll3 */
+	clrsetbits_le32(&ccm->hdmi_clk_cfg, CCM_HDMI_CTRL_PLL_MASK,
+			CCM_HDMI_CTRL_PLL3);
+
+	/* Set ahb gating to pass */
+	setbits_le32(&ccm->ahb_reset1_cfg, 1 << AHB_RESET_OFFSET_HDMI);
+	setbits_le32(&ccm->ahb_reset1_cfg, 1 << AHB_RESET_OFFSET_HDMI2);
+	setbits_le32(&ccm->ahb_gate1, 1 << AHB_GATE_OFFSET_HDMI);
+	setbits_le32(&ccm->hdmi_slow_clk_cfg, CCM_HDMI_SLOW_CTRL_DDC_GATE);
+
+	/* Clock on */
+	setbits_le32(&ccm->hdmi_clk_cfg, CCM_HDMI_CTRL_GATE);
+
+	sunxi_hdmi_phy_init();
+	sunxi_hdmi_ctrl_init();
+
+	while (timer_get_us() < tmo) {
+		if (readl(&phy->status) & SUNXI_HDMI_HPD_DETECT) {
+			status = 1;
+			break;
+		}
+	}
+
+	return status;
+}
+
+static void sunxi_hdmi_shutdown(void)
+{
+	struct sunxi_ccm_reg * const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	struct sunxi_phy_hdmi_reg * const phy =
+		(struct sunxi_phy_hdmi_reg *)SUNXI_HDMI_PHY_BASE;
+
+	writel(0, &phy->ctrl);
+	clrbits_le32(&ccm->hdmi_clk_cfg, CCM_HDMI_CTRL_GATE);
+	clrbits_le32(&ccm->hdmi_slow_clk_cfg, CCM_HDMI_SLOW_CTRL_DDC_GATE);
+	clrbits_le32(&ccm->ahb_gate1, 1 << AHB_GATE_OFFSET_HDMI);
+	clrbits_le32(&ccm->ahb_reset1_cfg, 1 << AHB_RESET_OFFSET_HDMI);
+	clrbits_le32(&ccm->ahb_reset1_cfg, 1 << AHB_RESET_OFFSET_HDMI2);
+	clock_set_pll3(0);
+}
+
+static int sunxi_hdmi_ddc_wait_i2c_done(int msec)
+{
+	u32 val;
+	ulong start;
+
+	start = get_timer(0);
+	do {
+		val = readb(SUNXI_HDMI_IH_I2CM_STAT0);
+		writeb(val, SUNXI_HDMI_IH_I2CM_STAT0);
+
+		if (val & 0x2)
+			return 0;
+		if (val & 0x1)
+			return -EIO;
+
+		udelay(100);
+	} while (get_timer(start) < msec);
+
+	return 1;
+}
+
+static int sunxi_hdmi_ddc_read(int block, u8 *buf)
+{
+	int shift = (block % 2) * 0x80;
+	int trytime = 5;
+	int edid_read_err = 0;
+	u32 op = (block == 0) ? 1 : 2;
+	int n;
+
+	writeb(block >> 1, SUNXI_HDMI_I2CM_SEGPTR);
+
+	while (trytime--) {
+		edid_read_err = 0;
+
+		for (n = 0; n < 128; n++) {
+			writeb(shift + n, SUNXI_HDMI_I2CM_ADDRESS);
+			writeb(op, SUNXI_HDMI_I2CM_OPERATION);
+
+			if (sunxi_hdmi_ddc_wait_i2c_done(10)) {
+				edid_read_err = 1;
+				break;
+			}
+
+			*buf++ = readb(SUNXI_HDMI_I2CM_DATAI);
+		}
+
+		if (!edid_read_err)
+			break;
+	}
+
+	return edid_read_err;
+}
+
+static int sunxi_hdmi_edid_get_block(int block, u8 *buf)
+{
+	int r, retries = 2;
+
+	do {
+		r = sunxi_hdmi_ddc_read(block, buf);
+		if (r)
+			continue;
+		r = edid_check_checksum(buf);
+		if (r) {
+			printf("EDID block %d: checksum error%s\n",
+			       block, retries ? ", retrying" : "");
+		}
+	} while (r && retries--);
+
+	return r;
+}
+
+static int sunxi_hdmi_edid_get_mode(struct ctfb_res_modes *mode)
+{
+	struct edid1_info edid1;
+	struct edid_cea861_info cea681[4];
+	struct edid_detailed_timing *t =
+		(struct edid_detailed_timing *)edid1.monitor_details.timing;
+	int i, r, ext_blocks = 0;
+
+	/* Reset i2c controller */
+	writeb(0, SUNXI_HDMI_I2CM_SOFTRSTZ);
+
+	writeb(0x05, SUNXI_HDMI_I2CM_DIV);
+	writeb(0x08, SUNXI_HDMI_I2CM_INT);
+	writeb(0xd8, SUNXI_HDMI_I2CM_SS_SCL_HCNT_0_ADDR);
+	writeb(0xfe, SUNXI_HDMI_I2CM_SS_SCL_LCNT_0_ADDR);
+	writeb(SUN8I_HMDI_DDC_ADDR_SLAVE_ADDR, SUNXI_HDMI_I2CM_SLAVE);
+	writeb(SUN8I_HMDI_DDC_ADDR_SEG_ADDR, SUNXI_HDMI_I2CM_SEGADDR);
+
+	r = sunxi_hdmi_edid_get_block(0, (u8 *)&edid1);
+	if (r == 0) {
+		r = edid_check_info(&edid1);
+		if (r) {
+			printf("EDID: invalid EDID data\n");
+			r = -EINVAL;
+		}
+	}
+	if (r == 0) {
+		ext_blocks = edid1.extension_flag;
+		if (ext_blocks > 4)
+			ext_blocks = 4;
+		for (i = 0; i < ext_blocks; i++) {
+			if (sunxi_hdmi_edid_get_block(1 + i,
+						(u8 *)&cea681[i]) != 0) {
+				ext_blocks = i;
+				break;
+			}
+		}
+	}
+
+	if (r)
+		return r;
+
+	/* We want version 1.3 or 1.2 with detailed timing info */
+	if (edid1.version != 1 || (edid1.revision < 3 &&
+			!EDID1_INFO_FEATURE_PREFERRED_TIMING_MODE(edid1))) {
+		printf("EDID: unsupported version %d.%d\n",
+		       edid1.version, edid1.revision);
+		return -EINVAL;
+	}
+
+	/* Take the first usable detailed timing */
+	for (i = 0; i < 4; i++, t++) {
+		r = video_edid_dtd_to_ctfb_res_modes(t, mode);
+		if (r == 0)
+			break;
+	}
+	if (i == 4) {
+		printf("EDID: no usable detailed timing found\n");
+		return -ENOENT;
+	}
+
+	/* Check for basic audio support, if found enable hdmi output */
+	sunxi_display.monitor = sunxi_monitor_dvi;
+	for (i = 0; i < ext_blocks; i++) {
+		if (cea681[i].extension_tag != EDID_CEA861_EXTENSION_TAG ||
+		    cea681[i].revision < 2)
+			continue;
+
+		if (EDID_CEA861_SUPPORTS_BASIC_AUDIO(cea681[i]))
+			sunxi_display.monitor = sunxi_monitor_hdmi;
+	}
+
+	return 0;
+}
+
+#endif /* CONFIG_VIDEO_HDMI */
+
+/*
+ * This is the entity that mixes and matches the different layers and inputs.
+ * Allwinner calls it display engine, but here is called composer.
+ */
+static void sunxi_composer_init(void)
+{
+	struct sunxi_ccm_reg * const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+
+	clock_set_pll10(432000000);
+
+	/* Set DE parent to pll10 */
+	clrsetbits_le32(&ccm->de_clk_cfg, CCM_DE_CTRL_PLL_MASK,
+			CCM_DE_CTRL_PLL10);
+
+	/* Set ahb gating to pass */
+	setbits_le32(&ccm->ahb_reset1_cfg, 1 << AHB_RESET_OFFSET_DE);
+	setbits_le32(&ccm->ahb_gate1, 1 << AHB_GATE_OFFSET_DE);
+
+	/* Clock on */
+	setbits_le32(&ccm->de_clk_cfg, CCM_DE_CTRL_GATE);
+}
+
+static void sunxi_composer_mode_set(const struct ctfb_res_modes *mode,
+				    unsigned int address)
+{
+	struct de_clk * const de_clk_regs =
+		(struct de_clk *)(SUNXI_DE2_BASE);
+	struct de_glb * const de_glb_regs =
+		(struct de_glb *)(SUNXI_DE2_MUX0_BASE + SUNXI_DE2_MUX_GLB_REGS);
+	struct de_bld * const de_bld_regs =
+		(struct de_bld *)(SUNXI_DE2_MUX0_BASE + SUNXI_DE2_MUX_BLD_REGS);
+	struct de_ui * const de_ui_regs =
+		(struct de_ui *)(SUNXI_DE2_MUX0_BASE + SUNXI_DE2_MUX_CHAN_REGS +
+			SUNXI_DE2_MUX_CHAN_SZ * 1);
+	u32 size = WH(mode->xres, mode->yres);
+	int channel, i;
+	u32 data;
+
+	/* enable clock */
+	setbits_le32(&de_clk_regs->rst_cfg, 1);
+	setbits_le32(&de_clk_regs->gate_cfg, 1);
+	setbits_le32(&de_clk_regs->bus_cfg, 1);
+
+	clrbits_le32(&de_clk_regs->sel_cfg, 1);
+
+	writel(DE_MUX_GLB_CTL_rt_en, &de_glb_regs->ctl);
+	writel(0, &de_glb_regs->status);
+	writel(1, &de_glb_regs->dbuff);
+	writel(size, &de_glb_regs->size);
+
+	for (channel = 0; channel < 4; channel++) {
+		void *chan = SUNXI_DE2_MUX0_BASE + SUNXI_DE2_MUX_CHAN_REGS +
+			SUNXI_DE2_MUX_CHAN_SZ * channel;
+		memset(chan, 0, channel == 0 ?
+			sizeof(struct de_vi) : sizeof(struct de_ui));
+	}
+	memset(de_bld_regs, 0, 0x44);
+	
+	writel(0x00000101, &de_bld_regs->fcolor_ctl);
+
+	writel(1, &de_bld_regs->route);
+
+	writel(0, &de_bld_regs->premultiply);
+	writel(0xff000000, &de_bld_regs->bkcolor);
+
+	writel(0x03010301, &de_bld_regs->bld_mode[0]);
+	writel(0x03010301, &de_bld_regs->bld_mode[1]);
+	
+	writel(size, &de_bld_regs->output_size);
+	writel(mode->vmode & FB_VMODE_INTERLACED ? 2 : 0,
+		&de_bld_regs->out_ctl);
+	writel(0, &de_bld_regs->ck_ctl);
+
+	for (i = 0; i < 4; i++) {
+		writel(0xff000000, &de_bld_regs->attr[i].fcolor);
+		writel(size, &de_bld_regs->attr[i].insize);
+	}
+
+	/* Disable all other units */
+	writel(0, SUNXI_DE2_MUX0_BASE + SUNXI_DE2_MUX_VSU_REGS);
+	writel(0, SUNXI_DE2_MUX0_BASE + SUNXI_DE2_MUX_GSU1_REGS);
+	writel(0, SUNXI_DE2_MUX0_BASE + SUNXI_DE2_MUX_GSU2_REGS);
+	writel(0, SUNXI_DE2_MUX0_BASE + SUNXI_DE2_MUX_GSU3_REGS);
+	writel(0, SUNXI_DE2_MUX0_BASE + SUNXI_DE2_MUX_FCE_REGS);
+	writel(0, SUNXI_DE2_MUX0_BASE + SUNXI_DE2_MUX_BWS_REGS);
+	writel(0, SUNXI_DE2_MUX0_BASE + SUNXI_DE2_MUX_LTI_REGS);
+	writel(0, SUNXI_DE2_MUX0_BASE + SUNXI_DE2_MUX_PEAK_REGS);
+	writel(0, SUNXI_DE2_MUX0_BASE + SUNXI_DE2_MUX_ASE_REGS);
+	writel(0, SUNXI_DE2_MUX0_BASE + SUNXI_DE2_MUX_FCC_REGS);
+	writel(0, SUNXI_DE2_MUX0_BASE + SUNXI_DE2_MUX_DCSC_REGS);
+
+	data = UI_CFG_ATTR_en | (SUNXI_DE2_FORMAT_XRGB_8888 << UI_CFG_ATTR_fmt_SHIFT) |
+		(1 << UI_CFG_ATTR_alpmod_SHIFT) | (0xff << UI_CFG_ATTR_alpha_SHIFT);
+	writel(data, &de_ui_regs->cfg[0].attr);
+	writel(size, &de_ui_regs->cfg[0].size);
+	writel(0, &de_ui_regs->cfg[0].coord);
+	writel(4 * mode->xres, &de_ui_regs->cfg[0].pitch);
+	writel(address, &de_ui_regs->cfg[0].top_laddr);
+	writel(size, &de_ui_regs->ovl_size);
+}
+
+static void sunxi_composer_enable(void)
+{
+	struct de_glb * const de_glb_regs =
+		(struct de_glb *)(SUNXI_DE2_MUX0_BASE + SUNXI_DE2_MUX_GLB_REGS);
+
+	writel(1, &de_glb_regs->dbuff);
+}
+
+/*
+ * LCDC, what allwinner calls a CRTC, so timing controller and serializer.
+ */
+static void sunxi_lcdc_pll_set(int dotclock, int *clk_div)
+{
+	struct sunxi_ccm_reg * const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	int value, n, m, x = 0, diff;
+	int best_n = 0, best_m = 0, best_diff = 0x0FFFFFFF;
+
+	/*
+	 * Due to unknown registers in HDMI PHY, we know correct settings
+	 * only for following four PHY dividers. Select one based on
+	 * clock speed.
+	 */
+	if (dotclock <= 27000)
+		x = 11;
+	else if (dotclock <= 74250)
+		x = 4;
+	else if (dotclock <= 148500)
+		x = 2;
+	else
+		x = 1;
+
+	/*
+	 * Find the lowest divider resulting in a matching clock. If there
+	 * is no match, pick the closest lower clock, as monitors tend to
+	 * not sync to higher frequencies.
+	 */
+	for (m = 1; m <= 16; m++) {
+		n = (m * x * dotclock) / 24000;
+
+		if ((n >= 1) && (n <= 128)) {
+			value = (24000 * n) / m / x;
+			diff = dotclock - value;
+			if (diff < best_diff) {
+				best_diff = diff;
+				best_m = m;
+				best_n = n;
+			}
+		}
+	}
+
+	clock_set_pll3_factors(best_m, best_n);
+	debug("dotclock: %dkHz = %dkHz: (24MHz * %d) / %d / %d\n",
+		dotclock, (clock_get_pll3() / 1000) / x,
+		best_n, best_m, x);
+
+	writel(CCM_TCON0_CTRL_GATE | CCM_TCON0_CTRL_M(x),
+	       &ccm->tcon0_clk_cfg);
+
+	*clk_div = x;
+}
+
+static void sunxi_lcdc_init(void)
+{
+	struct sunxi_ccm_reg * const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	struct sunxi_lcdc_reg * const lcdc =
+		(struct sunxi_lcdc_reg *)SUNXI_LCD0_BASE;
+
+	/* Reset off */
+	setbits_le32(&ccm->ahb_reset1_cfg, 1 << AHB_RESET_OFFSET_TCON0);
+
+	/* Clock on */
+	setbits_le32(&ccm->ahb_gate1, 1 << AHB_GATE_OFFSET_TCON0);
+	setbits_le32(&ccm->tcon0_clk_cfg, CCM_TCON0_CTRL_GATE);
+
+	/* Init lcdc */
+	writel(0, &lcdc->ctrl); /* Disable tcon */
+	writel(0, &lcdc->int0); /* Disable all interrupts */
+
+	/* Set all io lines to tristate */
+	writel(0x0fffffff, &lcdc->tcon1_io_tristate);
+}
+
+static void sunxi_lcdc_enable(void)
+{
+	struct sunxi_lcdc_reg * const lcdc =
+		(struct sunxi_lcdc_reg *)SUNXI_LCD0_BASE;
+
+	setbits_le32(&lcdc->ctrl, SUNXI_LCDC_CTRL_TCON_ENABLE);
+}
+
+static int sunxi_lcdc_get_clk_delay(const struct ctfb_res_modes *mode)
+{
+	int delay;
+
+	delay = mode->lower_margin + mode->vsync_len + mode->upper_margin;
+	if (mode->vmode == FB_VMODE_INTERLACED)
+		delay /= 2;
+	delay -= 2;
+
+	return (delay > 31) ? 31 : delay;
+}
+
+#if defined CONFIG_VIDEO_HDMI
+static void sunxi_lcdc_tcon1_mode_set(const struct ctfb_res_modes *mode,
+				      int *clk_div)
+{
+	struct sunxi_lcdc_reg * const lcdc =
+		(struct sunxi_lcdc_reg *)SUNXI_LCD0_BASE;
+	int bp, clk_delay, total, yres;
+
+	clk_delay = sunxi_lcdc_get_clk_delay(mode);
+	writel(SUNXI_LCDC_TCON1_CTRL_ENABLE |
+	       ((mode->vmode == FB_VMODE_INTERLACED) ?
+			SUNXI_LCDC_TCON1_CTRL_INTERLACE_ENABLE : 0) |
+	       SUNXI_LCDC_TCON1_CTRL_CLK_DELAY(clk_delay), &lcdc->tcon1_ctrl);
+
+	yres = mode->yres;
+	if (mode->vmode == FB_VMODE_INTERLACED)
+		yres /= 2;
+	writel(SUNXI_LCDC_X(mode->xres) | SUNXI_LCDC_Y(yres),
+	       &lcdc->tcon1_timing_source);
+	writel(SUNXI_LCDC_X(mode->xres) | SUNXI_LCDC_Y(yres),
+	       &lcdc->tcon1_timing_scale);
+	writel(SUNXI_LCDC_X(mode->xres) | SUNXI_LCDC_Y(yres),
+	       &lcdc->tcon1_timing_out);
+
+	bp = mode->hsync_len + mode->left_margin;
+	total = mode->xres + mode->right_margin + bp;
+	writel(SUNXI_LCDC_TCON1_TIMING_H_TOTAL(total) |
+	       SUNXI_LCDC_TCON1_TIMING_H_BP(bp), &lcdc->tcon1_timing_h);
+
+	bp = mode->vsync_len + mode->upper_margin;
+	total = mode->yres + mode->lower_margin + bp;
+	if (mode->vmode == FB_VMODE_NONINTERLACED)
+		total *= 2;
+	writel(SUNXI_LCDC_TCON1_TIMING_V_TOTAL(total) |
+	       SUNXI_LCDC_TCON1_TIMING_V_BP(bp), &lcdc->tcon1_timing_v);
+
+	writel(SUNXI_LCDC_X(mode->hsync_len) | SUNXI_LCDC_Y(mode->vsync_len),
+	       &lcdc->tcon1_timing_sync);
+
+	sunxi_lcdc_pll_set(mode->pixclock_khz, clk_div);
+}
+#endif /* CONFIG_VIDEO_HDMI */
+
+#ifdef CONFIG_VIDEO_HDMI
+
+static void sunxi_hdmi_setup_info_frames(const struct ctfb_res_modes *mode)
+{
+	u8 tmp;
+
+	if (mode->pixclock_khz <= 27000)
+		tmp = 0x40; /* SD-modes, ITU601 colorspace */
+	else
+		tmp = 0x80; /* HD-modes, ITU709 colorspace */
+
+	if (mode->xres * 100 / mode->yres < 156)
+		tmp |= 0x18;  /* 4 : 3 */
+	else
+		tmp |= 0x28; /* 16 : 9 */
+
+	setbits_8(SUNXI_HDMI_FC_INVIDCONF, 0x08);
+	writeb(0x60, SUNXI_HDMI_FC_AVICONF0);
+	writeb(tmp, SUNXI_HDMI_FC_AVICONF1);
+	writeb(0x88, SUNXI_HDMI_FC_AVICONF2);
+}
+
+static void sunxi_hdmi_phy_set(u32 divider)
+{
+	struct sunxi_phy_hdmi_reg * const phy =
+		(struct sunxi_phy_hdmi_reg *)SUNXI_HDMI_PHY_BASE;
+	u32 tmp;
+
+	/* 
+	 * Unfortunatelly, we don't know much about those magic
+	 * numbers. They are taken from Allwinner BSP driver.
+	 */
+	switch(divider) {
+	case 1:
+		writel(0x30dc5fc0, &phy->pll);
+		writel(0x800863C0, &phy->clk);
+		mdelay(10);
+		writel(0x00000001, &phy->unk3);
+		setbits_le32(&phy->pll, BIT(25));
+		mdelay(200);
+		tmp = (readl(&phy->status) & 0x1f800) >> 11;
+		setbits_le32(&phy->pll, BIT(31) | BIT(30));
+		if (tmp < 0x3d)
+			setbits_le32(&phy->pll, tmp + 2);
+		else
+			setbits_le32(&phy->pll, 0x3f);
+		mdelay(100);
+		writel(0x01FFFF7F, &phy->ctrl);
+		writel(0x8063b000, &phy->unk1);
+		writel(0x0F8246B5, &phy->unk2);
+		break;
+	case 2:
+		writel(0x39dc5040, &phy->pll);
+		writel(0x80084381, &phy->clk);
+		mdelay(10);
+		writel(0x00000001, &phy->unk3);
+		setbits_le32(&phy->pll, BIT(25));
+		mdelay(100);
+		tmp = (readl(&phy->status) & 0x1f800) >> 11;
+		setbits_le32(&phy->pll, BIT(31) | BIT(30));
+		setbits_le32(&phy->pll, tmp);
+		writel(0x01FFFF7F, &phy->ctrl);
+		writel(0x8063a800, &phy->unk1);
+		writel(0x0F81C485, &phy->unk2);
+		break;
+	case 4:
+		writel(0x39dc5040, &phy->pll);
+		writel(0x80084343, &phy->clk);
+		mdelay(10);
+		writel(0x00000001, &phy->unk3);
+		setbits_le32(&phy->pll, BIT(25));
+		mdelay(100);
+		tmp = (readl(&phy->status) & 0x1f800) >> 11;
+		setbits_le32(&phy->pll, BIT(31) | BIT(30));
+		setbits_le32(&phy->pll, tmp);
+		writel(0x01FFFF7F, &phy->ctrl);
+		writel(0x8063b000, &phy->unk1);
+		writel(0x0F81C405, &phy->unk2);
+		break;
+	case 11:
+		writel(0x39dc5040, &phy->pll);
+		writel(0x8008430a, &phy->clk);
+		mdelay(10);
+		writel(0x00000001, &phy->unk3);
+		setbits_le32(&phy->pll, BIT(25));
+		mdelay(100);
+		tmp = (readl(&phy->status) & 0x1f800) >> 11;
+		setbits_le32(&phy->pll, BIT(31) | BIT(30));
+		setbits_le32(&phy->pll, tmp);
+		writel(0x01FFFF7F, &phy->ctrl);
+		writel(0x8063b000, &phy->unk1);
+		writel(0x0F81C405, &phy->unk2);
+		break;
+	}
+}
+
+static void sunxi_hdmi_mode_set(const struct ctfb_res_modes *mode,
+				int clk_div)
+{
+	struct sunxi_phy_hdmi_reg * const phy =
+		(struct sunxi_phy_hdmi_reg *)SUNXI_HDMI_PHY_BASE;
+	u8 invidconf, v_blanking;
+	u32 h_blanking;
+
+	sunxi_hdmi_phy_set(clk_div);
+
+	invidconf = 0;
+	if(mode->vmode & FB_VMODE_INTERLACED)
+		invidconf |= 0x01;
+	if(mode->sync & FB_SYNC_HOR_HIGH_ACT)
+		invidconf |= 0x20;
+	if(mode->sync & FB_SYNC_VERT_HIGH_ACT)
+		invidconf |= 0x40;
+
+	h_blanking = mode->left_margin + mode->right_margin + mode->hsync_len;
+	v_blanking = mode->upper_margin + mode->lower_margin + mode->vsync_len;
+
+	writeb(invidconf | 0x10, SUNXI_HDMI_FC_INVIDCONF);
+	if (invidconf < 96)
+		setbits_le32(&phy->pol, 0x300);
+
+	writeb(mode->xres, SUNXI_HDMI_FC_INHACTV0);
+	writeb(mode->xres >> 8, SUNXI_HDMI_FC_INHACTV1);
+	writeb(mode->yres, SUNXI_HDMI_FC_INVACTV0);
+	writeb(mode->yres >> 8, SUNXI_HDMI_FC_INVACTV1);
+	writeb(mode->vsync_len, SUNXI_HDMI_FC_VSYNCINWIDTH);
+	writeb(h_blanking, SUNXI_HDMI_FC_INHBLANK0);
+	writeb(h_blanking >> 8, SUNXI_HDMI_FC_INHBLANK1);
+	writeb(mode->lower_margin, SUNXI_HDMI_FC_VSYNCINDELAY);
+	writeb(mode->right_margin, SUNXI_HDMI_FC_HSYNCINDELAY0);
+	writeb(mode->right_margin >> 8, SUNXI_HDMI_FC_HSYNCINDELAY1);
+	writeb(mode->hsync_len, SUNXI_HDMI_FC_HSYNCINWIDTH0);
+	writeb(mode->hsync_len >> 8, SUNXI_HDMI_FC_HSYNCINWIDTH1);
+	writeb(v_blanking, SUNXI_HDMI_FC_INVBLANK);
+
+	writeb(0x0c, SUNXI_HDMI_FC_CTRLDUR);
+	writeb(0x20, SUNXI_HDMI_FC_EXCTRLDUR);
+	writeb(0x01, SUNXI_HDMI_FC_EXCTRLSPAC);
+	writeb(0x0b, SUNXI_HDMI_FC_CH0PREAM);
+	writeb(0x16, SUNXI_HDMI_FC_CH1PREAM);
+	writeb(0x21, SUNXI_HDMI_FC_CH2PREAM);
+
+	writeb(0x40, SUNXI_HDMI_VP_PR_CD);
+	writeb(0x07, SUNXI_HDMI_VP_STUFF);
+
+	// default value, written 0 by rk_hdmi
+	writeb(0x00, SUNXI_HDMI_VP_REMAP);
+
+	writeb(0x47, SUNXI_HDMI_VP_CONF);
+	writeb(0x01, SUNXI_HDMI_TX_INVID0);
+	writeb(0x07, SUNXI_HDMI_TX_INSTUFFING);
+	writeb(0x00, SUNXI_HDMI_TX_GYDATA0);
+	writeb(0x00, SUNXI_HDMI_TX_GYDATA1);
+	writeb(0x00, SUNXI_HDMI_TX_RCRDATA0);
+	writeb(0x00, SUNXI_HDMI_TX_RCRDATA1);
+	writeb(0x00, SUNXI_HDMI_TX_BCBDATA0);
+	writeb(0x00, SUNXI_HDMI_TX_BCBDATA1);
+
+	if (sunxi_display.monitor == sunxi_monitor_hdmi)
+		sunxi_hdmi_setup_info_frames(mode);
+
+	writeb(0x00, SUNXI_HDMI_MC_FLOWCTRL);
+	writeb(0x74, SUNXI_HDMI_MC_CLKDIS);
+}
+
+static void sunxi_hdmi_enable(void)
+{
+	struct sunxi_phy_hdmi_reg * const phy =
+		(struct sunxi_phy_hdmi_reg *)SUNXI_HDMI_PHY_BASE;
+
+	setbits_le32(&phy->ctrl, 0xf << 12);
+	printf("hdmi enabled\n");
+}
+
+#endif /* CONFIG_VIDEO_HDMI */
+ 
+static void sunxi_engines_init(void)
+{
+	sunxi_composer_init();
+	sunxi_lcdc_init();
+}
+ 
+static void sunxi_mode_set(const struct ctfb_res_modes *mode,
+			   unsigned int address)
+{
+	int __maybe_unused clk_div;
+
+	switch (sunxi_display.monitor) {
+	case sunxi_monitor_none:
+		break;
+	case sunxi_monitor_dvi:
+	case sunxi_monitor_hdmi:
+#ifdef CONFIG_VIDEO_HDMI
+		sunxi_composer_mode_set(mode, address);
+		sunxi_lcdc_tcon1_mode_set(mode, &clk_div);
+		sunxi_hdmi_mode_set(mode, clk_div);
+		sunxi_composer_enable();
+		sunxi_lcdc_enable();
+		sunxi_hdmi_enable();
+#endif
+		break;
+	}
+}
+
+static const char *sunxi_get_mon_desc(enum sunxi_monitor monitor)
+{
+	switch (monitor) {
+	case sunxi_monitor_none:	return "none";
+	case sunxi_monitor_dvi:		return "dvi";
+	case sunxi_monitor_hdmi:	return "hdmi";
+	}
+	return NULL; /* never reached */
+}
+
+ulong board_get_usable_ram_top(ulong total_size)
+{
+	return gd->ram_top - CONFIG_SUNXI_MAX_FB_SIZE;
+}
+
+static bool sunxi_has_hdmi(void)
+{
+#ifdef CONFIG_VIDEO_HDMI
+	return true;
+#else
+	return false;
+#endif
+}
+
+static enum sunxi_monitor sunxi_get_default_mon(bool allow_hdmi)
+{
+	if (allow_hdmi && sunxi_has_hdmi())
+		return sunxi_monitor_dvi;
+	else
+		return sunxi_monitor_none;
+}
+
+void *video_hw_init(void)
+{
+	static GraphicDevice *graphic_device = &sunxi_display.graphic_device;
+	const struct ctfb_res_modes *mode;
+	struct ctfb_res_modes custom;
+	const char *options;
+#ifdef CONFIG_VIDEO_HDMI
+	int ret, hpd, hpd_delay, edid;
+#endif
+	int i, overscan_offset, overscan_x, overscan_y;
+	unsigned int fb_dma_addr;
+	char mon[16];
+
+	memset(&sunxi_display, 0, sizeof(struct sunxi_display));
+
+	video_get_ctfb_res_modes(RES_MODE_1024x768, 24, &mode,
+				 &sunxi_display.depth, &options);
+#ifdef CONFIG_VIDEO_HDMI
+	hpd = video_get_option_int(options, "hpd", 1);
+	hpd_delay = video_get_option_int(options, "hpd_delay", 500);
+	edid = video_get_option_int(options, "edid", 1);
+#endif
+	overscan_x = video_get_option_int(options, "overscan_x", -1);
+	overscan_y = video_get_option_int(options, "overscan_y", -1);
+	sunxi_display.monitor = sunxi_get_default_mon(true);
+	video_get_option_string(options, "monitor", mon, sizeof(mon),
+				sunxi_get_mon_desc(sunxi_display.monitor));
+	for (i = 0; i <= SUNXI_MONITOR_LAST; i++) {
+		if (strcmp(mon, sunxi_get_mon_desc(i)) == 0) {
+			sunxi_display.monitor = i;
+			break;
+		}
+	}
+	if (i > SUNXI_MONITOR_LAST)
+		printf("Unknown monitor: '%s', falling back to '%s'\n",
+		       mon, sunxi_get_mon_desc(sunxi_display.monitor));
+
+#ifdef CONFIG_VIDEO_HDMI
+	/* If HDMI/DVI is selected do HPD & EDID, and handle fallback */
+	if (sunxi_display.monitor == sunxi_monitor_dvi ||
+	    sunxi_display.monitor == sunxi_monitor_hdmi) {
+		/* Always call hdp_detect, as it also enables clocks, etc. */
+		ret = sunxi_hdmi_hpd_detect(hpd_delay);
+		if (ret) {
+			printf("HDMI connected: ");
+			if (edid && sunxi_hdmi_edid_get_mode(&custom) == 0)
+				mode = &custom;
+		} else if (hpd) {
+			sunxi_hdmi_shutdown();
+			sunxi_display.monitor = sunxi_get_default_mon(false);
+		} /* else continue with hdmi/dvi without a cable connected */
+	}
+#endif
+
+	switch (sunxi_display.monitor) {
+	case sunxi_monitor_none:
+		return NULL;
+	case sunxi_monitor_dvi:
+	case sunxi_monitor_hdmi:
+		if (!sunxi_has_hdmi()) {
+			printf("HDMI/DVI not supported on this board\n");
+			sunxi_display.monitor = sunxi_monitor_none;
+			return NULL;
+		}
+		break;
+	}
+
+	if (overscan_x == -1)
+		overscan_x = 0;
+	if (overscan_y == -1)
+		overscan_y = 0;
+
+	sunxi_display.fb_size =
+		(mode->xres * mode->yres * 4 + 0xfff) & ~0xfff;
+	overscan_offset = (overscan_y * mode->xres + overscan_x) * 4;
+	/* We want to keep the fb_base for simplefb page aligned, where as
+	 * the sunxi dma engines will happily accept an unaligned address. */
+	if (overscan_offset)
+		sunxi_display.fb_size += 0x1000;
+
+	if (sunxi_display.fb_size > CONFIG_SUNXI_MAX_FB_SIZE) {
+		printf("Error need %dkB for fb, but only %dkB is reserved\n",
+		       sunxi_display.fb_size >> 10,
+		       CONFIG_SUNXI_MAX_FB_SIZE >> 10);
+		return NULL;
+	}
+
+	printf("Setting up a %dx%d%s %s console (overscan %dx%d)\n",
+	       mode->xres, mode->yres,
+	       (mode->vmode == FB_VMODE_INTERLACED) ? "i" : "",
+	       sunxi_get_mon_desc(sunxi_display.monitor),
+	       overscan_x, overscan_y);
+
+	gd->fb_base = (unsigned long)memalign(0x1000, sunxi_display.fb_size);
+	sunxi_engines_init();
+
+	fb_dma_addr = gd->fb_base;
+	sunxi_display.fb_addr = gd->fb_base;
+	if (overscan_offset) {
+		fb_dma_addr += 0x1000 - (overscan_offset & 0xfff);
+		sunxi_display.fb_addr += (overscan_offset + 0xfff) & ~0xfff;
+		memset((void *)gd->fb_base, 0, sunxi_display.fb_size);
+		flush_cache(gd->fb_base, sunxi_display.fb_size);
+	}
+	sunxi_mode_set(mode, fb_dma_addr);
+
+	/*
+	 * These are the only members of this structure that are used. All the
+	 * others are driver specific. The pitch is stored in plnSizeX.
+	 */
+	graphic_device->frameAdrs = sunxi_display.fb_addr;
+	graphic_device->gdfIndex = GDF_32BIT_X888RGB;
+	graphic_device->gdfBytesPP = 4;
+	graphic_device->winSizeX = mode->xres - 2 * overscan_x;
+	graphic_device->winSizeY = mode->yres - 2 * overscan_y;
+	graphic_device->plnSizeX = mode->xres * graphic_device->gdfBytesPP;
+
+	return graphic_device;
+}
+
+/*
+ * Simplefb support.
+ */
+#if defined(CONFIG_OF_BOARD_SETUP) && defined(CONFIG_VIDEO_DT_SIMPLEFB)
+int sunxi_simplefb_setup(void *blob)
+{
+	static GraphicDevice *graphic_device = &sunxi_display.graphic_device;
+	int offset, ret;
+	u64 start, size;
+	const char *pipeline = NULL;
+
+	switch (sunxi_display.monitor) {
+	case sunxi_monitor_none:
+		return 0;
+	case sunxi_monitor_dvi:
+	case sunxi_monitor_hdmi:
+		pipeline = "de0-lcd0-hdmi";
+		break;
+	}
+
+	/* Find a prefilled simpefb node, matching out pipeline config */
+	offset = fdt_node_offset_by_compatible(blob, -1,
+					       "allwinner,simple-framebuffer");
+	while (offset >= 0) {
+		ret = fdt_stringlist_search(blob, offset, "allwinner,pipeline",
+					    pipeline);
+		if (ret == 0)
+			break;
+		offset = fdt_node_offset_by_compatible(blob, offset,
+					       "allwinner,simple-framebuffer");
+	}
+	if (offset < 0) {
+		eprintf("Cannot setup simplefb: node not found\n");
+		return 0; /* Keep older kernels working */
+	}
+
+	/*
+	 * Do not report the framebuffer as free RAM to the OS, note we cannot
+	 * use fdt_add_mem_rsv() here, because then it is still seen as RAM,
+	 * and e.g. Linux refuses to iomap RAM on ARM, see:
+	 * linux/arch/arm/mm/ioremap.c around line 301.
+	 */
+	start = gd->bd->bi_dram[0].start;
+	size = gd->bd->bi_dram[0].size - sunxi_display.fb_size;
+	ret = fdt_fixup_memory_banks(blob, &start, &size, 1);
+	if (ret) {
+		eprintf("Cannot setup simplefb: Error reserving memory\n");
+		return ret;
+	}
+
+	ret = fdt_setup_simplefb_node(blob, offset, sunxi_display.fb_addr,
+			graphic_device->winSizeX, graphic_device->winSizeY,
+			graphic_device->plnSizeX, "x8r8g8b8");
+	if (ret)
+		eprintf("Cannot setup simplefb: Error setting properties\n");
+
+	return ret;
+}
+#endif /* CONFIG_OF_BOARD_SETUP && CONFIG_VIDEO_DT_SIMPLEFB */
diff --git a/include/configs/sun8i.h b/include/configs/sun8i.h
index 011d70f..c4eb3ba 100644
--- a/include/configs/sun8i.h
+++ b/include/configs/sun8i.h
@@ -26,6 +26,10 @@
 	#define CONFIG_SUNXI_USB_PHYS	2
 #endif
 
+#if defined(CONFIG_MACH_SUN8I_H3)
+	#define CONFIG_SUNXI_DE2	1
+#endif
+
 /*
  * Include common sunxi configuration where most the settings are
  */
diff --git a/include/configs/sunxi-common.h b/include/configs/sunxi-common.h
--- a/include/configs/sunxi-common.h
+++ b/include/configs/sunxi-common.h
@@ -277,16 +277,23 @@ extern int soft_i2c_gpio_scl;
 #define CONFIG_SUNXI_GPIO
 
 #ifdef CONFIG_VIDEO
+/* Do we want to initialize a simple FB? */
+#define CONFIG_VIDEO_DT_SIMPLEFB
+#ifndef CONFIG_MACH_SUN8I_H3
+#define CONFIG_VIDEO_SUNXI
+#else
+#define CONFIG_VIDEO_SUNXI2
+#endif
+
 /*
  * The amount of RAM to keep free at the top of RAM when relocating u-boot,
  * to use as framebuffer. This must be a multiple of 4096.
  */
+#ifndef CONFIG_VIDEO_SUNXI2
 #define CONFIG_SUNXI_MAX_FB_SIZE (16 << 20)
-
-/* Do we want to initialize a simple FB? */
-#define CONFIG_VIDEO_DT_SIMPLEFB
-
-#define CONFIG_VIDEO_SUNXI
+#else
+#define CONFIG_SUNXI_MAX_FB_SIZE (32 << 20)
+#endif
 
 #define CONFIG_VIDEO_LOGO
 #define CONFIG_VIDEO_STD_TIMINGS
diff --git a/scripts/config_whitelist.txt b/scripts/config_whitelist.txt
--- a/scripts/config_whitelist.txt
+++ b/scripts/config_whitelist.txt
@@ -4357,6 +4357,7 @@ CONFIG_ST_SMI
 CONFIG_SUN4
 CONFIG_SUNXI
 CONFIG_SUNXI_AHCI
+CONFIG_SUNXI_DE2
 CONFIG_SUNXI_EMAC
 CONFIG_SUNXI_GMAC
 CONFIG_SUNXI_GPIO
@@ -8270,6 +8271,7 @@ CONFIG_VIDEO_SM501_8BPP
 CONFIG_VIDEO_SM501_PCI
 CONFIG_VIDEO_STD_TIMINGS
 CONFIG_VIDEO_SUNXI
+CONFIG_VIDEO_SUNXI2
 CONFIG_VIDEO_VCXK
 CONFIG_VID_FLS_ENV
 CONFIG_VM86
