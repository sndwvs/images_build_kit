source: https://github.com/CamberLoid/xr829

---

diff -Naurp a/drivers/net/wireless/xr829/Kconfig b/drivers/net/wireless/xr829/Kconfig
--- a/drivers/net/wireless/xr829/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/Kconfig	2022-08-27 01:22:42.898539650 +0300
@@ -0,0 +1,9 @@
+config XR829_WLAN
+	tristate "XR829 WLAN support"
+	default m
+	select CFG80211
+	select AVERAGE
+	select CRYPTO
+	select CRYPTO_ARC4
+	---help---
+	  To compile this code as a module, choose M here.
diff -Naurp a/drivers/net/wireless/xr829/LICENSE b/drivers/net/wireless/xr829/LICENSE
--- a/drivers/net/wireless/xr829/LICENSE	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/LICENSE	2022-08-27 01:22:42.902539665 +0300
@@ -0,0 +1,339 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+                            NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
diff -Naurp a/drivers/net/wireless/xr829/Makefile b/drivers/net/wireless/xr829/Makefile
--- a/drivers/net/wireless/xr829/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/Makefile	2022-08-27 01:22:42.902539665 +0300
@@ -0,0 +1,223 @@
+CONFIG_XR829_WLAN = m
+
+##################### XRADIO Wi-Fi Config #######################
+
+# DEBUGFS is not available since kernel behaviour fs/debugfs/file.c is changed
+# which will not return any value (void).
+# CONFIG_{XRADIO,XRMAC}_DEBUGFS will be set to n
+
+CONFIG_XRMAC_RC_DEFAULT = "minstrel_ht"
+CONFIG_XRMAC_RC_PID = n
+CONFIG_XRMAC_RC_MINSTREL = y
+CONFIG_XRMAC_RC_MINSTREL_HT = y
+CONFIG_XRMAC_DEBUGFS = n
+CONFIG_XRADIO_SDIO = y
+CONFIG_XRADIO_NON_POWER_OF_TWO_BLOCKSIZES = y
+CONFIG_XRADIO_USE_GPIO_IRQ = y
+CONFIG_XRADIO_SUSPEND_POWER_OFF = n
+CONFIG_XRADIO_EXTEND_SUSPEND = n
+CONFIG_XRADIO_NOMAL_SUSPEND_FORCE = n
+CONFIG_XRADIO_DEBUG = y
+CONFIG_XRADIO_ETF = y
+CONFIG_XRADIO_DUMP_ON_ERROR = n
+CONFIG_XRADIO_DEBUGFS = n
+CONFIG_XRADIO_VERBOSE_DEBUG = y
+CONFIG_XRADIO_DRIVER_API_TRACER = y
+CONFIG_MODULE_NAME = xr829
+
+define boolen_flag
+$(strip $(if $(findstring $($(1)),$(2)),-D$(1)))
+endef
+
+define string_flag
+$(strip $(if $($(1)),-D$(1)=\"$($(1))\"))
+endef
+
+DRV_FLAGS += $(call string_flag,CONFIG_XRMAC_RC_DEFAULT)
+DRV_FLAGS += $(call boolen_flag,CONFIG_XRMAC_RC_PID,y)
+DRV_FLAGS += $(call boolen_flag,CONFIG_XRMAC_RC_MINSTREL,y)
+DRV_FLAGS += $(call boolen_flag,CONFIG_XRMAC_RC_MINSTREL_HT,y)
+DRV_FLAGS += $(call boolen_flag,CONFIG_XRMAC_DEBUGFS,y)
+DRV_FLAGS += $(call boolen_flag,CONFIG_XRADIO_SDIO,y)
+DRV_FLAGS += $(call boolen_flag,CONFIG_XRADIO_NON_POWER_OF_TWO_BLOCKSIZES,y)
+DRV_FLAGS += $(call boolen_flag,CONFIG_XRADIO_USE_GPIO_IRQ,y)
+DRV_FLAGS += $(call boolen_flag,CONFIG_XRADIO_SUSPEND_POWER_OFF,y)
+DRV_FLAGS += $(call boolen_flag,CONFIG_XRADIO_EXTEND_SUSPEND,y)
+DRV_FLAGS += $(call boolen_flag,CONFIG_XRADIO_NOMAL_SUSPEND_FORCE,y)
+DRV_FLAGS += $(call boolen_flag,CONFIG_XRADIO_DEBUG,y)
+DRV_FLAGS += $(call boolen_flag,CONFIG_XRADIO_ETF,y)
+DRV_FLAGS += $(call boolen_flag,CONFIG_XRADIO_DUMP_ON_ERROR,y)
+DRV_FLAGS += $(call boolen_flag,CONFIG_XRADIO_DEBUGFS,y)
+
+ccflags-y += $(DRV_FLAGS)
+
+NOSTDINC_FLAGS := -I$(srctree)/$(src)/include/
+NOSTDINC_FLAGS += -I$(src)/include/
+
+ldflags-y += --strip-debug
+
+# xradio_mac objects
+xradio_mac-y := \
+	umac/main.o \
+	umac/status.o \
+	umac/sta_info.o \
+	umac/wep.o \
+	umac/wpa.o \
+	umac/wapi.o \
+	umac/scan.o \
+	umac/offchannel.o \
+	umac/ht.o \
+	umac/agg-tx.o \
+	umac/agg-rx.o \
+	umac/ibss.o \
+	umac/mlme.o \
+	umac/work.o \
+	umac/iface.o \
+	umac/rate.o \
+	umac/michael.o \
+	umac/tkip.o \
+	umac/aes_ccm.o \
+	umac/aes_cmac.o \
+	umac/cfg.o \
+	umac/rx.o \
+	umac/spectmgmt.o \
+	umac/tx.o \
+	umac/key.o \
+	umac/util.o \
+	umac/wme.o \
+	umac/event.o \
+	umac/average.o \
+	umac/chan.o
+
+xradio_mac-$(CONFIG_XRMAC_LEDS) += umac/led.o
+xradio_mac-$(CONFIG_XRMAC_DEBUGFS) += \
+	umac/debugfs.o \
+	umac/debugfs_sta.o \
+	umac/debugfs_netdev.o \
+	umac/debugfs_key.o
+
+xradio_mac-$(CONFIG_XRMAC_MESH) += \
+	umac/mesh.o \
+	umac/mesh_pathtbl.o \
+	umac/mesh_plink.o \
+	umac/mesh_hwmp.o
+
+xradio_mac-$(CONFIG_PM) += umac/pm.o
+
+xradio_mac-$(CONFIG_XRMAC_DRIVER_API_TRACER) += umac/driver-trace.o
+CFLAGS_driver-trace.o := -I$(src)
+
+# objects for PID algorithm
+rc80211_pid-y := umac/rc80211_pid_algo.o
+rc80211_pid-$(CONFIG_XRMAC_DEBUGFS) += umac/rc80211_pid_debugfs.o
+
+rc80211_minstrel-y := umac/rc80211_minstrel.o
+rc80211_minstrel-$(CONFIG_XRMAC_DEBUGFS) += umac/rc80211_minstrel_debugfs.o
+
+rc80211_minstrel_ht-y := umac/rc80211_minstrel_ht.o
+rc80211_minstrel_ht-$(CONFIG_XRMAC_DEBUGFS) += umac/rc80211_minstrel_ht_debugfs.o
+
+xradio_mac-$(CONFIG_XRMAC_RC_PID) += $(rc80211_pid-y)
+xradio_mac-$(CONFIG_XRMAC_RC_MINSTREL) += $(rc80211_minstrel-y)
+xradio_mac-$(CONFIG_XRMAC_RC_MINSTREL_HT) += $(rc80211_minstrel_ht-y)
+
+ccflags-y += -D__CHECK_ENDIAN__
+# Extra IE for probe response from upper layer is needed in P2P GO
+# For offloading probe response to FW, the extra IE must be included
+# in the probe response template
+ccflags-y += -DPROBE_RESP_EXTRA_IE
+ccflags-y += -DIPV6_FILTERING
+#ccflags-y += -DCONFIG_XRMAC_XR_ROAMING_CHANGES
+ccflags-y += -DUSE_RSSI_SMOOTH
+
+#This is use for old p2p mode, say yes to add P2P0 interface
+#ccflags-y += -DOLD_P2P_MODE
+
+######## xradio_core objects ########
+xradio_core-y := \
+	wlan/fwio.o \
+	wlan/txrx.o \
+	wlan/vendor.o \
+	wlan/main.o \
+	wlan/queue.o \
+	wlan/hwio.o \
+	wlan/bh.o \
+	wlan/wsm.o \
+	wlan/sta.o \
+	wlan/ap.o \
+	wlan/scan.o \
+	wlan/platform.o
+
+xradio_core-$(CONFIG_PM)            += wlan/pm.o
+xradio_core-$(CONFIG_XRADIO_SDIO)   += wlan/sdio.o
+xradio_core-$(CONFIG_XRADIO_DEBUG)  += wlan/debug.o
+xradio_core-$(CONFIG_XRADIO_ITP)    += wlan/itp.o
+xradio_core-$(CONFIG_XRADIO_ETF)    += wlan/etf.o
+
+$(CONFIG_MODULE_NAME)-y := $(xradio_mac-y)
+$(CONFIG_MODULE_NAME)-y += $(xradio_core-y)
+$(CONFIG_MODULE_NAME)-y += wlan/wlan_init.o
+
+obj-$(CONFIG_XR829_WLAN) += $(CONFIG_MODULE_NAME).o
+
+##=======  User Options =======
+## Mac addr config, disable hex for default.
+#ccflags-y += -DXRADIO_MACPARAM_HEX
+ccflags-y += -DMONITOR_MODE
+
+##======= Follows just for xradio internal, Don't change these macro if not ensure. =======
+ccflags-y += -DCONFIG_XRADIO_USE_EXTENSIONS
+ccflags-y += -DP2P_MULTIVIF
+ccflags-y += -DMCAST_FWDING
+ccflags-y += -DXRADIO_SUSPEND_RESUME_FILTER_ENABLE
+ccflags-y += -DAP_AGGREGATE_FW_FIX
+ccflags-y += -DAP_HT_CAP_UPDATE
+ccflags-y += -DAP_HT_COMPAT_FIX
+#ccflags-y += -DAP_ARP_COMPAT_FIX
+ccflags-y += -DENHANCE_ANTI_INTERFERE
+#ccflags-y += -DUSE_RSSI_OFFSET
+ccflags-y += -DSCAN_FAILED_WORKAROUND_OF_FW_EXCEPTION
+ccflags-y += -DHW_RESTART
+ccflags-y += -DHW_ERROR_WIFI_RESET
+
+## Use semaphore to sync bh txrx.
+#ccflags-y += -DBH_USE_SEMAPHORE
+ccflags-y += -DBH_PROC_THREAD
+ccflags-y += -DBH_COMINGRX_FORECAST
+#ccflags-y += -H
+
+# Modified for power save.
+#ccflags-y += -DXRADIO_USE_LONG_DTIM_PERIOD
+ccflags-y += -DXRADIO_USE_LONG_KEEP_ALIVE_PERIOD
+
+## Extra IE for probe response from upper layer is needed in P2P GO
+## For offloading probe response to FW, the extra IE must be included
+## in the probe response template
+ccflags-y += -DPROBE_RESP_EXTRA_IE
+ccflags-y += -DIPV6_FILTERING
+
+## Modified for P2P stability.
+ccflags-y += -DTES_P2P_0002_ROC_RESTART
+ccflags-y += -DTES_P2P_000B_EXTEND_INACTIVITY_CNT
+ccflags-y += -DTES_P2P_000B_DISABLE_EAPOL_FILTER
+
+## for chips.
+ccflags-y += -DSUPPORT_HT40
+ccflags-y += -DSUPPORT_EPTA
+ccflags-y += -DSUPPORT_DPLL_CHECK
+#ccflags-y += -DSUPPORT_NON_HT40_CHIP
+ccflags-y += -DBOOT_NOT_READY_FIX
+
+## for interal debug.
+#ccflags-y += -DSUPPORT_FW_DBG_INF
+#ccflags-y += -DERROR_HANG_DRIVER
+
+# Debug for hwx_BUG12:P2P setting crash
+ccflags-y += -DDEBUG_P2P_SETTING_CRASH
+
+EXTRA_CFLAGS += -Wno-error=date-time
+EXTRA_CFLAGS +=-Wno-date-time
+
+ccflags-y += -Wno-implicit-function-declaration
+
+clean-files += Module.symvers Module.markers modules modules.order
diff -Naurp a/drivers/net/wireless/xr829/include/crypto/aes.h b/drivers/net/wireless/xr829/include/crypto/aes.h
--- a/drivers/net/wireless/xr829/include/crypto/aes.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/crypto/aes.h	2022-08-27 01:22:42.902539665 +0300
@@ -0,0 +1,21 @@
+#ifndef _COMPAT_CRYPTO_AES_H
+#define _COMPAT_CRYPTO_AES_H
+
+#include <generated/uapi/linux/version.h>
+
+#if (KERNEL_VERSION(2, 6, 24) < LINUX_VERSION_CODE)
+#include_next <crypto/aes.h>
+#else
+
+#define AES_MIN_KEY_SIZE	16
+#define AES_MAX_KEY_SIZE	32
+#define AES_KEYSIZE_128		16
+#define AES_KEYSIZE_192		24
+#define AES_KEYSIZE_256		32
+#define AES_BLOCK_SIZE		16
+#define AES_MAX_KEYLENGTH	(15 * 16)
+#define AES_MAX_KEYLENGTH_U32	(AES_MAX_KEYLENGTH / sizeof(u32))
+
+#endif /* (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 24)) */
+
+#endif
diff -Naurp a/drivers/net/wireless/xr829/include/linux/atomic.h b/drivers/net/wireless/xr829/include/linux/atomic.h
--- a/drivers/net/wireless/xr829/include/linux/atomic.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/atomic.h	2022-08-27 01:22:42.902539665 +0300
@@ -0,0 +1,46 @@
+#ifndef _COMPAT_LINUX_ATOMIC_H
+#define _COMPAT_LINUX_ATOMIC_H 1
+
+#include <generated/uapi/linux/version.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 36))
+#include_next <linux/atomic.h>
+#else
+
+#include <asm/atomic.h>
+
+/**
+ * atomic_inc_not_zero_hint - increment if not null
+ * @v: pointer of type atomic_t
+ * @hint: probable value of the atomic before the increment
+ *
+ * This version of atomic_inc_not_zero() gives a hint of probable
+ * value of the atomic. This helps processor to not read the memory
+ * before doing the atomic read/modify/write cycle, lowering
+ * number of bus transactions on some arches.
+ *
+ * Returns: 0 if increment was not done, 1 otherwise.
+ */
+#ifndef atomic_inc_not_zero_hint
+static inline int atomic_inc_not_zero_hint(atomic_t *v, int hint)
+{
+	int val, c = hint;
+
+	/* sanity test, should be removed by compiler if hint is a constant */
+	if (!hint)
+		return atomic_inc_not_zero(v);
+
+	do {
+		val = atomic_cmpxchg(v, c, c + 1);
+		if (val == c)
+			return 1;
+		c = val;
+	} while (c);
+
+	return 0;
+}
+#endif
+
+#endif /* (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 36)) */
+
+#endif	/* _COMPAT_LINUX_ATOMIC_H */
diff -Naurp a/drivers/net/wireless/xr829/include/linux/average.h b/drivers/net/wireless/xr829/include/linux/average.h
--- a/drivers/net/wireless/xr829/include/linux/average.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/average.h	2022-08-27 01:22:42.902539665 +0300
@@ -0,0 +1,30 @@
+#ifndef _LINUX_AVERAGE_H
+#define _LINUX_AVERAGE_H
+
+/* Exponentially weighted moving average (EWMA) */
+
+/* For more documentation see lib/average.c */
+
+struct ewma {
+	unsigned long internal;
+	unsigned long factor;
+	unsigned long weight;
+};
+
+extern void ewma_init(struct ewma *avg, unsigned long factor,
+		      unsigned long weight);
+
+extern struct ewma *ewma_add(struct ewma *avg, unsigned long val);
+
+/**
+ * ewma_read() - Get average value
+ * @avg: Average structure
+ *
+ * Returns the average value held in @avg.
+ */
+static inline unsigned long ewma_read(const struct ewma *avg)
+{
+	return avg->internal >> avg->factor;
+}
+
+#endif /* _LINUX_AVERAGE_H */
diff -Naurp a/drivers/net/wireless/xr829/include/linux/bitops.h b/drivers/net/wireless/xr829/include/linux/bitops.h
--- a/drivers/net/wireless/xr829/include/linux/bitops.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/bitops.h	2022-08-27 01:22:42.902539665 +0300
@@ -0,0 +1,213 @@
+#ifndef _LINUX_BITOPS_H
+#define _LINUX_BITOPS_H
+#include <asm/types.h>
+#include <linux/bits.h>
+
+/* Set bits in the first 'n' bytes when loaded from memory */
+#ifdef __LITTLE_ENDIAN
+#  define aligned_byte_mask(n) ((1UL << 8*(n))-1)
+#else
+#  define aligned_byte_mask(n) (~0xffUL << (BITS_PER_LONG - 8 - 8*(n)))
+#endif
+
+#define BITS_PER_TYPE(type) (sizeof(type) * BITS_PER_BYTE)
+#define BITS_TO_LONGS(nr)	DIV_ROUND_UP(nr, BITS_PER_TYPE(long))
+
+extern unsigned int __sw_hweight8(unsigned int w);
+extern unsigned int __sw_hweight16(unsigned int w);
+extern unsigned int __sw_hweight32(unsigned int w);
+extern unsigned long __sw_hweight64(__u64 w);
+
+/*
+ * Include this here because some architectures need generic_ffs/fls in
+ * scope
+ */
+#include <asm/bitops.h>
+
+#define for_each_set_bit(bit, addr, size) \
+	for ((bit) = find_first_bit((addr), (size)); \
+	     (bit) < (size); \
+	     (bit) = find_next_bit((addr), (size), (bit) + 1))
+
+static __inline__ int get_bitmask_order(unsigned int count)
+{
+	int order;
+
+	order = fls(count);
+	return order;	/* We could be slightly more clever with -1 here... */
+}
+
+static __inline__ int get_count_order(unsigned int count)
+{
+	int order;
+
+	order = fls(count) - 1;
+	if (count & (count - 1))
+		order++;
+	return order;
+}
+
+static inline unsigned long hweight_long(unsigned long w)
+{
+	return sizeof(w) == 4 ? hweight32(w) : hweight64(w);
+}
+
+/**
+ * rol32 - rotate a 32-bit value left
+ * @word: value to rotate
+ * @shift: bits to roll
+ */
+static inline __u32 rol32(__u32 word, unsigned int shift)
+{
+	return (word << shift) | (word >> (32 - shift));
+}
+
+/**
+ * ror32 - rotate a 32-bit value right
+ * @word: value to rotate
+ * @shift: bits to roll
+ */
+static inline __u32 ror32(__u32 word, unsigned int shift)
+{
+	return (word >> shift) | (word << (32 - shift));
+}
+
+/**
+ * rol16 - rotate a 16-bit value left
+ * @word: value to rotate
+ * @shift: bits to roll
+ */
+static inline __u16 rol16(__u16 word, unsigned int shift)
+{
+	return (word << shift) | (word >> (16 - shift));
+}
+
+/**
+ * ror16 - rotate a 16-bit value right
+ * @word: value to rotate
+ * @shift: bits to roll
+ */
+static inline __u16 ror16(__u16 word, unsigned int shift)
+{
+	return (word >> shift) | (word << (16 - shift));
+}
+
+/**
+ * rol8 - rotate an 8-bit value left
+ * @word: value to rotate
+ * @shift: bits to roll
+ */
+static inline __u8 rol8(__u8 word, unsigned int shift)
+{
+	return (word << shift) | (word >> (8 - shift));
+}
+
+/**
+ * ror8 - rotate an 8-bit value right
+ * @word: value to rotate
+ * @shift: bits to roll
+ */
+static inline __u8 ror8(__u8 word, unsigned int shift)
+{
+	return (word >> shift) | (word << (8 - shift));
+}
+
+/**
+ * sign_extend32 - sign extend a 32-bit value using specified bit as sign-bit
+ * @value: value to sign extend
+ * @index: 0 based bit index (0<=index<32) to sign bit
+ */
+static inline __s32 sign_extend32(__u32 value, int index)
+{
+	__u8 shift = 31 - index;
+	return (__s32)(value << shift) >> shift;
+}
+
+/**
+ * sign_extend64 - sign extend a 64-bit value using specified bit as sign-bit
+ * @value: value to sign extend
+ * @index: 0 based bit index (0<=index<64) to sign bit
+ */
+static inline __s64 sign_extend64(__u64 value, int index)
+{
+		__u8 shift = 63 - index;
+			return (__s64)(value << shift) >> shift;
+}
+
+static inline unsigned fls_long(unsigned long l)
+{
+	if (sizeof(l) == 4)
+		return fls(l);
+	return fls64(l);
+}
+
+/**
+ * __ffs64 - find first set bit in a 64 bit word
+ * @word: The 64 bit word
+ *
+ * On 64 bit arches this is a synomyn for __ffs
+ * The result is not defined if no bits are set, so check that @word
+ * is non-zero before calling this.
+ */
+static inline unsigned long __ffs64(u64 word)
+{
+#if BITS_PER_LONG == 32
+	if (((u32)word) == 0UL)
+		return __ffs((u32)(word >> 32)) + 32;
+#elif BITS_PER_LONG != 64
+#error BITS_PER_LONG not 32 or 64
+#endif
+	return __ffs((unsigned long)word);
+}
+
+#ifdef __KERNEL__
+#ifdef CONFIG_GENERIC_FIND_FIRST_BIT
+
+/**
+ * find_first_bit - find the first set bit in a memory region
+ * @addr: The address to start the search at
+ * @size: The maximum size to search
+ *
+ * Returns the bit number of the first set bit.
+ */
+extern unsigned long find_first_bit(const unsigned long *addr,
+				    unsigned long size);
+
+/**
+ * find_first_zero_bit - find the first cleared bit in a memory region
+ * @addr: The address to start the search at
+ * @size: The maximum size to search
+ *
+ * Returns the bit number of the first cleared bit.
+ */
+extern unsigned long find_first_zero_bit(const unsigned long *addr,
+					 unsigned long size);
+#endif /* CONFIG_GENERIC_FIND_FIRST_BIT */
+
+
+
+#ifdef CONFIG_GENERIC_FIND_NEXT_BIT
+
+/**
+ * find_next_bit - find the next set bit in a memory region
+ * @addr: The address to base the search on
+ * @offset: The bitnumber to start searching at
+ * @size: The bitmap size in bits
+ */
+extern unsigned long find_next_bit(const unsigned long *addr,
+				   unsigned long size, unsigned long offset);
+
+/**
+ * find_next_zero_bit - find the next cleared bit in a memory region
+ * @addr: The address to base the search on
+ * @offset: The bitnumber to start searching at
+ * @size: The bitmap size in bits
+ */
+
+extern unsigned long find_next_zero_bit(const unsigned long *addr,
+					unsigned long size,
+					unsigned long offset);
+
+#endif /* CONFIG_GENERIC_FIND_NEXT_BIT */
+#endif /* __KERNEL__ */
+#endif
diff -Naurp a/drivers/net/wireless/xr829/include/linux/cordic.h b/drivers/net/wireless/xr829/include/linux/cordic.h
--- a/drivers/net/wireless/xr829/include/linux/cordic.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/cordic.h	2022-08-27 01:22:42.906539680 +0300
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2011 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef __CORDIC_H_
+#define __CORDIC_H_
+
+#include <linux/types.h>
+
+/**
+ * struct cordic_iq - i/q coordinate.
+ *
+ * @i: real part of coordinate (in phase).
+ * @q: imaginary part of coordinate (quadrature).
+ */
+struct cordic_iq {
+	s32 i;
+	s32 q;
+};
+
+/**
+ * cordic_calc_iq() - calculates the i/q coordinate for given angle.
+ *
+ * @theta: angle in degrees for which i/q coordinate is to be calculated.
+ * @coord: function output parameter holding the i/q coordinate.
+ *
+ * The function calculates the i/q coordinate for a given angle using the
+ * CORDIC algorithm. The coordinate consists of a real (i) and an
+ * imaginary (q) part. The real part is essentially the cosine of the
+ * angle and the imaginary part is the sine of the angle. The returned
+ * values are scaled by 2^16 for precision. The range for theta is
+ * for -180 degrees to +180 degrees. Passed values outside this range are
+ * converted before doing the actual calculation.
+ */
+struct cordic_iq cordic_calc_iq(s32 theta);
+
+#endif /* __CORDIC_H_ */
diff -Naurp a/drivers/net/wireless/xr829/include/linux/crc8.h b/drivers/net/wireless/xr829/include/linux/crc8.h
--- a/drivers/net/wireless/xr829/include/linux/crc8.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/crc8.h	2022-08-27 01:22:42.906539680 +0300
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 2011 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef __CRC8_H_
+#define __CRC8_H_
+
+#include <linux/types.h>
+
+/* see usage of this value in crc8() description */
+#define CRC8_INIT_VALUE		0xFF
+
+/*
+ * Return value of crc8() indicating valid message+crc. This is true
+ * if a CRC is inverted before transmission. The CRC computed over the
+ * whole received bitstream is _table[x], where x is the bit pattern
+ * of the modification (almost always 0xff).
+ */
+#define CRC8_GOOD_VALUE(_table)	(_table[0xFF])
+
+/* required table size for crc8 algorithm */
+#define CRC8_TABLE_SIZE			256
+
+/* helper macro assuring right table size is used */
+#define DECLARE_CRC8_TABLE(_table) \
+	static u8 _table[CRC8_TABLE_SIZE]
+
+/**
+ * crc8_populate_lsb - fill crc table for given polynomial in regular bit order.
+ *
+ * @table:	table to be filled.
+ * @polynomial:	polynomial for which table is to be filled.
+ *
+ * This function fills the provided table according the polynomial provided for
+ * regular bit order (lsb first). Polynomials in CRC algorithms are typically
+ * represented as shown below.
+ *
+ *	poly = x^8 + x^7 + x^6 + x^4 + x^2 + 1
+ *
+ * For lsb first direction x^7 maps to the lsb. So the polynomial is as below.
+ *
+ * - lsb first: poly = 10101011(1) = 0xAB
+ */
+void crc8_populate_lsb(u8 table[CRC8_TABLE_SIZE], u8 polynomial);
+
+/**
+ * crc8_populate_msb - fill crc table for given polynomial in reverse bit order.
+ *
+ * @table:	table to be filled.
+ * @polynomial:	polynomial for which table is to be filled.
+ *
+ * This function fills the provided table according the polynomial provided for
+ * reverse bit order (msb first). Polynomials in CRC algorithms are typically
+ * represented as shown below.
+ *
+ *	poly = x^8 + x^7 + x^6 + x^4 + x^2 + 1
+ *
+ * For msb first direction x^7 maps to the msb. So the polynomial is as below.
+ *
+ * - msb first: poly = (1)11010101 = 0xD5
+ */
+void crc8_populate_msb(u8 table[CRC8_TABLE_SIZE], u8 polynomial);
+
+/**
+ * crc8() - calculate a crc8 over the given input data.
+ *
+ * @table:	crc table used for calculation.
+ * @pdata:	pointer to data buffer.
+ * @nbytes:	number of bytes in data buffer.
+ * @crc:	previous returned crc8 value.
+ *
+ * The CRC8 is calculated using the polynomial given in crc8_populate_msb()
+ * or crc8_populate_lsb().
+ *
+ * The caller provides the initial value (either %CRC8_INIT_VALUE
+ * or the previous returned value) to allow for processing of
+ * discontiguous blocks of data.  When generating the CRC the
+ * caller is responsible for complementing the final return value
+ * and inserting it into the byte stream.  When validating a byte
+ * stream (including CRC8), a final return value of %CRC8_GOOD_VALUE
+ * indicates the byte stream data can be considered valid.
+ *
+ * Reference:
+ * "A Painless Guide to CRC Error Detection Algorithms", ver 3, Aug 1993
+ * Williams, Ross N., ross<at>ross.net
+ * (see URL http://www.ross.net/crc/download/crc_v3.txt).
+ */
+u8 crc8(const u8 table[CRC8_TABLE_SIZE], u8 *pdata, size_t nbytes, u8 crc);
+
+#endif /* __CRC8_H_ */
diff -Naurp a/drivers/net/wireless/xr829/include/linux/export.h b/drivers/net/wireless/xr829/include/linux/export.h
--- a/drivers/net/wireless/xr829/include/linux/export.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/export.h	2022-08-27 01:22:42.906539680 +0300
@@ -0,0 +1,12 @@
+#ifndef _COMPAT_LINUX_EXPORT_H
+#define _COMPAT_LINUX_EXPORT_H 1
+
+#include <generated/uapi/linux/version.h>
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
+#include_next <linux/export.h>
+#else
+#include <linux/module.h>
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)) */
+
+#endif	/* _COMPAT_LINUX_EXPORT_H */
diff -Naurp a/drivers/net/wireless/xr829/include/linux/ieee80211.h b/drivers/net/wireless/xr829/include/linux/ieee80211.h
--- a/drivers/net/wireless/xr829/include/linux/ieee80211.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/ieee80211.h	2022-08-27 01:22:42.906539680 +0300
@@ -0,0 +1,3523 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * IEEE 802.11 defines
+ *
+ * Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen
+ * <jkmaline@cc.hut.fi>
+ * Copyright (c) 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
+ * Copyright (c) 2005, Devicescape Software, Inc.
+ * Copyright (c) 2006, Michael Wu <flamingice@sourmilk.net>
+ * Copyright (c) 2013 - 2014 Intel Mobile Communications GmbH
+ * Copyright (c) 2016 - 2017 Intel Deutschland GmbH
+ * Copyright (c) 2018 - 2019 Intel Corporation
+ */
+
+#ifndef LINUX_IEEE80211_H
+#define LINUX_IEEE80211_H
+
+#include <linux/types.h>
+#include <linux/if_ether.h>
+#include <linux/etherdevice.h>
+#include <asm/byteorder.h>
+#include <asm/unaligned.h>
+
+/*
+ * DS bit usage
+ *
+ * TA = transmitter address
+ * RA = receiver address
+ * DA = destination address
+ * SA = source address
+ *
+ * ToDS    FromDS  A1(RA)  A2(TA)  A3      A4      Use
+ * -----------------------------------------------------------------
+ *  0       0       DA      SA      BSSID   -       IBSS/DLS
+ *  0       1       DA      BSSID   SA      -       AP -> STA
+ *  1       0       BSSID   SA      DA      -       AP <- STA
+ *  1       1       RA      TA      DA      SA      unspecified (WDS)
+ */
+
+#define FCS_LEN 4
+
+#define IEEE80211_FCTL_VERS		0x0003
+#define IEEE80211_FCTL_FTYPE		0x000c
+#define IEEE80211_FCTL_STYPE		0x00f0
+#define IEEE80211_FCTL_TODS		0x0100
+#define IEEE80211_FCTL_FROMDS		0x0200
+#define IEEE80211_FCTL_MOREFRAGS	0x0400
+#define IEEE80211_FCTL_RETRY		0x0800
+#define IEEE80211_FCTL_PM		0x1000
+#define IEEE80211_FCTL_MOREDATA		0x2000
+#define IEEE80211_FCTL_PROTECTED	0x4000
+#define IEEE80211_FCTL_ORDER		0x8000
+#define IEEE80211_FCTL_CTL_EXT		0x0f00
+
+#define IEEE80211_SCTL_FRAG		0x000F
+#define IEEE80211_SCTL_SEQ		0xFFF0
+
+#define IEEE80211_FTYPE_MGMT		0x0000
+#define IEEE80211_FTYPE_CTL		0x0004
+#define IEEE80211_FTYPE_DATA		0x0008
+#define IEEE80211_FTYPE_EXT		0x000c
+
+/* management */
+#define IEEE80211_STYPE_ASSOC_REQ	0x0000
+#define IEEE80211_STYPE_ASSOC_RESP	0x0010
+#define IEEE80211_STYPE_REASSOC_REQ	0x0020
+#define IEEE80211_STYPE_REASSOC_RESP	0x0030
+#define IEEE80211_STYPE_PROBE_REQ	0x0040
+#define IEEE80211_STYPE_PROBE_RESP	0x0050
+#define IEEE80211_STYPE_BEACON		0x0080
+#define IEEE80211_STYPE_ATIM		0x0090
+#define IEEE80211_STYPE_DISASSOC	0x00A0
+#define IEEE80211_STYPE_AUTH		0x00B0
+#define IEEE80211_STYPE_DEAUTH		0x00C0
+#define IEEE80211_STYPE_ACTION		0x00D0
+
+/* control */
+#define IEEE80211_STYPE_CTL_EXT		0x0060
+#define IEEE80211_STYPE_BACK_REQ	0x0080
+#define IEEE80211_STYPE_BACK		0x0090
+#define IEEE80211_STYPE_PSPOLL		0x00A0
+#define IEEE80211_STYPE_RTS		0x00B0
+#define IEEE80211_STYPE_CTS		0x00C0
+#define IEEE80211_STYPE_ACK		0x00D0
+#define IEEE80211_STYPE_CFEND		0x00E0
+#define IEEE80211_STYPE_CFENDACK	0x00F0
+
+/* data */
+#define IEEE80211_STYPE_DATA			0x0000
+#define IEEE80211_STYPE_DATA_CFACK		0x0010
+#define IEEE80211_STYPE_DATA_CFPOLL		0x0020
+#define IEEE80211_STYPE_DATA_CFACKPOLL		0x0030
+#define IEEE80211_STYPE_NULLFUNC		0x0040
+#define IEEE80211_STYPE_CFACK			0x0050
+#define IEEE80211_STYPE_CFPOLL			0x0060
+#define IEEE80211_STYPE_CFACKPOLL		0x0070
+#define IEEE80211_STYPE_QOS_DATA		0x0080
+#define IEEE80211_STYPE_QOS_DATA_CFACK		0x0090
+#define IEEE80211_STYPE_QOS_DATA_CFPOLL		0x00A0
+#define IEEE80211_STYPE_QOS_DATA_CFACKPOLL	0x00B0
+#define IEEE80211_STYPE_QOS_NULLFUNC		0x00C0
+#define IEEE80211_STYPE_QOS_CFACK		0x00D0
+#define IEEE80211_STYPE_QOS_CFPOLL		0x00E0
+#define IEEE80211_STYPE_QOS_CFACKPOLL		0x00F0
+
+/* extension, added by 802.11ad */
+#define IEEE80211_STYPE_DMG_BEACON		0x0000
+
+/* control extension - for IEEE80211_FTYPE_CTL | IEEE80211_STYPE_CTL_EXT */
+#define IEEE80211_CTL_EXT_POLL		0x2000
+#define IEEE80211_CTL_EXT_SPR		0x3000
+#define IEEE80211_CTL_EXT_GRANT	0x4000
+#define IEEE80211_CTL_EXT_DMG_CTS	0x5000
+#define IEEE80211_CTL_EXT_DMG_DTS	0x6000
+#define IEEE80211_CTL_EXT_SSW		0x8000
+#define IEEE80211_CTL_EXT_SSW_FBACK	0x9000
+#define IEEE80211_CTL_EXT_SSW_ACK	0xa000
+
+
+#define IEEE80211_SN_MASK		((IEEE80211_SCTL_SEQ) >> 4)
+#define IEEE80211_MAX_SN		IEEE80211_SN_MASK
+#define IEEE80211_SN_MODULO		(IEEE80211_MAX_SN + 1)
+
+static inline bool ieee80211_sn_less(u16 sn1, u16 sn2)
+{
+	return ((sn1 - sn2) & IEEE80211_SN_MASK) > (IEEE80211_SN_MODULO >> 1);
+}
+
+static inline u16 ieee80211_sn_add(u16 sn1, u16 sn2)
+{
+	return (sn1 + sn2) & IEEE80211_SN_MASK;
+}
+
+static inline u16 ieee80211_sn_inc(u16 sn)
+{
+	return ieee80211_sn_add(sn, 1);
+}
+
+static inline u16 ieee80211_sn_sub(u16 sn1, u16 sn2)
+{
+	return (sn1 - sn2) & IEEE80211_SN_MASK;
+}
+
+#define IEEE80211_SEQ_TO_SN(seq)	(((seq) & IEEE80211_SCTL_SEQ) >> 4)
+#define IEEE80211_SN_TO_SEQ(ssn)	(((ssn) << 4) & IEEE80211_SCTL_SEQ)
+
+/* miscellaneous IEEE 802.11 constants */
+#define IEEE80211_MAX_FRAG_THRESHOLD	2352
+#define IEEE80211_MAX_RTS_THRESHOLD	2353
+#define IEEE80211_MAX_AID		2007
+#define IEEE80211_MAX_TIM_LEN		251
+#define IEEE80211_MAX_MESH_PEERINGS	63
+/* Maximum size for the MA-UNITDATA primitive, 802.11 standard section
+   6.2.1.1.2.
+
+   802.11e clarifies the figure in section 7.1.2. The frame body is
+   up to 2304 octets long (maximum MSDU size) plus any crypt overhead. */
+#define IEEE80211_MAX_DATA_LEN		2304
+/* 802.11ad extends maximum MSDU size for DMG (freq > 40Ghz) networks
+ * to 7920 bytes, see 8.2.3 General frame format
+ */
+#define IEEE80211_MAX_DATA_LEN_DMG	7920
+/* 30 byte 4 addr hdr, 2 byte QoS, 2304 byte MSDU, 12 byte crypt, 4 byte FCS */
+#define IEEE80211_MAX_FRAME_LEN		2352
+
+/* Maximal size of an A-MSDU that can be transported in a HT BA session */
+#define IEEE80211_MAX_MPDU_LEN_HT_BA		4095
+
+/* Maximal size of an A-MSDU */
+#define IEEE80211_MAX_MPDU_LEN_HT_3839		3839
+#define IEEE80211_MAX_MPDU_LEN_HT_7935		7935
+
+#define IEEE80211_MAX_MPDU_LEN_VHT_3895		3895
+#define IEEE80211_MAX_MPDU_LEN_VHT_7991		7991
+#define IEEE80211_MAX_MPDU_LEN_VHT_11454	11454
+
+#define IEEE80211_MAX_SSID_LEN		32
+
+#define IEEE80211_MAX_MESH_ID_LEN	32
+
+#define IEEE80211_FIRST_TSPEC_TSID	8
+#define IEEE80211_NUM_TIDS		16
+
+/* number of user priorities 802.11 uses */
+#define IEEE80211_NUM_UPS		8
+/* number of ACs */
+#define IEEE80211_NUM_ACS		4
+
+#define IEEE80211_QOS_CTL_LEN		2
+/* 1d tag mask */
+#define IEEE80211_QOS_CTL_TAG1D_MASK		0x0007
+/* TID mask */
+#define IEEE80211_QOS_CTL_TID_MASK		0x000f
+/* EOSP */
+#define IEEE80211_QOS_CTL_EOSP			0x0010
+/* ACK policy */
+#define IEEE80211_QOS_CTL_ACK_POLICY_NORMAL	0x0000
+#define IEEE80211_QOS_CTL_ACK_POLICY_NOACK	0x0020
+#define IEEE80211_QOS_CTL_ACK_POLICY_NO_EXPL	0x0040
+#define IEEE80211_QOS_CTL_ACK_POLICY_BLOCKACK	0x0060
+#define IEEE80211_QOS_CTL_ACK_POLICY_MASK	0x0060
+/* A-MSDU 802.11n */
+#define IEEE80211_QOS_CTL_A_MSDU_PRESENT	0x0080
+/* Mesh Control 802.11s */
+#define IEEE80211_QOS_CTL_MESH_CONTROL_PRESENT  0x0100
+
+/* Mesh Power Save Level */
+#define IEEE80211_QOS_CTL_MESH_PS_LEVEL		0x0200
+/* Mesh Receiver Service Period Initiated */
+#define IEEE80211_QOS_CTL_RSPI			0x0400
+
+/* U-APSD queue for WMM IEs sent by AP */
+#define IEEE80211_WMM_IE_AP_QOSINFO_UAPSD	(1<<7)
+#define IEEE80211_WMM_IE_AP_QOSINFO_PARAM_SET_CNT_MASK	0x0f
+
+/* U-APSD queues for WMM IEs sent by STA */
+#define IEEE80211_WMM_IE_STA_QOSINFO_AC_VO	(1<<0)
+#define IEEE80211_WMM_IE_STA_QOSINFO_AC_VI	(1<<1)
+#define IEEE80211_WMM_IE_STA_QOSINFO_AC_BK	(1<<2)
+#define IEEE80211_WMM_IE_STA_QOSINFO_AC_BE	(1<<3)
+#define IEEE80211_WMM_IE_STA_QOSINFO_AC_MASK	0x0f
+
+/* U-APSD max SP length for WMM IEs sent by STA */
+#define IEEE80211_WMM_IE_STA_QOSINFO_SP_ALL	0x00
+#define IEEE80211_WMM_IE_STA_QOSINFO_SP_2	0x01
+#define IEEE80211_WMM_IE_STA_QOSINFO_SP_4	0x02
+#define IEEE80211_WMM_IE_STA_QOSINFO_SP_6	0x03
+#define IEEE80211_WMM_IE_STA_QOSINFO_SP_MASK	0x03
+#define IEEE80211_WMM_IE_STA_QOSINFO_SP_SHIFT	5
+
+#define IEEE80211_HT_CTL_LEN		4
+
+struct ieee80211_hdr {
+	__le16 frame_control;
+	__le16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	__le16 seq_ctrl;
+	u8 addr4[ETH_ALEN];
+} __packed __aligned(2);
+
+struct ieee80211_hdr_3addr {
+	__le16 frame_control;
+	__le16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	__le16 seq_ctrl;
+} __packed __aligned(2);
+
+struct ieee80211_qos_hdr {
+	__le16 frame_control;
+	__le16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	__le16 seq_ctrl;
+	__le16 qos_ctrl;
+} __packed __aligned(2);
+
+/**
+ * compare_ether_addr - Compare two Ethernet addresses
+ * @addr1: Pointer to a six-byte array containing the Ethernet address
+ * @addr2: Pointer other six-byte array containing the Ethernet address
+ *
+ * Compare two Ethernet addresses, returns 0 if equal, non-zero otherwise.
+ * Unlike memcmp(), it doesn't return a value suitable for sorting.
+ */
+static inline unsigned compare_ether_addr(const u8 *addr1, const u8 *addr2)
+{
+	const u16 *a = (const u16 *) addr1;
+	const u16 *b = (const u16 *) addr2;
+
+	return ((a[0] ^ b[0]) | (a[1] ^ b[1]) | (a[2] ^ b[2])) != 0;
+}
+
+/**
+ * ieee80211_has_tods - check if IEEE80211_FCTL_TODS is set
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_has_tods(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_TODS)) != 0;
+}
+
+/**
+ * ieee80211_has_fromds - check if IEEE80211_FCTL_FROMDS is set
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_has_fromds(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FROMDS)) != 0;
+}
+
+/**
+ * ieee80211_has_a4 - check if IEEE80211_FCTL_TODS and IEEE80211_FCTL_FROMDS are set
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_has_a4(__le16 fc)
+{
+	__le16 tmp = cpu_to_le16(IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS);
+	return (fc & tmp) == tmp;
+}
+
+/**
+ * ieee80211_has_morefrags - check if IEEE80211_FCTL_MOREFRAGS is set
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_has_morefrags(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_MOREFRAGS)) != 0;
+}
+
+/**
+ * ieee80211_has_retry - check if IEEE80211_FCTL_RETRY is set
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_has_retry(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_RETRY)) != 0;
+}
+
+/**
+ * ieee80211_has_pm - check if IEEE80211_FCTL_PM is set
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_has_pm(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_PM)) != 0;
+}
+
+/**
+ * ieee80211_has_moredata - check if IEEE80211_FCTL_MOREDATA is set
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_has_moredata(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_MOREDATA)) != 0;
+}
+
+/**
+ * ieee80211_has_protected - check if IEEE80211_FCTL_PROTECTED is set
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_has_protected(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_PROTECTED)) != 0;
+}
+
+/**
+ * ieee80211_has_order - check if IEEE80211_FCTL_ORDER is set
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_has_order(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_ORDER)) != 0;
+}
+
+/**
+ * ieee80211_is_mgmt - check if type is IEEE80211_FTYPE_MGMT
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_mgmt(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_MGMT);
+}
+
+/**
+ * ieee80211_is_ctl - check if type is IEEE80211_FTYPE_CTL
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_ctl(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_CTL);
+}
+
+/**
+ * ieee80211_is_data - check if type is IEEE80211_FTYPE_DATA
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_data(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_DATA);
+}
+
+/**
+ * ieee80211_is_data_qos - check if type is IEEE80211_FTYPE_DATA and IEEE80211_STYPE_QOS_DATA is set
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_data_qos(__le16 fc)
+{
+	/*
+	 * mask with QOS_DATA rather than IEEE80211_FCTL_STYPE as we just need
+	 * to check the one bit
+	 */
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_STYPE_QOS_DATA)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_DATA | IEEE80211_STYPE_QOS_DATA);
+}
+
+/**
+ * ieee80211_is_data_present - check if type is IEEE80211_FTYPE_DATA and has data
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_data_present(__le16 fc)
+{
+	/*
+	 * mask with 0x40 and test that that bit is clear to only return true
+	 * for the data-containing substypes.
+	 */
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE | 0x40)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_DATA);
+}
+
+/**
+ * ieee80211_is_assoc_req - check if IEEE80211_FTYPE_MGMT && IEEE80211_STYPE_ASSOC_REQ
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_assoc_req(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_ASSOC_REQ);
+}
+
+/**
+ * ieee80211_is_assoc_resp - check if IEEE80211_FTYPE_MGMT && IEEE80211_STYPE_ASSOC_RESP
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_assoc_resp(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_ASSOC_RESP);
+}
+
+/**
+ * ieee80211_is_reassoc_req - check if IEEE80211_FTYPE_MGMT && IEEE80211_STYPE_REASSOC_REQ
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_reassoc_req(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_REASSOC_REQ);
+}
+
+/**
+ * ieee80211_is_reassoc_resp - check if IEEE80211_FTYPE_MGMT && IEEE80211_STYPE_REASSOC_RESP
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_reassoc_resp(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_REASSOC_RESP);
+}
+
+/**
+ * ieee80211_is_probe_req - check if IEEE80211_FTYPE_MGMT && IEEE80211_STYPE_PROBE_REQ
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_probe_req(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_PROBE_REQ);
+}
+
+/**
+ * ieee80211_is_probe_resp - check if IEEE80211_FTYPE_MGMT && IEEE80211_STYPE_PROBE_RESP
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_probe_resp(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_PROBE_RESP);
+}
+
+/**
+ * ieee80211_is_beacon - check if IEEE80211_FTYPE_MGMT && IEEE80211_STYPE_BEACON
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_beacon(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_BEACON);
+}
+
+/**
+ * ieee80211_is_atim - check if IEEE80211_FTYPE_MGMT && IEEE80211_STYPE_ATIM
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_atim(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_ATIM);
+}
+
+/**
+ * ieee80211_is_disassoc - check if IEEE80211_FTYPE_MGMT && IEEE80211_STYPE_DISASSOC
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_disassoc(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_DISASSOC);
+}
+
+/**
+ * ieee80211_is_auth - check if IEEE80211_FTYPE_MGMT && IEEE80211_STYPE_AUTH
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_auth(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_AUTH);
+}
+
+/**
+ * ieee80211_is_deauth - check if IEEE80211_FTYPE_MGMT && IEEE80211_STYPE_DEAUTH
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_deauth(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_DEAUTH);
+}
+
+/**
+ * ieee80211_is_action - check if IEEE80211_FTYPE_MGMT && IEEE80211_STYPE_ACTION
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_action(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_ACTION);
+}
+
+/**
+ * ieee80211_is_back_req - check if IEEE80211_FTYPE_CTL && IEEE80211_STYPE_BACK_REQ
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_back_req(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_BACK_REQ);
+}
+
+/**
+ * ieee80211_is_back - check if IEEE80211_FTYPE_CTL && IEEE80211_STYPE_BACK
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_back(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_BACK);
+}
+
+/**
+ * ieee80211_is_pspoll - check if IEEE80211_FTYPE_CTL && IEEE80211_STYPE_PSPOLL
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_pspoll(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_PSPOLL);
+}
+
+/**
+ * ieee80211_is_rts - check if IEEE80211_FTYPE_CTL && IEEE80211_STYPE_RTS
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_rts(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_RTS);
+}
+
+/**
+ * ieee80211_is_cts - check if IEEE80211_FTYPE_CTL && IEEE80211_STYPE_CTS
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_cts(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_CTS);
+}
+
+/**
+ * ieee80211_is_ack - check if IEEE80211_FTYPE_CTL && IEEE80211_STYPE_ACK
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_ack(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_ACK);
+}
+
+/**
+ * ieee80211_is_cfend - check if IEEE80211_FTYPE_CTL && IEEE80211_STYPE_CFEND
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_cfend(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_CFEND);
+}
+
+/**
+ * ieee80211_is_cfendack - check if IEEE80211_FTYPE_CTL && IEEE80211_STYPE_CFENDACK
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_cfendack(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_CFENDACK);
+}
+
+/**
+ * ieee80211_is_nullfunc - check if frame is a regular (non-QoS) nullfunc frame
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_nullfunc(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_DATA | IEEE80211_STYPE_NULLFUNC);
+}
+
+/**
+ * ieee80211_is_qos_nullfunc - check if frame is a QoS nullfunc frame
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_qos_nullfunc(__le16 fc)
+{
+	return (fc & cpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) ==
+	       cpu_to_le16(IEEE80211_FTYPE_DATA | IEEE80211_STYPE_QOS_NULLFUNC);
+}
+
+/**
+ * ieee80211_is_any_nullfunc - check if frame is regular or QoS nullfunc frame
+ * @fc: frame control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_any_nullfunc(__le16 fc)
+{
+	return (ieee80211_is_nullfunc(fc) || ieee80211_is_qos_nullfunc(fc));
+}
+
+/**
+ * ieee80211_is_bufferable_mmpdu - check if frame is bufferable MMPDU
+ * @fc: frame control field in little-endian byteorder
+ */
+static inline bool ieee80211_is_bufferable_mmpdu(__le16 fc)
+{
+	/* IEEE 802.11-2012, definition of "bufferable management frame";
+	 * note that this ignores the IBSS special case. */
+	return ieee80211_is_mgmt(fc) &&
+	       (ieee80211_is_action(fc) ||
+		ieee80211_is_disassoc(fc) ||
+		ieee80211_is_deauth(fc));
+}
+
+/**
+ * ieee80211_is_first_frag - check if IEEE80211_SCTL_FRAG is not set
+ * @seq_ctrl: frame sequence control bytes in little-endian byteorder
+ */
+static inline bool ieee80211_is_first_frag(__le16 seq_ctrl)
+{
+	return (seq_ctrl & cpu_to_le16(IEEE80211_SCTL_FRAG)) == 0;
+}
+
+/**
+ * ieee80211_is_frag - check if a frame is a fragment
+ * @hdr: 802.11 header of the frame
+ */
+static inline bool ieee80211_is_frag(struct ieee80211_hdr *hdr)
+{
+	return ieee80211_has_morefrags(hdr->frame_control) ||
+	       hdr->seq_ctrl & cpu_to_le16(IEEE80211_SCTL_FRAG);
+}
+
+struct ieee80211s_hdr {
+	u8 flags;
+	u8 ttl;
+	__le32 seqnum;
+	u8 eaddr1[ETH_ALEN];
+	u8 eaddr2[ETH_ALEN];
+} __packed __aligned(2);
+
+/* Mesh flags */
+#define MESH_FLAGS_AE_A4 	0x1
+#define MESH_FLAGS_AE_A5_A6	0x2
+#define MESH_FLAGS_AE		0x3
+#define MESH_FLAGS_PS_DEEP	0x4
+
+/**
+ * enum ieee80211_preq_flags - mesh PREQ element flags
+ *
+ * @IEEE80211_PREQ_PROACTIVE_PREP_FLAG: proactive PREP subfield
+ */
+enum ieee80211_preq_flags {
+	IEEE80211_PREQ_PROACTIVE_PREP_FLAG	= 1<<2,
+};
+
+/**
+ * enum ieee80211_preq_target_flags - mesh PREQ element per target flags
+ *
+ * @IEEE80211_PREQ_TO_FLAG: target only subfield
+ * @IEEE80211_PREQ_USN_FLAG: unknown target HWMP sequence number subfield
+ */
+enum ieee80211_preq_target_flags {
+	IEEE80211_PREQ_TO_FLAG	= 1<<0,
+	IEEE80211_PREQ_USN_FLAG	= 1<<2,
+};
+
+/**
+ * struct ieee80211_quiet_ie
+ *
+ * This structure refers to "Quiet information element"
+ */
+struct ieee80211_quiet_ie {
+	u8 count;
+	u8 period;
+	__le16 duration;
+	__le16 offset;
+} __packed;
+
+/**
+ * struct ieee80211_msrment_ie
+ *
+ * This structure refers to "Measurement Request/Report information element"
+ */
+struct ieee80211_msrment_ie {
+	u8 token;
+	u8 mode;
+	u8 type;
+	u8 request[0];
+} __packed;
+
+/**
+ * struct ieee80211_channel_sw_ie
+ *
+ * This structure refers to "Channel Switch Announcement information element"
+ */
+struct ieee80211_channel_sw_ie {
+	u8 mode;
+	u8 new_ch_num;
+	u8 count;
+} __packed;
+
+/**
+ * struct ieee80211_ext_chansw_ie
+ *
+ * This structure represents the "Extended Channel Switch Announcement element"
+ */
+struct ieee80211_ext_chansw_ie {
+	u8 mode;
+	u8 new_operating_class;
+	u8 new_ch_num;
+	u8 count;
+} __packed;
+
+/**
+ * struct ieee80211_sec_chan_offs_ie - secondary channel offset IE
+ * @sec_chan_offs: secondary channel offset, uses IEEE80211_HT_PARAM_CHA_SEC_*
+ *	values here
+ * This structure represents the "Secondary Channel Offset element"
+ */
+struct ieee80211_sec_chan_offs_ie {
+	u8 sec_chan_offs;
+} __packed;
+
+/**
+ * struct ieee80211_mesh_chansw_params_ie - mesh channel switch parameters IE
+ *
+ * This structure represents the "Mesh Channel Switch Paramters element"
+ */
+struct ieee80211_mesh_chansw_params_ie {
+	u8 mesh_ttl;
+	u8 mesh_flags;
+	__le16 mesh_reason;
+	__le16 mesh_pre_value;
+} __packed;
+
+/**
+ * struct ieee80211_wide_bw_chansw_ie - wide bandwidth channel switch IE
+ */
+struct ieee80211_wide_bw_chansw_ie {
+	u8 new_channel_width;
+	u8 new_center_freq_seg0, new_center_freq_seg1;
+} __packed;
+
+/**
+ * struct ieee80211_tim
+ *
+ * This structure refers to "Traffic Indication Map information element"
+ */
+struct ieee80211_tim_ie {
+	u8 dtim_count;
+	u8 dtim_period;
+	u8 bitmap_ctrl;
+	/* variable size: 1 - 251 bytes */
+	u8 virtual_map[1];
+} __packed;
+
+/**
+ * struct ieee80211_meshconf_ie
+ *
+ * This structure refers to "Mesh Configuration information element"
+ */
+struct ieee80211_meshconf_ie {
+	u8 meshconf_psel;
+	u8 meshconf_pmetric;
+	u8 meshconf_congest;
+	u8 meshconf_synch;
+	u8 meshconf_auth;
+	u8 meshconf_form;
+	u8 meshconf_cap;
+} __packed;
+
+/**
+ * enum mesh_config_capab_flags - Mesh Configuration IE capability field flags
+ *
+ * @IEEE80211_MESHCONF_CAPAB_ACCEPT_PLINKS: STA is willing to establish
+ *	additional mesh peerings with other mesh STAs
+ * @IEEE80211_MESHCONF_CAPAB_FORWARDING: the STA forwards MSDUs
+ * @IEEE80211_MESHCONF_CAPAB_TBTT_ADJUSTING: TBTT adjustment procedure
+ *	is ongoing
+ * @IEEE80211_MESHCONF_CAPAB_POWER_SAVE_LEVEL: STA is in deep sleep mode or has
+ *	neighbors in deep sleep mode
+ */
+enum mesh_config_capab_flags {
+	IEEE80211_MESHCONF_CAPAB_ACCEPT_PLINKS		= 0x01,
+	IEEE80211_MESHCONF_CAPAB_FORWARDING		= 0x08,
+	IEEE80211_MESHCONF_CAPAB_TBTT_ADJUSTING		= 0x20,
+	IEEE80211_MESHCONF_CAPAB_POWER_SAVE_LEVEL	= 0x40,
+};
+
+#define IEEE80211_MESHCONF_FORM_CONNECTED_TO_GATE 0x1
+
+/**
+ * mesh channel switch parameters element's flag indicator
+ *
+ */
+#define WLAN_EID_CHAN_SWITCH_PARAM_TX_RESTRICT BIT(0)
+#define WLAN_EID_CHAN_SWITCH_PARAM_INITIATOR BIT(1)
+#define WLAN_EID_CHAN_SWITCH_PARAM_REASON BIT(2)
+
+/**
+ * struct ieee80211_rann_ie
+ *
+ * This structure refers to "Root Announcement information element"
+ */
+struct ieee80211_rann_ie {
+	u8 rann_flags;
+	u8 rann_hopcount;
+	u8 rann_ttl;
+	u8 rann_addr[ETH_ALEN];
+	__le32 rann_seq;
+	__le32 rann_interval;
+	__le32 rann_metric;
+} __packed;
+
+enum ieee80211_rann_flags {
+	RANN_FLAG_IS_GATE = 1 << 0,
+};
+
+enum ieee80211_ht_chanwidth_values {
+	IEEE80211_HT_CHANWIDTH_20MHZ = 0,
+	IEEE80211_HT_CHANWIDTH_ANY = 1,
+};
+
+/**
+ * enum ieee80211_opmode_bits - VHT operating mode field bits
+ * @IEEE80211_OPMODE_NOTIF_CHANWIDTH_MASK: channel width mask
+ * @IEEE80211_OPMODE_NOTIF_CHANWIDTH_20MHZ: 20 MHz channel width
+ * @IEEE80211_OPMODE_NOTIF_CHANWIDTH_40MHZ: 40 MHz channel width
+ * @IEEE80211_OPMODE_NOTIF_CHANWIDTH_80MHZ: 80 MHz channel width
+ * @IEEE80211_OPMODE_NOTIF_CHANWIDTH_160MHZ: 160 MHz or 80+80 MHz channel width
+ * @IEEE80211_OPMODE_NOTIF_RX_NSS_MASK: number of spatial streams mask
+ *	(the NSS value is the value of this field + 1)
+ * @IEEE80211_OPMODE_NOTIF_RX_NSS_SHIFT: number of spatial streams shift
+ * @IEEE80211_OPMODE_NOTIF_RX_NSS_TYPE_BF: indicates streams in SU-MIMO PPDU
+ *	using a beamforming steering matrix
+ */
+enum ieee80211_vht_opmode_bits {
+	IEEE80211_OPMODE_NOTIF_CHANWIDTH_MASK	= 3,
+	IEEE80211_OPMODE_NOTIF_CHANWIDTH_20MHZ	= 0,
+	IEEE80211_OPMODE_NOTIF_CHANWIDTH_40MHZ	= 1,
+	IEEE80211_OPMODE_NOTIF_CHANWIDTH_80MHZ	= 2,
+	IEEE80211_OPMODE_NOTIF_CHANWIDTH_160MHZ	= 3,
+	IEEE80211_OPMODE_NOTIF_RX_NSS_MASK	= 0x70,
+	IEEE80211_OPMODE_NOTIF_RX_NSS_SHIFT	= 4,
+	IEEE80211_OPMODE_NOTIF_RX_NSS_TYPE_BF	= 0x80,
+};
+
+#define WLAN_SA_QUERY_TR_ID_LEN 2
+#define WLAN_MEMBERSHIP_LEN 8
+#define WLAN_USER_POSITION_LEN 16
+
+/**
+ * struct ieee80211_tpc_report_ie
+ *
+ * This structure refers to "TPC Report element"
+ */
+struct ieee80211_tpc_report_ie {
+	u8 tx_power;
+	u8 link_margin;
+} __packed;
+
+#define IEEE80211_ADDBA_EXT_FRAG_LEVEL_MASK	GENMASK(2, 1)
+#define IEEE80211_ADDBA_EXT_FRAG_LEVEL_SHIFT	1
+#define IEEE80211_ADDBA_EXT_NO_FRAG		BIT(0)
+
+struct ieee80211_addba_ext_ie {
+	u8 data;
+} __packed;
+
+struct ieee80211_mgmt {
+	__le16 frame_control;
+	__le16 duration;
+	u8 da[ETH_ALEN];
+	u8 sa[ETH_ALEN];
+	u8 bssid[ETH_ALEN];
+	__le16 seq_ctrl;
+	union {
+		struct {
+			__le16 auth_alg;
+			__le16 auth_transaction;
+			__le16 status_code;
+			/* possibly followed by Challenge text */
+			u8 variable[0];
+		} __packed auth;
+		struct {
+			__le16 reason_code;
+		} __packed deauth;
+		struct {
+			__le16 capab_info;
+			__le16 listen_interval;
+			/* followed by SSID and Supported rates */
+			u8 variable[0];
+		} __packed assoc_req;
+		struct {
+			__le16 capab_info;
+			__le16 status_code;
+			__le16 aid;
+			/* followed by Supported rates */
+			u8 variable[0];
+		} __packed assoc_resp, reassoc_resp;
+		struct {
+			__le16 capab_info;
+			__le16 listen_interval;
+			u8 current_ap[ETH_ALEN];
+			/* followed by SSID and Supported rates */
+			u8 variable[0];
+		} __packed reassoc_req;
+		struct {
+			__le16 reason_code;
+		} __packed disassoc;
+		struct {
+			__le64 timestamp;
+			__le16 beacon_int;
+			__le16 capab_info;
+			/* followed by some of SSID, Supported rates,
+			 * FH Params, DS Params, CF Params, IBSS Params, TIM */
+			u8 variable[0];
+		} __packed beacon;
+		struct {
+			/* only variable items: SSID, Supported rates */
+			u8 variable[0];
+		} __packed probe_req;
+		struct {
+			__le64 timestamp;
+			__le16 beacon_int;
+			__le16 capab_info;
+			/* followed by some of SSID, Supported rates,
+			 * FH Params, DS Params, CF Params, IBSS Params */
+			u8 variable[0];
+		} __packed probe_resp;
+		struct {
+			u8 category;
+			union {
+				struct {
+					u8 action_code;
+					u8 dialog_token;
+					u8 status_code;
+					u8 variable[0];
+				} __packed wme_action;
+				struct{
+					u8 action_code;
+					u8 element_id;
+					u8 length;
+					struct ieee80211_channel_sw_ie sw_elem;
+					u8 variable[0];
+				} __packed chan_switch;
+				struct{
+					u8 action_code;
+					struct ieee80211_ext_chansw_ie data;
+					u8 variable[0];
+				} __packed ext_chan_switch;
+				struct{
+					u8 action_code;
+					u8 dialog_token;
+					u8 element_id;
+					u8 length;
+					struct ieee80211_msrment_ie msr_elem;
+				} __packed measurement;
+				struct{
+					u8 action_code;
+					u8 dialog_token;
+					__le16 capab;
+					__le16 timeout;
+					__le16 start_seq_num;
+					/* followed by BA Extension */
+					u8 variable[0];
+				} __packed addba_req;
+				struct{
+					u8 action_code;
+					u8 dialog_token;
+					__le16 status;
+					__le16 capab;
+					__le16 timeout;
+				} __packed addba_resp;
+				struct{
+					u8 action_code;
+					__le16 params;
+					__le16 reason_code;
+				} __packed delba;
+				struct {
+					u8 action_code;
+					u8 variable[0];
+				} __packed self_prot;
+				struct{
+					u8 action_code;
+					u8 variable[0];
+				} __packed mesh_action;
+				struct {
+					u8 action;
+					u8 trans_id[WLAN_SA_QUERY_TR_ID_LEN];
+				} __packed sa_query;
+				struct {
+					u8 action;
+					u8 smps_control;
+				} __packed ht_smps;
+				struct {
+					u8 action_code;
+					u8 chanwidth;
+				} __packed ht_notify_cw;
+				struct {
+					u8 action_code;
+					u8 dialog_token;
+					__le16 capability;
+					u8 variable[0];
+				} __packed tdls_discover_resp;
+				struct {
+					u8 action_code;
+					u8 operating_mode;
+				} __packed vht_opmode_notif;
+				struct {
+					u8 action_code;
+					u8 membership[WLAN_MEMBERSHIP_LEN];
+					u8 position[WLAN_USER_POSITION_LEN];
+				} __packed vht_group_notif;
+				struct {
+					u8 action_code;
+					u8 dialog_token;
+					u8 tpc_elem_id;
+					u8 tpc_elem_length;
+					struct ieee80211_tpc_report_ie tpc;
+				} __packed tpc_report;
+				struct {
+					u8 action_code;
+					u8 dialog_token;
+					u8 follow_up;
+					u8 tod[6];
+					u8 toa[6];
+					__le16 tod_error;
+					__le16 toa_error;
+					u8 variable[0];
+				} __packed ftm;
+			} u;
+		} __packed action;
+	} u;
+} __packed __aligned(2);
+
+/* Supported rates membership selectors */
+#define BSS_MEMBERSHIP_SELECTOR_HT_PHY	127
+#define BSS_MEMBERSHIP_SELECTOR_VHT_PHY	126
+
+/* mgmt header + 1 byte category code */
+#define IEEE80211_MIN_ACTION_SIZE offsetof(struct ieee80211_mgmt, u.action.u)
+
+
+/* Management MIC information element (IEEE 802.11w) */
+struct ieee80211_mmie {
+	u8 element_id;
+	u8 length;
+	__le16 key_id;
+	u8 sequence_number[6];
+	u8 mic[8];
+} __packed;
+
+/* Management MIC information element (IEEE 802.11w) for GMAC and CMAC-256 */
+struct ieee80211_mmie_16 {
+	u8 element_id;
+	u8 length;
+	__le16 key_id;
+	u8 sequence_number[6];
+	u8 mic[16];
+} __packed;
+
+struct ieee80211_vendor_ie {
+	u8 element_id;
+	u8 len;
+	u8 oui[3];
+	u8 oui_type;
+} __packed;
+
+struct ieee80211_wmm_ac_param {
+	u8 aci_aifsn; /* AIFSN, ACM, ACI */
+	u8 cw; /* ECWmin, ECWmax (CW = 2^ECW - 1) */
+	__le16 txop_limit;
+} __packed;
+
+struct ieee80211_wmm_param_ie {
+	u8 element_id; /* Element ID: 221 (0xdd); */
+	u8 len; /* Length: 24 */
+	/* required fields for WMM version 1 */
+	u8 oui[3]; /* 00:50:f2 */
+	u8 oui_type; /* 2 */
+	u8 oui_subtype; /* 1 */
+	u8 version; /* 1 for WMM version 1.0 */
+	u8 qos_info; /* AP/STA specific QoS info */
+	u8 reserved; /* 0 */
+	/* AC_BE, AC_BK, AC_VI, AC_VO */
+	struct ieee80211_wmm_ac_param ac[4];
+} __packed;
+
+/* Control frames */
+struct ieee80211_rts {
+	__le16 frame_control;
+	__le16 duration;
+	u8 ra[ETH_ALEN];
+	u8 ta[ETH_ALEN];
+} __packed __aligned(2);
+
+struct ieee80211_cts {
+	__le16 frame_control;
+	__le16 duration;
+	u8 ra[ETH_ALEN];
+} __packed __aligned(2);
+
+struct ieee80211_pspoll {
+	__le16 frame_control;
+	__le16 aid;
+	u8 bssid[ETH_ALEN];
+	u8 ta[ETH_ALEN];
+} __packed __aligned(2);
+
+/* TDLS */
+
+/* Channel switch timing */
+struct ieee80211_ch_switch_timing {
+	__le16 switch_time;
+	__le16 switch_timeout;
+} __packed;
+
+/* Link-id information element */
+struct ieee80211_tdls_lnkie {
+	u8 ie_type; /* Link Identifier IE */
+	u8 ie_len;
+	u8 bssid[ETH_ALEN];
+	u8 init_sta[ETH_ALEN];
+	u8 resp_sta[ETH_ALEN];
+} __packed;
+
+struct ieee80211_tdls_data {
+	u8 da[ETH_ALEN];
+	u8 sa[ETH_ALEN];
+	__be16 ether_type;
+	u8 payload_type;
+	u8 category;
+	u8 action_code;
+	union {
+		struct {
+			u8 dialog_token;
+			__le16 capability;
+			u8 variable[0];
+		} __packed setup_req;
+		struct {
+			__le16 status_code;
+			u8 dialog_token;
+			__le16 capability;
+			u8 variable[0];
+		} __packed setup_resp;
+		struct {
+			__le16 status_code;
+			u8 dialog_token;
+			u8 variable[0];
+		} __packed setup_cfm;
+		struct {
+			__le16 reason_code;
+			u8 variable[0];
+		} __packed teardown;
+		struct {
+			u8 dialog_token;
+			u8 variable[0];
+		} __packed discover_req;
+		struct {
+			u8 target_channel;
+			u8 oper_class;
+			u8 variable[0];
+		} __packed chan_switch_req;
+		struct {
+			__le16 status_code;
+			u8 variable[0];
+		} __packed chan_switch_resp;
+	} u;
+} __packed;
+
+/*
+ * Peer-to-Peer IE attribute related definitions.
+ */
+/**
+ * enum ieee80211_p2p_attr_id - identifies type of peer-to-peer attribute.
+ */
+enum ieee80211_p2p_attr_id {
+	IEEE80211_P2P_ATTR_STATUS = 0,
+	IEEE80211_P2P_ATTR_MINOR_REASON,
+	IEEE80211_P2P_ATTR_CAPABILITY,
+	IEEE80211_P2P_ATTR_DEVICE_ID,
+	IEEE80211_P2P_ATTR_GO_INTENT,
+	IEEE80211_P2P_ATTR_GO_CONFIG_TIMEOUT,
+	IEEE80211_P2P_ATTR_LISTEN_CHANNEL,
+	IEEE80211_P2P_ATTR_GROUP_BSSID,
+	IEEE80211_P2P_ATTR_EXT_LISTEN_TIMING,
+	IEEE80211_P2P_ATTR_INTENDED_IFACE_ADDR,
+	IEEE80211_P2P_ATTR_MANAGABILITY,
+	IEEE80211_P2P_ATTR_CHANNEL_LIST,
+	IEEE80211_P2P_ATTR_ABSENCE_NOTICE,
+	IEEE80211_P2P_ATTR_DEVICE_INFO,
+	IEEE80211_P2P_ATTR_GROUP_INFO,
+	IEEE80211_P2P_ATTR_GROUP_ID,
+	IEEE80211_P2P_ATTR_INTERFACE,
+	IEEE80211_P2P_ATTR_OPER_CHANNEL,
+	IEEE80211_P2P_ATTR_INVITE_FLAGS,
+	/* 19 - 220: Reserved */
+	IEEE80211_P2P_ATTR_VENDOR_SPECIFIC = 221,
+
+	IEEE80211_P2P_ATTR_MAX
+};
+
+/* Notice of Absence attribute - described in P2P spec 4.1.14 */
+/* Typical max value used here */
+#define IEEE80211_P2P_NOA_DESC_MAX	4
+
+struct ieee80211_p2p_noa_desc {
+	u8 count;
+	__le32 duration;
+	__le32 interval;
+	__le32 start_time;
+} __packed;
+
+struct ieee80211_p2p_noa_attr {
+	u8 index;
+	u8 oppps_ctwindow;
+	struct ieee80211_p2p_noa_desc desc[IEEE80211_P2P_NOA_DESC_MAX];
+} __packed;
+
+#define IEEE80211_P2P_OPPPS_ENABLE_BIT		BIT(7)
+#define IEEE80211_P2P_OPPPS_CTWINDOW_MASK	0x7F
+
+/**
+ * struct ieee80211_bar - HT Block Ack Request
+ *
+ * This structure refers to "HT BlockAckReq" as
+ * described in 802.11n draft section 7.2.1.7.1
+ */
+struct ieee80211_bar {
+	__le16 frame_control;
+	__le16 duration;
+	__u8 ra[ETH_ALEN];
+	__u8 ta[ETH_ALEN];
+	__le16 control;
+	__le16 start_seq_num;
+} __packed;
+
+/* 802.11 BAR control masks */
+#define IEEE80211_BAR_CTRL_ACK_POLICY_NORMAL	0x0000
+#define IEEE80211_BAR_CTRL_MULTI_TID		0x0002
+#define IEEE80211_BAR_CTRL_CBMTID_COMPRESSED_BA	0x0004
+#define IEEE80211_BAR_CTRL_TID_INFO_MASK	0xf000
+#define IEEE80211_BAR_CTRL_TID_INFO_SHIFT	12
+
+#define IEEE80211_HT_MCS_MASK_LEN		10
+
+/**
+ * struct ieee80211_mcs_info - MCS information
+ * @rx_mask: RX mask
+ * @rx_highest: highest supported RX rate. If set represents
+ *	the highest supported RX data rate in units of 1 Mbps.
+ *	If this field is 0 this value should not be used to
+ *	consider the highest RX data rate supported.
+ * @tx_params: TX parameters
+ */
+struct ieee80211_mcs_info {
+	u8 rx_mask[IEEE80211_HT_MCS_MASK_LEN];
+	__le16 rx_highest;
+	u8 tx_params;
+	u8 reserved[3];
+} __packed;
+
+/* 802.11n HT capability MSC set */
+#define IEEE80211_HT_MCS_RX_HIGHEST_MASK	0x3ff
+#define IEEE80211_HT_MCS_TX_DEFINED		0x01
+#define IEEE80211_HT_MCS_TX_RX_DIFF		0x02
+/* value 0 == 1 stream etc */
+#define IEEE80211_HT_MCS_TX_MAX_STREAMS_MASK	0x0C
+#define IEEE80211_HT_MCS_TX_MAX_STREAMS_SHIFT	2
+#define		IEEE80211_HT_MCS_TX_MAX_STREAMS	4
+#define IEEE80211_HT_MCS_TX_UNEQUAL_MODULATION	0x10
+
+/*
+ * 802.11n D5.0 20.3.5 / 20.6 says:
+ * - indices 0 to 7 and 32 are single spatial stream
+ * - 8 to 31 are multiple spatial streams using equal modulation
+ *   [8..15 for two streams, 16..23 for three and 24..31 for four]
+ * - remainder are multiple spatial streams using unequal modulation
+ */
+#define IEEE80211_HT_MCS_UNEQUAL_MODULATION_START 33
+#define IEEE80211_HT_MCS_UNEQUAL_MODULATION_START_BYTE \
+	(IEEE80211_HT_MCS_UNEQUAL_MODULATION_START / 8)
+
+/**
+ * struct ieee80211_ht_cap - HT capabilities
+ *
+ * This structure is the "HT capabilities element" as
+ * described in 802.11n D5.0 7.3.2.57
+ */
+struct ieee80211_ht_cap {
+	__le16 cap_info;
+	u8 ampdu_params_info;
+
+	/* 16 bytes MCS information */
+	struct ieee80211_mcs_info mcs;
+
+	__le16 extended_ht_cap_info;
+	__le32 tx_BF_cap_info;
+	u8 antenna_selection_info;
+} __packed;
+
+/* 802.11n HT capabilities masks (for cap_info) */
+#define IEEE80211_HT_CAP_LDPC_CODING		0x0001
+#define IEEE80211_HT_CAP_SUP_WIDTH_20_40	0x0002
+#define IEEE80211_HT_CAP_SM_PS			0x000C
+#define		IEEE80211_HT_CAP_SM_PS_SHIFT	2
+#define IEEE80211_HT_CAP_GRN_FLD		0x0010
+#define IEEE80211_HT_CAP_SGI_20			0x0020
+#define IEEE80211_HT_CAP_SGI_40			0x0040
+#define IEEE80211_HT_CAP_TX_STBC		0x0080
+#define IEEE80211_HT_CAP_RX_STBC		0x0300
+#define		IEEE80211_HT_CAP_RX_STBC_SHIFT	8
+#define IEEE80211_HT_CAP_DELAY_BA		0x0400
+#define IEEE80211_HT_CAP_MAX_AMSDU		0x0800
+#define IEEE80211_HT_CAP_DSSSCCK40		0x1000
+#define IEEE80211_HT_CAP_RESERVED		0x2000
+#define IEEE80211_HT_CAP_40MHZ_INTOLERANT	0x4000
+#define IEEE80211_HT_CAP_LSIG_TXOP_PROT		0x8000
+
+/* 802.11n HT extended capabilities masks (for extended_ht_cap_info) */
+#define IEEE80211_HT_EXT_CAP_PCO		0x0001
+#define IEEE80211_HT_EXT_CAP_PCO_TIME		0x0006
+#define		IEEE80211_HT_EXT_CAP_PCO_TIME_SHIFT	1
+#define IEEE80211_HT_EXT_CAP_MCS_FB		0x0300
+#define		IEEE80211_HT_EXT_CAP_MCS_FB_SHIFT	8
+#define IEEE80211_HT_EXT_CAP_HTC_SUP		0x0400
+#define IEEE80211_HT_EXT_CAP_RD_RESPONDER	0x0800
+
+/* 802.11n HT capability AMPDU settings (for ampdu_params_info) */
+#define IEEE80211_HT_AMPDU_PARM_FACTOR		0x03
+#define IEEE80211_HT_AMPDU_PARM_DENSITY		0x1C
+#define		IEEE80211_HT_AMPDU_PARM_DENSITY_SHIFT	2
+
+/*
+ * Maximum length of AMPDU that the STA can receive in high-throughput (HT).
+ * Length = 2 ^ (13 + max_ampdu_length_exp) - 1 (octets)
+ */
+enum ieee80211_max_ampdu_length_exp {
+	IEEE80211_HT_MAX_AMPDU_8K = 0,
+	IEEE80211_HT_MAX_AMPDU_16K = 1,
+	IEEE80211_HT_MAX_AMPDU_32K = 2,
+	IEEE80211_HT_MAX_AMPDU_64K = 3
+};
+
+/*
+ * Maximum length of AMPDU that the STA can receive in VHT.
+ * Length = 2 ^ (13 + max_ampdu_length_exp) - 1 (octets)
+ */
+enum ieee80211_vht_max_ampdu_length_exp {
+	IEEE80211_VHT_MAX_AMPDU_8K = 0,
+	IEEE80211_VHT_MAX_AMPDU_16K = 1,
+	IEEE80211_VHT_MAX_AMPDU_32K = 2,
+	IEEE80211_VHT_MAX_AMPDU_64K = 3,
+	IEEE80211_VHT_MAX_AMPDU_128K = 4,
+	IEEE80211_VHT_MAX_AMPDU_256K = 5,
+	IEEE80211_VHT_MAX_AMPDU_512K = 6,
+	IEEE80211_VHT_MAX_AMPDU_1024K = 7
+};
+
+#define IEEE80211_HT_MAX_AMPDU_FACTOR 13
+
+/* Minimum MPDU start spacing */
+enum ieee80211_min_mpdu_spacing {
+	IEEE80211_HT_MPDU_DENSITY_NONE = 0,	/* No restriction */
+	IEEE80211_HT_MPDU_DENSITY_0_25 = 1,	/* 1/4 usec */
+	IEEE80211_HT_MPDU_DENSITY_0_5 = 2,	/* 1/2 usec */
+	IEEE80211_HT_MPDU_DENSITY_1 = 3,	/* 1 usec */
+	IEEE80211_HT_MPDU_DENSITY_2 = 4,	/* 2 usec */
+	IEEE80211_HT_MPDU_DENSITY_4 = 5,	/* 4 usec */
+	IEEE80211_HT_MPDU_DENSITY_8 = 6,	/* 8 usec */
+	IEEE80211_HT_MPDU_DENSITY_16 = 7	/* 16 usec */
+};
+
+/**
+ * struct ieee80211_ht_operation - HT operation IE
+ *
+ * This structure is the "HT operation element" as
+ * described in 802.11n-2009 7.3.2.57
+ */
+struct ieee80211_ht_operation {
+	u8 primary_chan;
+	u8 ht_param;
+	__le16 operation_mode;
+	__le16 stbc_param;
+	u8 basic_set[16];
+} __packed;
+
+/* for ht_param */
+#define IEEE80211_HT_PARAM_CHA_SEC_OFFSET		0x03
+#define		IEEE80211_HT_PARAM_CHA_SEC_NONE		0x00
+#define		IEEE80211_HT_PARAM_CHA_SEC_ABOVE	0x01
+#define		IEEE80211_HT_PARAM_CHA_SEC_BELOW	0x03
+#define IEEE80211_HT_PARAM_CHAN_WIDTH_ANY		0x04
+#define IEEE80211_HT_PARAM_RIFS_MODE			0x08
+
+/* for operation_mode */
+#define IEEE80211_HT_OP_MODE_PROTECTION			0x0003
+#define		IEEE80211_HT_OP_MODE_PROTECTION_NONE		0
+#define		IEEE80211_HT_OP_MODE_PROTECTION_NONMEMBER	1
+#define		IEEE80211_HT_OP_MODE_PROTECTION_20MHZ		2
+#define		IEEE80211_HT_OP_MODE_PROTECTION_NONHT_MIXED	3
+#define IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT		0x0004
+#define IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT		0x0010
+#define IEEE80211_HT_OP_MODE_CCFS2_SHIFT		5
+#define IEEE80211_HT_OP_MODE_CCFS2_MASK			0x1fe0
+
+/* for stbc_param */
+#define IEEE80211_HT_STBC_PARAM_DUAL_BEACON		0x0040
+#define IEEE80211_HT_STBC_PARAM_DUAL_CTS_PROT		0x0080
+#define IEEE80211_HT_STBC_PARAM_STBC_BEACON		0x0100
+#define IEEE80211_HT_STBC_PARAM_LSIG_TXOP_FULLPROT	0x0200
+#define IEEE80211_HT_STBC_PARAM_PCO_ACTIVE		0x0400
+#define IEEE80211_HT_STBC_PARAM_PCO_PHASE		0x0800
+
+
+/* block-ack parameters */
+#define IEEE80211_ADDBA_PARAM_AMSDU_MASK 0x0001
+#define IEEE80211_ADDBA_PARAM_POLICY_MASK 0x0002
+#define IEEE80211_ADDBA_PARAM_TID_MASK 0x003C
+#define IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK 0xFFC0
+#define IEEE80211_DELBA_PARAM_TID_MASK 0xF000
+#define IEEE80211_DELBA_PARAM_INITIATOR_MASK 0x0800
+
+/*
+ * A-MPDU buffer sizes
+ * According to HT size varies from 8 to 64 frames
+ * HE adds the ability to have up to 256 frames.
+ */
+#define IEEE80211_MIN_AMPDU_BUF		0x8
+#define IEEE80211_MAX_AMPDU_BUF_HT	0x40
+#define IEEE80211_MAX_AMPDU_BUF		0x100
+
+
+/* Spatial Multiplexing Power Save Modes (for capability) */
+#define WLAN_HT_CAP_SM_PS_STATIC	0
+#define WLAN_HT_CAP_SM_PS_DYNAMIC	1
+#define WLAN_HT_CAP_SM_PS_INVALID	2
+#define WLAN_HT_CAP_SM_PS_DISABLED	3
+
+/* for SM power control field lower two bits */
+#define WLAN_HT_SMPS_CONTROL_DISABLED	0
+#define WLAN_HT_SMPS_CONTROL_STATIC	1
+#define WLAN_HT_SMPS_CONTROL_DYNAMIC	3
+
+/**
+ * struct ieee80211_vht_mcs_info - VHT MCS information
+ * @rx_mcs_map: RX MCS map 2 bits for each stream, total 8 streams
+ * @rx_highest: Indicates highest long GI VHT PPDU data rate
+ *	STA can receive. Rate expressed in units of 1 Mbps.
+ *	If this field is 0 this value should not be used to
+ *	consider the highest RX data rate supported.
+ *	The top 3 bits of this field indicate the Maximum NSTS,total
+ *	(a beamformee capability.)
+ * @tx_mcs_map: TX MCS map 2 bits for each stream, total 8 streams
+ * @tx_highest: Indicates highest long GI VHT PPDU data rate
+ *	STA can transmit. Rate expressed in units of 1 Mbps.
+ *	If this field is 0 this value should not be used to
+ *	consider the highest TX data rate supported.
+ *	The top 2 bits of this field are reserved, the
+ *	3rd bit from the top indiciates VHT Extended NSS BW
+ *	Capability.
+ */
+struct ieee80211_vht_mcs_info {
+	__le16 rx_mcs_map;
+	__le16 rx_highest;
+	__le16 tx_mcs_map;
+	__le16 tx_highest;
+} __packed;
+
+/* for rx_highest */
+#define IEEE80211_VHT_MAX_NSTS_TOTAL_SHIFT	13
+#define IEEE80211_VHT_MAX_NSTS_TOTAL_MASK	(7 << IEEE80211_VHT_MAX_NSTS_TOTAL_SHIFT)
+
+/* for tx_highest */
+#define IEEE80211_VHT_EXT_NSS_BW_CAPABLE	(1 << 13)
+
+/**
+ * enum ieee80211_vht_mcs_support - VHT MCS support definitions
+ * @IEEE80211_VHT_MCS_SUPPORT_0_7: MCSes 0-7 are supported for the
+ *	number of streams
+ * @IEEE80211_VHT_MCS_SUPPORT_0_8: MCSes 0-8 are supported
+ * @IEEE80211_VHT_MCS_SUPPORT_0_9: MCSes 0-9 are supported
+ * @IEEE80211_VHT_MCS_NOT_SUPPORTED: This number of streams isn't supported
+ *
+ * These definitions are used in each 2-bit subfield of the @rx_mcs_map
+ * and @tx_mcs_map fields of &struct ieee80211_vht_mcs_info, which are
+ * both split into 8 subfields by number of streams. These values indicate
+ * which MCSes are supported for the number of streams the value appears
+ * for.
+ */
+enum ieee80211_vht_mcs_support {
+	IEEE80211_VHT_MCS_SUPPORT_0_7	= 0,
+	IEEE80211_VHT_MCS_SUPPORT_0_8	= 1,
+	IEEE80211_VHT_MCS_SUPPORT_0_9	= 2,
+	IEEE80211_VHT_MCS_NOT_SUPPORTED	= 3,
+};
+
+/**
+ * struct ieee80211_vht_cap - VHT capabilities
+ *
+ * This structure is the "VHT capabilities element" as
+ * described in 802.11ac D3.0 8.4.2.160
+ * @vht_cap_info: VHT capability info
+ * @supp_mcs: VHT MCS supported rates
+ */
+struct ieee80211_vht_cap {
+	__le32 vht_cap_info;
+	struct ieee80211_vht_mcs_info supp_mcs;
+} __packed;
+
+/**
+ * enum ieee80211_vht_chanwidth - VHT channel width
+ * @IEEE80211_VHT_CHANWIDTH_USE_HT: use the HT operation IE to
+ *	determine the channel width (20 or 40 MHz)
+ * @IEEE80211_VHT_CHANWIDTH_80MHZ: 80 MHz bandwidth
+ * @IEEE80211_VHT_CHANWIDTH_160MHZ: 160 MHz bandwidth
+ * @IEEE80211_VHT_CHANWIDTH_80P80MHZ: 80+80 MHz bandwidth
+ */
+enum ieee80211_vht_chanwidth {
+	IEEE80211_VHT_CHANWIDTH_USE_HT		= 0,
+	IEEE80211_VHT_CHANWIDTH_80MHZ		= 1,
+	IEEE80211_VHT_CHANWIDTH_160MHZ		= 2,
+	IEEE80211_VHT_CHANWIDTH_80P80MHZ	= 3,
+};
+
+/**
+ * struct ieee80211_vht_operation - VHT operation IE
+ *
+ * This structure is the "VHT operation element" as
+ * described in 802.11ac D3.0 8.4.2.161
+ * @chan_width: Operating channel width
+ * @center_freq_seg0_idx: center freq segment 0 index
+ * @center_freq_seg1_idx: center freq segment 1 index
+ * @basic_mcs_set: VHT Basic MCS rate set
+ */
+struct ieee80211_vht_operation {
+	u8 chan_width;
+	u8 center_freq_seg0_idx;
+	u8 center_freq_seg1_idx;
+	__le16 basic_mcs_set;
+} __packed;
+
+/**
+ * struct ieee80211_he_cap_elem - HE capabilities element
+ *
+ * This structure is the "HE capabilities element" fixed fields as
+ * described in P802.11ax_D4.0 section 9.4.2.242.2 and 9.4.2.242.3
+ */
+struct ieee80211_he_cap_elem {
+	u8 mac_cap_info[6];
+	u8 phy_cap_info[11];
+} __packed;
+
+#define IEEE80211_TX_RX_MCS_NSS_DESC_MAX_LEN	5
+
+/**
+ * enum ieee80211_he_mcs_support - HE MCS support definitions
+ * @IEEE80211_HE_MCS_SUPPORT_0_7: MCSes 0-7 are supported for the
+ *	number of streams
+ * @IEEE80211_HE_MCS_SUPPORT_0_9: MCSes 0-9 are supported
+ * @IEEE80211_HE_MCS_SUPPORT_0_11: MCSes 0-11 are supported
+ * @IEEE80211_HE_MCS_NOT_SUPPORTED: This number of streams isn't supported
+ *
+ * These definitions are used in each 2-bit subfield of the rx_mcs_*
+ * and tx_mcs_* fields of &struct ieee80211_he_mcs_nss_supp, which are
+ * both split into 8 subfields by number of streams. These values indicate
+ * which MCSes are supported for the number of streams the value appears
+ * for.
+ */
+enum ieee80211_he_mcs_support {
+	IEEE80211_HE_MCS_SUPPORT_0_7	= 0,
+	IEEE80211_HE_MCS_SUPPORT_0_9	= 1,
+	IEEE80211_HE_MCS_SUPPORT_0_11	= 2,
+	IEEE80211_HE_MCS_NOT_SUPPORTED	= 3,
+};
+
+/**
+ * struct ieee80211_he_mcs_nss_supp - HE Tx/Rx HE MCS NSS Support Field
+ *
+ * This structure holds the data required for the Tx/Rx HE MCS NSS Support Field
+ * described in P802.11ax_D2.0 section 9.4.2.237.4
+ *
+ * @rx_mcs_80: Rx MCS map 2 bits for each stream, total 8 streams, for channel
+ *     widths less than 80MHz.
+ * @tx_mcs_80: Tx MCS map 2 bits for each stream, total 8 streams, for channel
+ *     widths less than 80MHz.
+ * @rx_mcs_160: Rx MCS map 2 bits for each stream, total 8 streams, for channel
+ *     width 160MHz.
+ * @tx_mcs_160: Tx MCS map 2 bits for each stream, total 8 streams, for channel
+ *     width 160MHz.
+ * @rx_mcs_80p80: Rx MCS map 2 bits for each stream, total 8 streams, for
+ *     channel width 80p80MHz.
+ * @tx_mcs_80p80: Tx MCS map 2 bits for each stream, total 8 streams, for
+ *     channel width 80p80MHz.
+ */
+struct ieee80211_he_mcs_nss_supp {
+	__le16 rx_mcs_80;
+	__le16 tx_mcs_80;
+	__le16 rx_mcs_160;
+	__le16 tx_mcs_160;
+	__le16 rx_mcs_80p80;
+	__le16 tx_mcs_80p80;
+} __packed;
+
+/**
+ * struct ieee80211_he_operation - HE capabilities element
+ *
+ * This structure is the "HE operation element" fields as
+ * described in P802.11ax_D4.0 section 9.4.2.243
+ */
+struct ieee80211_he_operation {
+	__le32 he_oper_params;
+	__le16 he_mcs_nss_set;
+	/* Optional 0,1,3,4,5,7 or 8 bytes: depends on @he_oper_params */
+	u8 optional[0];
+} __packed;
+
+/**
+ * struct ieee80211_he_spr - HE spatial reuse element
+ *
+ * This structure is the "HE spatial reuse element" element as
+ * described in P802.11ax_D4.0 section 9.4.2.241
+ */
+struct ieee80211_he_spr {
+	u8 he_sr_control;
+	/* Optional 0 to 19 bytes: depends on @he_sr_control */
+	u8 optional[0];
+} __packed;
+
+/**
+ * struct ieee80211_he_mu_edca_param_ac_rec - MU AC Parameter Record field
+ *
+ * This structure is the "MU AC Parameter Record" fields as
+ * described in P802.11ax_D4.0 section 9.4.2.245
+ */
+struct ieee80211_he_mu_edca_param_ac_rec {
+	u8 aifsn;
+	u8 ecw_min_max;
+	u8 mu_edca_timer;
+} __packed;
+
+/**
+ * struct ieee80211_mu_edca_param_set - MU EDCA Parameter Set element
+ *
+ * This structure is the "MU EDCA Parameter Set element" fields as
+ * described in P802.11ax_D4.0 section 9.4.2.245
+ */
+struct ieee80211_mu_edca_param_set {
+	u8 mu_qos_info;
+	struct ieee80211_he_mu_edca_param_ac_rec ac_be;
+	struct ieee80211_he_mu_edca_param_ac_rec ac_bk;
+	struct ieee80211_he_mu_edca_param_ac_rec ac_vi;
+	struct ieee80211_he_mu_edca_param_ac_rec ac_vo;
+} __packed;
+
+/* 802.11ac VHT Capabilities */
+#define IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_3895			0x00000000
+#define IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991			0x00000001
+#define IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454			0x00000002
+#define IEEE80211_VHT_CAP_MAX_MPDU_MASK				0x00000003
+#define IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ		0x00000004
+#define IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ	0x00000008
+#define IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK			0x0000000C
+#define IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_SHIFT			2
+#define IEEE80211_VHT_CAP_RXLDPC				0x00000010
+#define IEEE80211_VHT_CAP_SHORT_GI_80				0x00000020
+#define IEEE80211_VHT_CAP_SHORT_GI_160				0x00000040
+#define IEEE80211_VHT_CAP_TXSTBC				0x00000080
+#define IEEE80211_VHT_CAP_RXSTBC_1				0x00000100
+#define IEEE80211_VHT_CAP_RXSTBC_2				0x00000200
+#define IEEE80211_VHT_CAP_RXSTBC_3				0x00000300
+#define IEEE80211_VHT_CAP_RXSTBC_4				0x00000400
+#define IEEE80211_VHT_CAP_RXSTBC_MASK				0x00000700
+#define IEEE80211_VHT_CAP_RXSTBC_SHIFT				8
+#define IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE			0x00000800
+#define IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE			0x00001000
+#define IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT                  13
+#define IEEE80211_VHT_CAP_BEAMFORMEE_STS_MASK			\
+		(7 << IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT)
+#define IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_SHIFT		16
+#define IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK		\
+		(7 << IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_SHIFT)
+#define IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE			0x00080000
+#define IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE			0x00100000
+#define IEEE80211_VHT_CAP_VHT_TXOP_PS				0x00200000
+#define IEEE80211_VHT_CAP_HTC_VHT				0x00400000
+#define IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT	23
+#define IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK	\
+		(7 << IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT)
+#define IEEE80211_VHT_CAP_VHT_LINK_ADAPTATION_VHT_UNSOL_MFB	0x08000000
+#define IEEE80211_VHT_CAP_VHT_LINK_ADAPTATION_VHT_MRQ_MFB	0x0c000000
+#define IEEE80211_VHT_CAP_RX_ANTENNA_PATTERN			0x10000000
+#define IEEE80211_VHT_CAP_TX_ANTENNA_PATTERN			0x20000000
+#define IEEE80211_VHT_CAP_EXT_NSS_BW_SHIFT			30
+#define IEEE80211_VHT_CAP_EXT_NSS_BW_MASK			0xc0000000
+
+/**
+ * ieee80211_get_vht_max_nss - return max NSS for a given bandwidth/MCS
+ * @cap: VHT capabilities of the peer
+ * @bw: bandwidth to use
+ * @mcs: MCS index to use
+ * @ext_nss_bw_capable: indicates whether or not the local transmitter
+ *	(rate scaling algorithm) can deal with the new logic
+ *	(dot11VHTExtendedNSSBWCapable)
+ *
+ * Due to the VHT Extended NSS Bandwidth Support, the maximum NSS can
+ * vary for a given BW/MCS. This function parses the data.
+ *
+ * Note: This function is exported by cfg80211.
+ */
+int ieee80211_get_vht_max_nss(struct ieee80211_vht_cap *cap,
+			      enum ieee80211_vht_chanwidth bw,
+			      int mcs, bool ext_nss_bw_capable);
+
+/* 802.11ax HE MAC capabilities */
+#define IEEE80211_HE_MAC_CAP0_HTC_HE				0x01
+#define IEEE80211_HE_MAC_CAP0_TWT_REQ				0x02
+#define IEEE80211_HE_MAC_CAP0_TWT_RES				0x04
+#define IEEE80211_HE_MAC_CAP0_DYNAMIC_FRAG_NOT_SUPP		0x00
+#define IEEE80211_HE_MAC_CAP0_DYNAMIC_FRAG_LEVEL_1		0x08
+#define IEEE80211_HE_MAC_CAP0_DYNAMIC_FRAG_LEVEL_2		0x10
+#define IEEE80211_HE_MAC_CAP0_DYNAMIC_FRAG_LEVEL_3		0x18
+#define IEEE80211_HE_MAC_CAP0_DYNAMIC_FRAG_MASK			0x18
+#define IEEE80211_HE_MAC_CAP0_MAX_NUM_FRAG_MSDU_1		0x00
+#define IEEE80211_HE_MAC_CAP0_MAX_NUM_FRAG_MSDU_2		0x20
+#define IEEE80211_HE_MAC_CAP0_MAX_NUM_FRAG_MSDU_4		0x40
+#define IEEE80211_HE_MAC_CAP0_MAX_NUM_FRAG_MSDU_8		0x60
+#define IEEE80211_HE_MAC_CAP0_MAX_NUM_FRAG_MSDU_16		0x80
+#define IEEE80211_HE_MAC_CAP0_MAX_NUM_FRAG_MSDU_32		0xa0
+#define IEEE80211_HE_MAC_CAP0_MAX_NUM_FRAG_MSDU_64		0xc0
+#define IEEE80211_HE_MAC_CAP0_MAX_NUM_FRAG_MSDU_UNLIMITED	0xe0
+#define IEEE80211_HE_MAC_CAP0_MAX_NUM_FRAG_MSDU_MASK		0xe0
+
+#define IEEE80211_HE_MAC_CAP1_MIN_FRAG_SIZE_UNLIMITED		0x00
+#define IEEE80211_HE_MAC_CAP1_MIN_FRAG_SIZE_128			0x01
+#define IEEE80211_HE_MAC_CAP1_MIN_FRAG_SIZE_256			0x02
+#define IEEE80211_HE_MAC_CAP1_MIN_FRAG_SIZE_512			0x03
+#define IEEE80211_HE_MAC_CAP1_MIN_FRAG_SIZE_MASK		0x03
+#define IEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_0US		0x00
+#define IEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_8US		0x04
+#define IEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US		0x08
+#define IEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_MASK		0x0c
+#define IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_1		0x00
+#define IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_2		0x10
+#define IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_3		0x20
+#define IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_4		0x30
+#define IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_5		0x40
+#define IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_6		0x50
+#define IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_7		0x60
+#define IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8		0x70
+#define IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_MASK		0x70
+
+/* Link adaptation is split between byte HE_MAC_CAP1 and
+ * HE_MAC_CAP2. It should be set only if IEEE80211_HE_MAC_CAP0_HTC_HE
+ * in which case the following values apply:
+ * 0 = No feedback.
+ * 1 = reserved.
+ * 2 = Unsolicited feedback.
+ * 3 = both
+ */
+#define IEEE80211_HE_MAC_CAP1_LINK_ADAPTATION			0x80
+
+#define IEEE80211_HE_MAC_CAP2_LINK_ADAPTATION			0x01
+#define IEEE80211_HE_MAC_CAP2_ALL_ACK				0x02
+#define IEEE80211_HE_MAC_CAP2_TRS				0x04
+#define IEEE80211_HE_MAC_CAP2_BSR				0x08
+#define IEEE80211_HE_MAC_CAP2_BCAST_TWT				0x10
+#define IEEE80211_HE_MAC_CAP2_32BIT_BA_BITMAP			0x20
+#define IEEE80211_HE_MAC_CAP2_MU_CASCADING			0x40
+#define IEEE80211_HE_MAC_CAP2_ACK_EN				0x80
+
+#define IEEE80211_HE_MAC_CAP3_OMI_CONTROL			0x02
+#define IEEE80211_HE_MAC_CAP3_OFDMA_RA				0x04
+
+/* The maximum length of an A-MDPU is defined by the combination of the Maximum
+ * A-MDPU Length Exponent field in the HT capabilities, VHT capabilities and the
+ * same field in the HE capabilities.
+ */
+#define IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_USE_VHT	0x00
+#define IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_1		0x08
+#define IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2		0x10
+#define IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_RESERVED	0x18
+#define IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_MASK		0x18
+#define IEEE80211_HE_MAC_CAP3_AMSDU_FRAG			0x20
+#define IEEE80211_HE_MAC_CAP3_FLEX_TWT_SCHED			0x40
+#define IEEE80211_HE_MAC_CAP3_RX_CTRL_FRAME_TO_MULTIBSS		0x80
+
+#define IEEE80211_HE_MAC_CAP4_BSRP_BQRP_A_MPDU_AGG		0x01
+#define IEEE80211_HE_MAC_CAP4_QTP				0x02
+#define IEEE80211_HE_MAC_CAP4_BQR				0x04
+#define IEEE80211_HE_MAC_CAP4_SRP_RESP				0x08
+#define IEEE80211_HE_MAC_CAP4_NDP_FB_REP			0x10
+#define IEEE80211_HE_MAC_CAP4_OPS				0x20
+#define IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU			0x40
+/* Multi TID agg TX is split between byte #4 and #5
+ * The value is a combination of B39,B40,B41
+ */
+#define IEEE80211_HE_MAC_CAP4_MULTI_TID_AGG_TX_QOS_B39		0x80
+
+#define IEEE80211_HE_MAC_CAP5_MULTI_TID_AGG_TX_QOS_B40		0x01
+#define IEEE80211_HE_MAC_CAP5_MULTI_TID_AGG_TX_QOS_B41		0x02
+#define IEEE80211_HE_MAC_CAP5_SUBCHAN_SELECVITE_TRANSMISSION	0x04
+#define IEEE80211_HE_MAC_CAP5_UL_2x996_TONE_RU			0x08
+#define IEEE80211_HE_MAC_CAP5_OM_CTRL_UL_MU_DATA_DIS_RX		0x10
+#define IEEE80211_HE_MAC_CAP5_HE_DYNAMIC_SM_PS			0x20
+#define IEEE80211_HE_MAC_CAP5_PUNCTURED_SOUNDING		0x40
+#define IEEE80211_HE_MAC_CAP5_HT_VHT_TRIG_FRAME_RX		0x80
+
+/* 802.11ax HE PHY capabilities */
+#define IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G		0x02
+#define IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G	0x04
+#define IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G		0x08
+#define IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G	0x10
+#define IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_RU_MAPPING_IN_2G	0x20
+#define IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_RU_MAPPING_IN_5G	0x40
+#define IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_MASK			0xfe
+
+#define IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_80MHZ_ONLY_SECOND_20MHZ	0x01
+#define IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_80MHZ_ONLY_SECOND_40MHZ	0x02
+#define IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_160MHZ_ONLY_SECOND_20MHZ	0x04
+#define IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_160MHZ_ONLY_SECOND_40MHZ	0x08
+#define IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK			0x0f
+#define IEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A				0x10
+#define IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD			0x20
+#define IEEE80211_HE_PHY_CAP1_HE_LTF_AND_GI_FOR_HE_PPDUS_0_8US		0x40
+/* Midamble RX/TX Max NSTS is split between byte #2 and byte #3 */
+#define IEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS			0x80
+
+#define IEEE80211_HE_PHY_CAP2_MIDAMBLE_RX_TX_MAX_NSTS			0x01
+#define IEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US			0x02
+#define IEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ			0x04
+#define IEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ			0x08
+#define IEEE80211_HE_PHY_CAP2_DOPPLER_TX				0x10
+#define IEEE80211_HE_PHY_CAP2_DOPPLER_RX				0x20
+
+/* Note that the meaning of UL MU below is different between an AP and a non-AP
+ * sta, where in the AP case it indicates support for Rx and in the non-AP sta
+ * case it indicates support for Tx.
+ */
+#define IEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO			0x40
+#define IEEE80211_HE_PHY_CAP2_UL_MU_PARTIAL_MU_MIMO			0x80
+
+#define IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_NO_DCM			0x00
+#define IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_BPSK			0x01
+#define IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_QPSK			0x02
+#define IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_16_QAM			0x03
+#define IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_MASK			0x03
+#define IEEE80211_HE_PHY_CAP3_DCM_MAX_TX_NSS_1				0x00
+#define IEEE80211_HE_PHY_CAP3_DCM_MAX_TX_NSS_2				0x04
+#define IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_NO_DCM			0x00
+#define IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_BPSK			0x08
+#define IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_QPSK			0x10
+#define IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_16_QAM			0x18
+#define IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_MASK			0x18
+#define IEEE80211_HE_PHY_CAP3_DCM_MAX_RX_NSS_1				0x00
+#define IEEE80211_HE_PHY_CAP3_DCM_MAX_RX_NSS_2				0x20
+#define IEEE80211_HE_PHY_CAP3_RX_HE_MU_PPDU_FROM_NON_AP_STA		0x40
+#define IEEE80211_HE_PHY_CAP3_SU_BEAMFORMER				0x80
+
+#define IEEE80211_HE_PHY_CAP4_SU_BEAMFORMEE				0x01
+#define IEEE80211_HE_PHY_CAP4_MU_BEAMFORMER				0x02
+
+/* Minimal allowed value of Max STS under 80MHz is 3 */
+#define IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_4		0x0c
+#define IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_5		0x10
+#define IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_6		0x14
+#define IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_7		0x18
+#define IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_8		0x1c
+#define IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_MASK	0x1c
+
+/* Minimal allowed value of Max STS above 80MHz is 3 */
+#define IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_ABOVE_80MHZ_4		0x60
+#define IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_ABOVE_80MHZ_5		0x80
+#define IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_ABOVE_80MHZ_6		0xa0
+#define IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_ABOVE_80MHZ_7		0xc0
+#define IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_ABOVE_80MHZ_8		0xe0
+#define IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_ABOVE_80MHZ_MASK	0xe0
+
+#define IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_1	0x00
+#define IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_2	0x01
+#define IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_3	0x02
+#define IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_4	0x03
+#define IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_5	0x04
+#define IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_6	0x05
+#define IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_7	0x06
+#define IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_8	0x07
+#define IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_MASK	0x07
+
+#define IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_ABOVE_80MHZ_1	0x00
+#define IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_ABOVE_80MHZ_2	0x08
+#define IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_ABOVE_80MHZ_3	0x10
+#define IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_ABOVE_80MHZ_4	0x18
+#define IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_ABOVE_80MHZ_5	0x20
+#define IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_ABOVE_80MHZ_6	0x28
+#define IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_ABOVE_80MHZ_7	0x30
+#define IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_ABOVE_80MHZ_8	0x38
+#define IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_ABOVE_80MHZ_MASK	0x38
+
+#define IEEE80211_HE_PHY_CAP5_NG16_SU_FEEDBACK				0x40
+#define IEEE80211_HE_PHY_CAP5_NG16_MU_FEEDBACK				0x80
+
+#define IEEE80211_HE_PHY_CAP6_CODEBOOK_SIZE_42_SU			0x01
+#define IEEE80211_HE_PHY_CAP6_CODEBOOK_SIZE_75_MU			0x02
+#define IEEE80211_HE_PHY_CAP6_TRIG_SU_BEAMFORMER_FB			0x04
+#define IEEE80211_HE_PHY_CAP6_TRIG_MU_BEAMFORMER_FB			0x08
+#define IEEE80211_HE_PHY_CAP6_TRIG_CQI_FB				0x10
+#define IEEE80211_HE_PHY_CAP6_PARTIAL_BW_EXT_RANGE			0x20
+#define IEEE80211_HE_PHY_CAP6_PARTIAL_BANDWIDTH_DL_MUMIMO		0x40
+#define IEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT			0x80
+
+#define IEEE80211_HE_PHY_CAP7_SRP_BASED_SR				0x01
+#define IEEE80211_HE_PHY_CAP7_POWER_BOOST_FACTOR_AR			0x02
+#define IEEE80211_HE_PHY_CAP7_HE_SU_MU_PPDU_4XLTF_AND_08_US_GI		0x04
+#define IEEE80211_HE_PHY_CAP7_MAX_NC_1					0x08
+#define IEEE80211_HE_PHY_CAP7_MAX_NC_2					0x10
+#define IEEE80211_HE_PHY_CAP7_MAX_NC_3					0x18
+#define IEEE80211_HE_PHY_CAP7_MAX_NC_4					0x20
+#define IEEE80211_HE_PHY_CAP7_MAX_NC_5					0x28
+#define IEEE80211_HE_PHY_CAP7_MAX_NC_6					0x30
+#define IEEE80211_HE_PHY_CAP7_MAX_NC_7					0x38
+#define IEEE80211_HE_PHY_CAP7_MAX_NC_MASK				0x38
+#define IEEE80211_HE_PHY_CAP7_STBC_TX_ABOVE_80MHZ			0x40
+#define IEEE80211_HE_PHY_CAP7_STBC_RX_ABOVE_80MHZ			0x80
+
+#define IEEE80211_HE_PHY_CAP8_HE_ER_SU_PPDU_4XLTF_AND_08_US_GI		0x01
+#define IEEE80211_HE_PHY_CAP8_20MHZ_IN_40MHZ_HE_PPDU_IN_2G		0x02
+#define IEEE80211_HE_PHY_CAP8_20MHZ_IN_160MHZ_HE_PPDU			0x04
+#define IEEE80211_HE_PHY_CAP8_80MHZ_IN_160MHZ_HE_PPDU			0x08
+#define IEEE80211_HE_PHY_CAP8_HE_ER_SU_1XLTF_AND_08_US_GI		0x10
+#define IEEE80211_HE_PHY_CAP8_MIDAMBLE_RX_TX_2X_AND_1XLTF		0x20
+#define IEEE80211_HE_PHY_CAP8_DCM_MAX_RU_242				0x00
+#define IEEE80211_HE_PHY_CAP8_DCM_MAX_RU_484				0x40
+#define IEEE80211_HE_PHY_CAP8_DCM_MAX_RU_996				0x80
+#define IEEE80211_HE_PHY_CAP8_DCM_MAX_RU_2x996				0xc0
+#define IEEE80211_HE_PHY_CAP8_DCM_MAX_RU_MASK				0xc0
+
+#define IEEE80211_HE_PHY_CAP9_LONGER_THAN_16_SIGB_OFDM_SYM		0x01
+#define IEEE80211_HE_PHY_CAP9_NON_TRIGGERED_CQI_FEEDBACK		0x02
+#define IEEE80211_HE_PHY_CAP9_TX_1024_QAM_LESS_THAN_242_TONE_RU		0x04
+#define IEEE80211_HE_PHY_CAP9_RX_1024_QAM_LESS_THAN_242_TONE_RU		0x08
+#define IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_COMP_SIGB	0x10
+#define IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB	0x20
+#define IEEE80211_HE_PHY_CAP9_NOMIMAL_PKT_PADDING_0US			0x00
+#define IEEE80211_HE_PHY_CAP9_NOMIMAL_PKT_PADDING_8US			0x40
+#define IEEE80211_HE_PHY_CAP9_NOMIMAL_PKT_PADDING_16US			0x80
+#define IEEE80211_HE_PHY_CAP9_NOMIMAL_PKT_PADDING_RESERVED		0xc0
+#define IEEE80211_HE_PHY_CAP9_NOMIMAL_PKT_PADDING_MASK			0xc0
+
+/* 802.11ax HE TX/RX MCS NSS Support  */
+#define IEEE80211_TX_RX_MCS_NSS_SUPP_HIGHEST_MCS_POS			(3)
+#define IEEE80211_TX_RX_MCS_NSS_SUPP_TX_BITMAP_POS			(6)
+#define IEEE80211_TX_RX_MCS_NSS_SUPP_RX_BITMAP_POS			(11)
+#define IEEE80211_TX_RX_MCS_NSS_SUPP_TX_BITMAP_MASK			0x07c0
+#define IEEE80211_TX_RX_MCS_NSS_SUPP_RX_BITMAP_MASK			0xf800
+
+/* TX/RX HE MCS Support field Highest MCS subfield encoding */
+enum ieee80211_he_highest_mcs_supported_subfield_enc {
+	HIGHEST_MCS_SUPPORTED_MCS7 = 0,
+	HIGHEST_MCS_SUPPORTED_MCS8,
+	HIGHEST_MCS_SUPPORTED_MCS9,
+	HIGHEST_MCS_SUPPORTED_MCS10,
+	HIGHEST_MCS_SUPPORTED_MCS11,
+};
+
+/* Calculate 802.11ax HE capabilities IE Tx/Rx HE MCS NSS Support Field size */
+static inline u8
+ieee80211_he_mcs_nss_size(const struct ieee80211_he_cap_elem *he_cap)
+{
+	u8 count = 4;
+
+	if (he_cap->phy_cap_info[0] &
+	    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G)
+		count += 4;
+
+	if (he_cap->phy_cap_info[0] &
+	    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G)
+		count += 4;
+
+	return count;
+}
+
+/* 802.11ax HE PPE Thresholds */
+#define IEEE80211_PPE_THRES_NSS_SUPPORT_2NSS			(1)
+#define IEEE80211_PPE_THRES_NSS_POS				(0)
+#define IEEE80211_PPE_THRES_NSS_MASK				(7)
+#define IEEE80211_PPE_THRES_RU_INDEX_BITMASK_2x966_AND_966_RU	\
+	(BIT(5) | BIT(6))
+#define IEEE80211_PPE_THRES_RU_INDEX_BITMASK_MASK		0x78
+#define IEEE80211_PPE_THRES_RU_INDEX_BITMASK_POS		(3)
+#define IEEE80211_PPE_THRES_INFO_PPET_SIZE			(3)
+
+/*
+ * Calculate 802.11ax HE capabilities IE PPE field size
+ * Input: Header byte of ppe_thres (first byte), and HE capa IE's PHY cap u8*
+ */
+static inline u8
+ieee80211_he_ppe_size(u8 ppe_thres_hdr, const u8 *phy_cap_info)
+{
+	u8 n;
+
+	if ((phy_cap_info[6] &
+	     IEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT) == 0)
+		return 0;
+
+	n = hweight8(ppe_thres_hdr &
+		     IEEE80211_PPE_THRES_RU_INDEX_BITMASK_MASK);
+	n *= (1 + ((ppe_thres_hdr & IEEE80211_PPE_THRES_NSS_MASK) >>
+		   IEEE80211_PPE_THRES_NSS_POS));
+
+	/*
+	 * Each pair is 6 bits, and we need to add the 7 "header" bits to the
+	 * total size.
+	 */
+	n = (n * IEEE80211_PPE_THRES_INFO_PPET_SIZE * 2) + 7;
+	n = DIV_ROUND_UP(n, 8);
+
+	return n;
+}
+
+/* HE Operation defines */
+#define IEEE80211_HE_OPERATION_DFLT_PE_DURATION_MASK		0x00000007
+#define IEEE80211_HE_OPERATION_TWT_REQUIRED			0x00000008
+#define IEEE80211_HE_OPERATION_RTS_THRESHOLD_MASK		0x00003ff0
+#define IEEE80211_HE_OPERATION_RTS_THRESHOLD_OFFSET		4
+#define IEEE80211_HE_OPERATION_VHT_OPER_INFO			0x00004000
+#define IEEE80211_HE_OPERATION_CO_HOSTED_BSS			0x00008000
+#define IEEE80211_HE_OPERATION_ER_SU_DISABLE			0x00010000
+#define IEEE80211_HE_OPERATION_6GHZ_OP_INFO			0x00020000
+#define IEEE80211_HE_OPERATION_BSS_COLOR_MASK			0x3f000000
+#define IEEE80211_HE_OPERATION_BSS_COLOR_OFFSET		24
+#define IEEE80211_HE_OPERATION_PARTIAL_BSS_COLOR		0x40000000
+#define IEEE80211_HE_OPERATION_BSS_COLOR_DISABLED		0x80000000
+
+/**
+ * ieee80211_he_6ghz_oper - HE 6 GHz operation Information field
+ * @primary: primary channel
+ * @control: control flags
+ * @ccfs0: channel center frequency segment 0
+ * @ccfs1: channel center frequency segment 1
+ * @minrate: minimum rate (in 1 Mbps units)
+ */
+struct ieee80211_he_6ghz_oper {
+	u8 primary;
+#define IEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH	0x3
+#define		IEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_20MHZ	0
+#define		IEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_40MHZ	1
+#define		IEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_80MHZ	2
+#define		IEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_160MHZ	3
+#define IEEE80211_HE_6GHZ_OPER_CTRL_DUP_BEACON	0x4
+	u8 control;
+	u8 ccfs0;
+	u8 ccfs1;
+	u8 minrate;
+} __packed;
+
+/*
+ * ieee80211_he_oper_size - calculate 802.11ax HE Operations IE size
+ * @he_oper_ie: byte data of the He Operations IE, stating from the the byte
+ *	after the ext ID byte. It is assumed that he_oper_ie has at least
+ *	sizeof(struct ieee80211_he_operation) bytes, the caller must have
+ *	validated this.
+ * @return the actual size of the IE data (not including header), or 0 on error
+ */
+static inline u8
+ieee80211_he_oper_size(const u8 *he_oper_ie)
+{
+	struct ieee80211_he_operation *he_oper = (void *)he_oper_ie;
+	u8 oper_len = sizeof(struct ieee80211_he_operation);
+	u32 he_oper_params;
+
+	/* Make sure the input is not NULL */
+	if (!he_oper_ie)
+		return 0;
+
+	/* Calc required length */
+	he_oper_params = le32_to_cpu(he_oper->he_oper_params);
+	if (he_oper_params & IEEE80211_HE_OPERATION_VHT_OPER_INFO)
+		oper_len += 3;
+	if (he_oper_params & IEEE80211_HE_OPERATION_CO_HOSTED_BSS)
+		oper_len++;
+	if (he_oper_params & IEEE80211_HE_OPERATION_6GHZ_OP_INFO)
+		oper_len += sizeof(struct ieee80211_he_6ghz_oper);
+
+	/* Add the first byte (extension ID) to the total length */
+	oper_len++;
+
+	return oper_len;
+}
+
+/**
+ * ieee80211_he_6ghz_oper - obtain 6 GHz operation field
+ * @he_oper: HE operation element (must be pre-validated for size)
+ *	but may be %NULL
+ *
+ * Return: a pointer to the 6 GHz operation field, or %NULL
+ */
+static inline const struct ieee80211_he_6ghz_oper *
+ieee80211_he_6ghz_oper(const struct ieee80211_he_operation *he_oper)
+{
+	const u8 *ret = (void *)&he_oper->optional;
+	u32 he_oper_params;
+
+	if (!he_oper)
+		return NULL;
+
+	he_oper_params = le32_to_cpu(he_oper->he_oper_params);
+
+	if (!(he_oper_params & IEEE80211_HE_OPERATION_6GHZ_OP_INFO))
+		return NULL;
+	if (he_oper_params & IEEE80211_HE_OPERATION_VHT_OPER_INFO)
+		ret += 3;
+	if (he_oper_params & IEEE80211_HE_OPERATION_CO_HOSTED_BSS)
+		ret++;
+
+	return (void *)ret;
+}
+
+/* HE Spatial Reuse defines */
+#define IEEE80211_HE_SPR_NON_SRG_OFFSET_PRESENT			0x4
+#define IEEE80211_HE_SPR_SRG_INFORMATION_PRESENT		0x8
+
+/*
+ * ieee80211_he_spr_size - calculate 802.11ax HE Spatial Reuse IE size
+ * @he_spr_ie: byte data of the He Spatial Reuse IE, stating from the the byte
+ *	after the ext ID byte. It is assumed that he_spr_ie has at least
+ *	sizeof(struct ieee80211_he_spr) bytes, the caller must have validated
+ *	this
+ * @return the actual size of the IE data (not including header), or 0 on error
+ */
+static inline u8
+ieee80211_he_spr_size(const u8 *he_spr_ie)
+{
+	struct ieee80211_he_spr *he_spr = (void *)he_spr_ie;
+	u8 spr_len = sizeof(struct ieee80211_he_spr);
+	u8 he_spr_params;
+
+	/* Make sure the input is not NULL */
+	if (!he_spr_ie)
+		return 0;
+
+	/* Calc required length */
+	he_spr_params = he_spr->he_sr_control;
+	if (he_spr_params & IEEE80211_HE_SPR_NON_SRG_OFFSET_PRESENT)
+		spr_len++;
+	if (he_spr_params & IEEE80211_HE_SPR_SRG_INFORMATION_PRESENT)
+		spr_len += 18;
+
+	/* Add the first byte (extension ID) to the total length */
+	spr_len++;
+
+	return spr_len;
+}
+
+/* Authentication algorithms */
+#define WLAN_AUTH_OPEN 0
+#define WLAN_AUTH_SHARED_KEY 1
+#define WLAN_AUTH_FT 2
+#define WLAN_AUTH_SAE 3
+#define WLAN_AUTH_FILS_SK 4
+#define WLAN_AUTH_FILS_SK_PFS 5
+#define WLAN_AUTH_FILS_PK 6
+#define WLAN_AUTH_LEAP 128
+
+#define WLAN_AUTH_CHALLENGE_LEN 128
+
+#define WLAN_CAPABILITY_ESS		(1<<0)
+#define WLAN_CAPABILITY_IBSS		(1<<1)
+
+/*
+ * A mesh STA sets the ESS and IBSS capability bits to zero.
+ * however, this holds true for p2p probe responses (in the p2p_find
+ * phase) as well.
+ */
+#define WLAN_CAPABILITY_IS_STA_BSS(cap)	\
+	(!((cap) & (WLAN_CAPABILITY_ESS | WLAN_CAPABILITY_IBSS)))
+
+#define WLAN_CAPABILITY_CF_POLLABLE	(1<<2)
+#define WLAN_CAPABILITY_CF_POLL_REQUEST	(1<<3)
+#define WLAN_CAPABILITY_PRIVACY		(1<<4)
+#define WLAN_CAPABILITY_SHORT_PREAMBLE	(1<<5)
+#define WLAN_CAPABILITY_PBCC		(1<<6)
+#define WLAN_CAPABILITY_CHANNEL_AGILITY	(1<<7)
+
+/* 802.11h */
+#define WLAN_CAPABILITY_SPECTRUM_MGMT	(1<<8)
+#define WLAN_CAPABILITY_QOS		(1<<9)
+#define WLAN_CAPABILITY_SHORT_SLOT_TIME	(1<<10)
+#define WLAN_CAPABILITY_APSD		(1<<11)
+#define WLAN_CAPABILITY_RADIO_MEASURE	(1<<12)
+#define WLAN_CAPABILITY_DSSS_OFDM	(1<<13)
+#define WLAN_CAPABILITY_DEL_BACK	(1<<14)
+#define WLAN_CAPABILITY_IMM_BACK	(1<<15)
+
+/* DMG (60gHz) 802.11ad */
+/* type - bits 0..1 */
+#define WLAN_CAPABILITY_DMG_TYPE_MASK		(3<<0)
+#define WLAN_CAPABILITY_DMG_TYPE_IBSS		(1<<0) /* Tx by: STA */
+#define WLAN_CAPABILITY_DMG_TYPE_PBSS		(2<<0) /* Tx by: PCP */
+#define WLAN_CAPABILITY_DMG_TYPE_AP		(3<<0) /* Tx by: AP */
+
+#define WLAN_CAPABILITY_DMG_CBAP_ONLY		(1<<2)
+#define WLAN_CAPABILITY_DMG_CBAP_SOURCE		(1<<3)
+#define WLAN_CAPABILITY_DMG_PRIVACY		(1<<4)
+#define WLAN_CAPABILITY_DMG_ECPAC		(1<<5)
+
+#define WLAN_CAPABILITY_DMG_SPECTRUM_MGMT	(1<<8)
+#define WLAN_CAPABILITY_DMG_RADIO_MEASURE	(1<<12)
+
+/* measurement */
+#define IEEE80211_SPCT_MSR_RPRT_MODE_LATE	(1<<0)
+#define IEEE80211_SPCT_MSR_RPRT_MODE_INCAPABLE	(1<<1)
+#define IEEE80211_SPCT_MSR_RPRT_MODE_REFUSED	(1<<2)
+
+#define IEEE80211_SPCT_MSR_RPRT_TYPE_BASIC	0
+#define IEEE80211_SPCT_MSR_RPRT_TYPE_CCA	1
+#define IEEE80211_SPCT_MSR_RPRT_TYPE_RPI	2
+#define IEEE80211_SPCT_MSR_RPRT_TYPE_LCI	8
+#define IEEE80211_SPCT_MSR_RPRT_TYPE_CIVIC	11
+
+/* 802.11g ERP information element */
+#define WLAN_ERP_NON_ERP_PRESENT (1<<0)
+#define WLAN_ERP_USE_PROTECTION (1<<1)
+#define WLAN_ERP_BARKER_PREAMBLE (1<<2)
+
+/* WLAN_ERP_BARKER_PREAMBLE values */
+enum {
+	WLAN_ERP_PREAMBLE_SHORT = 0,
+	WLAN_ERP_PREAMBLE_LONG = 1,
+};
+
+/* Band ID, 802.11ad #8.4.1.45 */
+enum {
+	IEEE80211_BANDID_TV_WS = 0, /* TV white spaces */
+	IEEE80211_BANDID_SUB1  = 1, /* Sub-1 GHz (excluding TV white spaces) */
+	IEEE80211_BANDID_2G    = 2, /* 2.4 GHz */
+	IEEE80211_BANDID_3G    = 3, /* 3.6 GHz */
+	IEEE80211_BANDID_5G    = 4, /* 4.9 and 5 GHz */
+	IEEE80211_BANDID_60G   = 5, /* 60 GHz */
+};
+
+/* Status codes */
+enum ieee80211_statuscode {
+	WLAN_STATUS_SUCCESS = 0,
+	WLAN_STATUS_UNSPECIFIED_FAILURE = 1,
+	WLAN_STATUS_CAPS_UNSUPPORTED = 10,
+	WLAN_STATUS_REASSOC_NO_ASSOC = 11,
+	WLAN_STATUS_ASSOC_DENIED_UNSPEC = 12,
+	WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG = 13,
+	WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION = 14,
+	WLAN_STATUS_CHALLENGE_FAIL = 15,
+	WLAN_STATUS_AUTH_TIMEOUT = 16,
+	WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA = 17,
+	WLAN_STATUS_ASSOC_DENIED_RATES = 18,
+	/* 802.11b */
+	WLAN_STATUS_ASSOC_DENIED_NOSHORTPREAMBLE = 19,
+	WLAN_STATUS_ASSOC_DENIED_NOPBCC = 20,
+	WLAN_STATUS_ASSOC_DENIED_NOAGILITY = 21,
+	/* 802.11h */
+	WLAN_STATUS_ASSOC_DENIED_NOSPECTRUM = 22,
+	WLAN_STATUS_ASSOC_REJECTED_BAD_POWER = 23,
+	WLAN_STATUS_ASSOC_REJECTED_BAD_SUPP_CHAN = 24,
+	/* 802.11g */
+	WLAN_STATUS_ASSOC_DENIED_NOSHORTTIME = 25,
+	WLAN_STATUS_ASSOC_DENIED_NODSSSOFDM = 26,
+	/* 802.11w */
+	WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY = 30,
+	WLAN_STATUS_ROBUST_MGMT_FRAME_POLICY_VIOLATION = 31,
+	/* 802.11i */
+	WLAN_STATUS_INVALID_IE = 40,
+	WLAN_STATUS_INVALID_GROUP_CIPHER = 41,
+	WLAN_STATUS_INVALID_PAIRWISE_CIPHER = 42,
+	WLAN_STATUS_INVALID_AKMP = 43,
+	WLAN_STATUS_UNSUPP_RSN_VERSION = 44,
+	WLAN_STATUS_INVALID_RSN_IE_CAP = 45,
+	WLAN_STATUS_CIPHER_SUITE_REJECTED = 46,
+	/* 802.11e */
+	WLAN_STATUS_UNSPECIFIED_QOS = 32,
+	WLAN_STATUS_ASSOC_DENIED_NOBANDWIDTH = 33,
+	WLAN_STATUS_ASSOC_DENIED_LOWACK = 34,
+	WLAN_STATUS_ASSOC_DENIED_UNSUPP_QOS = 35,
+	WLAN_STATUS_REQUEST_DECLINED = 37,
+	WLAN_STATUS_INVALID_QOS_PARAM = 38,
+	WLAN_STATUS_CHANGE_TSPEC = 39,
+	WLAN_STATUS_WAIT_TS_DELAY = 47,
+	WLAN_STATUS_NO_DIRECT_LINK = 48,
+	WLAN_STATUS_STA_NOT_PRESENT = 49,
+	WLAN_STATUS_STA_NOT_QSTA = 50,
+	/* 802.11s */
+	WLAN_STATUS_ANTI_CLOG_REQUIRED = 76,
+	WLAN_STATUS_FCG_NOT_SUPP = 78,
+	WLAN_STATUS_STA_NO_TBTT = 78,
+	/* 802.11ad */
+	WLAN_STATUS_REJECTED_WITH_SUGGESTED_CHANGES = 39,
+	WLAN_STATUS_REJECTED_FOR_DELAY_PERIOD = 47,
+	WLAN_STATUS_REJECT_WITH_SCHEDULE = 83,
+	WLAN_STATUS_PENDING_ADMITTING_FST_SESSION = 86,
+	WLAN_STATUS_PERFORMING_FST_NOW = 87,
+	WLAN_STATUS_PENDING_GAP_IN_BA_WINDOW = 88,
+	WLAN_STATUS_REJECT_U_PID_SETTING = 89,
+	WLAN_STATUS_REJECT_DSE_BAND = 96,
+	WLAN_STATUS_DENIED_WITH_SUGGESTED_BAND_AND_CHANNEL = 99,
+	WLAN_STATUS_DENIED_DUE_TO_SPECTRUM_MANAGEMENT = 103,
+	/* 802.11ai */
+	WLAN_STATUS_FILS_AUTHENTICATION_FAILURE = 108,
+	WLAN_STATUS_UNKNOWN_AUTHENTICATION_SERVER = 109,
+};
+
+
+/* Reason codes */
+enum ieee80211_reasoncode {
+	WLAN_REASON_UNSPECIFIED = 1,
+	WLAN_REASON_PREV_AUTH_NOT_VALID = 2,
+	WLAN_REASON_DEAUTH_LEAVING = 3,
+	WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY = 4,
+	WLAN_REASON_DISASSOC_AP_BUSY = 5,
+	WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA = 6,
+	WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA = 7,
+	WLAN_REASON_DISASSOC_STA_HAS_LEFT = 8,
+	WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH = 9,
+	/* 802.11h */
+	WLAN_REASON_DISASSOC_BAD_POWER = 10,
+	WLAN_REASON_DISASSOC_BAD_SUPP_CHAN = 11,
+	/* 802.11i */
+	WLAN_REASON_INVALID_IE = 13,
+	WLAN_REASON_MIC_FAILURE = 14,
+	WLAN_REASON_4WAY_HANDSHAKE_TIMEOUT = 15,
+	WLAN_REASON_GROUP_KEY_HANDSHAKE_TIMEOUT = 16,
+	WLAN_REASON_IE_DIFFERENT = 17,
+	WLAN_REASON_INVALID_GROUP_CIPHER = 18,
+	WLAN_REASON_INVALID_PAIRWISE_CIPHER = 19,
+	WLAN_REASON_INVALID_AKMP = 20,
+	WLAN_REASON_UNSUPP_RSN_VERSION = 21,
+	WLAN_REASON_INVALID_RSN_IE_CAP = 22,
+	WLAN_REASON_IEEE8021X_FAILED = 23,
+	WLAN_REASON_CIPHER_SUITE_REJECTED = 24,
+	/* TDLS (802.11z) */
+	WLAN_REASON_TDLS_TEARDOWN_UNREACHABLE = 25,
+	WLAN_REASON_TDLS_TEARDOWN_UNSPECIFIED = 26,
+	/* 802.11e */
+	WLAN_REASON_DISASSOC_UNSPECIFIED_QOS = 32,
+	WLAN_REASON_DISASSOC_QAP_NO_BANDWIDTH = 33,
+	WLAN_REASON_DISASSOC_LOW_ACK = 34,
+	WLAN_REASON_DISASSOC_QAP_EXCEED_TXOP = 35,
+	WLAN_REASON_QSTA_LEAVE_QBSS = 36,
+	WLAN_REASON_QSTA_NOT_USE = 37,
+	WLAN_REASON_QSTA_REQUIRE_SETUP = 38,
+	WLAN_REASON_QSTA_TIMEOUT = 39,
+	WLAN_REASON_QSTA_CIPHER_NOT_SUPP = 45,
+	/* 802.11s */
+	WLAN_REASON_MESH_PEER_CANCELED = 52,
+	WLAN_REASON_MESH_MAX_PEERS = 53,
+	WLAN_REASON_MESH_CONFIG = 54,
+	WLAN_REASON_MESH_CLOSE = 55,
+	WLAN_REASON_MESH_MAX_RETRIES = 56,
+	WLAN_REASON_MESH_CONFIRM_TIMEOUT = 57,
+	WLAN_REASON_MESH_INVALID_GTK = 58,
+	WLAN_REASON_MESH_INCONSISTENT_PARAM = 59,
+	WLAN_REASON_MESH_INVALID_SECURITY = 60,
+	WLAN_REASON_MESH_PATH_ERROR = 61,
+	WLAN_REASON_MESH_PATH_NOFORWARD = 62,
+	WLAN_REASON_MESH_PATH_DEST_UNREACHABLE = 63,
+	WLAN_REASON_MAC_EXISTS_IN_MBSS = 64,
+	WLAN_REASON_MESH_CHAN_REGULATORY = 65,
+	WLAN_REASON_MESH_CHAN = 66,
+};
+
+
+/* Information Element IDs */
+enum ieee80211_eid {
+	WLAN_EID_SSID = 0,
+	WLAN_EID_SUPP_RATES = 1,
+	WLAN_EID_FH_PARAMS = 2, /* reserved now */
+	WLAN_EID_DS_PARAMS = 3,
+	WLAN_EID_CF_PARAMS = 4,
+	WLAN_EID_TIM = 5,
+	WLAN_EID_IBSS_PARAMS = 6,
+	WLAN_EID_COUNTRY = 7,
+	/* 8, 9 reserved */
+	WLAN_EID_REQUEST = 10,
+	WLAN_EID_QBSS_LOAD = 11,
+	WLAN_EID_EDCA_PARAM_SET = 12,
+	WLAN_EID_TSPEC = 13,
+	WLAN_EID_TCLAS = 14,
+	WLAN_EID_SCHEDULE = 15,
+	WLAN_EID_CHALLENGE = 16,
+	/* 17-31 reserved for challenge text extension */
+	WLAN_EID_PWR_CONSTRAINT = 32,
+	WLAN_EID_PWR_CAPABILITY = 33,
+	WLAN_EID_TPC_REQUEST = 34,
+	WLAN_EID_TPC_REPORT = 35,
+	WLAN_EID_SUPPORTED_CHANNELS = 36,
+	WLAN_EID_CHANNEL_SWITCH = 37,
+	WLAN_EID_MEASURE_REQUEST = 38,
+	WLAN_EID_MEASURE_REPORT = 39,
+	WLAN_EID_QUIET = 40,
+	WLAN_EID_IBSS_DFS = 41,
+	WLAN_EID_ERP_INFO = 42,
+	WLAN_EID_TS_DELAY = 43,
+	WLAN_EID_TCLAS_PROCESSING = 44,
+	WLAN_EID_HT_CAPABILITY = 45,
+	WLAN_EID_QOS_CAPA = 46,
+	/* 47 reserved for Broadcom */
+	WLAN_EID_RSN = 48,
+	WLAN_EID_802_15_COEX = 49,
+	WLAN_EID_EXT_SUPP_RATES = 50,
+	WLAN_EID_AP_CHAN_REPORT = 51,
+	WLAN_EID_NEIGHBOR_REPORT = 52,
+	WLAN_EID_RCPI = 53,
+	WLAN_EID_MOBILITY_DOMAIN = 54,
+	WLAN_EID_FAST_BSS_TRANSITION = 55,
+	WLAN_EID_TIMEOUT_INTERVAL = 56,
+	WLAN_EID_RIC_DATA = 57,
+	WLAN_EID_DSE_REGISTERED_LOCATION = 58,
+	WLAN_EID_SUPPORTED_REGULATORY_CLASSES = 59,
+	WLAN_EID_EXT_CHANSWITCH_ANN = 60,
+	WLAN_EID_HT_OPERATION = 61,
+	WLAN_EID_SECONDARY_CHANNEL_OFFSET = 62,
+	WLAN_EID_BSS_AVG_ACCESS_DELAY = 63,
+	WLAN_EID_ANTENNA_INFO = 64,
+	WLAN_EID_RSNI = 65,
+	WLAN_EID_MEASUREMENT_PILOT_TX_INFO = 66,
+	WLAN_EID_BSS_AVAILABLE_CAPACITY = 67,
+	WLAN_EID_BSS_AC_ACCESS_DELAY = 68,
+	WLAN_EID_TIME_ADVERTISEMENT = 69,
+	WLAN_EID_RRM_ENABLED_CAPABILITIES = 70,
+	WLAN_EID_MULTIPLE_BSSID = 71,
+	WLAN_EID_BSS_COEX_2040 = 72,
+	WLAN_EID_BSS_INTOLERANT_CHL_REPORT = 73,
+	WLAN_EID_OVERLAP_BSS_SCAN_PARAM = 74,
+	WLAN_EID_RIC_DESCRIPTOR = 75,
+	WLAN_EID_MMIE = 76,
+	WLAN_EID_ASSOC_COMEBACK_TIME = 77,
+	WLAN_EID_EVENT_REQUEST = 78,
+	WLAN_EID_EVENT_REPORT = 79,
+	WLAN_EID_DIAGNOSTIC_REQUEST = 80,
+	WLAN_EID_DIAGNOSTIC_REPORT = 81,
+	WLAN_EID_LOCATION_PARAMS = 82,
+	WLAN_EID_NON_TX_BSSID_CAP =  83,
+	WLAN_EID_SSID_LIST = 84,
+	WLAN_EID_MULTI_BSSID_IDX = 85,
+	WLAN_EID_FMS_DESCRIPTOR = 86,
+	WLAN_EID_FMS_REQUEST = 87,
+	WLAN_EID_FMS_RESPONSE = 88,
+	WLAN_EID_QOS_TRAFFIC_CAPA = 89,
+	WLAN_EID_BSS_MAX_IDLE_PERIOD = 90,
+	WLAN_EID_TSF_REQUEST = 91,
+	WLAN_EID_TSF_RESPOSNE = 92,
+	WLAN_EID_WNM_SLEEP_MODE = 93,
+	WLAN_EID_TIM_BCAST_REQ = 94,
+	WLAN_EID_TIM_BCAST_RESP = 95,
+	WLAN_EID_COLL_IF_REPORT = 96,
+	WLAN_EID_CHANNEL_USAGE = 97,
+	WLAN_EID_TIME_ZONE = 98,
+	WLAN_EID_DMS_REQUEST = 99,
+	WLAN_EID_DMS_RESPONSE = 100,
+	WLAN_EID_LINK_ID = 101,
+	WLAN_EID_WAKEUP_SCHEDUL = 102,
+	/* 103 reserved */
+	WLAN_EID_CHAN_SWITCH_TIMING = 104,
+	WLAN_EID_PTI_CONTROL = 105,
+	WLAN_EID_PU_BUFFER_STATUS = 106,
+	WLAN_EID_INTERWORKING = 107,
+	WLAN_EID_ADVERTISEMENT_PROTOCOL = 108,
+	WLAN_EID_EXPEDITED_BW_REQ = 109,
+	WLAN_EID_QOS_MAP_SET = 110,
+	WLAN_EID_ROAMING_CONSORTIUM = 111,
+	WLAN_EID_EMERGENCY_ALERT = 112,
+	WLAN_EID_MESH_CONFIG = 113,
+	WLAN_EID_MESH_ID = 114,
+	WLAN_EID_LINK_METRIC_REPORT = 115,
+	WLAN_EID_CONGESTION_NOTIFICATION = 116,
+	WLAN_EID_PEER_MGMT = 117,
+	WLAN_EID_CHAN_SWITCH_PARAM = 118,
+	WLAN_EID_MESH_AWAKE_WINDOW = 119,
+	WLAN_EID_BEACON_TIMING = 120,
+	WLAN_EID_MCCAOP_SETUP_REQ = 121,
+	WLAN_EID_MCCAOP_SETUP_RESP = 122,
+	WLAN_EID_MCCAOP_ADVERT = 123,
+	WLAN_EID_MCCAOP_TEARDOWN = 124,
+	WLAN_EID_GANN = 125,
+	WLAN_EID_RANN = 126,
+	WLAN_EID_EXT_CAPABILITY = 127,
+	/* 128, 129 reserved for Agere */
+	WLAN_EID_PREQ = 130,
+	WLAN_EID_PREP = 131,
+	WLAN_EID_PERR = 132,
+	/* 133-136 reserved for Cisco */
+	WLAN_EID_PXU = 137,
+	WLAN_EID_PXUC = 138,
+	WLAN_EID_AUTH_MESH_PEER_EXCH = 139,
+	WLAN_EID_MIC = 140,
+	WLAN_EID_DESTINATION_URI = 141,
+	WLAN_EID_UAPSD_COEX = 142,
+	WLAN_EID_WAKEUP_SCHEDULE = 143,
+	WLAN_EID_EXT_SCHEDULE = 144,
+	WLAN_EID_STA_AVAILABILITY = 145,
+	WLAN_EID_DMG_TSPEC = 146,
+	WLAN_EID_DMG_AT = 147,
+	WLAN_EID_DMG_CAP = 148,
+	/* 149 reserved for Cisco */
+	WLAN_EID_CISCO_VENDOR_SPECIFIC = 150,
+	WLAN_EID_DMG_OPERATION = 151,
+	WLAN_EID_DMG_BSS_PARAM_CHANGE = 152,
+	WLAN_EID_DMG_BEAM_REFINEMENT = 153,
+	WLAN_EID_CHANNEL_MEASURE_FEEDBACK = 154,
+	/* 155-156 reserved for Cisco */
+	WLAN_EID_AWAKE_WINDOW = 157,
+	WLAN_EID_MULTI_BAND = 158,
+	WLAN_EID_ADDBA_EXT = 159,
+	WLAN_EID_NEXT_PCP_LIST = 160,
+	WLAN_EID_PCP_HANDOVER = 161,
+	WLAN_EID_DMG_LINK_MARGIN = 162,
+	WLAN_EID_SWITCHING_STREAM = 163,
+	WLAN_EID_SESSION_TRANSITION = 164,
+	WLAN_EID_DYN_TONE_PAIRING_REPORT = 165,
+	WLAN_EID_CLUSTER_REPORT = 166,
+	WLAN_EID_RELAY_CAP = 167,
+	WLAN_EID_RELAY_XFER_PARAM_SET = 168,
+	WLAN_EID_BEAM_LINK_MAINT = 169,
+	WLAN_EID_MULTIPLE_MAC_ADDR = 170,
+	WLAN_EID_U_PID = 171,
+	WLAN_EID_DMG_LINK_ADAPT_ACK = 172,
+	/* 173 reserved for Symbol */
+	WLAN_EID_MCCAOP_ADV_OVERVIEW = 174,
+	WLAN_EID_QUIET_PERIOD_REQ = 175,
+	/* 176 reserved for Symbol */
+	WLAN_EID_QUIET_PERIOD_RESP = 177,
+	/* 178-179 reserved for Symbol */
+	/* 180 reserved for ISO/IEC 20011 */
+	WLAN_EID_EPAC_POLICY = 182,
+	WLAN_EID_CLISTER_TIME_OFF = 183,
+	WLAN_EID_INTER_AC_PRIO = 184,
+	WLAN_EID_SCS_DESCRIPTOR = 185,
+	WLAN_EID_QLOAD_REPORT = 186,
+	WLAN_EID_HCCA_TXOP_UPDATE_COUNT = 187,
+	WLAN_EID_HL_STREAM_ID = 188,
+	WLAN_EID_GCR_GROUP_ADDR = 189,
+	WLAN_EID_ANTENNA_SECTOR_ID_PATTERN = 190,
+	WLAN_EID_VHT_CAPABILITY = 191,
+	WLAN_EID_VHT_OPERATION = 192,
+	WLAN_EID_EXTENDED_BSS_LOAD = 193,
+	WLAN_EID_WIDE_BW_CHANNEL_SWITCH = 194,
+	WLAN_EID_VHT_TX_POWER_ENVELOPE = 195,
+	WLAN_EID_CHANNEL_SWITCH_WRAPPER = 196,
+	WLAN_EID_AID = 197,
+	WLAN_EID_QUIET_CHANNEL = 198,
+	WLAN_EID_OPMODE_NOTIF = 199,
+
+	WLAN_EID_VENDOR_SPECIFIC = 221,
+	WLAN_EID_QOS_PARAMETER = 222,
+	WLAN_EID_CAG_NUMBER = 237,
+	WLAN_EID_AP_CSN = 239,
+	WLAN_EID_FILS_INDICATION = 240,
+	WLAN_EID_DILS = 241,
+	WLAN_EID_FRAGMENT = 242,
+	WLAN_EID_EXTENSION = 255,
+
+	WLAN_EID_HT_INFORMATION = 61,
+};
+
+/* Element ID Extensions for Element ID 255 */
+enum ieee80211_eid_ext {
+	WLAN_EID_EXT_ASSOC_DELAY_INFO = 1,
+	WLAN_EID_EXT_FILS_REQ_PARAMS = 2,
+	WLAN_EID_EXT_FILS_KEY_CONFIRM = 3,
+	WLAN_EID_EXT_FILS_SESSION = 4,
+	WLAN_EID_EXT_FILS_HLP_CONTAINER = 5,
+	WLAN_EID_EXT_FILS_IP_ADDR_ASSIGN = 6,
+	WLAN_EID_EXT_KEY_DELIVERY = 7,
+	WLAN_EID_EXT_FILS_WRAPPED_DATA = 8,
+	WLAN_EID_EXT_FILS_PUBLIC_KEY = 12,
+	WLAN_EID_EXT_FILS_NONCE = 13,
+	WLAN_EID_EXT_FUTURE_CHAN_GUIDANCE = 14,
+	WLAN_EID_EXT_HE_CAPABILITY = 35,
+	WLAN_EID_EXT_HE_OPERATION = 36,
+	WLAN_EID_EXT_UORA = 37,
+	WLAN_EID_EXT_HE_MU_EDCA = 38,
+	WLAN_EID_EXT_HE_SPR = 39,
+	WLAN_EID_EXT_NDP_FEEDBACK_REPORT_PARAMSET = 41,
+	WLAN_EID_EXT_BSS_COLOR_CHG_ANN = 42,
+	WLAN_EID_EXT_QUIET_TIME_PERIOD_SETUP = 43,
+	WLAN_EID_EXT_ESS_REPORT = 45,
+	WLAN_EID_EXT_OPS = 46,
+	WLAN_EID_EXT_HE_BSS_LOAD = 47,
+	WLAN_EID_EXT_MAX_CHANNEL_SWITCH_TIME = 52,
+	WLAN_EID_EXT_MULTIPLE_BSSID_CONFIGURATION = 55,
+	WLAN_EID_EXT_NON_INHERITANCE = 56,
+	WLAN_EID_EXT_KNOWN_BSSID = 57,
+	WLAN_EID_EXT_SHORT_SSID_LIST = 58,
+	WLAN_EID_EXT_HE_6GHZ_CAPA = 59,
+	WLAN_EID_EXT_UL_MU_POWER_CAPA = 60,
+};
+
+/* Action category code */
+enum ieee80211_category {
+	WLAN_CATEGORY_SPECTRUM_MGMT = 0,
+	WLAN_CATEGORY_QOS = 1,
+	WLAN_CATEGORY_DLS = 2,
+	WLAN_CATEGORY_BACK = 3,
+	WLAN_CATEGORY_PUBLIC = 4,
+	WLAN_CATEGORY_RADIO_MEASUREMENT = 5,
+	WLAN_CATEGORY_HT = 7,
+	WLAN_CATEGORY_SA_QUERY = 8,
+	WLAN_CATEGORY_PROTECTED_DUAL_OF_ACTION = 9,
+	WLAN_CATEGORY_WNM = 10,
+	WLAN_CATEGORY_WNM_UNPROTECTED = 11,
+	WLAN_CATEGORY_TDLS = 12,
+	WLAN_CATEGORY_MESH_ACTION = 13,
+	WLAN_CATEGORY_MULTIHOP_ACTION = 14,
+	WLAN_CATEGORY_SELF_PROTECTED = 15,
+	WLAN_CATEGORY_DMG = 16,
+	WLAN_CATEGORY_WMM = 17,
+	WLAN_CATEGORY_FST = 18,
+	WLAN_CATEGORY_UNPROT_DMG = 20,
+	WLAN_CATEGORY_VHT = 21,
+	WLAN_CATEGORY_VENDOR_SPECIFIC_PROTECTED = 126,
+	WLAN_CATEGORY_VENDOR_SPECIFIC = 127,
+};
+
+/* SPECTRUM_MGMT action code */
+enum ieee80211_spectrum_mgmt_actioncode {
+	WLAN_ACTION_SPCT_MSR_REQ = 0,
+	WLAN_ACTION_SPCT_MSR_RPRT = 1,
+	WLAN_ACTION_SPCT_TPC_REQ = 2,
+	WLAN_ACTION_SPCT_TPC_RPRT = 3,
+	WLAN_ACTION_SPCT_CHL_SWITCH = 4,
+};
+
+/* HT action codes */
+enum ieee80211_ht_actioncode {
+	WLAN_HT_ACTION_NOTIFY_CHANWIDTH = 0,
+	WLAN_HT_ACTION_SMPS = 1,
+	WLAN_HT_ACTION_PSMP = 2,
+	WLAN_HT_ACTION_PCO_PHASE = 3,
+	WLAN_HT_ACTION_CSI = 4,
+	WLAN_HT_ACTION_NONCOMPRESSED_BF = 5,
+	WLAN_HT_ACTION_COMPRESSED_BF = 6,
+	WLAN_HT_ACTION_ASEL_IDX_FEEDBACK = 7,
+};
+
+/* VHT action codes */
+enum ieee80211_vht_actioncode {
+	WLAN_VHT_ACTION_COMPRESSED_BF = 0,
+	WLAN_VHT_ACTION_GROUPID_MGMT = 1,
+	WLAN_VHT_ACTION_OPMODE_NOTIF = 2,
+};
+
+/* Self Protected Action codes */
+enum ieee80211_self_protected_actioncode {
+	WLAN_SP_RESERVED = 0,
+	WLAN_SP_MESH_PEERING_OPEN = 1,
+	WLAN_SP_MESH_PEERING_CONFIRM = 2,
+	WLAN_SP_MESH_PEERING_CLOSE = 3,
+	WLAN_SP_MGK_INFORM = 4,
+	WLAN_SP_MGK_ACK = 5,
+};
+
+/* Mesh action codes */
+enum ieee80211_mesh_actioncode {
+	WLAN_MESH_ACTION_LINK_METRIC_REPORT,
+	WLAN_MESH_ACTION_HWMP_PATH_SELECTION,
+	WLAN_MESH_ACTION_GATE_ANNOUNCEMENT,
+	WLAN_MESH_ACTION_CONGESTION_CONTROL_NOTIFICATION,
+	WLAN_MESH_ACTION_MCCA_SETUP_REQUEST,
+	WLAN_MESH_ACTION_MCCA_SETUP_REPLY,
+	WLAN_MESH_ACTION_MCCA_ADVERTISEMENT_REQUEST,
+	WLAN_MESH_ACTION_MCCA_ADVERTISEMENT,
+	WLAN_MESH_ACTION_MCCA_TEARDOWN,
+	WLAN_MESH_ACTION_TBTT_ADJUSTMENT_REQUEST,
+	WLAN_MESH_ACTION_TBTT_ADJUSTMENT_RESPONSE,
+};
+
+/* Security key length */
+enum ieee80211_key_len {
+	WLAN_KEY_LEN_WEP40 = 5,
+	WLAN_KEY_LEN_WEP104 = 13,
+	WLAN_KEY_LEN_CCMP = 16,
+	WLAN_KEY_LEN_CCMP_256 = 32,
+	WLAN_KEY_LEN_TKIP = 32,
+	WLAN_KEY_LEN_AES_CMAC = 16,
+	WLAN_KEY_LEN_SMS4 = 32,
+	WLAN_KEY_LEN_GCMP = 16,
+	WLAN_KEY_LEN_GCMP_256 = 32,
+	WLAN_KEY_LEN_BIP_CMAC_256 = 32,
+	WLAN_KEY_LEN_BIP_GMAC_128 = 16,
+	WLAN_KEY_LEN_BIP_GMAC_256 = 32,
+};
+
+#define IEEE80211_WEP_IV_LEN		4
+#define IEEE80211_WEP_ICV_LEN		4
+#define IEEE80211_CCMP_HDR_LEN		8
+#define IEEE80211_CCMP_MIC_LEN		8
+#define IEEE80211_CCMP_PN_LEN		6
+#define IEEE80211_CCMP_256_HDR_LEN	8
+#define IEEE80211_CCMP_256_MIC_LEN	16
+#define IEEE80211_CCMP_256_PN_LEN	6
+#define IEEE80211_TKIP_IV_LEN		8
+#define IEEE80211_TKIP_ICV_LEN		4
+#define IEEE80211_CMAC_PN_LEN		6
+#define IEEE80211_GMAC_PN_LEN		6
+#define IEEE80211_GCMP_HDR_LEN		8
+#define IEEE80211_GCMP_MIC_LEN		16
+#define IEEE80211_GCMP_PN_LEN		6
+
+#define FILS_NONCE_LEN			16
+#define FILS_MAX_KEK_LEN		64
+
+#define FILS_ERP_MAX_USERNAME_LEN	16
+#define FILS_ERP_MAX_REALM_LEN		253
+#define FILS_ERP_MAX_RRK_LEN		64
+
+#define PMK_MAX_LEN			64
+#define SAE_PASSWORD_MAX_LEN		128
+
+/* Public action codes (IEEE Std 802.11-2016, 9.6.8.1, Table 9-307) */
+enum ieee80211_pub_actioncode {
+	WLAN_PUB_ACTION_20_40_BSS_COEX = 0,
+	WLAN_PUB_ACTION_DSE_ENABLEMENT = 1,
+	WLAN_PUB_ACTION_DSE_DEENABLEMENT = 2,
+	WLAN_PUB_ACTION_DSE_REG_LOC_ANN = 3,
+	WLAN_PUB_ACTION_EXT_CHANSW_ANN = 4,
+	WLAN_PUB_ACTION_DSE_MSMT_REQ = 5,
+	WLAN_PUB_ACTION_DSE_MSMT_RESP = 6,
+	WLAN_PUB_ACTION_MSMT_PILOT = 7,
+	WLAN_PUB_ACTION_DSE_PC = 8,
+	WLAN_PUB_ACTION_VENDOR_SPECIFIC = 9,
+	WLAN_PUB_ACTION_GAS_INITIAL_REQ = 10,
+	WLAN_PUB_ACTION_GAS_INITIAL_RESP = 11,
+	WLAN_PUB_ACTION_GAS_COMEBACK_REQ = 12,
+	WLAN_PUB_ACTION_GAS_COMEBACK_RESP = 13,
+	WLAN_PUB_ACTION_TDLS_DISCOVER_RES = 14,
+	WLAN_PUB_ACTION_LOC_TRACK_NOTI = 15,
+	WLAN_PUB_ACTION_QAB_REQUEST_FRAME = 16,
+	WLAN_PUB_ACTION_QAB_RESPONSE_FRAME = 17,
+	WLAN_PUB_ACTION_QMF_POLICY = 18,
+	WLAN_PUB_ACTION_QMF_POLICY_CHANGE = 19,
+	WLAN_PUB_ACTION_QLOAD_REQUEST = 20,
+	WLAN_PUB_ACTION_QLOAD_REPORT = 21,
+	WLAN_PUB_ACTION_HCCA_TXOP_ADVERT = 22,
+	WLAN_PUB_ACTION_HCCA_TXOP_RESPONSE = 23,
+	WLAN_PUB_ACTION_PUBLIC_KEY = 24,
+	WLAN_PUB_ACTION_CHANNEL_AVAIL_QUERY = 25,
+	WLAN_PUB_ACTION_CHANNEL_SCHEDULE_MGMT = 26,
+	WLAN_PUB_ACTION_CONTACT_VERI_SIGNAL = 27,
+	WLAN_PUB_ACTION_GDD_ENABLEMENT_REQ = 28,
+	WLAN_PUB_ACTION_GDD_ENABLEMENT_RESP = 29,
+	WLAN_PUB_ACTION_NETWORK_CHANNEL_CONTROL = 30,
+	WLAN_PUB_ACTION_WHITE_SPACE_MAP_ANN = 31,
+	WLAN_PUB_ACTION_FTM_REQUEST = 32,
+	WLAN_PUB_ACTION_FTM = 33,
+	WLAN_PUB_ACTION_FILS_DISCOVERY = 34,
+};
+
+/* TDLS action codes */
+enum ieee80211_tdls_actioncode {
+	WLAN_TDLS_SETUP_REQUEST = 0,
+	WLAN_TDLS_SETUP_RESPONSE = 1,
+	WLAN_TDLS_SETUP_CONFIRM = 2,
+	WLAN_TDLS_TEARDOWN = 3,
+	WLAN_TDLS_PEER_TRAFFIC_INDICATION = 4,
+	WLAN_TDLS_CHANNEL_SWITCH_REQUEST = 5,
+	WLAN_TDLS_CHANNEL_SWITCH_RESPONSE = 6,
+	WLAN_TDLS_PEER_PSM_REQUEST = 7,
+	WLAN_TDLS_PEER_PSM_RESPONSE = 8,
+	WLAN_TDLS_PEER_TRAFFIC_RESPONSE = 9,
+	WLAN_TDLS_DISCOVERY_REQUEST = 10,
+};
+
+/* Extended Channel Switching capability to be set in the 1st byte of
+ * the @WLAN_EID_EXT_CAPABILITY information element
+ */
+#define WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING	BIT(2)
+
+/* Multiple BSSID capability is set in the 6th bit of 3rd byte of the
+ * @WLAN_EID_EXT_CAPABILITY information element
+ */
+#define WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT	BIT(6)
+
+/* TDLS capabilities in the the 4th byte of @WLAN_EID_EXT_CAPABILITY */
+#define WLAN_EXT_CAPA4_TDLS_BUFFER_STA		BIT(4)
+#define WLAN_EXT_CAPA4_TDLS_PEER_PSM		BIT(5)
+#define WLAN_EXT_CAPA4_TDLS_CHAN_SWITCH		BIT(6)
+
+/* Interworking capabilities are set in 7th bit of 4th byte of the
+ * @WLAN_EID_EXT_CAPABILITY information element
+ */
+#define WLAN_EXT_CAPA4_INTERWORKING_ENABLED	BIT(7)
+
+/*
+ * TDLS capabililites to be enabled in the 5th byte of the
+ * @WLAN_EID_EXT_CAPABILITY information element
+ */
+#define WLAN_EXT_CAPA5_TDLS_ENABLED	BIT(5)
+#define WLAN_EXT_CAPA5_TDLS_PROHIBITED	BIT(6)
+#define WLAN_EXT_CAPA5_TDLS_CH_SW_PROHIBITED	BIT(7)
+
+#define WLAN_EXT_CAPA8_TDLS_WIDE_BW_ENABLED	BIT(5)
+#define WLAN_EXT_CAPA8_OPMODE_NOTIF	BIT(6)
+
+/* Defines the maximal number of MSDUs in an A-MSDU. */
+#define WLAN_EXT_CAPA8_MAX_MSDU_IN_AMSDU_LSB	BIT(7)
+#define WLAN_EXT_CAPA9_MAX_MSDU_IN_AMSDU_MSB	BIT(0)
+
+/*
+ * Fine Timing Measurement Initiator - bit 71 of @WLAN_EID_EXT_CAPABILITY
+ * information element
+ */
+#define WLAN_EXT_CAPA9_FTM_INITIATOR	BIT(7)
+
+/* Defines support for TWT Requester and TWT Responder */
+#define WLAN_EXT_CAPA10_TWT_REQUESTER_SUPPORT	BIT(5)
+#define WLAN_EXT_CAPA10_TWT_RESPONDER_SUPPORT	BIT(6)
+
+/*
+ * When set, indicates that the AP is able to tolerate 26-tone RU UL
+ * OFDMA transmissions using HE TB PPDU from OBSS (not falsely classify the
+ * 26-tone RU UL OFDMA transmissions as radar pulses).
+ */
+#define WLAN_EXT_CAPA10_OBSS_NARROW_BW_RU_TOLERANCE_SUPPORT BIT(7)
+
+/* Defines support for enhanced multi-bssid advertisement*/
+#define WLAN_EXT_CAPA11_EMA_SUPPORT	BIT(1)
+
+/* TDLS specific payload type in the LLC/SNAP header */
+#define WLAN_TDLS_SNAP_RFTYPE	0x2
+
+/* BSS Coex IE information field bits */
+#define WLAN_BSS_COEX_INFORMATION_REQUEST	BIT(0)
+
+/**
+ * enum ieee80211_mesh_sync_method - mesh synchronization method identifier
+ *
+ * @IEEE80211_SYNC_METHOD_NEIGHBOR_OFFSET: the default synchronization method
+ * @IEEE80211_SYNC_METHOD_VENDOR: a vendor specific synchronization method
+ *	that will be specified in a vendor specific information element
+ */
+enum ieee80211_mesh_sync_method {
+	IEEE80211_SYNC_METHOD_NEIGHBOR_OFFSET = 1,
+	IEEE80211_SYNC_METHOD_VENDOR = 255,
+};
+
+/**
+ * enum ieee80211_mesh_path_protocol - mesh path selection protocol identifier
+ *
+ * @IEEE80211_PATH_PROTOCOL_HWMP: the default path selection protocol
+ * @IEEE80211_PATH_PROTOCOL_VENDOR: a vendor specific protocol that will
+ *	be specified in a vendor specific information element
+ */
+enum ieee80211_mesh_path_protocol {
+	IEEE80211_PATH_PROTOCOL_HWMP = 1,
+	IEEE80211_PATH_PROTOCOL_VENDOR = 255,
+};
+
+/**
+ * enum ieee80211_mesh_path_metric - mesh path selection metric identifier
+ *
+ * @IEEE80211_PATH_METRIC_AIRTIME: the default path selection metric
+ * @IEEE80211_PATH_METRIC_VENDOR: a vendor specific metric that will be
+ *	specified in a vendor specific information element
+ */
+enum ieee80211_mesh_path_metric {
+	IEEE80211_PATH_METRIC_AIRTIME = 1,
+	IEEE80211_PATH_METRIC_VENDOR = 255,
+};
+
+/**
+ * enum ieee80211_root_mode_identifier - root mesh STA mode identifier
+ *
+ * These attribute are used by dot11MeshHWMPRootMode to set root mesh STA mode
+ *
+ * @IEEE80211_ROOTMODE_NO_ROOT: the mesh STA is not a root mesh STA (default)
+ * @IEEE80211_ROOTMODE_ROOT: the mesh STA is a root mesh STA if greater than
+ *	this value
+ * @IEEE80211_PROACTIVE_PREQ_NO_PREP: the mesh STA is a root mesh STA supports
+ *	the proactive PREQ with proactive PREP subfield set to 0
+ * @IEEE80211_PROACTIVE_PREQ_WITH_PREP: the mesh STA is a root mesh STA
+ *	supports the proactive PREQ with proactive PREP subfield set to 1
+ * @IEEE80211_PROACTIVE_RANN: the mesh STA is a root mesh STA supports
+ *	the proactive RANN
+ */
+enum ieee80211_root_mode_identifier {
+	IEEE80211_ROOTMODE_NO_ROOT = 0,
+	IEEE80211_ROOTMODE_ROOT = 1,
+	IEEE80211_PROACTIVE_PREQ_NO_PREP = 2,
+	IEEE80211_PROACTIVE_PREQ_WITH_PREP = 3,
+	IEEE80211_PROACTIVE_RANN = 4,
+};
+
+/*
+ * IEEE 802.11-2007 7.3.2.9 Country information element
+ *
+ * Minimum length is 8 octets, ie len must be evenly
+ * divisible by 2
+ */
+
+/* Although the spec says 8 I'm seeing 6 in practice */
+#define IEEE80211_COUNTRY_IE_MIN_LEN	6
+
+/* The Country String field of the element shall be 3 octets in length */
+#define IEEE80211_COUNTRY_STRING_LEN	3
+
+/*
+ * For regulatory extension stuff see IEEE 802.11-2007
+ * Annex I (page 1141) and Annex J (page 1147). Also
+ * review 7.3.2.9.
+ *
+ * When dot11RegulatoryClassesRequired is true and the
+ * first_channel/reg_extension_id is >= 201 then the IE
+ * compromises of the 'ext' struct represented below:
+ *
+ *  - Regulatory extension ID - when generating IE this just needs
+ *    to be monotonically increasing for each triplet passed in
+ *    the IE
+ *  - Regulatory class - index into set of rules
+ *  - Coverage class - index into air propagation time (Table 7-27),
+ *    in microseconds, you can compute the air propagation time from
+ *    the index by multiplying by 3, so index 10 yields a propagation
+ *    of 10 us. Valid values are 0-31, values 32-255 are not defined
+ *    yet. A value of 0 inicates air propagation of <= 1 us.
+ *
+ *  See also Table I.2 for Emission limit sets and table
+ *  I.3 for Behavior limit sets. Table J.1 indicates how to map
+ *  a reg_class to an emission limit set and behavior limit set.
+ */
+#define IEEE80211_COUNTRY_EXTENSION_ID 201
+
+/*
+ *  Channels numbers in the IE must be monotonically increasing
+ *  if dot11RegulatoryClassesRequired is not true.
+ *
+ *  If dot11RegulatoryClassesRequired is true consecutive
+ *  subband triplets following a regulatory triplet shall
+ *  have monotonically increasing first_channel number fields.
+ *
+ *  Channel numbers shall not overlap.
+ *
+ *  Note that max_power is signed.
+ */
+struct ieee80211_country_ie_triplet {
+	union {
+		struct {
+			u8 first_channel;
+			u8 num_channels;
+			s8 max_power;
+		} __packed chans;
+		struct {
+			u8 reg_extension_id;
+			u8 reg_class;
+			u8 coverage_class;
+		} __packed ext;
+	};
+} __packed;
+
+enum ieee80211_timeout_interval_type {
+	WLAN_TIMEOUT_REASSOC_DEADLINE = 1 /* 802.11r */,
+	WLAN_TIMEOUT_KEY_LIFETIME = 2 /* 802.11r */,
+	WLAN_TIMEOUT_ASSOC_COMEBACK = 3 /* 802.11w */,
+};
+
+/**
+ * struct ieee80211_timeout_interval_ie - Timeout Interval element
+ * @type: type, see &enum ieee80211_timeout_interval_type
+ * @value: timeout interval value
+ */
+struct ieee80211_timeout_interval_ie {
+	u8 type;
+	__le32 value;
+} __packed;
+
+/**
+ * enum ieee80211_idle_options - BSS idle options
+ * @WLAN_IDLE_OPTIONS_PROTECTED_KEEP_ALIVE: the station should send an RSN
+ *	protected frame to the AP to reset the idle timer at the AP for
+ *	the station.
+ */
+enum ieee80211_idle_options {
+	WLAN_IDLE_OPTIONS_PROTECTED_KEEP_ALIVE = BIT(0),
+};
+
+/**
+ * struct ieee80211_bss_max_idle_period_ie
+ *
+ * This structure refers to "BSS Max idle period element"
+ *
+ * @max_idle_period: indicates the time period during which a station can
+ *	refrain from transmitting frames to its associated AP without being
+ *	disassociated. In units of 1000 TUs.
+ * @idle_options: indicates the options associated with the BSS idle capability
+ *	as specified in &enum ieee80211_idle_options.
+ */
+struct ieee80211_bss_max_idle_period_ie {
+	__le16 max_idle_period;
+	u8 idle_options;
+} __packed;
+
+/* BACK action code */
+enum ieee80211_back_actioncode {
+	WLAN_ACTION_ADDBA_REQ = 0,
+	WLAN_ACTION_ADDBA_RESP = 1,
+	WLAN_ACTION_DELBA = 2,
+};
+
+/* BACK (block-ack) parties */
+enum ieee80211_back_parties {
+	WLAN_BACK_RECIPIENT = 0,
+	WLAN_BACK_INITIATOR = 1,
+};
+
+/* SA Query action */
+enum ieee80211_sa_query_action {
+	WLAN_ACTION_SA_QUERY_REQUEST = 0,
+	WLAN_ACTION_SA_QUERY_RESPONSE = 1,
+};
+
+/**
+ * struct ieee80211_bssid_index
+ *
+ * This structure refers to "Multiple BSSID-index element"
+ *
+ * @bssid_index: BSSID index
+ * @dtim_period: optional, overrides transmitted BSS dtim period
+ * @dtim_count: optional, overrides transmitted BSS dtim count
+ */
+struct ieee80211_bssid_index {
+	u8 bssid_index;
+	u8 dtim_period;
+	u8 dtim_count;
+};
+
+/**
+ * struct ieee80211_multiple_bssid_configuration
+ *
+ * This structure refers to "Multiple BSSID Configuration element"
+ *
+ * @bssid_count: total number of active BSSIDs in the set
+ * @profile_periodicity: the least number of beacon frames need to be received
+ *	in order to discover all the nontransmitted BSSIDs in the set.
+ */
+struct ieee80211_multiple_bssid_configuration {
+	u8 bssid_count;
+	u8 profile_periodicity;
+};
+
+#define SUITE(oui, id)	(((oui) << 8) | (id))
+
+/* cipher suite selectors */
+#define WLAN_CIPHER_SUITE_USE_GROUP	SUITE(0x000FAC, 0)
+#define WLAN_CIPHER_SUITE_WEP40		SUITE(0x000FAC, 1)
+#define WLAN_CIPHER_SUITE_TKIP		SUITE(0x000FAC, 2)
+/* reserved: 				SUITE(0x000FAC, 3) */
+#define WLAN_CIPHER_SUITE_CCMP		SUITE(0x000FAC, 4)
+#define WLAN_CIPHER_SUITE_WEP104	SUITE(0x000FAC, 5)
+#define WLAN_CIPHER_SUITE_AES_CMAC	SUITE(0x000FAC, 6)
+#define WLAN_CIPHER_SUITE_GCMP		SUITE(0x000FAC, 8)
+#define WLAN_CIPHER_SUITE_GCMP_256	SUITE(0x000FAC, 9)
+#define WLAN_CIPHER_SUITE_CCMP_256	SUITE(0x000FAC, 10)
+#define WLAN_CIPHER_SUITE_BIP_GMAC_128	SUITE(0x000FAC, 11)
+#define WLAN_CIPHER_SUITE_BIP_GMAC_256	SUITE(0x000FAC, 12)
+#define WLAN_CIPHER_SUITE_BIP_CMAC_256	SUITE(0x000FAC, 13)
+
+#define WLAN_CIPHER_SUITE_SMS4		SUITE(0x001472, 1)
+
+/* AKM suite selectors */
+#define WLAN_AKM_SUITE_8021X			SUITE(0x000FAC, 1)
+#define WLAN_AKM_SUITE_PSK			SUITE(0x000FAC, 2)
+#define WLAN_AKM_SUITE_FT_8021X			SUITE(0x000FAC, 3)
+#define WLAN_AKM_SUITE_FT_PSK			SUITE(0x000FAC, 4)
+#define WLAN_AKM_SUITE_8021X_SHA256		SUITE(0x000FAC, 5)
+#define WLAN_AKM_SUITE_PSK_SHA256		SUITE(0x000FAC, 6)
+#define WLAN_AKM_SUITE_TDLS			SUITE(0x000FAC, 7)
+#define WLAN_AKM_SUITE_SAE			SUITE(0x000FAC, 8)
+#define WLAN_AKM_SUITE_FT_OVER_SAE		SUITE(0x000FAC, 9)
+#define WLAN_AKM_SUITE_8021X_SUITE_B		SUITE(0x000FAC, 11)
+#define WLAN_AKM_SUITE_8021X_SUITE_B_192	SUITE(0x000FAC, 12)
+#define WLAN_AKM_SUITE_FILS_SHA256		SUITE(0x000FAC, 14)
+#define WLAN_AKM_SUITE_FILS_SHA384		SUITE(0x000FAC, 15)
+#define WLAN_AKM_SUITE_FT_FILS_SHA256		SUITE(0x000FAC, 16)
+#define WLAN_AKM_SUITE_FT_FILS_SHA384		SUITE(0x000FAC, 17)
+
+#define WLAN_MAX_KEY_LEN		32
+
+#define WLAN_PMK_NAME_LEN		16
+#define WLAN_PMKID_LEN			16
+#define WLAN_PMK_LEN_EAP_LEAP		16
+#define WLAN_PMK_LEN			32
+#define WLAN_PMK_LEN_SUITE_B_192	48
+
+#define WLAN_OUI_WFA			0x506f9a
+#define WLAN_OUI_TYPE_WFA_P2P		9
+#define WLAN_OUI_MICROSOFT		0x0050f2
+#define WLAN_OUI_TYPE_MICROSOFT_WPA	1
+#define WLAN_OUI_TYPE_MICROSOFT_WMM	2
+#define WLAN_OUI_TYPE_MICROSOFT_WPS	4
+#define WLAN_OUI_TYPE_MICROSOFT_TPC	8
+
+/*
+ * WMM/802.11e Tspec Element
+ */
+#define IEEE80211_WMM_IE_TSPEC_TID_MASK		0x0F
+#define IEEE80211_WMM_IE_TSPEC_TID_SHIFT	1
+
+enum ieee80211_tspec_status_code {
+	IEEE80211_TSPEC_STATUS_ADMISS_ACCEPTED = 0,
+	IEEE80211_TSPEC_STATUS_ADDTS_INVAL_PARAMS = 0x1,
+};
+
+struct ieee80211_tspec_ie {
+	u8 element_id;
+	u8 len;
+	u8 oui[3];
+	u8 oui_type;
+	u8 oui_subtype;
+	u8 version;
+	__le16 tsinfo;
+	u8 tsinfo_resvd;
+	__le16 nominal_msdu;
+	__le16 max_msdu;
+	__le32 min_service_int;
+	__le32 max_service_int;
+	__le32 inactivity_int;
+	__le32 suspension_int;
+	__le32 service_start_time;
+	__le32 min_data_rate;
+	__le32 mean_data_rate;
+	__le32 peak_data_rate;
+	__le32 max_burst_size;
+	__le32 delay_bound;
+	__le32 min_phy_rate;
+	__le16 sba;
+	__le16 medium_time;
+} __packed;
+
+struct ieee80211_he_6ghz_capa {
+	/* uses IEEE80211_HE_6GHZ_CAP_* below */
+	__le16 capa;
+} __packed;
+
+/* HE 6 GHz band capabilities */
+/* uses enum ieee80211_min_mpdu_spacing values */
+#define IEEE80211_HE_6GHZ_CAP_MIN_MPDU_START	0x0007
+/* uses enum ieee80211_vht_max_ampdu_length_exp values */
+#define IEEE80211_HE_6GHZ_CAP_MAX_AMPDU_LEN_EXP	0x0038
+/* uses IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_* values */
+#define IEEE80211_HE_6GHZ_CAP_MAX_MPDU_LEN	0x00c0
+/* WLAN_HT_CAP_SM_PS_* values */
+#define IEEE80211_HE_6GHZ_CAP_SM_PS		0x0600
+#define IEEE80211_HE_6GHZ_CAP_RD_RESPONDER	0x0800
+#define IEEE80211_HE_6GHZ_CAP_RX_ANTPAT_CONS	0x1000
+#define IEEE80211_HE_6GHZ_CAP_TX_ANTPAT_CONS	0x2000
+
+/**
+ * ieee80211_get_qos_ctl - get pointer to qos control bytes
+ * @hdr: the frame
+ *
+ * The qos ctrl bytes come after the frame_control, duration, seq_num
+ * and 3 or 4 addresses of length ETH_ALEN.
+ * 3 addr: 2 + 2 + 2 + 3*6 = 24
+ * 4 addr: 2 + 2 + 2 + 4*6 = 30
+ */
+static inline u8 *ieee80211_get_qos_ctl(struct ieee80211_hdr *hdr)
+{
+	if (ieee80211_has_a4(hdr->frame_control))
+		return (u8 *)hdr + 30;
+	else
+		return (u8 *)hdr + 24;
+}
+
+/**
+ * ieee80211_get_tid - get qos TID
+ * @hdr: the frame
+ */
+static inline u8 ieee80211_get_tid(struct ieee80211_hdr *hdr)
+{
+	u8 *qc = ieee80211_get_qos_ctl(hdr);
+
+	return qc[0] & IEEE80211_QOS_CTL_TID_MASK;
+}
+
+/**
+ * ieee80211_get_SA - get pointer to SA
+ * @hdr: the frame
+ *
+ * Given an 802.11 frame, this function returns the offset
+ * to the source address (SA). It does not verify that the
+ * header is long enough to contain the address, and the
+ * header must be long enough to contain the frame control
+ * field.
+ */
+static inline u8 *ieee80211_get_SA(struct ieee80211_hdr *hdr)
+{
+	if (ieee80211_has_a4(hdr->frame_control))
+		return hdr->addr4;
+	if (ieee80211_has_fromds(hdr->frame_control))
+		return hdr->addr3;
+	return hdr->addr2;
+}
+
+/**
+ * ieee80211_get_DA - get pointer to DA
+ * @hdr: the frame
+ *
+ * Given an 802.11 frame, this function returns the offset
+ * to the destination address (DA). It does not verify that
+ * the header is long enough to contain the address, and the
+ * header must be long enough to contain the frame control
+ * field.
+ */
+static inline u8 *ieee80211_get_DA(struct ieee80211_hdr *hdr)
+{
+	if (ieee80211_has_tods(hdr->frame_control))
+		return hdr->addr3;
+	else
+		return hdr->addr1;
+}
+
+/**
+ * _ieee80211_is_robust_mgmt_frame - check if frame is a robust management frame
+ * @hdr: the frame (buffer must include at least the first octet of payload)
+ */
+static inline bool _ieee80211_is_robust_mgmt_frame(struct ieee80211_hdr *hdr)
+{
+	if (ieee80211_is_disassoc(hdr->frame_control) ||
+	    ieee80211_is_deauth(hdr->frame_control))
+		return true;
+
+	if (ieee80211_is_action(hdr->frame_control)) {
+		u8 *category;
+
+		/*
+		 * Action frames, excluding Public Action frames, are Robust
+		 * Management Frames. However, if we are looking at a Protected
+		 * frame, skip the check since the data may be encrypted and
+		 * the frame has already been found to be a Robust Management
+		 * Frame (by the other end).
+		 */
+		if (ieee80211_has_protected(hdr->frame_control))
+			return true;
+		category = ((u8 *) hdr) + 24;
+		return *category != WLAN_CATEGORY_PUBLIC &&
+			*category != WLAN_CATEGORY_HT &&
+			*category != WLAN_CATEGORY_WNM_UNPROTECTED &&
+			*category != WLAN_CATEGORY_SELF_PROTECTED &&
+			*category != WLAN_CATEGORY_UNPROT_DMG &&
+			*category != WLAN_CATEGORY_VHT &&
+			*category != WLAN_CATEGORY_VENDOR_SPECIFIC;
+	}
+
+	return false;
+}
+
+/**
+ * ieee80211_is_robust_mgmt_frame - check if skb contains a robust mgmt frame
+ * @skb: the skb containing the frame, length will be checked
+ */
+static inline bool ieee80211_is_robust_mgmt_frame(struct sk_buff *skb)
+{
+	if (skb->len < IEEE80211_MIN_ACTION_SIZE)
+		return false;
+	return _ieee80211_is_robust_mgmt_frame((void *)skb->data);
+}
+
+/**
+ * ieee80211_is_public_action - check if frame is a public action frame
+ * @hdr: the frame
+ * @len: length of the frame
+ */
+static inline bool ieee80211_is_public_action(struct ieee80211_hdr *hdr,
+					      size_t len)
+{
+	struct ieee80211_mgmt *mgmt = (void *)hdr;
+
+	if (len < IEEE80211_MIN_ACTION_SIZE)
+		return false;
+	if (!ieee80211_is_action(hdr->frame_control))
+		return false;
+	return mgmt->u.action.category == WLAN_CATEGORY_PUBLIC;
+}
+
+/**
+ * _ieee80211_is_group_privacy_action - check if frame is a group addressed
+ * privacy action frame
+ * @hdr: the frame
+ */
+static inline bool _ieee80211_is_group_privacy_action(struct ieee80211_hdr *hdr)
+{
+	struct ieee80211_mgmt *mgmt = (void *)hdr;
+
+	if (!ieee80211_is_action(hdr->frame_control) ||
+	    !is_multicast_ether_addr(hdr->addr1))
+		return false;
+
+	return mgmt->u.action.category == WLAN_CATEGORY_MESH_ACTION ||
+	       mgmt->u.action.category == WLAN_CATEGORY_MULTIHOP_ACTION;
+}
+
+/**
+ * ieee80211_is_group_privacy_action - check if frame is a group addressed
+ * privacy action frame
+ * @skb: the skb containing the frame, length will be checked
+ */
+static inline bool ieee80211_is_group_privacy_action(struct sk_buff *skb)
+{
+	if (skb->len < IEEE80211_MIN_ACTION_SIZE)
+		return false;
+	return _ieee80211_is_group_privacy_action((void *)skb->data);
+}
+
+/**
+ * ieee80211_tu_to_usec - convert time units (TU) to microseconds
+ * @tu: the TUs
+ */
+static inline unsigned long ieee80211_tu_to_usec(unsigned long tu)
+{
+	return 1024 * tu;
+}
+
+/**
+ * ieee80211_check_tim - check if AID bit is set in TIM
+ * @tim: the TIM IE
+ * @tim_len: length of the TIM IE
+ * @aid: the AID to look for
+ */
+static inline bool ieee80211_check_tim(const struct ieee80211_tim_ie *tim,
+				       u8 tim_len, u16 aid)
+{
+	u8 mask;
+	u8 index, indexn1, indexn2;
+
+	if (unlikely(!tim || tim_len < sizeof(*tim)))
+		return false;
+
+	aid &= 0x3fff;
+	index = aid / 8;
+	mask  = 1 << (aid & 7);
+
+	indexn1 = tim->bitmap_ctrl & 0xfe;
+	indexn2 = tim_len + indexn1 - 4;
+
+	if (index < indexn1 || index > indexn2)
+		return false;
+
+	index -= indexn1;
+
+	return !!(tim->virtual_map[index] & mask);
+}
+
+/**
+ * ieee80211_get_tdls_action - get tdls packet action (or -1, if not tdls packet)
+ * @skb: the skb containing the frame, length will not be checked
+ * @hdr_size: the size of the ieee80211_hdr that starts at skb->data
+ *
+ * This function assumes the frame is a data frame, and that the network header
+ * is in the correct place.
+ */
+static inline int ieee80211_get_tdls_action(struct sk_buff *skb, u32 hdr_size)
+{
+	if (!skb_is_nonlinear(skb) &&
+	    skb->len > (skb_network_offset(skb) + 2)) {
+		/* Point to where the indication of TDLS should start */
+		const u8 *tdls_data = skb_network_header(skb) - 2;
+
+		if (get_unaligned_be16(tdls_data) == ETH_P_TDLS &&
+		    tdls_data[2] == WLAN_TDLS_SNAP_RFTYPE &&
+		    tdls_data[3] == WLAN_CATEGORY_TDLS)
+			return tdls_data[4];
+	}
+
+	return -1;
+}
+
+/* convert time units */
+#define TU_TO_JIFFIES(x)	(usecs_to_jiffies((x) * 1024))
+#define TU_TO_EXP_TIME(x)	(jiffies + TU_TO_JIFFIES(x))
+
+/**
+ * ieee80211_action_contains_tpc - checks if the frame contains TPC element
+ * @skb: the skb containing the frame, length will be checked
+ *
+ * This function checks if it's either TPC report action frame or Link
+ * Measurement report action frame as defined in IEEE Std. 802.11-2012 8.5.2.5
+ * and 8.5.7.5 accordingly.
+ */
+static inline bool ieee80211_action_contains_tpc(struct sk_buff *skb)
+{
+	struct ieee80211_mgmt *mgmt = (void *)skb->data;
+
+	if (!ieee80211_is_action(mgmt->frame_control))
+		return false;
+
+	if (skb->len < IEEE80211_MIN_ACTION_SIZE +
+		       sizeof(mgmt->u.action.u.tpc_report))
+		return false;
+
+	/*
+	 * TPC report - check that:
+	 * category = 0 (Spectrum Management) or 5 (Radio Measurement)
+	 * spectrum management action = 3 (TPC/Link Measurement report)
+	 * TPC report EID = 35
+	 * TPC report element length = 2
+	 *
+	 * The spectrum management's tpc_report struct is used here both for
+	 * parsing tpc_report and radio measurement's link measurement report
+	 * frame, since the relevant part is identical in both frames.
+	 */
+	if (mgmt->u.action.category != WLAN_CATEGORY_SPECTRUM_MGMT &&
+	    mgmt->u.action.category != WLAN_CATEGORY_RADIO_MEASUREMENT)
+		return false;
+
+	/* both spectrum mgmt and link measurement have same action code */
+	if (mgmt->u.action.u.tpc_report.action_code !=
+	    WLAN_ACTION_SPCT_TPC_RPRT)
+		return false;
+
+	if (mgmt->u.action.u.tpc_report.tpc_elem_id != WLAN_EID_TPC_REPORT ||
+	    mgmt->u.action.u.tpc_report.tpc_elem_length !=
+	    sizeof(struct ieee80211_tpc_report_ie))
+		return false;
+
+	return true;
+}
+
+struct element {
+	u8 id;
+	u8 datalen;
+	u8 data[];
+} __packed;
+
+/* element iteration helpers */
+#define for_each_element(_elem, _data, _datalen)			\
+	for (_elem = (const struct element *)(_data);			\
+	     (const u8 *)(_data) + (_datalen) - (const u8 *)_elem >=	\
+		(int)sizeof(*_elem) &&					\
+	     (const u8 *)(_data) + (_datalen) - (const u8 *)_elem >=	\
+		(int)sizeof(*_elem) + _elem->datalen;			\
+	     _elem = (const struct element *)(_elem->data + _elem->datalen))
+
+#define for_each_element_id(element, _id, data, datalen)		\
+	for_each_element(element, data, datalen)			\
+		if (element->id == (_id))
+
+#define for_each_element_extid(element, extid, _data, _datalen)		\
+	for_each_element(element, _data, _datalen)			\
+		if (element->id == WLAN_EID_EXTENSION &&		\
+		    element->datalen > 0 &&				\
+		    element->data[0] == (extid))
+
+#define for_each_subelement(sub, element)				\
+	for_each_element(sub, (element)->data, (element)->datalen)
+
+#define for_each_subelement_id(sub, id, element)			\
+	for_each_element_id(sub, id, (element)->data, (element)->datalen)
+
+#define for_each_subelement_extid(sub, extid, element)			\
+	for_each_element_extid(sub, extid, (element)->data, (element)->datalen)
+
+/**
+ * for_each_element_completed - determine if element parsing consumed all data
+ * @element: element pointer after for_each_element() or friends
+ * @data: same data pointer as passed to for_each_element() or friends
+ * @datalen: same data length as passed to for_each_element() or friends
+ *
+ * This function returns %true if all the data was parsed or considered
+ * while walking the elements. Only use this if your for_each_element()
+ * loop cannot be broken out of, otherwise it always returns %false.
+ *
+ * If some data was malformed, this returns %false since the last parsed
+ * element will not fill the whole remaining data.
+ */
+static inline bool for_each_element_completed(const struct element *element,
+					      const void *data, size_t datalen)
+{
+	return (const u8 *)element == (const u8 *)data + datalen;
+}
+
+#endif /* LINUX_IEEE80211_H */
diff -Naurp a/drivers/net/wireless/xr829/include/linux/kfifo.h b/drivers/net/wireless/xr829/include/linux/kfifo.h
--- a/drivers/net/wireless/xr829/include/linux/kfifo.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/kfifo.h	2022-08-27 01:22:42.910539695 +0300
@@ -0,0 +1,834 @@
+#include <generated/uapi/linux/version.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36))
+#include_next <linux/kfifo.h>
+#else
+/*
+ * A generic kernel FIFO implementation
+ *
+ * Copyright (C) 2013 Stefani Seibold <stefani@seibold.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_KFIFO_H
+#define _LINUX_KFIFO_H
+
+/*
+ * How to porting drivers to the new generic FIFO API:
+ *
+ * - Modify the declaration of the "struct kfifo *" object into a
+ *   in-place "struct kfifo" object
+ * - Init the in-place object with kfifo_alloc() or kfifo_init()
+ *   Note: The address of the in-place "struct kfifo" object must be
+ *   passed as the first argument to this functions
+ * - Replace the use of __kfifo_put into kfifo_in and __kfifo_get
+ *   into kfifo_out
+ * - Replace the use of kfifo_put into kfifo_in_spinlocked and kfifo_get
+ *   into kfifo_out_spinlocked
+ *   Note: the spinlock pointer formerly passed to kfifo_init/kfifo_alloc
+ *   must be passed now to the kfifo_in_spinlocked and kfifo_out_spinlocked
+ *   as the last parameter
+ * - The formerly __kfifo_* functions are renamed into kfifo_*
+ */
+
+/*
+ * Note about locking : There is no locking required until only * one reader
+ * and one writer is using the fifo and no kfifo_reset() will be * called
+ *  kfifo_reset_out() can be safely used, until it will be only called
+ * in the reader thread.
+ *  For multiple writer and one reader there is only a need to lock the writer.
+ * And vice versa for only one writer and multiple reader there is only a need
+ * to lock the reader.
+ */
+
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/stddef.h>
+#include <linux/scatterlist.h>
+
+struct __kfifo {
+	unsigned int	in;
+	unsigned int	out;
+	unsigned int	mask;
+	unsigned int	esize;
+	void		*data;
+};
+
+#define __STRUCT_KFIFO_COMMON(datatype, recsize, ptrtype) \
+	union { \
+		struct __kfifo	kfifo; \
+		datatype	*type; \
+		const datatype	*const_type; \
+		char		(*rectype)[recsize]; \
+		ptrtype		*ptr; \
+		ptrtype const	*ptr_const; \
+	}
+
+#define __STRUCT_KFIFO(type, size, recsize, ptrtype) \
+{ \
+	__STRUCT_KFIFO_COMMON(type, recsize, ptrtype); \
+	type		buf[((size < 2) || (size & (size - 1))) ? -1 : size]; \
+}
+
+#define STRUCT_KFIFO(type, size) \
+	struct __STRUCT_KFIFO(type, size, 0, type)
+
+#define __STRUCT_KFIFO_PTR(type, recsize, ptrtype) \
+{ \
+	__STRUCT_KFIFO_COMMON(type, recsize, ptrtype); \
+	type		buf[0]; \
+}
+
+#define STRUCT_KFIFO_PTR(type) \
+	struct __STRUCT_KFIFO_PTR(type, 0, type)
+
+/*
+ * define compatibility "struct kfifo" for dynamic allocated fifos
+ */
+struct kfifo __STRUCT_KFIFO_PTR(unsigned char, 0, void);
+
+#define STRUCT_KFIFO_REC_1(size) \
+	struct __STRUCT_KFIFO(unsigned char, size, 1, void)
+
+#define STRUCT_KFIFO_REC_2(size) \
+	struct __STRUCT_KFIFO(unsigned char, size, 2, void)
+
+/*
+ * define kfifo_rec types
+ */
+struct kfifo_rec_ptr_1 __STRUCT_KFIFO_PTR(unsigned char, 1, void);
+struct kfifo_rec_ptr_2 __STRUCT_KFIFO_PTR(unsigned char, 2, void);
+
+/*
+ * helper macro to distinguish between real in place fifo where the fifo
+ * array is a part of the structure and the fifo type where the array is
+ * outside of the fifo structure.
+ */
+#define	__is_kfifo_ptr(fifo)	(sizeof(*fifo) == sizeof(struct __kfifo))
+
+/**
+ * DECLARE_KFIFO_PTR - macro to declare a fifo pointer object
+ * @fifo: name of the declared fifo
+ * @type: type of the fifo elements
+ */
+#define DECLARE_KFIFO_PTR(fifo, type)	STRUCT_KFIFO_PTR(type) fifo
+
+/**
+ * DECLARE_KFIFO - macro to declare a fifo object
+ * @fifo: name of the declared fifo
+ * @type: type of the fifo elements
+ * @size: the number of elements in the fifo, this must be a power of 2
+ */
+#define DECLARE_KFIFO(fifo, type, size)	STRUCT_KFIFO(type, size) fifo
+
+/**
+ * INIT_KFIFO - Initialize a fifo declared by DECLARE_KFIFO
+ * @fifo: name of the declared fifo datatype
+ */
+#define INIT_KFIFO(fifo) \
+(void)({ \
+	typeof(&(fifo)) __tmp = &(fifo); \
+	struct __kfifo *__kfifo = &__tmp->kfifo; \
+	__kfifo->in = 0; \
+	__kfifo->out = 0; \
+	__kfifo->mask = __is_kfifo_ptr(__tmp) ? 0 : ARRAY_SIZE(__tmp->buf) - 1;\
+	__kfifo->esize = sizeof(*__tmp->buf); \
+	__kfifo->data = __is_kfifo_ptr(__tmp) ?  NULL : __tmp->buf; \
+})
+
+/**
+ * DEFINE_KFIFO - macro to define and initialize a fifo
+ * @fifo: name of the declared fifo datatype
+ * @type: type of the fifo elements
+ * @size: the number of elements in the fifo, this must be a power of 2
+ *
+ * Note: the macro can be used for global and local fifo data type variables.
+ */
+#define DEFINE_KFIFO(fifo, type, size) \
+	DECLARE_KFIFO(fifo, type, size) = \
+	(typeof(fifo)) { \
+		{ \
+			{ \
+			.in	= 0, \
+			.out	= 0, \
+			.mask	= __is_kfifo_ptr(&(fifo)) ? \
+				  0 : \
+				  ARRAY_SIZE((fifo).buf) - 1, \
+			.esize	= sizeof(*(fifo).buf), \
+			.data	= __is_kfifo_ptr(&(fifo)) ? \
+				NULL : \
+				(fifo).buf, \
+			} \
+		} \
+	}
+
+
+static inline unsigned int __must_check
+__kfifo_uint_must_check_helper(unsigned int val)
+{
+	return val;
+}
+
+static inline int __must_check
+__kfifo_int_must_check_helper(int val)
+{
+	return val;
+}
+
+/**
+ * kfifo_initialized - Check if the fifo is initialized
+ * @fifo: address of the fifo to check
+ *
+ * Return %true if fifo is initialized, otherwise %false.
+ * Assumes the fifo was 0 before.
+ */
+#define kfifo_initialized(fifo) ((fifo)->kfifo.mask)
+
+/**
+ * kfifo_esize - returns the size of the element managed by the fifo
+ * @fifo: address of the fifo to be used
+ */
+#define kfifo_esize(fifo)	((fifo)->kfifo.esize)
+
+/**
+ * kfifo_recsize - returns the size of the record length field
+ * @fifo: address of the fifo to be used
+ */
+#define kfifo_recsize(fifo)	(sizeof(*(fifo)->rectype))
+
+/**
+ * kfifo_size - returns the size of the fifo in elements
+ * @fifo: address of the fifo to be used
+ */
+#define kfifo_size(fifo)	((fifo)->kfifo.mask + 1)
+
+/**
+ * kfifo_reset - removes the entire fifo content
+ * @fifo: address of the fifo to be used
+ *
+ * Note: usage of kfifo_reset() is dangerous. It should be only called when the
+ * fifo is exclusived locked or when it is secured that no other thread is
+ * accessing the fifo.
+ */
+#define kfifo_reset(fifo) \
+(void)({ \
+	typeof((fifo) + 1) __tmp = (fifo); \
+	__tmp->kfifo.in = __tmp->kfifo.out = 0; \
+})
+
+/**
+ * kfifo_reset_out - skip fifo content
+ * @fifo: address of the fifo to be used
+ *
+ * Note: The usage of kfifo_reset_out() is safe until it will be only called
+ * from the reader thread and there is only one concurrent reader. Otherwise
+ * it is dangerous and must be handled in the same way as kfifo_reset().
+ */
+#define kfifo_reset_out(fifo)	\
+(void)({ \
+	typeof((fifo) + 1) __tmp = (fifo); \
+	__tmp->kfifo.out = __tmp->kfifo.in; \
+})
+
+/**
+ * kfifo_len - returns the number of used elements in the fifo
+ * @fifo: address of the fifo to be used
+ */
+#define kfifo_len(fifo) \
+({ \
+	typeof((fifo) + 1) __tmpl = (fifo); \
+	__tmpl->kfifo.in - __tmpl->kfifo.out; \
+})
+
+/**
+ * kfifo_is_empty - returns true if the fifo is empty
+ * @fifo: address of the fifo to be used
+ */
+#define	kfifo_is_empty(fifo) \
+({ \
+	typeof((fifo) + 1) __tmpq = (fifo); \
+	__tmpq->kfifo.in == __tmpq->kfifo.out; \
+})
+
+/**
+ * kfifo_is_full - returns true if the fifo is full
+ * @fifo: address of the fifo to be used
+ */
+#define	kfifo_is_full(fifo) \
+({ \
+	typeof((fifo) + 1) __tmpq = (fifo); \
+	kfifo_len(__tmpq) > __tmpq->kfifo.mask; \
+})
+
+/**
+ * kfifo_avail - returns the number of unused elements in the fifo
+ * @fifo: address of the fifo to be used
+ */
+#define	kfifo_avail(fifo) \
+__kfifo_uint_must_check_helper( \
+({ \
+	typeof((fifo) + 1) __tmpq = (fifo); \
+	const size_t __recsize = sizeof(*__tmpq->rectype); \
+	unsigned int __avail = kfifo_size(__tmpq) - kfifo_len(__tmpq); \
+	(__recsize) ? ((__avail <= __recsize) ? 0 : \
+	__kfifo_max_r(__avail - __recsize, __recsize)) : \
+	__avail; \
+}) \
+)
+
+/**
+ * kfifo_skip - skip output data
+ * @fifo: address of the fifo to be used
+ */
+#define	kfifo_skip(fifo) \
+(void)({ \
+	typeof((fifo) + 1) __tmp = (fifo); \
+	const size_t __recsize = sizeof(*__tmp->rectype); \
+	struct __kfifo *__kfifo = &__tmp->kfifo; \
+	if (__recsize) \
+		__kfifo_skip_r(__kfifo, __recsize); \
+	else \
+		__kfifo->out++; \
+})
+
+/**
+ * kfifo_peek_len - gets the size of the next fifo record
+ * @fifo: address of the fifo to be used
+ *
+ * This function returns the size of the next fifo record in number of bytes.
+ */
+#define kfifo_peek_len(fifo) \
+__kfifo_uint_must_check_helper( \
+({ \
+	typeof((fifo) + 1) __tmp = (fifo); \
+	const size_t __recsize = sizeof(*__tmp->rectype); \
+	struct __kfifo *__kfifo = &__tmp->kfifo; \
+	(!__recsize) ? kfifo_len(__tmp) * sizeof(*__tmp->type) : \
+	__kfifo_len_r(__kfifo, __recsize); \
+}) \
+)
+
+/**
+ * kfifo_alloc - dynamically allocates a new fifo buffer
+ * @fifo: pointer to the fifo
+ * @size: the number of elements in the fifo, this must be a power of 2
+ * @gfp_mask: get_free_pages mask, passed to kmalloc()
+ *
+ * This macro dynamically allocates a new fifo buffer.
+ *
+ * The numer of elements will be rounded-up to a power of 2.
+ * The fifo will be release with kfifo_free().
+ * Return 0 if no error, otherwise an error code.
+ */
+#define kfifo_alloc(fifo, size, gfp_mask) \
+__kfifo_int_must_check_helper( \
+({ \
+	typeof((fifo) + 1) __tmp = (fifo); \
+	struct __kfifo *__kfifo = &__tmp->kfifo; \
+	__is_kfifo_ptr(__tmp) ? \
+	__kfifo_alloc(__kfifo, size, sizeof(*__tmp->type), gfp_mask) : \
+	-EINVAL; \
+}) \
+)
+
+/**
+ * kfifo_free - frees the fifo
+ * @fifo: the fifo to be freed
+ */
+#define kfifo_free(fifo) \
+({ \
+	typeof((fifo) + 1) __tmp = (fifo); \
+	struct __kfifo *__kfifo = &__tmp->kfifo; \
+	if (__is_kfifo_ptr(__tmp)) \
+		__kfifo_free(__kfifo); \
+})
+
+/**
+ * kfifo_init - initialize a fifo using a preallocated buffer
+ * @fifo: the fifo to assign the buffer
+ * @buffer: the preallocated buffer to be used
+ * @size: the size of the internal buffer, this have to be a power of 2
+ *
+ * This macro initialize a fifo using a preallocated buffer.
+ *
+ * The numer of elements will be rounded-up to a power of 2.
+ * Return 0 if no error, otherwise an error code.
+ */
+#define kfifo_init(fifo, buffer, size) \
+({ \
+	typeof((fifo) + 1) __tmp = (fifo); \
+	struct __kfifo *__kfifo = &__tmp->kfifo; \
+	__is_kfifo_ptr(__tmp) ? \
+	__kfifo_init(__kfifo, buffer, size, sizeof(*__tmp->type)) : \
+	-EINVAL; \
+})
+
+/**
+ * kfifo_put - put data into the fifo
+ * @fifo: address of the fifo to be used
+ * @val: the data to be added
+ *
+ * This macro copies the given value into the fifo.
+ * It returns 0 if the fifo was full. Otherwise it returns the number
+ * processed elements.
+ *
+ * Note that with only one concurrent reader and one concurrent
+ * writer, you don't need extra locking to use these macro.
+ */
+#define	kfifo_put(fifo, val) \
+({ \
+	typeof((fifo) + 1) __tmp = (fifo); \
+	typeof(*__tmp->const_type) __val = (val); \
+	unsigned int __ret; \
+	size_t __recsize = sizeof(*__tmp->rectype); \
+	struct __kfifo *__kfifo = &__tmp->kfifo; \
+	if (__recsize) \
+		__ret = __kfifo_in_r(__kfifo, &__val, sizeof(__val), \
+			__recsize); \
+	else { \
+		__ret = !kfifo_is_full(__tmp); \
+		if (__ret) { \
+			(__is_kfifo_ptr(__tmp) ? \
+			((typeof(__tmp->type))__kfifo->data) : \
+			(__tmp->buf) \
+			)[__kfifo->in & __tmp->kfifo.mask] = \
+				(typeof(*__tmp->type))__val; \
+			smp_wmb(); \
+			__kfifo->in++; \
+		} \
+	} \
+	__ret; \
+})
+
+/**
+ * kfifo_get - get data from the fifo
+ * @fifo: address of the fifo to be used
+ * @val: address where to store the data
+ *
+ * This macro reads the data from the fifo.
+ * It returns 0 if the fifo was empty. Otherwise it returns the number
+ * processed elements.
+ *
+ * Note that with only one concurrent reader and one concurrent
+ * writer, you don't need extra locking to use these macro.
+ */
+#define	kfifo_get(fifo, val) \
+__kfifo_uint_must_check_helper( \
+({ \
+	typeof((fifo) + 1) __tmp = (fifo); \
+	typeof(__tmp->ptr) __val = (val); \
+	unsigned int __ret; \
+	const size_t __recsize = sizeof(*__tmp->rectype); \
+	struct __kfifo *__kfifo = &__tmp->kfifo; \
+	if (__recsize) \
+		__ret = __kfifo_out_r(__kfifo, __val, sizeof(*__val), \
+			__recsize); \
+	else { \
+		__ret = !kfifo_is_empty(__tmp); \
+		if (__ret) { \
+			*(typeof(__tmp->type))__val = \
+				(__is_kfifo_ptr(__tmp) ? \
+				((typeof(__tmp->type))__kfifo->data) : \
+				(__tmp->buf) \
+				)[__kfifo->out & __tmp->kfifo.mask]; \
+			smp_wmb(); \
+			__kfifo->out++; \
+		} \
+	} \
+	__ret; \
+}) \
+)
+
+/**
+ * kfifo_peek - get data from the fifo without removing
+ * @fifo: address of the fifo to be used
+ * @val: address where to store the data
+ *
+ * This reads the data from the fifo without removing it from the fifo.
+ * It returns 0 if the fifo was empty. Otherwise it returns the number
+ * processed elements.
+ *
+ * Note that with only one concurrent reader and one concurrent
+ * writer, you don't need extra locking to use these macro.
+ */
+#define	kfifo_peek(fifo, val) \
+__kfifo_uint_must_check_helper( \
+({ \
+	typeof((fifo) + 1) __tmp = (fifo); \
+	typeof(__tmp->ptr) __val = (val); \
+	unsigned int __ret; \
+	const size_t __recsize = sizeof(*__tmp->rectype); \
+	struct __kfifo *__kfifo = &__tmp->kfifo; \
+	if (__recsize) \
+		__ret = __kfifo_out_peek_r(__kfifo, __val, sizeof(*__val), \
+			__recsize); \
+	else { \
+		__ret = !kfifo_is_empty(__tmp); \
+		if (__ret) { \
+			*(typeof(__tmp->type))__val = \
+				(__is_kfifo_ptr(__tmp) ? \
+				((typeof(__tmp->type))__kfifo->data) : \
+				(__tmp->buf) \
+				)[__kfifo->out & __tmp->kfifo.mask]; \
+			smp_wmb(); \
+		} \
+	} \
+	__ret; \
+}) \
+)
+
+/**
+ * kfifo_in - put data into the fifo
+ * @fifo: address of the fifo to be used
+ * @buf: the data to be added
+ * @n: number of elements to be added
+ *
+ * This macro copies the given buffer into the fifo and returns the
+ * number of copied elements.
+ *
+ * Note that with only one concurrent reader and one concurrent
+ * writer, you don't need extra locking to use these macro.
+ */
+#define	kfifo_in(fifo, buf, n) \
+({ \
+	typeof((fifo) + 1) __tmp = (fifo); \
+	typeof(__tmp->ptr_const) __buf = (buf); \
+	unsigned long __n = (n); \
+	const size_t __recsize = sizeof(*__tmp->rectype); \
+	struct __kfifo *__kfifo = &__tmp->kfifo; \
+	(__recsize) ?\
+	__kfifo_in_r(__kfifo, __buf, __n, __recsize) : \
+	__kfifo_in(__kfifo, __buf, __n); \
+})
+
+/**
+ * kfifo_in_spinlocked - put data into the fifo using a spinlock for locking
+ * @fifo: address of the fifo to be used
+ * @buf: the data to be added
+ * @n: number of elements to be added
+ * @lock: pointer to the spinlock to use for locking
+ *
+ * This macro copies the given values buffer into the fifo and returns the
+ * number of copied elements.
+ */
+#define	kfifo_in_spinlocked(fifo, buf, n, lock) \
+({ \
+	unsigned long __flags; \
+	unsigned int __ret; \
+	spin_lock_irqsave(lock, __flags); \
+	__ret = kfifo_in(fifo, buf, n); \
+	spin_unlock_irqrestore(lock, __flags); \
+	__ret; \
+})
+
+/* alias for kfifo_in_spinlocked, will be removed in a future release */
+#define kfifo_in_locked(fifo, buf, n, lock) \
+		kfifo_in_spinlocked(fifo, buf, n, lock)
+
+/**
+ * kfifo_out - get data from the fifo
+ * @fifo: address of the fifo to be used
+ * @buf: pointer to the storage buffer
+ * @n: max. number of elements to get
+ *
+ * This macro get some data from the fifo and return the numbers of elements
+ * copied.
+ *
+ * Note that with only one concurrent reader and one concurrent
+ * writer, you don't need extra locking to use these macro.
+ */
+#define	kfifo_out(fifo, buf, n) \
+__kfifo_uint_must_check_helper( \
+({ \
+	typeof((fifo) + 1) __tmp = (fifo); \
+	typeof(__tmp->ptr) __buf = (buf); \
+	unsigned long __n = (n); \
+	const size_t __recsize = sizeof(*__tmp->rectype); \
+	struct __kfifo *__kfifo = &__tmp->kfifo; \
+	(__recsize) ?\
+	__kfifo_out_r(__kfifo, __buf, __n, __recsize) : \
+	__kfifo_out(__kfifo, __buf, __n); \
+}) \
+)
+
+/**
+ * kfifo_out_spinlocked - get data from the fifo using a spinlock for locking
+ * @fifo: address of the fifo to be used
+ * @buf: pointer to the storage buffer
+ * @n: max. number of elements to get
+ * @lock: pointer to the spinlock to use for locking
+ *
+ * This macro get the data from the fifo and return the numbers of elements
+ * copied.
+ */
+#define	kfifo_out_spinlocked(fifo, buf, n, lock) \
+__kfifo_uint_must_check_helper( \
+({ \
+	unsigned long __flags; \
+	unsigned int __ret; \
+	spin_lock_irqsave(lock, __flags); \
+	__ret = kfifo_out(fifo, buf, n); \
+	spin_unlock_irqrestore(lock, __flags); \
+	__ret; \
+}) \
+)
+
+/* alias for kfifo_out_spinlocked, will be removed in a future release */
+#define kfifo_out_locked(fifo, buf, n, lock) \
+		kfifo_out_spinlocked(fifo, buf, n, lock)
+
+/**
+ * kfifo_from_user - puts some data from user space into the fifo
+ * @fifo: address of the fifo to be used
+ * @from: pointer to the data to be added
+ * @len: the length of the data to be added
+ * @copied: pointer to output variable to store the number of copied bytes
+ *
+ * This macro copies at most @len bytes from the @from into the
+ * fifo, depending of the available space and returns -EFAULT/0.
+ *
+ * Note that with only one concurrent reader and one concurrent
+ * writer, you don't need extra locking to use these macro.
+ */
+#define	kfifo_from_user(fifo, from, len, copied) \
+__kfifo_uint_must_check_helper( \
+({ \
+	typeof((fifo) + 1) __tmp = (fifo); \
+	const void __user *__from = (from); \
+	unsigned int __len = (len); \
+	unsigned int *__copied = (copied); \
+	const size_t __recsize = sizeof(*__tmp->rectype); \
+	struct __kfifo *__kfifo = &__tmp->kfifo; \
+	(__recsize) ? \
+	__kfifo_from_user_r(__kfifo, __from, __len,  __copied, __recsize) : \
+	__kfifo_from_user(__kfifo, __from, __len, __copied); \
+}) \
+)
+
+/**
+ * kfifo_to_user - copies data from the fifo into user space
+ * @fifo: address of the fifo to be used
+ * @to: where the data must be copied
+ * @len: the size of the destination buffer
+ * @copied: pointer to output variable to store the number of copied bytes
+ *
+ * This macro copies at most @len bytes from the fifo into the
+ * @to buffer and returns -EFAULT/0.
+ *
+ * Note that with only one concurrent reader and one concurrent
+ * writer, you don't need extra locking to use these macro.
+ */
+#define	kfifo_to_user(fifo, to, len, copied) \
+__kfifo_uint_must_check_helper( \
+({ \
+	typeof((fifo) + 1) __tmp = (fifo); \
+	void __user *__to = (to); \
+	unsigned int __len = (len); \
+	unsigned int *__copied = (copied); \
+	const size_t __recsize = sizeof(*__tmp->rectype); \
+	struct __kfifo *__kfifo = &__tmp->kfifo; \
+	(__recsize) ? \
+	__kfifo_to_user_r(__kfifo, __to, __len, __copied, __recsize) : \
+	__kfifo_to_user(__kfifo, __to, __len, __copied); \
+}) \
+)
+
+/**
+ * kfifo_dma_in_prepare - setup a scatterlist for DMA input
+ * @fifo: address of the fifo to be used
+ * @sgl: pointer to the scatterlist array
+ * @nents: number of entries in the scatterlist array
+ * @len: number of elements to transfer
+ *
+ * This macro fills a scatterlist for DMA input.
+ * It returns the number entries in the scatterlist array.
+ *
+ * Note that with only one concurrent reader and one concurrent
+ * writer, you don't need extra locking to use these macros.
+ */
+#define	kfifo_dma_in_prepare(fifo, sgl, nents, len) \
+({ \
+	typeof((fifo) + 1) __tmp = (fifo); \
+	struct scatterlist *__sgl = (sgl); \
+	int __nents = (nents); \
+	unsigned int __len = (len); \
+	const size_t __recsize = sizeof(*__tmp->rectype); \
+	struct __kfifo *__kfifo = &__tmp->kfifo; \
+	(__recsize) ? \
+	__kfifo_dma_in_prepare_r(__kfifo, __sgl, __nents, __len, __recsize) : \
+	__kfifo_dma_in_prepare(__kfifo, __sgl, __nents, __len); \
+})
+
+/**
+ * kfifo_dma_in_finish - finish a DMA IN operation
+ * @fifo: address of the fifo to be used
+ * @len: number of bytes to received
+ *
+ * This macro finish a DMA IN operation. The in counter will be updated by
+ * the len parameter. No error checking will be done.
+ *
+ * Note that with only one concurrent reader and one concurrent
+ * writer, you don't need extra locking to use these macros.
+ */
+#define kfifo_dma_in_finish(fifo, len) \
+(void)({ \
+	typeof((fifo) + 1) __tmp = (fifo); \
+	unsigned int __len = (len); \
+	const size_t __recsize = sizeof(*__tmp->rectype); \
+	struct __kfifo *__kfifo = &__tmp->kfifo; \
+	if (__recsize) \
+		__kfifo_dma_in_finish_r(__kfifo, __len, __recsize); \
+	else \
+		__kfifo->in += __len / sizeof(*__tmp->type); \
+})
+
+/**
+ * kfifo_dma_out_prepare - setup a scatterlist for DMA output
+ * @fifo: address of the fifo to be used
+ * @sgl: pointer to the scatterlist array
+ * @nents: number of entries in the scatterlist array
+ * @len: number of elements to transfer
+ *
+ * This macro fills a scatterlist for DMA output which at most @len bytes
+ * to transfer.
+ * It returns the number entries in the scatterlist array.
+ * A zero means there is no space available and the scatterlist is not filled.
+ *
+ * Note that with only one concurrent reader and one concurrent
+ * writer, you don't need extra locking to use these macros.
+ */
+#define	kfifo_dma_out_prepare(fifo, sgl, nents, len) \
+({ \
+	typeof((fifo) + 1) __tmp = (fifo);  \
+	struct scatterlist *__sgl = (sgl); \
+	int __nents = (nents); \
+	unsigned int __len = (len); \
+	const size_t __recsize = sizeof(*__tmp->rectype); \
+	struct __kfifo *__kfifo = &__tmp->kfifo; \
+	(__recsize) ? \
+	__kfifo_dma_out_prepare_r(__kfifo, __sgl, __nents, __len, __recsize) : \
+	__kfifo_dma_out_prepare(__kfifo, __sgl, __nents, __len); \
+})
+
+/**
+ * kfifo_dma_out_finish - finish a DMA OUT operation
+ * @fifo: address of the fifo to be used
+ * @len: number of bytes transferred
+ *
+ * This macro finish a DMA OUT operation. The out counter will be updated by
+ * the len parameter. No error checking will be done.
+ *
+ * Note that with only one concurrent reader and one concurrent
+ * writer, you don't need extra locking to use these macros.
+ */
+#define kfifo_dma_out_finish(fifo, len) \
+(void)({ \
+	typeof((fifo) + 1) __tmp = (fifo); \
+	unsigned int __len = (len); \
+	const size_t __recsize = sizeof(*__tmp->rectype); \
+	struct __kfifo *__kfifo = &__tmp->kfifo; \
+	if (__recsize) \
+		__kfifo_dma_out_finish_r(__kfifo, __recsize); \
+	else \
+		__kfifo->out += __len / sizeof(*__tmp->type); \
+})
+
+/**
+ * kfifo_out_peek - gets some data from the fifo
+ * @fifo: address of the fifo to be used
+ * @buf: pointer to the storage buffer
+ * @n: max. number of elements to get
+ *
+ * This macro get the data from the fifo and return the numbers of elements
+ * copied. The data is not removed from the fifo.
+ *
+ * Note that with only one concurrent reader and one concurrent
+ * writer, you don't need extra locking to use these macro.
+ */
+#define	kfifo_out_peek(fifo, buf, n) \
+__kfifo_uint_must_check_helper( \
+({ \
+	typeof((fifo) + 1) __tmp = (fifo); \
+	typeof(__tmp->ptr) __buf = (buf); \
+	unsigned long __n = (n); \
+	const size_t __recsize = sizeof(*__tmp->rectype); \
+	struct __kfifo *__kfifo = &__tmp->kfifo; \
+	(__recsize) ? \
+	__kfifo_out_peek_r(__kfifo, __buf, __n, __recsize) : \
+	__kfifo_out_peek(__kfifo, __buf, __n); \
+}) \
+)
+
+extern int __kfifo_alloc(struct __kfifo *fifo, unsigned int size,
+	size_t esize, gfp_t gfp_mask);
+
+extern void __kfifo_free(struct __kfifo *fifo);
+
+extern int __kfifo_init(struct __kfifo *fifo, void *buffer,
+	unsigned int size, size_t esize);
+
+extern unsigned int __kfifo_in(struct __kfifo *fifo,
+	const void *buf, unsigned int len);
+
+extern unsigned int __kfifo_out(struct __kfifo *fifo,
+	void *buf, unsigned int len);
+
+extern int __kfifo_from_user(struct __kfifo *fifo,
+	const void __user *from, unsigned long len, unsigned int *copied);
+
+extern int __kfifo_to_user(struct __kfifo *fifo,
+	void __user *to, unsigned long len, unsigned int *copied);
+
+extern unsigned int __kfifo_dma_in_prepare(struct __kfifo *fifo,
+	struct scatterlist *sgl, int nents, unsigned int len);
+
+extern unsigned int __kfifo_dma_out_prepare(struct __kfifo *fifo,
+	struct scatterlist *sgl, int nents, unsigned int len);
+
+extern unsigned int __kfifo_out_peek(struct __kfifo *fifo,
+	void *buf, unsigned int len);
+
+extern unsigned int __kfifo_in_r(struct __kfifo *fifo,
+	const void *buf, unsigned int len, size_t recsize);
+
+extern unsigned int __kfifo_out_r(struct __kfifo *fifo,
+	void *buf, unsigned int len, size_t recsize);
+
+extern int __kfifo_from_user_r(struct __kfifo *fifo,
+	const void __user *from, unsigned long len, unsigned int *copied,
+	size_t recsize);
+
+extern int __kfifo_to_user_r(struct __kfifo *fifo, void __user *to,
+	unsigned long len, unsigned int *copied, size_t recsize);
+
+extern unsigned int __kfifo_dma_in_prepare_r(struct __kfifo *fifo,
+	struct scatterlist *sgl, int nents, unsigned int len, size_t recsize);
+
+extern void __kfifo_dma_in_finish_r(struct __kfifo *fifo,
+	unsigned int len, size_t recsize);
+
+extern unsigned int __kfifo_dma_out_prepare_r(struct __kfifo *fifo,
+	struct scatterlist *sgl, int nents, unsigned int len, size_t recsize);
+
+extern void __kfifo_dma_out_finish_r(struct __kfifo *fifo, size_t recsize);
+
+extern unsigned int __kfifo_len_r(struct __kfifo *fifo, size_t recsize);
+
+extern void __kfifo_skip_r(struct __kfifo *fifo, size_t recsize);
+
+extern unsigned int __kfifo_out_peek_r(struct __kfifo *fifo,
+	void *buf, unsigned int len, size_t recsize);
+
+extern unsigned int __kfifo_max_r(unsigned int len, size_t recsize);
+
+#endif
+#endif
diff -Naurp a/drivers/net/wireless/xr829/include/linux/math64.h b/drivers/net/wireless/xr829/include/linux/math64.h
--- a/drivers/net/wireless/xr829/include/linux/math64.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/math64.h	2022-08-27 01:22:42.910539695 +0300
@@ -0,0 +1,10 @@
+#ifndef _COMPAT_LINUX_MATH64_H
+#define _COMPAT_LINUX_MATH64_H 1
+
+#include <generated/uapi/linux/version.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 25))
+#include_next <linux/math64.h>
+#endif /* (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 25)) */
+
+#endif	/* _COMPAT_LINUX_MATH64_H */
diff -Naurp a/drivers/net/wireless/xr829/include/linux/of.h b/drivers/net/wireless/xr829/include/linux/of.h
--- a/drivers/net/wireless/xr829/include/linux/of.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/of.h	2022-08-27 01:22:42.910539695 +0300
@@ -0,0 +1,16 @@
+#ifndef _COMPAT_LINUX_OF_H
+#define _COMPAT_LINUX_OF_H 1
+
+#include <generated/uapi/linux/version.h>
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34))
+#include_next <linux/of.h>
+#else
+
+#ifdef CONFIG_OF
+#include_next <linux/of.h>
+#endif /* CONFIG_OF */
+
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)) */
+
+#endif	/* _COMPAT_LINUX_OF_H */
diff -Naurp a/drivers/net/wireless/xr829/include/linux/pm_qos.h b/drivers/net/wireless/xr829/include/linux/pm_qos.h
--- a/drivers/net/wireless/xr829/include/linux/pm_qos.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/pm_qos.h	2022-08-27 01:22:42.910539695 +0300
@@ -0,0 +1,54 @@
+#ifndef _COMPAT_LINUX_PM_QOS_H
+#define _COMPAT_LINUX_PM_QOS_H 1
+
+#include <generated/uapi/linux/version.h>
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
+#include_next <linux/pm_qos.h>
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0))
+
+#ifndef PM_QOS_NETWORK_LATENCY
+#define PM_QOS_NETWORK_LATENCY 2
+#endif
+
+#define PM_QOS_NETWORK_LAT_DEFAULT_VALUE	(2000 * USEC_PER_SEC)
+#define PM_QOS_NETWORK_THROUGHPUT_DEFAULT_VALUE	0
+#define PM_QOS_MEMORY_BANDWIDTH_DEFAULT_VALUE	0
+//#define PM_QOS_RESUME_LATENCY_DEFAULT_VALUE	0
+//#define PM_QOS_LATENCY_ANY			((s32)(~(__u32)0 >> 1))
+#define PM_QOS_FLAG_REMOTE_WAKEUP	(1 << 1)
+
+struct xr_miscdevice  {
+	int minor;
+	const char *name;
+	const struct file_operations *fops;
+	struct list_head list;
+	struct device *parent;
+	struct device *this_device;
+	const struct attribute_group **groups;
+	const char *nodename;
+	umode_t mode;
+};
+
+struct xr_pm_qos_object {
+	struct pm_qos_constraints *constraints;
+	struct xr_miscdevice pm_qos_power_miscdev;
+	char *name;
+};
+
+int xr_pm_qos_request(int pm_qos_class);
+
+int xr_pm_qos_add_notifier(int pm_qos_class,
+			struct notifier_block *notifier);
+
+int xr_pm_qos_remove_notifier(int pm_qos_class,
+				struct notifier_block *notifier);
+
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)) */
+
+#else
+#include <linux/pm_qos_params.h>
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)) */
+
+#endif	/* _COMPAT_LINUX_PM_QOS_H */
diff -Naurp a/drivers/net/wireless/xr829/include/linux/pm_qos_params.h b/drivers/net/wireless/xr829/include/linux/pm_qos_params.h
--- a/drivers/net/wireless/xr829/include/linux/pm_qos_params.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/pm_qos_params.h	2022-08-27 01:22:42.910539695 +0300
@@ -0,0 +1,40 @@
+#include <generated/uapi/linux/version.h>
+
+#ifndef __COMPAT_LINUX_PM_QOS_PARAMS_H
+#define __COMPAT_LINUX_PM_QOS_PARAMS_H
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
+#include_next <linux/pm_qos.h>
+#else
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25))
+#include_next <linux/pm_qos_params.h>
+#else
+/* interface for the pm_qos_power infrastructure of the linux kernel.
+ *
+ * Mark Gross <mgross@linux.intel.com>
+ */
+#include <linux/list.h>
+#include <linux/notifier.h>
+#include <linux/miscdevice.h>
+
+#define PM_QOS_RESERVED 0
+#define PM_QOS_CPU_DMA_LATENCY 1
+#define PM_QOS_NETWORK_LATENCY 2
+#define PM_QOS_NETWORK_THROUGHPUT 3
+#define PM_QOS_SYSTEM_BUS_FREQ 4
+
+#define PM_QOS_NUM_CLASSES 5
+#define PM_QOS_DEFAULT_VALUE -1
+
+int pm_qos_add_requirement(int qos, char *name, s32 value);
+int pm_qos_update_requirement(int qos, char *name, s32 new_value);
+void pm_qos_remove_requirement(int qos, char *name);
+
+int pm_qos_requirement(int qos);
+
+int pm_qos_add_notifier(int qos, struct notifier_block *notifier);
+int pm_qos_remove_notifier(int qos, struct notifier_block *notifier);
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) */
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)) */
+
+#endif
diff -Naurp a/drivers/net/wireless/xr829/include/linux/pm_runtime.h b/drivers/net/wireless/xr829/include/linux/pm_runtime.h
--- a/drivers/net/wireless/xr829/include/linux/pm_runtime.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/pm_runtime.h	2022-08-27 01:22:42.910539695 +0300
@@ -0,0 +1,14 @@
+#include <generated/uapi/linux/version.h>
+
+#ifndef __COMPAT_LINUX_PM_RUNTIME_H
+#define __COMPAT_LINUX_PM_RUNTIME_H
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32))
+#include_next <linux/pm_runtime.h>
+#else
+
+static inline void pm_runtime_enable(struct device *dev) {}
+
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)) */
+
+#endif
diff -Naurp a/drivers/net/wireless/xr829/include/linux/printk.h b/drivers/net/wireless/xr829/include/linux/printk.h
--- a/drivers/net/wireless/xr829/include/linux/printk.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/printk.h	2022-08-27 01:22:42.910539695 +0300
@@ -0,0 +1,12 @@
+#ifndef _COMPAT_LINUX_PRINTK_H
+#define _COMPAT_LINUX_PRINTK_H 1
+
+#include <generated/uapi/linux/version.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 36))
+#include_next <linux/printk.h>
+#else
+#include <linux/kernel.h>
+#endif /* (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35)) */
+
+#endif	/* _COMPAT_LINUX_PRINTK_H */
diff -Naurp a/drivers/net/wireless/xr829/include/linux/semaphore.h b/drivers/net/wireless/xr829/include/linux/semaphore.h
--- a/drivers/net/wireless/xr829/include/linux/semaphore.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/semaphore.h	2022-08-27 01:22:42.910539695 +0300
@@ -0,0 +1,12 @@
+#ifndef _COMPAT_LINUX_SEMAPHORE_H
+#define _COMPAT_LINUX_SEMAPHORE_H 1
+
+#include <generated/uapi/linux/version.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 25))
+#include_next <linux/semaphore.h>
+#else
+#include <asm/semaphore.h>
+#endif /* (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 25)) */
+
+#endif	/* _COMPAT_LINUX_SEMAPHORE_H */
diff -Naurp a/drivers/net/wireless/xr829/include/linux/sunxi-gpio.h b/drivers/net/wireless/xr829/include/linux/sunxi-gpio.h
--- a/drivers/net/wireless/xr829/include/linux/sunxi-gpio.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/sunxi-gpio.h	2022-08-27 01:22:42.910539695 +0300
@@ -0,0 +1,188 @@
+/*
+ * include/linux/sunxi-gpio.h
+ *
+ * (C) Copyright 2015-2020
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Wim Hwang <huangwei@allwinnertech.com>
+ *
+ * sunxi gpio utils
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __SW_GPIO_H
+#define __SW_GPIO_H
+
+#define SUNXI_PINCTRL	"pio"
+#define SUNXI_R_PINCTRL	"r_pio"
+#include <linux/pinctrl/pinconf-generic.h>
+
+/* pin group base number name space,
+ * the max pin number : 26*32=832.
+ */
+#define SUNXI_BANK_SIZE 32
+#define SUNXI_PA_BASE	0
+#define SUNXI_PB_BASE	32
+#define SUNXI_PC_BASE	64
+#define SUNXI_PD_BASE	96
+#define SUNXI_PE_BASE	128
+#define SUNXI_PF_BASE	160
+#define SUNXI_PG_BASE	192
+#define SUNXI_PH_BASE	224
+#define SUNXI_PI_BASE	256
+#define SUNXI_PJ_BASE	288
+#define SUNXI_PK_BASE	320
+#define SUNXI_PL_BASE	352
+#define SUNXI_PM_BASE	384
+#define SUNXI_PN_BASE	416
+#define SUNXI_PO_BASE	448
+#define AXP_PIN_BASE	1024
+
+#define SUNXI_PIN_NAME_MAX_LEN	8
+
+/* sunxi gpio name space */
+#define GPIOA(n)	(SUNXI_PA_BASE + (n))
+#define GPIOB(n)	(SUNXI_PB_BASE + (n))
+#define GPIOC(n)	(SUNXI_PC_BASE + (n))
+#define GPIOD(n)	(SUNXI_PD_BASE + (n))
+#define GPIOE(n)	(SUNXI_PE_BASE + (n))
+#define GPIOF(n)	(SUNXI_PF_BASE + (n))
+#define GPIOG(n)	(SUNXI_PG_BASE + (n))
+#define GPIOH(n)	(SUNXI_PH_BASE + (n))
+#define GPIOI(n)	(SUNXI_PI_BASE + (n))
+#define GPIOJ(n)	(SUNXI_PJ_BASE + (n))
+#define GPIOK(n)	(SUNXI_PK_BASE + (n))
+#define GPIOL(n)	(SUNXI_PL_BASE + (n))
+#define GPIOM(n)	(SUNXI_PM_BASE + (n))
+#define GPION(n)	(SUNXI_PN_BASE + (n))
+#define GPIOO(n)	(SUNXI_PO_BASE + (n))
+#define GPIO_AXP(n)	(AXP_PIN_BASE  + (n))
+
+/* sunxi specific input/output/eint functions */
+#define SUNXI_PIN_INPUT_FUNC	(0)
+#define SUNXI_PIN_OUTPUT_FUNC	(1)
+#define SUNXI_PIN_EINT_FUNC	(6)
+#define SUNXI_PIN_IO_DISABLE	(7)
+
+/* axp group base number name space,
+ * axp pinctrl number space coherent to sunxi-pinctrl.
+ */
+#define AXP_PINCTRL	        "axp-pinctrl"
+#define AXP_CFG_GRP		(0xFFFF)
+#define AXP_PIN_INPUT_FUNC	(0)
+#define AXP_PIN_OUTPUT_FUNC	(1)
+#define IS_AXP_PIN(pin)		(pin >= AXP_PIN_BASE)
+
+/* sunxi specific pull up/down */
+enum sunxi_pull_up_down {
+	SUNXI_PULL_DISABLE = 0,
+	SUNXI_PULL_UP,
+	SUNXI_PULL_DOWN,
+};
+
+/* sunxi specific data types */
+enum sunxi_data_type {
+	SUNXI_DATA_LOW = 0,
+	SUNXI_DATA_HIGH = 0,
+};
+
+/* sunxi specific pull status */
+enum sunxi_pin_pull {
+	SUNXI_PIN_PULL_DISABLE	= 0x00,
+	SUNXI_PIN_PULL_UP	= 0x01,
+	SUNXI_PIN_PULL_DOWN	= 0x02,
+	SUNXI_PIN_PULL_RESERVED	= 0x03,
+};
+
+/* sunxi specific driver levels */
+enum sunxi_pin_drv_level {
+	SUNXI_DRV_LEVEL0 = 10,
+	SUNXI_DRV_LEVEL1 = 20,
+	SUNXI_DRV_LEVEL2 = 30,
+	SUNXI_DRV_LEVEL3 = 40,
+};
+
+/* sunxi specific data bit status */
+enum sunxi_pin_data_status {
+	SUNXI_PIN_DATA_LOW  = 0x00,
+	SUNXI_PIN_DATA_HIGH = 0x01,
+};
+
+/* sunxi pin interrupt trigger mode */
+enum sunxi_pin_int_trigger_mode {
+	SUNXI_PIN_EINT_POSITIVE_EDGE   =   0x0,
+	SUNXI_PIN_EINT_NEGATIVE_EDGE   =   0x1,
+	SUNXI_PIN_EINT_HIGN_LEVEL      =   0x2,
+	SUNXI_PIN_EINT_LOW_LEVEL       =   0x3,
+	SUNXI_PIN_EINT_DOUBLE_EDGE     =   0x4
+};
+
+/* the source clock of pin int */
+enum sunxi_pin_int_source_clk {
+	SUNXI_PIN_INT_SRC_CLK_32K = 0x0,
+	SUNXI_PIN_INT_SRC_CLK_24M = 0x1
+};
+
+/*
+ * pin configuration (pull up/down and drive strength) type and its value are
+ * packed together into a 32-bits. The lower 8-bits represent the configuration
+ * type and the upper 24-bits hold the value of the configuration type.
+ */
+#define SUNXI_PINCFG_PACK(type, value)	(((value) << 8) | (type & 0xFF))
+#define SUNXI_PINCFG_UNPACK_TYPE(cfg)	((cfg) & 0xFF)
+#define SUNXI_PINCFG_UNPACK_VALUE(cfg)	(((cfg) & 0xFFFFFF00) >> 8)
+
+static inline int sunxi_gpio_to_name(int gpio, char *name)
+{
+	int bank, index;
+
+	if (!name)
+		return -EINVAL;
+
+	if (IS_AXP_PIN(gpio)) {
+		/* axp gpio name like this : GPIO0/GPIO1/.. */
+		index = gpio - AXP_PIN_BASE;
+		sprintf(name, "GPIO%d", index);
+	} else {
+		/* sunxi gpio name like this : PA0/PA1/PB0 */
+		bank = gpio / SUNXI_BANK_SIZE;
+		index = gpio % SUNXI_BANK_SIZE;
+		sprintf(name, "P%c%d", ('A' + bank), index);
+	}
+
+	return 0;
+}
+
+/* pio end, invalid macro */
+#define GPIO_INDEX_INVALID	(0xFFFFFFF0)
+#define GPIO_CFG_INVALID	(0xEEEEEEEE)
+#define GPIO_PULL_INVALID	(0xDDDDDDDD)
+#define GPIO_DRVLVL_INVALID	(0xCCCCCCCC)
+#define IRQ_NUM_INVALID		(0xFFFFFFFF)
+#define AXP_PORT_VAL		(0x0000FFFF)
+
+/* pio default macro */
+#define GPIO_PULL_DEFAULT	((u32)-1)
+#define GPIO_DRVLVL_DEFAULT	((u32)-1)
+#define GPIO_DATA_DEFAULT	((u32)-1)
+
+/*
+ * struct gpio_config - gpio config info
+ * @gpio:      gpio global index, must be unique
+ * @mul_sel:   multi sel val: 0 - input, 1 - output.
+ * @pull:      pull val: 0 - pull up/down disable, 1 - pull up
+ * @drv_level: driver level val: 0 - level 0, 1 - level 1
+ * @data:      data val: 0 - low, 1 - high, only valid when mul_sel is input/output
+ */
+struct gpio_config {
+	u32	data;
+	u32	gpio;
+	u32	mul_sel;
+	u32	pull;
+	u32	drv_level;
+};
+
+#endif
diff -Naurp a/drivers/net/wireless/xr829/include/linux/tracepoint.h b/drivers/net/wireless/xr829/include/linux/tracepoint.h
--- a/drivers/net/wireless/xr829/include/linux/tracepoint.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/tracepoint.h	2022-08-27 01:22:42.910539695 +0300
@@ -0,0 +1,10 @@
+#ifndef _COMPAT_LINUX_TRACEPOINT_H
+#define _COMPAT_LINUX_TRACEPOINT_H 1
+
+#include <generated/uapi/linux/version.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 27))
+#include_next <linux/tracepoint.h>
+#endif /* (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 27)) */
+
+#endif	/* _COMPAT_LINUX_TRACEPOINT_H */
diff -Naurp a/drivers/net/wireless/xr829/include/linux/unaligned/access_ok.h b/drivers/net/wireless/xr829/include/linux/unaligned/access_ok.h
--- a/drivers/net/wireless/xr829/include/linux/unaligned/access_ok.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/unaligned/access_ok.h	2022-08-27 01:22:42.910539695 +0300
@@ -0,0 +1,67 @@
+#ifndef _LINUX_UNALIGNED_ACCESS_OK_H
+#define _LINUX_UNALIGNED_ACCESS_OK_H
+
+#include <linux/kernel.h>
+#include <asm/byteorder.h>
+
+static inline u16 get_unaligned_le16(const void *p)
+{
+	return le16_to_cpup((__le16 *)p);
+}
+
+static inline u32 get_unaligned_le32(const void *p)
+{
+	return le32_to_cpup((__le32 *)p);
+}
+
+static inline u64 get_unaligned_le64(const void *p)
+{
+	return le64_to_cpup((__le64 *)p);
+}
+
+static inline u16 get_unaligned_be16(const void *p)
+{
+	return be16_to_cpup((__be16 *)p);
+}
+
+static inline u32 get_unaligned_be32(const void *p)
+{
+	return be32_to_cpup((__be32 *)p);
+}
+
+static inline u64 get_unaligned_be64(const void *p)
+{
+	return be64_to_cpup((__be64 *)p);
+}
+
+static inline void put_unaligned_le16(u16 val, void *p)
+{
+	*((__le16 *)p) = cpu_to_le16(val);
+}
+
+static inline void put_unaligned_le32(u32 val, void *p)
+{
+	*((__le32 *)p) = cpu_to_le32(val);
+}
+
+static inline void put_unaligned_le64(u64 val, void *p)
+{
+	*((__le64 *)p) = cpu_to_le64(val);
+}
+
+static inline void put_unaligned_be16(u16 val, void *p)
+{
+	*((__be16 *)p) = cpu_to_be16(val);
+}
+
+static inline void put_unaligned_be32(u32 val, void *p)
+{
+	*((__be32 *)p) = cpu_to_be32(val);
+}
+
+static inline void put_unaligned_be64(u64 val, void *p)
+{
+	*((__be64 *)p) = cpu_to_be64(val);
+}
+
+#endif /* _LINUX_UNALIGNED_ACCESS_OK_H */
diff -Naurp a/drivers/net/wireless/xr829/include/linux/unaligned/be_byteshift.h b/drivers/net/wireless/xr829/include/linux/unaligned/be_byteshift.h
--- a/drivers/net/wireless/xr829/include/linux/unaligned/be_byteshift.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/unaligned/be_byteshift.h	2022-08-27 01:22:42.910539695 +0300
@@ -0,0 +1,70 @@
+#ifndef _LINUX_UNALIGNED_BE_BYTESHIFT_H
+#define _LINUX_UNALIGNED_BE_BYTESHIFT_H
+
+#include <linux/types.h>
+
+static inline u16 __get_unaligned_be16(const u8 *p)
+{
+	return p[0] << 8 | p[1];
+}
+
+static inline u32 __get_unaligned_be32(const u8 *p)
+{
+	return p[0] << 24 | p[1] << 16 | p[2] << 8 | p[3];
+}
+
+static inline u64 __get_unaligned_be64(const u8 *p)
+{
+	return (u64)__get_unaligned_be32(p) << 32 |
+	       __get_unaligned_be32(p + 4);
+}
+
+static inline void __put_unaligned_be16(u16 val, u8 *p)
+{
+	*p++ = val >> 8;
+	*p++ = val;
+}
+
+static inline void __put_unaligned_be32(u32 val, u8 *p)
+{
+	__put_unaligned_be16(val >> 16, p);
+	__put_unaligned_be16(val, p + 2);
+}
+
+static inline void __put_unaligned_be64(u64 val, u8 *p)
+{
+	__put_unaligned_be32(val >> 32, p);
+	__put_unaligned_be32(val, p + 4);
+}
+
+static inline u16 get_unaligned_be16(const void *p)
+{
+	return __get_unaligned_be16((const u8 *)p);
+}
+
+static inline u32 get_unaligned_be32(const void *p)
+{
+	return __get_unaligned_be32((const u8 *)p);
+}
+
+static inline u64 get_unaligned_be64(const void *p)
+{
+	return __get_unaligned_be64((const u8 *)p);
+}
+
+static inline void put_unaligned_be16(u16 val, void *p)
+{
+	__put_unaligned_be16(val, p);
+}
+
+static inline void put_unaligned_be32(u32 val, void *p)
+{
+	__put_unaligned_be32(val, p);
+}
+
+static inline void put_unaligned_be64(u64 val, void *p)
+{
+	__put_unaligned_be64(val, p);
+}
+
+#endif /* _LINUX_UNALIGNED_BE_BYTESHIFT_H */
diff -Naurp a/drivers/net/wireless/xr829/include/linux/unaligned/be_memmove.h b/drivers/net/wireless/xr829/include/linux/unaligned/be_memmove.h
--- a/drivers/net/wireless/xr829/include/linux/unaligned/be_memmove.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/unaligned/be_memmove.h	2022-08-27 01:22:42.910539695 +0300
@@ -0,0 +1,36 @@
+#ifndef _LINUX_UNALIGNED_BE_MEMMOVE_H
+#define _LINUX_UNALIGNED_BE_MEMMOVE_H
+
+#include <linux/unaligned/memmove.h>
+
+static inline u16 get_unaligned_be16(const void *p)
+{
+	return __get_unaligned_memmove16((const u8 *)p);
+}
+
+static inline u32 get_unaligned_be32(const void *p)
+{
+	return __get_unaligned_memmove32((const u8 *)p);
+}
+
+static inline u64 get_unaligned_be64(const void *p)
+{
+	return __get_unaligned_memmove64((const u8 *)p);
+}
+
+static inline void put_unaligned_be16(u16 val, void *p)
+{
+	__put_unaligned_memmove16(val, p);
+}
+
+static inline void put_unaligned_be32(u32 val, void *p)
+{
+	__put_unaligned_memmove32(val, p);
+}
+
+static inline void put_unaligned_be64(u64 val, void *p)
+{
+	__put_unaligned_memmove64(val, p);
+}
+
+#endif /* _LINUX_UNALIGNED_LE_MEMMOVE_H */
diff -Naurp a/drivers/net/wireless/xr829/include/linux/unaligned/be_struct.h b/drivers/net/wireless/xr829/include/linux/unaligned/be_struct.h
--- a/drivers/net/wireless/xr829/include/linux/unaligned/be_struct.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/unaligned/be_struct.h	2022-08-27 01:22:42.910539695 +0300
@@ -0,0 +1,36 @@
+#ifndef _LINUX_UNALIGNED_BE_STRUCT_H
+#define _LINUX_UNALIGNED_BE_STRUCT_H
+
+#include <linux/unaligned/packed_struct.h>
+
+static inline u16 get_unaligned_be16(const void *p)
+{
+	return __get_unaligned_cpu16((const u8 *)p);
+}
+
+static inline u32 get_unaligned_be32(const void *p)
+{
+	return __get_unaligned_cpu32((const u8 *)p);
+}
+
+static inline u64 get_unaligned_be64(const void *p)
+{
+	return __get_unaligned_cpu64((const u8 *)p);
+}
+
+static inline void put_unaligned_be16(u16 val, void *p)
+{
+	__put_unaligned_cpu16(val, p);
+}
+
+static inline void put_unaligned_be32(u32 val, void *p)
+{
+	__put_unaligned_cpu32(val, p);
+}
+
+static inline void put_unaligned_be64(u64 val, void *p)
+{
+	__put_unaligned_cpu64(val, p);
+}
+
+#endif /* _LINUX_UNALIGNED_BE_STRUCT_H */
diff -Naurp a/drivers/net/wireless/xr829/include/linux/unaligned/generic.h b/drivers/net/wireless/xr829/include/linux/unaligned/generic.h
--- a/drivers/net/wireless/xr829/include/linux/unaligned/generic.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/unaligned/generic.h	2022-08-27 01:22:42.914539710 +0300
@@ -0,0 +1,68 @@
+#ifndef _LINUX_UNALIGNED_GENERIC_H
+#define _LINUX_UNALIGNED_GENERIC_H
+
+/*
+ * Cause a link-time error if we try an unaligned access other than
+ * 1, 2, 4 or 8 bytes long
+ */
+extern void __bad_unaligned_access_size(void);
+
+#define __get_unaligned_le(ptr) ((__force typeof(*(ptr)))({			\
+	__builtin_choose_expr(sizeof(*(ptr)) == 1, *(ptr),			\
+	__builtin_choose_expr(sizeof(*(ptr)) == 2, get_unaligned_le16((ptr)),	\
+	__builtin_choose_expr(sizeof(*(ptr)) == 4, get_unaligned_le32((ptr)),	\
+	__builtin_choose_expr(sizeof(*(ptr)) == 8, get_unaligned_le64((ptr)),	\
+	__bad_unaligned_access_size()))));					\
+	}))
+
+#define __get_unaligned_be(ptr) ((__force typeof(*(ptr)))({			\
+	__builtin_choose_expr(sizeof(*(ptr)) == 1, *(ptr),			\
+	__builtin_choose_expr(sizeof(*(ptr)) == 2, get_unaligned_be16((ptr)),	\
+	__builtin_choose_expr(sizeof(*(ptr)) == 4, get_unaligned_be32((ptr)),	\
+	__builtin_choose_expr(sizeof(*(ptr)) == 8, get_unaligned_be64((ptr)),	\
+	__bad_unaligned_access_size()))));					\
+	}))
+
+#define __put_unaligned_le(val, ptr) ({					\
+	void *__gu_p = (ptr);						\
+	switch (sizeof(*(ptr))) {					\
+	case 1:								\
+		*(u8 *)__gu_p = (__force u8)(val);			\
+		break;							\
+	case 2:								\
+		put_unaligned_le16((__force u16)(val), __gu_p);		\
+		break;							\
+	case 4:								\
+		put_unaligned_le32((__force u32)(val), __gu_p);		\
+		break;							\
+	case 8:								\
+		put_unaligned_le64((__force u64)(val), __gu_p);		\
+		break;							\
+	default:							\
+		__bad_unaligned_access_size();				\
+		break;							\
+	}								\
+	(void)0; })
+
+#define __put_unaligned_be(val, ptr) ({					\
+	void *__gu_p = (ptr);						\
+	switch (sizeof(*(ptr))) {					\
+	case 1:								\
+		*(u8 *)__gu_p = (__force u8)(val);			\
+		break;							\
+	case 2:								\
+		put_unaligned_be16((__force u16)(val), __gu_p);		\
+		break;							\
+	case 4:								\
+		put_unaligned_be32((__force u32)(val), __gu_p);		\
+		break;							\
+	case 8:								\
+		put_unaligned_be64((__force u64)(val), __gu_p);		\
+		break;							\
+	default:							\
+		__bad_unaligned_access_size();				\
+		break;							\
+	}								\
+	(void)0; })
+
+#endif /* _LINUX_UNALIGNED_GENERIC_H */
diff -Naurp a/drivers/net/wireless/xr829/include/linux/unaligned/le_byteshift.h b/drivers/net/wireless/xr829/include/linux/unaligned/le_byteshift.h
--- a/drivers/net/wireless/xr829/include/linux/unaligned/le_byteshift.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/unaligned/le_byteshift.h	2022-08-27 01:22:42.914539710 +0300
@@ -0,0 +1,70 @@
+#ifndef _LINUX_UNALIGNED_LE_BYTESHIFT_H
+#define _LINUX_UNALIGNED_LE_BYTESHIFT_H
+
+#include <linux/types.h>
+
+static inline u16 __get_unaligned_le16(const u8 *p)
+{
+	return p[0] | p[1] << 8;
+}
+
+static inline u32 __get_unaligned_le32(const u8 *p)
+{
+	return p[0] | p[1] << 8 | p[2] << 16 | p[3] << 24;
+}
+
+static inline u64 __get_unaligned_le64(const u8 *p)
+{
+	return (u64)__get_unaligned_le32(p + 4) << 32 |
+	       __get_unaligned_le32(p);
+}
+
+static inline void __put_unaligned_le16(u16 val, u8 *p)
+{
+	*p++ = val;
+	*p++ = val >> 8;
+}
+
+static inline void __put_unaligned_le32(u32 val, u8 *p)
+{
+	__put_unaligned_le16(val >> 16, p + 2);
+	__put_unaligned_le16(val, p);
+}
+
+static inline void __put_unaligned_le64(u64 val, u8 *p)
+{
+	__put_unaligned_le32(val >> 32, p + 4);
+	__put_unaligned_le32(val, p);
+}
+
+static inline u16 get_unaligned_le16(const void *p)
+{
+	return __get_unaligned_le16((const u8 *)p);
+}
+
+static inline u32 get_unaligned_le32(const void *p)
+{
+	return __get_unaligned_le32((const u8 *)p);
+}
+
+static inline u64 get_unaligned_le64(const void *p)
+{
+	return __get_unaligned_le64((const u8 *)p);
+}
+
+static inline void put_unaligned_le16(u16 val, void *p)
+{
+	__put_unaligned_le16(val, p);
+}
+
+static inline void put_unaligned_le32(u32 val, void *p)
+{
+	__put_unaligned_le32(val, p);
+}
+
+static inline void put_unaligned_le64(u64 val, void *p)
+{
+	__put_unaligned_le64(val, p);
+}
+
+#endif /* _LINUX_UNALIGNED_LE_BYTESHIFT_H */
diff -Naurp a/drivers/net/wireless/xr829/include/linux/unaligned/le_memmove.h b/drivers/net/wireless/xr829/include/linux/unaligned/le_memmove.h
--- a/drivers/net/wireless/xr829/include/linux/unaligned/le_memmove.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/unaligned/le_memmove.h	2022-08-27 01:22:42.914539710 +0300
@@ -0,0 +1,36 @@
+#ifndef _LINUX_UNALIGNED_LE_MEMMOVE_H
+#define _LINUX_UNALIGNED_LE_MEMMOVE_H
+
+#include <linux/unaligned/memmove.h>
+
+static inline u16 get_unaligned_le16(const void *p)
+{
+	return __get_unaligned_memmove16((const u8 *)p);
+}
+
+static inline u32 get_unaligned_le32(const void *p)
+{
+	return __get_unaligned_memmove32((const u8 *)p);
+}
+
+static inline u64 get_unaligned_le64(const void *p)
+{
+	return __get_unaligned_memmove64((const u8 *)p);
+}
+
+static inline void put_unaligned_le16(u16 val, void *p)
+{
+	__put_unaligned_memmove16(val, p);
+}
+
+static inline void put_unaligned_le32(u32 val, void *p)
+{
+	__put_unaligned_memmove32(val, p);
+}
+
+static inline void put_unaligned_le64(u64 val, void *p)
+{
+	__put_unaligned_memmove64(val, p);
+}
+
+#endif /* _LINUX_UNALIGNED_LE_MEMMOVE_H */
diff -Naurp a/drivers/net/wireless/xr829/include/linux/unaligned/le_struct.h b/drivers/net/wireless/xr829/include/linux/unaligned/le_struct.h
--- a/drivers/net/wireless/xr829/include/linux/unaligned/le_struct.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/unaligned/le_struct.h	2022-08-27 01:22:42.914539710 +0300
@@ -0,0 +1,36 @@
+#ifndef _LINUX_UNALIGNED_LE_STRUCT_H
+#define _LINUX_UNALIGNED_LE_STRUCT_H
+
+#include <linux/unaligned/packed_struct.h>
+
+static inline u16 get_unaligned_le16(const void *p)
+{
+	return __get_unaligned_cpu16((const u8 *)p);
+}
+
+static inline u32 get_unaligned_le32(const void *p)
+{
+	return __get_unaligned_cpu32((const u8 *)p);
+}
+
+static inline u64 get_unaligned_le64(const void *p)
+{
+	return __get_unaligned_cpu64((const u8 *)p);
+}
+
+static inline void put_unaligned_le16(u16 val, void *p)
+{
+	__put_unaligned_cpu16(val, p);
+}
+
+static inline void put_unaligned_le32(u32 val, void *p)
+{
+	__put_unaligned_cpu32(val, p);
+}
+
+static inline void put_unaligned_le64(u64 val, void *p)
+{
+	__put_unaligned_cpu64(val, p);
+}
+
+#endif /* _LINUX_UNALIGNED_LE_STRUCT_H */
diff -Naurp a/drivers/net/wireless/xr829/include/linux/unaligned/memmove.h b/drivers/net/wireless/xr829/include/linux/unaligned/memmove.h
--- a/drivers/net/wireless/xr829/include/linux/unaligned/memmove.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/unaligned/memmove.h	2022-08-27 01:22:42.914539710 +0300
@@ -0,0 +1,45 @@
+#ifndef _LINUX_UNALIGNED_MEMMOVE_H
+#define _LINUX_UNALIGNED_MEMMOVE_H
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+
+/* Use memmove here, so gcc does not insert a __builtin_memcpy. */
+
+static inline u16 __get_unaligned_memmove16(const void *p)
+{
+	u16 tmp;
+	memmove(&tmp, p, 2);
+	return tmp;
+}
+
+static inline u32 __get_unaligned_memmove32(const void *p)
+{
+	u32 tmp;
+	memmove(&tmp, p, 4);
+	return tmp;
+}
+
+static inline u64 __get_unaligned_memmove64(const void *p)
+{
+	u64 tmp;
+	memmove(&tmp, p, 8);
+	return tmp;
+}
+
+static inline void __put_unaligned_memmove16(u16 val, void *p)
+{
+	memmove(p, &val, 2);
+}
+
+static inline void __put_unaligned_memmove32(u32 val, void *p)
+{
+	memmove(p, &val, 4);
+}
+
+static inline void __put_unaligned_memmove64(u64 val, void *p)
+{
+	memmove(p, &val, 8);
+}
+
+#endif /* _LINUX_UNALIGNED_MEMMOVE_H */
diff -Naurp a/drivers/net/wireless/xr829/include/linux/unaligned/packed_struct.h b/drivers/net/wireless/xr829/include/linux/unaligned/packed_struct.h
--- a/drivers/net/wireless/xr829/include/linux/unaligned/packed_struct.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/unaligned/packed_struct.h	2022-08-27 01:22:42.914539710 +0300
@@ -0,0 +1,46 @@
+#ifndef _LINUX_UNALIGNED_PACKED_STRUCT_H
+#define _LINUX_UNALIGNED_PACKED_STRUCT_H
+
+#include <linux/kernel.h>
+
+struct __una_u16 { u16 x; } __packed;
+struct __una_u32 { u32 x; } __packed;
+struct __una_u64 { u64 x; } __packed;
+
+static inline u16 __get_unaligned_cpu16(const void *p)
+{
+	const struct __una_u16 *ptr = (const struct __una_u16 *)p;
+	return ptr->x;
+}
+
+static inline u32 __get_unaligned_cpu32(const void *p)
+{
+	const struct __una_u32 *ptr = (const struct __una_u32 *)p;
+	return ptr->x;
+}
+
+static inline u64 __get_unaligned_cpu64(const void *p)
+{
+	const struct __una_u64 *ptr = (const struct __una_u64 *)p;
+	return ptr->x;
+}
+
+static inline void __put_unaligned_cpu16(u16 val, void *p)
+{
+	struct __una_u16 *ptr = (struct __una_u16 *)p;
+	ptr->x = val;
+}
+
+static inline void __put_unaligned_cpu32(u32 val, void *p)
+{
+	struct __una_u32 *ptr = (struct __una_u32 *)p;
+	ptr->x = val;
+}
+
+static inline void __put_unaligned_cpu64(u64 val, void *p)
+{
+	struct __una_u64 *ptr = (struct __una_u64 *)p;
+	ptr->x = val;
+}
+
+#endif /* _LINUX_UNALIGNED_PACKED_STRUCT_H */
diff -Naurp a/drivers/net/wireless/xr829/include/linux/wireless.h b/drivers/net/wireless/xr829/include/linux/wireless.h
--- a/drivers/net/wireless/xr829/include/linux/wireless.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/linux/wireless.h	2022-08-27 01:22:42.914539710 +0300
@@ -0,0 +1,1107 @@
+/*
+ * This file define a set of standard wireless extensions
+ *
+ * Version :	22	16.3.07
+ *
+ * Authors :	Jean Tourrilhes - HPL - <jt@hpl.hp.com>
+ * Copyright (c) 1997-2007 Jean Tourrilhes, All Rights Reserved.
+ */
+
+#ifndef _UAPI_LINUX_WIRELESS_H
+#define _UAPI_LINUX_WIRELESS_H
+
+/************************** DOCUMENTATION **************************/
+/*
+ * Initial APIs (1996 -> onward) :
+ * -----------------------------
+ * Basically, the wireless extensions are for now a set of standard ioctl
+ * call + /proc/net/wireless
+ *
+ * The entry /proc/net/wireless give statistics and information on the
+ * driver.
+ * This is better than having each driver having its entry because
+ * its centralised and we may remove the driver module safely.
+ *
+ * Ioctl are used to configure the driver and issue commands.  This is
+ * better than command line options of insmod because we may want to
+ * change dynamically (while the driver is running) some parameters.
+ *
+ * The ioctl mechanimsm are copied from standard devices ioctl.
+ * We have the list of command plus a structure descibing the
+ * data exchanged...
+ * Note that to add these ioctl, I was obliged to modify :
+ *	# net/core/dev.c (two place + add include)
+ *	# net/ipv4/af_inet.c (one place + add include)
+ *
+ * /proc/net/wireless is a copy of /proc/net/dev.
+ * We have a structure for data passed from the driver to /proc/net/wireless
+ * Too add this, I've modified :
+ *	# net/core/dev.c (two other places)
+ *	# include/linux/netdevice.h (one place)
+ *	# include/linux/proc_fs.h (one place)
+ *
+ * New driver API (2002 -> onward) :
+ * -------------------------------
+ * This file is only concerned with the user space API and common definitions.
+ * The new driver API is defined and documented in :
+ *	# include/net/iw_handler.h
+ *
+ * Note as well that /proc/net/wireless implementation has now moved in :
+ *	# net/core/wireless.c
+ *
+ * Wireless Events (2002 -> onward) :
+ * --------------------------------
+ * Events are defined at the end of this file, and implemented in :
+ *	# net/core/wireless.c
+ *
+ * Other comments :
+ * --------------
+ * Do not add here things that are redundant with other mechanisms
+ * (drivers init, ifconfig, /proc/net/dev, ...) and with are not
+ * wireless specific.
+ *
+ * These wireless extensions are not magic : each driver has to provide
+ * support for them...
+ *
+ * IMPORTANT NOTE : As everything in the kernel, this is very much a
+ * work in progress. Contact me if you have ideas of improvements...
+ */
+
+/***************************** INCLUDES *****************************/
+
+#include <linux/types.h>		/* for __u* and __s* typedefs */
+#include <linux/socket.h>		/* for "struct sockaddr" et al	*/
+#include <linux/if.h>			/* for IFNAMSIZ and co... */
+
+/***************************** VERSION *****************************/
+/*
+ * This constant is used to know the availability of the wireless
+ * extensions and to know which version of wireless extensions it is
+ * (there is some stuff that will be added in the future...)
+ * I just plan to increment with each new version.
+ */
+#define WIRELESS_EXT	22
+
+/*
+ * Changes :
+ *
+ * V2 to V3
+ * --------
+ *	Alan Cox start some incompatibles changes. I've integrated a bit more.
+ *	- Encryption renamed to Encode to avoid US regulation problems
+ *	- Frequency changed from float to struct to avoid problems on old 386
+ *
+ * V3 to V4
+ * --------
+ *	- Add sensitivity
+ *
+ * V4 to V5
+ * --------
+ *	- Missing encoding definitions in range
+ *	- Access points stuff
+ *
+ * V5 to V6
+ * --------
+ *	- 802.11 support (ESSID ioctls)
+ *
+ * V6 to V7
+ * --------
+ *	- define IW_ESSID_MAX_SIZE and IW_MAX_AP
+ *
+ * V7 to V8
+ * --------
+ *	- Changed my e-mail address
+ *	- More 802.11 support (nickname, rate, rts, frag)
+ *	- List index in frequencies
+ *
+ * V8 to V9
+ * --------
+ *	- Support for 'mode of operation' (ad-hoc, managed...)
+ *	- Support for unicast and multicast power saving
+ *	- Change encoding to support larger tokens (>64 bits)
+ *	- Updated iw_params (disable, flags) and use it for NWID
+ *	- Extracted iw_point from iwreq for clarity
+ *
+ * V9 to V10
+ * ---------
+ *	- Add PM capability to range structure
+ *	- Add PM modifier : MAX/MIN/RELATIVE
+ *	- Add encoding option : IW_ENCODE_NOKEY
+ *	- Add TxPower ioctls (work like TxRate)
+ *
+ * V10 to V11
+ * ----------
+ *	- Add WE version in range (help backward/forward compatibility)
+ *	- Add retry ioctls (work like PM)
+ *
+ * V11 to V12
+ * ----------
+ *	- Add SIOCSIWSTATS to get /proc/net/wireless programatically
+ *	- Add DEV PRIVATE IOCTL to avoid collisions in SIOCDEVPRIVATE space
+ *	- Add new statistics (frag, retry, beacon)
+ *	- Add average quality (for user space calibration)
+ *
+ * V12 to V13
+ * ----------
+ *	- Document creation of new driver API.
+ *	- Extract union iwreq_data from struct iwreq (for new driver API).
+ *	- Rename SIOCSIWNAME as SIOCSIWCOMMIT
+ *
+ * V13 to V14
+ * ----------
+ *	- Wireless Events support : define struct iw_event
+ *	- Define additional specific event numbers
+ *	- Add "addr" and "param" fields in union iwreq_data
+ *	- AP scanning stuff (SIOCSIWSCAN and friends)
+ *
+ * V14 to V15
+ * ----------
+ *	- Add IW_PRIV_TYPE_ADDR for struct sockaddr private arg
+ *	- Make struct iw_freq signed (both m & e), add explicit padding
+ *	- Add IWEVCUSTOM for driver specific event/scanning token
+ *	- Add IW_MAX_GET_SPY for driver returning a lot of addresses
+ *	- Add IW_TXPOW_RANGE for range of Tx Powers
+ *	- Add IWEVREGISTERED & IWEVEXPIRED events for Access Points
+ *	- Add IW_MODE_MONITOR for passive monitor
+ *
+ * V15 to V16
+ * ----------
+ *	- Increase the number of bitrates in iw_range to 32 (for 802.11g)
+ *	- Increase the number of frequencies in iw_range to 32 (for 802.11b+a)
+ *	- Reshuffle struct iw_range for increases, add filler
+ *	- Increase IW_MAX_AP to 64 for driver returning a lot of addresses
+ *	- Remove IW_MAX_GET_SPY because conflict with enhanced spy support
+ *	- Add SIOCSIWTHRSPY/SIOCGIWTHRSPY and "struct iw_thrspy"
+ *	- Add IW_ENCODE_TEMP and iw_range->encoding_login_index
+ *
+ * V16 to V17
+ * ----------
+ *	- Add flags to frequency -> auto/fixed
+ *	- Document (struct iw_quality *)->updated, add new flags (INVALID)
+ *	- Wireless Event capability in struct iw_range
+ *	- Add support for relative TxPower (yick !)
+ *
+ * V17 to V18 (From Jouni Malinen <j@w1.fi>)
+ * ----------
+ *	- Add support for WPA/WPA2
+ *	- Add extended encoding configuration (SIOCSIWENCODEEXT and
+ *	  SIOCGIWENCODEEXT)
+ *	- Add SIOCSIWGENIE/SIOCGIWGENIE
+ *	- Add SIOCSIWMLME
+ *	- Add SIOCSIWPMKSA
+ *	- Add struct iw_range bit field for supported encoding capabilities
+ *	- Add optional scan request parameters for SIOCSIWSCAN
+ *	- Add SIOCSIWAUTH/SIOCGIWAUTH for setting authentication and WPA
+ *	  related parameters (extensible up to 4096 parameter values)
+ *	- Add wireless events: IWEVGENIE, IWEVMICHAELMICFAILURE,
+ *	  IWEVASSOCREQIE, IWEVASSOCRESPIE, IWEVPMKIDCAND
+ *
+ * V18 to V19
+ * ----------
+ *	- Remove (struct iw_point *)->pointer from events and streams
+ *	- Remove header includes to help user space
+ *	- Increase IW_ENCODING_TOKEN_MAX from 32 to 64
+ *	- Add IW_QUAL_ALL_UPDATED and IW_QUAL_ALL_INVALID macros
+ *	- Add explicit flag to tell stats are in dBm : IW_QUAL_DBM
+ *	- Add IW_IOCTL_IDX() and IW_EVENT_IDX() macros
+ *
+ * V19 to V20
+ * ----------
+ *	- RtNetlink requests support (SET/GET)
+ *
+ * V20 to V21
+ * ----------
+ *	- Remove (struct net_device *)->get_wireless_stats()
+ *	- Change length in ESSID and NICK to strlen() instead of strlen()+1
+ *	- Add IW_RETRY_SHORT/IW_RETRY_LONG retry modifiers
+ *	- Power/Retry relative values no longer * 100000
+ *	- Add explicit flag to tell stats are in 802.11k RCPI : IW_QUAL_RCPI
+ *
+ * V21 to V22
+ * ----------
+ *	- Prevent leaking of kernel space in stream on 64 bits.
+ */
+
+/**************************** CONSTANTS ****************************/
+
+/* -------------------------- IOCTL LIST -------------------------- */
+
+/* Wireless Identification */
+#define SIOCSIWCOMMIT	0x8B00		/* Commit pending changes to driver */
+#define SIOCGIWNAME	0x8B01		/* get name == wireless protocol */
+/* SIOCGIWNAME is used to verify the presence of Wireless Extensions.
+ * Common values : "IEEE 802.11-DS", "IEEE 802.11-FH", "IEEE 802.11b"...
+ * Don't put the name of your driver there, it's useless. */
+
+/* Basic operations */
+#define SIOCSIWNWID	0x8B02		/* set network id (pre-802.11) */
+#define SIOCGIWNWID	0x8B03		/* get network id (the cell) */
+#define SIOCSIWFREQ	0x8B04		/* set channel/frequency (Hz) */
+#define SIOCGIWFREQ	0x8B05		/* get channel/frequency (Hz) */
+#define SIOCSIWMODE	0x8B06		/* set operation mode */
+#define SIOCGIWMODE	0x8B07		/* get operation mode */
+#define SIOCSIWSENS	0x8B08		/* set sensitivity (dBm) */
+#define SIOCGIWSENS	0x8B09		/* get sensitivity (dBm) */
+
+/* Informative stuff */
+#define SIOCSIWRANGE	0x8B0A		/* Unused */
+#define SIOCGIWRANGE	0x8B0B		/* Get range of parameters */
+#define SIOCSIWPRIV	0x8B0C		/* Unused */
+#define SIOCGIWPRIV	0x8B0D		/* get private ioctl interface info */
+#define SIOCSIWSTATS	0x8B0E		/* Unused */
+#define SIOCGIWSTATS	0x8B0F		/* Get /proc/net/wireless stats */
+/* SIOCGIWSTATS is strictly used between user space and the kernel, and
+ * is never passed to the driver (i.e. the driver will never see it). */
+
+/* Spy support (statistics per MAC address - used for Mobile IP support) */
+#define SIOCSIWSPY	0x8B10		/* set spy addresses */
+#define SIOCGIWSPY	0x8B11		/* get spy info (quality of link) */
+#define SIOCSIWTHRSPY	0x8B12		/* set spy threshold (spy event) */
+#define SIOCGIWTHRSPY	0x8B13		/* get spy threshold */
+
+/* Access Point manipulation */
+#define SIOCSIWAP	0x8B14		/* set access point MAC addresses */
+#define SIOCGIWAP	0x8B15		/* get access point MAC addresses */
+#define SIOCGIWAPLIST	0x8B17		/* Deprecated in favor of scanning */
+#define SIOCSIWSCAN	0x8B18		/* trigger scanning (list cells) */
+#define SIOCGIWSCAN	0x8B19		/* get scanning results */
+
+/* 802.11 specific support */
+#define SIOCSIWESSID	0x8B1A		/* set ESSID (network name) */
+#define SIOCGIWESSID	0x8B1B		/* get ESSID */
+#define SIOCSIWNICKN	0x8B1C		/* set node name/nickname */
+#define SIOCGIWNICKN	0x8B1D		/* get node name/nickname */
+/* As the ESSID and NICKN are strings up to 32 bytes long, it doesn't fit
+ * within the 'iwreq' structure, so we need to use the 'data' member to
+ * point to a string in user space, like it is done for RANGE... */
+
+/* Other parameters useful in 802.11 and some other devices */
+#define SIOCSIWRATE	0x8B20		/* set default bit rate (bps) */
+#define SIOCGIWRATE	0x8B21		/* get default bit rate (bps) */
+#define SIOCSIWRTS	0x8B22		/* set RTS/CTS threshold (bytes) */
+#define SIOCGIWRTS	0x8B23		/* get RTS/CTS threshold (bytes) */
+#define SIOCSIWFRAG	0x8B24		/* set fragmentation thr (bytes) */
+#define SIOCGIWFRAG	0x8B25		/* get fragmentation thr (bytes) */
+#define SIOCSIWTXPOW	0x8B26		/* set transmit power (dBm) */
+#define SIOCGIWTXPOW	0x8B27		/* get transmit power (dBm) */
+#define SIOCSIWRETRY	0x8B28		/* set retry limits and lifetime */
+#define SIOCGIWRETRY	0x8B29		/* get retry limits and lifetime */
+
+/* Encoding stuff (scrambling, hardware security, WEP...) */
+#define SIOCSIWENCODE	0x8B2A		/* set encoding token & mode */
+#define SIOCGIWENCODE	0x8B2B		/* get encoding token & mode */
+/* Power saving stuff (power management, unicast and multicast) */
+#define SIOCSIWPOWER	0x8B2C		/* set Power Management settings */
+#define SIOCGIWPOWER	0x8B2D		/* get Power Management settings */
+
+/* WPA : Generic IEEE 802.11 informatiom element (e.g., for WPA/RSN/WMM).
+ * This ioctl uses struct iw_point and data buffer that includes IE id and len
+ * fields. More than one IE may be included in the request. Setting the generic
+ * IE to empty buffer (len=0) removes the generic IE from the driver. Drivers
+ * are allowed to generate their own WPA/RSN IEs, but in these cases, drivers
+ * are required to report the used IE as a wireless event, e.g., when
+ * associating with an AP. */
+#define SIOCSIWGENIE	0x8B30		/* set generic IE */
+#define SIOCGIWGENIE	0x8B31		/* get generic IE */
+
+/* WPA : IEEE 802.11 MLME requests */
+#define SIOCSIWMLME	0x8B16		/* request MLME operation; uses
+					 * struct iw_mlme */
+/* WPA : Authentication mode parameters */
+#define SIOCSIWAUTH	0x8B32		/* set authentication mode params */
+#define SIOCGIWAUTH	0x8B33		/* get authentication mode params */
+
+/* WPA : Extended version of encoding configuration */
+#define SIOCSIWENCODEEXT 0x8B34		/* set encoding token & mode */
+#define SIOCGIWENCODEEXT 0x8B35		/* get encoding token & mode */
+
+/* WPA2 : PMKSA cache management */
+#define SIOCSIWPMKSA	0x8B36		/* PMKSA cache operation */
+
+/* -------------------- DEV PRIVATE IOCTL LIST -------------------- */
+
+/* These 32 ioctl are wireless device private, for 16 commands.
+ * Each driver is free to use them for whatever purpose it chooses,
+ * however the driver *must* export the description of those ioctls
+ * with SIOCGIWPRIV and *must* use arguments as defined below.
+ * If you don't follow those rules, DaveM is going to hate you (reason :
+ * it make mixed 32/64bit operation impossible).
+ */
+#define SIOCIWFIRSTPRIV	0x8BE0
+#define SIOCIWLASTPRIV	0x8BFF
+/* Previously, we were using SIOCDEVPRIVATE, but we now have our
+ * separate range because of collisions with other tools such as
+ * 'mii-tool'.
+ * We now have 32 commands, so a bit more space ;-).
+ * Also, all 'even' commands are only usable by root and don't return the
+ * content of ifr/iwr to user (but you are not obliged to use the set/get
+ * convention, just use every other two command). More details in iwpriv.c.
+ * And I repeat : you are not forced to use them with iwpriv, but you
+ * must be compliant with it.
+ */
+
+/* ------------------------- IOCTL STUFF ------------------------- */
+
+/* The first and the last (range) */
+#define SIOCIWFIRST	0x8B00
+#define SIOCIWLAST	SIOCIWLASTPRIV		/* 0x8BFF */
+#define IW_IOCTL_IDX(cmd)	((cmd) - SIOCIWFIRST)
+#define IW_HANDLER(id, func)			\
+	[IW_IOCTL_IDX(id)] = func
+
+/* Odd : get (world access), even : set (root access) */
+#define IW_IS_SET(cmd)	(!((cmd) & 0x1))
+#define IW_IS_GET(cmd)	((cmd) & 0x1)
+
+/* ----------------------- WIRELESS EVENTS ----------------------- */
+/* Those are *NOT* ioctls, do not issue request on them !!! */
+/* Most events use the same identifier as ioctl requests */
+
+#define IWEVTXDROP	0x8C00		/* Packet dropped to excessive retry */
+#define IWEVQUAL	0x8C01		/* Quality part of statistics (scan) */
+#define IWEVCUSTOM	0x8C02		/* Driver specific ascii string */
+#define IWEVREGISTERED	0x8C03		/* Discovered a new node (AP mode) */
+#define IWEVEXPIRED	0x8C04		/* Expired a node (AP mode) */
+#define IWEVGENIE	0x8C05		/* Generic IE (WPA, RSN, WMM, ..)
+					 * (scan results); This includes id and
+					 * length fields. One IWEVGENIE may
+					 * contain more than one IE. Scan
+					 * results may contain one or more
+					 * IWEVGENIE events. */
+#define IWEVMICHAELMICFAILURE 0x8C06	/* Michael MIC failure
+					 * (struct iw_michaelmicfailure)
+					 */
+#define IWEVASSOCREQIE	0x8C07		/* IEs used in (Re)Association Request.
+					 * The data includes id and length
+					 * fields and may contain more than one
+					 * IE. This event is required in
+					 * Managed mode if the driver
+					 * generates its own WPA/RSN IE. This
+					 * should be sent just before
+					 * IWEVREGISTERED event for the
+					 * association. */
+#define IWEVASSOCRESPIE	0x8C08		/* IEs used in (Re)Association
+					 * Response. The data includes id and
+					 * length fields and may contain more
+					 * than one IE. This may be sent
+					 * between IWEVASSOCREQIE and
+					 * IWEVREGISTERED events for the
+					 * association. */
+#define IWEVPMKIDCAND	0x8C09		/* PMKID candidate for RSN
+					 * pre-authentication
+					 * (struct iw_pmkid_cand) */
+
+#define IWEVFIRST	0x8C00
+#define IW_EVENT_IDX(cmd)	((cmd) - IWEVFIRST)
+
+/* ------------------------- PRIVATE INFO ------------------------- */
+/*
+ * The following is used with SIOCGIWPRIV. It allow a driver to define
+ * the interface (name, type of data) for its private ioctl.
+ * Privates ioctl are SIOCIWFIRSTPRIV -> SIOCIWLASTPRIV
+ */
+
+#define IW_PRIV_TYPE_MASK	0x7000	/* Type of arguments */
+#define IW_PRIV_TYPE_NONE	0x0000
+#define IW_PRIV_TYPE_BYTE	0x1000	/* Char as number */
+#define IW_PRIV_TYPE_CHAR	0x2000	/* Char as character */
+#define IW_PRIV_TYPE_INT	0x4000	/* 32 bits int */
+#define IW_PRIV_TYPE_FLOAT	0x5000	/* struct iw_freq */
+#define IW_PRIV_TYPE_ADDR	0x6000	/* struct sockaddr */
+
+#define IW_PRIV_SIZE_FIXED	0x0800	/* Variable or fixed number of args */
+
+#define IW_PRIV_SIZE_MASK	0x07FF	/* Max number of those args */
+
+/*
+ * Note : if the number of args is fixed and the size < 16 octets,
+ * instead of passing a pointer we will put args in the iwreq struct...
+ */
+
+/* ----------------------- OTHER CONSTANTS ----------------------- */
+
+/* Maximum frequencies in the range struct */
+#define IW_MAX_FREQUENCIES	32
+/* Note : if you have something like 80 frequencies,
+ * don't increase this constant and don't fill the frequency list.
+ * The user will be able to set by channel anyway... */
+
+/* Maximum bit rates in the range struct */
+#define IW_MAX_BITRATES		32
+
+/* Maximum tx powers in the range struct */
+#define IW_MAX_TXPOWER		8
+/* Note : if you more than 8 TXPowers, just set the max and min or
+ * a few of them in the struct iw_range. */
+
+/* Maximum of address that you may set with SPY */
+#define IW_MAX_SPY		8
+
+/* Maximum of address that you may get in the
+   list of access points in range */
+#define IW_MAX_AP		64
+
+/* Maximum size of the ESSID and NICKN strings */
+#define IW_ESSID_MAX_SIZE	32
+
+/* Modes of operation */
+#define IW_MODE_AUTO	0	/* Let the driver decides */
+#define IW_MODE_ADHOC	1	/* Single cell network */
+#define IW_MODE_INFRA	2	/* Multi cell network, roaming, ... */
+#define IW_MODE_MASTER	3	/* Synchronisation master or Access Point */
+#define IW_MODE_REPEAT	4	/* Wireless Repeater (forwarder) */
+#define IW_MODE_SECOND	5	/* Secondary master/repeater (backup) */
+#define IW_MODE_MONITOR	6	/* Passive monitor (listen only) */
+#define IW_MODE_MESH	7	/* Mesh (IEEE 802.11s) network */
+
+/* Statistics flags (bitmask in updated) */
+#define IW_QUAL_QUAL_UPDATED	0x01	/* Value was updated since last read */
+#define IW_QUAL_LEVEL_UPDATED	0x02
+#define IW_QUAL_NOISE_UPDATED	0x04
+#define IW_QUAL_ALL_UPDATED	0x07
+#define IW_QUAL_DBM		0x08	/* Level + Noise are dBm */
+#define IW_QUAL_QUAL_INVALID	0x10	/* Driver doesn't provide value */
+#define IW_QUAL_LEVEL_INVALID	0x20
+#define IW_QUAL_NOISE_INVALID	0x40
+#define IW_QUAL_RCPI		0x80	/* Level + Noise are 802.11k RCPI */
+#define IW_QUAL_ALL_INVALID	0x70
+
+/* Frequency flags */
+#define IW_FREQ_AUTO		0x00	/* Let the driver decides */
+#define IW_FREQ_FIXED		0x01	/* Force a specific value */
+
+/* Maximum number of size of encoding token available
+ * they are listed in the range structure */
+#define IW_MAX_ENCODING_SIZES	8
+
+/* Maximum size of the encoding token in bytes */
+#define IW_ENCODING_TOKEN_MAX	64	/* 512 bits (for now) */
+
+/* Flags for encoding (along with the token) */
+#define IW_ENCODE_INDEX		0x00FF	/* Token index (if needed) */
+#define IW_ENCODE_FLAGS		0xFF00	/* Flags defined below */
+#define IW_ENCODE_MODE		0xF000	/* Modes defined below */
+#define IW_ENCODE_DISABLED	0x8000	/* Encoding disabled */
+#define IW_ENCODE_ENABLED	0x0000	/* Encoding enabled */
+#define IW_ENCODE_RESTRICTED	0x4000	/* Refuse non-encoded packets */
+#define IW_ENCODE_OPEN		0x2000	/* Accept non-encoded packets */
+#define IW_ENCODE_NOKEY		0x0800  /* Key is write only, so not present */
+#define IW_ENCODE_TEMP		0x0400  /* Temporary key */
+
+/* Power management flags available (along with the value, if any) */
+#define IW_POWER_ON		0x0000	/* No details... */
+#define IW_POWER_TYPE		0xF000	/* Type of parameter */
+#define IW_POWER_PERIOD		0x1000	/* Value is a period/duration of  */
+#define IW_POWER_TIMEOUT	0x2000	/* Value is a timeout (to go asleep) */
+#define IW_POWER_MODE		0x0F00	/* Power Management mode */
+#define IW_POWER_UNICAST_R	0x0100	/* Receive only unicast messages */
+#define IW_POWER_MULTICAST_R	0x0200	/* Receive only multicast messages */
+#define IW_POWER_ALL_R		0x0300	/* Receive all messages though PM */
+#define IW_POWER_FORCE_S	0x0400	/* Force PM procedure for sending unicast */
+#define IW_POWER_REPEATER	0x0800	/* Repeat broadcast messages in PM period */
+#define IW_POWER_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_POWER_MIN		0x0001	/* Value is a minimum  */
+#define IW_POWER_MAX		0x0002	/* Value is a maximum */
+#define IW_POWER_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+
+/* Transmit Power flags available */
+#define IW_TXPOW_TYPE		0x00FF	/* Type of value */
+#define IW_TXPOW_DBM		0x0000	/* Value is in dBm */
+#define IW_TXPOW_MWATT		0x0001	/* Value is in mW */
+#define IW_TXPOW_RELATIVE	0x0002	/* Value is in arbitrary units */
+#define IW_TXPOW_RANGE		0x1000	/* Range of value between min/max */
+
+/* Retry limits and lifetime flags available */
+#define IW_RETRY_ON		0x0000	/* No details... */
+#define IW_RETRY_TYPE		0xF000	/* Type of parameter */
+#define IW_RETRY_LIMIT		0x1000	/* Maximum number of retries*/
+#define IW_RETRY_LIFETIME	0x2000	/* Maximum duration of retries in us */
+#define IW_RETRY_MODIFIER	0x00FF	/* Modify a parameter */
+#define IW_RETRY_MIN		0x0001	/* Value is a minimum  */
+#define IW_RETRY_MAX		0x0002	/* Value is a maximum */
+#define IW_RETRY_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+#define IW_RETRY_SHORT		0x0010	/* Value is for short packets  */
+#define IW_RETRY_LONG		0x0020	/* Value is for long packets */
+
+/* Scanning request flags */
+#define IW_SCAN_DEFAULT		0x0000	/* Default scan of the driver */
+#define IW_SCAN_ALL_ESSID	0x0001	/* Scan all ESSIDs */
+#define IW_SCAN_THIS_ESSID	0x0002	/* Scan only this ESSID */
+#define IW_SCAN_ALL_FREQ	0x0004	/* Scan all Frequencies */
+#define IW_SCAN_THIS_FREQ	0x0008	/* Scan only this Frequency */
+#define IW_SCAN_ALL_MODE	0x0010	/* Scan all Modes */
+#define IW_SCAN_THIS_MODE	0x0020	/* Scan only this Mode */
+#define IW_SCAN_ALL_RATE	0x0040	/* Scan all Bit-Rates */
+#define IW_SCAN_THIS_RATE	0x0080	/* Scan only this Bit-Rate */
+/* struct iw_scan_req scan_type */
+#define IW_SCAN_TYPE_ACTIVE 0
+#define IW_SCAN_TYPE_PASSIVE 1
+/* Maximum size of returned data */
+#define IW_SCAN_MAX_DATA	4096	/* In bytes */
+
+/* Scan capability flags - in (struct iw_range *)->scan_capa */
+#define IW_SCAN_CAPA_NONE		0x00
+#define IW_SCAN_CAPA_ESSID		0x01
+#define IW_SCAN_CAPA_BSSID		0x02
+#define IW_SCAN_CAPA_CHANNEL	0x04
+#define IW_SCAN_CAPA_MODE		0x08
+#define IW_SCAN_CAPA_RATE		0x10
+#define IW_SCAN_CAPA_TYPE		0x20
+#define IW_SCAN_CAPA_TIME		0x40
+
+/* Max number of char in custom event - use multiple of them if needed */
+#define IW_CUSTOM_MAX		256	/* In bytes */
+
+/* Generic information element */
+#define IW_GENERIC_IE_MAX	1024
+
+/* MLME requests (SIOCSIWMLME / struct iw_mlme) */
+#define IW_MLME_DEAUTH		0
+#define IW_MLME_DISASSOC	1
+#define IW_MLME_AUTH		2
+#define IW_MLME_ASSOC		3
+
+/* SIOCSIWAUTH/SIOCGIWAUTH struct iw_param flags */
+#define IW_AUTH_INDEX		0x0FFF
+#define IW_AUTH_FLAGS		0xF000
+/* SIOCSIWAUTH/SIOCGIWAUTH parameters (0 .. 4095)
+ * (IW_AUTH_INDEX mask in struct iw_param flags; this is the index of the
+ * parameter that is being set/get to; value will be read/written to
+ * struct iw_param value field) */
+#define IW_AUTH_WPA_VERSION		0
+#define IW_AUTH_CIPHER_PAIRWISE		1
+#define IW_AUTH_CIPHER_GROUP		2
+#define IW_AUTH_KEY_MGMT		3
+#define IW_AUTH_TKIP_COUNTERMEASURES	4
+#define IW_AUTH_DROP_UNENCRYPTED	5
+#define IW_AUTH_80211_AUTH_ALG		6
+#define IW_AUTH_WPA_ENABLED		7
+#define IW_AUTH_RX_UNENCRYPTED_EAPOL	8
+#define IW_AUTH_ROAMING_CONTROL		9
+#define IW_AUTH_PRIVACY_INVOKED		10
+#define IW_AUTH_CIPHER_GROUP_MGMT	11
+#define IW_AUTH_MFP			12
+
+/* IW_AUTH_WPA_VERSION values (bit field) */
+#define IW_AUTH_WPA_VERSION_DISABLED	0x00000001
+#define IW_AUTH_WPA_VERSION_WPA		0x00000002
+#define IW_AUTH_WPA_VERSION_WPA2	0x00000004
+
+/* IW_AUTH_PAIRWISE_CIPHER, IW_AUTH_GROUP_CIPHER, and IW_AUTH_CIPHER_GROUP_MGMT
+ * values (bit field) */
+#define IW_AUTH_CIPHER_NONE	0x00000001
+#define IW_AUTH_CIPHER_WEP40	0x00000002
+#define IW_AUTH_CIPHER_TKIP	0x00000004
+#define IW_AUTH_CIPHER_CCMP	0x00000008
+#define IW_AUTH_CIPHER_WEP104	0x00000010
+#define IW_AUTH_CIPHER_AES_CMAC	0x00000020
+
+/* IW_AUTH_KEY_MGMT values (bit field) */
+#define IW_AUTH_KEY_MGMT_802_1X	1
+#define IW_AUTH_KEY_MGMT_PSK	2
+
+/* IW_AUTH_80211_AUTH_ALG values (bit field) */
+#define IW_AUTH_ALG_OPEN_SYSTEM	0x00000001
+#define IW_AUTH_ALG_SHARED_KEY	0x00000002
+#define IW_AUTH_ALG_LEAP	0x00000004
+
+/* IW_AUTH_ROAMING_CONTROL values */
+#define IW_AUTH_ROAMING_ENABLE	0	/* driver/firmware based roaming */
+#define IW_AUTH_ROAMING_DISABLE	1	/* user space program used for roaming
+					 * control */
+
+/* IW_AUTH_MFP (management frame protection) values */
+#define IW_AUTH_MFP_DISABLED	0	/* MFP disabled */
+#define IW_AUTH_MFP_OPTIONAL	1	/* MFP optional */
+#define IW_AUTH_MFP_REQUIRED	2	/* MFP required */
+
+/* SIOCSIWENCODEEXT definitions */
+#define IW_ENCODE_SEQ_MAX_SIZE	8
+/* struct iw_encode_ext ->alg */
+#define IW_ENCODE_ALG_NONE	0
+#define IW_ENCODE_ALG_WEP	1
+#define IW_ENCODE_ALG_TKIP	2
+#define IW_ENCODE_ALG_CCMP	3
+#define IW_ENCODE_ALG_PMK	4
+#define IW_ENCODE_ALG_AES_CMAC	5
+/* struct iw_encode_ext ->ext_flags */
+#define IW_ENCODE_EXT_TX_SEQ_VALID	0x00000001
+#define IW_ENCODE_EXT_RX_SEQ_VALID	0x00000002
+#define IW_ENCODE_EXT_GROUP_KEY		0x00000004
+#define IW_ENCODE_EXT_SET_TX_KEY	0x00000008
+
+/* IWEVMICHAELMICFAILURE : struct iw_michaelmicfailure ->flags */
+#define IW_MICFAILURE_KEY_ID	0x00000003 /* Key ID 0..3 */
+#define IW_MICFAILURE_GROUP	0x00000004
+#define IW_MICFAILURE_PAIRWISE	0x00000008
+#define IW_MICFAILURE_STAKEY	0x00000010
+#define IW_MICFAILURE_COUNT	0x00000060 /* 1 or 2 (0 = count not supported)
+					    */
+
+/* Bit field values for enc_capa in struct iw_range */
+#define IW_ENC_CAPA_WPA		0x00000001
+#define IW_ENC_CAPA_WPA2	0x00000002
+#define IW_ENC_CAPA_CIPHER_TKIP	0x00000004
+#define IW_ENC_CAPA_CIPHER_CCMP	0x00000008
+#define IW_ENC_CAPA_4WAY_HANDSHAKE	0x00000010
+
+/* Event capability macros - in (struct iw_range *)->event_capa
+ * Because we have more than 32 possible events, we use an array of
+ * 32 bit bitmasks. Note : 32 bits = 0x20 = 2^5. */
+#define IW_EVENT_CAPA_BASE(cmd)		((cmd >= SIOCIWFIRSTPRIV) ? \
+					 (cmd - SIOCIWFIRSTPRIV + 0x60) : \
+					 (cmd - SIOCIWFIRST))
+#define IW_EVENT_CAPA_INDEX(cmd)	(IW_EVENT_CAPA_BASE(cmd) >> 5)
+#define IW_EVENT_CAPA_MASK(cmd)		(1 << (IW_EVENT_CAPA_BASE(cmd) & 0x1F))
+/* Event capability constants - event autogenerated by the kernel
+ * This list is valid for most 802.11 devices, customise as needed... */
+#define IW_EVENT_CAPA_K_0	(IW_EVENT_CAPA_MASK(0x8B04) | \
+				 IW_EVENT_CAPA_MASK(0x8B06) | \
+				 IW_EVENT_CAPA_MASK(0x8B1A))
+#define IW_EVENT_CAPA_K_1	(IW_EVENT_CAPA_MASK(0x8B2A))
+/* "Easy" macro to set events in iw_range (less efficient) */
+#define IW_EVENT_CAPA_SET(event_capa, cmd) (event_capa[IW_EVENT_CAPA_INDEX(cmd)] |= IW_EVENT_CAPA_MASK(cmd))
+#define IW_EVENT_CAPA_SET_KERNEL(event_capa) {event_capa[0] |= IW_EVENT_CAPA_K_0; event_capa[1] |= IW_EVENT_CAPA_K_1; }
+
+
+/****************************** TYPES ******************************/
+
+/* --------------------------- SUBTYPES --------------------------- */
+/*
+ *	Generic format for most parameters that fit in an int
+ */
+struct	iw_param {
+  __s32		value;		/* The value of the parameter itself */
+  __u8		fixed;		/* Hardware should not use auto select */
+  __u8		disabled;	/* Disable the feature */
+  __u16		flags;		/* Various specifc flags (if any) */
+};
+
+/*
+ *	For all data larger than 16 octets, we need to use a
+ *	pointer to memory allocated in user space.
+ */
+struct	iw_point {
+  void __user	*pointer;	/* Pointer to the data  (in user space) */
+  __u16		length;		/* number of fields or size in bytes */
+  __u16		flags;		/* Optional params */
+};
+
+
+/*
+ *	A frequency
+ *	For numbers lower than 10^9, we encode the number in 'm' and
+ *	set 'e' to 0
+ *	For number greater than 10^9, we divide it by the lowest power
+ *	of 10 to get 'm' lower than 10^9, with 'm'= f / (10^'e')...
+ *	The power of 10 is in 'e', the result of the division is in 'm'.
+ */
+struct	iw_freq {
+	__s32		m;		/* Mantissa */
+	__s16		e;		/* Exponent */
+	__u8		i;		/* List index (when in range struct) */
+	__u8		flags;		/* Flags (fixed/auto) */
+};
+
+/*
+ *	Quality of the link
+ */
+struct	iw_quality {
+	__u8		qual;		/* link quality (%retries, SNR,
+					   %missed beacons or better...) */
+	__u8		level;		/* signal level (dBm) */
+	__u8		noise;		/* noise level (dBm) */
+	__u8		updated;	/* Flags to know if updated */
+};
+
+/*
+ *	Packet discarded in the wireless adapter due to
+ *	"wireless" specific problems...
+ *	Note : the list of counter and statistics in net_device_stats
+ *	is already pretty exhaustive, and you should use that first.
+ *	This is only additional stats...
+ */
+struct	iw_discarded {
+	__u32		nwid;		/* Rx : Wrong nwid/essid */
+	__u32		code;		/* Rx : Unable to code/decode (WEP) */
+	__u32		fragment;	/* Rx : Can't perform MAC reassembly */
+	__u32		retries;	/* Tx : Max MAC retries num reached */
+	__u32		misc;		/* Others cases */
+};
+
+/*
+ *	Packet/Time period missed in the wireless adapter due to
+ *	"wireless" specific problems...
+ */
+struct	iw_missed {
+	__u32		beacon;		/* Missed beacons/superframe */
+};
+
+/*
+ *	Quality range (for spy threshold)
+ */
+struct	iw_thrspy {
+	struct sockaddr		addr;		/* Source address (hw/mac) */
+	struct iw_quality	qual;		/* Quality of the link */
+	struct iw_quality	low;		/* Low threshold */
+	struct iw_quality	high;		/* High threshold */
+};
+
+/*
+ *	Optional data for scan request
+ *
+ *	Note: these optional parameters are controlling parameters for the
+ *	scanning behavior, these do not apply to getting scan results
+ *	(SIOCGIWSCAN). Drivers are expected to keep a local BSS table and
+ *	provide a merged results with all BSSes even if the previous scan
+ *	request limited scanning to a subset, e.g., by specifying an SSID.
+ *	Especially, scan results are required to include an entry for the
+ *	current BSS if the driver is in Managed mode and associated with an AP.
+ */
+struct	iw_scan_req {
+	__u8		scan_type; /* IW_SCAN_TYPE_{ACTIVE, PASSIVE} */
+	__u8		essid_len;
+	__u8		num_channels; /* num entries in channel_list;
+				       * 0 = scan all allowed channels */
+	__u8		flags; /* reserved as padding; use zero, this may
+				* be used in the future for adding flags
+				* to request different scan behavior */
+	struct sockaddr	bssid; /* ff:ff:ff:ff:ff:ff for broadcast BSSID or
+				* individual address of a specific BSS */
+
+	/*
+	 * Use this ESSID if IW_SCAN_THIS_ESSID flag is used instead of using
+	 * the current ESSID. This allows scan requests for specific ESSID
+	 * without having to change the current ESSID and potentially breaking
+	 * the current association.
+	 */
+	__u8		essid[IW_ESSID_MAX_SIZE];
+
+	/*
+	 * Optional parameters for changing the default scanning behavior.
+	 * These are based on the MLME-SCAN.request from IEEE Std 802.11.
+	 * TU is 1.024 ms. If these are set to 0, driver is expected to use
+	 * reasonable default values. min_channel_time defines the time that
+	 * will be used to wait for the first reply on each channel. If no
+	 * replies are received, next channel will be scanned after this. If
+	 * replies are received, total time waited on the channel is defined by
+	 * max_channel_time.
+	 */
+	__u32		min_channel_time; /* in TU */
+	__u32		max_channel_time; /* in TU */
+
+	struct iw_freq	channel_list[IW_MAX_FREQUENCIES];
+};
+
+/* ------------------------- WPA SUPPORT ------------------------- */
+
+/*
+ *	Extended data structure for get/set encoding (this is used with
+ *	SIOCSIWENCODEEXT/SIOCGIWENCODEEXT. struct iw_point and IW_ENCODE_*
+ *	flags are used in the same way as with SIOCSIWENCODE/SIOCGIWENCODE and
+ *	only the data contents changes (key data -> this structure, including
+ *	key data).
+ *
+ *	If the new key is the first group key, it will be set as the default
+ *	TX key. Otherwise, default TX key index is only changed if
+ *	IW_ENCODE_EXT_SET_TX_KEY flag is set.
+ *
+ *	Key will be changed with SIOCSIWENCODEEXT in all cases except for
+ *	special "change TX key index" operation which is indicated by setting
+ *	key_len = 0 and ext_flags |= IW_ENCODE_EXT_SET_TX_KEY.
+ *
+ *	tx_seq/rx_seq are only used when respective
+ *	IW_ENCODE_EXT_{TX, RX}_SEQ_VALID flag is set in ext_flags. Normal
+ *	TKIP/CCMP operation is to set RX seq with SIOCSIWENCODEEXT and start
+ *	TX seq from zero whenever key is changed. SIOCGIWENCODEEXT is normally
+ *	used only by an Authenticator (AP or an IBSS station) to get the
+ *	current TX sequence number. Using TX_SEQ_VALID for SIOCSIWENCODEEXT and
+ *	RX_SEQ_VALID for SIOCGIWENCODEEXT are optional, but can be useful for
+ *	debugging/testing.
+ */
+struct	iw_encode_ext {
+	__u32		ext_flags; /* IW_ENCODE_EXT_* */
+	__u8		tx_seq[IW_ENCODE_SEQ_MAX_SIZE]; /* LSB first */
+	__u8		rx_seq[IW_ENCODE_SEQ_MAX_SIZE]; /* LSB first */
+	struct sockaddr	addr; /* ff:ff:ff:ff:ff:ff for broadcast/multicast
+			       * (group) keys or unicast address for
+			       * individual keys */
+	__u16		alg; /* IW_ENCODE_ALG_* */
+	__u16		key_len;
+	__u8		key[0];
+};
+
+/* SIOCSIWMLME data */
+struct	iw_mlme {
+	__u16		cmd; /* IW_MLME_* */
+	__u16		reason_code;
+	struct sockaddr	addr;
+};
+
+/* SIOCSIWPMKSA data */
+#define IW_PMKSA_ADD		1
+#define IW_PMKSA_REMOVE		2
+#define IW_PMKSA_FLUSH		3
+
+#define IW_PMKID_LEN	16
+
+struct	iw_pmksa {
+	__u32		cmd; /* IW_PMKSA_* */
+	struct sockaddr	bssid;
+	__u8		pmkid[IW_PMKID_LEN];
+};
+
+/* IWEVMICHAELMICFAILURE data */
+struct	iw_michaelmicfailure {
+	__u32		flags;
+	struct sockaddr	src_addr;
+	__u8		tsc[IW_ENCODE_SEQ_MAX_SIZE]; /* LSB first */
+};
+
+/* IWEVPMKIDCAND data */
+#define IW_PMKID_CAND_PREAUTH	0x00000001 /* RNS pre-authentication enabled */
+struct	iw_pmkid_cand {
+	__u32		flags; /* IW_PMKID_CAND_* */
+	__u32		index; /* the smaller the index, the higher the
+				* priority */
+	struct sockaddr	bssid;
+};
+
+/* ------------------------ WIRELESS STATS ------------------------ */
+/*
+ * Wireless statistics (used for /proc/net/wireless)
+ */
+struct	iw_statistics {
+	__u16		status;		/* Status
+					 * - device dependent for now */
+
+	struct iw_quality	qual;		/* Quality of the link
+						 * (instant/mean/max) */
+	struct iw_discarded	discard;	/* Packet discarded counts */
+	struct iw_missed	miss;		/* Packet missed counts */
+};
+
+/* ------------------------ IOCTL REQUEST ------------------------ */
+/*
+ * This structure defines the payload of an ioctl, and is used
+ * below.
+ *
+ * Note that this structure should fit on the memory footprint
+ * of iwreq (which is the same as ifreq), which mean a max size of
+ * 16 octets = 128 bits. Warning, pointers might be 64 bits wide...
+ * You should check this when increasing the structures defined
+ * above in this file...
+ */
+union	iwreq_data {
+	/* Config - generic */
+	char		name[IFNAMSIZ];
+	/* Name : used to verify the presence of  wireless extensions.
+	 * Name of the protocol/provider... */
+
+	struct iw_point	essid;		/* Extended network name */
+	struct iw_param	nwid;		/* network id (or domain - the cell) */
+	struct iw_freq	freq;		/* frequency or channel :
+					 * 0-1000 = channel
+					 * > 1000 = frequency in Hz */
+
+	struct iw_param	sens;		/* signal level threshold */
+	struct iw_param	bitrate;	/* default bit rate */
+	struct iw_param	txpower;	/* default transmit power */
+	struct iw_param	rts;		/* RTS threshold threshold */
+	struct iw_param	frag;		/* Fragmentation threshold */
+	__u32		mode;		/* Operation mode */
+	struct iw_param	retry;		/* Retry limits & lifetime */
+
+	struct iw_point	encoding;	/* Encoding stuff : tokens */
+	struct iw_param	power;		/* PM duration/timeout */
+	struct iw_quality qual;		/* Quality part of statistics */
+
+	struct sockaddr	ap_addr;	/* Access point address */
+	struct sockaddr	addr;		/* Destination address (hw/mac) */
+
+	struct iw_param	param;		/* Other small parameters */
+	struct iw_point	data;		/* Other large parameters */
+};
+
+/*
+ * The structure to exchange data for ioctl.
+ * This structure is the same as 'struct ifreq', but (re)defined for
+ * convenience...
+ * Do I need to remind you about structure size (32 octets) ?
+ */
+struct	iwreq {
+	union {
+		char	ifrn_name[IFNAMSIZ];	/* if name, e.g. "eth0" */
+	} ifr_ifrn;
+
+	/* Data part (defined just above) */
+	union	iwreq_data	u;
+};
+
+/* -------------------------- IOCTL DATA -------------------------- */
+/*
+ *	For those ioctl which want to exchange mode data that what could
+ *	fit in the above structure...
+ */
+
+/*
+ *	Range of parameters
+ */
+
+struct	iw_range {
+	/* Informative stuff (to choose between different interface) */
+	__u32		throughput;	/* To give an idea... */
+	/* In theory this value should be the maximum benchmarked
+	 * TCP/IP throughput, because with most of these devices the
+	 * bit rate is meaningless (overhead an co) to estimate how
+	 * fast the connection will go and pick the fastest one.
+	 * I suggest people to play with Netperf or any benchmark...
+	 */
+
+	/* NWID (or domain id) */
+	__u32		min_nwid;	/* Minimal NWID we are able to set */
+	__u32		max_nwid;	/* Maximal NWID we are able to set */
+
+	/* Old Frequency (backward compat - moved lower ) */
+	__u16		old_num_channels;
+	__u8		old_num_frequency;
+
+	/* Scan capabilities */
+	__u8		scan_capa; 	/* IW_SCAN_CAPA_* bit field */
+
+	/* Wireless event capability bitmasks */
+	__u32		event_capa[6];
+
+	/* signal level threshold range */
+	__s32		sensitivity;
+
+	/* Quality of link & SNR stuff */
+	/* Quality range (link, level, noise)
+	 * If the quality is absolute, it will be in the range [0 ; max_qual],
+	 * if the quality is dBm, it will be in the range [max_qual ; 0].
+	 * Don't forget that we use 8 bit arithmetics... */
+	struct iw_quality	max_qual;	/* Quality of the link */
+	/* This should contain the average/typical values of the quality
+	 * indicator. This should be the threshold between a "good" and
+	 * a "bad" link (example : monitor going from green to orange).
+	 * Currently, user space apps like quality monitors don't have any
+	 * way to calibrate the measurement. With this, they can split
+	 * the range between 0 and max_qual in different quality level
+	 * (using a geometric subdivision centered on the average).
+	 * I expect that people doing the user space apps will feedback
+	 * us on which value we need to put in each driver... */
+	struct iw_quality	avg_qual;	/* Quality of the link */
+
+	/* Rates */
+	__u8		num_bitrates;	/* Number of entries in the list */
+	__s32		bitrate[IW_MAX_BITRATES];	/* list, in bps */
+
+	/* RTS threshold */
+	__s32		min_rts;	/* Minimal RTS threshold */
+	__s32		max_rts;	/* Maximal RTS threshold */
+
+	/* Frag threshold */
+	__s32		min_frag;	/* Minimal frag threshold */
+	__s32		max_frag;	/* Maximal frag threshold */
+
+	/* Power Management duration & timeout */
+	__s32		min_pmp;	/* Minimal PM period */
+	__s32		max_pmp;	/* Maximal PM period */
+	__s32		min_pmt;	/* Minimal PM timeout */
+	__s32		max_pmt;	/* Maximal PM timeout */
+	__u16		pmp_flags;	/* How to decode max/min PM period */
+	__u16		pmt_flags;	/* How to decode max/min PM timeout */
+	__u16		pm_capa;	/* What PM options are supported */
+
+	/* Encoder stuff */
+	__u16	encoding_size[IW_MAX_ENCODING_SIZES];	/* Different token sizes */
+	__u8	num_encoding_sizes;	/* Number of entry in the list */
+	__u8	max_encoding_tokens;	/* Max number of tokens */
+	/* For drivers that need a "login/passwd" form */
+	__u8	encoding_login_index;	/* token index for login token */
+
+	/* Transmit power */
+	__u16		txpower_capa;	/* What options are supported */
+	__u8		num_txpower;	/* Number of entries in the list */
+	__s32		txpower[IW_MAX_TXPOWER];	/* list, in bps */
+
+	/* Wireless Extension version info */
+	__u8		we_version_compiled;	/* Must be WIRELESS_EXT */
+	__u8		we_version_source;	/* Last update of source */
+
+	/* Retry limits and lifetime */
+	__u16		retry_capa;	/* What retry options are supported */
+	__u16		retry_flags;	/* How to decode max/min retry limit */
+	__u16		r_time_flags;	/* How to decode max/min retry life */
+	__s32		min_retry;	/* Minimal number of retries */
+	__s32		max_retry;	/* Maximal number of retries */
+	__s32		min_r_time;	/* Minimal retry lifetime */
+	__s32		max_r_time;	/* Maximal retry lifetime */
+
+	/* Frequency */
+	__u16		num_channels;	/* Number of channels [0; num - 1] */
+	__u8		num_frequency;	/* Number of entry in the list */
+	struct iw_freq	freq[IW_MAX_FREQUENCIES];	/* list */
+	/* Note : this frequency list doesn't need to fit channel numbers,
+	 * because each entry contain its channel index */
+
+	__u32		enc_capa;	/* IW_ENC_CAPA_* bit field */
+};
+
+/*
+ * Private ioctl interface information
+ */
+struct iw_priv_args {
+	__u32		cmd;		/* Number of the ioctl to issue */
+	__u16		set_args;	/* Type and number of args */
+	__u16		get_args;	/* Type and number of args */
+	char		name[IFNAMSIZ];	/* Name of the extension */
+};
+
+/* ----------------------- WIRELESS EVENTS ----------------------- */
+/*
+ * Wireless events are carried through the rtnetlink socket to user
+ * space. They are encapsulated in the IFLA_WIRELESS field of
+ * a RTM_NEWLINK message.
+ */
+
+/*
+ * A Wireless Event. Contains basically the same data as the ioctl...
+ */
+struct iw_event {
+	__u16		len;			/* Real length of this stuff */
+	__u16		cmd;			/* Wireless IOCTL */
+	union iwreq_data	u;		/* IOCTL fixed payload */
+};
+
+/* Size of the Event prefix (including padding and alignement junk) */
+#define IW_EV_LCP_LEN	(sizeof(struct iw_event) - sizeof(union iwreq_data))
+/* Size of the various events */
+#define IW_EV_CHAR_LEN	(IW_EV_LCP_LEN + IFNAMSIZ)
+#define IW_EV_UINT_LEN	(IW_EV_LCP_LEN + sizeof(__u32))
+#define IW_EV_FREQ_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_freq))
+#define IW_EV_PARAM_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_param))
+#define IW_EV_ADDR_LEN	(IW_EV_LCP_LEN + sizeof(struct sockaddr))
+#define IW_EV_QUAL_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_quality))
+
+/* iw_point events are special. First, the payload (extra data) come at
+ * the end of the event, so they are bigger than IW_EV_POINT_LEN. Second,
+ * we omit the pointer, so start at an offset. */
+#define IW_EV_POINT_OFF (((char *) &(((struct iw_point *) NULL)->length)) - \
+			  (char *) NULL)
+#define IW_EV_POINT_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_point) - \
+			 IW_EV_POINT_OFF)
+
+
+/* Size of the Event prefix when packed in stream */
+#define IW_EV_LCP_PK_LEN	(4)
+/* Size of the various events when packed in stream */
+#define IW_EV_CHAR_PK_LEN	(IW_EV_LCP_PK_LEN + IFNAMSIZ)
+#define IW_EV_UINT_PK_LEN	(IW_EV_LCP_PK_LEN + sizeof(__u32))
+#define IW_EV_FREQ_PK_LEN	(IW_EV_LCP_PK_LEN + sizeof(struct iw_freq))
+#define IW_EV_PARAM_PK_LEN	(IW_EV_LCP_PK_LEN + sizeof(struct iw_param))
+#define IW_EV_ADDR_PK_LEN	(IW_EV_LCP_PK_LEN + sizeof(struct sockaddr))
+#define IW_EV_QUAL_PK_LEN	(IW_EV_LCP_PK_LEN + sizeof(struct iw_quality))
+#define IW_EV_POINT_PK_LEN	(IW_EV_LCP_PK_LEN + 4)
+
+#endif /* _UAPI_LINUX_WIRELESS_H */
diff -Naurp a/drivers/net/wireless/xr829/include/net/cfg80211-wext.h b/drivers/net/wireless/xr829/include/net/cfg80211-wext.h
--- a/drivers/net/wireless/xr829/include/net/cfg80211-wext.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/net/cfg80211-wext.h	2022-08-27 01:22:42.914539710 +0300
@@ -0,0 +1,55 @@
+#ifndef __NET_CFG80211_WEXT_H
+#define __NET_CFG80211_WEXT_H
+/*
+ * 802.11 device and configuration interface -- wext handlers
+ *
+ * Copyright 2006-2010	Johannes Berg <johannes@sipsolutions.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/netdevice.h>
+#include <linux/wireless.h>
+#include <net/iw_handler.h>
+
+/*
+ * Temporary wext handlers & helper functions
+ *
+ * These are used only by drivers that aren't yet fully
+ * converted to cfg80211.
+ */
+int cfg80211_wext_giwname(struct net_device *dev,
+			  struct iw_request_info *info,
+			  char *name, char *extra);
+int cfg80211_wext_siwmode(struct net_device *dev, struct iw_request_info *info,
+			  u32 *mode, char *extra);
+int cfg80211_wext_giwmode(struct net_device *dev, struct iw_request_info *info,
+			  u32 *mode, char *extra);
+int cfg80211_wext_siwscan(struct net_device *dev,
+			  struct iw_request_info *info,
+			  union iwreq_data *wrqu, char *extra);
+int cfg80211_wext_giwscan(struct net_device *dev,
+			  struct iw_request_info *info,
+			  struct iw_point *data, char *extra);
+int cfg80211_wext_giwrange(struct net_device *dev,
+			   struct iw_request_info *info,
+			   struct iw_point *data, char *extra);
+int cfg80211_wext_siwrts(struct net_device *dev,
+			 struct iw_request_info *info,
+			 struct iw_param *rts, char *extra);
+int cfg80211_wext_giwrts(struct net_device *dev,
+			 struct iw_request_info *info,
+			 struct iw_param *rts, char *extra);
+int cfg80211_wext_siwfrag(struct net_device *dev,
+			  struct iw_request_info *info,
+			  struct iw_param *frag, char *extra);
+int cfg80211_wext_giwfrag(struct net_device *dev,
+			  struct iw_request_info *info,
+			  struct iw_param *frag, char *extra);
+int cfg80211_wext_giwretry(struct net_device *dev,
+			   struct iw_request_info *info,
+			   struct iw_param *retry, char *extra);
+
+#endif /* __NET_CFG80211_WEXT_H */
diff -Naurp a/drivers/net/wireless/xr829/include/net/cfg80211.h b/drivers/net/wireless/xr829/include/net/cfg80211.h
--- a/drivers/net/wireless/xr829/include/net/cfg80211.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/net/cfg80211.h	2022-08-27 01:22:42.922539741 +0300
@@ -0,0 +1,7746 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+#ifndef __NET_CFG80211_H
+#define __NET_CFG80211_H
+/*
+ * 802.11 device and configuration interface
+ *
+ * Copyright 2006-2010	Johannes Berg <johannes@sipsolutions.net>
+ * Copyright 2013-2014 Intel Mobile Communications GmbH
+ * Copyright 2015-2017	Intel Deutschland GmbH
+ * Copyright (C) 2018-2019 Intel Corporation
+ */
+
+#include <linux/netdevice.h>
+#include <linux/debugfs.h>
+#include <linux/list.h>
+#include <linux/bug.h>
+#include <linux/netlink.h>
+#include <linux/skbuff.h>
+#include <linux/nl80211.h>
+#include <linux/if_ether.h>
+#include <linux/ieee80211.h>
+#include <linux/net.h>
+#include <uapi/linux/ethtool.h>
+#include <net/regulatory.h>
+
+/**
+ * DOC: Introduction
+ *
+ * cfg80211 is the configuration API for 802.11 devices in Linux. It bridges
+ * userspace and drivers, and offers some utility functionality associated
+ * with 802.11. cfg80211 must, directly or indirectly via mac80211, be used
+ * by all modern wireless drivers in Linux, so that they offer a consistent
+ * API through nl80211. For backward compatibility, cfg80211 also offers
+ * wireless extensions to userspace, but hides them from drivers completely.
+ *
+ * Additionally, cfg80211 contains code to help enforce regulatory spectrum
+ * use restrictions.
+ */
+
+
+/**
+ * DOC: Device registration
+ *
+ * In order for a driver to use cfg80211, it must register the hardware device
+ * with cfg80211. This happens through a number of hardware capability structs
+ * described below.
+ *
+ * The fundamental structure for each device is the 'wiphy', of which each
+ * instance describes a physical wireless device connected to the system. Each
+ * such wiphy can have zero, one, or many virtual interfaces associated with
+ * it, which need to be identified as such by pointing the network interface's
+ * @ieee80211_ptr pointer to a &struct wireless_dev which further describes
+ * the wireless part of the interface, normally this struct is embedded in the
+ * network interface's private data area. Drivers can optionally allow creating
+ * or destroying virtual interfaces on the fly, but without at least one or the
+ * ability to create some the wireless device isn't useful.
+ *
+ * Each wiphy structure contains device capability information, and also has
+ * a pointer to the various operations the driver offers. The definitions and
+ * structures here describe these capabilities in detail.
+ */
+
+struct wiphy;
+
+/*
+ * wireless hardware capability structures
+ */
+
+/**
+ * enum ieee80211_channel_flags - channel flags
+ *
+ * Channel flags set by the regulatory control code.
+ *
+ * @IEEE80211_CHAN_DISABLED: This channel is disabled.
+ * @IEEE80211_CHAN_NO_IR: do not initiate radiation, this includes
+ * 	sending probe requests or beaconing.
+ * @IEEE80211_CHAN_RADAR: Radar detection is required on this channel.
+ * @IEEE80211_CHAN_NO_HT40PLUS: extension channel above this channel
+ * 	is not permitted.
+ * @IEEE80211_CHAN_NO_HT40MINUS: extension channel below this channel
+ * 	is not permitted.
+ * @IEEE80211_CHAN_NO_OFDM: OFDM is not allowed on this channel.
+ * @IEEE80211_CHAN_NO_80MHZ: If the driver supports 80 MHz on the band,
+ *	this flag indicates that an 80 MHz channel cannot use this
+ *	channel as the control or any of the secondary channels.
+ *	This may be due to the driver or due to regulatory bandwidth
+ *	restrictions.
+ * @IEEE80211_CHAN_NO_160MHZ: If the driver supports 160 MHz on the band,
+ *	this flag indicates that an 160 MHz channel cannot use this
+ *	channel as the control or any of the secondary channels.
+ *	This may be due to the driver or due to regulatory bandwidth
+ *	restrictions.
+ * @IEEE80211_CHAN_INDOOR_ONLY: see %NL80211_FREQUENCY_ATTR_INDOOR_ONLY
+ * @IEEE80211_CHAN_IR_CONCURRENT: see %NL80211_FREQUENCY_ATTR_IR_CONCURRENT
+ * @IEEE80211_CHAN_NO_20MHZ: 20 MHz bandwidth is not permitted
+ *	on this channel.
+ * @IEEE80211_CHAN_NO_10MHZ: 10 MHz bandwidth is not permitted
+ *	on this channel.
+ *
+ */
+enum ieee80211_channel_flags {
+	IEEE80211_CHAN_DISABLED		= 1<<0,
+	IEEE80211_CHAN_NO_IR		= 1<<1,
+	/* hole at 1<<2 */
+	IEEE80211_CHAN_RADAR		= 1<<3,
+	IEEE80211_CHAN_NO_HT40PLUS	= 1<<4,
+	IEEE80211_CHAN_NO_HT40MINUS	= 1<<5,
+	IEEE80211_CHAN_NO_OFDM		= 1<<6,
+	IEEE80211_CHAN_NO_80MHZ		= 1<<7,
+	IEEE80211_CHAN_NO_160MHZ	= 1<<8,
+	IEEE80211_CHAN_INDOOR_ONLY	= 1<<9,
+	IEEE80211_CHAN_IR_CONCURRENT	= 1<<10,
+	IEEE80211_CHAN_NO_20MHZ		= 1<<11,
+	IEEE80211_CHAN_NO_10MHZ		= 1<<12,
+};
+
+#define IEEE80211_CHAN_NO_HT40 \
+	(IEEE80211_CHAN_NO_HT40PLUS | IEEE80211_CHAN_NO_HT40MINUS)
+
+#define IEEE80211_DFS_MIN_CAC_TIME_MS		60000
+#define IEEE80211_DFS_MIN_NOP_TIME_MS		(30 * 60 * 1000)
+
+/**
+ * struct ieee80211_channel - channel definition
+ *
+ * This structure describes a single channel for use
+ * with cfg80211.
+ *
+ * @center_freq: center frequency in MHz
+ * @freq_offset: offset from @center_freq, in KHz
+ * @hw_value: hardware-specific value for the channel
+ * @flags: channel flags from &enum ieee80211_channel_flags.
+ * @orig_flags: channel flags at registration time, used by regulatory
+ *	code to support devices with additional restrictions
+ * @band: band this channel belongs to.
+ * @max_antenna_gain: maximum antenna gain in dBi
+ * @max_power: maximum transmission power (in dBm)
+ * @max_reg_power: maximum regulatory transmission power (in dBm)
+ * @beacon_found: helper to regulatory code to indicate when a beacon
+ *	has been found on this channel. Use regulatory_hint_found_beacon()
+ *	to enable this, this is useful only on 5 GHz band.
+ * @orig_mag: internal use
+ * @orig_mpwr: internal use
+ * @dfs_state: current state of this channel. Only relevant if radar is required
+ *	on this channel.
+ * @dfs_state_entered: timestamp (jiffies) when the dfs state was entered.
+ * @dfs_cac_ms: DFS CAC time in milliseconds, this is valid for DFS channels.
+ */
+struct ieee80211_channel {
+	enum nl80211_band band;
+	u32 center_freq;
+	u16 freq_offset;
+	u16 hw_value;
+	u32 flags;
+	int max_antenna_gain;
+	int max_power;
+	int max_reg_power;
+	bool beacon_found;
+	u32 orig_flags;
+	int orig_mag, orig_mpwr;
+	enum nl80211_dfs_state dfs_state;
+	unsigned long dfs_state_entered;
+	unsigned int dfs_cac_ms;
+};
+
+/**
+ * enum ieee80211_rate_flags - rate flags
+ *
+ * Hardware/specification flags for rates. These are structured
+ * in a way that allows using the same bitrate structure for
+ * different bands/PHY modes.
+ *
+ * @IEEE80211_RATE_SHORT_PREAMBLE: Hardware can send with short
+ *	preamble on this bitrate; only relevant in 2.4GHz band and
+ *	with CCK rates.
+ * @IEEE80211_RATE_MANDATORY_A: This bitrate is a mandatory rate
+ *	when used with 802.11a (on the 5 GHz band); filled by the
+ *	core code when registering the wiphy.
+ * @IEEE80211_RATE_MANDATORY_B: This bitrate is a mandatory rate
+ *	when used with 802.11b (on the 2.4 GHz band); filled by the
+ *	core code when registering the wiphy.
+ * @IEEE80211_RATE_MANDATORY_G: This bitrate is a mandatory rate
+ *	when used with 802.11g (on the 2.4 GHz band); filled by the
+ *	core code when registering the wiphy.
+ * @IEEE80211_RATE_ERP_G: This is an ERP rate in 802.11g mode.
+ * @IEEE80211_RATE_SUPPORTS_5MHZ: Rate can be used in 5 MHz mode
+ * @IEEE80211_RATE_SUPPORTS_10MHZ: Rate can be used in 10 MHz mode
+ */
+enum ieee80211_rate_flags {
+	IEEE80211_RATE_SHORT_PREAMBLE	= 1<<0,
+	IEEE80211_RATE_MANDATORY_A	= 1<<1,
+	IEEE80211_RATE_MANDATORY_B	= 1<<2,
+	IEEE80211_RATE_MANDATORY_G	= 1<<3,
+	IEEE80211_RATE_ERP_G		= 1<<4,
+	IEEE80211_RATE_SUPPORTS_5MHZ	= 1<<5,
+	IEEE80211_RATE_SUPPORTS_10MHZ	= 1<<6,
+};
+
+/**
+ * enum ieee80211_bss_type - BSS type filter
+ *
+ * @IEEE80211_BSS_TYPE_ESS: Infrastructure BSS
+ * @IEEE80211_BSS_TYPE_PBSS: Personal BSS
+ * @IEEE80211_BSS_TYPE_IBSS: Independent BSS
+ * @IEEE80211_BSS_TYPE_MBSS: Mesh BSS
+ * @IEEE80211_BSS_TYPE_ANY: Wildcard value for matching any BSS type
+ */
+enum ieee80211_bss_type {
+	IEEE80211_BSS_TYPE_ESS,
+	IEEE80211_BSS_TYPE_PBSS,
+	IEEE80211_BSS_TYPE_IBSS,
+	IEEE80211_BSS_TYPE_MBSS,
+	IEEE80211_BSS_TYPE_ANY
+};
+
+/**
+ * enum ieee80211_privacy - BSS privacy filter
+ *
+ * @IEEE80211_PRIVACY_ON: privacy bit set
+ * @IEEE80211_PRIVACY_OFF: privacy bit clear
+ * @IEEE80211_PRIVACY_ANY: Wildcard value for matching any privacy setting
+ */
+enum ieee80211_privacy {
+	IEEE80211_PRIVACY_ON,
+	IEEE80211_PRIVACY_OFF,
+	IEEE80211_PRIVACY_ANY
+};
+
+#define IEEE80211_PRIVACY(x)	\
+	((x) ? IEEE80211_PRIVACY_ON : IEEE80211_PRIVACY_OFF)
+
+/**
+ * struct ieee80211_rate - bitrate definition
+ *
+ * This structure describes a bitrate that an 802.11 PHY can
+ * operate with. The two values @hw_value and @hw_value_short
+ * are only for driver use when pointers to this structure are
+ * passed around.
+ *
+ * @flags: rate-specific flags
+ * @bitrate: bitrate in units of 100 Kbps
+ * @hw_value: driver/hardware value for this rate
+ * @hw_value_short: driver/hardware value for this rate when
+ *	short preamble is used
+ */
+struct ieee80211_rate {
+	u32 flags;
+	u16 bitrate;
+	u16 hw_value, hw_value_short;
+};
+
+/**
+ * struct ieee80211_he_obss_pd - AP settings for spatial reuse
+ *
+ * @enable: is the feature enabled.
+ * @min_offset: minimal tx power offset an associated station shall use
+ * @max_offset: maximum tx power offset an associated station shall use
+ */
+struct ieee80211_he_obss_pd {
+	bool enable;
+	u8 min_offset;
+	u8 max_offset;
+};
+
+/**
+ * struct cfg80211_he_bss_color - AP settings for BSS coloring
+ *
+ * @color: the current color.
+ * @disabled: is the feature disabled.
+ * @partial: define the AID equation.
+ */
+struct cfg80211_he_bss_color {
+	u8 color;
+	bool disabled;
+	bool partial;
+};
+
+/**
+ * struct ieee80211_sta_ht_cap - STA's HT capabilities
+ *
+ * This structure describes most essential parameters needed
+ * to describe 802.11n HT capabilities for an STA.
+ *
+ * @ht_supported: is HT supported by the STA
+ * @cap: HT capabilities map as described in 802.11n spec
+ * @ampdu_factor: Maximum A-MPDU length factor
+ * @ampdu_density: Minimum A-MPDU spacing
+ * @mcs: Supported MCS rates
+ */
+struct ieee80211_sta_ht_cap {
+	u16 cap; /* use IEEE80211_HT_CAP_ */
+	bool ht_supported;
+	u8 ampdu_factor;
+	u8 ampdu_density;
+	struct ieee80211_mcs_info mcs;
+};
+
+/**
+ * struct ieee80211_sta_vht_cap - STA's VHT capabilities
+ *
+ * This structure describes most essential parameters needed
+ * to describe 802.11ac VHT capabilities for an STA.
+ *
+ * @vht_supported: is VHT supported by the STA
+ * @cap: VHT capabilities map as described in 802.11ac spec
+ * @vht_mcs: Supported VHT MCS rates
+ */
+struct ieee80211_sta_vht_cap {
+	bool vht_supported;
+	u32 cap; /* use IEEE80211_VHT_CAP_ */
+	struct ieee80211_vht_mcs_info vht_mcs;
+};
+
+#define IEEE80211_HE_PPE_THRES_MAX_LEN		25
+
+/**
+ * struct ieee80211_sta_he_cap - STA's HE capabilities
+ *
+ * This structure describes most essential parameters needed
+ * to describe 802.11ax HE capabilities for a STA.
+ *
+ * @has_he: true iff HE data is valid.
+ * @he_cap_elem: Fixed portion of the HE capabilities element.
+ * @he_mcs_nss_supp: The supported NSS/MCS combinations.
+ * @ppe_thres: Holds the PPE Thresholds data.
+ */
+struct ieee80211_sta_he_cap {
+	bool has_he;
+	struct ieee80211_he_cap_elem he_cap_elem;
+	struct ieee80211_he_mcs_nss_supp he_mcs_nss_supp;
+	u8 ppe_thres[IEEE80211_HE_PPE_THRES_MAX_LEN];
+};
+
+/**
+ * struct ieee80211_sband_iftype_data
+ *
+ * This structure encapsulates sband data that is relevant for the
+ * interface types defined in @types_mask.  Each type in the
+ * @types_mask must be unique across all instances of iftype_data.
+ *
+ * @types_mask: interface types mask
+ * @he_cap: holds the HE capabilities
+ * @he_6ghz_capa: HE 6 GHz capabilities, must be filled in for a
+ *	6 GHz band channel (and 0 may be valid value).
+ */
+struct ieee80211_sband_iftype_data {
+	u16 types_mask;
+	struct ieee80211_sta_he_cap he_cap;
+	struct ieee80211_he_6ghz_capa he_6ghz_capa;
+};
+
+/**
+ * enum ieee80211_edmg_bw_config - allowed channel bandwidth configurations
+ *
+ * @IEEE80211_EDMG_BW_CONFIG_4: 2.16GHz
+ * @IEEE80211_EDMG_BW_CONFIG_5: 2.16GHz and 4.32GHz
+ * @IEEE80211_EDMG_BW_CONFIG_6: 2.16GHz, 4.32GHz and 6.48GHz
+ * @IEEE80211_EDMG_BW_CONFIG_7: 2.16GHz, 4.32GHz, 6.48GHz and 8.64GHz
+ * @IEEE80211_EDMG_BW_CONFIG_8: 2.16GHz and 2.16GHz + 2.16GHz
+ * @IEEE80211_EDMG_BW_CONFIG_9: 2.16GHz, 4.32GHz and 2.16GHz + 2.16GHz
+ * @IEEE80211_EDMG_BW_CONFIG_10: 2.16GHz, 4.32GHz, 6.48GHz and 2.16GHz+2.16GHz
+ * @IEEE80211_EDMG_BW_CONFIG_11: 2.16GHz, 4.32GHz, 6.48GHz, 8.64GHz and
+ *	2.16GHz+2.16GHz
+ * @IEEE80211_EDMG_BW_CONFIG_12: 2.16GHz, 2.16GHz + 2.16GHz and
+ *	4.32GHz + 4.32GHz
+ * @IEEE80211_EDMG_BW_CONFIG_13: 2.16GHz, 4.32GHz, 2.16GHz + 2.16GHz and
+ *	4.32GHz + 4.32GHz
+ * @IEEE80211_EDMG_BW_CONFIG_14: 2.16GHz, 4.32GHz, 6.48GHz, 2.16GHz + 2.16GHz
+ *	and 4.32GHz + 4.32GHz
+ * @IEEE80211_EDMG_BW_CONFIG_15: 2.16GHz, 4.32GHz, 6.48GHz, 8.64GHz,
+ *	2.16GHz + 2.16GHz and 4.32GHz + 4.32GHz
+ */
+enum ieee80211_edmg_bw_config {
+	IEEE80211_EDMG_BW_CONFIG_4	= 4,
+	IEEE80211_EDMG_BW_CONFIG_5	= 5,
+	IEEE80211_EDMG_BW_CONFIG_6	= 6,
+	IEEE80211_EDMG_BW_CONFIG_7	= 7,
+	IEEE80211_EDMG_BW_CONFIG_8	= 8,
+	IEEE80211_EDMG_BW_CONFIG_9	= 9,
+	IEEE80211_EDMG_BW_CONFIG_10	= 10,
+	IEEE80211_EDMG_BW_CONFIG_11	= 11,
+	IEEE80211_EDMG_BW_CONFIG_12	= 12,
+	IEEE80211_EDMG_BW_CONFIG_13	= 13,
+	IEEE80211_EDMG_BW_CONFIG_14	= 14,
+	IEEE80211_EDMG_BW_CONFIG_15	= 15,
+};
+
+/**
+ * struct ieee80211_edmg - EDMG configuration
+ *
+ * This structure describes most essential parameters needed
+ * to describe 802.11ay EDMG configuration
+ *
+ * @channels: bitmap that indicates the 2.16 GHz channel(s)
+ *	that are allowed to be used for transmissions.
+ *	Bit 0 indicates channel 1, bit 1 indicates channel 2, etc.
+ *	Set to 0 indicate EDMG not supported.
+ * @bw_config: Channel BW Configuration subfield encodes
+ *	the allowed channel bandwidth configurations
+ */
+struct ieee80211_edmg {
+	u8 channels;
+	enum ieee80211_edmg_bw_config bw_config;
+};
+
+/**
+ * struct ieee80211_supported_band - frequency band definition
+ *
+ * This structure describes a frequency band a wiphy
+ * is able to operate in.
+ *
+ * @channels: Array of channels the hardware can operate in
+ *	in this band.
+ * @band: the band this structure represents
+ * @n_channels: Number of channels in @channels
+ * @bitrates: Array of bitrates the hardware can operate with
+ *	in this band. Must be sorted to give a valid "supported
+ *	rates" IE, i.e. CCK rates first, then OFDM.
+ * @n_bitrates: Number of bitrates in @bitrates
+ * @ht_cap: HT capabilities in this band
+ * @vht_cap: VHT capabilities in this band
+ * @edmg_cap: EDMG capabilities in this band
+ * @n_iftype_data: number of iftype data entries
+ * @iftype_data: interface type data entries.  Note that the bits in
+ *	@types_mask inside this structure cannot overlap (i.e. only
+ *	one occurrence of each type is allowed across all instances of
+ *	iftype_data).
+ */
+struct ieee80211_supported_band {
+	struct ieee80211_channel *channels;
+	struct ieee80211_rate *bitrates;
+	enum nl80211_band band;
+	int n_channels;
+	int n_bitrates;
+	struct ieee80211_sta_ht_cap ht_cap;
+	struct ieee80211_sta_vht_cap vht_cap;
+	struct ieee80211_edmg edmg_cap;
+	u16 n_iftype_data;
+	const struct ieee80211_sband_iftype_data *iftype_data;
+};
+
+/**
+ * ieee80211_get_sband_iftype_data - return sband data for a given iftype
+ * @sband: the sband to search for the STA on
+ * @iftype: enum nl80211_iftype
+ *
+ * Return: pointer to struct ieee80211_sband_iftype_data, or NULL is none found
+ */
+static inline const struct ieee80211_sband_iftype_data *
+ieee80211_get_sband_iftype_data(const struct ieee80211_supported_band *sband,
+				u8 iftype)
+{
+	int i;
+
+	if (WARN_ON(iftype >= NL80211_IFTYPE_MAX))
+		return NULL;
+
+	for (i = 0; i < sband->n_iftype_data; i++)  {
+		const struct ieee80211_sband_iftype_data *data =
+			&sband->iftype_data[i];
+
+		if (data->types_mask & BIT(iftype))
+			return data;
+	}
+
+	return NULL;
+}
+
+/**
+ * ieee80211_get_he_iftype_cap - return HE capabilities for an sband's iftype
+ * @sband: the sband to search for the iftype on
+ * @iftype: enum nl80211_iftype
+ *
+ * Return: pointer to the struct ieee80211_sta_he_cap, or NULL is none found
+ */
+static inline const struct ieee80211_sta_he_cap *
+ieee80211_get_he_iftype_cap(const struct ieee80211_supported_band *sband,
+			    u8 iftype)
+{
+	const struct ieee80211_sband_iftype_data *data =
+		ieee80211_get_sband_iftype_data(sband, iftype);
+
+	if (data && data->he_cap.has_he)
+		return &data->he_cap;
+
+	return NULL;
+}
+
+/**
+ * ieee80211_get_he_sta_cap - return HE capabilities for an sband's STA
+ * @sband: the sband to search for the STA on
+ *
+ * Return: pointer to the struct ieee80211_sta_he_cap, or NULL is none found
+ */
+static inline const struct ieee80211_sta_he_cap *
+ieee80211_get_he_sta_cap(const struct ieee80211_supported_band *sband)
+{
+	return ieee80211_get_he_iftype_cap(sband, NL80211_IFTYPE_STATION);
+}
+
+/**
+ * ieee80211_get_he_6ghz_capa - return HE 6 GHz capabilities
+ * @sband: the sband to search for the STA on
+ * @iftype: the iftype to search for
+ *
+ * Return: the 6GHz capabilities
+ */
+static inline __le16
+ieee80211_get_he_6ghz_capa(const struct ieee80211_supported_band *sband,
+			   enum nl80211_iftype iftype)
+{
+	const struct ieee80211_sband_iftype_data *data =
+		ieee80211_get_sband_iftype_data(sband, iftype);
+
+	if (WARN_ON(!data || !data->he_cap.has_he))
+		return 0;
+
+	return data->he_6ghz_capa.capa;
+}
+
+/**
+ * wiphy_read_of_freq_limits - read frequency limits from device tree
+ *
+ * @wiphy: the wireless device to get extra limits for
+ *
+ * Some devices may have extra limitations specified in DT. This may be useful
+ * for chipsets that normally support more bands but are limited due to board
+ * design (e.g. by antennas or external power amplifier).
+ *
+ * This function reads info from DT and uses it to *modify* channels (disable
+ * unavailable ones). It's usually a *bad* idea to use it in drivers with
+ * shared channel data as DT limitations are device specific. You should make
+ * sure to call it only if channels in wiphy are copied and can be modified
+ * without affecting other devices.
+ *
+ * As this function access device node it has to be called after set_wiphy_dev.
+ * It also modifies channels so they have to be set first.
+ * If using this helper, call it before wiphy_register().
+ */
+#ifdef CONFIG_OF
+void wiphy_read_of_freq_limits(struct wiphy *wiphy);
+#else /* CONFIG_OF */
+static inline void wiphy_read_of_freq_limits(struct wiphy *wiphy)
+{
+}
+#endif /* !CONFIG_OF */
+
+
+/*
+ * Wireless hardware/device configuration structures and methods
+ */
+
+/**
+ * DOC: Actions and configuration
+ *
+ * Each wireless device and each virtual interface offer a set of configuration
+ * operations and other actions that are invoked by userspace. Each of these
+ * actions is described in the operations structure, and the parameters these
+ * operations use are described separately.
+ *
+ * Additionally, some operations are asynchronous and expect to get status
+ * information via some functions that drivers need to call.
+ *
+ * Scanning and BSS list handling with its associated functionality is described
+ * in a separate chapter.
+ */
+
+#define VHT_MUMIMO_GROUPS_DATA_LEN (WLAN_MEMBERSHIP_LEN +\
+				    WLAN_USER_POSITION_LEN)
+
+/**
+ * struct vif_params - describes virtual interface parameters
+ * @flags: monitor interface flags, unchanged if 0, otherwise
+ *	%MONITOR_FLAG_CHANGED will be set
+ * @use_4addr: use 4-address frames
+ * @macaddr: address to use for this virtual interface.
+ *	If this parameter is set to zero address the driver may
+ *	determine the address as needed.
+ *	This feature is only fully supported by drivers that enable the
+ *	%NL80211_FEATURE_MAC_ON_CREATE flag.  Others may support creating
+ **	only p2p devices with specified MAC.
+ * @vht_mumimo_groups: MU-MIMO groupID, used for monitoring MU-MIMO packets
+ *	belonging to that MU-MIMO groupID; %NULL if not changed
+ * @vht_mumimo_follow_addr: MU-MIMO follow address, used for monitoring
+ *	MU-MIMO packets going to the specified station; %NULL if not changed
+ */
+struct vif_params {
+	u32 flags;
+	int use_4addr;
+	u8 macaddr[ETH_ALEN];
+	const u8 *vht_mumimo_groups;
+	const u8 *vht_mumimo_follow_addr;
+};
+
+/**
+ * struct key_params - key information
+ *
+ * Information about a key
+ *
+ * @key: key material
+ * @key_len: length of key material
+ * @cipher: cipher suite selector
+ * @seq: sequence counter (IV/PN) for TKIP and CCMP keys, only used
+ *	with the get_key() callback, must be in little endian,
+ *	length given by @seq_len.
+ * @seq_len: length of @seq.
+ * @vlan_id: vlan_id for VLAN group key (if nonzero)
+ * @mode: key install mode (RX_TX, NO_TX or SET_TX)
+ */
+struct key_params {
+	const u8 *key;
+	const u8 *seq;
+	int key_len;
+	int seq_len;
+	u16 vlan_id;
+	u32 cipher;
+	enum nl80211_key_mode mode;
+};
+
+/**
+ * struct cfg80211_chan_def - channel definition
+ * @chan: the (control) channel
+ * @width: channel width
+ * @center_freq1: center frequency of first segment
+ * @center_freq2: center frequency of second segment
+ *	(only with 80+80 MHz)
+ * @edmg: define the EDMG channels configuration.
+ *	If edmg is requested (i.e. the .channels member is non-zero),
+ *	chan will define the primary channel and all other
+ *	parameters are ignored.
+ * @freq1_offset: offset from @center_freq1, in KHz
+ */
+struct cfg80211_chan_def {
+	struct ieee80211_channel *chan;
+	enum nl80211_chan_width width;
+	u32 center_freq1;
+	u32 center_freq2;
+	struct ieee80211_edmg edmg;
+	u16 freq1_offset;
+};
+
+/**
+ * struct cfg80211_tid_cfg - TID specific configuration
+ * @config_override: Flag to notify driver to reset TID configuration
+ *	of the peer.
+ * @tids: bitmap of TIDs to modify
+ * @mask: bitmap of attributes indicating which parameter changed,
+ *	similar to &nl80211_tid_config_supp.
+ * @noack: noack configuration value for the TID
+ */
+struct cfg80211_tid_cfg {
+	bool config_override;
+	u8 tids;
+	u32 mask;
+	enum nl80211_tid_config noack;
+};
+
+/**
+ * struct cfg80211_tid_config - TID configuration
+ * @peer: Station's MAC address
+ * @n_tid_conf: Number of TID specific configurations to be applied
+ * @tid_conf: Configuration change info
+ */
+struct cfg80211_tid_config {
+	const u8 *peer;
+	u32 n_tid_conf;
+	struct cfg80211_tid_cfg tid_conf[];
+};
+
+/**
+ * cfg80211_get_chandef_type - return old channel type from chandef
+ * @chandef: the channel definition
+ *
+ * Return: The old channel type (NOHT, HT20, HT40+/-) from a given
+ * chandef, which must have a bandwidth allowing this conversion.
+ */
+static inline enum nl80211_channel_type
+cfg80211_get_chandef_type(const struct cfg80211_chan_def *chandef)
+{
+	switch (chandef->width) {
+	case NL80211_CHAN_WIDTH_20_NOHT:
+		return NL80211_CHAN_NO_HT;
+	case NL80211_CHAN_WIDTH_20:
+		return NL80211_CHAN_HT20;
+	case NL80211_CHAN_WIDTH_40:
+		if (chandef->center_freq1 > chandef->chan->center_freq)
+			return NL80211_CHAN_HT40PLUS;
+		return NL80211_CHAN_HT40MINUS;
+	default:
+		WARN_ON(1);
+		return NL80211_CHAN_NO_HT;
+	}
+}
+
+/**
+ * cfg80211_chandef_create - create channel definition using channel type
+ * @chandef: the channel definition struct to fill
+ * @channel: the control channel
+ * @chantype: the channel type
+ *
+ * Given a channel type, create a channel definition.
+ */
+void cfg80211_chandef_create(struct cfg80211_chan_def *chandef,
+			     struct ieee80211_channel *channel,
+			     enum nl80211_channel_type chantype);
+
+/**
+ * cfg80211_chandef_identical - check if two channel definitions are identical
+ * @chandef1: first channel definition
+ * @chandef2: second channel definition
+ *
+ * Return: %true if the channels defined by the channel definitions are
+ * identical, %false otherwise.
+ */
+static inline bool
+cfg80211_chandef_identical(const struct cfg80211_chan_def *chandef1,
+			   const struct cfg80211_chan_def *chandef2)
+{
+	return (chandef1->chan == chandef2->chan &&
+		chandef1->width == chandef2->width &&
+		chandef1->center_freq1 == chandef2->center_freq1 &&
+		chandef1->freq1_offset == chandef2->freq1_offset &&
+		chandef1->center_freq2 == chandef2->center_freq2);
+}
+
+/**
+ * cfg80211_chandef_is_edmg - check if chandef represents an EDMG channel
+ *
+ * @chandef: the channel definition
+ *
+ * Return: %true if EDMG defined, %false otherwise.
+ */
+static inline bool
+cfg80211_chandef_is_edmg(const struct cfg80211_chan_def *chandef)
+{
+	return chandef->edmg.channels || chandef->edmg.bw_config;
+}
+
+/**
+ * cfg80211_chandef_compatible - check if two channel definitions are compatible
+ * @chandef1: first channel definition
+ * @chandef2: second channel definition
+ *
+ * Return: %NULL if the given channel definitions are incompatible,
+ * chandef1 or chandef2 otherwise.
+ */
+const struct cfg80211_chan_def *
+cfg80211_chandef_compatible(const struct cfg80211_chan_def *chandef1,
+			    const struct cfg80211_chan_def *chandef2);
+
+/**
+ * cfg80211_chandef_valid - check if a channel definition is valid
+ * @chandef: the channel definition to check
+ * Return: %true if the channel definition is valid. %false otherwise.
+ */
+bool cfg80211_chandef_valid(const struct cfg80211_chan_def *chandef);
+
+/**
+ * cfg80211_chandef_usable - check if secondary channels can be used
+ * @wiphy: the wiphy to validate against
+ * @chandef: the channel definition to check
+ * @prohibited_flags: the regulatory channel flags that must not be set
+ * Return: %true if secondary channels are usable. %false otherwise.
+ */
+bool cfg80211_chandef_usable(struct wiphy *wiphy,
+			     const struct cfg80211_chan_def *chandef,
+			     u32 prohibited_flags);
+
+/**
+ * cfg80211_chandef_dfs_required - checks if radar detection is required
+ * @wiphy: the wiphy to validate against
+ * @chandef: the channel definition to check
+ * @iftype: the interface type as specified in &enum nl80211_iftype
+ * Returns:
+ *	1 if radar detection is required, 0 if it is not, < 0 on error
+ */
+int cfg80211_chandef_dfs_required(struct wiphy *wiphy,
+				  const struct cfg80211_chan_def *chandef,
+				  enum nl80211_iftype iftype);
+
+/**
+ * ieee80211_chandef_rate_flags - returns rate flags for a channel
+ *
+ * In some channel types, not all rates may be used - for example CCK
+ * rates may not be used in 5/10 MHz channels.
+ *
+ * @chandef: channel definition for the channel
+ *
+ * Returns: rate flags which apply for this channel
+ */
+static inline enum ieee80211_rate_flags
+ieee80211_chandef_rate_flags(struct cfg80211_chan_def *chandef)
+{
+	switch (chandef->width) {
+	case NL80211_CHAN_WIDTH_5:
+		return IEEE80211_RATE_SUPPORTS_5MHZ;
+	case NL80211_CHAN_WIDTH_10:
+		return IEEE80211_RATE_SUPPORTS_10MHZ;
+	default:
+		break;
+	}
+	return 0;
+}
+
+/**
+ * ieee80211_chandef_max_power - maximum transmission power for the chandef
+ *
+ * In some regulations, the transmit power may depend on the configured channel
+ * bandwidth which may be defined as dBm/MHz. This function returns the actual
+ * max_power for non-standard (20 MHz) channels.
+ *
+ * @chandef: channel definition for the channel
+ *
+ * Returns: maximum allowed transmission power in dBm for the chandef
+ */
+static inline int
+ieee80211_chandef_max_power(struct cfg80211_chan_def *chandef)
+{
+	switch (chandef->width) {
+	case NL80211_CHAN_WIDTH_5:
+		return min(chandef->chan->max_reg_power - 6,
+			   chandef->chan->max_power);
+	case NL80211_CHAN_WIDTH_10:
+		return min(chandef->chan->max_reg_power - 3,
+			   chandef->chan->max_power);
+	default:
+		break;
+	}
+	return chandef->chan->max_power;
+}
+
+/**
+ * enum survey_info_flags - survey information flags
+ *
+ * @SURVEY_INFO_NOISE_DBM: noise (in dBm) was filled in
+ * @SURVEY_INFO_IN_USE: channel is currently being used
+ * @SURVEY_INFO_TIME: active time (in ms) was filled in
+ * @SURVEY_INFO_TIME_BUSY: busy time was filled in
+ * @SURVEY_INFO_TIME_EXT_BUSY: extension channel busy time was filled in
+ * @SURVEY_INFO_TIME_RX: receive time was filled in
+ * @SURVEY_INFO_TIME_TX: transmit time was filled in
+ * @SURVEY_INFO_TIME_SCAN: scan time was filled in
+ * @SURVEY_INFO_TIME_BSS_RX: local BSS receive time was filled in
+ *
+ * Used by the driver to indicate which info in &struct survey_info
+ * it has filled in during the get_survey().
+ */
+enum survey_info_flags {
+	SURVEY_INFO_NOISE_DBM		= BIT(0),
+	SURVEY_INFO_IN_USE		= BIT(1),
+	SURVEY_INFO_TIME		= BIT(2),
+	SURVEY_INFO_TIME_BUSY		= BIT(3),
+	SURVEY_INFO_TIME_EXT_BUSY	= BIT(4),
+	SURVEY_INFO_TIME_RX		= BIT(5),
+	SURVEY_INFO_TIME_TX		= BIT(6),
+	SURVEY_INFO_TIME_SCAN		= BIT(7),
+	SURVEY_INFO_TIME_BSS_RX		= BIT(8),
+};
+
+/**
+ * struct survey_info - channel survey response
+ *
+ * @channel: the channel this survey record reports, may be %NULL for a single
+ *	record to report global statistics
+ * @filled: bitflag of flags from &enum survey_info_flags
+ * @noise: channel noise in dBm. This and all following fields are
+ *	optional
+ * @time: amount of time in ms the radio was turn on (on the channel)
+ * @time_busy: amount of time the primary channel was sensed busy
+ * @time_ext_busy: amount of time the extension channel was sensed busy
+ * @time_rx: amount of time the radio spent receiving data
+ * @time_tx: amount of time the radio spent transmitting data
+ * @time_scan: amount of time the radio spent for scanning
+ * @time_bss_rx: amount of time the radio spent receiving data on a local BSS
+ *
+ * Used by dump_survey() to report back per-channel survey information.
+ *
+ * This structure can later be expanded with things like
+ * channel duty cycle etc.
+ */
+struct survey_info {
+	struct ieee80211_channel *channel;
+	u64 time;
+	u64 time_busy;
+	u64 time_ext_busy;
+	u64 time_rx;
+	u64 time_tx;
+	u64 time_scan;
+	u64 time_bss_rx;
+	u32 filled;
+	s8 noise;
+};
+
+#define CFG80211_MAX_WEP_KEYS	4
+
+/**
+ * struct cfg80211_crypto_settings - Crypto settings
+ * @wpa_versions: indicates which, if any, WPA versions are enabled
+ *	(from enum nl80211_wpa_versions)
+ * @cipher_group: group key cipher suite (or 0 if unset)
+ * @n_ciphers_pairwise: number of AP supported unicast ciphers
+ * @ciphers_pairwise: unicast key cipher suites
+ * @n_akm_suites: number of AKM suites
+ * @akm_suites: AKM suites
+ * @control_port: Whether user space controls IEEE 802.1X port, i.e.,
+ *	sets/clears %NL80211_STA_FLAG_AUTHORIZED. If true, the driver is
+ *	required to assume that the port is unauthorized until authorized by
+ *	user space. Otherwise, port is marked authorized by default.
+ * @control_port_ethertype: the control port protocol that should be
+ *	allowed through even on unauthorized ports
+ * @control_port_no_encrypt: TRUE to prevent encryption of control port
+ *	protocol frames.
+ * @control_port_over_nl80211: TRUE if userspace expects to exchange control
+ *	port frames over NL80211 instead of the network interface.
+ * @wep_keys: static WEP keys, if not NULL points to an array of
+ *	CFG80211_MAX_WEP_KEYS WEP keys
+ * @wep_tx_key: key index (0..3) of the default TX static WEP key
+ * @psk: PSK (for devices supporting 4-way-handshake offload)
+ * @sae_pwd: password for SAE authentication (for devices supporting SAE
+ *	offload)
+ * @sae_pwd_len: length of SAE password (for devices supporting SAE offload)
+ */
+struct cfg80211_crypto_settings {
+	u32 wpa_versions;
+	u32 cipher_group;
+	int n_ciphers_pairwise;
+	u32 ciphers_pairwise[NL80211_MAX_NR_CIPHER_SUITES];
+	int n_akm_suites;
+	u32 akm_suites[NL80211_MAX_NR_AKM_SUITES];
+	bool control_port;
+	__be16 control_port_ethertype;
+	bool control_port_no_encrypt;
+	bool control_port_over_nl80211;
+	struct key_params *wep_keys;
+	int wep_tx_key;
+	const u8 *psk;
+	const u8 *sae_pwd;
+	u8 sae_pwd_len;
+};
+
+/**
+ * struct cfg80211_beacon_data - beacon data
+ * @head: head portion of beacon (before TIM IE)
+ *	or %NULL if not changed
+ * @tail: tail portion of beacon (after TIM IE)
+ *	or %NULL if not changed
+ * @head_len: length of @head
+ * @tail_len: length of @tail
+ * @beacon_ies: extra information element(s) to add into Beacon frames or %NULL
+ * @beacon_ies_len: length of beacon_ies in octets
+ * @proberesp_ies: extra information element(s) to add into Probe Response
+ *	frames or %NULL
+ * @proberesp_ies_len: length of proberesp_ies in octets
+ * @assocresp_ies: extra information element(s) to add into (Re)Association
+ *	Response frames or %NULL
+ * @assocresp_ies_len: length of assocresp_ies in octets
+ * @probe_resp_len: length of probe response template (@probe_resp)
+ * @probe_resp: probe response template (AP mode only)
+ * @ftm_responder: enable FTM responder functionality; -1 for no change
+ *	(which also implies no change in LCI/civic location data)
+ * @lci: Measurement Report element content, starting with Measurement Token
+ *	(measurement type 8)
+ * @civicloc: Measurement Report element content, starting with Measurement
+ *	Token (measurement type 11)
+ * @lci_len: LCI data length
+ * @civicloc_len: Civic location data length
+ */
+struct cfg80211_beacon_data {
+	const u8 *head, *tail;
+	const u8 *beacon_ies;
+	const u8 *proberesp_ies;
+	const u8 *assocresp_ies;
+	const u8 *probe_resp;
+	const u8 *lci;
+	const u8 *civicloc;
+	s8 ftm_responder;
+
+	size_t head_len, tail_len;
+	size_t beacon_ies_len;
+	size_t proberesp_ies_len;
+	size_t assocresp_ies_len;
+	size_t probe_resp_len;
+	size_t lci_len;
+	size_t civicloc_len;
+};
+
+struct mac_address {
+	u8 addr[ETH_ALEN];
+};
+
+/**
+ * struct cfg80211_acl_data - Access control list data
+ *
+ * @acl_policy: ACL policy to be applied on the station's
+ *	entry specified by mac_addr
+ * @n_acl_entries: Number of MAC address entries passed
+ * @mac_addrs: List of MAC addresses of stations to be used for ACL
+ */
+struct cfg80211_acl_data {
+	enum nl80211_acl_policy acl_policy;
+	int n_acl_entries;
+
+	/* Keep it last */
+	struct mac_address mac_addrs[];
+};
+
+/*
+ * cfg80211_bitrate_mask - masks for bitrate control
+ */
+struct cfg80211_bitrate_mask {
+	struct {
+		u32 legacy;
+		u8 ht_mcs[IEEE80211_HT_MCS_MASK_LEN];
+		u16 vht_mcs[NL80211_VHT_NSS_MAX];
+		enum nl80211_txrate_gi gi;
+	} control[NUM_NL80211_BANDS];
+};
+
+/**
+ * enum cfg80211_ap_settings_flags - AP settings flags
+ *
+ * Used by cfg80211_ap_settings
+ *
+ * @AP_SETTINGS_EXTERNAL_AUTH_SUPPORT: AP supports external authentication
+ */
+enum cfg80211_ap_settings_flags {
+	AP_SETTINGS_EXTERNAL_AUTH_SUPPORT = BIT(0),
+};
+
+/**
+ * struct cfg80211_ap_settings - AP configuration
+ *
+ * Used to configure an AP interface.
+ *
+ * @chandef: defines the channel to use
+ * @beacon: beacon data
+ * @beacon_interval: beacon interval
+ * @dtim_period: DTIM period
+ * @ssid: SSID to be used in the BSS (note: may be %NULL if not provided from
+ *	user space)
+ * @ssid_len: length of @ssid
+ * @hidden_ssid: whether to hide the SSID in Beacon/Probe Response frames
+ * @crypto: crypto settings
+ * @privacy: the BSS uses privacy
+ * @auth_type: Authentication type (algorithm)
+ * @smps_mode: SMPS mode
+ * @inactivity_timeout: time in seconds to determine station's inactivity.
+ * @p2p_ctwindow: P2P CT Window
+ * @p2p_opp_ps: P2P opportunistic PS
+ * @acl: ACL configuration used by the drivers which has support for
+ *	MAC address based access control
+ * @pbss: If set, start as a PCP instead of AP. Relevant for DMG
+ *	networks.
+ * @beacon_rate: bitrate to be used for beacons
+ * @ht_cap: HT capabilities (or %NULL if HT isn't enabled)
+ * @vht_cap: VHT capabilities (or %NULL if VHT isn't enabled)
+ * @he_cap: HE capabilities (or %NULL if HE isn't enabled)
+ * @ht_required: stations must support HT
+ * @vht_required: stations must support VHT
+ * @twt_responder: Enable Target Wait Time
+ * @flags: flags, as defined in enum cfg80211_ap_settings_flags
+ * @he_obss_pd: OBSS Packet Detection settings
+ * @he_bss_color: BSS Color settings
+ */
+struct cfg80211_ap_settings {
+	struct cfg80211_chan_def chandef;
+
+	struct cfg80211_beacon_data beacon;
+
+	int beacon_interval, dtim_period;
+	const u8 *ssid;
+	size_t ssid_len;
+	enum nl80211_hidden_ssid hidden_ssid;
+	struct cfg80211_crypto_settings crypto;
+	bool privacy;
+	enum nl80211_auth_type auth_type;
+	enum nl80211_smps_mode smps_mode;
+	int inactivity_timeout;
+	u8 p2p_ctwindow;
+	bool p2p_opp_ps;
+	const struct cfg80211_acl_data *acl;
+	bool pbss;
+	struct cfg80211_bitrate_mask beacon_rate;
+
+	const struct ieee80211_ht_cap *ht_cap;
+	const struct ieee80211_vht_cap *vht_cap;
+	const struct ieee80211_he_cap_elem *he_cap;
+	bool ht_required, vht_required;
+	bool twt_responder;
+	u32 flags;
+	struct ieee80211_he_obss_pd he_obss_pd;
+	struct cfg80211_he_bss_color he_bss_color;
+};
+
+/**
+ * struct cfg80211_csa_settings - channel switch settings
+ *
+ * Used for channel switch
+ *
+ * @chandef: defines the channel to use after the switch
+ * @beacon_csa: beacon data while performing the switch
+ * @counter_offsets_beacon: offsets of the counters within the beacon (tail)
+ * @counter_offsets_presp: offsets of the counters within the probe response
+ * @n_counter_offsets_beacon: number of csa counters the beacon (tail)
+ * @n_counter_offsets_presp: number of csa counters in the probe response
+ * @beacon_after: beacon data to be used on the new channel
+ * @radar_required: whether radar detection is required on the new channel
+ * @block_tx: whether transmissions should be blocked while changing
+ * @count: number of beacons until switch
+ */
+struct cfg80211_csa_settings {
+	struct cfg80211_chan_def chandef;
+	struct cfg80211_beacon_data beacon_csa;
+	const u16 *counter_offsets_beacon;
+	const u16 *counter_offsets_presp;
+	unsigned int n_counter_offsets_beacon;
+	unsigned int n_counter_offsets_presp;
+	struct cfg80211_beacon_data beacon_after;
+	bool radar_required;
+	bool block_tx;
+	u8 count;
+};
+
+#define CFG80211_MAX_NUM_DIFFERENT_CHANNELS 10
+
+/**
+ * struct iface_combination_params - input parameters for interface combinations
+ *
+ * Used to pass interface combination parameters
+ *
+ * @num_different_channels: the number of different channels we want
+ *	to use for verification
+ * @radar_detect: a bitmap where each bit corresponds to a channel
+ *	width where radar detection is needed, as in the definition of
+ *	&struct ieee80211_iface_combination.@radar_detect_widths
+ * @iftype_num: array with the number of interfaces of each interface
+ *	type.  The index is the interface type as specified in &enum
+ *	nl80211_iftype.
+ * @new_beacon_int: set this to the beacon interval of a new interface
+ *	that's not operating yet, if such is to be checked as part of
+ *	the verification
+ */
+struct iface_combination_params {
+	int num_different_channels;
+	u8 radar_detect;
+	int iftype_num[NUM_NL80211_IFTYPES];
+	u32 new_beacon_int;
+};
+
+/**
+ * enum station_parameters_apply_mask - station parameter values to apply
+ * @STATION_PARAM_APPLY_UAPSD: apply new uAPSD parameters (uapsd_queues, max_sp)
+ * @STATION_PARAM_APPLY_CAPABILITY: apply new capability
+ * @STATION_PARAM_APPLY_PLINK_STATE: apply new plink state
+ *
+ * Not all station parameters have in-band "no change" signalling,
+ * for those that don't these flags will are used.
+ */
+enum station_parameters_apply_mask {
+	STATION_PARAM_APPLY_UAPSD = BIT(0),
+	STATION_PARAM_APPLY_CAPABILITY = BIT(1),
+	STATION_PARAM_APPLY_PLINK_STATE = BIT(2),
+	STATION_PARAM_APPLY_STA_TXPOWER = BIT(3),
+};
+
+/**
+ * struct sta_txpwr - station txpower configuration
+ *
+ * Used to configure txpower for station.
+ *
+ * @power: tx power (in dBm) to be used for sending data traffic. If tx power
+ *	is not provided, the default per-interface tx power setting will be
+ *	overriding. Driver should be picking up the lowest tx power, either tx
+ *	power per-interface or per-station.
+ * @type: In particular if TPC %type is NL80211_TX_POWER_LIMITED then tx power
+ *	will be less than or equal to specified from userspace, whereas if TPC
+ *	%type is NL80211_TX_POWER_AUTOMATIC then it indicates default tx power.
+ *	NL80211_TX_POWER_FIXED is not a valid configuration option for
+ *	per peer TPC.
+ */
+struct sta_txpwr {
+	s16 power;
+	enum nl80211_tx_power_setting type;
+};
+
+/**
+ * struct station_parameters - station parameters
+ *
+ * Used to change and create a new station.
+ *
+ * @vlan: vlan interface station should belong to
+ * @supported_rates: supported rates in IEEE 802.11 format
+ *	(or NULL for no change)
+ * @supported_rates_len: number of supported rates
+ * @sta_flags_mask: station flags that changed
+ *	(bitmask of BIT(%NL80211_STA_FLAG_...))
+ * @sta_flags_set: station flags values
+ *	(bitmask of BIT(%NL80211_STA_FLAG_...))
+ * @listen_interval: listen interval or -1 for no change
+ * @aid: AID or zero for no change
+ * @vlan_id: VLAN ID for station (if nonzero)
+ * @peer_aid: mesh peer AID or zero for no change
+ * @plink_action: plink action to take
+ * @plink_state: set the peer link state for a station
+ * @ht_capa: HT capabilities of station
+ * @vht_capa: VHT capabilities of station
+ * @uapsd_queues: bitmap of queues configured for uapsd. same format
+ *	as the AC bitmap in the QoS info field
+ * @max_sp: max Service Period. same format as the MAX_SP in the
+ *	QoS info field (but already shifted down)
+ * @sta_modify_mask: bitmap indicating which parameters changed
+ *	(for those that don't have a natural "no change" value),
+ *	see &enum station_parameters_apply_mask
+ * @local_pm: local link-specific mesh power save mode (no change when set
+ *	to unknown)
+ * @capability: station capability
+ * @ext_capab: extended capabilities of the station
+ * @ext_capab_len: number of extended capabilities
+ * @supported_channels: supported channels in IEEE 802.11 format
+ * @supported_channels_len: number of supported channels
+ * @supported_oper_classes: supported oper classes in IEEE 802.11 format
+ * @supported_oper_classes_len: number of supported operating classes
+ * @opmode_notif: operating mode field from Operating Mode Notification
+ * @opmode_notif_used: information if operating mode field is used
+ * @support_p2p_ps: information if station supports P2P PS mechanism
+ * @he_capa: HE capabilities of station
+ * @he_capa_len: the length of the HE capabilities
+ * @airtime_weight: airtime scheduler weight for this station
+ * @he_6ghz_capa: HE 6 GHz Band capabilities of station
+ */
+struct station_parameters {
+	const u8 *supported_rates;
+	struct net_device *vlan;
+	u32 sta_flags_mask, sta_flags_set;
+	u32 sta_modify_mask;
+	int listen_interval;
+	u16 aid;
+	u16 vlan_id;
+	u16 peer_aid;
+	u8 supported_rates_len;
+	u8 plink_action;
+	u8 plink_state;
+	const struct ieee80211_ht_cap *ht_capa;
+	const struct ieee80211_vht_cap *vht_capa;
+	u8 uapsd_queues;
+	u8 max_sp;
+	enum nl80211_mesh_power_mode local_pm;
+	u16 capability;
+	const u8 *ext_capab;
+	u8 ext_capab_len;
+	const u8 *supported_channels;
+	u8 supported_channels_len;
+	const u8 *supported_oper_classes;
+	u8 supported_oper_classes_len;
+	u8 opmode_notif;
+	bool opmode_notif_used;
+	int support_p2p_ps;
+	const struct ieee80211_he_cap_elem *he_capa;
+	u8 he_capa_len;
+	u16 airtime_weight;
+	struct sta_txpwr txpwr;
+	const struct ieee80211_he_6ghz_capa *he_6ghz_capa;
+};
+
+/**
+ * struct station_del_parameters - station deletion parameters
+ *
+ * Used to delete a station entry (or all stations).
+ *
+ * @mac: MAC address of the station to remove or NULL to remove all stations
+ * @subtype: Management frame subtype to use for indicating removal
+ *	(10 = Disassociation, 12 = Deauthentication)
+ * @reason_code: Reason code for the Disassociation/Deauthentication frame
+ */
+struct station_del_parameters {
+	const u8 *mac;
+	u8 subtype;
+	u16 reason_code;
+};
+
+/**
+ * enum cfg80211_station_type - the type of station being modified
+ * @CFG80211_STA_AP_CLIENT: client of an AP interface
+ * @CFG80211_STA_AP_CLIENT_UNASSOC: client of an AP interface that is still
+ *	unassociated (update properties for this type of client is permitted)
+ * @CFG80211_STA_AP_MLME_CLIENT: client of an AP interface that has
+ *	the AP MLME in the device
+ * @CFG80211_STA_AP_STA: AP station on managed interface
+ * @CFG80211_STA_IBSS: IBSS station
+ * @CFG80211_STA_TDLS_PEER_SETUP: TDLS peer on managed interface (dummy entry
+ *	while TDLS setup is in progress, it moves out of this state when
+ *	being marked authorized; use this only if TDLS with external setup is
+ *	supported/used)
+ * @CFG80211_STA_TDLS_PEER_ACTIVE: TDLS peer on managed interface (active
+ *	entry that is operating, has been marked authorized by userspace)
+ * @CFG80211_STA_MESH_PEER_KERNEL: peer on mesh interface (kernel managed)
+ * @CFG80211_STA_MESH_PEER_USER: peer on mesh interface (user managed)
+ */
+enum cfg80211_station_type {
+	CFG80211_STA_AP_CLIENT,
+	CFG80211_STA_AP_CLIENT_UNASSOC,
+	CFG80211_STA_AP_MLME_CLIENT,
+	CFG80211_STA_AP_STA,
+	CFG80211_STA_IBSS,
+	CFG80211_STA_TDLS_PEER_SETUP,
+	CFG80211_STA_TDLS_PEER_ACTIVE,
+	CFG80211_STA_MESH_PEER_KERNEL,
+	CFG80211_STA_MESH_PEER_USER,
+};
+
+/**
+ * cfg80211_check_station_change - validate parameter changes
+ * @wiphy: the wiphy this operates on
+ * @params: the new parameters for a station
+ * @statype: the type of station being modified
+ *
+ * Utility function for the @change_station driver method. Call this function
+ * with the appropriate station type looking up the station (and checking that
+ * it exists). It will verify whether the station change is acceptable, and if
+ * not will return an error code. Note that it may modify the parameters for
+ * backward compatibility reasons, so don't use them before calling this.
+ */
+int cfg80211_check_station_change(struct wiphy *wiphy,
+				  struct station_parameters *params,
+				  enum cfg80211_station_type statype);
+
+/**
+ * enum station_info_rate_flags - bitrate info flags
+ *
+ * Used by the driver to indicate the specific rate transmission
+ * type for 802.11n transmissions.
+ *
+ * @RATE_INFO_FLAGS_MCS: mcs field filled with HT MCS
+ * @RATE_INFO_FLAGS_VHT_MCS: mcs field filled with VHT MCS
+ * @RATE_INFO_FLAGS_SHORT_GI: 400ns guard interval
+ * @RATE_INFO_FLAGS_DMG: 60GHz MCS
+ * @RATE_INFO_FLAGS_HE_MCS: HE MCS information
+ * @RATE_INFO_FLAGS_EDMG: 60GHz MCS in EDMG mode
+ */
+enum rate_info_flags {
+	RATE_INFO_FLAGS_MCS			= BIT(0),
+	RATE_INFO_FLAGS_VHT_MCS			= BIT(1),
+	RATE_INFO_FLAGS_SHORT_GI		= BIT(2),
+	RATE_INFO_FLAGS_DMG			= BIT(3),
+	RATE_INFO_FLAGS_HE_MCS			= BIT(4),
+	RATE_INFO_FLAGS_EDMG			= BIT(5),
+};
+
+/**
+ * enum rate_info_bw - rate bandwidth information
+ *
+ * Used by the driver to indicate the rate bandwidth.
+ *
+ * @RATE_INFO_BW_5: 5 MHz bandwidth
+ * @RATE_INFO_BW_10: 10 MHz bandwidth
+ * @RATE_INFO_BW_20: 20 MHz bandwidth
+ * @RATE_INFO_BW_40: 40 MHz bandwidth
+ * @RATE_INFO_BW_80: 80 MHz bandwidth
+ * @RATE_INFO_BW_160: 160 MHz bandwidth
+ * @RATE_INFO_BW_HE_RU: bandwidth determined by HE RU allocation
+ */
+enum rate_info_bw {
+	RATE_INFO_BW_20 = 0,
+	RATE_INFO_BW_5,
+	RATE_INFO_BW_10,
+	RATE_INFO_BW_40,
+	RATE_INFO_BW_80,
+	RATE_INFO_BW_160,
+	RATE_INFO_BW_HE_RU,
+};
+
+/**
+ * struct rate_info - bitrate information
+ *
+ * Information about a receiving or transmitting bitrate
+ *
+ * @flags: bitflag of flags from &enum rate_info_flags
+ * @mcs: mcs index if struct describes an HT/VHT/HE rate
+ * @legacy: bitrate in 100kbit/s for 802.11abg
+ * @nss: number of streams (VHT & HE only)
+ * @bw: bandwidth (from &enum rate_info_bw)
+ * @he_gi: HE guard interval (from &enum nl80211_he_gi)
+ * @he_dcm: HE DCM value
+ * @he_ru_alloc: HE RU allocation (from &enum nl80211_he_ru_alloc,
+ *	only valid if bw is %RATE_INFO_BW_HE_RU)
+ * @n_bonded_ch: In case of EDMG the number of bonded channels (1-4)
+ */
+struct rate_info {
+	u8 flags;
+	u8 mcs;
+	u16 legacy;
+	u8 nss;
+	u8 bw;
+	u8 he_gi;
+	u8 he_dcm;
+	u8 he_ru_alloc;
+	u8 n_bonded_ch;
+};
+
+/**
+ * enum station_info_rate_flags - bitrate info flags
+ *
+ * Used by the driver to indicate the specific rate transmission
+ * type for 802.11n transmissions.
+ *
+ * @BSS_PARAM_FLAGS_CTS_PROT: whether CTS protection is enabled
+ * @BSS_PARAM_FLAGS_SHORT_PREAMBLE: whether short preamble is enabled
+ * @BSS_PARAM_FLAGS_SHORT_SLOT_TIME: whether short slot time is enabled
+ */
+enum bss_param_flags {
+	BSS_PARAM_FLAGS_CTS_PROT	= 1<<0,
+	BSS_PARAM_FLAGS_SHORT_PREAMBLE	= 1<<1,
+	BSS_PARAM_FLAGS_SHORT_SLOT_TIME	= 1<<2,
+};
+
+/**
+ * struct sta_bss_parameters - BSS parameters for the attached station
+ *
+ * Information about the currently associated BSS
+ *
+ * @flags: bitflag of flags from &enum bss_param_flags
+ * @dtim_period: DTIM period for the BSS
+ * @beacon_interval: beacon interval
+ */
+struct sta_bss_parameters {
+	u8 flags;
+	u8 dtim_period;
+	u16 beacon_interval;
+};
+
+/**
+ * struct cfg80211_txq_stats - TXQ statistics for this TID
+ * @filled: bitmap of flags using the bits of &enum nl80211_txq_stats to
+ *	indicate the relevant values in this struct are filled
+ * @backlog_bytes: total number of bytes currently backlogged
+ * @backlog_packets: total number of packets currently backlogged
+ * @flows: number of new flows seen
+ * @drops: total number of packets dropped
+ * @ecn_marks: total number of packets marked with ECN CE
+ * @overlimit: number of drops due to queue space overflow
+ * @overmemory: number of drops due to memory limit overflow
+ * @collisions: number of hash collisions
+ * @tx_bytes: total number of bytes dequeued
+ * @tx_packets: total number of packets dequeued
+ * @max_flows: maximum number of flows supported
+ */
+struct cfg80211_txq_stats {
+	u32 filled;
+	u32 backlog_bytes;
+	u32 backlog_packets;
+	u32 flows;
+	u32 drops;
+	u32 ecn_marks;
+	u32 overlimit;
+	u32 overmemory;
+	u32 collisions;
+	u32 tx_bytes;
+	u32 tx_packets;
+	u32 max_flows;
+};
+
+/**
+ * struct cfg80211_tid_stats - per-TID statistics
+ * @filled: bitmap of flags using the bits of &enum nl80211_tid_stats to
+ *	indicate the relevant values in this struct are filled
+ * @rx_msdu: number of received MSDUs
+ * @tx_msdu: number of (attempted) transmitted MSDUs
+ * @tx_msdu_retries: number of retries (not counting the first) for
+ *	transmitted MSDUs
+ * @tx_msdu_failed: number of failed transmitted MSDUs
+ * @txq_stats: TXQ statistics
+ */
+struct cfg80211_tid_stats {
+	u32 filled;
+	u64 rx_msdu;
+	u64 tx_msdu;
+	u64 tx_msdu_retries;
+	u64 tx_msdu_failed;
+	struct cfg80211_txq_stats txq_stats;
+};
+
+#define IEEE80211_MAX_CHAINS	4
+
+/**
+ * struct station_info - station information
+ *
+ * Station information filled by driver for get_station() and dump_station.
+ *
+ * @filled: bitflag of flags using the bits of &enum nl80211_sta_info to
+ *	indicate the relevant values in this struct for them
+ * @connected_time: time(in secs) since a station is last connected
+ * @inactive_time: time since last station activity (tx/rx) in milliseconds
+ * @assoc_at: bootime (ns) of the last association
+ * @rx_bytes: bytes (size of MPDUs) received from this station
+ * @tx_bytes: bytes (size of MPDUs) transmitted to this station
+ * @llid: mesh local link id
+ * @plid: mesh peer link id
+ * @plink_state: mesh peer link state
+ * @signal: The signal strength, type depends on the wiphy's signal_type.
+ *	For CFG80211_SIGNAL_TYPE_MBM, value is expressed in _dBm_.
+ * @signal_avg: Average signal strength, type depends on the wiphy's signal_type.
+ *	For CFG80211_SIGNAL_TYPE_MBM, value is expressed in _dBm_.
+ * @chains: bitmask for filled values in @chain_signal, @chain_signal_avg
+ * @chain_signal: per-chain signal strength of last received packet in dBm
+ * @chain_signal_avg: per-chain signal strength average in dBm
+ * @txrate: current unicast bitrate from this station
+ * @rxrate: current unicast bitrate to this station
+ * @rx_packets: packets (MSDUs & MMPDUs) received from this station
+ * @tx_packets: packets (MSDUs & MMPDUs) transmitted to this station
+ * @tx_retries: cumulative retry counts (MPDUs)
+ * @tx_failed: number of failed transmissions (MPDUs) (retries exceeded, no ACK)
+ * @rx_dropped_misc:  Dropped for un-specified reason.
+ * @bss_param: current BSS parameters
+ * @generation: generation number for nl80211 dumps.
+ *	This number should increase every time the list of stations
+ *	changes, i.e. when a station is added or removed, so that
+ *	userspace can tell whether it got a consistent snapshot.
+ * @assoc_req_ies: IEs from (Re)Association Request.
+ *	This is used only when in AP mode with drivers that do not use
+ *	user space MLME/SME implementation. The information is provided for
+ *	the cfg80211_new_sta() calls to notify user space of the IEs.
+ * @assoc_req_ies_len: Length of assoc_req_ies buffer in octets.
+ * @sta_flags: station flags mask & values
+ * @beacon_loss_count: Number of times beacon loss event has triggered.
+ * @t_offset: Time offset of the station relative to this host.
+ * @local_pm: local mesh STA power save mode
+ * @peer_pm: peer mesh STA power save mode
+ * @nonpeer_pm: non-peer mesh STA power save mode
+ * @expected_throughput: expected throughput in kbps (including 802.11 headers)
+ *	towards this station.
+ * @rx_beacon: number of beacons received from this peer
+ * @rx_beacon_signal_avg: signal strength average (in dBm) for beacons received
+ *	from this peer
+ * @connected_to_gate: true if mesh STA has a path to mesh gate
+ * @rx_duration: aggregate PPDU duration(usecs) for all the frames from a peer
+ * @tx_duration: aggregate PPDU duration(usecs) for all the frames to a peer
+ * @airtime_weight: current airtime scheduling weight
+ * @pertid: per-TID statistics, see &struct cfg80211_tid_stats, using the last
+ *	(IEEE80211_NUM_TIDS) index for MSDUs not encapsulated in QoS-MPDUs.
+ *	Note that this doesn't use the @filled bit, but is used if non-NULL.
+ * @ack_signal: signal strength (in dBm) of the last ACK frame.
+ * @avg_ack_signal: average rssi value of ack packet for the no of msdu's has
+ *	been sent.
+ * @rx_mpdu_count: number of MPDUs received from this station
+ * @fcs_err_count: number of packets (MPDUs) received from this station with
+ *	an FCS error. This counter should be incremented only when TA of the
+ *	received packet with an FCS error matches the peer MAC address.
+ * @airtime_link_metric: mesh airtime link metric.
+ */
+struct station_info {
+	u64 filled;
+	u32 connected_time;
+	u32 inactive_time;
+	u64 assoc_at;
+	u64 rx_bytes;
+	u64 tx_bytes;
+	u16 llid;
+	u16 plid;
+	u8 plink_state;
+	s8 signal;
+	s8 signal_avg;
+
+	u8 chains;
+	s8 chain_signal[IEEE80211_MAX_CHAINS];
+	s8 chain_signal_avg[IEEE80211_MAX_CHAINS];
+
+	struct rate_info txrate;
+	struct rate_info rxrate;
+	u32 rx_packets;
+	u32 tx_packets;
+	u32 tx_retries;
+	u32 tx_failed;
+	u32 rx_dropped_misc;
+	struct sta_bss_parameters bss_param;
+	struct nl80211_sta_flag_update sta_flags;
+
+	int generation;
+
+	const u8 *assoc_req_ies;
+	size_t assoc_req_ies_len;
+
+	u32 beacon_loss_count;
+	s64 t_offset;
+	enum nl80211_mesh_power_mode local_pm;
+	enum nl80211_mesh_power_mode peer_pm;
+	enum nl80211_mesh_power_mode nonpeer_pm;
+
+	u32 expected_throughput;
+
+	u64 tx_duration;
+	u64 rx_duration;
+	u64 rx_beacon;
+	u8 rx_beacon_signal_avg;
+	u8 connected_to_gate;
+
+	struct cfg80211_tid_stats *pertid;
+	s8 ack_signal;
+	s8 avg_ack_signal;
+
+	u16 airtime_weight;
+
+	u32 rx_mpdu_count;
+	u32 fcs_err_count;
+
+	u32 airtime_link_metric;
+};
+
+#if IS_ENABLED(CONFIG_CFG80211)
+/**
+ * cfg80211_get_station - retrieve information about a given station
+ * @dev: the device where the station is supposed to be connected to
+ * @mac_addr: the mac address of the station of interest
+ * @sinfo: pointer to the structure to fill with the information
+ *
+ * Returns 0 on success and sinfo is filled with the available information
+ * otherwise returns a negative error code and the content of sinfo has to be
+ * considered undefined.
+ */
+int cfg80211_get_station(struct net_device *dev, const u8 *mac_addr,
+			 struct station_info *sinfo);
+#else
+static inline int cfg80211_get_station(struct net_device *dev,
+				       const u8 *mac_addr,
+				       struct station_info *sinfo)
+{
+	return -ENOENT;
+}
+#endif
+
+/**
+ * enum monitor_flags - monitor flags
+ *
+ * Monitor interface configuration flags. Note that these must be the bits
+ * according to the nl80211 flags.
+ *
+ * @MONITOR_FLAG_CHANGED: set if the flags were changed
+ * @MONITOR_FLAG_FCSFAIL: pass frames with bad FCS
+ * @MONITOR_FLAG_PLCPFAIL: pass frames with bad PLCP
+ * @MONITOR_FLAG_CONTROL: pass control frames
+ * @MONITOR_FLAG_OTHER_BSS: disable BSSID filtering
+ * @MONITOR_FLAG_COOK_FRAMES: report frames after processing
+ * @MONITOR_FLAG_ACTIVE: active monitor, ACKs frames on its MAC address
+ */
+enum monitor_flags {
+	MONITOR_FLAG_CHANGED		= 1<<__NL80211_MNTR_FLAG_INVALID,
+	MONITOR_FLAG_FCSFAIL		= 1<<NL80211_MNTR_FLAG_FCSFAIL,
+	MONITOR_FLAG_PLCPFAIL		= 1<<NL80211_MNTR_FLAG_PLCPFAIL,
+	MONITOR_FLAG_CONTROL		= 1<<NL80211_MNTR_FLAG_CONTROL,
+	MONITOR_FLAG_OTHER_BSS		= 1<<NL80211_MNTR_FLAG_OTHER_BSS,
+	MONITOR_FLAG_COOK_FRAMES	= 1<<NL80211_MNTR_FLAG_COOK_FRAMES,
+	MONITOR_FLAG_ACTIVE		= 1<<NL80211_MNTR_FLAG_ACTIVE,
+};
+
+/**
+ * enum mpath_info_flags -  mesh path information flags
+ *
+ * Used by the driver to indicate which info in &struct mpath_info it has filled
+ * in during get_station() or dump_station().
+ *
+ * @MPATH_INFO_FRAME_QLEN: @frame_qlen filled
+ * @MPATH_INFO_SN: @sn filled
+ * @MPATH_INFO_METRIC: @metric filled
+ * @MPATH_INFO_EXPTIME: @exptime filled
+ * @MPATH_INFO_DISCOVERY_TIMEOUT: @discovery_timeout filled
+ * @MPATH_INFO_DISCOVERY_RETRIES: @discovery_retries filled
+ * @MPATH_INFO_FLAGS: @flags filled
+ * @MPATH_INFO_HOP_COUNT: @hop_count filled
+ * @MPATH_INFO_PATH_CHANGE: @path_change_count filled
+ */
+enum mpath_info_flags {
+	MPATH_INFO_FRAME_QLEN		= BIT(0),
+	MPATH_INFO_SN			= BIT(1),
+	MPATH_INFO_METRIC		= BIT(2),
+	MPATH_INFO_EXPTIME		= BIT(3),
+	MPATH_INFO_DISCOVERY_TIMEOUT	= BIT(4),
+	MPATH_INFO_DISCOVERY_RETRIES	= BIT(5),
+	MPATH_INFO_FLAGS		= BIT(6),
+	MPATH_INFO_HOP_COUNT		= BIT(7),
+	MPATH_INFO_PATH_CHANGE		= BIT(8),
+};
+
+/**
+ * struct mpath_info - mesh path information
+ *
+ * Mesh path information filled by driver for get_mpath() and dump_mpath().
+ *
+ * @filled: bitfield of flags from &enum mpath_info_flags
+ * @frame_qlen: number of queued frames for this destination
+ * @sn: target sequence number
+ * @metric: metric (cost) of this mesh path
+ * @exptime: expiration time for the mesh path from now, in msecs
+ * @flags: mesh path flags
+ * @discovery_timeout: total mesh path discovery timeout, in msecs
+ * @discovery_retries: mesh path discovery retries
+ * @generation: generation number for nl80211 dumps.
+ *	This number should increase every time the list of mesh paths
+ *	changes, i.e. when a station is added or removed, so that
+ *	userspace can tell whether it got a consistent snapshot.
+ * @hop_count: hops to destination
+ * @path_change_count: total number of path changes to destination
+ */
+struct mpath_info {
+	u32 filled;
+	u32 frame_qlen;
+	u32 sn;
+	u32 metric;
+	u32 exptime;
+	u32 discovery_timeout;
+	u8 discovery_retries;
+	u8 flags;
+	u8 hop_count;
+	u32 path_change_count;
+
+	int generation;
+};
+
+/**
+ * struct bss_parameters - BSS parameters
+ *
+ * Used to change BSS parameters (mainly for AP mode).
+ *
+ * @use_cts_prot: Whether to use CTS protection
+ *	(0 = no, 1 = yes, -1 = do not change)
+ * @use_short_preamble: Whether the use of short preambles is allowed
+ *	(0 = no, 1 = yes, -1 = do not change)
+ * @use_short_slot_time: Whether the use of short slot time is allowed
+ *	(0 = no, 1 = yes, -1 = do not change)
+ * @basic_rates: basic rates in IEEE 802.11 format
+ *	(or NULL for no change)
+ * @basic_rates_len: number of basic rates
+ * @ap_isolate: do not forward packets between connected stations
+ * @ht_opmode: HT Operation mode
+ * 	(u16 = opmode, -1 = do not change)
+ * @p2p_ctwindow: P2P CT Window (-1 = no change)
+ * @p2p_opp_ps: P2P opportunistic PS (-1 = no change)
+ */
+struct bss_parameters {
+	int use_cts_prot;
+	int use_short_preamble;
+	int use_short_slot_time;
+	const u8 *basic_rates;
+	u8 basic_rates_len;
+	int ap_isolate;
+	int ht_opmode;
+	s8 p2p_ctwindow, p2p_opp_ps;
+};
+
+/**
+ * struct mesh_config - 802.11s mesh configuration
+ *
+ * These parameters can be changed while the mesh is active.
+ *
+ * @dot11MeshRetryTimeout: the initial retry timeout in millisecond units used
+ *	by the Mesh Peering Open message
+ * @dot11MeshConfirmTimeout: the initial retry timeout in millisecond units
+ *	used by the Mesh Peering Open message
+ * @dot11MeshHoldingTimeout: the confirm timeout in millisecond units used by
+ *	the mesh peering management to close a mesh peering
+ * @dot11MeshMaxPeerLinks: the maximum number of peer links allowed on this
+ *	mesh interface
+ * @dot11MeshMaxRetries: the maximum number of peer link open retries that can
+ *	be sent to establish a new peer link instance in a mesh
+ * @dot11MeshTTL: the value of TTL field set at a source mesh STA
+ * @element_ttl: the value of TTL field set at a mesh STA for path selection
+ *	elements
+ * @auto_open_plinks: whether we should automatically open peer links when we
+ *	detect compatible mesh peers
+ * @dot11MeshNbrOffsetMaxNeighbor: the maximum number of neighbors to
+ *	synchronize to for 11s default synchronization method
+ * @dot11MeshHWMPmaxPREQretries: the number of action frames containing a PREQ
+ *	that an originator mesh STA can send to a particular path target
+ * @path_refresh_time: how frequently to refresh mesh paths in milliseconds
+ * @min_discovery_timeout: the minimum length of time to wait until giving up on
+ *	a path discovery in milliseconds
+ * @dot11MeshHWMPactivePathTimeout: the time (in TUs) for which mesh STAs
+ *	receiving a PREQ shall consider the forwarding information from the
+ *	root to be valid. (TU = time unit)
+ * @dot11MeshHWMPpreqMinInterval: the minimum interval of time (in TUs) during
+ *	which a mesh STA can send only one action frame containing a PREQ
+ *	element
+ * @dot11MeshHWMPperrMinInterval: the minimum interval of time (in TUs) during
+ *	which a mesh STA can send only one Action frame containing a PERR
+ *	element
+ * @dot11MeshHWMPnetDiameterTraversalTime: the interval of time (in TUs) that
+ *	it takes for an HWMP information element to propagate across the mesh
+ * @dot11MeshHWMPRootMode: the configuration of a mesh STA as root mesh STA
+ * @dot11MeshHWMPRannInterval: the interval of time (in TUs) between root
+ *	announcements are transmitted
+ * @dot11MeshGateAnnouncementProtocol: whether to advertise that this mesh
+ *	station has access to a broader network beyond the MBSS. (This is
+ *	missnamed in draft 12.0: dot11MeshGateAnnouncementProtocol set to true
+ *	only means that the station will announce others it's a mesh gate, but
+ *	not necessarily using the gate announcement protocol. Still keeping the
+ *	same nomenclature to be in sync with the spec)
+ * @dot11MeshForwarding: whether the Mesh STA is forwarding or non-forwarding
+ *	entity (default is TRUE - forwarding entity)
+ * @rssi_threshold: the threshold for average signal strength of candidate
+ *	station to establish a peer link
+ * @ht_opmode: mesh HT protection mode
+ *
+ * @dot11MeshHWMPactivePathToRootTimeout: The time (in TUs) for which mesh STAs
+ *	receiving a proactive PREQ shall consider the forwarding information to
+ *	the root mesh STA to be valid.
+ *
+ * @dot11MeshHWMProotInterval: The interval of time (in TUs) between proactive
+ *	PREQs are transmitted.
+ * @dot11MeshHWMPconfirmationInterval: The minimum interval of time (in TUs)
+ *	during which a mesh STA can send only one Action frame containing
+ *	a PREQ element for root path confirmation.
+ * @power_mode: The default mesh power save mode which will be the initial
+ *	setting for new peer links.
+ * @dot11MeshAwakeWindowDuration: The duration in TUs the STA will remain awake
+ *	after transmitting its beacon.
+ * @plink_timeout: If no tx activity is seen from a STA we've established
+ *	peering with for longer than this time (in seconds), then remove it
+ *	from the STA's list of peers.  Default is 30 minutes.
+ * @dot11MeshConnectedToMeshGate: if set to true, advertise that this STA is
+ *      connected to a mesh gate in mesh formation info.  If false, the
+ *      value in mesh formation is determined by the presence of root paths
+ *      in the mesh path table
+ */
+struct mesh_config {
+	u16 dot11MeshRetryTimeout;
+	u16 dot11MeshConfirmTimeout;
+	u16 dot11MeshHoldingTimeout;
+	u16 dot11MeshMaxPeerLinks;
+	u8 dot11MeshMaxRetries;
+	u8 dot11MeshTTL;
+	u8 element_ttl;
+	bool auto_open_plinks;
+	u32 dot11MeshNbrOffsetMaxNeighbor;
+	u8 dot11MeshHWMPmaxPREQretries;
+	u32 path_refresh_time;
+	u16 min_discovery_timeout;
+	u32 dot11MeshHWMPactivePathTimeout;
+	u16 dot11MeshHWMPpreqMinInterval;
+	u16 dot11MeshHWMPperrMinInterval;
+	u16 dot11MeshHWMPnetDiameterTraversalTime;
+	u8 dot11MeshHWMPRootMode;
+	bool dot11MeshConnectedToMeshGate;
+	u16 dot11MeshHWMPRannInterval;
+	bool dot11MeshGateAnnouncementProtocol;
+	bool dot11MeshForwarding;
+	s32 rssi_threshold;
+	u16 ht_opmode;
+	u32 dot11MeshHWMPactivePathToRootTimeout;
+	u16 dot11MeshHWMProotInterval;
+	u16 dot11MeshHWMPconfirmationInterval;
+	enum nl80211_mesh_power_mode power_mode;
+	u16 dot11MeshAwakeWindowDuration;
+	u32 plink_timeout;
+};
+
+/**
+ * struct mesh_setup - 802.11s mesh setup configuration
+ * @chandef: defines the channel to use
+ * @mesh_id: the mesh ID
+ * @mesh_id_len: length of the mesh ID, at least 1 and at most 32 bytes
+ * @sync_method: which synchronization method to use
+ * @path_sel_proto: which path selection protocol to use
+ * @path_metric: which metric to use
+ * @auth_id: which authentication method this mesh is using
+ * @ie: vendor information elements (optional)
+ * @ie_len: length of vendor information elements
+ * @is_authenticated: this mesh requires authentication
+ * @is_secure: this mesh uses security
+ * @user_mpm: userspace handles all MPM functions
+ * @dtim_period: DTIM period to use
+ * @beacon_interval: beacon interval to use
+ * @mcast_rate: multicat rate for Mesh Node [6Mbps is the default for 802.11a]
+ * @basic_rates: basic rates to use when creating the mesh
+ * @beacon_rate: bitrate to be used for beacons
+ * @userspace_handles_dfs: whether user space controls DFS operation, i.e.
+ *	changes the channel when a radar is detected. This is required
+ *	to operate on DFS channels.
+ * @control_port_over_nl80211: TRUE if userspace expects to exchange control
+ *	port frames over NL80211 instead of the network interface.
+ *
+ * These parameters are fixed when the mesh is created.
+ */
+struct mesh_setup {
+	struct cfg80211_chan_def chandef;
+	const u8 *mesh_id;
+	u8 mesh_id_len;
+	u8 sync_method;
+	u8 path_sel_proto;
+	u8 path_metric;
+	u8 auth_id;
+	const u8 *ie;
+	u8 ie_len;
+	bool is_authenticated;
+	bool is_secure;
+	bool user_mpm;
+	u8 dtim_period;
+	u16 beacon_interval;
+	int mcast_rate[NUM_NL80211_BANDS];
+	u32 basic_rates;
+	struct cfg80211_bitrate_mask beacon_rate;
+	bool userspace_handles_dfs;
+	bool control_port_over_nl80211;
+};
+
+/**
+ * struct ocb_setup - 802.11p OCB mode setup configuration
+ * @chandef: defines the channel to use
+ *
+ * These parameters are fixed when connecting to the network
+ */
+struct ocb_setup {
+	struct cfg80211_chan_def chandef;
+};
+
+/**
+ * struct ieee80211_txq_params - TX queue parameters
+ * @ac: AC identifier
+ * @txop: Maximum burst time in units of 32 usecs, 0 meaning disabled
+ * @cwmin: Minimum contention window [a value of the form 2^n-1 in the range
+ *	1..32767]
+ * @cwmax: Maximum contention window [a value of the form 2^n-1 in the range
+ *	1..32767]
+ * @aifs: Arbitration interframe space [0..255]
+ */
+struct ieee80211_txq_params {
+	enum nl80211_ac ac;
+	u16 txop;
+	u16 cwmin;
+	u16 cwmax;
+	u8 aifs;
+};
+
+/**
+ * DOC: Scanning and BSS list handling
+ *
+ * The scanning process itself is fairly simple, but cfg80211 offers quite
+ * a bit of helper functionality. To start a scan, the scan operation will
+ * be invoked with a scan definition. This scan definition contains the
+ * channels to scan, and the SSIDs to send probe requests for (including the
+ * wildcard, if desired). A passive scan is indicated by having no SSIDs to
+ * probe. Additionally, a scan request may contain extra information elements
+ * that should be added to the probe request. The IEs are guaranteed to be
+ * well-formed, and will not exceed the maximum length the driver advertised
+ * in the wiphy structure.
+ *
+ * When scanning finds a BSS, cfg80211 needs to be notified of that, because
+ * it is responsible for maintaining the BSS list; the driver should not
+ * maintain a list itself. For this notification, various functions exist.
+ *
+ * Since drivers do not maintain a BSS list, there are also a number of
+ * functions to search for a BSS and obtain information about it from the
+ * BSS structure cfg80211 maintains. The BSS list is also made available
+ * to userspace.
+ */
+
+/**
+ * struct cfg80211_ssid - SSID description
+ * @ssid: the SSID
+ * @ssid_len: length of the ssid
+ */
+struct cfg80211_ssid {
+	u8 ssid[IEEE80211_MAX_SSID_LEN];
+	u8 ssid_len;
+};
+
+/**
+ * struct cfg80211_scan_info - information about completed scan
+ * @scan_start_tsf: scan start time in terms of the TSF of the BSS that the
+ *	wireless device that requested the scan is connected to. If this
+ *	information is not available, this field is left zero.
+ * @tsf_bssid: the BSSID according to which %scan_start_tsf is set.
+ * @aborted: set to true if the scan was aborted for any reason,
+ *	userspace will be notified of that
+ */
+struct cfg80211_scan_info {
+	u64 scan_start_tsf;
+	u8 tsf_bssid[ETH_ALEN] __aligned(2);
+	bool aborted;
+};
+
+/**
+ * struct cfg80211_scan_request - scan request description
+ *
+ * @ssids: SSIDs to scan for (active scan only)
+ * @n_ssids: number of SSIDs
+ * @channels: channels to scan on.
+ * @n_channels: total number of channels to scan
+ * @scan_width: channel width for scanning
+ * @ie: optional information element(s) to add into Probe Request or %NULL
+ * @ie_len: length of ie in octets
+ * @duration: how long to listen on each channel, in TUs. If
+ *	%duration_mandatory is not set, this is the maximum dwell time and
+ *	the actual dwell time may be shorter.
+ * @duration_mandatory: if set, the scan duration must be as specified by the
+ *	%duration field.
+ * @flags: bit field of flags controlling operation
+ * @rates: bitmap of rates to advertise for each band
+ * @wiphy: the wiphy this was for
+ * @scan_start: time (in jiffies) when the scan started
+ * @wdev: the wireless device to scan for
+ * @info: (internal) information about completed scan
+ * @notified: (internal) scan request was notified as done or aborted
+ * @no_cck: used to send probe requests at non CCK rate in 2GHz band
+ * @mac_addr: MAC address used with randomisation
+ * @mac_addr_mask: MAC address mask used with randomisation, bits that
+ *	are 0 in the mask should be randomised, bits that are 1 should
+ *	be taken from the @mac_addr
+ * @bssid: BSSID to scan for (most commonly, the wildcard BSSID)
+ */
+struct cfg80211_scan_request {
+	struct cfg80211_ssid *ssids;
+	int n_ssids;
+	u32 n_channels;
+	enum nl80211_bss_scan_width scan_width;
+	const u8 *ie;
+	size_t ie_len;
+	u16 duration;
+	bool duration_mandatory;
+	u32 flags;
+
+	u32 rates[NUM_NL80211_BANDS];
+
+	struct wireless_dev *wdev;
+
+	u8 mac_addr[ETH_ALEN] __aligned(2);
+	u8 mac_addr_mask[ETH_ALEN] __aligned(2);
+	u8 bssid[ETH_ALEN] __aligned(2);
+
+	/* internal */
+	struct wiphy *wiphy;
+	unsigned long scan_start;
+	struct cfg80211_scan_info info;
+	bool notified;
+	bool no_cck;
+
+	/* keep last */
+	struct ieee80211_channel *channels[0];
+};
+
+static inline void get_random_mask_addr(u8 *buf, const u8 *addr, const u8 *mask)
+{
+	int i;
+
+	get_random_bytes(buf, ETH_ALEN);
+	for (i = 0; i < ETH_ALEN; i++) {
+		buf[i] &= ~mask[i];
+		buf[i] |= addr[i] & mask[i];
+	}
+}
+
+/**
+ * struct cfg80211_match_set - sets of attributes to match
+ *
+ * @ssid: SSID to be matched; may be zero-length in case of BSSID match
+ *	or no match (RSSI only)
+ * @bssid: BSSID to be matched; may be all-zero BSSID in case of SSID match
+ *	or no match (RSSI only)
+ * @rssi_thold: don't report scan results below this threshold (in s32 dBm)
+ * @per_band_rssi_thold: Minimum rssi threshold for each band to be applied
+ *	for filtering out scan results received. Drivers advertize this support
+ *	of band specific rssi based filtering through the feature capability
+ *	%NL80211_EXT_FEATURE_SCHED_SCAN_BAND_SPECIFIC_RSSI_THOLD. These band
+ *	specific rssi thresholds take precedence over rssi_thold, if specified.
+ *	If not specified for any band, it will be assigned with rssi_thold of
+ *	corresponding matchset.
+ */
+struct cfg80211_match_set {
+	struct cfg80211_ssid ssid;
+	u8 bssid[ETH_ALEN];
+	s32 rssi_thold;
+	s32 per_band_rssi_thold[NUM_NL80211_BANDS];
+};
+
+/**
+ * struct cfg80211_sched_scan_plan - scan plan for scheduled scan
+ *
+ * @interval: interval between scheduled scan iterations. In seconds.
+ * @iterations: number of scan iterations in this scan plan. Zero means
+ *	infinite loop.
+ *	The last scan plan will always have this parameter set to zero,
+ *	all other scan plans will have a finite number of iterations.
+ */
+struct cfg80211_sched_scan_plan {
+	u32 interval;
+	u32 iterations;
+};
+
+/**
+ * struct cfg80211_bss_select_adjust - BSS selection with RSSI adjustment.
+ *
+ * @band: band of BSS which should match for RSSI level adjustment.
+ * @delta: value of RSSI level adjustment.
+ */
+struct cfg80211_bss_select_adjust {
+	enum nl80211_band band;
+	s8 delta;
+};
+
+/**
+ * struct cfg80211_sched_scan_request - scheduled scan request description
+ *
+ * @reqid: identifies this request.
+ * @ssids: SSIDs to scan for (passed in the probe_reqs in active scans)
+ * @n_ssids: number of SSIDs
+ * @n_channels: total number of channels to scan
+ * @scan_width: channel width for scanning
+ * @ie: optional information element(s) to add into Probe Request or %NULL
+ * @ie_len: length of ie in octets
+ * @flags: bit field of flags controlling operation
+ * @match_sets: sets of parameters to be matched for a scan result
+ * 	entry to be considered valid and to be passed to the host
+ * 	(others are filtered out).
+ *	If ommited, all results are passed.
+ * @n_match_sets: number of match sets
+ * @report_results: indicates that results were reported for this request
+ * @wiphy: the wiphy this was for
+ * @dev: the interface
+ * @scan_start: start time of the scheduled scan
+ * @channels: channels to scan
+ * @min_rssi_thold: for drivers only supporting a single threshold, this
+ *	contains the minimum over all matchsets
+ * @mac_addr: MAC address used with randomisation
+ * @mac_addr_mask: MAC address mask used with randomisation, bits that
+ *	are 0 in the mask should be randomised, bits that are 1 should
+ *	be taken from the @mac_addr
+ * @scan_plans: scan plans to be executed in this scheduled scan. Lowest
+ *	index must be executed first.
+ * @n_scan_plans: number of scan plans, at least 1.
+ * @rcu_head: RCU callback used to free the struct
+ * @owner_nlportid: netlink portid of owner (if this should is a request
+ *	owned by a particular socket)
+ * @nl_owner_dead: netlink owner socket was closed - this request be freed
+ * @list: for keeping list of requests.
+ * @delay: delay in seconds to use before starting the first scan
+ *	cycle.  The driver may ignore this parameter and start
+ *	immediately (or at any other time), if this feature is not
+ *	supported.
+ * @relative_rssi_set: Indicates whether @relative_rssi is set or not.
+ * @relative_rssi: Relative RSSI threshold in dB to restrict scan result
+ *	reporting in connected state to cases where a matching BSS is determined
+ *	to have better or slightly worse RSSI than the current connected BSS.
+ *	The relative RSSI threshold values are ignored in disconnected state.
+ * @rssi_adjust: delta dB of RSSI preference to be given to the BSSs that belong
+ *	to the specified band while deciding whether a better BSS is reported
+ *	using @relative_rssi. If delta is a negative number, the BSSs that
+ *	belong to the specified band will be penalized by delta dB in relative
+ *	comparisions.
+ */
+struct cfg80211_sched_scan_request {
+	u64 reqid;
+	struct cfg80211_ssid *ssids;
+	int n_ssids;
+	u32 n_channels;
+	enum nl80211_bss_scan_width scan_width;
+	const u8 *ie;
+	size_t ie_len;
+	u32 flags;
+	struct cfg80211_match_set *match_sets;
+	int n_match_sets;
+	s32 min_rssi_thold;
+	u32 delay;
+	struct cfg80211_sched_scan_plan *scan_plans;
+	int n_scan_plans;
+
+	u8 mac_addr[ETH_ALEN] __aligned(2);
+	u8 mac_addr_mask[ETH_ALEN] __aligned(2);
+
+	bool relative_rssi_set;
+	s8 relative_rssi;
+	struct cfg80211_bss_select_adjust rssi_adjust;
+
+	/* internal */
+	struct wiphy *wiphy;
+	struct net_device *dev;
+	unsigned long scan_start;
+	bool report_results;
+	struct rcu_head rcu_head;
+	u32 owner_nlportid;
+	bool nl_owner_dead;
+	struct list_head list;
+
+	/* keep last */
+	struct ieee80211_channel *channels[0];
+};
+
+/**
+ * enum cfg80211_signal_type - signal type
+ *
+ * @CFG80211_SIGNAL_TYPE_NONE: no signal strength information available
+ * @CFG80211_SIGNAL_TYPE_MBM: signal strength in mBm (100*dBm)
+ * @CFG80211_SIGNAL_TYPE_UNSPEC: signal strength, increasing from 0 through 100
+ */
+enum cfg80211_signal_type {
+	CFG80211_SIGNAL_TYPE_NONE,
+	CFG80211_SIGNAL_TYPE_MBM,
+	CFG80211_SIGNAL_TYPE_UNSPEC,
+};
+
+/**
+ * struct cfg80211_inform_bss - BSS inform data
+ * @chan: channel the frame was received on
+ * @scan_width: scan width that was used
+ * @signal: signal strength value, according to the wiphy's
+ *	signal type
+ * @boottime_ns: timestamp (CLOCK_BOOTTIME) when the information was
+ *	received; should match the time when the frame was actually
+ *	received by the device (not just by the host, in case it was
+ *	buffered on the device) and be accurate to about 10ms.
+ *	If the frame isn't buffered, just passing the return value of
+ *	ktime_get_boottime_ns() is likely appropriate.
+ * @parent_tsf: the time at the start of reception of the first octet of the
+ *	timestamp field of the frame. The time is the TSF of the BSS specified
+ *	by %parent_bssid.
+ * @parent_bssid: the BSS according to which %parent_tsf is set. This is set to
+ *	the BSS that requested the scan in which the beacon/probe was received.
+ * @chains: bitmask for filled values in @chain_signal.
+ * @chain_signal: per-chain signal strength of last received BSS in dBm.
+ */
+struct cfg80211_inform_bss {
+	struct ieee80211_channel *chan;
+	enum nl80211_bss_scan_width scan_width;
+	s32 signal;
+	u64 boottime_ns;
+	u64 parent_tsf;
+	u8 parent_bssid[ETH_ALEN] __aligned(2);
+	u8 chains;
+	s8 chain_signal[IEEE80211_MAX_CHAINS];
+};
+
+/**
+ * struct cfg80211_bss_ies - BSS entry IE data
+ * @tsf: TSF contained in the frame that carried these IEs
+ * @rcu_head: internal use, for freeing
+ * @len: length of the IEs
+ * @from_beacon: these IEs are known to come from a beacon
+ * @data: IE data
+ */
+struct cfg80211_bss_ies {
+	u64 tsf;
+	struct rcu_head rcu_head;
+	int len;
+	bool from_beacon;
+	u8 data[];
+};
+
+/**
+ * struct cfg80211_bss - BSS description
+ *
+ * This structure describes a BSS (which may also be a mesh network)
+ * for use in scan results and similar.
+ *
+ * @channel: channel this BSS is on
+ * @scan_width: width of the control channel
+ * @bssid: BSSID of the BSS
+ * @beacon_interval: the beacon interval as from the frame
+ * @capability: the capability field in host byte order
+ * @ies: the information elements (Note that there is no guarantee that these
+ *	are well-formed!); this is a pointer to either the beacon_ies or
+ *	proberesp_ies depending on whether Probe Response frame has been
+ *	received. It is always non-%NULL.
+ * @beacon_ies: the information elements from the last Beacon frame
+ *	(implementation note: if @hidden_beacon_bss is set this struct doesn't
+ *	own the beacon_ies, but they're just pointers to the ones from the
+ *	@hidden_beacon_bss struct)
+ * @proberesp_ies: the information elements from the last Probe Response frame
+ * @hidden_beacon_bss: in case this BSS struct represents a probe response from
+ *	a BSS that hides the SSID in its beacon, this points to the BSS struct
+ *	that holds the beacon data. @beacon_ies is still valid, of course, and
+ *	points to the same data as hidden_beacon_bss->beacon_ies in that case.
+ * @transmitted_bss: pointer to the transmitted BSS, if this is a
+ *	non-transmitted one (multi-BSSID support)
+ * @nontrans_list: list of non-transmitted BSS, if this is a transmitted one
+ *	(multi-BSSID support)
+ * @signal: signal strength value (type depends on the wiphy's signal_type)
+ * @chains: bitmask for filled values in @chain_signal.
+ * @chain_signal: per-chain signal strength of last received BSS in dBm.
+ * @bssid_index: index in the multiple BSS set
+ * @max_bssid_indicator: max number of members in the BSS set
+ * @priv: private area for driver use, has at least wiphy->bss_priv_size bytes
+ */
+struct cfg80211_bss {
+	struct ieee80211_channel *channel;
+	enum nl80211_bss_scan_width scan_width;
+
+	const struct cfg80211_bss_ies __rcu *ies;
+	const struct cfg80211_bss_ies __rcu *beacon_ies;
+	const struct cfg80211_bss_ies __rcu *proberesp_ies;
+
+	struct cfg80211_bss *hidden_beacon_bss;
+	struct cfg80211_bss *transmitted_bss;
+	struct list_head nontrans_list;
+
+	s32 signal;
+
+	u16 beacon_interval;
+	u16 capability;
+
+	u8 bssid[ETH_ALEN];
+	u8 chains;
+	s8 chain_signal[IEEE80211_MAX_CHAINS];
+
+	u8 bssid_index;
+	u8 max_bssid_indicator;
+
+	u8 priv[0] __aligned(sizeof(void *));
+};
+
+/**
+ * ieee80211_bss_get_elem - find element with given ID
+ * @bss: the bss to search
+ * @id: the element ID
+ *
+ * Note that the return value is an RCU-protected pointer, so
+ * rcu_read_lock() must be held when calling this function.
+ * Return: %NULL if not found.
+ */
+const struct element *ieee80211_bss_get_elem(struct cfg80211_bss *bss, u8 id);
+
+/**
+ * ieee80211_bss_get_ie - find IE with given ID
+ * @bss: the bss to search
+ * @id: the element ID
+ *
+ * Note that the return value is an RCU-protected pointer, so
+ * rcu_read_lock() must be held when calling this function.
+ * Return: %NULL if not found.
+ */
+static inline const u8 *ieee80211_bss_get_ie(struct cfg80211_bss *bss, u8 id)
+{
+	return (void *)ieee80211_bss_get_elem(bss, id);
+}
+
+
+/**
+ * struct cfg80211_auth_request - Authentication request data
+ *
+ * This structure provides information needed to complete IEEE 802.11
+ * authentication.
+ *
+ * @bss: The BSS to authenticate with, the callee must obtain a reference
+ *	to it if it needs to keep it.
+ * @auth_type: Authentication type (algorithm)
+ * @ie: Extra IEs to add to Authentication frame or %NULL
+ * @ie_len: Length of ie buffer in octets
+ * @key_len: length of WEP key for shared key authentication
+ * @key_idx: index of WEP key for shared key authentication
+ * @key: WEP key for shared key authentication
+ * @auth_data: Fields and elements in Authentication frames. This contains
+ *	the authentication frame body (non-IE and IE data), excluding the
+ *	Authentication algorithm number, i.e., starting at the Authentication
+ *	transaction sequence number field.
+ * @auth_data_len: Length of auth_data buffer in octets
+ */
+struct cfg80211_auth_request {
+	struct cfg80211_bss *bss;
+	const u8 *ie;
+	size_t ie_len;
+	enum nl80211_auth_type auth_type;
+	const u8 *key;
+	u8 key_len, key_idx;
+	const u8 *auth_data;
+	size_t auth_data_len;
+};
+
+/**
+ * enum cfg80211_assoc_req_flags - Over-ride default behaviour in association.
+ *
+ * @ASSOC_REQ_DISABLE_HT:  Disable HT (802.11n)
+ * @ASSOC_REQ_DISABLE_VHT:  Disable VHT
+ * @ASSOC_REQ_USE_RRM: Declare RRM capability in this association
+ * @CONNECT_REQ_EXTERNAL_AUTH_SUPPORT: User space indicates external
+ *	authentication capability. Drivers can offload authentication to
+ *	userspace if this flag is set. Only applicable for cfg80211_connect()
+ *	request (connect callback).
+ */
+enum cfg80211_assoc_req_flags {
+	ASSOC_REQ_DISABLE_HT			= BIT(0),
+	ASSOC_REQ_DISABLE_VHT			= BIT(1),
+	ASSOC_REQ_USE_RRM			= BIT(2),
+	CONNECT_REQ_EXTERNAL_AUTH_SUPPORT	= BIT(3),
+};
+
+/**
+ * struct cfg80211_assoc_request - (Re)Association request data
+ *
+ * This structure provides information needed to complete IEEE 802.11
+ * (re)association.
+ * @bss: The BSS to associate with. If the call is successful the driver is
+ *	given a reference that it must give back to cfg80211_send_rx_assoc()
+ *	or to cfg80211_assoc_timeout(). To ensure proper refcounting, new
+ *	association requests while already associating must be rejected.
+ * @ie: Extra IEs to add to (Re)Association Request frame or %NULL
+ * @ie_len: Length of ie buffer in octets
+ * @use_mfp: Use management frame protection (IEEE 802.11w) in this association
+ * @crypto: crypto settings
+ * @prev_bssid: previous BSSID, if not %NULL use reassociate frame. This is used
+ *	to indicate a request to reassociate within the ESS instead of a request
+ *	do the initial association with the ESS. When included, this is set to
+ *	the BSSID of the current association, i.e., to the value that is
+ *	included in the Current AP address field of the Reassociation Request
+ *	frame.
+ * @flags:  See &enum cfg80211_assoc_req_flags
+ * @ht_capa:  HT Capabilities over-rides.  Values set in ht_capa_mask
+ *	will be used in ht_capa.  Un-supported values will be ignored.
+ * @ht_capa_mask:  The bits of ht_capa which are to be used.
+ * @vht_capa: VHT capability override
+ * @vht_capa_mask: VHT capability mask indicating which fields to use
+ * @fils_kek: FILS KEK for protecting (Re)Association Request/Response frame or
+ *	%NULL if FILS is not used.
+ * @fils_kek_len: Length of fils_kek in octets
+ * @fils_nonces: FILS nonces (part of AAD) for protecting (Re)Association
+ *	Request/Response frame or %NULL if FILS is not used. This field starts
+ *	with 16 octets of STA Nonce followed by 16 octets of AP Nonce.
+ */
+struct cfg80211_assoc_request {
+	struct cfg80211_bss *bss;
+	const u8 *ie, *prev_bssid;
+	size_t ie_len;
+	struct cfg80211_crypto_settings crypto;
+	bool use_mfp;
+	u32 flags;
+	struct ieee80211_ht_cap ht_capa;
+	struct ieee80211_ht_cap ht_capa_mask;
+	struct ieee80211_vht_cap vht_capa, vht_capa_mask;
+	const u8 *fils_kek;
+	size_t fils_kek_len;
+	const u8 *fils_nonces;
+};
+
+/**
+ * struct cfg80211_deauth_request - Deauthentication request data
+ *
+ * This structure provides information needed to complete IEEE 802.11
+ * deauthentication.
+ *
+ * @bssid: the BSSID of the BSS to deauthenticate from
+ * @ie: Extra IEs to add to Deauthentication frame or %NULL
+ * @ie_len: Length of ie buffer in octets
+ * @reason_code: The reason code for the deauthentication
+ * @local_state_change: if set, change local state only and
+ *	do not set a deauth frame
+ */
+struct cfg80211_deauth_request {
+	const u8 *bssid;
+	const u8 *ie;
+	size_t ie_len;
+	u16 reason_code;
+	bool local_state_change;
+};
+
+/**
+ * struct cfg80211_disassoc_request - Disassociation request data
+ *
+ * This structure provides information needed to complete IEEE 802.11
+ * disassociation.
+ *
+ * @bss: the BSS to disassociate from
+ * @ie: Extra IEs to add to Disassociation frame or %NULL
+ * @ie_len: Length of ie buffer in octets
+ * @reason_code: The reason code for the disassociation
+ * @local_state_change: This is a request for a local state only, i.e., no
+ *	Disassociation frame is to be transmitted.
+ */
+struct cfg80211_disassoc_request {
+	struct cfg80211_bss *bss;
+	const u8 *ie;
+	size_t ie_len;
+	u16 reason_code;
+	bool local_state_change;
+};
+
+/**
+ * struct cfg80211_ibss_params - IBSS parameters
+ *
+ * This structure defines the IBSS parameters for the join_ibss()
+ * method.
+ *
+ * @ssid: The SSID, will always be non-null.
+ * @ssid_len: The length of the SSID, will always be non-zero.
+ * @bssid: Fixed BSSID requested, maybe be %NULL, if set do not
+ *	search for IBSSs with a different BSSID.
+ * @chandef: defines the channel to use if no other IBSS to join can be found
+ * @channel_fixed: The channel should be fixed -- do not search for
+ *	IBSSs to join on other channels.
+ * @ie: information element(s) to include in the beacon
+ * @ie_len: length of that
+ * @beacon_interval: beacon interval to use
+ * @privacy: this is a protected network, keys will be configured
+ *	after joining
+ * @control_port: whether user space controls IEEE 802.1X port, i.e.,
+ *	sets/clears %NL80211_STA_FLAG_AUTHORIZED. If true, the driver is
+ *	required to assume that the port is unauthorized until authorized by
+ *	user space. Otherwise, port is marked authorized by default.
+ * @control_port_over_nl80211: TRUE if userspace expects to exchange control
+ *	port frames over NL80211 instead of the network interface.
+ * @userspace_handles_dfs: whether user space controls DFS operation, i.e.
+ *	changes the channel when a radar is detected. This is required
+ *	to operate on DFS channels.
+ * @basic_rates: bitmap of basic rates to use when creating the IBSS
+ * @mcast_rate: per-band multicast rate index + 1 (0: disabled)
+ * @ht_capa:  HT Capabilities over-rides.  Values set in ht_capa_mask
+ *	will be used in ht_capa.  Un-supported values will be ignored.
+ * @ht_capa_mask:  The bits of ht_capa which are to be used.
+ * @wep_keys: static WEP keys, if not NULL points to an array of
+ * 	CFG80211_MAX_WEP_KEYS WEP keys
+ * @wep_tx_key: key index (0..3) of the default TX static WEP key
+ */
+struct cfg80211_ibss_params {
+	const u8 *ssid;
+	const u8 *bssid;
+	struct cfg80211_chan_def chandef;
+	const u8 *ie;
+	u8 ssid_len, ie_len;
+	u16 beacon_interval;
+	u32 basic_rates;
+	bool channel_fixed;
+	bool privacy;
+	bool control_port;
+	bool control_port_over_nl80211;
+	bool userspace_handles_dfs;
+	int mcast_rate[NUM_NL80211_BANDS];
+	struct ieee80211_ht_cap ht_capa;
+	struct ieee80211_ht_cap ht_capa_mask;
+	struct key_params *wep_keys;
+	int wep_tx_key;
+};
+
+/**
+ * struct cfg80211_bss_selection - connection parameters for BSS selection.
+ *
+ * @behaviour: requested BSS selection behaviour.
+ * @param: parameters for requestion behaviour.
+ * @band_pref: preferred band for %NL80211_BSS_SELECT_ATTR_BAND_PREF.
+ * @adjust: parameters for %NL80211_BSS_SELECT_ATTR_RSSI_ADJUST.
+ */
+struct cfg80211_bss_selection {
+	enum nl80211_bss_select_attr behaviour;
+	union {
+		enum nl80211_band band_pref;
+		struct cfg80211_bss_select_adjust adjust;
+	} param;
+};
+
+/**
+ * struct cfg80211_connect_params - Connection parameters
+ *
+ * This structure provides information needed to complete IEEE 802.11
+ * authentication and association.
+ *
+ * @channel: The channel to use or %NULL if not specified (auto-select based
+ *	on scan results)
+ * @channel_hint: The channel of the recommended BSS for initial connection or
+ *	%NULL if not specified
+ * @bssid: The AP BSSID or %NULL if not specified (auto-select based on scan
+ *	results)
+ * @bssid_hint: The recommended AP BSSID for initial connection to the BSS or
+ *	%NULL if not specified. Unlike the @bssid parameter, the driver is
+ *	allowed to ignore this @bssid_hint if it has knowledge of a better BSS
+ *	to use.
+ * @ssid: SSID
+ * @ssid_len: Length of ssid in octets
+ * @auth_type: Authentication type (algorithm)
+ * @ie: IEs for association request
+ * @ie_len: Length of assoc_ie in octets
+ * @privacy: indicates whether privacy-enabled APs should be used
+ * @mfp: indicate whether management frame protection is used
+ * @crypto: crypto settings
+ * @key_len: length of WEP key for shared key authentication
+ * @key_idx: index of WEP key for shared key authentication
+ * @key: WEP key for shared key authentication
+ * @flags:  See &enum cfg80211_assoc_req_flags
+ * @bg_scan_period:  Background scan period in seconds
+ *	or -1 to indicate that default value is to be used.
+ * @ht_capa:  HT Capabilities over-rides.  Values set in ht_capa_mask
+ *	will be used in ht_capa.  Un-supported values will be ignored.
+ * @ht_capa_mask:  The bits of ht_capa which are to be used.
+ * @vht_capa:  VHT Capability overrides
+ * @vht_capa_mask: The bits of vht_capa which are to be used.
+ * @pbss: if set, connect to a PCP instead of AP. Valid for DMG
+ *	networks.
+ * @bss_select: criteria to be used for BSS selection.
+ * @prev_bssid: previous BSSID, if not %NULL use reassociate frame. This is used
+ *	to indicate a request to reassociate within the ESS instead of a request
+ *	do the initial association with the ESS. When included, this is set to
+ *	the BSSID of the current association, i.e., to the value that is
+ *	included in the Current AP address field of the Reassociation Request
+ *	frame.
+ * @fils_erp_username: EAP re-authentication protocol (ERP) username part of the
+ *	NAI or %NULL if not specified. This is used to construct FILS wrapped
+ *	data IE.
+ * @fils_erp_username_len: Length of @fils_erp_username in octets.
+ * @fils_erp_realm: EAP re-authentication protocol (ERP) realm part of NAI or
+ *	%NULL if not specified. This specifies the domain name of ER server and
+ *	is used to construct FILS wrapped data IE.
+ * @fils_erp_realm_len: Length of @fils_erp_realm in octets.
+ * @fils_erp_next_seq_num: The next sequence number to use in the FILS ERP
+ *	messages. This is also used to construct FILS wrapped data IE.
+ * @fils_erp_rrk: ERP re-authentication Root Key (rRK) used to derive additional
+ *	keys in FILS or %NULL if not specified.
+ * @fils_erp_rrk_len: Length of @fils_erp_rrk in octets.
+ * @want_1x: indicates user-space supports and wants to use 802.1X driver
+ *	offload of 4-way handshake.
+ * @edmg: define the EDMG channels.
+ *	This may specify multiple channels and bonding options for the driver
+ *	to choose from, based on BSS configuration.
+ */
+struct cfg80211_connect_params {
+	struct ieee80211_channel *channel;
+	struct ieee80211_channel *channel_hint;
+	const u8 *bssid;
+	const u8 *bssid_hint;
+	const u8 *ssid;
+	size_t ssid_len;
+	enum nl80211_auth_type auth_type;
+	const u8 *ie;
+	size_t ie_len;
+	bool privacy;
+	enum nl80211_mfp mfp;
+	struct cfg80211_crypto_settings crypto;
+	const u8 *key;
+	u8 key_len, key_idx;
+	u32 flags;
+	int bg_scan_period;
+	struct ieee80211_ht_cap ht_capa;
+	struct ieee80211_ht_cap ht_capa_mask;
+	struct ieee80211_vht_cap vht_capa;
+	struct ieee80211_vht_cap vht_capa_mask;
+	bool pbss;
+	struct cfg80211_bss_selection bss_select;
+	const u8 *prev_bssid;
+	const u8 *fils_erp_username;
+	size_t fils_erp_username_len;
+	const u8 *fils_erp_realm;
+	size_t fils_erp_realm_len;
+	u16 fils_erp_next_seq_num;
+	const u8 *fils_erp_rrk;
+	size_t fils_erp_rrk_len;
+	bool want_1x;
+	struct ieee80211_edmg edmg;
+};
+
+/**
+ * enum cfg80211_connect_params_changed - Connection parameters being updated
+ *
+ * This enum provides information of all connect parameters that
+ * have to be updated as part of update_connect_params() call.
+ *
+ * @UPDATE_ASSOC_IES: Indicates whether association request IEs are updated
+ * @UPDATE_FILS_ERP_INFO: Indicates that FILS connection parameters (realm,
+ *	username, erp sequence number and rrk) are updated
+ * @UPDATE_AUTH_TYPE: Indicates that authentication type is updated
+ */
+enum cfg80211_connect_params_changed {
+	UPDATE_ASSOC_IES		= BIT(0),
+	UPDATE_FILS_ERP_INFO		= BIT(1),
+	UPDATE_AUTH_TYPE		= BIT(2),
+};
+
+/**
+ * enum wiphy_params_flags - set_wiphy_params bitfield values
+ * @WIPHY_PARAM_RETRY_SHORT: wiphy->retry_short has changed
+ * @WIPHY_PARAM_RETRY_LONG: wiphy->retry_long has changed
+ * @WIPHY_PARAM_FRAG_THRESHOLD: wiphy->frag_threshold has changed
+ * @WIPHY_PARAM_RTS_THRESHOLD: wiphy->rts_threshold has changed
+ * @WIPHY_PARAM_COVERAGE_CLASS: coverage class changed
+ * @WIPHY_PARAM_DYN_ACK: dynack has been enabled
+ * @WIPHY_PARAM_TXQ_LIMIT: TXQ packet limit has been changed
+ * @WIPHY_PARAM_TXQ_MEMORY_LIMIT: TXQ memory limit has been changed
+ * @WIPHY_PARAM_TXQ_QUANTUM: TXQ scheduler quantum
+ */
+enum wiphy_params_flags {
+	WIPHY_PARAM_RETRY_SHORT		= 1 << 0,
+	WIPHY_PARAM_RETRY_LONG		= 1 << 1,
+	WIPHY_PARAM_FRAG_THRESHOLD	= 1 << 2,
+	WIPHY_PARAM_RTS_THRESHOLD	= 1 << 3,
+	WIPHY_PARAM_COVERAGE_CLASS	= 1 << 4,
+	WIPHY_PARAM_DYN_ACK		= 1 << 5,
+	WIPHY_PARAM_TXQ_LIMIT		= 1 << 6,
+	WIPHY_PARAM_TXQ_MEMORY_LIMIT	= 1 << 7,
+	WIPHY_PARAM_TXQ_QUANTUM		= 1 << 8,
+};
+
+#define IEEE80211_DEFAULT_AIRTIME_WEIGHT	256
+
+/**
+ * struct cfg80211_pmksa - PMK Security Association
+ *
+ * This structure is passed to the set/del_pmksa() method for PMKSA
+ * caching.
+ *
+ * @bssid: The AP's BSSID (may be %NULL).
+ * @pmkid: The identifier to refer a PMKSA.
+ * @pmk: The PMK for the PMKSA identified by @pmkid. This is used for key
+ *	derivation by a FILS STA. Otherwise, %NULL.
+ * @pmk_len: Length of the @pmk. The length of @pmk can differ depending on
+ *	the hash algorithm used to generate this.
+ * @ssid: SSID to specify the ESS within which a PMKSA is valid when using FILS
+ *	cache identifier (may be %NULL).
+ * @ssid_len: Length of the @ssid in octets.
+ * @cache_id: 2-octet cache identifier advertized by a FILS AP identifying the
+ *	scope of PMKSA. This is valid only if @ssid_len is non-zero (may be
+ *	%NULL).
+ * @pmk_lifetime: Maximum lifetime for PMKSA in seconds
+ *	(dot11RSNAConfigPMKLifetime) or 0 if not specified.
+ *	The configured PMKSA must not be used for PMKSA caching after
+ *	expiration and any keys derived from this PMK become invalid on
+ *	expiration, i.e., the current association must be dropped if the PMK
+ *	used for it expires.
+ * @pmk_reauth_threshold: Threshold time for reauthentication (percentage of
+ *	PMK lifetime, dot11RSNAConfigPMKReauthThreshold) or 0 if not specified.
+ *	Drivers are expected to trigger a full authentication instead of using
+ *	this PMKSA for caching when reassociating to a new BSS after this
+ *	threshold to generate a new PMK before the current one expires.
+ */
+struct cfg80211_pmksa {
+	const u8 *bssid;
+	const u8 *pmkid;
+	const u8 *pmk;
+	size_t pmk_len;
+	const u8 *ssid;
+	size_t ssid_len;
+	const u8 *cache_id;
+	u32 pmk_lifetime;
+	u8 pmk_reauth_threshold;
+};
+
+/**
+ * struct cfg80211_pkt_pattern - packet pattern
+ * @mask: bitmask where to match pattern and where to ignore bytes,
+ *	one bit per byte, in same format as nl80211
+ * @pattern: bytes to match where bitmask is 1
+ * @pattern_len: length of pattern (in bytes)
+ * @pkt_offset: packet offset (in bytes)
+ *
+ * Internal note: @mask and @pattern are allocated in one chunk of
+ * memory, free @mask only!
+ */
+struct cfg80211_pkt_pattern {
+	const u8 *mask, *pattern;
+	int pattern_len;
+	int pkt_offset;
+};
+
+/**
+ * struct cfg80211_wowlan_tcp - TCP connection parameters
+ *
+ * @sock: (internal) socket for source port allocation
+ * @src: source IP address
+ * @dst: destination IP address
+ * @dst_mac: destination MAC address
+ * @src_port: source port
+ * @dst_port: destination port
+ * @payload_len: data payload length
+ * @payload: data payload buffer
+ * @payload_seq: payload sequence stamping configuration
+ * @data_interval: interval at which to send data packets
+ * @wake_len: wakeup payload match length
+ * @wake_data: wakeup payload match data
+ * @wake_mask: wakeup payload match mask
+ * @tokens_size: length of the tokens buffer
+ * @payload_tok: payload token usage configuration
+ */
+struct cfg80211_wowlan_tcp {
+	struct socket *sock;
+	__be32 src, dst;
+	u16 src_port, dst_port;
+	u8 dst_mac[ETH_ALEN];
+	int payload_len;
+	const u8 *payload;
+	struct nl80211_wowlan_tcp_data_seq payload_seq;
+	u32 data_interval;
+	u32 wake_len;
+	const u8 *wake_data, *wake_mask;
+	u32 tokens_size;
+	/* must be last, variable member */
+	struct nl80211_wowlan_tcp_data_token payload_tok;
+};
+
+/**
+ * struct cfg80211_wowlan - Wake on Wireless-LAN support info
+ *
+ * This structure defines the enabled WoWLAN triggers for the device.
+ * @any: wake up on any activity -- special trigger if device continues
+ *	operating as normal during suspend
+ * @disconnect: wake up if getting disconnected
+ * @magic_pkt: wake up on receiving magic packet
+ * @patterns: wake up on receiving packet matching a pattern
+ * @n_patterns: number of patterns
+ * @gtk_rekey_failure: wake up on GTK rekey failure
+ * @eap_identity_req: wake up on EAP identity request packet
+ * @four_way_handshake: wake up on 4-way handshake
+ * @rfkill_release: wake up when rfkill is released
+ * @tcp: TCP connection establishment/wakeup parameters, see nl80211.h.
+ *	NULL if not configured.
+ * @nd_config: configuration for the scan to be used for net detect wake.
+ */
+struct cfg80211_wowlan {
+	bool any, disconnect, magic_pkt, gtk_rekey_failure,
+	     eap_identity_req, four_way_handshake,
+	     rfkill_release;
+	struct cfg80211_pkt_pattern *patterns;
+	struct cfg80211_wowlan_tcp *tcp;
+	int n_patterns;
+	struct cfg80211_sched_scan_request *nd_config;
+};
+
+/**
+ * struct cfg80211_coalesce_rules - Coalesce rule parameters
+ *
+ * This structure defines coalesce rule for the device.
+ * @delay: maximum coalescing delay in msecs.
+ * @condition: condition for packet coalescence.
+ *	see &enum nl80211_coalesce_condition.
+ * @patterns: array of packet patterns
+ * @n_patterns: number of patterns
+ */
+struct cfg80211_coalesce_rules {
+	int delay;
+	enum nl80211_coalesce_condition condition;
+	struct cfg80211_pkt_pattern *patterns;
+	int n_patterns;
+};
+
+/**
+ * struct cfg80211_coalesce - Packet coalescing settings
+ *
+ * This structure defines coalescing settings.
+ * @rules: array of coalesce rules
+ * @n_rules: number of rules
+ */
+struct cfg80211_coalesce {
+	struct cfg80211_coalesce_rules *rules;
+	int n_rules;
+};
+
+/**
+ * struct cfg80211_wowlan_nd_match - information about the match
+ *
+ * @ssid: SSID of the match that triggered the wake up
+ * @n_channels: Number of channels where the match occurred.  This
+ *	value may be zero if the driver can't report the channels.
+ * @channels: center frequencies of the channels where a match
+ *	occurred (in MHz)
+ */
+struct cfg80211_wowlan_nd_match {
+	struct cfg80211_ssid ssid;
+	int n_channels;
+	u32 channels[];
+};
+
+/**
+ * struct cfg80211_wowlan_nd_info - net detect wake up information
+ *
+ * @n_matches: Number of match information instances provided in
+ *	@matches.  This value may be zero if the driver can't provide
+ *	match information.
+ * @matches: Array of pointers to matches containing information about
+ *	the matches that triggered the wake up.
+ */
+struct cfg80211_wowlan_nd_info {
+	int n_matches;
+	struct cfg80211_wowlan_nd_match *matches[];
+};
+
+/**
+ * struct cfg80211_wowlan_wakeup - wakeup report
+ * @disconnect: woke up by getting disconnected
+ * @magic_pkt: woke up by receiving magic packet
+ * @gtk_rekey_failure: woke up by GTK rekey failure
+ * @eap_identity_req: woke up by EAP identity request packet
+ * @four_way_handshake: woke up by 4-way handshake
+ * @rfkill_release: woke up by rfkill being released
+ * @pattern_idx: pattern that caused wakeup, -1 if not due to pattern
+ * @packet_present_len: copied wakeup packet data
+ * @packet_len: original wakeup packet length
+ * @packet: The packet causing the wakeup, if any.
+ * @packet_80211:  For pattern match, magic packet and other data
+ *	frame triggers an 802.3 frame should be reported, for
+ *	disconnect due to deauth 802.11 frame. This indicates which
+ *	it is.
+ * @tcp_match: TCP wakeup packet received
+ * @tcp_connlost: TCP connection lost or failed to establish
+ * @tcp_nomoretokens: TCP data ran out of tokens
+ * @net_detect: if not %NULL, woke up because of net detect
+ */
+struct cfg80211_wowlan_wakeup {
+	bool disconnect, magic_pkt, gtk_rekey_failure,
+	     eap_identity_req, four_way_handshake,
+	     rfkill_release, packet_80211,
+	     tcp_match, tcp_connlost, tcp_nomoretokens;
+	s32 pattern_idx;
+	u32 packet_present_len, packet_len;
+	const void *packet;
+	struct cfg80211_wowlan_nd_info *net_detect;
+};
+
+/**
+ * struct cfg80211_gtk_rekey_data - rekey data
+ * @kek: key encryption key (NL80211_KEK_LEN bytes)
+ * @kck: key confirmation key (NL80211_KCK_LEN bytes)
+ * @replay_ctr: replay counter (NL80211_REPLAY_CTR_LEN bytes)
+ */
+struct cfg80211_gtk_rekey_data {
+	const u8 *kek, *kck, *replay_ctr;
+};
+
+/**
+ * struct cfg80211_update_ft_ies_params - FT IE Information
+ *
+ * This structure provides information needed to update the fast transition IE
+ *
+ * @md: The Mobility Domain ID, 2 Octet value
+ * @ie: Fast Transition IEs
+ * @ie_len: Length of ft_ie in octets
+ */
+struct cfg80211_update_ft_ies_params {
+	u16 md;
+	const u8 *ie;
+	size_t ie_len;
+};
+
+/**
+ * struct cfg80211_mgmt_tx_params - mgmt tx parameters
+ *
+ * This structure provides information needed to transmit a mgmt frame
+ *
+ * @chan: channel to use
+ * @offchan: indicates wether off channel operation is required
+ * @wait: duration for ROC
+ * @buf: buffer to transmit
+ * @len: buffer length
+ * @no_cck: don't use cck rates for this frame
+ * @dont_wait_for_ack: tells the low level not to wait for an ack
+ * @n_csa_offsets: length of csa_offsets array
+ * @csa_offsets: array of all the csa offsets in the frame
+ */
+struct cfg80211_mgmt_tx_params {
+	struct ieee80211_channel *chan;
+	bool offchan;
+	unsigned int wait;
+	const u8 *buf;
+	size_t len;
+	bool no_cck;
+	bool dont_wait_for_ack;
+	int n_csa_offsets;
+	const u16 *csa_offsets;
+};
+
+/**
+ * struct cfg80211_dscp_exception - DSCP exception
+ *
+ * @dscp: DSCP value that does not adhere to the user priority range definition
+ * @up: user priority value to which the corresponding DSCP value belongs
+ */
+struct cfg80211_dscp_exception {
+	u8 dscp;
+	u8 up;
+};
+
+/**
+ * struct cfg80211_dscp_range - DSCP range definition for user priority
+ *
+ * @low: lowest DSCP value of this user priority range, inclusive
+ * @high: highest DSCP value of this user priority range, inclusive
+ */
+struct cfg80211_dscp_range {
+	u8 low;
+	u8 high;
+};
+
+/* QoS Map Set element length defined in IEEE Std 802.11-2012, 8.4.2.97 */
+#define IEEE80211_QOS_MAP_MAX_EX	21
+#define IEEE80211_QOS_MAP_LEN_MIN	16
+#define IEEE80211_QOS_MAP_LEN_MAX \
+	(IEEE80211_QOS_MAP_LEN_MIN + 2 * IEEE80211_QOS_MAP_MAX_EX)
+
+/**
+ * struct cfg80211_qos_map - QoS Map Information
+ *
+ * This struct defines the Interworking QoS map setting for DSCP values
+ *
+ * @num_des: number of DSCP exceptions (0..21)
+ * @dscp_exception: optionally up to maximum of 21 DSCP exceptions from
+ *	the user priority DSCP range definition
+ * @up: DSCP range definition for a particular user priority
+ */
+struct cfg80211_qos_map {
+	u8 num_des;
+	struct cfg80211_dscp_exception dscp_exception[IEEE80211_QOS_MAP_MAX_EX];
+	struct cfg80211_dscp_range up[8];
+};
+
+/**
+ * struct cfg80211_nan_conf - NAN configuration
+ *
+ * This struct defines NAN configuration parameters
+ *
+ * @master_pref: master preference (1 - 255)
+ * @bands: operating bands, a bitmap of &enum nl80211_band values.
+ *	For instance, for NL80211_BAND_2GHZ, bit 0 would be set
+ *	(i.e. BIT(NL80211_BAND_2GHZ)).
+ */
+struct cfg80211_nan_conf {
+	u8 master_pref;
+	u8 bands;
+};
+
+/**
+ * enum cfg80211_nan_conf_changes - indicates changed fields in NAN
+ * configuration
+ *
+ * @CFG80211_NAN_CONF_CHANGED_PREF: master preference
+ * @CFG80211_NAN_CONF_CHANGED_BANDS: operating bands
+ */
+enum cfg80211_nan_conf_changes {
+	CFG80211_NAN_CONF_CHANGED_PREF = BIT(0),
+	CFG80211_NAN_CONF_CHANGED_BANDS = BIT(1),
+};
+
+/**
+ * struct cfg80211_nan_func_filter - a NAN function Rx / Tx filter
+ *
+ * @filter: the content of the filter
+ * @len: the length of the filter
+ */
+struct cfg80211_nan_func_filter {
+	const u8 *filter;
+	u8 len;
+};
+
+/**
+ * struct cfg80211_nan_func - a NAN function
+ *
+ * @type: &enum nl80211_nan_function_type
+ * @service_id: the service ID of the function
+ * @publish_type: &nl80211_nan_publish_type
+ * @close_range: if true, the range should be limited. Threshold is
+ *	implementation specific.
+ * @publish_bcast: if true, the solicited publish should be broadcasted
+ * @subscribe_active: if true, the subscribe is active
+ * @followup_id: the instance ID for follow up
+ * @followup_reqid: the requestor instance ID for follow up
+ * @followup_dest: MAC address of the recipient of the follow up
+ * @ttl: time to live counter in DW.
+ * @serv_spec_info: Service Specific Info
+ * @serv_spec_info_len: Service Specific Info length
+ * @srf_include: if true, SRF is inclusive
+ * @srf_bf: Bloom Filter
+ * @srf_bf_len: Bloom Filter length
+ * @srf_bf_idx: Bloom Filter index
+ * @srf_macs: SRF MAC addresses
+ * @srf_num_macs: number of MAC addresses in SRF
+ * @rx_filters: rx filters that are matched with corresponding peer's tx_filter
+ * @tx_filters: filters that should be transmitted in the SDF.
+ * @num_rx_filters: length of &rx_filters.
+ * @num_tx_filters: length of &tx_filters.
+ * @instance_id: driver allocated id of the function.
+ * @cookie: unique NAN function identifier.
+ */
+struct cfg80211_nan_func {
+	enum nl80211_nan_function_type type;
+	u8 service_id[NL80211_NAN_FUNC_SERVICE_ID_LEN];
+	u8 publish_type;
+	bool close_range;
+	bool publish_bcast;
+	bool subscribe_active;
+	u8 followup_id;
+	u8 followup_reqid;
+	struct mac_address followup_dest;
+	u32 ttl;
+	const u8 *serv_spec_info;
+	u8 serv_spec_info_len;
+	bool srf_include;
+	const u8 *srf_bf;
+	u8 srf_bf_len;
+	u8 srf_bf_idx;
+	struct mac_address *srf_macs;
+	int srf_num_macs;
+	struct cfg80211_nan_func_filter *rx_filters;
+	struct cfg80211_nan_func_filter *tx_filters;
+	u8 num_tx_filters;
+	u8 num_rx_filters;
+	u8 instance_id;
+	u64 cookie;
+};
+
+/**
+ * struct cfg80211_pmk_conf - PMK configuration
+ *
+ * @aa: authenticator address
+ * @pmk_len: PMK length in bytes.
+ * @pmk: the PMK material
+ * @pmk_r0_name: PMK-R0 Name. NULL if not applicable (i.e., the PMK
+ *	is not PMK-R0). When pmk_r0_name is not NULL, the pmk field
+ *	holds PMK-R0.
+ */
+struct cfg80211_pmk_conf {
+	const u8 *aa;
+	u8 pmk_len;
+	const u8 *pmk;
+	const u8 *pmk_r0_name;
+};
+
+/**
+ * struct cfg80211_external_auth_params - Trigger External authentication.
+ *
+ * Commonly used across the external auth request and event interfaces.
+ *
+ * @action: action type / trigger for external authentication. Only significant
+ *	for the authentication request event interface (driver to user space).
+ * @bssid: BSSID of the peer with which the authentication has
+ *	to happen. Used by both the authentication request event and
+ *	authentication response command interface.
+ * @ssid: SSID of the AP.  Used by both the authentication request event and
+ *	authentication response command interface.
+ * @key_mgmt_suite: AKM suite of the respective authentication. Used by the
+ *	authentication request event interface.
+ * @status: status code, %WLAN_STATUS_SUCCESS for successful authentication,
+ *	use %WLAN_STATUS_UNSPECIFIED_FAILURE if user space cannot give you
+ *	the real status code for failures. Used only for the authentication
+ *	response command interface (user space to driver).
+ * @pmkid: The identifier to refer a PMKSA.
+ */
+struct cfg80211_external_auth_params {
+	enum nl80211_external_auth_action action;
+	u8 bssid[ETH_ALEN] __aligned(2);
+	struct cfg80211_ssid ssid;
+	unsigned int key_mgmt_suite;
+	u16 status;
+	const u8 *pmkid;
+};
+
+/**
+ * struct cfg80211_ftm_responder_stats - FTM responder statistics
+ *
+ * @filled: bitflag of flags using the bits of &enum nl80211_ftm_stats to
+ *	indicate the relevant values in this struct for them
+ * @success_num: number of FTM sessions in which all frames were successfully
+ *	answered
+ * @partial_num: number of FTM sessions in which part of frames were
+ *	successfully answered
+ * @failed_num: number of failed FTM sessions
+ * @asap_num: number of ASAP FTM sessions
+ * @non_asap_num: number of  non-ASAP FTM sessions
+ * @total_duration_ms: total sessions durations - gives an indication
+ *	of how much time the responder was busy
+ * @unknown_triggers_num: number of unknown FTM triggers - triggers from
+ *	initiators that didn't finish successfully the negotiation phase with
+ *	the responder
+ * @reschedule_requests_num: number of FTM reschedule requests - initiator asks
+ *	for a new scheduling although it already has scheduled FTM slot
+ * @out_of_window_triggers_num: total FTM triggers out of scheduled window
+ */
+struct cfg80211_ftm_responder_stats {
+	u32 filled;
+	u32 success_num;
+	u32 partial_num;
+	u32 failed_num;
+	u32 asap_num;
+	u32 non_asap_num;
+	u64 total_duration_ms;
+	u32 unknown_triggers_num;
+	u32 reschedule_requests_num;
+	u32 out_of_window_triggers_num;
+};
+
+/**
+ * struct cfg80211_pmsr_ftm_result - FTM result
+ * @failure_reason: if this measurement failed (PMSR status is
+ *	%NL80211_PMSR_STATUS_FAILURE), this gives a more precise
+ *	reason than just "failure"
+ * @burst_index: if reporting partial results, this is the index
+ *	in [0 .. num_bursts-1] of the burst that's being reported
+ * @num_ftmr_attempts: number of FTM request frames transmitted
+ * @num_ftmr_successes: number of FTM request frames acked
+ * @busy_retry_time: if failure_reason is %NL80211_PMSR_FTM_FAILURE_PEER_BUSY,
+ *	fill this to indicate in how many seconds a retry is deemed possible
+ *	by the responder
+ * @num_bursts_exp: actual number of bursts exponent negotiated
+ * @burst_duration: actual burst duration negotiated
+ * @ftms_per_burst: actual FTMs per burst negotiated
+ * @lci_len: length of LCI information (if present)
+ * @civicloc_len: length of civic location information (if present)
+ * @lci: LCI data (may be %NULL)
+ * @civicloc: civic location data (may be %NULL)
+ * @rssi_avg: average RSSI over FTM action frames reported
+ * @rssi_spread: spread of the RSSI over FTM action frames reported
+ * @tx_rate: bitrate for transmitted FTM action frame response
+ * @rx_rate: bitrate of received FTM action frame
+ * @rtt_avg: average of RTTs measured (must have either this or @dist_avg)
+ * @rtt_variance: variance of RTTs measured (note that standard deviation is
+ *	the square root of the variance)
+ * @rtt_spread: spread of the RTTs measured
+ * @dist_avg: average of distances (mm) measured
+ *	(must have either this or @rtt_avg)
+ * @dist_variance: variance of distances measured (see also @rtt_variance)
+ * @dist_spread: spread of distances measured (see also @rtt_spread)
+ * @num_ftmr_attempts_valid: @num_ftmr_attempts is valid
+ * @num_ftmr_successes_valid: @num_ftmr_successes is valid
+ * @rssi_avg_valid: @rssi_avg is valid
+ * @rssi_spread_valid: @rssi_spread is valid
+ * @tx_rate_valid: @tx_rate is valid
+ * @rx_rate_valid: @rx_rate is valid
+ * @rtt_avg_valid: @rtt_avg is valid
+ * @rtt_variance_valid: @rtt_variance is valid
+ * @rtt_spread_valid: @rtt_spread is valid
+ * @dist_avg_valid: @dist_avg is valid
+ * @dist_variance_valid: @dist_variance is valid
+ * @dist_spread_valid: @dist_spread is valid
+ */
+struct cfg80211_pmsr_ftm_result {
+	const u8 *lci;
+	const u8 *civicloc;
+	unsigned int lci_len;
+	unsigned int civicloc_len;
+	enum nl80211_peer_measurement_ftm_failure_reasons failure_reason;
+	u32 num_ftmr_attempts, num_ftmr_successes;
+	s16 burst_index;
+	u8 busy_retry_time;
+	u8 num_bursts_exp;
+	u8 burst_duration;
+	u8 ftms_per_burst;
+	s32 rssi_avg;
+	s32 rssi_spread;
+	struct rate_info tx_rate, rx_rate;
+	s64 rtt_avg;
+	s64 rtt_variance;
+	s64 rtt_spread;
+	s64 dist_avg;
+	s64 dist_variance;
+	s64 dist_spread;
+
+	u16 num_ftmr_attempts_valid:1,
+	    num_ftmr_successes_valid:1,
+	    rssi_avg_valid:1,
+	    rssi_spread_valid:1,
+	    tx_rate_valid:1,
+	    rx_rate_valid:1,
+	    rtt_avg_valid:1,
+	    rtt_variance_valid:1,
+	    rtt_spread_valid:1,
+	    dist_avg_valid:1,
+	    dist_variance_valid:1,
+	    dist_spread_valid:1;
+};
+
+/**
+ * struct cfg80211_pmsr_result - peer measurement result
+ * @addr: address of the peer
+ * @host_time: host time (use ktime_get_boottime() adjust to the time when the
+ *	measurement was made)
+ * @ap_tsf: AP's TSF at measurement time
+ * @status: status of the measurement
+ * @final: if reporting partial results, mark this as the last one; if not
+ *	reporting partial results always set this flag
+ * @ap_tsf_valid: indicates the @ap_tsf value is valid
+ * @type: type of the measurement reported, note that we only support reporting
+ *	one type at a time, but you can report multiple results separately and
+ *	they're all aggregated for userspace.
+ */
+struct cfg80211_pmsr_result {
+	u64 host_time, ap_tsf;
+	enum nl80211_peer_measurement_status status;
+
+	u8 addr[ETH_ALEN];
+
+	u8 final:1,
+	   ap_tsf_valid:1;
+
+	enum nl80211_peer_measurement_type type;
+
+	union {
+		struct cfg80211_pmsr_ftm_result ftm;
+	};
+};
+
+/**
+ * struct cfg80211_pmsr_ftm_request_peer - FTM request data
+ * @requested: indicates FTM is requested
+ * @preamble: frame preamble to use
+ * @burst_period: burst period to use
+ * @asap: indicates to use ASAP mode
+ * @num_bursts_exp: number of bursts exponent
+ * @burst_duration: burst duration
+ * @ftms_per_burst: number of FTMs per burst
+ * @ftmr_retries: number of retries for FTM request
+ * @request_lci: request LCI information
+ * @request_civicloc: request civic location information
+ *
+ * See also nl80211 for the respective attribute documentation.
+ */
+struct cfg80211_pmsr_ftm_request_peer {
+	enum nl80211_preamble preamble;
+	u16 burst_period;
+	u8 requested:1,
+	   asap:1,
+	   request_lci:1,
+	   request_civicloc:1;
+	u8 num_bursts_exp;
+	u8 burst_duration;
+	u8 ftms_per_burst;
+	u8 ftmr_retries;
+};
+
+/**
+ * struct cfg80211_pmsr_request_peer - peer data for a peer measurement request
+ * @addr: MAC address
+ * @chandef: channel to use
+ * @report_ap_tsf: report the associated AP's TSF
+ * @ftm: FTM data, see &struct cfg80211_pmsr_ftm_request_peer
+ */
+struct cfg80211_pmsr_request_peer {
+	u8 addr[ETH_ALEN];
+	struct cfg80211_chan_def chandef;
+	u8 report_ap_tsf:1;
+	struct cfg80211_pmsr_ftm_request_peer ftm;
+};
+
+/**
+ * struct cfg80211_pmsr_request - peer measurement request
+ * @cookie: cookie, set by cfg80211
+ * @nl_portid: netlink portid - used by cfg80211
+ * @drv_data: driver data for this request, if required for aborting,
+ *	not otherwise freed or anything by cfg80211
+ * @mac_addr: MAC address used for (randomised) request
+ * @mac_addr_mask: MAC address mask used for randomisation, bits that
+ *	are 0 in the mask should be randomised, bits that are 1 should
+ *	be taken from the @mac_addr
+ * @list: used by cfg80211 to hold on to the request
+ * @timeout: timeout (in milliseconds) for the whole operation, if
+ *	zero it means there's no timeout
+ * @n_peers: number of peers to do measurements with
+ * @peers: per-peer measurement request data
+ */
+struct cfg80211_pmsr_request {
+	u64 cookie;
+	void *drv_data;
+	u32 n_peers;
+	u32 nl_portid;
+
+	u32 timeout;
+
+	u8 mac_addr[ETH_ALEN] __aligned(2);
+	u8 mac_addr_mask[ETH_ALEN] __aligned(2);
+
+	struct list_head list;
+
+	struct cfg80211_pmsr_request_peer peers[];
+};
+
+/**
+ * struct cfg80211_update_owe_info - OWE Information
+ *
+ * This structure provides information needed for the drivers to offload OWE
+ * (Opportunistic Wireless Encryption) processing to the user space.
+ *
+ * Commonly used across update_owe_info request and event interfaces.
+ *
+ * @peer: MAC address of the peer device for which the OWE processing
+ *	has to be done.
+ * @status: status code, %WLAN_STATUS_SUCCESS for successful OWE info
+ *	processing, use %WLAN_STATUS_UNSPECIFIED_FAILURE if user space
+ *	cannot give you the real status code for failures. Used only for
+ *	OWE update request command interface (user space to driver).
+ * @ie: IEs obtained from the peer or constructed by the user space. These are
+ *	the IEs of the remote peer in the event from the host driver and
+ *	the constructed IEs by the user space in the request interface.
+ * @ie_len: Length of IEs in octets.
+ */
+struct cfg80211_update_owe_info {
+	u8 peer[ETH_ALEN] __aligned(2);
+	u16 status;
+	const u8 *ie;
+	size_t ie_len;
+};
+
+/**
+ * struct cfg80211_ops - backend description for wireless configuration
+ *
+ * This struct is registered by fullmac card drivers and/or wireless stacks
+ * in order to handle configuration requests on their interfaces.
+ *
+ * All callbacks except where otherwise noted should return 0
+ * on success or a negative error code.
+ *
+ * All operations are currently invoked under rtnl for consistency with the
+ * wireless extensions but this is subject to reevaluation as soon as this
+ * code is used more widely and we have a first user without wext.
+ *
+ * @suspend: wiphy device needs to be suspended. The variable @wow will
+ *	be %NULL or contain the enabled Wake-on-Wireless triggers that are
+ *	configured for the device.
+ * @resume: wiphy device needs to be resumed
+ * @set_wakeup: Called when WoWLAN is enabled/disabled, use this callback
+ *	to call device_set_wakeup_enable() to enable/disable wakeup from
+ *	the device.
+ *
+ * @add_virtual_intf: create a new virtual interface with the given name,
+ *	must set the struct wireless_dev's iftype. Beware: You must create
+ *	the new netdev in the wiphy's network namespace! Returns the struct
+ *	wireless_dev, or an ERR_PTR. For P2P device wdevs, the driver must
+ *	also set the address member in the wdev.
+ *
+ * @del_virtual_intf: remove the virtual interface
+ *
+ * @change_virtual_intf: change type/configuration of virtual interface,
+ *	keep the struct wireless_dev's iftype updated.
+ *
+ * @add_key: add a key with the given parameters. @mac_addr will be %NULL
+ *	when adding a group key.
+ *
+ * @get_key: get information about the key with the given parameters.
+ *	@mac_addr will be %NULL when requesting information for a group
+ *	key. All pointers given to the @callback function need not be valid
+ *	after it returns. This function should return an error if it is
+ *	not possible to retrieve the key, -ENOENT if it doesn't exist.
+ *
+ * @del_key: remove a key given the @mac_addr (%NULL for a group key)
+ *	and @key_index, return -ENOENT if the key doesn't exist.
+ *
+ * @set_default_key: set the default key on an interface
+ *
+ * @set_default_mgmt_key: set the default management frame key on an interface
+
+ * @set_default_beacon_key: set the default Beacon frame key on an interface
+ *
+ * @set_rekey_data: give the data necessary for GTK rekeying to the driver
+ *
+ * @start_ap: Start acting in AP mode defined by the parameters.
+ * @change_beacon: Change the beacon parameters for an access point mode
+ *	interface. This should reject the call when AP mode wasn't started.
+ * @stop_ap: Stop being an AP, including stopping beaconing.
+ *
+ * @add_station: Add a new station.
+ * @del_station: Remove a station
+ * @change_station: Modify a given station. Note that flags changes are not much
+ *	validated in cfg80211, in particular the auth/assoc/authorized flags
+ *	might come to the driver in invalid combinations -- make sure to check
+ *	them, also against the existing state! Drivers must call
+ *	cfg80211_check_station_change() to validate the information.
+ * @get_station: get station information for the station identified by @mac
+ * @dump_station: dump station callback -- resume dump at index @idx
+ *
+ * @add_mpath: add a fixed mesh path
+ * @del_mpath: delete a given mesh path
+ * @change_mpath: change a given mesh path
+ * @get_mpath: get a mesh path for the given parameters
+ * @dump_mpath: dump mesh path callback -- resume dump at index @idx
+ * @get_mpp: get a mesh proxy path for the given parameters
+ * @dump_mpp: dump mesh proxy path callback -- resume dump at index @idx
+ * @join_mesh: join the mesh network with the specified parameters
+ *	(invoked with the wireless_dev mutex held)
+ * @leave_mesh: leave the current mesh network
+ *	(invoked with the wireless_dev mutex held)
+ *
+ * @get_mesh_config: Get the current mesh configuration
+ *
+ * @update_mesh_config: Update mesh parameters on a running mesh.
+ *	The mask is a bitfield which tells us which parameters to
+ *	set, and which to leave alone.
+ *
+ * @change_bss: Modify parameters for a given BSS.
+ *
+ * @set_txq_params: Set TX queue parameters
+ *
+ * @libertas_set_mesh_channel: Only for backward compatibility for libertas,
+ *	as it doesn't implement join_mesh and needs to set the channel to
+ *	join the mesh instead.
+ *
+ * @set_monitor_channel: Set the monitor mode channel for the device. If other
+ *	interfaces are active this callback should reject the configuration.
+ *	If no interfaces are active or the device is down, the channel should
+ *	be stored for when a monitor interface becomes active.
+ *
+ * @scan: Request to do a scan. If returning zero, the scan request is given
+ *	the driver, and will be valid until passed to cfg80211_scan_done().
+ *	For scan results, call cfg80211_inform_bss(); you can call this outside
+ *	the scan/scan_done bracket too.
+ * @abort_scan: Tell the driver to abort an ongoing scan. The driver shall
+ *	indicate the status of the scan through cfg80211_scan_done().
+ *
+ * @auth: Request to authenticate with the specified peer
+ *	(invoked with the wireless_dev mutex held)
+ * @assoc: Request to (re)associate with the specified peer
+ *	(invoked with the wireless_dev mutex held)
+ * @deauth: Request to deauthenticate from the specified peer
+ *	(invoked with the wireless_dev mutex held)
+ * @disassoc: Request to disassociate from the specified peer
+ *	(invoked with the wireless_dev mutex held)
+ *
+ * @connect: Connect to the ESS with the specified parameters. When connected,
+ *	call cfg80211_connect_result()/cfg80211_connect_bss() with status code
+ *	%WLAN_STATUS_SUCCESS. If the connection fails for some reason, call
+ *	cfg80211_connect_result()/cfg80211_connect_bss() with the status code
+ *	from the AP or cfg80211_connect_timeout() if no frame with status code
+ *	was received.
+ *	The driver is allowed to roam to other BSSes within the ESS when the
+ *	other BSS matches the connect parameters. When such roaming is initiated
+ *	by the driver, the driver is expected to verify that the target matches
+ *	the configured security parameters and to use Reassociation Request
+ *	frame instead of Association Request frame.
+ *	The connect function can also be used to request the driver to perform a
+ *	specific roam when connected to an ESS. In that case, the prev_bssid
+ *	parameter is set to the BSSID of the currently associated BSS as an
+ *	indication of requesting reassociation.
+ *	In both the driver-initiated and new connect() call initiated roaming
+ *	cases, the result of roaming is indicated with a call to
+ *	cfg80211_roamed(). (invoked with the wireless_dev mutex held)
+ * @update_connect_params: Update the connect parameters while connected to a
+ *	BSS. The updated parameters can be used by driver/firmware for
+ *	subsequent BSS selection (roaming) decisions and to form the
+ *	Authentication/(Re)Association Request frames. This call does not
+ *	request an immediate disassociation or reassociation with the current
+ *	BSS, i.e., this impacts only subsequent (re)associations. The bits in
+ *	changed are defined in &enum cfg80211_connect_params_changed.
+ *	(invoked with the wireless_dev mutex held)
+ * @disconnect: Disconnect from the BSS/ESS or stop connection attempts if
+ *      connection is in progress. Once done, call cfg80211_disconnected() in
+ *      case connection was already established (invoked with the
+ *      wireless_dev mutex held), otherwise call cfg80211_connect_timeout().
+ *
+ * @join_ibss: Join the specified IBSS (or create if necessary). Once done, call
+ *	cfg80211_ibss_joined(), also call that function when changing BSSID due
+ *	to a merge.
+ *	(invoked with the wireless_dev mutex held)
+ * @leave_ibss: Leave the IBSS.
+ *	(invoked with the wireless_dev mutex held)
+ *
+ * @set_mcast_rate: Set the specified multicast rate (only if vif is in ADHOC or
+ *	MESH mode)
+ *
+ * @set_wiphy_params: Notify that wiphy parameters have changed;
+ *	@changed bitfield (see &enum wiphy_params_flags) describes which values
+ *	have changed. The actual parameter values are available in
+ *	struct wiphy. If returning an error, no value should be changed.
+ *
+ * @set_tx_power: set the transmit power according to the parameters,
+ *	the power passed is in mBm, to get dBm use MBM_TO_DBM(). The
+ *	wdev may be %NULL if power was set for the wiphy, and will
+ *	always be %NULL unless the driver supports per-vif TX power
+ *	(as advertised by the nl80211 feature flag.)
+ * @get_tx_power: store the current TX power into the dbm variable;
+ *	return 0 if successful
+ *
+ * @set_wds_peer: set the WDS peer for a WDS interface
+ *
+ * @rfkill_poll: polls the hw rfkill line, use cfg80211 reporting
+ *	functions to adjust rfkill hw state
+ *
+ * @dump_survey: get site survey information.
+ *
+ * @remain_on_channel: Request the driver to remain awake on the specified
+ *	channel for the specified duration to complete an off-channel
+ *	operation (e.g., public action frame exchange). When the driver is
+ *	ready on the requested channel, it must indicate this with an event
+ *	notification by calling cfg80211_ready_on_channel().
+ * @cancel_remain_on_channel: Cancel an on-going remain-on-channel operation.
+ *	This allows the operation to be terminated prior to timeout based on
+ *	the duration value.
+ * @mgmt_tx: Transmit a management frame.
+ * @mgmt_tx_cancel_wait: Cancel the wait time from transmitting a management
+ *	frame on another channel
+ *
+ * @testmode_cmd: run a test mode command; @wdev may be %NULL
+ * @testmode_dump: Implement a test mode dump. The cb->args[2] and up may be
+ *	used by the function, but 0 and 1 must not be touched. Additionally,
+ *	return error codes other than -ENOBUFS and -ENOENT will terminate the
+ *	dump and return to userspace with an error, so be careful. If any data
+ *	was passed in from userspace then the data/len arguments will be present
+ *	and point to the data contained in %NL80211_ATTR_TESTDATA.
+ *
+ * @set_bitrate_mask: set the bitrate mask configuration
+ *
+ * @set_pmksa: Cache a PMKID for a BSSID. This is mostly useful for fullmac
+ *	devices running firmwares capable of generating the (re) association
+ *	RSN IE. It allows for faster roaming between WPA2 BSSIDs.
+ * @del_pmksa: Delete a cached PMKID.
+ * @flush_pmksa: Flush all cached PMKIDs.
+ * @set_power_mgmt: Configure WLAN power management. A timeout value of -1
+ *	allows the driver to adjust the dynamic ps timeout value.
+ * @set_cqm_rssi_config: Configure connection quality monitor RSSI threshold.
+ *	After configuration, the driver should (soon) send an event indicating
+ *	the current level is above/below the configured threshold; this may
+ *	need some care when the configuration is changed (without first being
+ *	disabled.)
+ * @set_cqm_rssi_range_config: Configure two RSSI thresholds in the
+ *	connection quality monitor.  An event is to be sent only when the
+ *	signal level is found to be outside the two values.  The driver should
+ *	set %NL80211_EXT_FEATURE_CQM_RSSI_LIST if this method is implemented.
+ *	If it is provided then there's no point providing @set_cqm_rssi_config.
+ * @set_cqm_txe_config: Configure connection quality monitor TX error
+ *	thresholds.
+ * @sched_scan_start: Tell the driver to start a scheduled scan.
+ * @sched_scan_stop: Tell the driver to stop an ongoing scheduled scan with
+ *	given request id. This call must stop the scheduled scan and be ready
+ *	for starting a new one before it returns, i.e. @sched_scan_start may be
+ *	called immediately after that again and should not fail in that case.
+ *	The driver should not call cfg80211_sched_scan_stopped() for a requested
+ *	stop (when this method returns 0).
+ *
+ * @mgmt_frame_register: Notify driver that a management frame type was
+ *	registered. The callback is allowed to sleep.
+ *
+ * @set_antenna: Set antenna configuration (tx_ant, rx_ant) on the device.
+ *	Parameters are bitmaps of allowed antennas to use for TX/RX. Drivers may
+ *	reject TX/RX mask combinations they cannot support by returning -EINVAL
+ *	(also see nl80211.h @NL80211_ATTR_WIPHY_ANTENNA_TX).
+ *
+ * @get_antenna: Get current antenna configuration from device (tx_ant, rx_ant).
+ *
+ * @tdls_mgmt: Transmit a TDLS management frame.
+ * @tdls_oper: Perform a high-level TDLS operation (e.g. TDLS link setup).
+ *
+ * @probe_client: probe an associated client, must return a cookie that it
+ *	later passes to cfg80211_probe_status().
+ *
+ * @set_noack_map: Set the NoAck Map for the TIDs.
+ *
+ * @get_channel: Get the current operating channel for the virtual interface.
+ *	For monitor interfaces, it should return %NULL unless there's a single
+ *	current monitoring channel.
+ *
+ * @start_p2p_device: Start the given P2P device.
+ * @stop_p2p_device: Stop the given P2P device.
+ *
+ * @set_mac_acl: Sets MAC address control list in AP and P2P GO mode.
+ *	Parameters include ACL policy, an array of MAC address of stations
+ *	and the number of MAC addresses. If there is already a list in driver
+ *	this new list replaces the existing one. Driver has to clear its ACL
+ *	when number of MAC addresses entries is passed as 0. Drivers which
+ *	advertise the support for MAC based ACL have to implement this callback.
+ *
+ * @start_radar_detection: Start radar detection in the driver.
+ *
+ * @end_cac: End running CAC, probably because a related CAC
+ *	was finished on another phy.
+ *
+ * @update_ft_ies: Provide updated Fast BSS Transition information to the
+ *	driver. If the SME is in the driver/firmware, this information can be
+ *	used in building Authentication and Reassociation Request frames.
+ *
+ * @crit_proto_start: Indicates a critical protocol needs more link reliability
+ *	for a given duration (milliseconds). The protocol is provided so the
+ *	driver can take the most appropriate actions.
+ * @crit_proto_stop: Indicates critical protocol no longer needs increased link
+ *	reliability. This operation can not fail.
+ * @set_coalesce: Set coalesce parameters.
+ *
+ * @channel_switch: initiate channel-switch procedure (with CSA). Driver is
+ *	responsible for veryfing if the switch is possible. Since this is
+ *	inherently tricky driver may decide to disconnect an interface later
+ *	with cfg80211_stop_iface(). This doesn't mean driver can accept
+ *	everything. It should do it's best to verify requests and reject them
+ *	as soon as possible.
+ *
+ * @set_qos_map: Set QoS mapping information to the driver
+ *
+ * @set_ap_chanwidth: Set the AP (including P2P GO) mode channel width for the
+ *	given interface This is used e.g. for dynamic HT 20/40 MHz channel width
+ *	changes during the lifetime of the BSS.
+ *
+ * @add_tx_ts: validate (if admitted_time is 0) or add a TX TS to the device
+ *	with the given parameters; action frame exchange has been handled by
+ *	userspace so this just has to modify the TX path to take the TS into
+ *	account.
+ *	If the admitted time is 0 just validate the parameters to make sure
+ *	the session can be created at all; it is valid to just always return
+ *	success for that but that may result in inefficient behaviour (handshake
+ *	with the peer followed by immediate teardown when the addition is later
+ *	rejected)
+ * @del_tx_ts: remove an existing TX TS
+ *
+ * @join_ocb: join the OCB network with the specified parameters
+ *	(invoked with the wireless_dev mutex held)
+ * @leave_ocb: leave the current OCB network
+ *	(invoked with the wireless_dev mutex held)
+ *
+ * @tdls_channel_switch: Start channel-switching with a TDLS peer. The driver
+ *	is responsible for continually initiating channel-switching operations
+ *	and returning to the base channel for communication with the AP.
+ * @tdls_cancel_channel_switch: Stop channel-switching with a TDLS peer. Both
+ *	peers must be on the base channel when the call completes.
+ * @start_nan: Start the NAN interface.
+ * @stop_nan: Stop the NAN interface.
+ * @add_nan_func: Add a NAN function. Returns negative value on failure.
+ *	On success @nan_func ownership is transferred to the driver and
+ *	it may access it outside of the scope of this function. The driver
+ *	should free the @nan_func when no longer needed by calling
+ *	cfg80211_free_nan_func().
+ *	On success the driver should assign an instance_id in the
+ *	provided @nan_func.
+ * @del_nan_func: Delete a NAN function.
+ * @nan_change_conf: changes NAN configuration. The changed parameters must
+ *	be specified in @changes (using &enum cfg80211_nan_conf_changes);
+ *	All other parameters must be ignored.
+ *
+ * @set_multicast_to_unicast: configure multicast to unicast conversion for BSS
+ *
+ * @get_txq_stats: Get TXQ stats for interface or phy. If wdev is %NULL, this
+ *      function should return phy stats, and interface stats otherwise.
+ *
+ * @set_pmk: configure the PMK to be used for offloaded 802.1X 4-Way handshake.
+ *	If not deleted through @del_pmk the PMK remains valid until disconnect
+ *	upon which the driver should clear it.
+ *	(invoked with the wireless_dev mutex held)
+ * @del_pmk: delete the previously configured PMK for the given authenticator.
+ *	(invoked with the wireless_dev mutex held)
+ *
+ * @external_auth: indicates result of offloaded authentication processing from
+ *     user space
+ *
+ * @tx_control_port: TX a control port frame (EAPoL).  The noencrypt parameter
+ *	tells the driver that the frame should not be encrypted.
+ *
+ * @get_ftm_responder_stats: Retrieve FTM responder statistics, if available.
+ *	Statistics should be cumulative, currently no way to reset is provided.
+ * @start_pmsr: start peer measurement (e.g. FTM)
+ * @abort_pmsr: abort peer measurement
+ *
+ * @update_owe_info: Provide updated OWE info to driver. Driver implementing SME
+ *	but offloading OWE processing to the user space will get the updated
+ *	DH IE through this interface.
+ *
+ * @probe_mesh_link: Probe direct Mesh peer's link quality by sending data frame
+ *	and overrule HWMP path selection algorithm.
+ * @set_tid_config: TID specific configuration, this can be peer or BSS specific
+ *	This callback may sleep.
+ * @reset_tid_config: Reset TID specific configuration for the peer, for the
+ *	given TIDs. This callback may sleep.
+ */
+struct cfg80211_ops {
+	int	(*suspend)(struct wiphy *wiphy, struct cfg80211_wowlan *wow);
+	int	(*resume)(struct wiphy *wiphy);
+	void	(*set_wakeup)(struct wiphy *wiphy, bool enabled);
+
+	struct wireless_dev * (*add_virtual_intf)(struct wiphy *wiphy,
+						  const char *name,
+						  unsigned char name_assign_type,
+						  enum nl80211_iftype type,
+						  struct vif_params *params);
+	int	(*del_virtual_intf)(struct wiphy *wiphy,
+				    struct wireless_dev *wdev);
+	int	(*change_virtual_intf)(struct wiphy *wiphy,
+				       struct net_device *dev,
+				       enum nl80211_iftype type,
+				       struct vif_params *params);
+
+	int	(*add_key)(struct wiphy *wiphy, struct net_device *netdev,
+			   u8 key_index, bool pairwise, const u8 *mac_addr,
+			   struct key_params *params);
+	int	(*get_key)(struct wiphy *wiphy, struct net_device *netdev,
+			   u8 key_index, bool pairwise, const u8 *mac_addr,
+			   void *cookie,
+			   void (*callback)(void *cookie, struct key_params*));
+	int	(*del_key)(struct wiphy *wiphy, struct net_device *netdev,
+			   u8 key_index, bool pairwise, const u8 *mac_addr);
+	int	(*set_default_key)(struct wiphy *wiphy,
+				   struct net_device *netdev,
+				   u8 key_index, bool unicast, bool multicast);
+	int	(*set_default_mgmt_key)(struct wiphy *wiphy,
+					struct net_device *netdev,
+					u8 key_index);
+	int	(*set_default_beacon_key)(struct wiphy *wiphy,
+					  struct net_device *netdev,
+					  u8 key_index);
+
+	int	(*start_ap)(struct wiphy *wiphy, struct net_device *dev,
+			    struct cfg80211_ap_settings *settings);
+	int	(*change_beacon)(struct wiphy *wiphy, struct net_device *dev,
+				 struct cfg80211_beacon_data *info);
+	int	(*stop_ap)(struct wiphy *wiphy, struct net_device *dev);
+
+
+	int	(*add_station)(struct wiphy *wiphy, struct net_device *dev,
+			       const u8 *mac,
+			       struct station_parameters *params);
+	int	(*del_station)(struct wiphy *wiphy, struct net_device *dev,
+			       struct station_del_parameters *params);
+	int	(*change_station)(struct wiphy *wiphy, struct net_device *dev,
+				  const u8 *mac,
+				  struct station_parameters *params);
+	int	(*get_station)(struct wiphy *wiphy, struct net_device *dev,
+			       const u8 *mac, struct station_info *sinfo);
+	int	(*dump_station)(struct wiphy *wiphy, struct net_device *dev,
+				int idx, u8 *mac, struct station_info *sinfo);
+
+	int	(*add_mpath)(struct wiphy *wiphy, struct net_device *dev,
+			       const u8 *dst, const u8 *next_hop);
+	int	(*del_mpath)(struct wiphy *wiphy, struct net_device *dev,
+			       const u8 *dst);
+	int	(*change_mpath)(struct wiphy *wiphy, struct net_device *dev,
+				  const u8 *dst, const u8 *next_hop);
+	int	(*get_mpath)(struct wiphy *wiphy, struct net_device *dev,
+			     u8 *dst, u8 *next_hop, struct mpath_info *pinfo);
+	int	(*dump_mpath)(struct wiphy *wiphy, struct net_device *dev,
+			      int idx, u8 *dst, u8 *next_hop,
+			      struct mpath_info *pinfo);
+	int	(*get_mpp)(struct wiphy *wiphy, struct net_device *dev,
+			   u8 *dst, u8 *mpp, struct mpath_info *pinfo);
+	int	(*dump_mpp)(struct wiphy *wiphy, struct net_device *dev,
+			    int idx, u8 *dst, u8 *mpp,
+			    struct mpath_info *pinfo);
+	int	(*get_mesh_config)(struct wiphy *wiphy,
+				struct net_device *dev,
+				struct mesh_config *conf);
+	int	(*update_mesh_config)(struct wiphy *wiphy,
+				      struct net_device *dev, u32 mask,
+				      const struct mesh_config *nconf);
+	int	(*join_mesh)(struct wiphy *wiphy, struct net_device *dev,
+			     const struct mesh_config *conf,
+			     const struct mesh_setup *setup);
+	int	(*leave_mesh)(struct wiphy *wiphy, struct net_device *dev);
+
+	int	(*join_ocb)(struct wiphy *wiphy, struct net_device *dev,
+			    struct ocb_setup *setup);
+	int	(*leave_ocb)(struct wiphy *wiphy, struct net_device *dev);
+
+	int	(*change_bss)(struct wiphy *wiphy, struct net_device *dev,
+			      struct bss_parameters *params);
+
+	int	(*set_txq_params)(struct wiphy *wiphy, struct net_device *dev,
+				  struct ieee80211_txq_params *params);
+
+	int	(*libertas_set_mesh_channel)(struct wiphy *wiphy,
+					     struct net_device *dev,
+					     struct ieee80211_channel *chan);
+
+	int	(*set_monitor_channel)(struct wiphy *wiphy,
+				       struct cfg80211_chan_def *chandef);
+
+	int	(*scan)(struct wiphy *wiphy,
+			struct cfg80211_scan_request *request);
+	void	(*abort_scan)(struct wiphy *wiphy, struct wireless_dev *wdev);
+
+	int	(*auth)(struct wiphy *wiphy, struct net_device *dev,
+			struct cfg80211_auth_request *req);
+	int	(*assoc)(struct wiphy *wiphy, struct net_device *dev,
+			 struct cfg80211_assoc_request *req);
+	int	(*deauth)(struct wiphy *wiphy, struct net_device *dev,
+			  struct cfg80211_deauth_request *req);
+	int	(*disassoc)(struct wiphy *wiphy, struct net_device *dev,
+			    struct cfg80211_disassoc_request *req);
+
+	int	(*connect)(struct wiphy *wiphy, struct net_device *dev,
+			   struct cfg80211_connect_params *sme);
+	int	(*update_connect_params)(struct wiphy *wiphy,
+					 struct net_device *dev,
+					 struct cfg80211_connect_params *sme,
+					 u32 changed);
+	int	(*disconnect)(struct wiphy *wiphy, struct net_device *dev,
+			      u16 reason_code);
+
+	int	(*join_ibss)(struct wiphy *wiphy, struct net_device *dev,
+			     struct cfg80211_ibss_params *params);
+	int	(*leave_ibss)(struct wiphy *wiphy, struct net_device *dev);
+
+	int	(*set_mcast_rate)(struct wiphy *wiphy, struct net_device *dev,
+				  int rate[NUM_NL80211_BANDS]);
+
+	int	(*set_wiphy_params)(struct wiphy *wiphy, u32 changed);
+
+	int	(*set_tx_power)(struct wiphy *wiphy, struct wireless_dev *wdev,
+				enum nl80211_tx_power_setting type, int mbm);
+	int	(*get_tx_power)(struct wiphy *wiphy, struct wireless_dev *wdev,
+				int *dbm);
+
+	int	(*set_wds_peer)(struct wiphy *wiphy, struct net_device *dev,
+				const u8 *addr);
+
+	void	(*rfkill_poll)(struct wiphy *wiphy);
+
+#ifdef CONFIG_NL80211_TESTMODE
+	int	(*testmode_cmd)(struct wiphy *wiphy, struct wireless_dev *wdev,
+				void *data, int len);
+	int	(*testmode_dump)(struct wiphy *wiphy, struct sk_buff *skb,
+				 struct netlink_callback *cb,
+				 void *data, int len);
+#endif
+
+	int	(*set_bitrate_mask)(struct wiphy *wiphy,
+				    struct net_device *dev,
+				    const u8 *peer,
+				    const struct cfg80211_bitrate_mask *mask);
+
+	int	(*dump_survey)(struct wiphy *wiphy, struct net_device *netdev,
+			int idx, struct survey_info *info);
+
+	int	(*set_pmksa)(struct wiphy *wiphy, struct net_device *netdev,
+			     struct cfg80211_pmksa *pmksa);
+	int	(*del_pmksa)(struct wiphy *wiphy, struct net_device *netdev,
+			     struct cfg80211_pmksa *pmksa);
+	int	(*flush_pmksa)(struct wiphy *wiphy, struct net_device *netdev);
+
+	int	(*remain_on_channel)(struct wiphy *wiphy,
+				     struct wireless_dev *wdev,
+				     struct ieee80211_channel *chan,
+				     unsigned int duration,
+				     u64 *cookie);
+	int	(*cancel_remain_on_channel)(struct wiphy *wiphy,
+					    struct wireless_dev *wdev,
+					    u64 cookie);
+
+	int	(*mgmt_tx)(struct wiphy *wiphy, struct wireless_dev *wdev,
+			   struct cfg80211_mgmt_tx_params *params,
+			   u64 *cookie);
+	int	(*mgmt_tx_cancel_wait)(struct wiphy *wiphy,
+				       struct wireless_dev *wdev,
+				       u64 cookie);
+
+	int	(*set_power_mgmt)(struct wiphy *wiphy, struct net_device *dev,
+				  bool enabled, int timeout);
+
+	int	(*set_cqm_rssi_config)(struct wiphy *wiphy,
+				       struct net_device *dev,
+				       s32 rssi_thold, u32 rssi_hyst);
+
+	int	(*set_cqm_rssi_range_config)(struct wiphy *wiphy,
+					     struct net_device *dev,
+					     s32 rssi_low, s32 rssi_high);
+
+	int	(*set_cqm_txe_config)(struct wiphy *wiphy,
+				      struct net_device *dev,
+				      u32 rate, u32 pkts, u32 intvl);
+
+	void	(*mgmt_frame_register)(struct wiphy *wiphy,
+				       struct wireless_dev *wdev,
+				       u16 frame_type, bool reg);
+
+	int	(*set_antenna)(struct wiphy *wiphy, u32 tx_ant, u32 rx_ant);
+	int	(*get_antenna)(struct wiphy *wiphy, u32 *tx_ant, u32 *rx_ant);
+
+	int	(*sched_scan_start)(struct wiphy *wiphy,
+				struct net_device *dev,
+				struct cfg80211_sched_scan_request *request);
+	int	(*sched_scan_stop)(struct wiphy *wiphy, struct net_device *dev,
+				   u64 reqid);
+
+	int	(*set_rekey_data)(struct wiphy *wiphy, struct net_device *dev,
+				  struct cfg80211_gtk_rekey_data *data);
+
+	int	(*tdls_mgmt)(struct wiphy *wiphy, struct net_device *dev,
+			     const u8 *peer, u8 action_code,  u8 dialog_token,
+			     u16 status_code, u32 peer_capability,
+			     bool initiator, const u8 *buf, size_t len);
+	int	(*tdls_oper)(struct wiphy *wiphy, struct net_device *dev,
+			     const u8 *peer, enum nl80211_tdls_operation oper);
+
+	int	(*probe_client)(struct wiphy *wiphy, struct net_device *dev,
+				const u8 *peer, u64 *cookie);
+
+	int	(*set_noack_map)(struct wiphy *wiphy,
+				  struct net_device *dev,
+				  u16 noack_map);
+
+	int	(*get_channel)(struct wiphy *wiphy,
+			       struct wireless_dev *wdev,
+			       struct cfg80211_chan_def *chandef);
+
+	int	(*start_p2p_device)(struct wiphy *wiphy,
+				    struct wireless_dev *wdev);
+	void	(*stop_p2p_device)(struct wiphy *wiphy,
+				   struct wireless_dev *wdev);
+
+	int	(*set_mac_acl)(struct wiphy *wiphy, struct net_device *dev,
+			       const struct cfg80211_acl_data *params);
+
+	int	(*start_radar_detection)(struct wiphy *wiphy,
+					 struct net_device *dev,
+					 struct cfg80211_chan_def *chandef,
+					 u32 cac_time_ms);
+	void	(*end_cac)(struct wiphy *wiphy,
+				struct net_device *dev);
+	int	(*update_ft_ies)(struct wiphy *wiphy, struct net_device *dev,
+				 struct cfg80211_update_ft_ies_params *ftie);
+	int	(*crit_proto_start)(struct wiphy *wiphy,
+				    struct wireless_dev *wdev,
+				    enum nl80211_crit_proto_id protocol,
+				    u16 duration);
+	void	(*crit_proto_stop)(struct wiphy *wiphy,
+				   struct wireless_dev *wdev);
+	int	(*set_coalesce)(struct wiphy *wiphy,
+				struct cfg80211_coalesce *coalesce);
+
+	int	(*channel_switch)(struct wiphy *wiphy,
+				  struct net_device *dev,
+				  struct cfg80211_csa_settings *params);
+
+	int     (*set_qos_map)(struct wiphy *wiphy,
+			       struct net_device *dev,
+			       struct cfg80211_qos_map *qos_map);
+
+	int	(*set_ap_chanwidth)(struct wiphy *wiphy, struct net_device *dev,
+				    struct cfg80211_chan_def *chandef);
+
+	int	(*add_tx_ts)(struct wiphy *wiphy, struct net_device *dev,
+			     u8 tsid, const u8 *peer, u8 user_prio,
+			     u16 admitted_time);
+	int	(*del_tx_ts)(struct wiphy *wiphy, struct net_device *dev,
+			     u8 tsid, const u8 *peer);
+
+	int	(*tdls_channel_switch)(struct wiphy *wiphy,
+				       struct net_device *dev,
+				       const u8 *addr, u8 oper_class,
+				       struct cfg80211_chan_def *chandef);
+	void	(*tdls_cancel_channel_switch)(struct wiphy *wiphy,
+					      struct net_device *dev,
+					      const u8 *addr);
+	int	(*start_nan)(struct wiphy *wiphy, struct wireless_dev *wdev,
+			     struct cfg80211_nan_conf *conf);
+	void	(*stop_nan)(struct wiphy *wiphy, struct wireless_dev *wdev);
+	int	(*add_nan_func)(struct wiphy *wiphy, struct wireless_dev *wdev,
+				struct cfg80211_nan_func *nan_func);
+	void	(*del_nan_func)(struct wiphy *wiphy, struct wireless_dev *wdev,
+			       u64 cookie);
+	int	(*nan_change_conf)(struct wiphy *wiphy,
+				   struct wireless_dev *wdev,
+				   struct cfg80211_nan_conf *conf,
+				   u32 changes);
+
+	int	(*set_multicast_to_unicast)(struct wiphy *wiphy,
+					    struct net_device *dev,
+					    const bool enabled);
+
+	int	(*get_txq_stats)(struct wiphy *wiphy,
+				 struct wireless_dev *wdev,
+				 struct cfg80211_txq_stats *txqstats);
+
+	int	(*set_pmk)(struct wiphy *wiphy, struct net_device *dev,
+			   const struct cfg80211_pmk_conf *conf);
+	int	(*del_pmk)(struct wiphy *wiphy, struct net_device *dev,
+			   const u8 *aa);
+	int     (*external_auth)(struct wiphy *wiphy, struct net_device *dev,
+				 struct cfg80211_external_auth_params *params);
+
+	int	(*tx_control_port)(struct wiphy *wiphy,
+				   struct net_device *dev,
+				   const u8 *buf, size_t len,
+				   const u8 *dest, const __be16 proto,
+				   const bool noencrypt);
+
+	int	(*get_ftm_responder_stats)(struct wiphy *wiphy,
+				struct net_device *dev,
+				struct cfg80211_ftm_responder_stats *ftm_stats);
+
+	int	(*start_pmsr)(struct wiphy *wiphy, struct wireless_dev *wdev,
+			      struct cfg80211_pmsr_request *request);
+	void	(*abort_pmsr)(struct wiphy *wiphy, struct wireless_dev *wdev,
+			      struct cfg80211_pmsr_request *request);
+	int	(*update_owe_info)(struct wiphy *wiphy, struct net_device *dev,
+				   struct cfg80211_update_owe_info *owe_info);
+	int	(*probe_mesh_link)(struct wiphy *wiphy, struct net_device *dev,
+				   const u8 *buf, size_t len);
+	int     (*set_tid_config)(struct wiphy *wiphy, struct net_device *dev,
+				  struct cfg80211_tid_config *tid_conf);
+	int	(*reset_tid_config)(struct wiphy *wiphy, struct net_device *dev,
+				    const u8 *peer, u8 tids);
+};
+
+/*
+ * wireless hardware and networking interfaces structures
+ * and registration/helper functions
+ */
+
+/**
+ * enum wiphy_flags - wiphy capability flags
+ *
+ * @WIPHY_FLAG_NETNS_OK: if not set, do not allow changing the netns of this
+ *	wiphy at all
+ * @WIPHY_FLAG_PS_ON_BY_DEFAULT: if set to true, powersave will be enabled
+ *	by default -- this flag will be set depending on the kernel's default
+ *	on wiphy_new(), but can be changed by the driver if it has a good
+ *	reason to override the default
+ * @WIPHY_FLAG_4ADDR_AP: supports 4addr mode even on AP (with a single station
+ *	on a VLAN interface). This flag also serves an extra purpose of
+ *	supporting 4ADDR AP mode on devices which do not support AP/VLAN iftype.
+ * @WIPHY_FLAG_4ADDR_STATION: supports 4addr mode even as a station
+ * @WIPHY_FLAG_CONTROL_PORT_PROTOCOL: This device supports setting the
+ *	control port protocol ethertype. The device also honours the
+ *	control_port_no_encrypt flag.
+ * @WIPHY_FLAG_IBSS_RSN: The device supports IBSS RSN.
+ * @WIPHY_FLAG_MESH_AUTH: The device supports mesh authentication by routing
+ *	auth frames to userspace. See @NL80211_MESH_SETUP_USERSPACE_AUTH.
+ * @WIPHY_FLAG_SUPPORTS_FW_ROAM: The device supports roaming feature in the
+ *	firmware.
+ * @WIPHY_FLAG_AP_UAPSD: The device supports uapsd on AP.
+ * @WIPHY_FLAG_SUPPORTS_TDLS: The device supports TDLS (802.11z) operation.
+ * @WIPHY_FLAG_TDLS_EXTERNAL_SETUP: The device does not handle TDLS (802.11z)
+ *	link setup/discovery operations internally. Setup, discovery and
+ *	teardown packets should be sent through the @NL80211_CMD_TDLS_MGMT
+ *	command. When this flag is not set, @NL80211_CMD_TDLS_OPER should be
+ *	used for asking the driver/firmware to perform a TDLS operation.
+ * @WIPHY_FLAG_HAVE_AP_SME: device integrates AP SME
+ * @WIPHY_FLAG_REPORTS_OBSS: the device will report beacons from other BSSes
+ *	when there are virtual interfaces in AP mode by calling
+ *	cfg80211_report_obss_beacon().
+ * @WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD: When operating as an AP, the device
+ *	responds to probe-requests in hardware.
+ * @WIPHY_FLAG_OFFCHAN_TX: Device supports direct off-channel TX.
+ * @WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL: Device supports remain-on-channel call.
+ * @WIPHY_FLAG_SUPPORTS_5_10_MHZ: Device supports 5 MHz and 10 MHz channels.
+ * @WIPHY_FLAG_HAS_CHANNEL_SWITCH: Device supports channel switch in
+ *	beaconing mode (AP, IBSS, Mesh, ...).
+ * @WIPHY_FLAG_HAS_STATIC_WEP: The device supports static WEP key installation
+ *	before connection.
+ */
+enum wiphy_flags {
+	/* use hole at 0 */
+	/* use hole at 1 */
+	/* use hole at 2 */
+	WIPHY_FLAG_NETNS_OK			= BIT(3),
+	WIPHY_FLAG_PS_ON_BY_DEFAULT		= BIT(4),
+	WIPHY_FLAG_4ADDR_AP			= BIT(5),
+	WIPHY_FLAG_4ADDR_STATION		= BIT(6),
+	WIPHY_FLAG_CONTROL_PORT_PROTOCOL	= BIT(7),
+	WIPHY_FLAG_IBSS_RSN			= BIT(8),
+	WIPHY_FLAG_MESH_AUTH			= BIT(10),
+	/* use hole at 11 */
+	/* use hole at 12 */
+	WIPHY_FLAG_SUPPORTS_FW_ROAM		= BIT(13),
+	WIPHY_FLAG_AP_UAPSD			= BIT(14),
+	WIPHY_FLAG_SUPPORTS_TDLS		= BIT(15),
+	WIPHY_FLAG_TDLS_EXTERNAL_SETUP		= BIT(16),
+	WIPHY_FLAG_HAVE_AP_SME			= BIT(17),
+	WIPHY_FLAG_REPORTS_OBSS			= BIT(18),
+	WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD	= BIT(19),
+	WIPHY_FLAG_OFFCHAN_TX			= BIT(20),
+	WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL	= BIT(21),
+	WIPHY_FLAG_SUPPORTS_5_10_MHZ		= BIT(22),
+	WIPHY_FLAG_HAS_CHANNEL_SWITCH		= BIT(23),
+	WIPHY_FLAG_HAS_STATIC_WEP		= BIT(24),
+};
+
+/**
+ * struct ieee80211_iface_limit - limit on certain interface types
+ * @max: maximum number of interfaces of these types
+ * @types: interface types (bits)
+ */
+struct ieee80211_iface_limit {
+	u16 max;
+	u16 types;
+};
+
+/**
+ * struct ieee80211_iface_combination - possible interface combination
+ *
+ * With this structure the driver can describe which interface
+ * combinations it supports concurrently.
+ *
+ * Examples:
+ *
+ * 1. Allow #STA <= 1, #AP <= 1, matching BI, channels = 1, 2 total:
+ *
+ *    .. code-block:: c
+ *
+ *	struct ieee80211_iface_limit limits1[] = {
+ *		{ .max = 1, .types = BIT(NL80211_IFTYPE_STATION), },
+ *		{ .max = 1, .types = BIT(NL80211_IFTYPE_AP}, },
+ *	};
+ *	struct ieee80211_iface_combination combination1 = {
+ *		.limits = limits1,
+ *		.n_limits = ARRAY_SIZE(limits1),
+ *		.max_interfaces = 2,
+ *		.beacon_int_infra_match = true,
+ *	};
+ *
+ *
+ * 2. Allow #{AP, P2P-GO} <= 8, channels = 1, 8 total:
+ *
+ *    .. code-block:: c
+ *
+ *	struct ieee80211_iface_limit limits2[] = {
+ *		{ .max = 8, .types = BIT(NL80211_IFTYPE_AP) |
+ *				     BIT(NL80211_IFTYPE_P2P_GO), },
+ *	};
+ *	struct ieee80211_iface_combination combination2 = {
+ *		.limits = limits2,
+ *		.n_limits = ARRAY_SIZE(limits2),
+ *		.max_interfaces = 8,
+ *		.num_different_channels = 1,
+ *	};
+ *
+ *
+ * 3. Allow #STA <= 1, #{P2P-client,P2P-GO} <= 3 on two channels, 4 total.
+ *
+ *    This allows for an infrastructure connection and three P2P connections.
+ *
+ *    .. code-block:: c
+ *
+ *	struct ieee80211_iface_limit limits3[] = {
+ *		{ .max = 1, .types = BIT(NL80211_IFTYPE_STATION), },
+ *		{ .max = 3, .types = BIT(NL80211_IFTYPE_P2P_GO) |
+ *				     BIT(NL80211_IFTYPE_P2P_CLIENT), },
+ *	};
+ *	struct ieee80211_iface_combination combination3 = {
+ *		.limits = limits3,
+ *		.n_limits = ARRAY_SIZE(limits3),
+ *		.max_interfaces = 4,
+ *		.num_different_channels = 2,
+ *	};
+ *
+ */
+struct ieee80211_iface_combination {
+	/**
+	 * @limits:
+	 * limits for the given interface types
+	 */
+	const struct ieee80211_iface_limit *limits;
+
+	/**
+	 * @num_different_channels:
+	 * can use up to this many different channels
+	 */
+	u32 num_different_channels;
+
+	/**
+	 * @max_interfaces:
+	 * maximum number of interfaces in total allowed in this group
+	 */
+	u16 max_interfaces;
+
+	/**
+	 * @n_limits:
+	 * number of limitations
+	 */
+	u8 n_limits;
+
+	/**
+	 * @beacon_int_infra_match:
+	 * In this combination, the beacon intervals between infrastructure
+	 * and AP types must match. This is required only in special cases.
+	 */
+	bool beacon_int_infra_match;
+
+	/**
+	 * @radar_detect_widths:
+	 * bitmap of channel widths supported for radar detection
+	 */
+	u8 radar_detect_widths;
+
+	/**
+	 * @radar_detect_regions:
+	 * bitmap of regions supported for radar detection
+	 */
+	u8 radar_detect_regions;
+
+	/**
+	 * @beacon_int_min_gcd:
+	 * This interface combination supports different beacon intervals.
+	 *
+	 * = 0
+	 *   all beacon intervals for different interface must be same.
+	 * > 0
+	 *   any beacon interval for the interface part of this combination AND
+	 *   GCD of all beacon intervals from beaconing interfaces of this
+	 *   combination must be greater or equal to this value.
+	 */
+	u32 beacon_int_min_gcd;
+};
+
+struct ieee80211_txrx_stypes {
+	u16 tx, rx;
+};
+
+/**
+ * enum wiphy_wowlan_support_flags - WoWLAN support flags
+ * @WIPHY_WOWLAN_ANY: supports wakeup for the special "any"
+ *	trigger that keeps the device operating as-is and
+ *	wakes up the host on any activity, for example a
+ *	received packet that passed filtering; note that the
+ *	packet should be preserved in that case
+ * @WIPHY_WOWLAN_MAGIC_PKT: supports wakeup on magic packet
+ *	(see nl80211.h)
+ * @WIPHY_WOWLAN_DISCONNECT: supports wakeup on disconnect
+ * @WIPHY_WOWLAN_SUPPORTS_GTK_REKEY: supports GTK rekeying while asleep
+ * @WIPHY_WOWLAN_GTK_REKEY_FAILURE: supports wakeup on GTK rekey failure
+ * @WIPHY_WOWLAN_EAP_IDENTITY_REQ: supports wakeup on EAP identity request
+ * @WIPHY_WOWLAN_4WAY_HANDSHAKE: supports wakeup on 4-way handshake failure
+ * @WIPHY_WOWLAN_RFKILL_RELEASE: supports wakeup on RF-kill release
+ * @WIPHY_WOWLAN_NET_DETECT: supports wakeup on network detection
+ */
+enum wiphy_wowlan_support_flags {
+	WIPHY_WOWLAN_ANY		= BIT(0),
+	WIPHY_WOWLAN_MAGIC_PKT		= BIT(1),
+	WIPHY_WOWLAN_DISCONNECT		= BIT(2),
+	WIPHY_WOWLAN_SUPPORTS_GTK_REKEY	= BIT(3),
+	WIPHY_WOWLAN_GTK_REKEY_FAILURE	= BIT(4),
+	WIPHY_WOWLAN_EAP_IDENTITY_REQ	= BIT(5),
+	WIPHY_WOWLAN_4WAY_HANDSHAKE	= BIT(6),
+	WIPHY_WOWLAN_RFKILL_RELEASE	= BIT(7),
+	WIPHY_WOWLAN_NET_DETECT		= BIT(8),
+};
+
+struct wiphy_wowlan_tcp_support {
+	const struct nl80211_wowlan_tcp_data_token_feature *tok;
+	u32 data_payload_max;
+	u32 data_interval_max;
+	u32 wake_payload_max;
+	bool seq;
+};
+
+/**
+ * struct wiphy_wowlan_support - WoWLAN support data
+ * @flags: see &enum wiphy_wowlan_support_flags
+ * @n_patterns: number of supported wakeup patterns
+ *	(see nl80211.h for the pattern definition)
+ * @pattern_max_len: maximum length of each pattern
+ * @pattern_min_len: minimum length of each pattern
+ * @max_pkt_offset: maximum Rx packet offset
+ * @max_nd_match_sets: maximum number of matchsets for net-detect,
+ *	similar, but not necessarily identical, to max_match_sets for
+ *	scheduled scans.
+ *	See &struct cfg80211_sched_scan_request.@match_sets for more
+ *	details.
+ * @tcp: TCP wakeup support information
+ */
+struct wiphy_wowlan_support {
+	u32 flags;
+	int n_patterns;
+	int pattern_max_len;
+	int pattern_min_len;
+	int max_pkt_offset;
+	int max_nd_match_sets;
+	const struct wiphy_wowlan_tcp_support *tcp;
+};
+
+/**
+ * struct wiphy_coalesce_support - coalesce support data
+ * @n_rules: maximum number of coalesce rules
+ * @max_delay: maximum supported coalescing delay in msecs
+ * @n_patterns: number of supported patterns in a rule
+ *	(see nl80211.h for the pattern definition)
+ * @pattern_max_len: maximum length of each pattern
+ * @pattern_min_len: minimum length of each pattern
+ * @max_pkt_offset: maximum Rx packet offset
+ */
+struct wiphy_coalesce_support {
+	int n_rules;
+	int max_delay;
+	int n_patterns;
+	int pattern_max_len;
+	int pattern_min_len;
+	int max_pkt_offset;
+};
+
+/**
+ * enum wiphy_vendor_command_flags - validation flags for vendor commands
+ * @WIPHY_VENDOR_CMD_NEED_WDEV: vendor command requires wdev
+ * @WIPHY_VENDOR_CMD_NEED_NETDEV: vendor command requires netdev
+ * @WIPHY_VENDOR_CMD_NEED_RUNNING: interface/wdev must be up & running
+ *	(must be combined with %_WDEV or %_NETDEV)
+ */
+enum wiphy_vendor_command_flags {
+	WIPHY_VENDOR_CMD_NEED_WDEV = BIT(0),
+	WIPHY_VENDOR_CMD_NEED_NETDEV = BIT(1),
+	WIPHY_VENDOR_CMD_NEED_RUNNING = BIT(2),
+};
+
+/**
+ * enum wiphy_opmode_flag - Station's ht/vht operation mode information flags
+ *
+ * @STA_OPMODE_MAX_BW_CHANGED: Max Bandwidth changed
+ * @STA_OPMODE_SMPS_MODE_CHANGED: SMPS mode changed
+ * @STA_OPMODE_N_SS_CHANGED: max N_SS (number of spatial streams) changed
+ *
+ */
+enum wiphy_opmode_flag {
+	STA_OPMODE_MAX_BW_CHANGED	= BIT(0),
+	STA_OPMODE_SMPS_MODE_CHANGED	= BIT(1),
+	STA_OPMODE_N_SS_CHANGED		= BIT(2),
+};
+
+/**
+ * struct sta_opmode_info - Station's ht/vht operation mode information
+ * @changed: contains value from &enum wiphy_opmode_flag
+ * @smps_mode: New SMPS mode value from &enum nl80211_smps_mode of a station
+ * @bw: new max bandwidth value from &enum nl80211_chan_width of a station
+ * @rx_nss: new rx_nss value of a station
+ */
+
+struct sta_opmode_info {
+	u32 changed;
+	enum nl80211_smps_mode smps_mode;
+	enum nl80211_chan_width bw;
+	u8 rx_nss;
+};
+
+#define VENDOR_CMD_RAW_DATA ((const struct nla_policy *)(long)(-ENODATA))
+
+/**
+ * struct wiphy_vendor_command - vendor command definition
+ * @info: vendor command identifying information, as used in nl80211
+ * @flags: flags, see &enum wiphy_vendor_command_flags
+ * @doit: callback for the operation, note that wdev is %NULL if the
+ *	flags didn't ask for a wdev and non-%NULL otherwise; the data
+ *	pointer may be %NULL if userspace provided no data at all
+ * @dumpit: dump callback, for transferring bigger/multiple items. The
+ *	@storage points to cb->args[5], ie. is preserved over the multiple
+ *	dumpit calls.
+ * @policy: policy pointer for attributes within %NL80211_ATTR_VENDOR_DATA.
+ *	Set this to %VENDOR_CMD_RAW_DATA if no policy can be given and the
+ *	attribute is just raw data (e.g. a firmware command).
+ * @maxattr: highest attribute number in policy
+ * It's recommended to not have the same sub command with both @doit and
+ * @dumpit, so that userspace can assume certain ones are get and others
+ * are used with dump requests.
+ */
+struct wiphy_vendor_command {
+	struct nl80211_vendor_cmd_info info;
+	u32 flags;
+	int (*doit)(struct wiphy *wiphy, struct wireless_dev *wdev,
+		    const void *data, int data_len);
+	int (*dumpit)(struct wiphy *wiphy, struct wireless_dev *wdev,
+		      struct sk_buff *skb, const void *data, int data_len,
+		      unsigned long *storage);
+	const struct nla_policy *policy;
+	unsigned int maxattr;
+};
+
+/**
+ * struct wiphy_iftype_ext_capab - extended capabilities per interface type
+ * @iftype: interface type
+ * @extended_capabilities: extended capabilities supported by the driver,
+ *	additional capabilities might be supported by userspace; these are the
+ *	802.11 extended capabilities ("Extended Capabilities element") and are
+ *	in the same format as in the information element. See IEEE Std
+ *	802.11-2012 8.4.2.29 for the defined fields.
+ * @extended_capabilities_mask: mask of the valid values
+ * @extended_capabilities_len: length of the extended capabilities
+ */
+struct wiphy_iftype_ext_capab {
+	enum nl80211_iftype iftype;
+	const u8 *extended_capabilities;
+	const u8 *extended_capabilities_mask;
+	u8 extended_capabilities_len;
+};
+
+/**
+ * struct cfg80211_pmsr_capabilities - cfg80211 peer measurement capabilities
+ * @max_peers: maximum number of peers in a single measurement
+ * @report_ap_tsf: can report assoc AP's TSF for radio resource measurement
+ * @randomize_mac_addr: can randomize MAC address for measurement
+ * @ftm.supported: FTM measurement is supported
+ * @ftm.asap: ASAP-mode is supported
+ * @ftm.non_asap: non-ASAP-mode is supported
+ * @ftm.request_lci: can request LCI data
+ * @ftm.request_civicloc: can request civic location data
+ * @ftm.preambles: bitmap of preambles supported (&enum nl80211_preamble)
+ * @ftm.bandwidths: bitmap of bandwidths supported (&enum nl80211_chan_width)
+ * @ftm.max_bursts_exponent: maximum burst exponent supported
+ *	(set to -1 if not limited; note that setting this will necessarily
+ *	forbid using the value 15 to let the responder pick)
+ * @ftm.max_ftms_per_burst: maximum FTMs per burst supported (set to 0 if
+ *	not limited)
+ */
+struct cfg80211_pmsr_capabilities {
+	unsigned int max_peers;
+	u8 report_ap_tsf:1,
+	   randomize_mac_addr:1;
+
+	struct {
+		u32 preambles;
+		u32 bandwidths;
+		s8 max_bursts_exponent;
+		u8 max_ftms_per_burst;
+		u8 supported:1,
+		   asap:1,
+		   non_asap:1,
+		   request_lci:1,
+		   request_civicloc:1;
+	} ftm;
+};
+
+/**
+ * struct wiphy_iftype_akm_suites - This structure encapsulates supported akm
+ * suites for interface types defined in @iftypes_mask. Each type in the
+ * @iftypes_mask must be unique across all instances of iftype_akm_suites.
+ *
+ * @iftypes_mask: bitmask of interfaces types
+ * @akm_suites: points to an array of supported akm suites
+ * @n_akm_suites: number of supported AKM suites
+ */
+struct wiphy_iftype_akm_suites {
+	u16 iftypes_mask;
+	const u32 *akm_suites;
+	int n_akm_suites;
+};
+
+/**
+ * struct wiphy - wireless hardware description
+ * @reg_notifier: the driver's regulatory notification callback,
+ *	note that if your driver uses wiphy_apply_custom_regulatory()
+ *	the reg_notifier's request can be passed as NULL
+ * @regd: the driver's regulatory domain, if one was requested via
+ * 	the regulatory_hint() API. This can be used by the driver
+ *	on the reg_notifier() if it chooses to ignore future
+ *	regulatory domain changes caused by other drivers.
+ * @signal_type: signal type reported in &struct cfg80211_bss.
+ * @cipher_suites: supported cipher suites
+ * @n_cipher_suites: number of supported cipher suites
+ * @akm_suites: supported AKM suites. These are the default AKMs supported if
+ *	the supported AKMs not advertized for a specific interface type in
+ *	iftype_akm_suites.
+ * @n_akm_suites: number of supported AKM suites
+ * @iftype_akm_suites: array of supported akm suites info per interface type.
+ *	Note that the bits in @iftypes_mask inside this structure cannot
+ *	overlap (i.e. only one occurrence of each type is allowed across all
+ *	instances of iftype_akm_suites).
+ * @num_iftype_akm_suites: number of interface types for which supported akm
+ *	suites are specified separately.
+ * @retry_short: Retry limit for short frames (dot11ShortRetryLimit)
+ * @retry_long: Retry limit for long frames (dot11LongRetryLimit)
+ * @frag_threshold: Fragmentation threshold (dot11FragmentationThreshold);
+ *	-1 = fragmentation disabled, only odd values >= 256 used
+ * @rts_threshold: RTS threshold (dot11RTSThreshold); -1 = RTS/CTS disabled
+ * @_net: the network namespace this wiphy currently lives in
+ * @perm_addr: permanent MAC address of this device
+ * @addr_mask: If the device supports multiple MAC addresses by masking,
+ *	set this to a mask with variable bits set to 1, e.g. if the last
+ *	four bits are variable then set it to 00-00-00-00-00-0f. The actual
+ *	variable bits shall be determined by the interfaces added, with
+ *	interfaces not matching the mask being rejected to be brought up.
+ * @n_addresses: number of addresses in @addresses.
+ * @addresses: If the device has more than one address, set this pointer
+ *	to a list of addresses (6 bytes each). The first one will be used
+ *	by default for perm_addr. In this case, the mask should be set to
+ *	all-zeroes. In this case it is assumed that the device can handle
+ *	the same number of arbitrary MAC addresses.
+ * @registered: protects ->resume and ->suspend sysfs callbacks against
+ *	unregister hardware
+ * @debugfsdir: debugfs directory used for this wiphy, will be renamed
+ *	automatically on wiphy renames
+ * @dev: (virtual) struct device for this wiphy
+ * @registered: helps synchronize suspend/resume with wiphy unregister
+ * @wext: wireless extension handlers
+ * @priv: driver private data (sized according to wiphy_new() parameter)
+ * @interface_modes: bitmask of interfaces types valid for this wiphy,
+ *	must be set by driver
+ * @iface_combinations: Valid interface combinations array, should not
+ *	list single interface types.
+ * @n_iface_combinations: number of entries in @iface_combinations array.
+ * @software_iftypes: bitmask of software interface types, these are not
+ *	subject to any restrictions since they are purely managed in SW.
+ * @flags: wiphy flags, see &enum wiphy_flags
+ * @regulatory_flags: wiphy regulatory flags, see
+ *	&enum ieee80211_regulatory_flags
+ * @features: features advertised to nl80211, see &enum nl80211_feature_flags.
+ * @ext_features: extended features advertised to nl80211, see
+ *	&enum nl80211_ext_feature_index.
+ * @bss_priv_size: each BSS struct has private data allocated with it,
+ *	this variable determines its size
+ * @max_scan_ssids: maximum number of SSIDs the device can scan for in
+ *	any given scan
+ * @max_sched_scan_reqs: maximum number of scheduled scan requests that
+ *	the device can run concurrently.
+ * @max_sched_scan_ssids: maximum number of SSIDs the device can scan
+ *	for in any given scheduled scan
+ * @max_match_sets: maximum number of match sets the device can handle
+ *	when performing a scheduled scan, 0 if filtering is not
+ *	supported.
+ * @max_scan_ie_len: maximum length of user-controlled IEs device can
+ *	add to probe request frames transmitted during a scan, must not
+ *	include fixed IEs like supported rates
+ * @max_sched_scan_ie_len: same as max_scan_ie_len, but for scheduled
+ *	scans
+ * @max_sched_scan_plans: maximum number of scan plans (scan interval and number
+ *	of iterations) for scheduled scan supported by the device.
+ * @max_sched_scan_plan_interval: maximum interval (in seconds) for a
+ *	single scan plan supported by the device.
+ * @max_sched_scan_plan_iterations: maximum number of iterations for a single
+ *	scan plan supported by the device.
+ * @coverage_class: current coverage class
+ * @fw_version: firmware version for ethtool reporting
+ * @hw_version: hardware version for ethtool reporting
+ * @max_num_pmkids: maximum number of PMKIDs supported by device
+ * @privid: a pointer that drivers can use to identify if an arbitrary
+ *	wiphy is theirs, e.g. in global notifiers
+ * @bands: information about bands/channels supported by this device
+ *
+ * @mgmt_stypes: bitmasks of frame subtypes that can be subscribed to or
+ *	transmitted through nl80211, points to an array indexed by interface
+ *	type
+ *
+ * @available_antennas_tx: bitmap of antennas which are available to be
+ *	configured as TX antennas. Antenna configuration commands will be
+ *	rejected unless this or @available_antennas_rx is set.
+ *
+ * @available_antennas_rx: bitmap of antennas which are available to be
+ *	configured as RX antennas. Antenna configuration commands will be
+ *	rejected unless this or @available_antennas_tx is set.
+ *
+ * @probe_resp_offload:
+ *	 Bitmap of supported protocols for probe response offloading.
+ *	 See &enum nl80211_probe_resp_offload_support_attr. Only valid
+ *	 when the wiphy flag @WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD is set.
+ *
+ * @max_remain_on_channel_duration: Maximum time a remain-on-channel operation
+ *	may request, if implemented.
+ *
+ * @wowlan: WoWLAN support information
+ * @wowlan_config: current WoWLAN configuration; this should usually not be
+ *	used since access to it is necessarily racy, use the parameter passed
+ *	to the suspend() operation instead.
+ *
+ * @ap_sme_capa: AP SME capabilities, flags from &enum nl80211_ap_sme_features.
+ * @ht_capa_mod_mask:  Specify what ht_cap values can be over-ridden.
+ *	If null, then none can be over-ridden.
+ * @vht_capa_mod_mask:  Specify what VHT capabilities can be over-ridden.
+ *	If null, then none can be over-ridden.
+ *
+ * @wdev_list: the list of associated (virtual) interfaces; this list must
+ *	not be modified by the driver, but can be read with RTNL/RCU protection.
+ *
+ * @max_acl_mac_addrs: Maximum number of MAC addresses that the device
+ *	supports for ACL.
+ *
+ * @extended_capabilities: extended capabilities supported by the driver,
+ *	additional capabilities might be supported by userspace; these are
+ *	the 802.11 extended capabilities ("Extended Capabilities element")
+ *	and are in the same format as in the information element. See
+ *	802.11-2012 8.4.2.29 for the defined fields. These are the default
+ *	extended capabilities to be used if the capabilities are not specified
+ *	for a specific interface type in iftype_ext_capab.
+ * @extended_capabilities_mask: mask of the valid values
+ * @extended_capabilities_len: length of the extended capabilities
+ * @iftype_ext_capab: array of extended capabilities per interface type
+ * @num_iftype_ext_capab: number of interface types for which extended
+ *	capabilities are specified separately.
+ * @coalesce: packet coalescing support information
+ *
+ * @vendor_commands: array of vendor commands supported by the hardware
+ * @n_vendor_commands: number of vendor commands
+ * @vendor_events: array of vendor events supported by the hardware
+ * @n_vendor_events: number of vendor events
+ *
+ * @max_ap_assoc_sta: maximum number of associated stations supported in AP mode
+ *	(including P2P GO) or 0 to indicate no such limit is advertised. The
+ *	driver is allowed to advertise a theoretical limit that it can reach in
+ *	some cases, but may not always reach.
+ *
+ * @max_num_csa_counters: Number of supported csa_counters in beacons
+ *	and probe responses.  This value should be set if the driver
+ *	wishes to limit the number of csa counters. Default (0) means
+ *	infinite.
+ * @max_adj_channel_rssi_comp: max offset of between the channel on which the
+ *	frame was sent and the channel on which the frame was heard for which
+ *	the reported rssi is still valid. If a driver is able to compensate the
+ *	low rssi when a frame is heard on different channel, then it should set
+ *	this variable to the maximal offset for which it can compensate.
+ *	This value should be set in MHz.
+ * @bss_select_support: bitmask indicating the BSS selection criteria supported
+ *	by the driver in the .connect() callback. The bit position maps to the
+ *	attribute indices defined in &enum nl80211_bss_select_attr.
+ *
+ * @nan_supported_bands: bands supported by the device in NAN mode, a
+ *	bitmap of &enum nl80211_band values.  For instance, for
+ *	NL80211_BAND_2GHZ, bit 0 would be set
+ *	(i.e. BIT(NL80211_BAND_2GHZ)).
+ *
+ * @txq_limit: configuration of internal TX queue frame limit
+ * @txq_memory_limit: configuration internal TX queue memory limit
+ * @txq_quantum: configuration of internal TX queue scheduler quantum
+ *
+ * @support_mbssid: can HW support association with nontransmitted AP
+ * @support_only_he_mbssid: don't parse MBSSID elements if it is not
+ *	HE AP, in order to avoid compatibility issues.
+ *	@support_mbssid must be set for this to have any effect.
+ *
+ * @pmsr_capa: peer measurement capabilities
+ *
+ * @tid_config_support: describes the per-TID config support that the
+ *	device has
+ * @tid_config_support.vif: bitmap of attributes (configurations)
+ *	supported by the driver for each vif
+ * @tid_config_support.peer: bitmap of attributes (configurations)
+ *	supported by the driver for each peer
+ */
+struct wiphy {
+	/* assign these fields before you register the wiphy */
+
+	/* permanent MAC address(es) */
+	u8 perm_addr[ETH_ALEN];
+	u8 addr_mask[ETH_ALEN];
+
+	struct mac_address *addresses;
+
+	const struct ieee80211_txrx_stypes *mgmt_stypes;
+
+	const struct ieee80211_iface_combination *iface_combinations;
+	int n_iface_combinations;
+	u16 software_iftypes;
+
+	u16 n_addresses;
+
+	/* Supported interface modes, OR together BIT(NL80211_IFTYPE_...) */
+	u16 interface_modes;
+
+	u16 max_acl_mac_addrs;
+
+	u32 flags, regulatory_flags, features;
+	u8 ext_features[DIV_ROUND_UP(NUM_NL80211_EXT_FEATURES, 8)];
+
+	u32 ap_sme_capa;
+
+	enum cfg80211_signal_type signal_type;
+
+	int bss_priv_size;
+	u8 max_scan_ssids;
+	u8 max_sched_scan_reqs;
+	u8 max_sched_scan_ssids;
+	u8 max_match_sets;
+	u16 max_scan_ie_len;
+	u16 max_sched_scan_ie_len;
+	u32 max_sched_scan_plans;
+	u32 max_sched_scan_plan_interval;
+	u32 max_sched_scan_plan_iterations;
+
+	int n_cipher_suites;
+	const u32 *cipher_suites;
+
+	int n_akm_suites;
+	const u32 *akm_suites;
+
+	const struct wiphy_iftype_akm_suites *iftype_akm_suites;
+	unsigned int num_iftype_akm_suites;
+
+	u8 retry_short;
+	u8 retry_long;
+	u32 frag_threshold;
+	u32 rts_threshold;
+	u8 coverage_class;
+
+	char fw_version[ETHTOOL_FWVERS_LEN];
+	u32 hw_version;
+
+#ifdef CONFIG_PM
+	const struct wiphy_wowlan_support *wowlan;
+	struct cfg80211_wowlan *wowlan_config;
+#endif
+
+	u16 max_remain_on_channel_duration;
+
+	u8 max_num_pmkids;
+
+	u32 available_antennas_tx;
+	u32 available_antennas_rx;
+
+	/*
+	 * Bitmap of supported protocols for probe response offloading
+	 * see &enum nl80211_probe_resp_offload_support_attr. Only valid
+	 * when the wiphy flag @WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD is set.
+	 */
+	u32 probe_resp_offload;
+
+	const u8 *extended_capabilities, *extended_capabilities_mask;
+	u8 extended_capabilities_len;
+
+	const struct wiphy_iftype_ext_capab *iftype_ext_capab;
+	unsigned int num_iftype_ext_capab;
+
+	/* If multiple wiphys are registered and you're handed e.g.
+	 * a regular netdev with assigned ieee80211_ptr, you won't
+	 * know whether it points to a wiphy your driver has registered
+	 * or not. Assign this to something global to your driver to
+	 * help determine whether you own this wiphy or not. */
+	const void *privid;
+
+	struct ieee80211_supported_band *bands[NUM_NL80211_BANDS];
+
+	/* Lets us get back the wiphy on the callback */
+	void (*reg_notifier)(struct wiphy *wiphy,
+			     struct regulatory_request *request);
+
+	/* fields below are read-only, assigned by cfg80211 */
+
+	const struct ieee80211_regdomain __rcu *regd;
+
+	/* the item in /sys/class/ieee80211/ points to this,
+	 * you need use set_wiphy_dev() (see below) */
+	struct device dev;
+
+	/* protects ->resume, ->suspend sysfs callbacks against unregister hw */
+	bool registered;
+
+	/* dir in debugfs: ieee80211/<wiphyname> */
+	struct dentry *debugfsdir;
+
+	const struct ieee80211_ht_cap *ht_capa_mod_mask;
+	const struct ieee80211_vht_cap *vht_capa_mod_mask;
+
+	struct list_head wdev_list;
+
+	/* the network namespace this phy lives in currently */
+	possible_net_t _net;
+
+#ifdef CONFIG_CFG80211_WEXT
+	const struct iw_handler_def *wext;
+#endif
+
+	const struct wiphy_coalesce_support *coalesce;
+
+	const struct wiphy_vendor_command *vendor_commands;
+	const struct nl80211_vendor_cmd_info *vendor_events;
+	int n_vendor_commands, n_vendor_events;
+
+	u16 max_ap_assoc_sta;
+
+	u8 max_num_csa_counters;
+	u8 max_adj_channel_rssi_comp;
+
+	u32 bss_select_support;
+
+	u8 nan_supported_bands;
+
+	u32 txq_limit;
+	u32 txq_memory_limit;
+	u32 txq_quantum;
+
+	u8 support_mbssid:1,
+	   support_only_he_mbssid:1;
+
+	const struct cfg80211_pmsr_capabilities *pmsr_capa;
+
+	struct {
+		u64 peer, vif;
+	} tid_config_support;
+
+	char priv[0] __aligned(NETDEV_ALIGN);
+};
+
+static inline struct net *wiphy_net(struct wiphy *wiphy)
+{
+	return read_pnet(&wiphy->_net);
+}
+
+static inline void wiphy_net_set(struct wiphy *wiphy, struct net *net)
+{
+	write_pnet(&wiphy->_net, net);
+}
+
+/**
+ * wiphy_priv - return priv from wiphy
+ *
+ * @wiphy: the wiphy whose priv pointer to return
+ * Return: The priv of @wiphy.
+ */
+static inline void *wiphy_priv(struct wiphy *wiphy)
+{
+	BUG_ON(!wiphy);
+	return &wiphy->priv;
+}
+
+/**
+ * priv_to_wiphy - return the wiphy containing the priv
+ *
+ * @priv: a pointer previously returned by wiphy_priv
+ * Return: The wiphy of @priv.
+ */
+static inline struct wiphy *priv_to_wiphy(void *priv)
+{
+	BUG_ON(!priv);
+	return container_of(priv, struct wiphy, priv);
+}
+
+/**
+ * set_wiphy_dev - set device pointer for wiphy
+ *
+ * @wiphy: The wiphy whose device to bind
+ * @dev: The device to parent it to
+ */
+static inline void set_wiphy_dev(struct wiphy *wiphy, struct device *dev)
+{
+	wiphy->dev.parent = dev;
+}
+
+/**
+ * wiphy_dev - get wiphy dev pointer
+ *
+ * @wiphy: The wiphy whose device struct to look up
+ * Return: The dev of @wiphy.
+ */
+static inline struct device *wiphy_dev(struct wiphy *wiphy)
+{
+	return wiphy->dev.parent;
+}
+
+/**
+ * wiphy_name - get wiphy name
+ *
+ * @wiphy: The wiphy whose name to return
+ * Return: The name of @wiphy.
+ */
+static inline const char *wiphy_name(const struct wiphy *wiphy)
+{
+	return dev_name(&wiphy->dev);
+}
+
+/**
+ * wiphy_new_nm - create a new wiphy for use with cfg80211
+ *
+ * @ops: The configuration operations for this device
+ * @sizeof_priv: The size of the private area to allocate
+ * @requested_name: Request a particular name.
+ *	NULL is valid value, and means use the default phy%d naming.
+ *
+ * Create a new wiphy and associate the given operations with it.
+ * @sizeof_priv bytes are allocated for private use.
+ *
+ * Return: A pointer to the new wiphy. This pointer must be
+ * assigned to each netdev's ieee80211_ptr for proper operation.
+ */
+struct wiphy *wiphy_new_nm(const struct cfg80211_ops *ops, int sizeof_priv,
+			   const char *requested_name);
+
+/**
+ * wiphy_new - create a new wiphy for use with cfg80211
+ *
+ * @ops: The configuration operations for this device
+ * @sizeof_priv: The size of the private area to allocate
+ *
+ * Create a new wiphy and associate the given operations with it.
+ * @sizeof_priv bytes are allocated for private use.
+ *
+ * Return: A pointer to the new wiphy. This pointer must be
+ * assigned to each netdev's ieee80211_ptr for proper operation.
+ */
+static inline struct wiphy *wiphy_new(const struct cfg80211_ops *ops,
+				      int sizeof_priv)
+{
+	return wiphy_new_nm(ops, sizeof_priv, NULL);
+}
+
+/**
+ * wiphy_register - register a wiphy with cfg80211
+ *
+ * @wiphy: The wiphy to register.
+ *
+ * Return: A non-negative wiphy index or a negative error code.
+ */
+int wiphy_register(struct wiphy *wiphy);
+
+/**
+ * wiphy_unregister - deregister a wiphy from cfg80211
+ *
+ * @wiphy: The wiphy to unregister.
+ *
+ * After this call, no more requests can be made with this priv
+ * pointer, but the call may sleep to wait for an outstanding
+ * request that is being handled.
+ */
+void wiphy_unregister(struct wiphy *wiphy);
+
+/**
+ * wiphy_free - free wiphy
+ *
+ * @wiphy: The wiphy to free
+ */
+void wiphy_free(struct wiphy *wiphy);
+
+/* internal structs */
+struct cfg80211_conn;
+struct cfg80211_internal_bss;
+struct cfg80211_cached_keys;
+struct cfg80211_cqm_config;
+
+/**
+ * struct wireless_dev - wireless device state
+ *
+ * For netdevs, this structure must be allocated by the driver
+ * that uses the ieee80211_ptr field in struct net_device (this
+ * is intentional so it can be allocated along with the netdev.)
+ * It need not be registered then as netdev registration will
+ * be intercepted by cfg80211 to see the new wireless device.
+ *
+ * For non-netdev uses, it must also be allocated by the driver
+ * in response to the cfg80211 callbacks that require it, as
+ * there's no netdev registration in that case it may not be
+ * allocated outside of callback operations that return it.
+ *
+ * @wiphy: pointer to hardware description
+ * @iftype: interface type
+ * @list: (private) Used to collect the interfaces
+ * @netdev: (private) Used to reference back to the netdev, may be %NULL
+ * @identifier: (private) Identifier used in nl80211 to identify this
+ *	wireless device if it has no netdev
+ * @current_bss: (private) Used by the internal configuration code
+ * @chandef: (private) Used by the internal configuration code to track
+ *	the user-set channel definition.
+ * @preset_chandef: (private) Used by the internal configuration code to
+ *	track the channel to be used for AP later
+ * @bssid: (private) Used by the internal configuration code
+ * @ssid: (private) Used by the internal configuration code
+ * @ssid_len: (private) Used by the internal configuration code
+ * @mesh_id_len: (private) Used by the internal configuration code
+ * @mesh_id_up_len: (private) Used by the internal configuration code
+ * @wext: (private) Used by the internal wireless extensions compat code
+ * @wext.ibss: (private) IBSS data part of wext handling
+ * @wext.connect: (private) connection handling data
+ * @wext.keys: (private) (WEP) key data
+ * @wext.ie: (private) extra elements for association
+ * @wext.ie_len: (private) length of extra elements
+ * @wext.bssid: (private) selected network BSSID
+ * @wext.ssid: (private) selected network SSID
+ * @wext.default_key: (private) selected default key index
+ * @wext.default_mgmt_key: (private) selected default management key index
+ * @wext.prev_bssid: (private) previous BSSID for reassociation
+ * @wext.prev_bssid_valid: (private) previous BSSID validity
+ * @use_4addr: indicates 4addr mode is used on this interface, must be
+ *	set by driver (if supported) on add_interface BEFORE registering the
+ *	netdev and may otherwise be used by driver read-only, will be update
+ *	by cfg80211 on change_interface
+ * @mgmt_registrations: list of registrations for management frames
+ * @mgmt_registrations_lock: lock for the list
+ * @mtx: mutex used to lock data in this struct, may be used by drivers
+ *	and some API functions require it held
+ * @beacon_interval: beacon interval used on this device for transmitting
+ *	beacons, 0 when not valid
+ * @address: The address for this device, valid only if @netdev is %NULL
+ * @is_running: true if this is a non-netdev device that has been started, e.g.
+ *	the P2P Device.
+ * @cac_started: true if DFS channel availability check has been started
+ * @cac_start_time: timestamp (jiffies) when the dfs state was entered.
+ * @cac_time_ms: CAC time in ms
+ * @ps: powersave mode is enabled
+ * @ps_timeout: dynamic powersave timeout
+ * @ap_unexpected_nlportid: (private) netlink port ID of application
+ *	registered for unexpected class 3 frames (AP mode)
+ * @conn: (private) cfg80211 software SME connection state machine data
+ * @connect_keys: (private) keys to set after connection is established
+ * @conn_bss_type: connecting/connected BSS type
+ * @conn_owner_nlportid: (private) connection owner socket port ID
+ * @disconnect_wk: (private) auto-disconnect work
+ * @disconnect_bssid: (private) the BSSID to use for auto-disconnect
+ * @ibss_fixed: (private) IBSS is using fixed BSSID
+ * @ibss_dfs_possible: (private) IBSS may change to a DFS channel
+ * @event_list: (private) list for internal event processing
+ * @event_lock: (private) lock for event list
+ * @owner_nlportid: (private) owner socket port ID
+ * @nl_owner_dead: (private) owner socket went away
+ * @cqm_config: (private) nl80211 RSSI monitor state
+ * @pmsr_list: (private) peer measurement requests
+ * @pmsr_lock: (private) peer measurements requests/results lock
+ * @pmsr_free_wk: (private) peer measurements cleanup work
+ */
+struct wireless_dev {
+	struct wiphy *wiphy;
+	enum nl80211_iftype iftype;
+
+	/* the remainder of this struct should be private to cfg80211 */
+	struct list_head list;
+	struct net_device *netdev;
+
+	u32 identifier;
+
+	struct list_head mgmt_registrations;
+	spinlock_t mgmt_registrations_lock;
+
+	struct mutex mtx;
+
+	bool use_4addr, is_running;
+
+	u8 address[ETH_ALEN] __aligned(sizeof(u16));
+
+	/* currently used for IBSS and SME - might be rearranged later */
+	u8 ssid[IEEE80211_MAX_SSID_LEN];
+	u8 ssid_len, mesh_id_len, mesh_id_up_len;
+	struct cfg80211_conn *conn;
+	struct cfg80211_cached_keys *connect_keys;
+	enum ieee80211_bss_type conn_bss_type;
+	u32 conn_owner_nlportid;
+
+	struct work_struct disconnect_wk;
+	u8 disconnect_bssid[ETH_ALEN];
+
+	struct list_head event_list;
+	spinlock_t event_lock;
+
+	struct cfg80211_internal_bss *current_bss; /* associated / joined */
+	struct cfg80211_chan_def preset_chandef;
+	struct cfg80211_chan_def chandef;
+
+	bool ibss_fixed;
+	bool ibss_dfs_possible;
+
+	bool ps;
+	int ps_timeout;
+
+	int beacon_interval;
+
+	u32 ap_unexpected_nlportid;
+
+	u32 owner_nlportid;
+	bool nl_owner_dead;
+
+	bool cac_started;
+	unsigned long cac_start_time;
+	unsigned int cac_time_ms;
+
+#ifdef CONFIG_CFG80211_WEXT
+	/* wext data */
+	struct {
+		struct cfg80211_ibss_params ibss;
+		struct cfg80211_connect_params connect;
+		struct cfg80211_cached_keys *keys;
+		const u8 *ie;
+		size_t ie_len;
+		u8 bssid[ETH_ALEN];
+		u8 prev_bssid[ETH_ALEN];
+		u8 ssid[IEEE80211_MAX_SSID_LEN];
+		s8 default_key, default_mgmt_key;
+		bool prev_bssid_valid;
+	} wext;
+#endif
+
+	struct cfg80211_cqm_config *cqm_config;
+
+	struct list_head pmsr_list;
+	spinlock_t pmsr_lock;
+	struct work_struct pmsr_free_wk;
+};
+
+static inline u8 *wdev_address(struct wireless_dev *wdev)
+{
+	if (wdev->netdev)
+		return wdev->netdev->dev_addr;
+	return wdev->address;
+}
+
+static inline bool wdev_running(struct wireless_dev *wdev)
+{
+	if (wdev->netdev)
+		return netif_running(wdev->netdev);
+	return wdev->is_running;
+}
+
+/**
+ * wdev_priv - return wiphy priv from wireless_dev
+ *
+ * @wdev: The wireless device whose wiphy's priv pointer to return
+ * Return: The wiphy priv of @wdev.
+ */
+static inline void *wdev_priv(struct wireless_dev *wdev)
+{
+	BUG_ON(!wdev);
+	return wiphy_priv(wdev->wiphy);
+}
+
+/**
+ * DOC: Utility functions
+ *
+ * cfg80211 offers a number of utility functions that can be useful.
+ */
+
+/**
+ * ieee80211_channel_equal - compare two struct ieee80211_channel
+ *
+ * @a: 1st struct ieee80211_channel
+ * @b: 2nd struct ieee80211_channel
+ * Return: true if center frequency of @a == @b
+ */
+static inline bool
+ieee80211_channel_equal(struct ieee80211_channel *a,
+			struct ieee80211_channel *b)
+{
+	return (a->center_freq == b->center_freq &&
+		a->freq_offset == b->freq_offset);
+}
+
+/**
+ * ieee80211_channel_to_khz - convert ieee80211_channel to frequency in KHz
+ * @chan: struct ieee80211_channel to convert
+ * Return: The corresponding frequency (in KHz)
+ */
+static inline u32
+ieee80211_channel_to_khz(const struct ieee80211_channel *chan)
+{
+	return MHZ_TO_KHZ(chan->center_freq) + chan->freq_offset;
+}
+
+/**
+ * ieee80211_channel_to_freq_khz - convert channel number to frequency
+ * @chan: channel number
+ * @band: band, necessary due to channel number overlap
+ * Return: The corresponding frequency (in KHz), or 0 if the conversion failed.
+ */
+u32 ieee80211_channel_to_freq_khz(int chan, enum nl80211_band band);
+
+/**
+ * ieee80211_channel_to_frequency - convert channel number to frequency
+ * @chan: channel number
+ * @band: band, necessary due to channel number overlap
+ * Return: The corresponding frequency (in MHz), or 0 if the conversion failed.
+ */
+static inline int
+ieee80211_channel_to_frequency(int chan, enum nl80211_band band)
+{
+	return KHZ_TO_MHZ(ieee80211_channel_to_freq_khz(chan, band));
+}
+
+/**
+ * ieee80211_freq_khz_to_channel - convert frequency to channel number
+ * @freq: center frequency in KHz
+ * Return: The corresponding channel, or 0 if the conversion failed.
+ */
+int ieee80211_freq_khz_to_channel(u32 freq);
+
+/**
+ * ieee80211_frequency_to_channel - convert frequency to channel number
+ * @freq: center frequency in MHz
+ * Return: The corresponding channel, or 0 if the conversion failed.
+ */
+static inline int
+ieee80211_frequency_to_channel(int freq)
+{
+	return ieee80211_freq_khz_to_channel(MHZ_TO_KHZ(freq));
+}
+
+/**
+ * ieee80211_get_channel_khz - get channel struct from wiphy for specified
+ * frequency
+ * @wiphy: the struct wiphy to get the channel for
+ * @freq: the center frequency (in KHz) of the channel
+ * Return: The channel struct from @wiphy at @freq.
+ */
+struct ieee80211_channel *
+ieee80211_get_channel_khz(struct wiphy *wiphy, u32 freq);
+
+/**
+ * ieee80211_get_channel - get channel struct from wiphy for specified frequency
+ *
+ * @wiphy: the struct wiphy to get the channel for
+ * @freq: the center frequency (in MHz) of the channel
+ * Return: The channel struct from @wiphy at @freq.
+ */
+static inline struct ieee80211_channel *
+ieee80211_get_channel(struct wiphy *wiphy, int freq)
+{
+	return ieee80211_get_channel_khz(wiphy, MHZ_TO_KHZ(freq));
+}
+
+/**
+ * cfg80211_channel_is_psc - Check if the channel is a 6 GHz PSC
+ * @chan: control channel to check
+ *
+ * The Preferred Scanning Channels (PSC) are defined in
+ * Draft IEEE P802.11ax/D5.0, 26.17.2.3.3
+ */
+static inline bool cfg80211_channel_is_psc(struct ieee80211_channel *chan)
+{
+	if (chan->band != NL80211_BAND_6GHZ)
+		return false;
+
+	return ieee80211_frequency_to_channel(chan->center_freq) % 16 == 5;
+}
+
+/**
+ * ieee80211_get_response_rate - get basic rate for a given rate
+ *
+ * @sband: the band to look for rates in
+ * @basic_rates: bitmap of basic rates
+ * @bitrate: the bitrate for which to find the basic rate
+ *
+ * Return: The basic rate corresponding to a given bitrate, that
+ * is the next lower bitrate contained in the basic rate map,
+ * which is, for this function, given as a bitmap of indices of
+ * rates in the band's bitrate table.
+ */
+struct ieee80211_rate *
+ieee80211_get_response_rate(struct ieee80211_supported_band *sband,
+			    u32 basic_rates, int bitrate);
+
+/**
+ * ieee80211_mandatory_rates - get mandatory rates for a given band
+ * @sband: the band to look for rates in
+ * @scan_width: width of the control channel
+ *
+ * This function returns a bitmap of the mandatory rates for the given
+ * band, bits are set according to the rate position in the bitrates array.
+ */
+u32 ieee80211_mandatory_rates(struct ieee80211_supported_band *sband,
+			      enum nl80211_bss_scan_width scan_width);
+
+/*
+ * Radiotap parsing functions -- for controlled injection support
+ *
+ * Implemented in net/wireless/radiotap.c
+ * Documentation in Documentation/networking/radiotap-headers.txt
+ */
+
+struct radiotap_align_size {
+	uint8_t align:4, size:4;
+};
+
+struct ieee80211_radiotap_namespace {
+	const struct radiotap_align_size *align_size;
+	int n_bits;
+	uint32_t oui;
+	uint8_t subns;
+};
+
+struct ieee80211_radiotap_vendor_namespaces {
+	const struct ieee80211_radiotap_namespace *ns;
+	int n_ns;
+};
+
+/**
+ * struct ieee80211_radiotap_iterator - tracks walk thru present radiotap args
+ * @this_arg_index: index of current arg, valid after each successful call
+ *	to ieee80211_radiotap_iterator_next()
+ * @this_arg: pointer to current radiotap arg; it is valid after each
+ *	call to ieee80211_radiotap_iterator_next() but also after
+ *	ieee80211_radiotap_iterator_init() where it will point to
+ *	the beginning of the actual data portion
+ * @this_arg_size: length of the current arg, for convenience
+ * @current_namespace: pointer to the current namespace definition
+ *	(or internally %NULL if the current namespace is unknown)
+ * @is_radiotap_ns: indicates whether the current namespace is the default
+ *	radiotap namespace or not
+ *
+ * @_rtheader: pointer to the radiotap header we are walking through
+ * @_max_length: length of radiotap header in cpu byte ordering
+ * @_arg_index: next argument index
+ * @_arg: next argument pointer
+ * @_next_bitmap: internal pointer to next present u32
+ * @_bitmap_shifter: internal shifter for curr u32 bitmap, b0 set == arg present
+ * @_vns: vendor namespace definitions
+ * @_next_ns_data: beginning of the next namespace's data
+ * @_reset_on_ext: internal; reset the arg index to 0 when going to the
+ *	next bitmap word
+ *
+ * Describes the radiotap parser state. Fields prefixed with an underscore
+ * must not be used by users of the parser, only by the parser internally.
+ */
+
+struct ieee80211_radiotap_iterator {
+	struct ieee80211_radiotap_header *_rtheader;
+	const struct ieee80211_radiotap_vendor_namespaces *_vns;
+	const struct ieee80211_radiotap_namespace *current_namespace;
+
+	unsigned char *_arg, *_next_ns_data;
+	__le32 *_next_bitmap;
+
+	unsigned char *this_arg;
+	int this_arg_index;
+	int this_arg_size;
+
+	int is_radiotap_ns;
+
+	int _max_length;
+	int _arg_index;
+	uint32_t _bitmap_shifter;
+	int _reset_on_ext;
+};
+
+int
+ieee80211_radiotap_iterator_init(struct ieee80211_radiotap_iterator *iterator,
+				 struct ieee80211_radiotap_header *radiotap_header,
+				 int max_length,
+				 const struct ieee80211_radiotap_vendor_namespaces *vns);
+
+int
+ieee80211_radiotap_iterator_next(struct ieee80211_radiotap_iterator *iterator);
+
+
+extern const unsigned char rfc1042_header[6];
+extern const unsigned char bridge_tunnel_header[6];
+
+/**
+ * ieee80211_get_hdrlen_from_skb - get header length from data
+ *
+ * @skb: the frame
+ *
+ * Given an skb with a raw 802.11 header at the data pointer this function
+ * returns the 802.11 header length.
+ *
+ * Return: The 802.11 header length in bytes (not including encryption
+ * headers). Or 0 if the data in the sk_buff is too short to contain a valid
+ * 802.11 header.
+ */
+unsigned int ieee80211_get_hdrlen_from_skb(const struct sk_buff *skb);
+
+/**
+ * ieee80211_hdrlen - get header length in bytes from frame control
+ * @fc: frame control field in little-endian format
+ * Return: The header length in bytes.
+ */
+unsigned int __attribute_const__ ieee80211_hdrlen(__le16 fc);
+
+/**
+ * ieee80211_get_mesh_hdrlen - get mesh extension header length
+ * @meshhdr: the mesh extension header, only the flags field
+ *	(first byte) will be accessed
+ * Return: The length of the extension header, which is always at
+ * least 6 bytes and at most 18 if address 5 and 6 are present.
+ */
+unsigned int ieee80211_get_mesh_hdrlen(struct ieee80211s_hdr *meshhdr);
+
+/**
+ * DOC: Data path helpers
+ *
+ * In addition to generic utilities, cfg80211 also offers
+ * functions that help implement the data path for devices
+ * that do not do the 802.11/802.3 conversion on the device.
+ */
+
+/**
+ * ieee80211_data_to_8023_exthdr - convert an 802.11 data frame to 802.3
+ * @skb: the 802.11 data frame
+ * @ehdr: pointer to a &struct ethhdr that will get the header, instead
+ *	of it being pushed into the SKB
+ * @addr: the device MAC address
+ * @iftype: the virtual interface type
+ * @data_offset: offset of payload after the 802.11 header
+ * Return: 0 on success. Non-zero on error.
+ */
+int ieee80211_data_to_8023_exthdr(struct sk_buff *skb, struct ethhdr *ehdr,
+				  const u8 *addr, enum nl80211_iftype iftype,
+				  u8 data_offset);
+
+/**
+ * ieee80211_data_to_8023 - convert an 802.11 data frame to 802.3
+ * @skb: the 802.11 data frame
+ * @addr: the device MAC address
+ * @iftype: the virtual interface type
+ * Return: 0 on success. Non-zero on error.
+ */
+static inline int ieee80211_data_to_8023(struct sk_buff *skb, const u8 *addr,
+					 enum nl80211_iftype iftype)
+{
+	return ieee80211_data_to_8023_exthdr(skb, NULL, addr, iftype, 0);
+}
+
+/**
+ * ieee80211_amsdu_to_8023s - decode an IEEE 802.11n A-MSDU frame
+ *
+ * Decode an IEEE 802.11 A-MSDU and convert it to a list of 802.3 frames.
+ * The @list will be empty if the decode fails. The @skb must be fully
+ * header-less before being passed in here; it is freed in this function.
+ *
+ * @skb: The input A-MSDU frame without any headers.
+ * @list: The output list of 802.3 frames. It must be allocated and
+ *	initialized by by the caller.
+ * @addr: The device MAC address.
+ * @iftype: The device interface type.
+ * @extra_headroom: The hardware extra headroom for SKBs in the @list.
+ * @check_da: DA to check in the inner ethernet header, or NULL
+ * @check_sa: SA to check in the inner ethernet header, or NULL
+ */
+void ieee80211_amsdu_to_8023s(struct sk_buff *skb, struct sk_buff_head *list,
+			      const u8 *addr, enum nl80211_iftype iftype,
+			      const unsigned int extra_headroom,
+			      const u8 *check_da, const u8 *check_sa);
+
+/**
+ * cfg80211_classify8021d - determine the 802.1p/1d tag for a data frame
+ * @skb: the data frame
+ * @qos_map: Interworking QoS mapping or %NULL if not in use
+ * Return: The 802.1p/1d tag.
+ */
+unsigned int cfg80211_classify8021d(struct sk_buff *skb,
+				    struct cfg80211_qos_map *qos_map);
+
+/**
+ * cfg80211_find_elem_match - match information element and byte array in data
+ *
+ * @eid: element ID
+ * @ies: data consisting of IEs
+ * @len: length of data
+ * @match: byte array to match
+ * @match_len: number of bytes in the match array
+ * @match_offset: offset in the IE data where the byte array should match.
+ *	Note the difference to cfg80211_find_ie_match() which considers
+ *	the offset to start from the element ID byte, but here we take
+ *	the data portion instead.
+ *
+ * Return: %NULL if the element ID could not be found or if
+ * the element is invalid (claims to be longer than the given
+ * data) or if the byte array doesn't match; otherwise return the
+ * requested element struct.
+ *
+ * Note: There are no checks on the element length other than
+ * having to fit into the given data and being large enough for the
+ * byte array to match.
+ */
+const struct element *
+cfg80211_find_elem_match(u8 eid, const u8 *ies, unsigned int len,
+			 const u8 *match, unsigned int match_len,
+			 unsigned int match_offset);
+
+/**
+ * cfg80211_find_ie_match - match information element and byte array in data
+ *
+ * @eid: element ID
+ * @ies: data consisting of IEs
+ * @len: length of data
+ * @match: byte array to match
+ * @match_len: number of bytes in the match array
+ * @match_offset: offset in the IE where the byte array should match.
+ *	If match_len is zero, this must also be set to zero.
+ *	Otherwise this must be set to 2 or more, because the first
+ *	byte is the element id, which is already compared to eid, and
+ *	the second byte is the IE length.
+ *
+ * Return: %NULL if the element ID could not be found or if
+ * the element is invalid (claims to be longer than the given
+ * data) or if the byte array doesn't match, or a pointer to the first
+ * byte of the requested element, that is the byte containing the
+ * element ID.
+ *
+ * Note: There are no checks on the element length other than
+ * having to fit into the given data and being large enough for the
+ * byte array to match.
+ */
+static inline const u8 *
+cfg80211_find_ie_match(u8 eid, const u8 *ies, unsigned int len,
+		       const u8 *match, unsigned int match_len,
+		       unsigned int match_offset)
+{
+	/* match_offset can't be smaller than 2, unless match_len is
+	 * zero, in which case match_offset must be zero as well.
+	 */
+	if (WARN_ON((match_len && match_offset < 2) ||
+		    (!match_len && match_offset)))
+		return NULL;
+
+	return (void *)cfg80211_find_elem_match(eid, ies, len,
+						match, match_len,
+						match_offset ?
+							match_offset - 2 : 0);
+}
+
+/**
+ * cfg80211_find_elem - find information element in data
+ *
+ * @eid: element ID
+ * @ies: data consisting of IEs
+ * @len: length of data
+ *
+ * Return: %NULL if the element ID could not be found or if
+ * the element is invalid (claims to be longer than the given
+ * data) or if the byte array doesn't match; otherwise return the
+ * requested element struct.
+ *
+ * Note: There are no checks on the element length other than
+ * having to fit into the given data.
+ */
+static inline const struct element *
+cfg80211_find_elem(u8 eid, const u8 *ies, int len)
+{
+	return cfg80211_find_elem_match(eid, ies, len, NULL, 0, 0);
+}
+
+/**
+ * cfg80211_find_ie - find information element in data
+ *
+ * @eid: element ID
+ * @ies: data consisting of IEs
+ * @len: length of data
+ *
+ * Return: %NULL if the element ID could not be found or if
+ * the element is invalid (claims to be longer than the given
+ * data), or a pointer to the first byte of the requested
+ * element, that is the byte containing the element ID.
+ *
+ * Note: There are no checks on the element length other than
+ * having to fit into the given data.
+ */
+static inline const u8 *cfg80211_find_ie(u8 eid, const u8 *ies, int len)
+{
+	return cfg80211_find_ie_match(eid, ies, len, NULL, 0, 0);
+}
+
+/**
+ * cfg80211_find_ext_elem - find information element with EID Extension in data
+ *
+ * @ext_eid: element ID Extension
+ * @ies: data consisting of IEs
+ * @len: length of data
+ *
+ * Return: %NULL if the etended element could not be found or if
+ * the element is invalid (claims to be longer than the given
+ * data) or if the byte array doesn't match; otherwise return the
+ * requested element struct.
+ *
+ * Note: There are no checks on the element length other than
+ * having to fit into the given data.
+ */
+static inline const struct element *
+cfg80211_find_ext_elem(u8 ext_eid, const u8 *ies, int len)
+{
+	return cfg80211_find_elem_match(WLAN_EID_EXTENSION, ies, len,
+					&ext_eid, 1, 0);
+}
+
+/**
+ * cfg80211_find_ext_ie - find information element with EID Extension in data
+ *
+ * @ext_eid: element ID Extension
+ * @ies: data consisting of IEs
+ * @len: length of data
+ *
+ * Return: %NULL if the extended element ID could not be found or if
+ * the element is invalid (claims to be longer than the given
+ * data), or a pointer to the first byte of the requested
+ * element, that is the byte containing the element ID.
+ *
+ * Note: There are no checks on the element length other than
+ * having to fit into the given data.
+ */
+static inline const u8 *cfg80211_find_ext_ie(u8 ext_eid, const u8 *ies, int len)
+{
+	return cfg80211_find_ie_match(WLAN_EID_EXTENSION, ies, len,
+				      &ext_eid, 1, 2);
+}
+
+/**
+ * cfg80211_find_vendor_elem - find vendor specific information element in data
+ *
+ * @oui: vendor OUI
+ * @oui_type: vendor-specific OUI type (must be < 0xff), negative means any
+ * @ies: data consisting of IEs
+ * @len: length of data
+ *
+ * Return: %NULL if the vendor specific element ID could not be found or if the
+ * element is invalid (claims to be longer than the given data); otherwise
+ * return the element structure for the requested element.
+ *
+ * Note: There are no checks on the element length other than having to fit into
+ * the given data.
+ */
+const struct element *cfg80211_find_vendor_elem(unsigned int oui, int oui_type,
+						const u8 *ies,
+						unsigned int len);
+
+/**
+ * cfg80211_find_vendor_ie - find vendor specific information element in data
+ *
+ * @oui: vendor OUI
+ * @oui_type: vendor-specific OUI type (must be < 0xff), negative means any
+ * @ies: data consisting of IEs
+ * @len: length of data
+ *
+ * Return: %NULL if the vendor specific element ID could not be found or if the
+ * element is invalid (claims to be longer than the given data), or a pointer to
+ * the first byte of the requested element, that is the byte containing the
+ * element ID.
+ *
+ * Note: There are no checks on the element length other than having to fit into
+ * the given data.
+ */
+static inline const u8 *
+cfg80211_find_vendor_ie(unsigned int oui, int oui_type,
+			const u8 *ies, unsigned int len)
+{
+	return (void *)cfg80211_find_vendor_elem(oui, oui_type, ies, len);
+}
+
+/**
+ * cfg80211_send_layer2_update - send layer 2 update frame
+ *
+ * @dev: network device
+ * @addr: STA MAC address
+ *
+ * Wireless drivers can use this function to update forwarding tables in bridge
+ * devices upon STA association.
+ */
+void cfg80211_send_layer2_update(struct net_device *dev, const u8 *addr);
+
+/**
+ * DOC: Regulatory enforcement infrastructure
+ *
+ * TODO
+ */
+
+/**
+ * regulatory_hint - driver hint to the wireless core a regulatory domain
+ * @wiphy: the wireless device giving the hint (used only for reporting
+ *	conflicts)
+ * @alpha2: the ISO/IEC 3166 alpha2 the driver claims its regulatory domain
+ * 	should be in. If @rd is set this should be NULL. Note that if you
+ * 	set this to NULL you should still set rd->alpha2 to some accepted
+ * 	alpha2.
+ *
+ * Wireless drivers can use this function to hint to the wireless core
+ * what it believes should be the current regulatory domain by
+ * giving it an ISO/IEC 3166 alpha2 country code it knows its regulatory
+ * domain should be in or by providing a completely build regulatory domain.
+ * If the driver provides an ISO/IEC 3166 alpha2 userspace will be queried
+ * for a regulatory domain structure for the respective country.
+ *
+ * The wiphy must have been registered to cfg80211 prior to this call.
+ * For cfg80211 drivers this means you must first use wiphy_register(),
+ * for mac80211 drivers you must first use ieee80211_register_hw().
+ *
+ * Drivers should check the return value, its possible you can get
+ * an -ENOMEM.
+ *
+ * Return: 0 on success. -ENOMEM.
+ */
+int regulatory_hint(struct wiphy *wiphy, const char *alpha2);
+
+/**
+ * regulatory_set_wiphy_regd - set regdom info for self managed drivers
+ * @wiphy: the wireless device we want to process the regulatory domain on
+ * @rd: the regulatory domain informatoin to use for this wiphy
+ *
+ * Set the regulatory domain information for self-managed wiphys, only they
+ * may use this function. See %REGULATORY_WIPHY_SELF_MANAGED for more
+ * information.
+ *
+ * Return: 0 on success. -EINVAL, -EPERM
+ */
+int regulatory_set_wiphy_regd(struct wiphy *wiphy,
+			      struct ieee80211_regdomain *rd);
+
+/**
+ * regulatory_set_wiphy_regd_sync_rtnl - set regdom for self-managed drivers
+ * @wiphy: the wireless device we want to process the regulatory domain on
+ * @rd: the regulatory domain information to use for this wiphy
+ *
+ * This functions requires the RTNL to be held and applies the new regdomain
+ * synchronously to this wiphy. For more details see
+ * regulatory_set_wiphy_regd().
+ *
+ * Return: 0 on success. -EINVAL, -EPERM
+ */
+int regulatory_set_wiphy_regd_sync_rtnl(struct wiphy *wiphy,
+					struct ieee80211_regdomain *rd);
+
+/**
+ * wiphy_apply_custom_regulatory - apply a custom driver regulatory domain
+ * @wiphy: the wireless device we want to process the regulatory domain on
+ * @regd: the custom regulatory domain to use for this wiphy
+ *
+ * Drivers can sometimes have custom regulatory domains which do not apply
+ * to a specific country. Drivers can use this to apply such custom regulatory
+ * domains. This routine must be called prior to wiphy registration. The
+ * custom regulatory domain will be trusted completely and as such previous
+ * default channel settings will be disregarded. If no rule is found for a
+ * channel on the regulatory domain the channel will be disabled.
+ * Drivers using this for a wiphy should also set the wiphy flag
+ * REGULATORY_CUSTOM_REG or cfg80211 will set it for the wiphy
+ * that called this helper.
+ */
+void wiphy_apply_custom_regulatory(struct wiphy *wiphy,
+				   const struct ieee80211_regdomain *regd);
+
+/**
+ * freq_reg_info - get regulatory information for the given frequency
+ * @wiphy: the wiphy for which we want to process this rule for
+ * @center_freq: Frequency in KHz for which we want regulatory information for
+ *
+ * Use this function to get the regulatory rule for a specific frequency on
+ * a given wireless device. If the device has a specific regulatory domain
+ * it wants to follow we respect that unless a country IE has been received
+ * and processed already.
+ *
+ * Return: A valid pointer, or, when an error occurs, for example if no rule
+ * can be found, the return value is encoded using ERR_PTR(). Use IS_ERR() to
+ * check and PTR_ERR() to obtain the numeric return value. The numeric return
+ * value will be -ERANGE if we determine the given center_freq does not even
+ * have a regulatory rule for a frequency range in the center_freq's band.
+ * See freq_in_rule_band() for our current definition of a band -- this is
+ * purely subjective and right now it's 802.11 specific.
+ */
+const struct ieee80211_reg_rule *freq_reg_info(struct wiphy *wiphy,
+					       u32 center_freq);
+
+/**
+ * reg_initiator_name - map regulatory request initiator enum to name
+ * @initiator: the regulatory request initiator
+ *
+ * You can use this to map the regulatory request initiator enum to a
+ * proper string representation.
+ */
+const char *reg_initiator_name(enum nl80211_reg_initiator initiator);
+
+/**
+ * regulatory_pre_cac_allowed - check if pre-CAC allowed in the current regdom
+ * @wiphy: wiphy for which pre-CAC capability is checked.
+ *
+ * Pre-CAC is allowed only in some regdomains (notable ETSI).
+ */
+bool regulatory_pre_cac_allowed(struct wiphy *wiphy);
+
+/**
+ * DOC: Internal regulatory db functions
+ *
+ */
+
+/**
+ * reg_query_regdb_wmm -  Query internal regulatory db for wmm rule
+ * Regulatory self-managed driver can use it to proactively
+ *
+ * @alpha2: the ISO/IEC 3166 alpha2 wmm rule to be queried.
+ * @freq: the freqency(in MHz) to be queried.
+ * @rule: pointer to store the wmm rule from the regulatory db.
+ *
+ * Self-managed wireless drivers can use this function to  query
+ * the internal regulatory database to check whether the given
+ * ISO/IEC 3166 alpha2 country and freq have wmm rule limitations.
+ *
+ * Drivers should check the return value, its possible you can get
+ * an -ENODATA.
+ *
+ * Return: 0 on success. -ENODATA.
+ */
+int reg_query_regdb_wmm(char *alpha2, int freq,
+			struct ieee80211_reg_rule *rule);
+
+/*
+ * callbacks for asynchronous cfg80211 methods, notification
+ * functions and BSS handling helpers
+ */
+
+/**
+ * cfg80211_scan_done - notify that scan finished
+ *
+ * @request: the corresponding scan request
+ * @info: information about the completed scan
+ */
+void cfg80211_scan_done(struct cfg80211_scan_request *request,
+			struct cfg80211_scan_info *info);
+
+/**
+ * cfg80211_sched_scan_results - notify that new scan results are available
+ *
+ * @wiphy: the wiphy which got scheduled scan results
+ * @reqid: identifier for the related scheduled scan request
+ */
+void cfg80211_sched_scan_results(struct wiphy *wiphy, u64 reqid);
+
+/**
+ * cfg80211_sched_scan_stopped - notify that the scheduled scan has stopped
+ *
+ * @wiphy: the wiphy on which the scheduled scan stopped
+ * @reqid: identifier for the related scheduled scan request
+ *
+ * The driver can call this function to inform cfg80211 that the
+ * scheduled scan had to be stopped, for whatever reason.  The driver
+ * is then called back via the sched_scan_stop operation when done.
+ */
+void cfg80211_sched_scan_stopped(struct wiphy *wiphy, u64 reqid);
+
+/**
+ * cfg80211_sched_scan_stopped_rtnl - notify that the scheduled scan has stopped
+ *
+ * @wiphy: the wiphy on which the scheduled scan stopped
+ * @reqid: identifier for the related scheduled scan request
+ *
+ * The driver can call this function to inform cfg80211 that the
+ * scheduled scan had to be stopped, for whatever reason.  The driver
+ * is then called back via the sched_scan_stop operation when done.
+ * This function should be called with rtnl locked.
+ */
+void cfg80211_sched_scan_stopped_rtnl(struct wiphy *wiphy, u64 reqid);
+
+/**
+ * cfg80211_inform_bss_frame_data - inform cfg80211 of a received BSS frame
+ * @wiphy: the wiphy reporting the BSS
+ * @data: the BSS metadata
+ * @mgmt: the management frame (probe response or beacon)
+ * @len: length of the management frame
+ * @gfp: context flags
+ *
+ * This informs cfg80211 that BSS information was found and
+ * the BSS should be updated/added.
+ *
+ * Return: A referenced struct, must be released with cfg80211_put_bss()!
+ * Or %NULL on error.
+ */
+struct cfg80211_bss * __must_check
+cfg80211_inform_bss_frame_data(struct wiphy *wiphy,
+			       struct cfg80211_inform_bss *data,
+			       struct ieee80211_mgmt *mgmt, size_t len,
+			       gfp_t gfp);
+
+static inline struct cfg80211_bss * __must_check
+cfg80211_inform_bss_width_frame(struct wiphy *wiphy,
+				struct ieee80211_channel *rx_channel,
+				enum nl80211_bss_scan_width scan_width,
+				struct ieee80211_mgmt *mgmt, size_t len,
+				s32 signal, gfp_t gfp)
+{
+	struct cfg80211_inform_bss data = {
+		.chan = rx_channel,
+		.scan_width = scan_width,
+		.signal = signal,
+	};
+
+	return cfg80211_inform_bss_frame_data(wiphy, &data, mgmt, len, gfp);
+}
+
+static inline struct cfg80211_bss * __must_check
+cfg80211_inform_bss_frame(struct wiphy *wiphy,
+			  struct ieee80211_channel *rx_channel,
+			  struct ieee80211_mgmt *mgmt, size_t len,
+			  s32 signal, gfp_t gfp)
+{
+	struct cfg80211_inform_bss data = {
+		.chan = rx_channel,
+		.scan_width = NL80211_BSS_CHAN_WIDTH_20,
+		.signal = signal,
+	};
+
+	return cfg80211_inform_bss_frame_data(wiphy, &data, mgmt, len, gfp);
+}
+
+/**
+ * cfg80211_gen_new_bssid - generate a nontransmitted BSSID for multi-BSSID
+ * @bssid: transmitter BSSID
+ * @max_bssid: max BSSID indicator, taken from Multiple BSSID element
+ * @mbssid_index: BSSID index, taken from Multiple BSSID index element
+ * @new_bssid: calculated nontransmitted BSSID
+ */
+static inline void cfg80211_gen_new_bssid(const u8 *bssid, u8 max_bssid,
+					  u8 mbssid_index, u8 *new_bssid)
+{
+	u64 bssid_u64 = ether_addr_to_u64(bssid);
+	u64 mask = GENMASK_ULL(max_bssid - 1, 0);
+	u64 new_bssid_u64;
+
+	new_bssid_u64 = bssid_u64 & ~mask;
+
+	new_bssid_u64 |= ((bssid_u64 & mask) + mbssid_index) & mask;
+
+	u64_to_ether_addr(new_bssid_u64, new_bssid);
+}
+
+/**
+ * cfg80211_is_element_inherited - returns if element ID should be inherited
+ * @element: element to check
+ * @non_inherit_element: non inheritance element
+ */
+bool cfg80211_is_element_inherited(const struct element *element,
+				   const struct element *non_inherit_element);
+
+/**
+ * cfg80211_merge_profile - merges a MBSSID profile if it is split between IEs
+ * @ie: ies
+ * @ielen: length of IEs
+ * @mbssid_elem: current MBSSID element
+ * @sub_elem: current MBSSID subelement (profile)
+ * @merged_ie: location of the merged profile
+ * @max_copy_len: max merged profile length
+ */
+size_t cfg80211_merge_profile(const u8 *ie, size_t ielen,
+			      const struct element *mbssid_elem,
+			      const struct element *sub_elem,
+			      u8 *merged_ie, size_t max_copy_len);
+
+/**
+ * enum cfg80211_bss_frame_type - frame type that the BSS data came from
+ * @CFG80211_BSS_FTYPE_UNKNOWN: driver doesn't know whether the data is
+ *	from a beacon or probe response
+ * @CFG80211_BSS_FTYPE_BEACON: data comes from a beacon
+ * @CFG80211_BSS_FTYPE_PRESP: data comes from a probe response
+ */
+enum cfg80211_bss_frame_type {
+	CFG80211_BSS_FTYPE_UNKNOWN,
+	CFG80211_BSS_FTYPE_BEACON,
+	CFG80211_BSS_FTYPE_PRESP,
+};
+
+/**
+ * cfg80211_inform_bss_data - inform cfg80211 of a new BSS
+ *
+ * @wiphy: the wiphy reporting the BSS
+ * @data: the BSS metadata
+ * @ftype: frame type (if known)
+ * @bssid: the BSSID of the BSS
+ * @tsf: the TSF sent by the peer in the beacon/probe response (or 0)
+ * @capability: the capability field sent by the peer
+ * @beacon_interval: the beacon interval announced by the peer
+ * @ie: additional IEs sent by the peer
+ * @ielen: length of the additional IEs
+ * @gfp: context flags
+ *
+ * This informs cfg80211 that BSS information was found and
+ * the BSS should be updated/added.
+ *
+ * Return: A referenced struct, must be released with cfg80211_put_bss()!
+ * Or %NULL on error.
+ */
+struct cfg80211_bss * __must_check
+cfg80211_inform_bss_data(struct wiphy *wiphy,
+			 struct cfg80211_inform_bss *data,
+			 enum cfg80211_bss_frame_type ftype,
+			 const u8 *bssid, u64 tsf, u16 capability,
+			 u16 beacon_interval, const u8 *ie, size_t ielen,
+			 gfp_t gfp);
+
+static inline struct cfg80211_bss * __must_check
+cfg80211_inform_bss_width(struct wiphy *wiphy,
+			  struct ieee80211_channel *rx_channel,
+			  enum nl80211_bss_scan_width scan_width,
+			  enum cfg80211_bss_frame_type ftype,
+			  const u8 *bssid, u64 tsf, u16 capability,
+			  u16 beacon_interval, const u8 *ie, size_t ielen,
+			  s32 signal, gfp_t gfp)
+{
+	struct cfg80211_inform_bss data = {
+		.chan = rx_channel,
+		.scan_width = scan_width,
+		.signal = signal,
+	};
+
+	return cfg80211_inform_bss_data(wiphy, &data, ftype, bssid, tsf,
+					capability, beacon_interval, ie, ielen,
+					gfp);
+}
+
+static inline struct cfg80211_bss * __must_check
+cfg80211_inform_bss(struct wiphy *wiphy,
+		    struct ieee80211_channel *rx_channel,
+		    enum cfg80211_bss_frame_type ftype,
+		    const u8 *bssid, u64 tsf, u16 capability,
+		    u16 beacon_interval, const u8 *ie, size_t ielen,
+		    s32 signal, gfp_t gfp)
+{
+	struct cfg80211_inform_bss data = {
+		.chan = rx_channel,
+		.scan_width = NL80211_BSS_CHAN_WIDTH_20,
+		.signal = signal,
+	};
+
+	return cfg80211_inform_bss_data(wiphy, &data, ftype, bssid, tsf,
+					capability, beacon_interval, ie, ielen,
+					gfp);
+}
+
+/**
+ * cfg80211_get_bss - get a BSS reference
+ * @wiphy: the wiphy this BSS struct belongs to
+ * @channel: the channel to search on (or %NULL)
+ * @bssid: the desired BSSID (or %NULL)
+ * @ssid: the desired SSID (or %NULL)
+ * @ssid_len: length of the SSID (or 0)
+ * @bss_type: type of BSS, see &enum ieee80211_bss_type
+ * @privacy: privacy filter, see &enum ieee80211_privacy
+ */
+struct cfg80211_bss *cfg80211_get_bss(struct wiphy *wiphy,
+				      struct ieee80211_channel *channel,
+				      const u8 *bssid,
+				      const u8 *ssid, size_t ssid_len,
+				      enum ieee80211_bss_type bss_type,
+				      enum ieee80211_privacy privacy);
+static inline struct cfg80211_bss *
+cfg80211_get_ibss(struct wiphy *wiphy,
+		  struct ieee80211_channel *channel,
+		  const u8 *ssid, size_t ssid_len)
+{
+	return cfg80211_get_bss(wiphy, channel, NULL, ssid, ssid_len,
+				IEEE80211_BSS_TYPE_IBSS,
+				IEEE80211_PRIVACY_ANY);
+}
+
+/**
+ * cfg80211_ref_bss - reference BSS struct
+ * @wiphy: the wiphy this BSS struct belongs to
+ * @bss: the BSS struct to reference
+ *
+ * Increments the refcount of the given BSS struct.
+ */
+void cfg80211_ref_bss(struct wiphy *wiphy, struct cfg80211_bss *bss);
+
+/**
+ * cfg80211_put_bss - unref BSS struct
+ * @wiphy: the wiphy this BSS struct belongs to
+ * @bss: the BSS struct
+ *
+ * Decrements the refcount of the given BSS struct.
+ */
+void cfg80211_put_bss(struct wiphy *wiphy, struct cfg80211_bss *bss);
+
+/**
+ * cfg80211_unlink_bss - unlink BSS from internal data structures
+ * @wiphy: the wiphy
+ * @bss: the bss to remove
+ *
+ * This function removes the given BSS from the internal data structures
+ * thereby making it no longer show up in scan results etc. Use this
+ * function when you detect a BSS is gone. Normally BSSes will also time
+ * out, so it is not necessary to use this function at all.
+ */
+void cfg80211_unlink_bss(struct wiphy *wiphy, struct cfg80211_bss *bss);
+
+/**
+ * cfg80211_bss_iter - iterate all BSS entries
+ *
+ * This function iterates over the BSS entries associated with the given wiphy
+ * and calls the callback for the iterated BSS. The iterator function is not
+ * allowed to call functions that might modify the internal state of the BSS DB.
+ *
+ * @wiphy: the wiphy
+ * @chandef: if given, the iterator function will be called only if the channel
+ *     of the currently iterated BSS is a subset of the given channel.
+ * @iter: the iterator function to call
+ * @iter_data: an argument to the iterator function
+ */
+void cfg80211_bss_iter(struct wiphy *wiphy,
+		       struct cfg80211_chan_def *chandef,
+		       void (*iter)(struct wiphy *wiphy,
+				    struct cfg80211_bss *bss,
+				    void *data),
+		       void *iter_data);
+
+static inline enum nl80211_bss_scan_width
+cfg80211_chandef_to_scan_width(const struct cfg80211_chan_def *chandef)
+{
+	switch (chandef->width) {
+	case NL80211_CHAN_WIDTH_5:
+		return NL80211_BSS_CHAN_WIDTH_5;
+	case NL80211_CHAN_WIDTH_10:
+		return NL80211_BSS_CHAN_WIDTH_10;
+	default:
+		return NL80211_BSS_CHAN_WIDTH_20;
+	}
+}
+
+/**
+ * cfg80211_rx_mlme_mgmt - notification of processed MLME management frame
+ * @dev: network device
+ * @buf: authentication frame (header + body)
+ * @len: length of the frame data
+ *
+ * This function is called whenever an authentication, disassociation or
+ * deauthentication frame has been received and processed in station mode.
+ * After being asked to authenticate via cfg80211_ops::auth() the driver must
+ * call either this function or cfg80211_auth_timeout().
+ * After being asked to associate via cfg80211_ops::assoc() the driver must
+ * call either this function or cfg80211_auth_timeout().
+ * While connected, the driver must calls this for received and processed
+ * disassociation and deauthentication frames. If the frame couldn't be used
+ * because it was unprotected, the driver must call the function
+ * cfg80211_rx_unprot_mlme_mgmt() instead.
+ *
+ * This function may sleep. The caller must hold the corresponding wdev's mutex.
+ */
+void cfg80211_rx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len);
+
+/**
+ * cfg80211_auth_timeout - notification of timed out authentication
+ * @dev: network device
+ * @addr: The MAC address of the device with which the authentication timed out
+ *
+ * This function may sleep. The caller must hold the corresponding wdev's
+ * mutex.
+ */
+void cfg80211_auth_timeout(struct net_device *dev, const u8 *addr);
+
+/**
+ * cfg80211_rx_assoc_resp - notification of processed association response
+ * @dev: network device
+ * @bss: the BSS that association was requested with, ownership of the pointer
+ *	moves to cfg80211 in this call
+ * @buf: (Re)Association Response frame (header + body)
+ * @len: length of the frame data
+ * @uapsd_queues: bitmap of queues configured for uapsd. Same format
+ *	as the AC bitmap in the QoS info field
+ * @req_ies: information elements from the (Re)Association Request frame
+ * @req_ies_len: length of req_ies data
+ *
+ * After being asked to associate via cfg80211_ops::assoc() the driver must
+ * call either this function or cfg80211_auth_timeout().
+ *
+ * This function may sleep. The caller must hold the corresponding wdev's mutex.
+ */
+void cfg80211_rx_assoc_resp(struct net_device *dev,
+			    struct cfg80211_bss *bss,
+			    const u8 *buf, size_t len,
+			    int uapsd_queues,
+			    const u8 *req_ies, size_t req_ies_len);
+
+/**
+ * cfg80211_assoc_timeout - notification of timed out association
+ * @dev: network device
+ * @bss: The BSS entry with which association timed out.
+ *
+ * This function may sleep. The caller must hold the corresponding wdev's mutex.
+ */
+void cfg80211_assoc_timeout(struct net_device *dev, struct cfg80211_bss *bss);
+
+/**
+ * cfg80211_abandon_assoc - notify cfg80211 of abandoned association attempt
+ * @dev: network device
+ * @bss: The BSS entry with which association was abandoned.
+ *
+ * Call this whenever - for reasons reported through other API, like deauth RX,
+ * an association attempt was abandoned.
+ * This function may sleep. The caller must hold the corresponding wdev's mutex.
+ */
+void cfg80211_abandon_assoc(struct net_device *dev, struct cfg80211_bss *bss);
+
+/**
+ * cfg80211_tx_mlme_mgmt - notification of transmitted deauth/disassoc frame
+ * @dev: network device
+ * @buf: 802.11 frame (header + body)
+ * @len: length of the frame data
+ *
+ * This function is called whenever deauthentication has been processed in
+ * station mode. This includes both received deauthentication frames and
+ * locally generated ones. This function may sleep. The caller must hold the
+ * corresponding wdev's mutex.
+ */
+void cfg80211_tx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len);
+
+/**
+ * cfg80211_rx_unprot_mlme_mgmt - notification of unprotected mlme mgmt frame
+ * @dev: network device
+ * @buf: deauthentication frame (header + body)
+ * @len: length of the frame data
+ *
+ * This function is called whenever a received deauthentication or dissassoc
+ * frame has been dropped in station mode because of MFP being used but the
+ * frame was not protected. This function may sleep.
+ */
+void cfg80211_rx_unprot_mlme_mgmt(struct net_device *dev,
+				  const u8 *buf, size_t len);
+
+/**
+ * cfg80211_michael_mic_failure - notification of Michael MIC failure (TKIP)
+ * @dev: network device
+ * @addr: The source MAC address of the frame
+ * @key_type: The key type that the received frame used
+ * @key_id: Key identifier (0..3). Can be -1 if missing.
+ * @tsc: The TSC value of the frame that generated the MIC failure (6 octets)
+ * @gfp: allocation flags
+ *
+ * This function is called whenever the local MAC detects a MIC failure in a
+ * received frame. This matches with MLME-MICHAELMICFAILURE.indication()
+ * primitive.
+ */
+void cfg80211_michael_mic_failure(struct net_device *dev, const u8 *addr,
+				  enum nl80211_key_type key_type, int key_id,
+				  const u8 *tsc, gfp_t gfp);
+
+/**
+ * cfg80211_ibss_joined - notify cfg80211 that device joined an IBSS
+ *
+ * @dev: network device
+ * @bssid: the BSSID of the IBSS joined
+ * @channel: the channel of the IBSS joined
+ * @gfp: allocation flags
+ *
+ * This function notifies cfg80211 that the device joined an IBSS or
+ * switched to a different BSSID. Before this function can be called,
+ * either a beacon has to have been received from the IBSS, or one of
+ * the cfg80211_inform_bss{,_frame} functions must have been called
+ * with the locally generated beacon -- this guarantees that there is
+ * always a scan result for this IBSS. cfg80211 will handle the rest.
+ */
+void cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid,
+			  struct ieee80211_channel *channel, gfp_t gfp);
+
+/**
+ * cfg80211_notify_new_candidate - notify cfg80211 of a new mesh peer candidate
+ *
+ * @dev: network device
+ * @macaddr: the MAC address of the new candidate
+ * @ie: information elements advertised by the peer candidate
+ * @ie_len: length of the information elements buffer
+ * @gfp: allocation flags
+ *
+ * This function notifies cfg80211 that the mesh peer candidate has been
+ * detected, most likely via a beacon or, less likely, via a probe response.
+ * cfg80211 then sends a notification to userspace.
+ */
+void cfg80211_notify_new_peer_candidate(struct net_device *dev,
+		const u8 *macaddr, const u8 *ie, u8 ie_len,
+		int sig_dbm, gfp_t gfp);
+
+/**
+ * DOC: RFkill integration
+ *
+ * RFkill integration in cfg80211 is almost invisible to drivers,
+ * as cfg80211 automatically registers an rfkill instance for each
+ * wireless device it knows about. Soft kill is also translated
+ * into disconnecting and turning all interfaces off, drivers are
+ * expected to turn off the device when all interfaces are down.
+ *
+ * However, devices may have a hard RFkill line, in which case they
+ * also need to interact with the rfkill subsystem, via cfg80211.
+ * They can do this with a few helper functions documented here.
+ */
+
+/**
+ * wiphy_rfkill_set_hw_state - notify cfg80211 about hw block state
+ * @wiphy: the wiphy
+ * @blocked: block status
+ */
+void wiphy_rfkill_set_hw_state(struct wiphy *wiphy, bool blocked);
+
+/**
+ * wiphy_rfkill_start_polling - start polling rfkill
+ * @wiphy: the wiphy
+ */
+void wiphy_rfkill_start_polling(struct wiphy *wiphy);
+
+/**
+ * wiphy_rfkill_stop_polling - stop polling rfkill
+ * @wiphy: the wiphy
+ */
+void wiphy_rfkill_stop_polling(struct wiphy *wiphy);
+
+/**
+ * DOC: Vendor commands
+ *
+ * Occasionally, there are special protocol or firmware features that
+ * can't be implemented very openly. For this and similar cases, the
+ * vendor command functionality allows implementing the features with
+ * (typically closed-source) userspace and firmware, using nl80211 as
+ * the configuration mechanism.
+ *
+ * A driver supporting vendor commands must register them as an array
+ * in struct wiphy, with handlers for each one, each command has an
+ * OUI and sub command ID to identify it.
+ *
+ * Note that this feature should not be (ab)used to implement protocol
+ * features that could openly be shared across drivers. In particular,
+ * it must never be required to use vendor commands to implement any
+ * "normal" functionality that higher-level userspace like connection
+ * managers etc. need.
+ */
+
+struct sk_buff *__cfg80211_alloc_reply_skb(struct wiphy *wiphy,
+					   enum nl80211_commands cmd,
+					   enum nl80211_attrs attr,
+					   int approxlen);
+
+struct sk_buff *__cfg80211_alloc_event_skb(struct wiphy *wiphy,
+					   struct wireless_dev *wdev,
+					   enum nl80211_commands cmd,
+					   enum nl80211_attrs attr,
+					   unsigned int portid,
+					   int vendor_event_idx,
+					   int approxlen, gfp_t gfp);
+
+void __cfg80211_send_event_skb(struct sk_buff *skb, gfp_t gfp);
+
+/**
+ * cfg80211_vendor_cmd_alloc_reply_skb - allocate vendor command reply
+ * @wiphy: the wiphy
+ * @approxlen: an upper bound of the length of the data that will
+ *	be put into the skb
+ *
+ * This function allocates and pre-fills an skb for a reply to
+ * a vendor command. Since it is intended for a reply, calling
+ * it outside of a vendor command's doit() operation is invalid.
+ *
+ * The returned skb is pre-filled with some identifying data in
+ * a way that any data that is put into the skb (with skb_put(),
+ * nla_put() or similar) will end up being within the
+ * %NL80211_ATTR_VENDOR_DATA attribute, so all that needs to be done
+ * with the skb is adding data for the corresponding userspace tool
+ * which can then read that data out of the vendor data attribute.
+ * You must not modify the skb in any other way.
+ *
+ * When done, call cfg80211_vendor_cmd_reply() with the skb and return
+ * its error code as the result of the doit() operation.
+ *
+ * Return: An allocated and pre-filled skb. %NULL if any errors happen.
+ */
+static inline struct sk_buff *
+cfg80211_vendor_cmd_alloc_reply_skb(struct wiphy *wiphy, int approxlen)
+{
+	return __cfg80211_alloc_reply_skb(wiphy, NL80211_CMD_VENDOR,
+					  NL80211_ATTR_VENDOR_DATA, approxlen);
+}
+
+/**
+ * cfg80211_vendor_cmd_reply - send the reply skb
+ * @skb: The skb, must have been allocated with
+ *	cfg80211_vendor_cmd_alloc_reply_skb()
+ *
+ * Since calling this function will usually be the last thing
+ * before returning from the vendor command doit() you should
+ * return the error code.  Note that this function consumes the
+ * skb regardless of the return value.
+ *
+ * Return: An error code or 0 on success.
+ */
+int cfg80211_vendor_cmd_reply(struct sk_buff *skb);
+
+/**
+ * cfg80211_vendor_cmd_get_sender
+ * @wiphy: the wiphy
+ *
+ * Return the current netlink port ID in a vendor command handler.
+ * Valid to call only there.
+ */
+unsigned int cfg80211_vendor_cmd_get_sender(struct wiphy *wiphy);
+
+/**
+ * cfg80211_vendor_event_alloc - allocate vendor-specific event skb
+ * @wiphy: the wiphy
+ * @wdev: the wireless device
+ * @event_idx: index of the vendor event in the wiphy's vendor_events
+ * @approxlen: an upper bound of the length of the data that will
+ *	be put into the skb
+ * @gfp: allocation flags
+ *
+ * This function allocates and pre-fills an skb for an event on the
+ * vendor-specific multicast group.
+ *
+ * If wdev != NULL, both the ifindex and identifier of the specified
+ * wireless device are added to the event message before the vendor data
+ * attribute.
+ *
+ * When done filling the skb, call cfg80211_vendor_event() with the
+ * skb to send the event.
+ *
+ * Return: An allocated and pre-filled skb. %NULL if any errors happen.
+ */
+static inline struct sk_buff *
+cfg80211_vendor_event_alloc(struct wiphy *wiphy, struct wireless_dev *wdev,
+			     int approxlen, int event_idx, gfp_t gfp)
+{
+	return __cfg80211_alloc_event_skb(wiphy, wdev, NL80211_CMD_VENDOR,
+					  NL80211_ATTR_VENDOR_DATA,
+					  0, event_idx, approxlen, gfp);
+}
+
+/**
+ * cfg80211_vendor_event_alloc_ucast - alloc unicast vendor-specific event skb
+ * @wiphy: the wiphy
+ * @wdev: the wireless device
+ * @event_idx: index of the vendor event in the wiphy's vendor_events
+ * @portid: port ID of the receiver
+ * @approxlen: an upper bound of the length of the data that will
+ *	be put into the skb
+ * @gfp: allocation flags
+ *
+ * This function allocates and pre-fills an skb for an event to send to
+ * a specific (userland) socket. This socket would previously have been
+ * obtained by cfg80211_vendor_cmd_get_sender(), and the caller MUST take
+ * care to register a netlink notifier to see when the socket closes.
+ *
+ * If wdev != NULL, both the ifindex and identifier of the specified
+ * wireless device are added to the event message before the vendor data
+ * attribute.
+ *
+ * When done filling the skb, call cfg80211_vendor_event() with the
+ * skb to send the event.
+ *
+ * Return: An allocated and pre-filled skb. %NULL if any errors happen.
+ */
+static inline struct sk_buff *
+cfg80211_vendor_event_alloc_ucast(struct wiphy *wiphy,
+				  struct wireless_dev *wdev,
+				  unsigned int portid, int approxlen,
+				  int event_idx, gfp_t gfp)
+{
+	return __cfg80211_alloc_event_skb(wiphy, wdev, NL80211_CMD_VENDOR,
+					  NL80211_ATTR_VENDOR_DATA,
+					  portid, event_idx, approxlen, gfp);
+}
+
+/**
+ * cfg80211_vendor_event - send the event
+ * @skb: The skb, must have been allocated with cfg80211_vendor_event_alloc()
+ * @gfp: allocation flags
+ *
+ * This function sends the given @skb, which must have been allocated
+ * by cfg80211_vendor_event_alloc(), as an event. It always consumes it.
+ */
+static inline void cfg80211_vendor_event(struct sk_buff *skb, gfp_t gfp)
+{
+	__cfg80211_send_event_skb(skb, gfp);
+}
+
+#ifdef CONFIG_NL80211_TESTMODE
+/**
+ * DOC: Test mode
+ *
+ * Test mode is a set of utility functions to allow drivers to
+ * interact with driver-specific tools to aid, for instance,
+ * factory programming.
+ *
+ * This chapter describes how drivers interact with it, for more
+ * information see the nl80211 book's chapter on it.
+ */
+
+/**
+ * cfg80211_testmode_alloc_reply_skb - allocate testmode reply
+ * @wiphy: the wiphy
+ * @approxlen: an upper bound of the length of the data that will
+ *	be put into the skb
+ *
+ * This function allocates and pre-fills an skb for a reply to
+ * the testmode command. Since it is intended for a reply, calling
+ * it outside of the @testmode_cmd operation is invalid.
+ *
+ * The returned skb is pre-filled with the wiphy index and set up in
+ * a way that any data that is put into the skb (with skb_put(),
+ * nla_put() or similar) will end up being within the
+ * %NL80211_ATTR_TESTDATA attribute, so all that needs to be done
+ * with the skb is adding data for the corresponding userspace tool
+ * which can then read that data out of the testdata attribute. You
+ * must not modify the skb in any other way.
+ *
+ * When done, call cfg80211_testmode_reply() with the skb and return
+ * its error code as the result of the @testmode_cmd operation.
+ *
+ * Return: An allocated and pre-filled skb. %NULL if any errors happen.
+ */
+static inline struct sk_buff *
+cfg80211_testmode_alloc_reply_skb(struct wiphy *wiphy, int approxlen)
+{
+	return __cfg80211_alloc_reply_skb(wiphy, NL80211_CMD_TESTMODE,
+					  NL80211_ATTR_TESTDATA, approxlen);
+}
+
+/**
+ * cfg80211_testmode_reply - send the reply skb
+ * @skb: The skb, must have been allocated with
+ *	cfg80211_testmode_alloc_reply_skb()
+ *
+ * Since calling this function will usually be the last thing
+ * before returning from the @testmode_cmd you should return
+ * the error code.  Note that this function consumes the skb
+ * regardless of the return value.
+ *
+ * Return: An error code or 0 on success.
+ */
+static inline int cfg80211_testmode_reply(struct sk_buff *skb)
+{
+	return cfg80211_vendor_cmd_reply(skb);
+}
+
+/**
+ * cfg80211_testmode_alloc_event_skb - allocate testmode event
+ * @wiphy: the wiphy
+ * @approxlen: an upper bound of the length of the data that will
+ *	be put into the skb
+ * @gfp: allocation flags
+ *
+ * This function allocates and pre-fills an skb for an event on the
+ * testmode multicast group.
+ *
+ * The returned skb is set up in the same way as with
+ * cfg80211_testmode_alloc_reply_skb() but prepared for an event. As
+ * there, you should simply add data to it that will then end up in the
+ * %NL80211_ATTR_TESTDATA attribute. Again, you must not modify the skb
+ * in any other way.
+ *
+ * When done filling the skb, call cfg80211_testmode_event() with the
+ * skb to send the event.
+ *
+ * Return: An allocated and pre-filled skb. %NULL if any errors happen.
+ */
+static inline struct sk_buff *
+cfg80211_testmode_alloc_event_skb(struct wiphy *wiphy, int approxlen, gfp_t gfp)
+{
+	return __cfg80211_alloc_event_skb(wiphy, NULL, NL80211_CMD_TESTMODE,
+					  NL80211_ATTR_TESTDATA, 0, -1,
+					  approxlen, gfp);
+}
+
+/**
+ * cfg80211_testmode_event - send the event
+ * @skb: The skb, must have been allocated with
+ *	cfg80211_testmode_alloc_event_skb()
+ * @gfp: allocation flags
+ *
+ * This function sends the given @skb, which must have been allocated
+ * by cfg80211_testmode_alloc_event_skb(), as an event. It always
+ * consumes it.
+ */
+static inline void cfg80211_testmode_event(struct sk_buff *skb, gfp_t gfp)
+{
+	__cfg80211_send_event_skb(skb, gfp);
+}
+
+#define CFG80211_TESTMODE_CMD(cmd)	.testmode_cmd = (cmd),
+#define CFG80211_TESTMODE_DUMP(cmd)	.testmode_dump = (cmd),
+#else
+#define CFG80211_TESTMODE_CMD(cmd)
+#define CFG80211_TESTMODE_DUMP(cmd)
+#endif
+
+/**
+ * struct cfg80211_fils_resp_params - FILS connection response params
+ * @kek: KEK derived from a successful FILS connection (may be %NULL)
+ * @kek_len: Length of @fils_kek in octets
+ * @update_erp_next_seq_num: Boolean value to specify whether the value in
+ *	@erp_next_seq_num is valid.
+ * @erp_next_seq_num: The next sequence number to use in ERP message in
+ *	FILS Authentication. This value should be specified irrespective of the
+ *	status for a FILS connection.
+ * @pmk: A new PMK if derived from a successful FILS connection (may be %NULL).
+ * @pmk_len: Length of @pmk in octets
+ * @pmkid: A new PMKID if derived from a successful FILS connection or the PMKID
+ *	used for this FILS connection (may be %NULL).
+ */
+struct cfg80211_fils_resp_params {
+	const u8 *kek;
+	size_t kek_len;
+	bool update_erp_next_seq_num;
+	u16 erp_next_seq_num;
+	const u8 *pmk;
+	size_t pmk_len;
+	const u8 *pmkid;
+};
+
+/**
+ * struct cfg80211_connect_resp_params - Connection response params
+ * @status: Status code, %WLAN_STATUS_SUCCESS for successful connection, use
+ *	%WLAN_STATUS_UNSPECIFIED_FAILURE if your device cannot give you
+ *	the real status code for failures. If this call is used to report a
+ *	failure due to a timeout (e.g., not receiving an Authentication frame
+ *	from the AP) instead of an explicit rejection by the AP, -1 is used to
+ *	indicate that this is a failure, but without a status code.
+ *	@timeout_reason is used to report the reason for the timeout in that
+ *	case.
+ * @bssid: The BSSID of the AP (may be %NULL)
+ * @bss: Entry of bss to which STA got connected to, can be obtained through
+ *	cfg80211_get_bss() (may be %NULL). But it is recommended to store the
+ *	bss from the connect_request and hold a reference to it and return
+ *	through this param to avoid a warning if the bss is expired during the
+ *	connection, esp. for those drivers implementing connect op.
+ *	Only one parameter among @bssid and @bss needs to be specified.
+ * @req_ie: Association request IEs (may be %NULL)
+ * @req_ie_len: Association request IEs length
+ * @resp_ie: Association response IEs (may be %NULL)
+ * @resp_ie_len: Association response IEs length
+ * @fils: FILS connection response parameters.
+ * @timeout_reason: Reason for connection timeout. This is used when the
+ *	connection fails due to a timeout instead of an explicit rejection from
+ *	the AP. %NL80211_TIMEOUT_UNSPECIFIED is used when the timeout reason is
+ *	not known. This value is used only if @status < 0 to indicate that the
+ *	failure is due to a timeout and not due to explicit rejection by the AP.
+ *	This value is ignored in other cases (@status >= 0).
+ */
+struct cfg80211_connect_resp_params {
+	int status;
+	const u8 *bssid;
+	struct cfg80211_bss *bss;
+	const u8 *req_ie;
+	size_t req_ie_len;
+	const u8 *resp_ie;
+	size_t resp_ie_len;
+	struct cfg80211_fils_resp_params fils;
+	enum nl80211_timeout_reason timeout_reason;
+};
+
+/**
+ * cfg80211_connect_done - notify cfg80211 of connection result
+ *
+ * @dev: network device
+ * @params: connection response parameters
+ * @gfp: allocation flags
+ *
+ * It should be called by the underlying driver once execution of the connection
+ * request from connect() has been completed. This is similar to
+ * cfg80211_connect_bss(), but takes a structure pointer for connection response
+ * parameters. Only one of the functions among cfg80211_connect_bss(),
+ * cfg80211_connect_result(), cfg80211_connect_timeout(),
+ * and cfg80211_connect_done() should be called.
+ */
+void cfg80211_connect_done(struct net_device *dev,
+			   struct cfg80211_connect_resp_params *params,
+			   gfp_t gfp);
+
+/**
+ * cfg80211_connect_bss - notify cfg80211 of connection result
+ *
+ * @dev: network device
+ * @bssid: the BSSID of the AP
+ * @bss: Entry of bss to which STA got connected to, can be obtained through
+ *	cfg80211_get_bss() (may be %NULL). But it is recommended to store the
+ *	bss from the connect_request and hold a reference to it and return
+ *	through this param to avoid a warning if the bss is expired during the
+ *	connection, esp. for those drivers implementing connect op.
+ *	Only one parameter among @bssid and @bss needs to be specified.
+ * @req_ie: association request IEs (maybe be %NULL)
+ * @req_ie_len: association request IEs length
+ * @resp_ie: association response IEs (may be %NULL)
+ * @resp_ie_len: assoc response IEs length
+ * @status: status code, %WLAN_STATUS_SUCCESS for successful connection, use
+ *	%WLAN_STATUS_UNSPECIFIED_FAILURE if your device cannot give you
+ *	the real status code for failures. If this call is used to report a
+ *	failure due to a timeout (e.g., not receiving an Authentication frame
+ *	from the AP) instead of an explicit rejection by the AP, -1 is used to
+ *	indicate that this is a failure, but without a status code.
+ *	@timeout_reason is used to report the reason for the timeout in that
+ *	case.
+ * @gfp: allocation flags
+ * @timeout_reason: reason for connection timeout. This is used when the
+ *	connection fails due to a timeout instead of an explicit rejection from
+ *	the AP. %NL80211_TIMEOUT_UNSPECIFIED is used when the timeout reason is
+ *	not known. This value is used only if @status < 0 to indicate that the
+ *	failure is due to a timeout and not due to explicit rejection by the AP.
+ *	This value is ignored in other cases (@status >= 0).
+ *
+ * It should be called by the underlying driver once execution of the connection
+ * request from connect() has been completed. This is similar to
+ * cfg80211_connect_result(), but with the option of identifying the exact bss
+ * entry for the connection. Only one of the functions among
+ * cfg80211_connect_bss(), cfg80211_connect_result(),
+ * cfg80211_connect_timeout(), and cfg80211_connect_done() should be called.
+ */
+static inline void
+cfg80211_connect_bss(struct net_device *dev, const u8 *bssid,
+		     struct cfg80211_bss *bss, const u8 *req_ie,
+		     size_t req_ie_len, const u8 *resp_ie,
+		     size_t resp_ie_len, int status, gfp_t gfp,
+		     enum nl80211_timeout_reason timeout_reason)
+{
+	struct cfg80211_connect_resp_params params;
+
+	memset(&params, 0, sizeof(params));
+	params.status = status;
+	params.bssid = bssid;
+	params.bss = bss;
+	params.req_ie = req_ie;
+	params.req_ie_len = req_ie_len;
+	params.resp_ie = resp_ie;
+	params.resp_ie_len = resp_ie_len;
+	params.timeout_reason = timeout_reason;
+
+	cfg80211_connect_done(dev, &params, gfp);
+}
+
+/**
+ * cfg80211_connect_result - notify cfg80211 of connection result
+ *
+ * @dev: network device
+ * @bssid: the BSSID of the AP
+ * @req_ie: association request IEs (maybe be %NULL)
+ * @req_ie_len: association request IEs length
+ * @resp_ie: association response IEs (may be %NULL)
+ * @resp_ie_len: assoc response IEs length
+ * @status: status code, %WLAN_STATUS_SUCCESS for successful connection, use
+ *	%WLAN_STATUS_UNSPECIFIED_FAILURE if your device cannot give you
+ *	the real status code for failures.
+ * @gfp: allocation flags
+ *
+ * It should be called by the underlying driver once execution of the connection
+ * request from connect() has been completed. This is similar to
+ * cfg80211_connect_bss() which allows the exact bss entry to be specified. Only
+ * one of the functions among cfg80211_connect_bss(), cfg80211_connect_result(),
+ * cfg80211_connect_timeout(), and cfg80211_connect_done() should be called.
+ */
+static inline void
+cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
+			const u8 *req_ie, size_t req_ie_len,
+			const u8 *resp_ie, size_t resp_ie_len,
+			u16 status, gfp_t gfp)
+{
+	cfg80211_connect_bss(dev, bssid, NULL, req_ie, req_ie_len, resp_ie,
+			     resp_ie_len, status, gfp,
+			     NL80211_TIMEOUT_UNSPECIFIED);
+}
+
+/**
+ * cfg80211_connect_timeout - notify cfg80211 of connection timeout
+ *
+ * @dev: network device
+ * @bssid: the BSSID of the AP
+ * @req_ie: association request IEs (maybe be %NULL)
+ * @req_ie_len: association request IEs length
+ * @gfp: allocation flags
+ * @timeout_reason: reason for connection timeout.
+ *
+ * It should be called by the underlying driver whenever connect() has failed
+ * in a sequence where no explicit authentication/association rejection was
+ * received from the AP. This could happen, e.g., due to not being able to send
+ * out the Authentication or Association Request frame or timing out while
+ * waiting for the response. Only one of the functions among
+ * cfg80211_connect_bss(), cfg80211_connect_result(),
+ * cfg80211_connect_timeout(), and cfg80211_connect_done() should be called.
+ */
+static inline void
+cfg80211_connect_timeout(struct net_device *dev, const u8 *bssid,
+			 const u8 *req_ie, size_t req_ie_len, gfp_t gfp,
+			 enum nl80211_timeout_reason timeout_reason)
+{
+	cfg80211_connect_bss(dev, bssid, NULL, req_ie, req_ie_len, NULL, 0, -1,
+			     gfp, timeout_reason);
+}
+
+/**
+ * struct cfg80211_roam_info - driver initiated roaming information
+ *
+ * @channel: the channel of the new AP
+ * @bss: entry of bss to which STA got roamed (may be %NULL if %bssid is set)
+ * @bssid: the BSSID of the new AP (may be %NULL if %bss is set)
+ * @req_ie: association request IEs (maybe be %NULL)
+ * @req_ie_len: association request IEs length
+ * @resp_ie: association response IEs (may be %NULL)
+ * @resp_ie_len: assoc response IEs length
+ * @fils: FILS related roaming information.
+ */
+struct cfg80211_roam_info {
+	struct ieee80211_channel *channel;
+	struct cfg80211_bss *bss;
+	const u8 *bssid;
+	const u8 *req_ie;
+	size_t req_ie_len;
+	const u8 *resp_ie;
+	size_t resp_ie_len;
+	struct cfg80211_fils_resp_params fils;
+};
+
+/**
+ * cfg80211_roamed - notify cfg80211 of roaming
+ *
+ * @dev: network device
+ * @info: information about the new BSS. struct &cfg80211_roam_info.
+ * @gfp: allocation flags
+ *
+ * This function may be called with the driver passing either the BSSID of the
+ * new AP or passing the bss entry to avoid a race in timeout of the bss entry.
+ * It should be called by the underlying driver whenever it roamed from one AP
+ * to another while connected. Drivers which have roaming implemented in
+ * firmware should pass the bss entry to avoid a race in bss entry timeout where
+ * the bss entry of the new AP is seen in the driver, but gets timed out by the
+ * time it is accessed in __cfg80211_roamed() due to delay in scheduling
+ * rdev->event_work. In case of any failures, the reference is released
+ * either in cfg80211_roamed() or in __cfg80211_romed(), Otherwise, it will be
+ * released while diconneting from the current bss.
+ */
+void cfg80211_roamed(struct net_device *dev, struct cfg80211_roam_info *info,
+		     gfp_t gfp);
+
+/**
+ * cfg80211_port_authorized - notify cfg80211 of successful security association
+ *
+ * @dev: network device
+ * @bssid: the BSSID of the AP
+ * @gfp: allocation flags
+ *
+ * This function should be called by a driver that supports 4 way handshake
+ * offload after a security association was successfully established (i.e.,
+ * the 4 way handshake was completed successfully). The call to this function
+ * should be preceded with a call to cfg80211_connect_result(),
+ * cfg80211_connect_done(), cfg80211_connect_bss() or cfg80211_roamed() to
+ * indicate the 802.11 association.
+ */
+void cfg80211_port_authorized(struct net_device *dev, const u8 *bssid,
+			      gfp_t gfp);
+
+/**
+ * cfg80211_disconnected - notify cfg80211 that connection was dropped
+ *
+ * @dev: network device
+ * @ie: information elements of the deauth/disassoc frame (may be %NULL)
+ * @ie_len: length of IEs
+ * @reason: reason code for the disconnection, set it to 0 if unknown
+ * @locally_generated: disconnection was requested locally
+ * @gfp: allocation flags
+ *
+ * After it calls this function, the driver should enter an idle state
+ * and not try to connect to any AP any more.
+ */
+void cfg80211_disconnected(struct net_device *dev, u16 reason,
+			   const u8 *ie, size_t ie_len,
+			   bool locally_generated, gfp_t gfp);
+
+/**
+ * cfg80211_ready_on_channel - notification of remain_on_channel start
+ * @wdev: wireless device
+ * @cookie: the request cookie
+ * @chan: The current channel (from remain_on_channel request)
+ * @duration: Duration in milliseconds that the driver intents to remain on the
+ *	channel
+ * @gfp: allocation flags
+ */
+void cfg80211_ready_on_channel(struct wireless_dev *wdev, u64 cookie,
+			       struct ieee80211_channel *chan,
+			       unsigned int duration, gfp_t gfp);
+
+/**
+ * cfg80211_remain_on_channel_expired - remain_on_channel duration expired
+ * @wdev: wireless device
+ * @cookie: the request cookie
+ * @chan: The current channel (from remain_on_channel request)
+ * @gfp: allocation flags
+ */
+void cfg80211_remain_on_channel_expired(struct wireless_dev *wdev, u64 cookie,
+					struct ieee80211_channel *chan,
+					gfp_t gfp);
+
+/**
+ * cfg80211_tx_mgmt_expired - tx_mgmt duration expired
+ * @wdev: wireless device
+ * @cookie: the requested cookie
+ * @chan: The current channel (from tx_mgmt request)
+ * @gfp: allocation flags
+ */
+void cfg80211_tx_mgmt_expired(struct wireless_dev *wdev, u64 cookie,
+			      struct ieee80211_channel *chan, gfp_t gfp);
+
+/**
+ * cfg80211_sinfo_alloc_tid_stats - allocate per-tid statistics.
+ *
+ * @sinfo: the station information
+ * @gfp: allocation flags
+ */
+int cfg80211_sinfo_alloc_tid_stats(struct station_info *sinfo, gfp_t gfp);
+
+/**
+ * cfg80211_sinfo_release_content - release contents of station info
+ * @sinfo: the station information
+ *
+ * Releases any potentially allocated sub-information of the station
+ * information, but not the struct itself (since it's typically on
+ * the stack.)
+ */
+static inline void cfg80211_sinfo_release_content(struct station_info *sinfo)
+{
+	kfree(sinfo->pertid);
+}
+
+/**
+ * cfg80211_new_sta - notify userspace about station
+ *
+ * @dev: the netdev
+ * @mac_addr: the station's address
+ * @sinfo: the station information
+ * @gfp: allocation flags
+ */
+void cfg80211_new_sta(struct net_device *dev, const u8 *mac_addr,
+		      struct station_info *sinfo, gfp_t gfp);
+
+/**
+ * cfg80211_del_sta_sinfo - notify userspace about deletion of a station
+ * @dev: the netdev
+ * @mac_addr: the station's address
+ * @sinfo: the station information/statistics
+ * @gfp: allocation flags
+ */
+void cfg80211_del_sta_sinfo(struct net_device *dev, const u8 *mac_addr,
+			    struct station_info *sinfo, gfp_t gfp);
+
+/**
+ * cfg80211_del_sta - notify userspace about deletion of a station
+ *
+ * @dev: the netdev
+ * @mac_addr: the station's address
+ * @gfp: allocation flags
+ */
+static inline void cfg80211_del_sta(struct net_device *dev,
+				    const u8 *mac_addr, gfp_t gfp)
+{
+	cfg80211_del_sta_sinfo(dev, mac_addr, NULL, gfp);
+}
+
+/**
+ * cfg80211_conn_failed - connection request failed notification
+ *
+ * @dev: the netdev
+ * @mac_addr: the station's address
+ * @reason: the reason for connection failure
+ * @gfp: allocation flags
+ *
+ * Whenever a station tries to connect to an AP and if the station
+ * could not connect to the AP as the AP has rejected the connection
+ * for some reasons, this function is called.
+ *
+ * The reason for connection failure can be any of the value from
+ * nl80211_connect_failed_reason enum
+ */
+void cfg80211_conn_failed(struct net_device *dev, const u8 *mac_addr,
+			  enum nl80211_connect_failed_reason reason,
+			  gfp_t gfp);
+
+/**
+ * cfg80211_rx_mgmt - notification of received, unprocessed management frame
+ * @wdev: wireless device receiving the frame
+ * @freq: Frequency on which the frame was received in MHz
+ * @sig_dbm: signal strength in dBm, or 0 if unknown
+ * @buf: Management frame (header + body)
+ * @len: length of the frame data
+ * @flags: flags, as defined in enum nl80211_rxmgmt_flags
+ *
+ * This function is called whenever an Action frame is received for a station
+ * mode interface, but is not processed in kernel.
+ *
+ * Return: %true if a user space application has registered for this frame.
+ * For action frames, that makes it responsible for rejecting unrecognized
+ * action frames; %false otherwise, in which case for action frames the
+ * driver is responsible for rejecting the frame.
+ */
+bool cfg80211_rx_mgmt(struct wireless_dev *wdev, int freq, int sig_dbm,
+		      const u8 *buf, size_t len, u32 flags);
+
+/**
+ * cfg80211_mgmt_tx_status - notification of TX status for management frame
+ * @wdev: wireless device receiving the frame
+ * @cookie: Cookie returned by cfg80211_ops::mgmt_tx()
+ * @buf: Management frame (header + body)
+ * @len: length of the frame data
+ * @ack: Whether frame was acknowledged
+ * @gfp: context flags
+ *
+ * This function is called whenever a management frame was requested to be
+ * transmitted with cfg80211_ops::mgmt_tx() to report the TX status of the
+ * transmission attempt.
+ */
+void cfg80211_mgmt_tx_status(struct wireless_dev *wdev, u64 cookie,
+			     const u8 *buf, size_t len, bool ack, gfp_t gfp);
+
+
+/**
+ * cfg80211_rx_control_port - notification about a received control port frame
+ * @dev: The device the frame matched to
+ * @skb: The skbuf with the control port frame.  It is assumed that the skbuf
+ *	is 802.3 formatted (with 802.3 header).  The skb can be non-linear.
+ *	This function does not take ownership of the skb, so the caller is
+ *	responsible for any cleanup.  The caller must also ensure that
+ *	skb->protocol is set appropriately.
+ * @unencrypted: Whether the frame was received unencrypted
+ *
+ * This function is used to inform userspace about a received control port
+ * frame.  It should only be used if userspace indicated it wants to receive
+ * control port frames over nl80211.
+ *
+ * The frame is the data portion of the 802.3 or 802.11 data frame with all
+ * network layer headers removed (e.g. the raw EAPoL frame).
+ *
+ * Return: %true if the frame was passed to userspace
+ */
+bool cfg80211_rx_control_port(struct net_device *dev,
+			      struct sk_buff *skb, bool unencrypted);
+
+/**
+ * cfg80211_cqm_rssi_notify - connection quality monitoring rssi event
+ * @dev: network device
+ * @rssi_event: the triggered RSSI event
+ * @rssi_level: new RSSI level value or 0 if not available
+ * @gfp: context flags
+ *
+ * This function is called when a configured connection quality monitoring
+ * rssi threshold reached event occurs.
+ */
+void cfg80211_cqm_rssi_notify(struct net_device *dev,
+			      enum nl80211_cqm_rssi_threshold_event rssi_event,
+			      s32 rssi_level, gfp_t gfp);
+
+/**
+ * cfg80211_cqm_pktloss_notify - notify userspace about packetloss to peer
+ * @dev: network device
+ * @peer: peer's MAC address
+ * @num_packets: how many packets were lost -- should be a fixed threshold
+ *	but probably no less than maybe 50, or maybe a throughput dependent
+ *	threshold (to account for temporary interference)
+ * @gfp: context flags
+ */
+void cfg80211_cqm_pktloss_notify(struct net_device *dev,
+				 const u8 *peer, u32 num_packets, gfp_t gfp);
+
+/**
+ * cfg80211_cqm_txe_notify - TX error rate event
+ * @dev: network device
+ * @peer: peer's MAC address
+ * @num_packets: how many packets were lost
+ * @rate: % of packets which failed transmission
+ * @intvl: interval (in s) over which the TX failure threshold was breached.
+ * @gfp: context flags
+ *
+ * Notify userspace when configured % TX failures over number of packets in a
+ * given interval is exceeded.
+ */
+void cfg80211_cqm_txe_notify(struct net_device *dev, const u8 *peer,
+			     u32 num_packets, u32 rate, u32 intvl, gfp_t gfp);
+
+/**
+ * cfg80211_cqm_beacon_loss_notify - beacon loss event
+ * @dev: network device
+ * @gfp: context flags
+ *
+ * Notify userspace about beacon loss from the connected AP.
+ */
+void cfg80211_cqm_beacon_loss_notify(struct net_device *dev, gfp_t gfp);
+
+/**
+ * cfg80211_radar_event - radar detection event
+ * @wiphy: the wiphy
+ * @chandef: chandef for the current channel
+ * @gfp: context flags
+ *
+ * This function is called when a radar is detected on the current chanenl.
+ */
+void cfg80211_radar_event(struct wiphy *wiphy,
+			  struct cfg80211_chan_def *chandef, gfp_t gfp);
+
+/**
+ * cfg80211_sta_opmode_change_notify - STA's ht/vht operation mode change event
+ * @dev: network device
+ * @mac: MAC address of a station which opmode got modified
+ * @sta_opmode: station's current opmode value
+ * @gfp: context flags
+ *
+ * Driver should call this function when station's opmode modified via action
+ * frame.
+ */
+void cfg80211_sta_opmode_change_notify(struct net_device *dev, const u8 *mac,
+				       struct sta_opmode_info *sta_opmode,
+				       gfp_t gfp);
+
+/**
+ * cfg80211_cac_event - Channel availability check (CAC) event
+ * @netdev: network device
+ * @chandef: chandef for the current channel
+ * @event: type of event
+ * @gfp: context flags
+ *
+ * This function is called when a Channel availability check (CAC) is finished
+ * or aborted. This must be called to notify the completion of a CAC process,
+ * also by full-MAC drivers.
+ */
+void cfg80211_cac_event(struct net_device *netdev,
+			const struct cfg80211_chan_def *chandef,
+			enum nl80211_radar_event event, gfp_t gfp);
+
+
+/**
+ * cfg80211_gtk_rekey_notify - notify userspace about driver rekeying
+ * @dev: network device
+ * @bssid: BSSID of AP (to avoid races)
+ * @replay_ctr: new replay counter
+ * @gfp: allocation flags
+ */
+void cfg80211_gtk_rekey_notify(struct net_device *dev, const u8 *bssid,
+			       const u8 *replay_ctr, gfp_t gfp);
+
+/**
+ * cfg80211_pmksa_candidate_notify - notify about PMKSA caching candidate
+ * @dev: network device
+ * @index: candidate index (the smaller the index, the higher the priority)
+ * @bssid: BSSID of AP
+ * @preauth: Whether AP advertises support for RSN pre-authentication
+ * @gfp: allocation flags
+ */
+void cfg80211_pmksa_candidate_notify(struct net_device *dev, int index,
+				     const u8 *bssid, bool preauth, gfp_t gfp);
+
+/**
+ * cfg80211_rx_spurious_frame - inform userspace about a spurious frame
+ * @dev: The device the frame matched to
+ * @addr: the transmitter address
+ * @gfp: context flags
+ *
+ * This function is used in AP mode (only!) to inform userspace that
+ * a spurious class 3 frame was received, to be able to deauth the
+ * sender.
+ * Return: %true if the frame was passed to userspace (or this failed
+ * for a reason other than not having a subscription.)
+ */
+bool cfg80211_rx_spurious_frame(struct net_device *dev,
+				const u8 *addr, gfp_t gfp);
+
+/**
+ * cfg80211_rx_unexpected_4addr_frame - inform about unexpected WDS frame
+ * @dev: The device the frame matched to
+ * @addr: the transmitter address
+ * @gfp: context flags
+ *
+ * This function is used in AP mode (only!) to inform userspace that
+ * an associated station sent a 4addr frame but that wasn't expected.
+ * It is allowed and desirable to send this event only once for each
+ * station to avoid event flooding.
+ * Return: %true if the frame was passed to userspace (or this failed
+ * for a reason other than not having a subscription.)
+ */
+bool cfg80211_rx_unexpected_4addr_frame(struct net_device *dev,
+					const u8 *addr, gfp_t gfp);
+
+/**
+ * cfg80211_probe_status - notify userspace about probe status
+ * @dev: the device the probe was sent on
+ * @addr: the address of the peer
+ * @cookie: the cookie filled in @probe_client previously
+ * @acked: indicates whether probe was acked or not
+ * @ack_signal: signal strength (in dBm) of the ACK frame.
+ * @is_valid_ack_signal: indicates the ack_signal is valid or not.
+ * @gfp: allocation flags
+ */
+void cfg80211_probe_status(struct net_device *dev, const u8 *addr,
+			   u64 cookie, bool acked, s32 ack_signal,
+			   bool is_valid_ack_signal, gfp_t gfp);
+
+/**
+ * cfg80211_report_obss_beacon - report beacon from other APs
+ * @wiphy: The wiphy that received the beacon
+ * @frame: the frame
+ * @len: length of the frame
+ * @freq: frequency the frame was received on
+ * @sig_dbm: signal strength in dBm, or 0 if unknown
+ *
+ * Use this function to report to userspace when a beacon was
+ * received. It is not useful to call this when there is no
+ * netdev that is in AP/GO mode.
+ */
+void cfg80211_report_obss_beacon(struct wiphy *wiphy,
+				 const u8 *frame, size_t len,
+				 int freq, int sig_dbm);
+
+/**
+ * cfg80211_reg_can_beacon - check if beaconing is allowed
+ * @wiphy: the wiphy
+ * @chandef: the channel definition
+ * @iftype: interface type
+ *
+ * Return: %true if there is no secondary channel or the secondary channel(s)
+ * can be used for beaconing (i.e. is not a radar channel etc.)
+ */
+bool cfg80211_reg_can_beacon(struct wiphy *wiphy,
+			     struct cfg80211_chan_def *chandef,
+			     enum nl80211_iftype iftype);
+
+/**
+ * cfg80211_reg_can_beacon_relax - check if beaconing is allowed with relaxation
+ * @wiphy: the wiphy
+ * @chandef: the channel definition
+ * @iftype: interface type
+ *
+ * Return: %true if there is no secondary channel or the secondary channel(s)
+ * can be used for beaconing (i.e. is not a radar channel etc.). This version
+ * also checks if IR-relaxation conditions apply, to allow beaconing under
+ * more permissive conditions.
+ *
+ * Requires the RTNL to be held.
+ */
+bool cfg80211_reg_can_beacon_relax(struct wiphy *wiphy,
+				   struct cfg80211_chan_def *chandef,
+				   enum nl80211_iftype iftype);
+
+/*
+ * cfg80211_ch_switch_notify - update wdev channel and notify userspace
+ * @dev: the device which switched channels
+ * @chandef: the new channel definition
+ *
+ * Caller must acquire wdev_lock, therefore must only be called from sleepable
+ * driver context!
+ */
+void cfg80211_ch_switch_notify(struct net_device *dev,
+			       struct cfg80211_chan_def *chandef);
+
+/*
+ * cfg80211_ch_switch_started_notify - notify channel switch start
+ * @dev: the device on which the channel switch started
+ * @chandef: the future channel definition
+ * @count: the number of TBTTs until the channel switch happens
+ *
+ * Inform the userspace about the channel switch that has just
+ * started, so that it can take appropriate actions (eg. starting
+ * channel switch on other vifs), if necessary.
+ */
+void cfg80211_ch_switch_started_notify(struct net_device *dev,
+				       struct cfg80211_chan_def *chandef,
+				       u8 count);
+
+/**
+ * ieee80211_operating_class_to_band - convert operating class to band
+ *
+ * @operating_class: the operating class to convert
+ * @band: band pointer to fill
+ *
+ * Returns %true if the conversion was successful, %false otherwise.
+ */
+bool ieee80211_operating_class_to_band(u8 operating_class,
+				       enum nl80211_band *band);
+
+/**
+ * ieee80211_chandef_to_operating_class - convert chandef to operation class
+ *
+ * @chandef: the chandef to convert
+ * @op_class: a pointer to the resulting operating class
+ *
+ * Returns %true if the conversion was successful, %false otherwise.
+ */
+bool ieee80211_chandef_to_operating_class(struct cfg80211_chan_def *chandef,
+					  u8 *op_class);
+
+/**
+ * ieee80211_chandef_to_khz - convert chandef to frequency in KHz
+ *
+ * @chandef: the chandef to convert
+ *
+ * Returns the center frequency of chandef (1st segment) in KHz.
+ */
+static inline u32
+ieee80211_chandef_to_khz(const struct cfg80211_chan_def *chandef)
+{
+	return MHZ_TO_KHZ(chandef->center_freq1) + chandef->freq1_offset;
+}
+
+/*
+ * cfg80211_tdls_oper_request - request userspace to perform TDLS operation
+ * @dev: the device on which the operation is requested
+ * @peer: the MAC address of the peer device
+ * @oper: the requested TDLS operation (NL80211_TDLS_SETUP or
+ *	NL80211_TDLS_TEARDOWN)
+ * @reason_code: the reason code for teardown request
+ * @gfp: allocation flags
+ *
+ * This function is used to request userspace to perform TDLS operation that
+ * requires knowledge of keys, i.e., link setup or teardown when the AP
+ * connection uses encryption. This is optional mechanism for the driver to use
+ * if it can automatically determine when a TDLS link could be useful (e.g.,
+ * based on traffic and signal strength for a peer).
+ */
+void cfg80211_tdls_oper_request(struct net_device *dev, const u8 *peer,
+				enum nl80211_tdls_operation oper,
+				u16 reason_code, gfp_t gfp);
+
+/*
+ * cfg80211_calculate_bitrate - calculate actual bitrate (in 100Kbps units)
+ * @rate: given rate_info to calculate bitrate from
+ *
+ * return 0 if MCS index >= 32
+ */
+u32 cfg80211_calculate_bitrate(struct rate_info *rate);
+
+/**
+ * cfg80211_unregister_wdev - remove the given wdev
+ * @wdev: struct wireless_dev to remove
+ *
+ * Call this function only for wdevs that have no netdev assigned,
+ * e.g. P2P Devices. It removes the device from the list so that
+ * it can no longer be used. It is necessary to call this function
+ * even when cfg80211 requests the removal of the interface by
+ * calling the del_virtual_intf() callback. The function must also
+ * be called when the driver wishes to unregister the wdev, e.g.
+ * when the device is unbound from the driver.
+ *
+ * Requires the RTNL to be held.
+ */
+void cfg80211_unregister_wdev(struct wireless_dev *wdev);
+
+/**
+ * struct cfg80211_ft_event - FT Information Elements
+ * @ies: FT IEs
+ * @ies_len: length of the FT IE in bytes
+ * @target_ap: target AP's MAC address
+ * @ric_ies: RIC IE
+ * @ric_ies_len: length of the RIC IE in bytes
+ */
+struct cfg80211_ft_event_params {
+	const u8 *ies;
+	size_t ies_len;
+	const u8 *target_ap;
+	const u8 *ric_ies;
+	size_t ric_ies_len;
+};
+
+/**
+ * cfg80211_ft_event - notify userspace about FT IE and RIC IE
+ * @netdev: network device
+ * @ft_event: IE information
+ */
+void cfg80211_ft_event(struct net_device *netdev,
+		       struct cfg80211_ft_event_params *ft_event);
+
+/**
+ * cfg80211_get_p2p_attr - find and copy a P2P attribute from IE buffer
+ * @ies: the input IE buffer
+ * @len: the input length
+ * @attr: the attribute ID to find
+ * @buf: output buffer, can be %NULL if the data isn't needed, e.g.
+ *	if the function is only called to get the needed buffer size
+ * @bufsize: size of the output buffer
+ *
+ * The function finds a given P2P attribute in the (vendor) IEs and
+ * copies its contents to the given buffer.
+ *
+ * Return: A negative error code (-%EILSEQ or -%ENOENT) if the data is
+ * malformed or the attribute can't be found (respectively), or the
+ * length of the found attribute (which can be zero).
+ */
+int cfg80211_get_p2p_attr(const u8 *ies, unsigned int len,
+			  enum ieee80211_p2p_attr_id attr,
+			  u8 *buf, unsigned int bufsize);
+
+/**
+ * ieee80211_ie_split_ric - split an IE buffer according to ordering (with RIC)
+ * @ies: the IE buffer
+ * @ielen: the length of the IE buffer
+ * @ids: an array with element IDs that are allowed before
+ *	the split. A WLAN_EID_EXTENSION value means that the next
+ *	EID in the list is a sub-element of the EXTENSION IE.
+ * @n_ids: the size of the element ID array
+ * @after_ric: array IE types that come after the RIC element
+ * @n_after_ric: size of the @after_ric array
+ * @offset: offset where to start splitting in the buffer
+ *
+ * This function splits an IE buffer by updating the @offset
+ * variable to point to the location where the buffer should be
+ * split.
+ *
+ * It assumes that the given IE buffer is well-formed, this
+ * has to be guaranteed by the caller!
+ *
+ * It also assumes that the IEs in the buffer are ordered
+ * correctly, if not the result of using this function will not
+ * be ordered correctly either, i.e. it does no reordering.
+ *
+ * The function returns the offset where the next part of the
+ * buffer starts, which may be @ielen if the entire (remainder)
+ * of the buffer should be used.
+ */
+size_t ieee80211_ie_split_ric(const u8 *ies, size_t ielen,
+			      const u8 *ids, int n_ids,
+			      const u8 *after_ric, int n_after_ric,
+			      size_t offset);
+
+/**
+ * ieee80211_ie_split - split an IE buffer according to ordering
+ * @ies: the IE buffer
+ * @ielen: the length of the IE buffer
+ * @ids: an array with element IDs that are allowed before
+ *	the split. A WLAN_EID_EXTENSION value means that the next
+ *	EID in the list is a sub-element of the EXTENSION IE.
+ * @n_ids: the size of the element ID array
+ * @offset: offset where to start splitting in the buffer
+ *
+ * This function splits an IE buffer by updating the @offset
+ * variable to point to the location where the buffer should be
+ * split.
+ *
+ * It assumes that the given IE buffer is well-formed, this
+ * has to be guaranteed by the caller!
+ *
+ * It also assumes that the IEs in the buffer are ordered
+ * correctly, if not the result of using this function will not
+ * be ordered correctly either, i.e. it does no reordering.
+ *
+ * The function returns the offset where the next part of the
+ * buffer starts, which may be @ielen if the entire (remainder)
+ * of the buffer should be used.
+ */
+static inline size_t ieee80211_ie_split(const u8 *ies, size_t ielen,
+					const u8 *ids, int n_ids, size_t offset)
+{
+	return ieee80211_ie_split_ric(ies, ielen, ids, n_ids, NULL, 0, offset);
+}
+
+/**
+ * cfg80211_report_wowlan_wakeup - report wakeup from WoWLAN
+ * @wdev: the wireless device reporting the wakeup
+ * @wakeup: the wakeup report
+ * @gfp: allocation flags
+ *
+ * This function reports that the given device woke up. If it
+ * caused the wakeup, report the reason(s), otherwise you may
+ * pass %NULL as the @wakeup parameter to advertise that something
+ * else caused the wakeup.
+ */
+void cfg80211_report_wowlan_wakeup(struct wireless_dev *wdev,
+				   struct cfg80211_wowlan_wakeup *wakeup,
+				   gfp_t gfp);
+
+/**
+ * cfg80211_crit_proto_stopped() - indicate critical protocol stopped by driver.
+ *
+ * @wdev: the wireless device for which critical protocol is stopped.
+ * @gfp: allocation flags
+ *
+ * This function can be called by the driver to indicate it has reverted
+ * operation back to normal. One reason could be that the duration given
+ * by .crit_proto_start() has expired.
+ */
+void cfg80211_crit_proto_stopped(struct wireless_dev *wdev, gfp_t gfp);
+
+/**
+ * ieee80211_get_num_supported_channels - get number of channels device has
+ * @wiphy: the wiphy
+ *
+ * Return: the number of channels supported by the device.
+ */
+unsigned int ieee80211_get_num_supported_channels(struct wiphy *wiphy);
+
+/**
+ * cfg80211_check_combinations - check interface combinations
+ *
+ * @wiphy: the wiphy
+ * @params: the interface combinations parameter
+ *
+ * This function can be called by the driver to check whether a
+ * combination of interfaces and their types are allowed according to
+ * the interface combinations.
+ */
+int cfg80211_check_combinations(struct wiphy *wiphy,
+				struct iface_combination_params *params);
+
+/**
+ * cfg80211_iter_combinations - iterate over matching combinations
+ *
+ * @wiphy: the wiphy
+ * @params: the interface combinations parameter
+ * @iter: function to call for each matching combination
+ * @data: pointer to pass to iter function
+ *
+ * This function can be called by the driver to check what possible
+ * combinations it fits in at a given moment, e.g. for channel switching
+ * purposes.
+ */
+int cfg80211_iter_combinations(struct wiphy *wiphy,
+			       struct iface_combination_params *params,
+			       void (*iter)(const struct ieee80211_iface_combination *c,
+					    void *data),
+			       void *data);
+
+/*
+ * cfg80211_stop_iface - trigger interface disconnection
+ *
+ * @wiphy: the wiphy
+ * @wdev: wireless device
+ * @gfp: context flags
+ *
+ * Trigger interface to be stopped as if AP was stopped, IBSS/mesh left, STA
+ * disconnected.
+ *
+ * Note: This doesn't need any locks and is asynchronous.
+ */
+void cfg80211_stop_iface(struct wiphy *wiphy, struct wireless_dev *wdev,
+			 gfp_t gfp);
+
+/**
+ * cfg80211_shutdown_all_interfaces - shut down all interfaces for a wiphy
+ * @wiphy: the wiphy to shut down
+ *
+ * This function shuts down all interfaces belonging to this wiphy by
+ * calling dev_close() (and treating non-netdev interfaces as needed).
+ * It shouldn't really be used unless there are some fatal device errors
+ * that really can't be recovered in any other way.
+ *
+ * Callers must hold the RTNL and be able to deal with callbacks into
+ * the driver while the function is running.
+ */
+void cfg80211_shutdown_all_interfaces(struct wiphy *wiphy);
+
+/**
+ * wiphy_ext_feature_set - set the extended feature flag
+ *
+ * @wiphy: the wiphy to modify.
+ * @ftidx: extended feature bit index.
+ *
+ * The extended features are flagged in multiple bytes (see
+ * &struct wiphy.@ext_features)
+ */
+static inline void wiphy_ext_feature_set(struct wiphy *wiphy,
+					 enum nl80211_ext_feature_index ftidx)
+{
+	u8 *ft_byte;
+
+	ft_byte = &wiphy->ext_features[ftidx / 8];
+	*ft_byte |= BIT(ftidx % 8);
+}
+
+/**
+ * wiphy_ext_feature_isset - check the extended feature flag
+ *
+ * @wiphy: the wiphy to modify.
+ * @ftidx: extended feature bit index.
+ *
+ * The extended features are flagged in multiple bytes (see
+ * &struct wiphy.@ext_features)
+ */
+static inline bool
+wiphy_ext_feature_isset(struct wiphy *wiphy,
+			enum nl80211_ext_feature_index ftidx)
+{
+	u8 ft_byte;
+
+	ft_byte = wiphy->ext_features[ftidx / 8];
+	return (ft_byte & BIT(ftidx % 8)) != 0;
+}
+
+/**
+ * cfg80211_free_nan_func - free NAN function
+ * @f: NAN function that should be freed
+ *
+ * Frees all the NAN function and all it's allocated members.
+ */
+void cfg80211_free_nan_func(struct cfg80211_nan_func *f);
+
+/**
+ * struct cfg80211_nan_match_params - NAN match parameters
+ * @type: the type of the function that triggered a match. If it is
+ *	 %NL80211_NAN_FUNC_SUBSCRIBE it means that we replied to a subscriber.
+ *	 If it is %NL80211_NAN_FUNC_PUBLISH, it means that we got a discovery
+ *	 result.
+ *	 If it is %NL80211_NAN_FUNC_FOLLOW_UP, we received a follow up.
+ * @inst_id: the local instance id
+ * @peer_inst_id: the instance id of the peer's function
+ * @addr: the MAC address of the peer
+ * @info_len: the length of the &info
+ * @info: the Service Specific Info from the peer (if any)
+ * @cookie: unique identifier of the corresponding function
+ */
+struct cfg80211_nan_match_params {
+	enum nl80211_nan_function_type type;
+	u8 inst_id;
+	u8 peer_inst_id;
+	const u8 *addr;
+	u8 info_len;
+	const u8 *info;
+	u64 cookie;
+};
+
+/**
+ * cfg80211_nan_match - report a match for a NAN function.
+ * @wdev: the wireless device reporting the match
+ * @match: match notification parameters
+ * @gfp: allocation flags
+ *
+ * This function reports that the a NAN function had a match. This
+ * can be a subscribe that had a match or a solicited publish that
+ * was sent. It can also be a follow up that was received.
+ */
+void cfg80211_nan_match(struct wireless_dev *wdev,
+			struct cfg80211_nan_match_params *match, gfp_t gfp);
+
+/**
+ * cfg80211_nan_func_terminated - notify about NAN function termination.
+ *
+ * @wdev: the wireless device reporting the match
+ * @inst_id: the local instance id
+ * @reason: termination reason (one of the NL80211_NAN_FUNC_TERM_REASON_*)
+ * @cookie: unique NAN function identifier
+ * @gfp: allocation flags
+ *
+ * This function reports that the a NAN function is terminated.
+ */
+void cfg80211_nan_func_terminated(struct wireless_dev *wdev,
+				  u8 inst_id,
+				  enum nl80211_nan_func_term_reason reason,
+				  u64 cookie, gfp_t gfp);
+
+/* ethtool helper */
+void cfg80211_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info);
+
+/**
+ * cfg80211_external_auth_request - userspace request for authentication
+ * @netdev: network device
+ * @params: External authentication parameters
+ * @gfp: allocation flags
+ * Returns: 0 on success, < 0 on error
+ */
+int cfg80211_external_auth_request(struct net_device *netdev,
+				   struct cfg80211_external_auth_params *params,
+				   gfp_t gfp);
+
+/**
+ * cfg80211_pmsr_report - report peer measurement result data
+ * @wdev: the wireless device reporting the measurement
+ * @req: the original measurement request
+ * @result: the result data
+ * @gfp: allocation flags
+ */
+void cfg80211_pmsr_report(struct wireless_dev *wdev,
+			  struct cfg80211_pmsr_request *req,
+			  struct cfg80211_pmsr_result *result,
+			  gfp_t gfp);
+
+/**
+ * cfg80211_pmsr_complete - report peer measurement completed
+ * @wdev: the wireless device reporting the measurement
+ * @req: the original measurement request
+ * @gfp: allocation flags
+ *
+ * Report that the entire measurement completed, after this
+ * the request pointer will no longer be valid.
+ */
+void cfg80211_pmsr_complete(struct wireless_dev *wdev,
+			    struct cfg80211_pmsr_request *req,
+			    gfp_t gfp);
+
+/**
+ * cfg80211_iftype_allowed - check whether the interface can be allowed
+ * @wiphy: the wiphy
+ * @iftype: interface type
+ * @is_4addr: use_4addr flag, must be '0' when check_swif is '1'
+ * @check_swif: check iftype against software interfaces
+ *
+ * Check whether the interface is allowed to operate; additionally, this API
+ * can be used to check iftype against the software interfaces when
+ * check_swif is '1'.
+ */
+bool cfg80211_iftype_allowed(struct wiphy *wiphy, enum nl80211_iftype iftype,
+			     bool is_4addr, u8 check_swif);
+
+
+/* Logging, debugging and troubleshooting/diagnostic helpers. */
+
+/* wiphy_printk helpers, similar to dev_printk */
+
+#define wiphy_printk(level, wiphy, format, args...)		\
+	dev_printk(level, &(wiphy)->dev, format, ##args)
+#define wiphy_emerg(wiphy, format, args...)			\
+	dev_emerg(&(wiphy)->dev, format, ##args)
+#define wiphy_alert(wiphy, format, args...)			\
+	dev_alert(&(wiphy)->dev, format, ##args)
+#define wiphy_crit(wiphy, format, args...)			\
+	dev_crit(&(wiphy)->dev, format, ##args)
+#define wiphy_err(wiphy, format, args...)			\
+	dev_err(&(wiphy)->dev, format, ##args)
+#define wiphy_warn(wiphy, format, args...)			\
+	dev_warn(&(wiphy)->dev, format, ##args)
+#define wiphy_notice(wiphy, format, args...)			\
+	dev_notice(&(wiphy)->dev, format, ##args)
+#define wiphy_info(wiphy, format, args...)			\
+	dev_info(&(wiphy)->dev, format, ##args)
+
+#define wiphy_err_ratelimited(wiphy, format, args...)		\
+	dev_err_ratelimited(&(wiphy)->dev, format, ##args)
+#define wiphy_warn_ratelimited(wiphy, format, args...)		\
+	dev_warn_ratelimited(&(wiphy)->dev, format, ##args)
+
+#define wiphy_debug(wiphy, format, args...)			\
+	wiphy_printk(KERN_DEBUG, wiphy, format, ##args)
+
+#define wiphy_dbg(wiphy, format, args...)			\
+	dev_dbg(&(wiphy)->dev, format, ##args)
+
+#if defined(VERBOSE_DEBUG)
+#define wiphy_vdbg	wiphy_dbg
+#else
+#define wiphy_vdbg(wiphy, format, args...)				\
+({									\
+	if (0)								\
+		wiphy_printk(KERN_DEBUG, wiphy, format, ##args);	\
+	0;								\
+})
+#endif
+
+/*
+ * wiphy_WARN() acts like wiphy_printk(), but with the key difference
+ * of using a WARN/WARN_ON to get the message out, including the
+ * file/line information and a backtrace.
+ */
+#define wiphy_WARN(wiphy, format, args...)			\
+	WARN(1, "wiphy: %s\n" format, wiphy_name(wiphy), ##args);
+
+/**
+ * cfg80211_update_owe_info_event - Notify the peer's OWE info to user space
+ * @netdev: network device
+ * @owe_info: peer's owe info
+ * @gfp: allocation flags
+ */
+void cfg80211_update_owe_info_event(struct net_device *netdev,
+				    struct cfg80211_update_owe_info *owe_info,
+				    gfp_t gfp);
+
+#endif /* __NET_CFG80211_H */
diff -Naurp a/drivers/net/wireless/xr829/include/net/ieee80211_radiotap.h b/drivers/net/wireless/xr829/include/net/ieee80211_radiotap.h
--- a/drivers/net/wireless/xr829/include/net/ieee80211_radiotap.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/net/ieee80211_radiotap.h	2022-08-27 01:22:42.922539741 +0300
@@ -0,0 +1,291 @@
+/*
+ * Copyright (c) 2003, 2004 David Young.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of David Young may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY DAVID YOUNG ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL DAVID
+ * YOUNG BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+ * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ */
+
+/*
+ * Modifications to fit into the linux IEEE 802.11 stack,
+ * Mike Kershaw (dragorn@kismetwireless.net)
+ */
+
+#ifndef IEEE80211RADIOTAP_H
+#define IEEE80211RADIOTAP_H
+
+#include <linux/if_ether.h>
+#include <linux/kernel.h>
+#include <asm/unaligned.h>
+
+/* Base version of the radiotap packet header data */
+#define PKTHDR_RADIOTAP_VERSION		0
+
+/* A generic radio capture format is desirable. There is one for
+ * Linux, but it is neither rigidly defined (there were not even
+ * units given for some fields) nor easily extensible.
+ *
+ * I suggest the following extensible radio capture format. It is
+ * based on a bitmap indicating which fields are present.
+ *
+ * I am trying to describe precisely what the application programmer
+ * should expect in the following, and for that reason I tell the
+ * units and origin of each measurement (where it applies), or else I
+ * use sufficiently weaselly language ("is a monotonically nondecreasing
+ * function of...") that I cannot set false expectations for lawyerly
+ * readers.
+ */
+
+/*
+ * The radio capture header precedes the 802.11 header.
+ * All data in the header is little endian on all platforms.
+ */
+struct ieee80211_radiotap_header {
+	u8 it_version;		/* Version 0. Only increases
+				 * for drastic changes,
+				 * introduction of compatible
+				 * new fields does not count.
+				 */
+	u8 it_pad;
+	__le16 it_len;		/* length of the whole
+				 * header in bytes, including
+				 * it_version, it_pad,
+				 * it_len, and data fields.
+				 */
+	__le32 it_present;	/* A bitmap telling which
+				 * fields are present. Set bit 31
+				 * (0x80000000) to extend the
+				 * bitmap by another 32 bits.
+				 * Additional extensions are made
+				 * by setting bit 31.
+				 */
+} __packed;
+
+/* Name                                 Data type    Units
+ * ----                                 ---------    -----
+ *
+ * IEEE80211_RADIOTAP_TSFT              __le64       microseconds
+ *
+ *      Value in microseconds of the MAC's 64-bit 802.11 Time
+ *      Synchronization Function timer when the first bit of the
+ *      MPDU arrived at the MAC. For received frames, only.
+ *
+ * IEEE80211_RADIOTAP_CHANNEL           2 x __le16   MHz, bitmap
+ *
+ *      Tx/Rx frequency in MHz, followed by flags (see below).
+ *
+ * IEEE80211_RADIOTAP_FHSS              __le16       see below
+ *
+ *      For frequency-hopping radios, the hop set (first byte)
+ *      and pattern (second byte).
+ *
+ * IEEE80211_RADIOTAP_RATE              u8           500kb/s
+ *
+ *      Tx/Rx data rate
+ *
+ * IEEE80211_RADIOTAP_DBM_ANTSIGNAL     s8           decibels from
+ *                                                   one milliwatt (dBm)
+ *
+ *      RF signal power at the antenna, decibel difference from
+ *      one milliwatt.
+ *
+ * IEEE80211_RADIOTAP_DBM_ANTNOISE      s8           decibels from
+ *                                                   one milliwatt (dBm)
+ *
+ *      RF noise power at the antenna, decibel difference from one
+ *      milliwatt.
+ *
+ * IEEE80211_RADIOTAP_DB_ANTSIGNAL      u8           decibel (dB)
+ *
+ *      RF signal power at the antenna, decibel difference from an
+ *      arbitrary, fixed reference.
+ *
+ * IEEE80211_RADIOTAP_DB_ANTNOISE       u8           decibel (dB)
+ *
+ *      RF noise power at the antenna, decibel difference from an
+ *      arbitrary, fixed reference point.
+ *
+ * IEEE80211_RADIOTAP_LOCK_QUALITY      __le16       unitless
+ *
+ *      Quality of Barker code lock. Unitless. Monotonically
+ *      nondecreasing with "better" lock strength. Called "Signal
+ *      Quality" in datasheets.  (Is there a standard way to measure
+ *      this?)
+ *
+ * IEEE80211_RADIOTAP_TX_ATTENUATION    __le16       unitless
+ *
+ *      Transmit power expressed as unitless distance from max
+ *      power set at factory calibration.  0 is max power.
+ *      Monotonically nondecreasing with lower power levels.
+ *
+ * IEEE80211_RADIOTAP_DB_TX_ATTENUATION __le16       decibels (dB)
+ *
+ *      Transmit power expressed as decibel distance from max power
+ *      set at factory calibration.  0 is max power.  Monotonically
+ *      nondecreasing with lower power levels.
+ *
+ * IEEE80211_RADIOTAP_DBM_TX_POWER      s8           decibels from
+ *                                                   one milliwatt (dBm)
+ *
+ *      Transmit power expressed as dBm (decibels from a 1 milliwatt
+ *      reference). This is the absolute power level measured at
+ *      the antenna port.
+ *
+ * IEEE80211_RADIOTAP_FLAGS             u8           bitmap
+ *
+ *      Properties of transmitted and received frames. See flags
+ *      defined below.
+ *
+ * IEEE80211_RADIOTAP_ANTENNA           u8           antenna index
+ *
+ *      Unitless indication of the Rx/Tx antenna for this packet.
+ *      The first antenna is antenna 0.
+ *
+ * IEEE80211_RADIOTAP_RX_FLAGS          __le16       bitmap
+ *
+ *     Properties of received frames. See flags defined below.
+ *
+ * IEEE80211_RADIOTAP_TX_FLAGS          __le16       bitmap
+ *
+ *     Properties of transmitted frames. See flags defined below.
+ *
+ * IEEE80211_RADIOTAP_RTS_RETRIES       u8           data
+ *
+ *     Number of rts retries a transmitted frame used.
+ *
+ * IEEE80211_RADIOTAP_DATA_RETRIES      u8           data
+ *
+ *     Number of unicast retries a transmitted frame used.
+ *
+ * IEEE80211_RADIOTAP_MCS	u8, u8, u8		unitless
+ *
+ *     Contains a bitmap of known fields/flags, the flags, and
+ *     the MCS index.
+ *
+ */
+enum ieee80211_radiotap_type {
+	IEEE80211_RADIOTAP_TSFT = 0,
+	IEEE80211_RADIOTAP_FLAGS = 1,
+	IEEE80211_RADIOTAP_RATE = 2,
+	IEEE80211_RADIOTAP_CHANNEL = 3,
+	IEEE80211_RADIOTAP_FHSS = 4,
+	IEEE80211_RADIOTAP_DBM_ANTSIGNAL = 5,
+	IEEE80211_RADIOTAP_DBM_ANTNOISE = 6,
+	IEEE80211_RADIOTAP_LOCK_QUALITY = 7,
+	IEEE80211_RADIOTAP_TX_ATTENUATION = 8,
+	IEEE80211_RADIOTAP_DB_TX_ATTENUATION = 9,
+	IEEE80211_RADIOTAP_DBM_TX_POWER = 10,
+	IEEE80211_RADIOTAP_ANTENNA = 11,
+	IEEE80211_RADIOTAP_DB_ANTSIGNAL = 12,
+	IEEE80211_RADIOTAP_DB_ANTNOISE = 13,
+	IEEE80211_RADIOTAP_RX_FLAGS = 14,
+	IEEE80211_RADIOTAP_TX_FLAGS = 15,
+	IEEE80211_RADIOTAP_RTS_RETRIES = 16,
+	IEEE80211_RADIOTAP_DATA_RETRIES = 17,
+
+	IEEE80211_RADIOTAP_MCS = 19,
+
+	/* valid in every it_present bitmap, even vendor namespaces */
+	IEEE80211_RADIOTAP_RADIOTAP_NAMESPACE = 29,
+	IEEE80211_RADIOTAP_VENDOR_NAMESPACE = 30,
+	IEEE80211_RADIOTAP_EXT = 31
+};
+
+/* Channel flags. */
+#define	IEEE80211_CHAN_TURBO	0x0010	/* Turbo channel */
+#define	IEEE80211_CHAN_CCK	0x0020	/* CCK channel */
+#define	IEEE80211_CHAN_OFDM	0x0040	/* OFDM channel */
+#define	IEEE80211_CHAN_2GHZ	0x0080	/* 2 GHz spectrum channel. */
+#define	IEEE80211_CHAN_5GHZ	0x0100	/* 5 GHz spectrum channel */
+#define	IEEE80211_CHAN_PASSIVE	0x0200	/* Only passive scan allowed */
+#define	IEEE80211_CHAN_DYN	0x0400	/* Dynamic CCK-OFDM channel */
+#define	IEEE80211_CHAN_GFSK	0x0800	/* GFSK channel (FHSS PHY) */
+
+/* For IEEE80211_RADIOTAP_FLAGS */
+#define	IEEE80211_RADIOTAP_F_CFP	0x01	/* sent/received
+						 * during CFP
+						 */
+#define	IEEE80211_RADIOTAP_F_SHORTPRE	0x02	/* sent/received
+						 * with short
+						 * preamble
+						 */
+#define	IEEE80211_RADIOTAP_F_WEP	0x04	/* sent/received
+						 * with WEP encryption
+						 */
+#define	IEEE80211_RADIOTAP_F_FRAG	0x08	/* sent/received
+						 * with fragmentation
+						 */
+#define	IEEE80211_RADIOTAP_F_FCS	0x10	/* frame includes FCS */
+#define	IEEE80211_RADIOTAP_F_DATAPAD	0x20	/* frame has padding between
+						 * 802.11 header and payload
+						 * (to 32-bit boundary)
+						 */
+#define IEEE80211_RADIOTAP_F_BADFCS	0x40	/* bad FCS */
+
+/* For IEEE80211_RADIOTAP_RX_FLAGS */
+#define IEEE80211_RADIOTAP_F_RX_BADPLCP	0x0002	/* frame has bad PLCP */
+
+/* For IEEE80211_RADIOTAP_TX_FLAGS */
+#define IEEE80211_RADIOTAP_F_TX_FAIL	0x0001	/* failed due to excessive
+						 * retries */
+#define IEEE80211_RADIOTAP_F_TX_CTS	0x0002	/* used cts 'protection' */
+#define IEEE80211_RADIOTAP_F_TX_RTS	0x0004	/* used rts/cts handshake */
+#define IEEE80211_RADIOTAP_F_TX_NOACK	0x0008	/* don't expect an ack */
+
+
+/* For IEEE80211_RADIOTAP_MCS */
+#define IEEE80211_RADIOTAP_MCS_HAVE_BW		0x01
+#define IEEE80211_RADIOTAP_MCS_HAVE_MCS		0x02
+#define IEEE80211_RADIOTAP_MCS_HAVE_GI		0x04
+#define IEEE80211_RADIOTAP_MCS_HAVE_FMT		0x08
+#define IEEE80211_RADIOTAP_MCS_HAVE_FEC		0x10
+
+#define IEEE80211_RADIOTAP_MCS_BW_MASK		0x03
+#define		IEEE80211_RADIOTAP_MCS_BW_20	0
+#define		IEEE80211_RADIOTAP_MCS_BW_40	1
+#define		IEEE80211_RADIOTAP_MCS_BW_20L	2
+#define		IEEE80211_RADIOTAP_MCS_BW_20U	3
+#define IEEE80211_RADIOTAP_MCS_SGI		0x04
+#define IEEE80211_RADIOTAP_MCS_FMT_GF		0x08
+#define IEEE80211_RADIOTAP_MCS_FEC_LDPC		0x10
+
+
+/* Ugly macro to convert literal channel numbers into their mhz equivalents
+ * There are certianly some conditions that will break this (like feeding it '30')
+ * but they shouldn't arise since nothing talks on channel 30. */
+#define ieee80211chan2mhz(x) \
+	(((x) <= 14) ? \
+	(((x) == 14) ? 2484 : ((x) * 5) + 2407) : \
+	((x) + 1000) * 5)
+
+/* helpers */
+static inline int ieee80211_get_radiotap_len(unsigned char *data)
+{
+	struct ieee80211_radiotap_header *hdr =
+		(struct ieee80211_radiotap_header *)data;
+
+	return get_unaligned_le16(&hdr->it_len);
+}
+
+#endif				/* IEEE80211_RADIOTAP_H */
diff -Naurp a/drivers/net/wireless/xr829/include/net/mac80211.h b/drivers/net/wireless/xr829/include/net/mac80211.h
--- a/drivers/net/wireless/xr829/include/net/mac80211.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/net/mac80211.h	2022-08-27 01:22:42.926539756 +0300
@@ -0,0 +1,3977 @@
+/*
+ * mac80211 <-> driver interface
+ *
+ * Copyright 2002-2005, Devicescape Software, Inc.
+ * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
+ * Copyright 2007-2010	Johannes Berg <johannes@sipsolutions.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef MAC80211_H
+#define MAC80211_H
+
+#include <linux/kernel.h>
+#include <linux/if_ether.h>
+#include <linux/skbuff.h>
+#include <linux/device.h>
+#include <linux/ieee80211.h>
+#include <generated/uapi/linux/version.h>
+#include <net/cfg80211.h>
+#include <asm/unaligned.h>
+
+#ifdef IPV6_FILTERING
+#include <linux/in6.h>
+#endif /*IPV6_FILTERING*/
+
+/**
+ * DOC: Introduction
+ *
+ * mac80211 is the Linux stack for 802.11 hardware that implements
+ * only partial functionality in hard- or firmware. This document
+ * defines the interface between mac80211 and low-level hardware
+ * drivers.
+ */
+
+/**
+ * DOC: Calling mac80211 from interrupts
+ *
+ * Only mac80211_tx_status_irqsafe() and mac80211_rx_irqsafe() can be
+ * called in hardware interrupt context. The low-level driver must not call any
+ * other functions in hardware interrupt context. If there is a need for such
+ * call, the low-level driver should first ACK the interrupt and perform the
+ * IEEE 802.11 code call after this, e.g. from a scheduled workqueue or even
+ * tasklet function.
+ *
+ * NOTE: If the driver opts to use the _irqsafe() functions, it may not also
+ *	 use the non-IRQ-safe functions!
+ */
+
+/**
+ * DOC: Warning
+ *
+ * If you're reading this document and not the header file itself, it will
+ * be incomplete because not all documentation has been converted yet.
+ */
+
+/**
+ * DOC: Frame format
+ *
+ * As a general rule, when frames are passed between mac80211 and the driver,
+ * they start with the IEEE 802.11 header and include the same octets that are
+ * sent over the air except for the FCS which should be calculated by the
+ * hardware.
+ *
+ * There are, however, various exceptions to this rule for advanced features:
+ *
+ * The first exception is for hardware encryption and decryption offload
+ * where the IV/ICV may or may not be generated in hardware.
+ *
+ * Secondly, when the hardware handles fragmentation, the frame handed to
+ * the driver from mac80211 is the MSDU, not the MPDU.
+ *
+ * Finally, for received frames, the driver is able to indicate that it has
+ * filled a radiotap header and put that in front of the frame; if it does
+ * not do so then mac80211 may add this under certain circumstances.
+ */
+
+/**
+ * DOC: mac80211 workqueue
+ *
+ * mac80211 provides its own workqueue for drivers and internal mac80211 use.
+ * The workqueue is a single threaded workqueue and can only be accessed by
+ * helpers for sanity checking. Drivers must ensure all work added onto the
+ * mac80211 workqueue should be cancelled on the driver stop() callback.
+ *
+ * mac80211 will flushed the workqueue upon interface removal and during
+ * suspend.
+ *
+ * All work performed on the mac80211 workqueue must not acquire the RTNL lock.
+ *
+ */
+
+/**
+ * enum ieee80211_max_queues - maximum number of queues
+ *
+ * @IEEE80211_MAX_QUEUES: Maximum number of regular device queues.
+ */
+enum ieee80211_max_queues {
+	IEEE80211_MAX_QUEUES =		16,
+};
+
+#define IEEE80211_INVAL_HW_QUEUE	0xff
+
+/**
+ * enum ieee80211_ac_numbers - AC numbers as used in mac80211
+ * @IEEE80211_AC_VO: voice
+ * @IEEE80211_AC_VI: video
+ * @IEEE80211_AC_BE: best effort
+ * @IEEE80211_AC_BK: background
+ */
+enum ieee80211_ac_numbers {
+	IEEE80211_AC_VO		= 0,
+	IEEE80211_AC_VI		= 1,
+	IEEE80211_AC_BE		= 2,
+	IEEE80211_AC_BK		= 3,
+};
+#define IEEE80211_NUM_ACS	4
+
+/**
+ * struct ieee80211_tx_queue_params - transmit queue configuration
+ *
+ * The information provided in this structure is required for QoS
+ * transmit queue configuration. Cf. IEEE 802.11 7.3.2.29.
+ *
+ * @aifs: arbitration interframe space [0..255]
+ * @cw_min: minimum contention window [a value of the form
+ *	2^n-1 in the range 1..32767]
+ * @cw_max: maximum contention window [like @cw_min]
+ * @txop: maximum burst time in units of 32 usecs, 0 meaning disabled
+ * @uapsd: is U-APSD mode enabled for the queue
+ */
+struct ieee80211_tx_queue_params {
+	u16 txop;
+	u16 cw_min;
+	u16 cw_max;
+	u8 aifs;
+	bool acm;
+	bool uapsd;
+};
+
+struct ieee80211_low_level_stats {
+	unsigned int dot11ACKFailureCount;
+	unsigned int dot11RTSFailureCount;
+	unsigned int dot11FCSErrorCount;
+	unsigned int dot11RTSSuccessCount;
+};
+
+/**
+ * enum ieee80211_bss_change - BSS change notification flags
+ *
+ * These flags are used with the bss_info_changed() callback
+ * to indicate which BSS parameter changed.
+ *
+ * @BSS_CHANGED_ASSOC: association status changed (associated/disassociated),
+ *	also implies a change in the AID.
+ * @BSS_CHANGED_ERP_CTS_PROT: CTS protection changed
+ * @BSS_CHANGED_ERP_PREAMBLE: preamble changed
+ * @BSS_CHANGED_ERP_SLOT: slot timing changed
+ * @BSS_CHANGED_HT: 802.11n parameters changed
+ * @BSS_CHANGED_BASIC_RATES: Basic rateset changed
+ * @BSS_CHANGED_BEACON_INT: Beacon interval changed
+ * @BSS_CHANGED_BSSID: BSSID changed, for whatever
+ *	reason (IBSS and managed mode)
+ * @BSS_CHANGED_BEACON: Beacon data changed, retrieve
+ *	new beacon (beaconing modes)
+ * @BSS_CHANGED_BEACON_ENABLED: Beaconing should be
+ *	enabled/disabled (beaconing modes)
+ * @BSS_CHANGED_CQM: Connection quality monitor config changed
+ * @BSS_CHANGED_IBSS: IBSS join status changed
+ * @BSS_CHANGED_ARP_FILTER: Hardware ARP filter address list or state changed.
+ * @BSS_CHANGED_QOS: QoS for this association was enabled/disabled. Note
+ *	that it is only ever disabled for station mode.
+ * @BSS_CHANGED_IDLE: Idle changed for this BSS/interface.
+ * @BSS_CHANGED_SSID: SSID changed for this BSS (AP mode)
+ * @BSS_CHANGED_PS: the PS flag or dynamic PS timeout changed
+ * @BSS_CHANGED_CHANNEL: vif channel changed
+ * @BSS_CHANGED_P2P_PS: NOA parameters changed.
+ */
+enum ieee80211_bss_change {
+	BSS_CHANGED_ASSOC		= 1<<0,
+	BSS_CHANGED_ERP_CTS_PROT	= 1<<1,
+	BSS_CHANGED_ERP_PREAMBLE	= 1<<2,
+	BSS_CHANGED_ERP_SLOT		= 1<<3,
+	BSS_CHANGED_HT			= 1<<4,
+	BSS_CHANGED_BASIC_RATES		= 1<<5,
+	BSS_CHANGED_BEACON_INT		= 1<<6,
+	BSS_CHANGED_BSSID		= 1<<7,
+	BSS_CHANGED_BEACON		= 1<<8,
+	BSS_CHANGED_BEACON_ENABLED	= 1<<9,
+	BSS_CHANGED_CQM			= 1<<10,
+	BSS_CHANGED_IBSS		= 1<<11,
+	BSS_CHANGED_ARP_FILTER		= 1<<12,
+	BSS_CHANGED_QOS			= 1<<13,
+	BSS_CHANGED_IDLE		= 1<<14,
+	BSS_CHANGED_SSID		= 1<<15,
+	BSS_CHANGED_PS			= 1<<16,
+	BSS_CHANGED_CHANNEL		= 1<<17, /* XXX: COMBO: should this be merged with _HT?*/
+	BSS_CHANGED_RETRY_LIMITS	= 1<<18,
+	BSS_CHANGED_P2P_PS		= 1<<19,
+#ifdef IPV6_FILTERING
+	BSS_CHANGED_NDP_FILTER		= 1<<20,
+#endif /*IPV6_FILTERING*/
+	BSS_CHANGED_BANDWIDTH		= 1<<21,
+	BSS_CHANGED_OCB				= 1<<22,
+	BSS_CHANGED_MU_GROUPS		= 1<<23,
+
+	/* when adding here, make sure to change ieee80211_reconfig */
+};
+
+/*
+ * The maximum number of IPv4 addresses listed for ARP filtering. If the number
+ * of addresses for an interface increase beyond this value, hardware ARP
+ * filtering will be disabled.
+ */
+#define IEEE80211_BSS_ARP_ADDR_LIST_LEN 4
+
+#ifdef IPV6_FILTERING
+/*
+ * The maximum number of IPv6 addresses listed for NDP filtering. If the number
+ * of addresses for an interface increase beyond this value, hardware NDP
+ * filtering will be disabled.
+ */
+#define IEEE80211_BSS_NDP_ADDR_LIST_LEN 4
+#endif /*IPV6_FILTERING*/
+
+/**
+ * enum ieee80211_rssi_event - RSSI threshold event
+ * An indicator for when RSSI goes below/above a certain threshold.
+ * @RSSI_EVENT_HIGH: AP's rssi crossed the high threshold set by the driver.
+ * @RSSI_EVENT_LOW: AP's rssi crossed the low threshold set by the driver.
+ */
+enum ieee80211_rssi_event {
+	RSSI_EVENT_HIGH,
+	RSSI_EVENT_LOW,
+};
+
+/**
+ * ieee80211_channel_conf - channel configuration
+ *
+ * @channel: the channel to tune to
+ * @channel_type: the channel (HT) type
+ * @offchannel: The device is currently not on its main operating channel.
+ */
+struct ieee80211_channel_conf {
+	struct ieee80211_channel *channel;
+	enum nl80211_channel_type channel_type;
+	bool offchannel;
+};
+
+/**
+ * struct cfg80211_p2p_ps - p2p power save params
+ *
+ * This structure ...
+ *
+ * @legacy_ps: 0=disable, 1=enable, 2=maximum_ps, -1=no change
+ * @opp_ps: 0=disable, 1=enable, -1=no change
+ * @ctwidnow: 0... - change in ms, -1=no change
+ * @count: 0..255 - count
+ * @start: Start time in ms from next TBTT
+ * @duration: Duration in ms
+ * @interval: interval in ms
+ */
+struct cfg80211_p2p_ps {
+	int	legacy_ps;
+
+	/* Opportunistic Power Save */
+	int	opp_ps;
+	int	ctwindow;
+
+	/* Notice of Absence */
+	int	count;
+	int	start;
+	int	duration;
+	int	interval;
+
+	/* Index */
+	u8	index;
+};
+
+/**
+ * struct ieee80211_bss_conf - holds the BSS's changing parameters
+ *
+ * This structure keeps information about a BSS (and an association
+ * to that BSS) that can change during the lifetime of the BSS.
+ *
+ * @assoc: association status
+ * @ibss_joined: indicates whether this station is part of an IBSS
+ *	or not
+ * @aid: association ID number, valid only when @assoc is true
+ * @use_cts_prot: use CTS protection
+ * @use_short_preamble: use 802.11b short preamble;
+ *	if the hardware cannot handle this it must set the
+ *	IEEE80211_HW_2GHZ_SHORT_PREAMBLE_INCAPABLE hardware flag
+ * @use_short_slot: use short slot time (only relevant for ERP);
+ *	if the hardware cannot handle this it must set the
+ *	IEEE80211_HW_2GHZ_SHORT_SLOT_INCAPABLE hardware flag
+ * @dtim_period: num of beacons before the next DTIM, for beaconing,
+ *	valid in station mode only while @assoc is true and if also
+ *	requested by %IEEE80211_HW_NEED_DTIM_PERIOD (cf. also hw conf
+ *	@ps_dtim_period)
+ * @timestamp: beacon timestamp
+ * @beacon_int: beacon interval
+ * @assoc_capability: capabilities taken from assoc resp
+ * @basic_rates: bitmap of basic rates, each bit stands for an
+ *	index into the rate table configured by the driver in
+ *	the current band.
+ * @mcast_rate: per-band multicast rate index + 1 (0: disabled)
+ * @bssid: The BSSID for this BSS
+ * @enable_beacon: whether beaconing should be enabled or not
+ * @channel_type: Channel type for this BSS -- the hardware might be
+ *	configured for HT40+ while this BSS only uses no-HT, for
+ *	example.
+ * @ht_operation_mode: HT operation mode (like in &struct ieee80211_ht_info).
+ *	This field is only valid when the channel type is one of the HT types.
+ * @cqm_rssi_thold: Connection quality monitor RSSI threshold, a zero value
+ *	implies disabled
+ * @cqm_rssi_hyst: Connection quality monitor RSSI hysteresis
+ * @cqm_beacon_miss_thold: Connection quality monitor beacon threshold, a zero
+ *	value implies disabled
+ * @cqm_tx_fail_thold: Connection quality monitor tx threshold, a zero value
+ *	implies disabled
+ * @arp_addr_list: List of IPv4 addresses for hardware ARP filtering. The
+ *	may filter ARP queries targeted for other addresses than listed here.
+ *	The driver must allow ARP queries targeted for all address listed here
+ *	to pass through. An empty list implies no ARP queries need to pass.
+ * @arp_addr_cnt: Number of addresses currently on the list.
+ * @arp_filter_enabled: Enable ARP filtering - if enabled, the hardware may
+ *	filter ARP queries based on the @arp_addr_list, if disabled, the
+ *	hardware must not perform any ARP filtering. Note, that the filter will
+ *	be enabled also in promiscuous mode.
+ * @qos: This is a QoS-enabled BSS.
+ * @idle: This interface is idle. There's also a global idle flag in the
+ *	hardware config which may be more appropriate depending on what
+ *	your driver/device needs to do.
+ * @ps_enabled: Enable 802.11 power save mode (managed mode only). This is the power
+ *	save mode defined by IEEE 802.11-2007 section 11.2, meaning that the
+ *	hardware still wakes up for beacons, is able to transmit frames and
+ *	receive the possible acknowledgment frames. Not to be confused with
+ *	hardware specific wakeup/sleep states, driver is responsible for that.
+ *	See the section "Powersave support" for more.
+ * @listen_interval: listen interval in units of beacon interval
+ * @max_sleep_period: the maximum number of beacon intervals to sleep for
+ *	before checking the beacon for a TIM bit (managed mode only); this
+ *	value will be only achievable between DTIM frames, the hardware
+ *	needs to check for the multicast traffic bit in DTIM beacons.
+ *	This variable is valid only when the ps_enabled variable is true.
+ * @ps_dtim_period: The DTIM period of the AP we're connected to, for use
+ *	in power saving. Power saving will not be enabled until a beacon
+ *	has been received and the DTIM period is known.
+ * @dynamic_ps_timeout: The dynamic powersave timeout (in ms), see the
+ *	powersave documentation below. This variable is valid only when
+ *	the ps_enabled variable is true.
+ * @ssid: The SSID of the current vif. Only valid in AP-mode.
+ * @ssid_len: Length of SSID given in @ssid.
+ * @hidden_ssid: The SSID of the current vif is hidden. Only valid in AP-mode.
+ * @chan_conf: current channel configuration (i.e. channel, channel type)
+ * @ndp_addr_list: List of IPv6 addresses for hardware NDP filtering. The
+ *	may filter NDP queries targeted for other addresses than listed here.
+ *	The driver must allow NDP queries targeted for all address listed here
+ *	to pass through. An empty list implies no NDP queries need to pass.
+ * @ndp_addr_cnt: Number of addresses currently on the list.
+ * @ndp_filter_enabled: Enable NDP filtering - if enabled, the hardware may
+ *	filter NDP queries based on the @ndp_addr_list, if disabled, the
+ *	hardware must not perform any NDP filtering. Note, that the filter will
+ *	be enabled also in promiscuous mode.
+ */
+struct ieee80211_bss_conf {
+	const u8 *bssid;
+	/* association related data */
+	bool assoc, ibss_joined;
+	u16 aid;
+	/* erp related data */
+	bool use_cts_prot;
+	bool use_short_preamble;
+	bool use_short_slot;
+	bool enable_beacon;
+	u8 dtim_period;
+	u16 beacon_int;
+	u16 assoc_capability;
+	u64 timestamp;
+	u32 basic_rates;
+	int mcast_rate[NUM_NL80211_BANDS];
+	u16 ht_operation_mode;
+	s32 cqm_rssi_thold;
+	u32 cqm_rssi_hyst;
+	u32 cqm_beacon_miss_thold;
+	u32 cqm_tx_fail_thold;
+	enum nl80211_channel_type channel_type;
+	__be32 arp_addr_list[IEEE80211_BSS_ARP_ADDR_LIST_LEN];
+	u8 arp_addr_cnt;
+	bool arp_filter_enabled;
+	bool qos;
+	bool idle;
+	bool ps_enabled;
+	int dynamic_ps_timeout;
+	int max_sleep_period;
+	int listen_interval;
+	int ps_dtim_period;
+	u8 ssid[IEEE80211_MAX_SSID_LEN];
+	size_t ssid_len;
+	bool hidden_ssid;
+	struct ieee80211_channel_conf *chan_conf;
+	u8 retry_short;
+	u8 retry_long;
+	struct cfg80211_p2p_ps p2p_ps;
+
+#ifdef IPV6_FILTERING
+	struct in6_addr ndp_addr_list[IEEE80211_BSS_NDP_ADDR_LIST_LEN];
+	u8 ndp_addr_cnt;
+	bool ndp_filter_enabled;
+#endif /*IPV6_FILTERING*/
+    u32 ap_rx_beacon_erp_info;
+};
+
+/**
+ * enum mac80211_tx_control_flags - flags to describe transmission information/status
+ *
+ * These flags are used with the @flags member of &ieee80211_tx_info.
+ *
+ * @IEEE80211_TX_CTL_REQ_TX_STATUS: require TX status callback for this frame.
+ * @IEEE80211_TX_CTL_ASSIGN_SEQ: The driver has to assign a sequence
+ *	number to this frame, taking care of not overwriting the fragment
+ *	number and increasing the sequence number only when the
+ *	IEEE80211_TX_CTL_FIRST_FRAGMENT flag is set. mac80211 will properly
+ *	assign sequence numbers to QoS-data frames but cannot do so correctly
+ *	for non-QoS-data and management frames because beacons need them from
+ *	that counter as well and mac80211 cannot guarantee proper sequencing.
+ *	If this flag is set, the driver should instruct the hardware to
+ *	assign a sequence number to the frame or assign one itself. Cf. IEEE
+ *	802.11-2007 7.1.3.4.1 paragraph 3. This flag will always be set for
+ *	beacons and always be clear for frames without a sequence number field.
+ * @IEEE80211_TX_CTL_NO_ACK: tell the low level not to wait for an ack
+ * @IEEE80211_TX_CTL_CLEAR_PS_FILT: clear powersave filter for destination
+ *	station
+ * @IEEE80211_TX_CTL_FIRST_FRAGMENT: this is a first fragment of the frame
+ * @IEEE80211_TX_CTL_SEND_AFTER_DTIM: send this frame after DTIM beacon
+ * @IEEE80211_TX_CTL_AMPDU: this frame should be sent as part of an A-MPDU
+ * @IEEE80211_TX_CTL_INJECTED: Frame was injected, internal to mac80211.
+ * @IEEE80211_TX_STAT_TX_FILTERED: The frame was not transmitted
+ *	because the destination STA was in powersave mode. Note that to
+ *	avoid race conditions, the filter must be set by the hardware or
+ *	firmware upon receiving a frame that indicates that the station
+ *	went to sleep (must be done on device to filter frames already on
+ *	the queue) and may only be unset after mac80211 gives the OK for
+ *	that by setting the IEEE80211_TX_CTL_CLEAR_PS_FILT (see above),
+ *	since only then is it guaranteed that no more frames are in the
+ *	hardware queue.
+ * @IEEE80211_TX_STAT_ACK: Frame was acknowledged
+ * @IEEE80211_TX_STAT_AMPDU: The frame was aggregated, so status
+ * 	is for the whole aggregation.
+ * @IEEE80211_TX_STAT_AMPDU_NO_BACK: no block ack was returned,
+ * 	so consider using block ack request (BAR).
+ * @IEEE80211_TX_CTL_RATE_CTRL_PROBE: internal to mac80211, can be
+ *	set by rate control algorithms to indicate probe rate, will
+ *	be cleared for fragmented frames (except on the last fragment)
+ * @IEEE80211_TX_INTFL_NEED_TXPROCESSING: completely internal to mac80211,
+ *	used to indicate that a pending frame requires TX processing before
+ *	it can be sent out.
+ * @IEEE80211_TX_INTFL_RETRIED: completely internal to mac80211,
+ *	used to indicate that a frame was already retried due to PS
+ * @IEEE80211_TX_INTFL_DONT_ENCRYPT: completely internal to mac80211,
+ *	used to indicate frame should not be encrypted
+ * @IEEE80211_TX_CTL_POLL_RESPONSE: This frame is a response to a poll
+ *	frame (PS-Poll or uAPSD) and should be sent although the station
+ *	is in powersave mode.
+ * @IEEE80211_TX_CTL_MORE_FRAMES: More frames will be passed to the
+ *	transmit function after the current frame, this can be used
+ *	by drivers to kick the DMA queue only if unset or when the
+ *	queue gets full.
+ * @IEEE80211_TX_INTFL_RETRANSMISSION: This frame is being retransmitted
+ *	after TX status because the destination was asleep, it must not
+ *	be modified again (no seqno assignment, crypto, etc.)
+ * @IEEE80211_TX_INTFL_NL80211_FRAME_TX: Frame was requested through nl80211
+ *	MLME command (internal to mac80211 to figure out whether to send TX
+ *	status to user space)
+ * @IEEE80211_TX_CTL_LDPC: tells the driver to use LDPC for this frame
+ * @IEEE80211_TX_CTL_STBC: Enables Space-Time Block Coding (STBC) for this
+ *	frame and selects the maximum number of streams that it can use.
+ * @IEEE80211_TX_CTL_TX_OFFCHAN: Marks this packet to be transmitted on
+ *	the off-channel channel when a remain-on-channel offload is done
+ *	in hardware -- normal packets still flow and are expected to be
+ *	handled properly by the device.
+ * @IEEE80211_TX_INTFL_TKIP_MIC_FAILURE: Marks this packet to be used for TKIP
+ *	testing. It will be sent out with incorrect Michael MIC key to allow
+ *	TKIP countermeasures to be tested.
+ * @IEEE80211_TX_CTL_NO_CCK_RATE: This frame will be sent at non CCK rate.
+ *	This flag is actually used for management frame especially for P2P
+ *	frames not being sent at CCK rate in 2GHz band.
+ * @IEEE80211_TX_STATUS_EOSP: This packet marks the end of service period,
+ *	when its status is reported the service period ends. For frames in
+ *	an SP that mac80211 transmits, it is already set; for driver frames
+ *	the driver may set this flag. It is also used to do the same for
+ *	PS-Poll responses.
+ * @IEEE80211_TX_CTL_USE_MINRATE: This frame will be sent at lowest rate.
+ *	This flag is used to send nullfunc frame at minimum rate when
+ *	the nullfunc is used for connection monitoring purpose.
+ * @IEEE80211_TX_CTL_DONTFRAG: Don't fragment this packet even if it
+ *	would be fragmented by size (this is optional, only used for
+ *	monitor injection).
+ *
+ * Note: If you have to add new flags to the enumeration, then don't
+ *	 forget to update %IEEE80211_TX_TEMPORARY_FLAGS when necessary.
+ */
+enum mac80211_tx_control_flags {
+	IEEE80211_TX_CTL_REQ_TX_STATUS		= BIT(0),
+	IEEE80211_TX_CTL_ASSIGN_SEQ		= BIT(1),
+	IEEE80211_TX_CTL_NO_ACK			= BIT(2),
+	IEEE80211_TX_CTL_CLEAR_PS_FILT		= BIT(3),
+	IEEE80211_TX_CTL_FIRST_FRAGMENT		= BIT(4),
+	IEEE80211_TX_CTL_SEND_AFTER_DTIM	= BIT(5),
+	IEEE80211_TX_CTL_AMPDU			= BIT(6),
+	IEEE80211_TX_CTL_INJECTED		= BIT(7),
+	IEEE80211_TX_STAT_TX_FILTERED		= BIT(8),
+	IEEE80211_TX_STAT_ACK			= BIT(9),
+	IEEE80211_TX_STAT_AMPDU			= BIT(10),
+	IEEE80211_TX_STAT_AMPDU_NO_BACK		= BIT(11),
+	IEEE80211_TX_CTL_RATE_CTRL_PROBE	= BIT(12),
+	IEEE80211_TX_INTFL_NEED_TXPROCESSING	= BIT(14),
+	IEEE80211_TX_INTFL_RETRIED		= BIT(15),
+	IEEE80211_TX_INTFL_DONT_ENCRYPT		= BIT(16),
+	IEEE80211_TX_CTL_POLL_RESPONSE		= BIT(17),
+	IEEE80211_TX_CTL_MORE_FRAMES		= BIT(18),
+	IEEE80211_TX_INTFL_RETRANSMISSION	= BIT(19),
+	/* hole at 20, use later */
+	IEEE80211_TX_INTFL_NL80211_FRAME_TX	= BIT(21),
+	IEEE80211_TX_CTL_LDPC			= BIT(22),
+	IEEE80211_TX_CTL_STBC			= BIT(23) | BIT(24),
+	IEEE80211_TX_CTL_TX_OFFCHAN		= BIT(25),
+	IEEE80211_TX_INTFL_TKIP_MIC_FAILURE	= BIT(26),
+	IEEE80211_TX_CTL_NO_CCK_RATE		= BIT(27),
+	IEEE80211_TX_STATUS_EOSP		= BIT(28),
+	IEEE80211_TX_CTL_USE_MINRATE		= BIT(29),
+	IEEE80211_TX_CTL_DONTFRAG		= BIT(30),
+};
+
+#define IEEE80211_TX_CTL_STBC_SHIFT		23
+
+/*
+ * This definition is used as a mask to clear all temporary flags, which are
+ * set by the tx handlers for each transmission attempt by the mac80211 stack.
+ */
+#define IEEE80211_TX_TEMPORARY_FLAGS (IEEE80211_TX_CTL_NO_ACK |		      \
+	IEEE80211_TX_CTL_CLEAR_PS_FILT | IEEE80211_TX_CTL_FIRST_FRAGMENT |    \
+	IEEE80211_TX_CTL_SEND_AFTER_DTIM | IEEE80211_TX_CTL_AMPDU |	      \
+	IEEE80211_TX_STAT_TX_FILTERED |	IEEE80211_TX_STAT_ACK |		      \
+	IEEE80211_TX_STAT_AMPDU | IEEE80211_TX_STAT_AMPDU_NO_BACK |	      \
+	IEEE80211_TX_CTL_RATE_CTRL_PROBE | IEEE80211_TX_CTL_POLL_RESPONSE |   \
+	IEEE80211_TX_CTL_MORE_FRAMES | IEEE80211_TX_CTL_LDPC |		      \
+	IEEE80211_TX_CTL_STBC | IEEE80211_TX_STATUS_EOSP)
+
+/**
+ * enum mac80211_rate_control_flags - per-rate flags set by the
+ *	Rate Control algorithm.
+ *
+ * These flags are set by the Rate control algorithm for each rate during tx,
+ * in the @flags member of struct ieee80211_tx_rate.
+ *
+ * @IEEE80211_TX_RC_USE_RTS_CTS: Use RTS/CTS exchange for this rate.
+ * @IEEE80211_TX_RC_USE_CTS_PROTECT: CTS-to-self protection is required.
+ *	This is set if the current BSS requires ERP protection.
+ * @IEEE80211_TX_RC_USE_SHORT_PREAMBLE: Use short preamble.
+ * @IEEE80211_TX_RC_MCS: HT rate.
+ * @IEEE80211_TX_RC_GREEN_FIELD: Indicates whether this rate should be used in
+ *	Greenfield mode.
+ * @IEEE80211_TX_RC_40_MHZ_WIDTH: Indicates if the Channel Width should be 40 MHz.
+ * @IEEE80211_TX_RC_DUP_DATA: The frame should be transmitted on both of the
+ *	adjacent 20 MHz channels, if the current channel type is
+ *	NL80211_CHAN_HT40MINUS or NL80211_CHAN_HT40PLUS.
+ * @IEEE80211_TX_RC_SHORT_GI: Short Guard interval should be used for this rate.
+ */
+enum mac80211_rate_control_flags {
+	IEEE80211_TX_RC_USE_RTS_CTS		= BIT(0),
+	IEEE80211_TX_RC_USE_CTS_PROTECT		= BIT(1),
+	IEEE80211_TX_RC_USE_SHORT_PREAMBLE	= BIT(2),
+
+	/* rate index is an MCS rate number instead of an index */
+	IEEE80211_TX_RC_MCS			= BIT(3),
+	IEEE80211_TX_RC_GREEN_FIELD		= BIT(4),
+	IEEE80211_TX_RC_40_MHZ_WIDTH		= BIT(5),
+	IEEE80211_TX_RC_DUP_DATA		= BIT(6),
+	IEEE80211_TX_RC_SHORT_GI		= BIT(7),
+};
+
+
+/* there are 40 bytes if you don't need the rateset to be kept */
+#define IEEE80211_TX_INFO_DRIVER_DATA_SIZE 40
+
+/* if you do need the rateset, then you have less space */
+#define IEEE80211_TX_INFO_RATE_DRIVER_DATA_SIZE 24
+
+/* maximum number of rate stages */
+#define IEEE80211_TX_MAX_RATES	5
+
+/**
+ * struct ieee80211_tx_rate - rate selection/status
+ *
+ * @idx: rate index to attempt to send with
+ * @flags: rate control flags (&enum mac80211_rate_control_flags)
+ * @count: number of tries in this rate before going to the next rate
+ *
+ * A value of -1 for @idx indicates an invalid rate and, if used
+ * in an array of retry rates, that no more rates should be tried.
+ *
+ * When used for transmit status reporting, the driver should
+ * always report the rate along with the flags it used.
+ *
+ * &struct ieee80211_tx_info contains an array of these structs
+ * in the control information, and it will be filled by the rate
+ * control algorithm according to what should be sent. For example,
+ * if this array contains, in the format { <idx>, <count> } the
+ * information
+ *    { 3, 2 }, { 2, 2 }, { 1, 4 }, { -1, 0 }, { -1, 0 }
+ * then this means that the frame should be transmitted
+ * up to twice at rate 3, up to twice at rate 2, and up to four
+ * times at rate 1 if it doesn't get acknowledged. Say it gets
+ * acknowledged by the peer after the fifth attempt, the status
+ * information should then contain
+ *   { 3, 2 }, { 2, 2 }, { 1, 1 }, { -1, 0 } ...
+ * since it was transmitted twice at rate 3, twice at rate 2
+ * and once at rate 1 after which we received an acknowledgement.
+ */
+struct ieee80211_tx_rate {
+	s8 idx;
+	u8 count;
+	u8 flags;
+} __packed;
+
+/**
+ * struct ieee80211_tx_info - skb transmit information
+ *
+ * This structure is placed in skb->cb for three uses:
+ *  (1) mac80211 TX control - mac80211 tells the driver what to do
+ *  (2) driver internal use (if applicable)
+ *  (3) TX status information - driver tells mac80211 what happened
+ *
+ * The TX control's sta pointer is only valid during the ->tx call,
+ * it may be NULL.
+ *
+ * @flags: transmit info flags, defined above
+ * @band: the band to transmit on (use for checking for races)
+ * @antenna_sel_tx: antenna to use, 0 for automatic diversity
+ * @hw_queue: HW queue to put the frame on, skb_get_queue_mapping() gives the AC
+ * @pad: padding, ignore
+ * @control: union for control data
+ * @status: union for status data
+ * @driver_data: array of driver_data pointers
+ * @ampdu_ack_len: number of acked aggregated frames.
+ * 	relevant only if IEEE80211_TX_STAT_AMPDU was set.
+ * @ampdu_len: number of aggregated frames.
+ * 	relevant only if IEEE80211_TX_STAT_AMPDU was set.
+ * @ack_signal: signal strength of the ACK frame
+ */
+struct ieee80211_tx_info {
+	/* common information */
+	u32 flags;
+	u8 band;
+
+	u8 antenna_sel_tx;
+
+	u8 hw_queue;
+	/* 2 byte hole */
+	u8 pad[1];
+
+	union {
+		struct {
+			union {
+				/* rate control */
+				struct {
+					struct ieee80211_tx_rate rates[
+						IEEE80211_TX_MAX_RATES];
+					s8 rts_cts_rate_idx;
+				};
+				/* only needed before rate control */
+				unsigned long jiffies;
+			};
+			/* NB: vif can be NULL for injected frames */
+			struct ieee80211_vif *vif;
+			struct ieee80211_key_conf *hw_key;
+			struct ieee80211_sta *sta;
+		} control;
+		struct {
+			struct ieee80211_tx_rate rates[IEEE80211_TX_MAX_RATES];
+			u8 ampdu_ack_len;
+			int ack_signal;
+			u8 ampdu_len;
+			/* 15 bytes free */
+		} status;
+		struct {
+			struct ieee80211_tx_rate driver_rates[
+				IEEE80211_TX_MAX_RATES];
+			void *rate_driver_data[
+				IEEE80211_TX_INFO_RATE_DRIVER_DATA_SIZE / sizeof(void *)];
+		};
+		void *driver_data[
+			IEEE80211_TX_INFO_DRIVER_DATA_SIZE / sizeof(void *)];
+	};
+};
+
+/**
+ * struct ieee80211_sched_scan_ies - scheduled scan IEs
+ *
+ * This structure is used to pass the appropriate IEs to be used in scheduled
+ * scans for all bands.  It contains both the IEs passed from the userspace
+ * and the ones generated by mac80211.
+ *
+ * @ie: array with the IEs for each supported band
+ * @len: array with the total length of the IEs for each band
+ */
+struct ieee80211_sched_scan_ies {
+	u8 *ie[NUM_NL80211_BANDS];
+	size_t len[NUM_NL80211_BANDS];
+};
+
+static inline struct ieee80211_tx_info *IEEE80211_SKB_CB(struct sk_buff *skb)
+{
+	return (struct ieee80211_tx_info *)skb->cb;
+}
+
+static inline struct ieee80211_rx_status *IEEE80211_SKB_RXCB(struct sk_buff *skb)
+{
+	return (struct ieee80211_rx_status *)skb->cb;
+}
+
+/**
+ * ieee80211_tx_info_clear_status - clear TX status
+ *
+ * @info: The &struct ieee80211_tx_info to be cleared.
+ *
+ * When the driver passes an skb back to mac80211, it must report
+ * a number of things in TX status. This function clears everything
+ * in the TX status but the rate control information (it does clear
+ * the count since you need to fill that in anyway).
+ *
+ * NOTE: You can only use this function if you do NOT use
+ *	 info->driver_data! Use info->rate_driver_data
+ *	 instead if you need only the less space that allows.
+ */
+static inline void
+ieee80211_tx_info_clear_status(struct ieee80211_tx_info *info)
+{
+	int i;
+
+	BUILD_BUG_ON(offsetof(struct ieee80211_tx_info, status.rates) !=
+		     offsetof(struct ieee80211_tx_info, control.rates));
+	BUILD_BUG_ON(offsetof(struct ieee80211_tx_info, status.rates) !=
+		     offsetof(struct ieee80211_tx_info, driver_rates));
+	BUILD_BUG_ON(offsetof(struct ieee80211_tx_info, status.rates) != 8);
+	/* clear the rate counts */
+	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
+		info->status.rates[i].count = 0;
+
+	BUILD_BUG_ON(
+	    offsetof(struct ieee80211_tx_info, status.ampdu_ack_len) != 23);
+	memset(&info->status.ampdu_ack_len, 0,
+	       sizeof(struct ieee80211_tx_info) -
+	       offsetof(struct ieee80211_tx_info, status.ampdu_ack_len));
+}
+
+
+/**
+ * enum mac80211_rx_flags - receive flags
+ *
+ * These flags are used with the @flag member of &struct ieee80211_rx_status.
+ * @RX_FLAG_MMIC_ERROR: Michael MIC error was reported on this frame.
+ *	Use together with %RX_FLAG_MMIC_STRIPPED.
+ * @RX_FLAG_DECRYPTED: This frame was decrypted in hardware.
+ * @RX_FLAG_MMIC_STRIPPED: the Michael MIC is stripped off this frame,
+ *	verification has been done by the hardware.
+ * @RX_FLAG_IV_STRIPPED: The IV/ICV are stripped from this frame.
+ *	If this flag is set, the stack cannot do any replay detection
+ *	hence the driver or hardware will have to do that.
+ * @RX_FLAG_FAILED_FCS_CRC: Set this flag if the FCS check failed on
+ *	the frame.
+ * @RX_FLAG_FAILED_PLCP_CRC: Set this flag if the PCLP check failed on
+ *	the frame.
+ * @RX_FLAG_MACTIME_MPDU: The timestamp passed in the RX status (@mactime
+ *	field) is valid and contains the time the first symbol of the MPDU
+ *	was received. This is useful in monitor mode and for proper IBSS
+ *	merging.
+ * @RX_FLAG_SHORTPRE: Short preamble was used for this frame
+ * @RX_FLAG_HT: HT MCS was used and rate_idx is MCS index
+ * @RX_FLAG_40MHZ: HT40 (40 MHz) was used
+ * @RX_FLAG_SHORT_GI: Short guard interval was used
+ */
+enum mac80211_rx_flags {
+	RX_FLAG_MMIC_ERROR	= 1<<0,
+	RX_FLAG_DECRYPTED	= 1<<1,
+	RX_FLAG_MMIC_STRIPPED	= 1<<3,
+	RX_FLAG_IV_STRIPPED	= 1<<4,
+	RX_FLAG_FAILED_FCS_CRC	= 1<<5,
+	RX_FLAG_FAILED_PLCP_CRC = 1<<6,
+	RX_FLAG_MACTIME_MPDU	= 1<<7,
+	RX_FLAG_SHORTPRE	= 1<<8,
+	RX_FLAG_HT		= 1<<9,
+	RX_FLAG_40MHZ		= 1<<10,
+	RX_FLAG_SHORT_GI	= 1<<11,
+};
+
+/**
+ * struct ieee80211_rx_status - receive status
+ *
+ * The low-level driver should provide this information (the subset
+ * supported by hardware) to the 802.11 code with each received
+ * frame, in the skb's control buffer (cb).
+ *
+ * @mactime: value in microseconds of the 64-bit Time Synchronization Function
+ * 	(TSF) timer when the first data symbol (MPDU) arrived at the hardware.
+ * @band: the active band when this frame was received
+ * @freq: frequency the radio was tuned to when receiving this frame, in MHz
+ * @signal: signal strength when receiving this frame, either in dBm, in dB or
+ *	unspecified depending on the hardware capabilities flags
+ *	@IEEE80211_HW_SIGNAL_*
+ * @antenna: antenna used
+ * @rate_idx: index of data rate into band's supported rates or MCS index if
+ *	HT rates are use (RX_FLAG_HT)
+ * @flag: %RX_FLAG_*
+ * @rx_flags: internal RX flags for mac80211
+ */
+struct ieee80211_rx_status {
+	u64 mactime;
+	enum nl80211_band band;
+	int freq;
+	int signal;
+	int antenna;
+	int rate_idx;
+	int flag;
+	unsigned int rx_flags;
+};
+
+/**
+ * enum ieee80211_conf_flags - configuration flags
+ *
+ * Flags to define PHY configuration options
+ *
+ * @IEEE80211_CONF_MONITOR: there's a monitor interface present -- use this
+ *	to determine for example whether to calculate timestamps for packets
+ *	or not, do not use instead of filter flags!
+ * @IEEE80211_CONF_PS: Enable 802.11 power save mode (managed mode only).
+ *	This is the power save mode defined by IEEE 802.11-2007 section 11.2,
+ *	meaning that the hardware still wakes up for beacons, is able to
+ *	transmit frames and receive the possible acknowledgment frames.
+ *	Not to be confused with hardware specific wakeup/sleep states,
+ *	driver is responsible for that. See the section "Powersave support"
+ *	for more.
+ * @IEEE80211_CONF_IDLE: The device is running, but idle; if the flag is set
+ *	the driver should be prepared to handle configuration requests but
+ *	may turn the device off as much as possible. Typically, this flag will
+ *	be set when an interface is set UP but not associated or scanning, but
+ *	it can also be unset in that case when monitor interfaces are active.
+ */
+enum ieee80211_conf_flags {
+	IEEE80211_CONF_MONITOR		= (1<<0),
+	IEEE80211_CONF_PS		= (1<<1),
+	IEEE80211_CONF_IDLE		= (1<<2),
+};
+
+
+/**
+ * enum ieee80211_conf_changed - denotes which configuration changed
+ *
+ * @IEEE80211_CONF_CHANGE_LISTEN_INTERVAL: the listen interval changed
+ * @IEEE80211_CONF_CHANGE_MONITOR: the monitor flag changed
+ * @IEEE80211_CONF_CHANGE_PS: the PS flag or dynamic PS timeout changed
+ * @IEEE80211_CONF_CHANGE_POWER: the TX power changed
+ * @IEEE80211_CONF_CHANGE_CHANNEL: the channel/channel_type changed
+ * @IEEE80211_CONF_CHANGE_RETRY_LIMITS: retry limits changed
+ * @IEEE80211_CONF_CHANGE_IDLE: Idle flag changed
+ * @IEEE80211_CONF_CHANGE_SMPS: Spatial multiplexing powersave mode changed
+ */
+enum ieee80211_conf_changed {
+	IEEE80211_CONF_CHANGE_SMPS		= BIT(1),
+	IEEE80211_CONF_CHANGE_LISTEN_INTERVAL	= BIT(2),
+	IEEE80211_CONF_CHANGE_MONITOR		= BIT(3),
+	IEEE80211_CONF_CHANGE_PS		= BIT(4),
+	IEEE80211_CONF_CHANGE_POWER		= BIT(5),
+	IEEE80211_CONF_CHANGE_CHANNEL		= BIT(6),
+	IEEE80211_CONF_CHANGE_RETRY_LIMITS	= BIT(7),
+	IEEE80211_CONF_CHANGE_IDLE		= BIT(8),
+};
+
+/**
+ * enum ieee80211_smps_mode - spatial multiplexing power save mode
+ *
+ * @IEEE80211_SMPS_AUTOMATIC: automatic
+ * @IEEE80211_SMPS_OFF: off
+ * @IEEE80211_SMPS_STATIC: static
+ * @IEEE80211_SMPS_DYNAMIC: dynamic
+ * @IEEE80211_SMPS_NUM_MODES: internal, don't use
+ */
+enum ieee80211_smps_mode {
+	IEEE80211_SMPS_AUTOMATIC,
+	IEEE80211_SMPS_OFF,
+	IEEE80211_SMPS_STATIC,
+	IEEE80211_SMPS_DYNAMIC,
+
+	/* keep last */
+	IEEE80211_SMPS_NUM_MODES,
+};
+
+/**
+ * struct ieee80211_conf - configuration of the device
+ *
+ * This struct indicates how the driver shall configure the hardware.
+ *
+ * @flags: configuration flags defined above
+ *
+ * @power_level: requested transmit power (in dBm)
+ *
+ * @long_frame_max_tx_count: Maximum number of transmissions for a "long" frame
+ *    (a frame not RTS protected), called "dot11LongRetryLimit" in 802.11,
+ *    but actually means the number of transmissions not the number of retries
+ * @short_frame_max_tx_count: Maximum number of transmissions for a "short"
+ *    frame, called "dot11ShortRetryLimit" in 802.11, but actually means the
+ *    number of transmissions not the number of retries
+ *
+ * @chan_conf: current channel configuration (i.e. channel, channel type)
+ *
+ * @smps_mode: spatial multiplexing powersave mode; note that
+ *	%IEEE80211_SMPS_STATIC is used when the device is not
+ *	configured for an HT channel
+ */
+struct ieee80211_conf {
+	u32 flags;
+	int power_level;
+
+	u8 long_frame_max_tx_count, short_frame_max_tx_count;
+
+	struct ieee80211_channel_conf *chan_conf;
+	enum ieee80211_smps_mode smps_mode;
+};
+
+/**
+ * struct ieee80211_channel_switch - holds the channel switch data
+ *
+ * The information provided in this structure is required for channel switch
+ * operation.
+ *
+ * @timestamp: value in microseconds of the 64-bit Time Synchronization
+ *	Function (TSF) timer when the frame containing the channel switch
+ *	announcement was received. This is simply the rx.mactime parameter
+ *	the driver passed into mac80211.
+ * @block_tx: Indicates whether transmission must be blocked before the
+ *	scheduled channel switch, as indicated by the AP.
+ * @channel: the new channel to switch to
+ * @count: the number of TBTT's until the channel switch event
+ */
+struct ieee80211_channel_switch {
+	u64 timestamp;
+	bool block_tx;
+	struct ieee80211_channel *channel;
+	u8 count;
+};
+
+/**
+ * struct ieee80211_vif - per-interface data
+ *
+ * Data in this structure is continually present for driver
+ * use during the life of a virtual interface.
+ *
+ * @type: type of this virtual interface
+ * @bss_conf: BSS configuration for this interface, either our own
+ *	or the BSS we're associated to
+ * @addr: address of this interface
+ * @p2p: indicates whether this AP or STA interface is a p2p
+ *	interface, i.e. a GO or p2p-sta respectively
+ * @hw_queue: hardware queue for each AC
+ * @cab_queue: content-after-beacon (DTIM beacon really) queue, AP mode only
+ * @drv_priv: data area for driver use, will always be aligned to
+ *	sizeof(void *).
+ */
+struct ieee80211_vif {
+	enum nl80211_iftype type;
+	struct ieee80211_bss_conf bss_conf;
+	u8 addr[ETH_ALEN];
+	bool p2p;
+	bool csa_active;
+
+	u8 cab_queue;
+	u8 hw_queue[IEEE80211_NUM_ACS];
+
+	struct ieee80211_txq *txq;
+
+	struct ieee80211_chanctx_conf __rcu *chanctx_conf;
+
+	u32 driver_flags;
+
+#ifdef CONFIG_MAC80211_DEBUGFS
+	struct dentry *debugfs_dir;
+#endif
+
+	unsigned int probe_req_reg;
+
+	/* must be last */
+	u8 drv_priv[0] __aligned(sizeof(void *));
+};
+
+static inline bool ieee80211_vif_is_mesh(struct ieee80211_vif *vif)
+{
+#ifdef CONFIG_XRMAC_MESH
+	return vif->type == NL80211_IFTYPE_MESH_POINT;
+#endif
+	return false;
+}
+
+/**
+ * enum ieee80211_key_flags - key flags
+ *
+ * These flags are used for communication about keys between the driver
+ * and mac80211, with the @flags parameter of &struct ieee80211_key_conf.
+ *
+ * @IEEE80211_KEY_FLAG_WMM_STA: Set by mac80211, this flag indicates
+ *	that the STA this key will be used with could be using QoS.
+ * @IEEE80211_KEY_FLAG_GENERATE_IV: This flag should be set by the
+ *	driver to indicate that it requires IV generation for this
+ *	particular key.
+ * @IEEE80211_KEY_FLAG_GENERATE_MMIC: This flag should be set by
+ *	the driver for a TKIP key if it requires Michael MIC
+ *	generation in software.
+ * @IEEE80211_KEY_FLAG_PAIRWISE: Set by mac80211, this flag indicates
+ *	that the key is pairwise rather then a shared key.
+ * @IEEE80211_KEY_FLAG_SW_MGMT: This flag should be set by the driver for a
+ *	CCMP key if it requires CCMP encryption of management frames (MFP) to
+ *	be done in software.
+ */
+enum ieee80211_key_flags {
+	IEEE80211_KEY_FLAG_WMM_STA	= 1<<0,
+	IEEE80211_KEY_FLAG_GENERATE_IV	= 1<<1,
+	IEEE80211_KEY_FLAG_GENERATE_MMIC = 1<<2,
+	IEEE80211_KEY_FLAG_PAIRWISE	= 1<<3,
+	IEEE80211_KEY_FLAG_SW_MGMT	= 1<<4,
+	IEEE80211_KEY_FLAG_ALLOC_IV	= 1<<5,
+	IEEE80211_KEY_FLAG_PUT_IV_SPACE = IEEE80211_KEY_FLAG_ALLOC_IV,
+};
+
+/**
+ * struct ieee80211_key_conf - key information
+ *
+ * This key information is given by mac80211 to the driver by
+ * the set_key() callback in &struct ieee80211_ops.
+ *
+ * @hw_key_idx: To be set by the driver, this is the key index the driver
+ *	wants to be given when a frame is transmitted and needs to be
+ *	encrypted in hardware.
+ * @cipher: The key's cipher suite selector.
+ * @tx_pn: PN used for TX on non-TKIP keys, may be used by the driver
+ *	as well if it needs to do software PN assignment by itself
+ *	(e.g. due to TSO)
+ * @flags: key flags, see &enum ieee80211_key_flags.
+ * @keyidx: the key index (0-3)
+ * @keylen: key material length
+ * @key: key material. For ALG_TKIP the key is encoded as a 256-bit (32 byte)
+ * 	data block:
+ * 	- Temporal Encryption Key (128 bits)
+ * 	- Temporal Authenticator Tx MIC Key (64 bits)
+ * 	- Temporal Authenticator Rx MIC Key (64 bits)
+ * @icv_len: The ICV length for this key type
+ * @iv_len: The IV length for this key type
+ */
+struct ieee80211_key_conf {
+	atomic64_t tx_pn;
+	u32 cipher;
+	u8 icv_len;
+	u8 iv_len;
+	u8 hw_key_idx;
+	u8 flags;
+	s8 keyidx;
+	u8 keylen;
+	u8 key[0];
+};
+
+/**
+ * struct ieee80211_cipher_scheme - cipher scheme
+ *
+ * This structure contains a cipher scheme information defining
+ * the secure packet crypto handling.
+ *
+ * @cipher: a cipher suite selector
+ * @iftype: a cipher iftype bit mask indicating an allowed cipher usage
+ * @hdr_len: a length of a security header used the cipher
+ * @pn_len: a length of a packet number in the security header
+ * @pn_off: an offset of pn from the beginning of the security header
+ * @key_idx_off: an offset of key index byte in the security header
+ * @key_idx_mask: a bit mask of key_idx bits
+ * @key_idx_shift: a bit shift needed to get key_idx
+ *     key_idx value calculation:
+ *      (sec_header_base[key_idx_off] & key_idx_mask) >> key_idx_shift
+ * @mic_len: a mic length in bytes
+ */
+struct ieee80211_cipher_scheme {
+	u32 cipher;
+	u16 iftype;
+	u8 hdr_len;
+	u8 pn_len;
+	u8 pn_off;
+	u8 key_idx_off;
+	u8 key_idx_mask;
+	u8 key_idx_shift;
+	u8 mic_len;
+};
+
+/**
+ * enum set_key_cmd - key command
+ *
+ * Used with the set_key() callback in &struct ieee80211_ops, this
+ * indicates whether a key is being removed or added.
+ *
+ * @SET_KEY: a key is set
+ * @DISABLE_KEY: a key must be disabled
+ */
+enum set_key_cmd {
+	SET_KEY, DISABLE_KEY,
+};
+
+/**
+ * struct ieee80211_sta - station table entry
+ *
+ * A station table entry represents a station we are possibly
+ * communicating with. Since stations are RCU-managed in
+ * mac80211, any ieee80211_sta pointer you get access to must
+ * either be protected by rcu_read_lock() explicitly or implicitly,
+ * or you must take good care to not use such a pointer after a
+ * call to your sta_remove callback that removed it.
+ *
+ * @addr: MAC address
+ * @aid: AID we assigned to the station if we're an AP
+ * @supp_rates: Bitmap of supported rates (per band)
+ * @ht_cap: HT capabilities of this STA; restricted to our own TX capabilities
+ * @wme: indicates whether the STA supports WME. Only valid during AP-mode.
+ * @drv_priv: data area for driver use, will always be aligned to
+ *	sizeof(void *), size is determined in hw information.
+ * @uapsd_queues: bitmap of queues configured for uapsd. Only valid
+ *	if wme is supported.
+ * @max_sp: max Service Period. Only valid if wme is supported.
+ */
+struct ieee80211_sta {
+	u32 supp_rates[NUM_NL80211_BANDS];
+	u8 addr[ETH_ALEN];
+	u16 aid;
+	struct ieee80211_sta_ht_cap ht_cap;
+	bool wme;
+	u8 uapsd_queues;
+	u8 max_sp;
+
+	/* must be last */
+	u8 drv_priv[0] __attribute__((__aligned__(sizeof(void *))));
+};
+
+/**
+ * enum sta_notify_cmd - sta notify command
+ *
+ * Used with the sta_notify() callback in &struct ieee80211_ops, this
+ * indicates if an associated station made a power state transition.
+ *
+ * @STA_NOTIFY_SLEEP: a station is now sleeping
+ * @STA_NOTIFY_AWAKE: a sleeping station woke up
+ */
+enum sta_notify_cmd {
+	STA_NOTIFY_SLEEP, STA_NOTIFY_AWAKE,
+};
+
+/**
+ * enum ieee80211_hw_flags - hardware flags
+ *
+ * These flags are used to indicate hardware capabilities to
+ * the stack. Generally, flags here should have their meaning
+ * done in a way that the simplest hardware doesn't need setting
+ * any particular flags. There are some exceptions to this rule,
+ * however, so you are advised to review these flags carefully.
+ *
+ * @IEEE80211_HW_HAS_RATE_CONTROL:
+ *	The hardware or firmware includes rate control, and cannot be
+ *	controlled by the stack. As such, no rate control algorithm
+ *	should be instantiated, and the TX rate reported to userspace
+ *	will be taken from the TX status instead of the rate control
+ *	algorithm.
+ *	Note that this requires that the driver implement a number of
+ *	callbacks so it has the correct information, it needs to have
+ *	the @set_rts_threshold callback and must look at the BSS config
+ *	@use_cts_prot for G/N protection, @use_short_slot for slot
+ *	timing in 2.4 GHz and @use_short_preamble for preambles for
+ *	CCK frames.
+ *
+ * @IEEE80211_HW_RX_INCLUDES_FCS:
+ *	Indicates that received frames passed to the stack include
+ *	the FCS at the end.
+ *
+ * @IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING:
+ *	Some wireless LAN chipsets buffer broadcast/multicast frames
+ *	for power saving stations in the hardware/firmware and others
+ *	rely on the host system for such buffering. This option is used
+ *	to configure the IEEE 802.11 upper layer to buffer broadcast and
+ *	multicast frames when there are power saving stations so that
+ *	the driver can fetch them with mac80211_get_buffered_bc().
+ *
+ * @IEEE80211_HW_2GHZ_SHORT_SLOT_INCAPABLE:
+ *	Hardware is not capable of short slot operation on the 2.4 GHz band.
+ *
+ * @IEEE80211_HW_2GHZ_SHORT_PREAMBLE_INCAPABLE:
+ *	Hardware is not capable of receiving frames with short preamble on
+ *	the 2.4 GHz band.
+ *
+ * @IEEE80211_HW_SIGNAL_UNSPEC:
+ *	Hardware can provide signal values but we don't know its units. We
+ *	expect values between 0 and @max_signal.
+ *	If possible please provide dB or dBm instead.
+ *
+ * @IEEE80211_HW_SIGNAL_DBM:
+ *	Hardware gives signal values in dBm, decibel difference from
+ *	one milliwatt. This is the preferred method since it is standardized
+ *	between different devices. @max_signal does not need to be set.
+ *
+ * @IEEE80211_HW_SPECTRUM_MGMT:
+ * 	Hardware supports spectrum management defined in 802.11h
+ * 	Measurement, Channel Switch, Quieting, TPC
+ *
+ * @IEEE80211_HW_AMPDU_AGGREGATION:
+ *	Hardware supports 11n A-MPDU aggregation.
+ *
+ * @IEEE80211_HW_SUPPORTS_PS:
+ *	Hardware has power save support (i.e. can go to sleep).
+ *
+ * @IEEE80211_HW_PS_NULLFUNC_STACK:
+ *	Hardware requires nullfunc frame handling in stack, implies
+ *	stack support for dynamic PS.
+ *
+ * @IEEE80211_HW_SUPPORTS_DYNAMIC_PS:
+ *	Hardware has support for dynamic PS.
+ *
+ * @IEEE80211_HW_MFP_CAPABLE:
+ *	Hardware supports management frame protection (MFP, IEEE 802.11w).
+ *
+ * @IEEE80211_HW_BEACON_FILTER:
+ *	Hardware supports dropping of irrelevant beacon frames to
+ *	avoid waking up cpu.
+ *
+ * @IEEE80211_HW_SUPPORTS_STATIC_SMPS:
+ *	Hardware supports static spatial multiplexing powersave,
+ *	ie. can turn off all but one chain even on HT connections
+ *	that should be using more chains.
+ *
+ * @IEEE80211_HW_SUPPORTS_DYNAMIC_SMPS:
+ *	Hardware supports dynamic spatial multiplexing powersave,
+ *	ie. can turn off all but one chain and then wake the rest
+ *	up as required after, for example, rts/cts handshake.
+ *
+ * @IEEE80211_HW_SUPPORTS_UAPSD:
+ *	Hardware supports Unscheduled Automatic Power Save Delivery
+ *	(U-APSD) in managed mode. The mode is configured with
+ *	conf_tx() operation.
+ *
+ * @IEEE80211_HW_REPORTS_TX_ACK_STATUS:
+ *	Hardware can provide ack status reports of Tx frames to
+ *	the stack.
+ *
+ * @IEEE80211_HW_CONNECTION_MONITOR:
+ *      The hardware performs its own connection monitoring, including
+ *      periodic keep-alives to the AP and probing the AP on beacon loss.
+ *      When this flag is set, signaling beacon-loss will cause an immediate
+ *      change to disassociated state.
+ *
+ * @IEEE80211_HW_SUPPORTS_CQM_RSSI:
+ *	Hardware can do connection quality monitoring - i.e. it can monitor
+ *	connection quality related parameters, such as the RSSI level and
+ *	provide notifications if configured trigger levels are reached.
+ *
+ * @IEEE80211_HW_NEED_DTIM_PERIOD:
+ *	This device needs to know the DTIM period for the BSS before
+ *	associating.
+ *
+ * @IEEE80211_HW_SUPPORTS_PER_STA_GTK: The device's crypto engine supports
+ *	per-station GTKs as used by IBSS RSN or during fast transition. If
+ *	the device doesn't support per-station GTKs, but can be asked not
+ *	to decrypt group addressed frames, then IBSS RSN support is still
+ *	possible but software crypto will be used. Advertise the wiphy flag
+ *	only in that case.
+ *
+ * @IEEE80211_HW_AP_LINK_PS: When operating in AP mode the device
+ *	autonomously manages the PS status of connected stations. When
+ *	this flag is set mac80211 will not trigger PS mode for connected
+ *	stations based on the PM bit of incoming frames.
+ *	Use ieee80211_start_ps()/ieee8021_end_ps() to manually configure
+ *	the PS mode of connected stations.
+ *
+ * @IEEE80211_HW_TX_AMPDU_SETUP_IN_HW: The device handles TX A-MPDU session
+ *      setup strictly in HW. mac80211 should not attempt to do this in
+ *      software.
+ *
+ * @IEEE80211_HW_SUPPORTS_CQM_BEACON_MISS
+ *      Connection quality monitoring - beacon miss.
+ *
+ * @IEEE80211_HW_SUPPORTS_CQM_TX_FAIL
+ *      Connection quality monitoring - tx failure.
+ *
+ * @IEEE80211_HW_SUPPORTS_MULTI_CHANNEL
+ *      Hardware supports simultaneous operation on different channels.
+ *
+ * @IEEE80211_HW_QUEUE_CONTROL: The driver wants to control per-interface
+ *	queue mapping in order to use different queues (not just one per AC)
+ *	for different virtual interfaces. See the doc section on HW queue
+ *	control for more details.
+ */
+enum ieee80211_hw_flags {
+	IEEE80211_HW_HAS_RATE_CONTROL			= 1<<0,
+	IEEE80211_HW_RX_INCLUDES_FCS			= 1<<1,
+	IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING	= 1<<2,
+	IEEE80211_HW_2GHZ_SHORT_SLOT_INCAPABLE		= 1<<3,
+	IEEE80211_HW_2GHZ_SHORT_PREAMBLE_INCAPABLE	= 1<<4,
+	IEEE80211_HW_SIGNAL_UNSPEC			= 1<<5,
+	IEEE80211_HW_SIGNAL_DBM				= 1<<6,
+	IEEE80211_HW_NEED_DTIM_PERIOD			= 1<<7,
+	IEEE80211_HW_SPECTRUM_MGMT			= 1<<8,
+	IEEE80211_HW_AMPDU_AGGREGATION			= 1<<9,
+	IEEE80211_HW_SUPPORTS_PS			= 1<<10,
+	IEEE80211_HW_PS_NULLFUNC_STACK			= 1<<11,
+	IEEE80211_HW_SUPPORTS_DYNAMIC_PS		= 1<<12,
+	IEEE80211_HW_MFP_CAPABLE			= 1<<13,
+	IEEE80211_HW_BEACON_FILTER			= 1<<14,
+	IEEE80211_HW_SUPPORTS_STATIC_SMPS		= 1<<15,
+	IEEE80211_HW_SUPPORTS_DYNAMIC_SMPS		= 1<<16,
+	IEEE80211_HW_SUPPORTS_UAPSD			= 1<<17,
+	IEEE80211_HW_REPORTS_TX_ACK_STATUS		= 1<<18,
+	IEEE80211_HW_CONNECTION_MONITOR			= 1<<19,
+	IEEE80211_HW_SUPPORTS_CQM_RSSI			= 1<<20,
+	IEEE80211_HW_SUPPORTS_PER_STA_GTK		= 1<<21,
+	IEEE80211_HW_AP_LINK_PS				= 1<<22,
+	IEEE80211_HW_TX_AMPDU_SETUP_IN_HW		= 1<<23,
+	IEEE80211_HW_SUPPORTS_CQM_BEACON_MISS		= 1<<24,
+	IEEE80211_HW_SUPPORTS_CQM_TX_FAIL		= 1<<25,
+	IEEE80211_HW_SUPPORTS_P2P_PS			= 1<<26,
+	IEEE80211_HW_SUPPORTS_MULTI_CHANNEL		= 1<<27,
+	IEEE80211_HW_QUEUE_CONTROL			= 1<<28,
+};
+
+/**
+ * struct ieee80211_hw - hardware information and state
+ *
+ * This structure contains the configuration and hardware
+ * information for an 802.11 PHY.
+ *
+ * @wiphy: This points to the &struct wiphy allocated for this
+ *	802.11 PHY. You must fill in the @perm_addr and @dev
+ *	members of this structure using SET_IEEE80211_DEV()
+ *	and SET_IEEE80211_PERM_ADDR(). Additionally, all supported
+ *	bands (with channels, bitrates) are registered here.
+ *
+ * @conf: &struct ieee80211_conf, device configuration, don't use.
+ *
+ * @priv: pointer to private area that was allocated for driver use
+ *	along with this structure.
+ *
+ * @flags: hardware flags, see &enum ieee80211_hw_flags.
+ *
+ * @extra_tx_headroom: headroom to reserve in each transmit skb
+ *	for use by the driver (e.g. for transmit headers.)
+ *
+ * @channel_change_time: time (in microseconds) it takes to change channels.
+ *
+ * @max_signal: Maximum value for signal (rssi) in RX information, used
+ *     only when @IEEE80211_HW_SIGNAL_UNSPEC or @IEEE80211_HW_SIGNAL_DB
+ *
+ * @max_listen_interval: max listen interval in units of beacon interval
+ *     that HW supports
+ *
+ * @queues: number of available hardware transmit queues for
+ *	data packets. WMM/QoS requires at least four, these
+ *	queues need to have configurable access parameters.
+ *
+ * @rate_control_algorithm: rate control algorithm for this hardware.
+ *	If unset (NULL), the default algorithm will be used. Must be
+ *	set before calling mac80211_register_hw().
+ *
+ * @vif_data_size: size (in bytes) of the drv_priv data area
+ *	within &struct ieee80211_vif.
+ * @sta_data_size: size (in bytes) of the drv_priv data area
+ *	within &struct ieee80211_sta.
+ *
+ * @max_rates: maximum number of alternate rate retry stages the hw
+ *	can handle.
+ * @max_report_rates: maximum number of alternate rate retry stages
+ *	the hw can report back.
+ * @max_rate_tries: maximum number of tries for each stage
+ *
+ * @napi_weight: weight used for NAPI polling.  You must specify an
+ *	appropriate value here if a napi_poll operation is provided
+ *	by your driver.
+ *
+ * @max_rx_aggregation_subframes: maximum buffer size (number of
+ *	sub-frames) to be used for A-MPDU block ack receiver
+ *	aggregation.
+ *	This is only relevant if the device has restrictions on the
+ *	number of subframes, if it relies on mac80211 to do reordering
+ *	it shouldn't be set.
+ *
+ * @max_tx_aggregation_subframes: maximum number of subframes in an
+ *	aggregate an HT driver will transmit, used by the peer as a
+ *	hint to size its reorder buffer.
+ *
+ * @offchannel_tx_hw_queue: HW queue ID to use for offchannel TX
+ *	(if %IEEE80211_HW_QUEUE_CONTROL is set)
+ */
+struct ieee80211_hw {
+	struct ieee80211_conf conf;
+	struct wiphy *wiphy;
+	const char *rate_control_algorithm;
+	void *priv;
+	u32 flags;
+	unsigned int extra_tx_headroom;
+	int channel_change_time;
+	int vif_data_size;
+	int sta_data_size;
+	int napi_weight;
+	u16 queues;
+	u16 max_listen_interval;
+	s8 max_signal;
+	u8 max_rates;
+	u8 max_report_rates;
+	u8 max_rate_tries;
+	u16 max_rx_aggregation_subframes;
+	u16 max_tx_aggregation_subframes;
+	u8 offchannel_tx_hw_queue;
+	u8 n_cipher_schemes;
+	const struct ieee80211_cipher_scheme *cipher_schemes;
+
+};
+
+/**
+ * wiphy_to_ieee80211_hw - return a mac80211 driver hw struct from a wiphy
+ *
+ * @wiphy: the &struct wiphy which we want to query
+ *
+ * mac80211 drivers can use this to get to their respective
+ * &struct ieee80211_hw. Drivers wishing to get to their own private
+ * structure can then access it via hw->priv. Note that mac802111 drivers should
+ * not use wiphy_priv() to try to get their private driver structure as this
+ * is already used internally by mac80211.
+ */
+struct ieee80211_hw *wiphy_to_ieee80211_hw(struct wiphy *wiphy);
+
+/**
+ * SET_IEEE80211_DEV - set device for 802.11 hardware
+ *
+ * @hw: the &struct ieee80211_hw to set the device for
+ * @dev: the &struct device of this 802.11 device
+ */
+static inline void SET_IEEE80211_DEV(struct ieee80211_hw *hw, struct device *dev)
+{
+	set_wiphy_dev(hw->wiphy, dev);
+}
+
+/**
+ * SET_IEEE80211_PERM_ADDR - set the permanent MAC address for 802.11 hardware
+ *
+ * @hw: the &struct ieee80211_hw to set the MAC address for
+ * @addr: the address to set
+ */
+static inline void SET_IEEE80211_PERM_ADDR(struct ieee80211_hw *hw, u8 *addr)
+{
+	memcpy(hw->wiphy->perm_addr, addr, ETH_ALEN);
+}
+
+static inline struct ieee80211_rate *
+ieee80211_get_tx_rate(const struct ieee80211_hw *hw,
+		      const struct ieee80211_tx_info *c)
+{
+	if (WARN_ON(c->control.rates[0].idx < 0))
+		return NULL;
+	return &hw->wiphy->bands[c->band]->bitrates[c->control.rates[0].idx];
+}
+
+static inline struct ieee80211_rate *
+ieee80211_get_rts_cts_rate(const struct ieee80211_hw *hw,
+			   const struct ieee80211_tx_info *c)
+{
+	if (c->control.rts_cts_rate_idx < 0)
+		return NULL;
+	return &hw->wiphy->bands[c->band]->bitrates[c->control.rts_cts_rate_idx];
+}
+
+static inline struct ieee80211_rate *
+ieee80211_get_alt_retry_rate(const struct ieee80211_hw *hw,
+			     const struct ieee80211_tx_info *c, int idx)
+{
+	if (c->control.rates[idx + 1].idx < 0)
+		return NULL;
+	return &hw->wiphy->bands[c->band]->bitrates[c->control.rates[idx + 1].idx];
+}
+
+/**
+ * DOC: Hardware crypto acceleration
+ *
+ * mac80211 is capable of taking advantage of many hardware
+ * acceleration designs for encryption and decryption operations.
+ *
+ * The set_key() callback in the &struct ieee80211_ops for a given
+ * device is called to enable hardware acceleration of encryption and
+ * decryption. The callback takes a @sta parameter that will be NULL
+ * for default keys or keys used for transmission only, or point to
+ * the station information for the peer for individual keys.
+ * Multiple transmission keys with the same key index may be used when
+ * VLANs are configured for an access point.
+ *
+ * When transmitting, the TX control data will use the @hw_key_idx
+ * selected by the driver by modifying the &struct ieee80211_key_conf
+ * pointed to by the @key parameter to the set_key() function.
+ *
+ * The set_key() call for the %SET_KEY command should return 0 if
+ * the key is now in use, -%EOPNOTSUPP or -%ENOSPC if it couldn't be
+ * added; if you return 0 then hw_key_idx must be assigned to the
+ * hardware key index, you are free to use the full u8 range.
+ *
+ * When the cmd is %DISABLE_KEY then it must succeed.
+ *
+ * Note that it is permissible to not decrypt a frame even if a key
+ * for it has been uploaded to hardware, the stack will not make any
+ * decision based on whether a key has been uploaded or not but rather
+ * based on the receive flags.
+ *
+ * The &struct ieee80211_key_conf structure pointed to by the @key
+ * parameter is guaranteed to be valid until another call to set_key()
+ * removes it, but it can only be used as a cookie to differentiate
+ * keys.
+ *
+ * In TKIP some HW need to be provided a phase 1 key, for RX decryption
+ * acceleration (i.e. iwlwifi). Those drivers should provide update_tkip_key
+ * handler.
+ * The update_tkip_key() call updates the driver with the new phase 1 key.
+ * This happens every time the iv16 wraps around (every 65536 packets). The
+ * set_key() call will happen only once for each key (unless the AP did
+ * rekeying), it will not include a valid phase 1 key. The valid phase 1 key is
+ * provided by update_tkip_key only. The trigger that makes mac80211 call this
+ * handler is software decryption with wrap around of iv16.
+ */
+
+/**
+ * DOC: Powersave support
+ *
+ * mac80211 has support for various powersave implementations.
+ *
+ * First, it can support hardware that handles all powersaving by itself,
+ * such hardware should simply set the %IEEE80211_HW_SUPPORTS_PS hardware
+ * flag. In that case, it will be told about the desired powersave mode
+ * with the %IEEE80211_CONF_PS flag depending on the association status.
+ * The hardware must take care of sending nullfunc frames when necessary,
+ * i.e. when entering and leaving powersave mode. The hardware is required
+ * to look at the AID in beacons and signal to the AP that it woke up when
+ * it finds traffic directed to it.
+ *
+ * %IEEE80211_CONF_PS flag enabled means that the powersave mode defined in
+ * IEEE 802.11-2007 section 11.2 is enabled. This is not to be confused
+ * with hardware wakeup and sleep states. Driver is responsible for waking
+ * up the hardware before issuing commands to the hardware and putting it
+ * back to sleep at appropriate times.
+ *
+ * When PS is enabled, hardware needs to wakeup for beacons and receive the
+ * buffered multicast/broadcast frames after the beacon. Also it must be
+ * possible to send frames and receive the acknowledment frame.
+ *
+ * Other hardware designs cannot send nullfunc frames by themselves and also
+ * need software support for parsing the TIM bitmap. This is also supported
+ * by mac80211 by combining the %IEEE80211_HW_SUPPORTS_PS and
+ * %IEEE80211_HW_PS_NULLFUNC_STACK flags. The hardware is of course still
+ * required to pass up beacons. The hardware is still required to handle
+ * waking up for multicast traffic; if it cannot the driver must handle that
+ * as best as it can, mac80211 is too slow to do that.
+ *
+ * Dynamic powersave is an extension to normal powersave in which the
+ * hardware stays awake for a user-specified period of time after sending a
+ * frame so that reply frames need not be buffered and therefore delayed to
+ * the next wakeup. It's compromise of getting good enough latency when
+ * there's data traffic and still saving significantly power in idle
+ * periods.
+ *
+ * Dynamic powersave is simply supported by mac80211 enabling and disabling
+ * PS based on traffic. Driver needs to only set %IEEE80211_HW_SUPPORTS_PS
+ * flag and mac80211 will handle everything automatically. Additionally,
+ * hardware having support for the dynamic PS feature may set the
+ * %IEEE80211_HW_SUPPORTS_DYNAMIC_PS flag to indicate that it can support
+ * dynamic PS mode itself. The driver needs to look at the
+ * @dynamic_ps_timeout hardware configuration value and use it that value
+ * whenever %IEEE80211_CONF_PS is set. In this case mac80211 will disable
+ * dynamic PS feature in stack and will just keep %IEEE80211_CONF_PS
+ * enabled whenever user has enabled powersave.
+ *
+ * Some hardware need to toggle a single shared antenna between WLAN and
+ * Bluetooth to facilitate co-existence. These types of hardware set
+ * limitations on the use of host controlled dynamic powersave whenever there
+ * is simultaneous WLAN and Bluetooth traffic. For these types of hardware, the
+ * driver may request temporarily going into full power save, in order to
+ * enable toggling the antenna between BT and WLAN. If the driver requests
+ * disabling dynamic powersave, the @dynamic_ps_timeout value will be
+ * temporarily set to zero until the driver re-enables dynamic powersave.
+ *
+ * Driver informs U-APSD client support by enabling
+ * %IEEE80211_HW_SUPPORTS_UAPSD flag. The mode is configured through the
+ * uapsd paramater in conf_tx() operation. Hardware needs to send the QoS
+ * Nullfunc frames and stay awake until the service period has ended. To
+ * utilize U-APSD, dynamic powersave is disabled for voip AC and all frames
+ * from that AC are transmitted with powersave enabled.
+ *
+ * Note: U-APSD client mode is not yet supported with
+ * %IEEE80211_HW_PS_NULLFUNC_STACK.
+ */
+
+/**
+ * DOC: Beacon filter support
+ *
+ * Some hardware have beacon filter support to reduce host cpu wakeups
+ * which will reduce system power consumption. It usuallly works so that
+ * the firmware creates a checksum of the beacon but omits all constantly
+ * changing elements (TSF, TIM etc). Whenever the checksum changes the
+ * beacon is forwarded to the host, otherwise it will be just dropped. That
+ * way the host will only receive beacons where some relevant information
+ * (for example ERP protection or WMM settings) have changed.
+ *
+ * Beacon filter support is advertised with the %IEEE80211_HW_BEACON_FILTER
+ * hardware capability. The driver needs to enable beacon filter support
+ * whenever power save is enabled, that is %IEEE80211_CONF_PS is set. When
+ * power save is enabled, the stack will not check for beacon loss and the
+ * driver needs to notify about loss of beacons with mac80211_beacon_loss().
+ *
+ * The time (or number of beacons missed) until the firmware notifies the
+ * driver of a beacon loss event (which in turn causes the driver to call
+ * mac80211_beacon_loss()) should be configurable and will be controlled
+ * by mac80211 and the roaming algorithm in the future.
+ *
+ * Since there may be constantly changing information elements that nothing
+ * in the software stack cares about, we will, in the future, have mac80211
+ * tell the driver which information elements are interesting in the sense
+ * that we want to see changes in them. This will include
+ *  - a list of information element IDs
+ *  - a list of OUIs for the vendor information element
+ *
+ * Ideally, the hardware would filter out any beacons without changes in the
+ * requested elements, but if it cannot support that it may, at the expense
+ * of some efficiency, filter out only a subset. For example, if the device
+ * doesn't support checking for OUIs it should pass up all changes in all
+ * vendor information elements.
+ *
+ * Note that change, for the sake of simplification, also includes information
+ * elements appearing or disappearing from the beacon.
+ *
+ * Some hardware supports an "ignore list" instead, just make sure nothing
+ * that was requested is on the ignore list, and include commonly changing
+ * information element IDs in the ignore list, for example 11 (BSS load) and
+ * the various vendor-assigned IEs with unknown contents (128, 129, 133-136,
+ * 149, 150, 155, 156, 173, 176, 178, 179, 219); for forward compatibility
+ * it could also include some currently unused IDs.
+ *
+ *
+ * In addition to these capabilities, hardware should support notifying the
+ * host of changes in the beacon RSSI. This is relevant to implement roaming
+ * when no traffic is flowing (when traffic is flowing we see the RSSI of
+ * the received data packets). This can consist in notifying the host when
+ * the RSSI changes significantly or when it drops below or rises above
+ * configurable thresholds. In the future these thresholds will also be
+ * configured by mac80211 (which gets them from userspace) to implement
+ * them as the roaming algorithm requires.
+ *
+ * If the hardware cannot implement this, the driver should ask it to
+ * periodically pass beacon frames to the host so that software can do the
+ * signal strength threshold checking.
+ */
+
+/**
+ * DOC: Spatial multiplexing power save
+ *
+ * SMPS (Spatial multiplexing power save) is a mechanism to conserve
+ * power in an 802.11n implementation. For details on the mechanism
+ * and rationale, please refer to 802.11 (as amended by 802.11n-2009)
+ * "11.2.3 SM power save".
+ *
+ * The mac80211 implementation is capable of sending action frames
+ * to update the AP about the station's SMPS mode, and will instruct
+ * the driver to enter the specific mode. It will also announce the
+ * requested SMPS mode during the association handshake. Hardware
+ * support for this feature is required, and can be indicated by
+ * hardware flags.
+ *
+ * The default mode will be "automatic", which nl80211/cfg80211
+ * defines to be dynamic SMPS in (regular) powersave, and SMPS
+ * turned off otherwise.
+ *
+ * To support this feature, the driver must set the appropriate
+ * hardware support flags, and handle the SMPS flag to the config()
+ * operation. It will then with this mechanism be instructed to
+ * enter the requested SMPS mode while associated to an HT AP.
+ */
+
+/**
+ * DOC: Frame filtering
+ *
+ * mac80211 requires to see many management frames for proper
+ * operation, and users may want to see many more frames when
+ * in monitor mode. However, for best CPU usage and power consumption,
+ * having as few frames as possible percolate through the stack is
+ * desirable. Hence, the hardware should filter as much as possible.
+ *
+ * To achieve this, mac80211 uses filter flags (see below) to tell
+ * the driver's configure_filter() function which frames should be
+ * passed to mac80211 and which should be filtered out.
+ *
+ * Before configure_filter() is invoked, the prepare_multicast()
+ * callback is invoked with the parameters @mc_count and @mc_list
+ * for the combined multicast address list of all virtual interfaces.
+ * It's use is optional, and it returns a u64 that is passed to
+ * configure_filter(). Additionally, configure_filter() has the
+ * arguments @changed_flags telling which flags were changed and
+ * @total_flags with the new flag states.
+ *
+ * If your device has no multicast address filters your driver will
+ * need to check both the %FIF_ALLMULTI flag and the @mc_count
+ * parameter to see whether multicast frames should be accepted
+ * or dropped.
+ *
+ * All unsupported flags in @total_flags must be cleared.
+ * Hardware does not support a flag if it is incapable of _passing_
+ * the frame to the stack. Otherwise the driver must ignore
+ * the flag, but not clear it.
+ * You must _only_ clear the flag (announce no support for the
+ * flag to mac80211) if you are not able to pass the packet type
+ * to the stack (so the hardware always filters it).
+ * So for example, you should clear @FIF_CONTROL, if your hardware
+ * always filters control frames. If your hardware always passes
+ * control frames to the kernel and is incapable of filtering them,
+ * you do _not_ clear the @FIF_CONTROL flag.
+ * This rule applies to all other FIF flags as well.
+ */
+
+/**
+ * DOC: AP support for powersaving clients
+ *
+ * In order to implement AP and P2P GO modes, mac80211 has support for
+ * client powersaving, both "legacy" PS (PS-Poll/null data) and uAPSD.
+ * There currently is no support for sAPSD.
+ *
+ * There is one assumption that mac80211 makes, namely that a client
+ * will not poll with PS-Poll and trigger with uAPSD at the same time.
+ * Both are supported, and both can be used by the same client, but
+ * they can't be used concurrently by the same client. This simplifies
+ * the driver code.
+ *
+ * The first thing to keep in mind is that there is a flag for complete
+ * driver implementation: %IEEE80211_HW_AP_LINK_PS. If this flag is set,
+ * mac80211 expects the driver to handle most of the state machine for
+ * powersaving clients and will ignore the PM bit in incoming frames.
+ * Drivers then use mac80211_sta_ps_transition() to inform mac80211 of
+ * stations' powersave transitions. In this mode, mac80211 also doesn't
+ * handle PS-Poll/uAPSD.
+ *
+ * In the mode without %IEEE80211_HW_AP_LINK_PS, mac80211 will check the
+ * PM bit in incoming frames for client powersave transitions. When a
+ * station goes to sleep, we will stop transmitting to it. There is,
+ * however, a race condition: a station might go to sleep while there is
+ * data buffered on hardware queues. If the device has support for this
+ * it will reject frames, and the driver should give the frames back to
+ * mac80211 with the %IEEE80211_TX_STAT_TX_FILTERED flag set which will
+ * cause mac80211 to retry the frame when the station wakes up. The
+ * driver is also notified of powersave transitions by calling its
+ * @sta_notify callback.
+ *
+ * When the station is asleep, it has three choices: it can wake up,
+ * it can PS-Poll, or it can possibly start a uAPSD service period.
+ * Waking up is implemented by simply transmitting all buffered (and
+ * filtered) frames to the station. This is the easiest case. When
+ * the station sends a PS-Poll or a uAPSD trigger frame, mac80211
+ * will inform the driver of this with the @allow_buffered_frames
+ * callback; this callback is optional. mac80211 will then transmit
+ * the frames as usual and set the %IEEE80211_TX_CTL_POLL_RESPONSE
+ * on each frame. The last frame in the service period (or the only
+ * response to a PS-Poll) also has %IEEE80211_TX_STATUS_EOSP set to
+ * indicate that it ends the service period; as this frame must have
+ * TX status report it also sets %IEEE80211_TX_CTL_REQ_TX_STATUS.
+ * When TX status is reported for this frame, the service period is
+ * marked has having ended and a new one can be started by the peer.
+ *
+ * Another race condition can happen on some devices like iwlwifi
+ * when there are frames queued for the station and it wakes up
+ * or polls; the frames that are already queued could end up being
+ * transmitted first instead, causing reordering and/or wrong
+ * processing of the EOSP. The cause is that allowing frames to be
+ * transmitted to a certain station is out-of-band communication to
+ * the device. To allow this problem to be solved, the driver can
+ * call mac80211_sta_block_awake() if frames are buffered when it
+ * is notified that the station went to sleep. When all these frames
+ * have been filtered (see above), it must call the function again
+ * to indicate that the station is no longer blocked.
+ *
+ * If the driver buffers frames in the driver for aggregation in any
+ * way, it must use the mac80211_sta_set_buffered() call when it is
+ * notified of the station going to sleep to inform mac80211 of any
+ * TIDs that have frames buffered. Note that when a station wakes up
+ * this information is reset (hence the requirement to call it when
+ * informed of the station going to sleep). Then, when a service
+ * period starts for any reason, @release_buffered_frames is called
+ * with the number of frames to be released and which TIDs they are
+ * to come from. In this case, the driver is responsible for setting
+ * the EOSP (for uAPSD) and MORE_DATA bits in the released frames,
+ * to help the @more_data paramter is passed to tell the driver if
+ * there is more data on other TIDs -- the TIDs to release frames
+ * from are ignored since mac80211 doesn't know how many frames the
+ * buffers for those TIDs contain.
+ *
+ * If the driver also implement GO mode, where absence periods may
+ * shorten service periods (or abort PS-Poll responses), it must
+ * filter those response frames except in the case of frames that
+ * are buffered in the driver -- those must remain buffered to avoid
+ * reordering. Because it is possible that no frames are released
+ * in this case, the driver must call mac80211_sta_eosp_irqsafe()
+ * to indicate to mac80211 that the service period ended anyway.
+ *
+ * Finally, if frames from multiple TIDs are released from mac80211
+ * but the driver might reorder them, it must clear & set the flags
+ * appropriately (only the last frame may have %IEEE80211_TX_STATUS_EOSP)
+ * and also take care of the EOSP and MORE_DATA bits in the frame.
+ * The driver may also use mac80211_sta_eosp_irqsafe() in this case.
+ */
+
+/**
+ * DOC: HW queue control
+ *
+ * Before HW queue control was introduced, mac80211 only had a single static
+ * assignment of per-interface AC software queues to hardware queues. This
+ * was problematic for a few reasons:
+ * 1) off-channel transmissions might get stuck behind other frames
+ * 2) multiple virtual interfaces couldn't be handled correctly
+ * 3) after-DTIM frames could get stuck behind other frames
+ *
+ * To solve this, hardware typically uses multiple different queues for all
+ * the different usages, and this needs to be propagated into mac80211 so it
+ * won't have the same problem with the software queues.
+ *
+ * Therefore, mac80211 now offers the %IEEE80211_HW_QUEUE_CONTROL capability
+ * flag that tells it that the driver implements its own queue control. To do
+ * so, the driver will set up the various queues in each &struct ieee80211_vif
+ * and the offchannel queue in &struct ieee80211_hw. In response, mac80211 will
+ * use those queue IDs in the hw_queue field of &struct ieee80211_tx_info and
+ * if necessary will queue the frame on the right software queue that mirrors
+ * the hardware queue.
+ * Additionally, the driver has to then use these HW queue IDs for the queue
+ * management functions (mac80211_stop_queue() et al.)
+ *
+ * The driver is free to set up the queue mappings as needed, multiple virtual
+ * interfaces may map to the same hardware queues if needed. The setup has to
+ * happen during add_interface or change_interface callbacks. For example, a
+ * driver supporting station+station and station+AP modes might decide to have
+ * 10 hardware queues to handle different scenarios:
+ *
+ * 4 AC HW queues for 1st vif: 0, 1, 2, 3
+ * 4 AC HW queues for 2nd vif: 4, 5, 6, 7
+ * after-DTIM queue for AP:   8
+ * off-channel queue:         9
+ *
+ * It would then set up the hardware like this:
+ *   hw.offchannel_tx_hw_queue = 9
+ *
+ * and the first virtual interface that is added as follows:
+ *   vif.hw_queue[IEEE80211_AC_VO] = 0
+ *   vif.hw_queue[IEEE80211_AC_VI] = 1
+ *   vif.hw_queue[IEEE80211_AC_BE] = 2
+ *   vif.hw_queue[IEEE80211_AC_BK] = 3
+ *   vif.cab_queue = 8 // if AP mode, otherwise %IEEE80211_INVAL_HW_QUEUE
+ * and the second virtual interface with 4-7.
+ *
+ * If queue 6 gets full, for example, mac80211 would only stop the second
+ * virtual interface's BE queue since virtual interface queues are per AC.
+ *
+ * Note that the vif.cab_queue value should be set to %IEEE80211_INVAL_HW_QUEUE
+ * whenever the queue is not used (i.e. the interface is not in AP mode) if the
+ * queue could potentially be shared since mac80211 will look at cab_queue when
+ * a queue is stopped/woken even if the interface is not in AP mode.
+ */
+
+/**
+ * enum ieee80211_filter_flags - hardware filter flags
+ *
+ * These flags determine what the filter in hardware should be
+ * programmed to let through and what should not be passed to the
+ * stack. It is always safe to pass more frames than requested,
+ * but this has negative impact on power consumption.
+ *
+ * @FIF_PROMISC_IN_BSS: promiscuous mode within your BSS,
+ *	think of the BSS as your network segment and then this corresponds
+ *	to the regular ethernet device promiscuous mode.
+ *
+ * @FIF_ALLMULTI: pass all multicast frames, this is used if requested
+ *	by the user or if the hardware is not capable of filtering by
+ *	multicast address.
+ *
+ * @FIF_FCSFAIL: pass frames with failed FCS (but you need to set the
+ *	%RX_FLAG_FAILED_FCS_CRC for them)
+ *
+ * @FIF_PLCPFAIL: pass frames with failed PLCP CRC (but you need to set
+ *	the %RX_FLAG_FAILED_PLCP_CRC for them
+ *
+ * @FIF_BCN_PRBRESP_PROMISC: This flag is set during scanning to indicate
+ *	to the hardware that it should not filter beacons or probe responses
+ *	by BSSID. Filtering them can greatly reduce the amount of processing
+ *	mac80211 needs to do and the amount of CPU wakeups, so you should
+ *	honour this flag if possible.
+ *
+ * @FIF_CONTROL: pass control frames (except for PS Poll), if PROMISC_IN_BSS
+ * 	is not set then only those addressed to this station.
+ *
+ * @FIF_OTHER_BSS: pass frames destined to other BSSes
+ *
+ * @FIF_PSPOLL: pass PS Poll frames, if PROMISC_IN_BSS is not set then only
+ * 	those addressed to this station.
+ *
+ * @FIF_PROBE_REQ: pass probe request frames
+ */
+enum ieee80211_filter_flags {
+	FIF_PROMISC_IN_BSS	= 1<<0,
+	FIF_ALLMULTI		= 1<<1,
+	FIF_FCSFAIL		= 1<<2,
+	FIF_PLCPFAIL		= 1<<3,
+	FIF_BCN_PRBRESP_PROMISC	= 1<<4,
+	FIF_CONTROL		= 1<<5,
+	FIF_OTHER_BSS		= 1<<6,
+	FIF_PSPOLL		= 1<<7,
+	FIF_PROBE_REQ		= 1<<8,
+};
+
+/**
+ * enum ieee80211_ampdu_mlme_action - A-MPDU actions
+ *
+ * These flags are used with the ampdu_action() callback in
+ * &struct ieee80211_ops to indicate which action is needed.
+ *
+ * Note that drivers MUST be able to deal with a TX aggregation
+ * session being stopped even before they OK'ed starting it by
+ * calling mac80211_start_tx_ba_cb_irqsafe, because the peer
+ * might receive the addBA frame and send a delBA right away!
+ *
+ * @IEEE80211_AMPDU_RX_START: start Rx aggregation
+ * @IEEE80211_AMPDU_RX_STOP: stop Rx aggregation
+ * @IEEE80211_AMPDU_TX_START: start Tx aggregation
+ * @IEEE80211_AMPDU_TX_STOP: stop Tx aggregation
+ * @IEEE80211_AMPDU_TX_OPERATIONAL: TX aggregation has become operational
+ */
+enum ieee80211_ampdu_mlme_action {
+	IEEE80211_AMPDU_RX_START,
+	IEEE80211_AMPDU_RX_STOP,
+	IEEE80211_AMPDU_TX_START,
+	IEEE80211_AMPDU_TX_STOP,
+	IEEE80211_AMPDU_TX_OPERATIONAL,
+};
+
+/**
+ * enum ieee80211_tx_sync_type - TX sync type
+ * @IEEE80211_TX_SYNC_AUTH: sync TX for authentication
+ *	(and possibly also before direct probe)
+ * @IEEE80211_TX_SYNC_ASSOC: sync TX for association
+ * @IEEE80211_TX_SYNC_ACTION: sync TX for action frame
+ *	(not implemented yet)
+ */
+enum ieee80211_tx_sync_type {
+	IEEE80211_TX_SYNC_AUTH,
+	IEEE80211_TX_SYNC_ASSOC,
+	IEEE80211_TX_SYNC_ACTION,
+};
+
+/**
+ * enum ieee80211_frame_release_type - frame release reason
+ * @IEEE80211_FRAME_RELEASE_PSPOLL: frame released for PS-Poll
+ * @IEEE80211_FRAME_RELEASE_UAPSD: frame(s) released due to
+ *	frame received on trigger-enabled AC
+ */
+enum ieee80211_frame_release_type {
+	IEEE80211_FRAME_RELEASE_PSPOLL,
+	IEEE80211_FRAME_RELEASE_UAPSD,
+};
+
+/**
+ * struct ieee80211_ops - callbacks from mac80211 to the driver
+ *
+ * This structure contains various callbacks that the driver may
+ * handle or, in some cases, must handle, for example to configure
+ * the hardware to a new channel or to transmit a frame.
+ *
+ * @tx: Handler that 802.11 module calls for each transmitted frame.
+ *	skb contains the buffer starting from the IEEE 802.11 header.
+ *	The low-level driver should send the frame out based on
+ *	configuration in the TX control data. This handler should,
+ *	preferably, never fail and stop queues appropriately, more
+ *	importantly, however, it must never fail for A-MPDU-queues.
+ *	This function should return NETDEV_TX_OK except in very
+ *	limited cases.
+ *	Must be implemented and atomic.
+ *
+ * @start: Called before the first netdevice attached to the hardware
+ *	is enabled. This should turn on the hardware and must turn on
+ *	frame reception (for possibly enabled monitor interfaces.)
+ *	Returns negative error codes, these may be seen in userspace,
+ *	or zero.
+ *	When the device is started it should not have a MAC address
+ *	to avoid acknowledging frames before a non-monitor device
+ *	is added.
+ *	Must be implemented and can sleep.
+ *
+ * @stop: Called after last netdevice attached to the hardware
+ *	is disabled. This should turn off the hardware (at least
+ *	it must turn off frame reception.)
+ *	May be called right after add_interface if that rejects
+ *	an interface. If you added any work onto the mac80211 workqueue
+ *	you should ensure to cancel it on this callback.
+ *	Must be implemented and can sleep.
+ *
+ * @suspend: Suspend the device; mac80211 itself will quiesce before and
+ *	stop transmitting and doing any other configuration, and then
+ *	ask the device to suspend. This is only invoked when WoWLAN is
+ *	configured, otherwise the device is deconfigured completely and
+ *	reconfigured at resume time.
+ *	The driver may also impose special conditions under which it
+ *	wants to use the "normal" suspend (deconfigure), say if it only
+ *	supports WoWLAN when the device is associated. In this case, it
+ *	must return 1 from this function.
+ *
+ * @resume: If WoWLAN was configured, this indicates that mac80211 is
+ *	now resuming its operation, after this the device must be fully
+ *	functional again. If this returns an error, the only way out is
+ *	to also unregister the device. If it returns 1, then mac80211
+ *	will also go through the regular complete restart on resume.
+ *
+ * @add_interface: Called when a netdevice attached to the hardware is
+ *	enabled. Because it is not called for monitor mode devices, @start
+ *	and @stop must be implemented.
+ *	The driver should perform any initialization it needs before
+ *	the device can be enabled. The initial configuration for the
+ *	interface is given in the conf parameter.
+ *	The callback may refuse to add an interface by returning a
+ *	negative error code (which will be seen in userspace.)
+ *	Must be implemented and can sleep.
+ *
+ * @change_interface: Called when a netdevice changes type. This callback
+ *	is optional, but only if it is supported can interface types be
+ *	switched while the interface is UP. The callback may sleep.
+ *	Note that while an interface is being switched, it will not be
+ *	found by the interface iteration callbacks.
+ *
+ * @remove_interface: Notifies a driver that an interface is going down.
+ *	The @stop callback is called after this if it is the last interface
+ *	and no monitor interfaces are present.
+ *	When all interfaces are removed, the MAC address in the hardware
+ *	must be cleared so the device no longer acknowledges packets,
+ *	the mac_addr member of the conf structure is, however, set to the
+ *	MAC address of the device going away.
+ *	Hence, this callback must be implemented. It can sleep.
+ *
+ * @config: Handler for configuration requests. IEEE 802.11 code calls this
+ *	function to change hardware configuration, e.g., channel.
+ *	This function should never fail but returns a negative error code
+ *	if it does. The callback can sleep.
+ *
+ * @bss_info_changed: Handler for configuration requests related to BSS
+ *	parameters that may vary during BSS's lifespan, and may affect low
+ *	level driver (e.g. assoc/disassoc status, erp parameters).
+ *	This function should not be used if no BSS has been set, unless
+ *	for association indication. The @changed parameter indicates which
+ *	of the bss parameters has changed when a call is made. The callback
+ *	can sleep.
+ *
+ * @tx_sync: Called before a frame is sent to an AP/GO. In the GO case, the
+ *	driver should sync with the GO's powersaving so the device doesn't
+ *	transmit the frame while the GO is asleep. In the regular AP case
+ *	it may be used by drivers for devices implementing other restrictions
+ *	on talking to APs, e.g. due to regulatory enforcement or just HW
+ *	restrictions.
+ *	This function is called for every authentication, association and
+ *	action frame separately since applications might attempt to auth
+ *	with multiple APs before chosing one to associate to. If it returns
+ *	an error, the corresponding authentication, association or frame
+ *	transmission is aborted and reported as having failed. It is always
+ *	called after tuning to the correct channel.
+ *	The callback might be called multiple times before @finish_tx_sync
+ *	(but @finish_tx_sync will be called once for each) but in practice
+ *	this is unlikely to happen. It can also refuse in that case if the
+ *	driver cannot handle that situation.
+ *	This callback can sleep.
+ * @finish_tx_sync: Called as a counterpart to @tx_sync, unless that returned
+ *	an error. This callback can sleep.
+ *
+ * @prepare_multicast: Prepare for multicast filter configuration.
+ *	This callback is optional, and its return value is passed
+ *	to configure_filter(). This callback must be atomic.
+ *
+ * @configure_filter: Configure the device's RX filter.
+ *	See the section "Frame filtering" for more information.
+ *	This callback must be implemented and can sleep.
+ *
+ * @set_tim: Set TIM bit. mac80211 calls this function when a TIM bit
+ * 	must be set or cleared for a given STA. Must be atomic.
+ *
+ * @set_key: See the section "Hardware crypto acceleration"
+ *	This callback is only called between add_interface and
+ *	remove_interface calls, i.e. while the given virtual interface
+ *	is enabled.
+ *	Returns a negative error code if the key can't be added.
+ *	The callback can sleep.
+ *
+ * @update_tkip_key: See the section "Hardware crypto acceleration"
+ * 	This callback will be called in the context of Rx. Called for drivers
+ * 	which set IEEE80211_KEY_FLAG_TKIP_REQ_RX_P1_KEY.
+ *	The callback must be atomic.
+ *
+ * @set_rekey_data: If the device supports GTK rekeying, for example while the
+ *	host is suspended, it can assign this callback to retrieve the data
+ *	necessary to do GTK rekeying, this is the KEK, KCK and replay counter.
+ *	After rekeying was done it should (for example during resume) notify
+ *	userspace of the new replay counter using mac80211_gtk_rekey_notify().
+ *
+ * @hw_scan: Ask the hardware to service the scan request, no need to start
+ *	the scan state machine in stack. The scan must honour the channel
+ *	configuration done by the regulatory agent in the wiphy's
+ *	registered bands. The hardware (or the driver) needs to make sure
+ *	that power save is disabled.
+ *	The @req ie/ie_len members are rewritten by mac80211 to contain the
+ *	entire IEs after the SSID, so that drivers need not look at these
+ *	at all but just send them after the SSID -- mac80211 includes the
+ *	(extended) supported rates and HT information (where applicable).
+ *	When the scan finishes, mac80211_scan_completed() must be called;
+ *	note that it also must be called when the scan cannot finish due to
+ *	any error unless this callback returned a negative error code.
+ *	The callback can sleep.
+ *
+ * @cancel_hw_scan: Ask the low-level tp cancel the active hw scan.
+ *	The driver should ask the hardware to cancel the scan (if possible),
+ *	but the scan will be completed only after the driver will call
+ *	mac80211_scan_completed().
+ *	This callback is needed for wowlan, to prevent enqueueing a new
+ *	scan_work after the low-level driver was already suspended.
+ *	The callback can sleep.
+ *
+ * @sched_scan_start: Ask the hardware to start scanning repeatedly at
+ *	specific intervals.  The driver must call the
+ *	mac80211_sched_scan_results() function whenever it finds results.
+ *	This process will continue until sched_scan_stop is called.
+ *
+ * @sched_scan_stop: Tell the hardware to stop an ongoing scheduled scan.
+ *
+ * @sw_scan_start: Notifier function that is called just before a software scan
+ *	is started. Can be NULL, if the driver doesn't need this notification.
+ *	The callback can sleep.
+ *
+ * @sw_scan_complete: Notifier function that is called just after a
+ *	software scan finished. Can be NULL, if the driver doesn't need
+ *	this notification.
+ *	The callback can sleep.
+ *
+ * @get_stats: Return low-level statistics.
+ * 	Returns zero if statistics are available.
+ *	The callback can sleep.
+ *
+ * @get_tkip_seq: If your device implements TKIP encryption in hardware this
+ *	callback should be provided to read the TKIP transmit IVs (both IV32
+ *	and IV16) for the given key from hardware.
+ *	The callback must be atomic.
+ *
+ * @set_frag_threshold: Configuration of fragmentation threshold. Assign this
+ *	if the device does fragmentation by itself; if this callback is
+ *	implemented then the stack will not do fragmentation.
+ *	The callback can sleep.
+ *
+ * @set_rts_threshold: Configuration of RTS threshold (if device needs it)
+ *	The callback can sleep.
+ *
+ * @sta_add: Notifies low level driver about addition of an associated station,
+ *	AP, IBSS/WDS/mesh peer etc. This callback can sleep.
+ *
+ * @sta_remove: Notifies low level driver about removal of an associated
+ *	station, AP, IBSS/WDS/mesh peer etc. This callback can sleep.
+ *
+ * @sta_notify: Notifies low level driver about power state transition of an
+ *	associated station, AP,  IBSS/WDS/mesh peer etc. For a VIF operating
+ *	in AP mode, this callback will not be called when the flag
+ *	%IEEE80211_HW_AP_LINK_PS is set. Must be atomic.
+ *
+ * @conf_tx: Configure TX queue parameters (EDCF (aifs, cw_min, cw_max),
+ *	bursting) for a hardware TX queue.
+ *	Returns a negative error code on failure.
+ *	The callback can sleep.
+ *
+ * @get_tsf: Get the current TSF timer value from firmware/hardware. Currently,
+ *	this is only used for IBSS mode BSSID merging and debugging. Is not a
+ *	required function.
+ *	The callback can sleep.
+ *
+ * @set_tsf: Set the TSF timer to the specified value in the firmware/hardware.
+ *      Currently, this is only used for IBSS mode debugging. Is not a
+ *	required function.
+ *	The callback can sleep.
+ *
+ * @reset_tsf: Reset the TSF timer and allow firmware/hardware to synchronize
+ *	with other STAs in the IBSS. This is only used in IBSS mode. This
+ *	function is optional if the firmware/hardware takes full care of
+ *	TSF synchronization.
+ *	The callback can sleep.
+ *
+ * @tx_last_beacon: Determine whether the last IBSS beacon was sent by us.
+ *	This is needed only for IBSS mode and the result of this function is
+ *	used to determine whether to reply to Probe Requests.
+ *	Returns non-zero if this device sent the last beacon.
+ *	The callback can sleep.
+ *
+ * @ampdu_action: Perform a certain A-MPDU action
+ * 	The RA/TID combination determines the destination and TID we want
+ * 	the ampdu action to be performed for. The action is defined through
+ * 	ieee80211_ampdu_mlme_action. Starting sequence number (@ssn)
+ * 	is the first frame we expect to perform the action on. Notice
+ * 	that TX/RX_STOP can pass NULL for this parameter.
+ *	The @buf_size parameter is only valid when the action is set to
+ *	%IEEE80211_AMPDU_TX_OPERATIONAL and indicates the peer's reorder
+ *	buffer size (number of subframes) for this session -- the driver
+ *	may neither send aggregates containing more subframes than this
+ *	nor send aggregates in a way that lost frames would exceed the
+ *	buffer size. If just limiting the aggregate size, this would be
+ *	possible with a buf_size of 8:
+ *	 - TX: 1.....7
+ *	 - RX:  2....7 (lost frame #1)
+ *	 - TX:        8..1...
+ *	which is invalid since #1 was now re-transmitted well past the
+ *	buffer size of 8. Correct ways to retransmit #1 would be:
+ *	 - TX:       1 or 18 or 81
+ *	Even "189" would be wrong since 1 could be lost again.
+ *
+ *	Returns a negative error code on failure.
+ *	The callback can sleep.
+ *
+ * @get_survey: Return per-channel survey information
+ *
+ * @rfkill_poll: Poll rfkill hardware state. If you need this, you also
+ *	need to set wiphy->rfkill_poll to %true before registration,
+ *	and need to call wiphy_rfkill_set_hw_state() in the callback.
+ *	The callback can sleep.
+ *
+ * @set_coverage_class: Set slot time for given coverage class as specified
+ *	in IEEE 802.11-2007 section 17.3.8.6 and modify ACK timeout
+ *	accordingly. This callback is not required and may sleep.
+ *
+ * @testmode_cmd: Implement a cfg80211 test mode command.
+ *	The callback can sleep.
+ * @testmode_dump: Implement a cfg80211 test mode dump. The callback can sleep.
+ *
+ * @flush: Flush all pending frames from the hardware queue, making sure
+ *	that the hardware queues are empty. If the parameter @drop is set
+ *	to %true, pending frames may be dropped. The callback can sleep.
+ *
+ * @channel_switch: Drivers that need (or want) to offload the channel
+ *	switch operation for CSAs received from the AP may implement this
+ *	callback. They must then call mac80211_chswitch_done() to indicate
+ *	completion of the channel switch.
+ *
+ * @napi_poll: Poll Rx queue for incoming data frames.
+ *
+ * @set_antenna: Set antenna configuration (tx_ant, rx_ant) on the device.
+ *	Parameters are bitmaps of allowed antennas to use for TX/RX. Drivers may
+ *	reject TX/RX mask combinations they cannot support by returning -EINVAL
+ *	(also see nl80211.h @NL80211_ATTR_WIPHY_ANTENNA_TX).
+ *
+ * @get_antenna: Get current antenna configuration from device (tx_ant, rx_ant).
+ *
+ * @remain_on_channel: Starts an off-channel period on the given channel, must
+ *	call back to mac80211_ready_on_channel() when on that channel. Note
+ *	that normal channel traffic is not stopped as this is intended for hw
+ *	offload. Frames to transmit on the off-channel channel are transmitted
+ *	normally except for the %IEEE80211_TX_CTL_TX_OFFCHAN flag. When the
+ *	duration (which will always be non-zero) expires, the driver must call
+ *	mac80211_remain_on_channel_expired(). This callback may sleep.
+ * @cancel_remain_on_channel: Requests that an ongoing off-channel period is
+ *	aborted before it expires. This callback may sleep.
+ *
+ * @set_ringparam: Set tx and rx ring sizes.
+ *
+ * @get_ringparam: Get tx and rx ring current and maximum sizes.
+ *
+ * @tx_frames_pending: Check if there is any pending frame in the hardware
+ *	queues before entering power save.
+ *
+ * @set_bitrate_mask: Set a mask of rates to be used for rate control selection
+ *	when transmitting a frame. Currently only legacy rates are handled.
+ *	The callback can sleep.
+ * @rssi_callback: Notify driver when the average RSSI goes above/below
+ *	thresholds that were registered previously. The callback can sleep.
+ *
+ * @release_buffered_frames: Release buffered frames according to the given
+ *	parameters. In the case where the driver buffers some frames for
+ *	sleeping stations mac80211 will use this callback to tell the driver
+ *	to release some frames, either for PS-poll or uAPSD.
+ *	Note that if the @more_data paramter is %false the driver must check
+ *	if there are more frames on the given TIDs, and if there are more than
+ *	the frames being released then it must still set the more-data bit in
+ *	the frame. If the @more_data parameter is %true, then of course the
+ *	more-data bit must always be set.
+ *	The @tids parameter tells the driver which TIDs to release frames
+ *	from, for PS-poll it will always have only a single bit set.
+ *	In the case this is used for a PS-poll initiated release, the
+ *	@num_frames parameter will always be 1 so code can be shared. In
+ *	this case the driver must also set %IEEE80211_TX_STATUS_EOSP flag
+ *	on the TX status (and must report TX status) so that the PS-poll
+ *	period is properly ended. This is used to avoid sending multiple
+ *	responses for a retried PS-poll frame.
+ *	In the case this is used for uAPSD, the @num_frames parameter may be
+ *	bigger than one, but the driver may send fewer frames (it must send
+ *	at least one, however). In this case it is also responsible for
+ *	setting the EOSP flag in the QoS header of the frames. Also, when the
+ *	service period ends, the driver must set %IEEE80211_TX_STATUS_EOSP
+ *	on the last frame in the SP. Alternatively, it may call the function
+ *	mac80211_sta_eosp_irqsafe() to inform mac80211 of the end of the SP.
+ *	This callback must be atomic.
+ * @allow_buffered_frames: Prepare device to allow the given number of frames
+ *	to go out to the given station. The frames will be sent by mac80211
+ *	via the usual TX path after this call. The TX information for frames
+ *	released will also have the %IEEE80211_TX_CTL_POLL_RESPONSE flag set
+ *	and the last one will also have %IEEE80211_TX_STATUS_EOSP set. In case
+ *	frames from multiple TIDs are released and the driver might reorder
+ *	them between the TIDs, it must set the %IEEE80211_TX_STATUS_EOSP flag
+ *	on the last frame and clear it on all others and also handle the EOSP
+ *	bit in the QoS header correctly. Alternatively, it can also call the
+ *	mac80211_sta_eosp_irqsafe() function.
+ *	The @tids parameter is a bitmap and tells the driver which TIDs the
+ *	frames will be on; it will at most have two bits set.
+ *	This callback must be atomic.
+ * @set_data_filter: Prepare device to configure data packet filter and filter
+ *	data packetsi accoding to its type. The filter can be configured
+ *	as multicast, ipv4, ipv6i, mac address, dhcp & ssdp
+ */
+struct ieee80211_ops {
+	void (*tx)(struct ieee80211_hw *hw, struct sk_buff *skb);
+	int (*start)(struct ieee80211_hw *hw);
+	void (*stop)(struct ieee80211_hw *hw);
+#ifdef CONFIG_PM
+	int (*suspend)(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan);
+	int (*resume)(struct ieee80211_hw *hw);
+#endif
+	int (*add_interface)(struct ieee80211_hw *hw,
+			     struct ieee80211_vif *vif);
+	int (*change_interface)(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif,
+				enum nl80211_iftype new_type, bool p2p);
+	void (*remove_interface)(struct ieee80211_hw *hw,
+				 struct ieee80211_vif *vif);
+	int (*config)(struct ieee80211_hw *hw, u32 changed);
+	void (*bss_info_changed)(struct ieee80211_hw *hw,
+				 struct ieee80211_vif *vif,
+				 struct ieee80211_bss_conf *info,
+				 u32 changed);
+
+	int (*tx_sync)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		       const u8 *bssid, enum ieee80211_tx_sync_type type);
+	void (*finish_tx_sync)(struct ieee80211_hw *hw,
+			       struct ieee80211_vif *vif,
+			       const u8 *bssid,
+			       enum ieee80211_tx_sync_type type);
+
+	u64 (*prepare_multicast)(struct ieee80211_hw *hw,
+				 struct ieee80211_vif *vif,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
+				 struct netdev_hw_addr_list *mc_list);
+#else
+				 int mc_count, struct dev_addr_list *mc_list);
+#endif
+	void (*configure_filter)(struct ieee80211_hw *hw,
+				 struct ieee80211_vif *vif,
+				 unsigned int changed_flags,
+				 unsigned int *total_flags,
+				 u64 multicast);
+	int (*set_tim)(struct ieee80211_hw *hw, struct ieee80211_sta *sta,
+		       bool set);
+	int (*set_key)(struct ieee80211_hw *hw, enum set_key_cmd cmd,
+		       struct ieee80211_vif *vif, struct ieee80211_sta *sta,
+		       struct ieee80211_key_conf *key);
+	void (*update_tkip_key)(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif,
+				struct ieee80211_key_conf *conf,
+				struct ieee80211_sta *sta,
+				u32 iv32, u16 *phase1key);
+	void (*set_rekey_data)(struct ieee80211_hw *hw,
+			       struct ieee80211_vif *vif,
+			       struct cfg80211_gtk_rekey_data *data);
+	int (*hw_scan)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		       struct cfg80211_scan_request *req);
+	void (*cancel_hw_scan)(struct ieee80211_hw *hw,
+			       struct ieee80211_vif *vif);
+	int (*sched_scan_start)(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif,
+				struct cfg80211_sched_scan_request *req,
+				struct ieee80211_sched_scan_ies *ies);
+	void (*sched_scan_stop)(struct ieee80211_hw *hw,
+			       struct ieee80211_vif *vif);
+	void (*sw_scan_start)(struct ieee80211_hw *hw);
+	void (*sw_scan_complete)(struct ieee80211_hw *hw);
+	int (*get_stats)(struct ieee80211_hw *hw,
+			 struct ieee80211_low_level_stats *stats);
+	void (*get_tkip_seq)(struct ieee80211_hw *hw, u8 hw_key_idx,
+			     u32 *iv32, u16 *iv16);
+	int (*set_frag_threshold)(struct ieee80211_hw *hw, u32 value);
+	int (*set_rts_threshold)(struct ieee80211_hw *hw,
+			struct ieee80211_vif *vif, u32 value);
+	int (*sta_add)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		       struct ieee80211_sta *sta);
+	int (*sta_remove)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			  struct ieee80211_sta *sta);
+	void (*sta_notify)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			enum sta_notify_cmd, struct ieee80211_sta *sta);
+	int (*conf_tx)(struct ieee80211_hw *hw,
+		       struct ieee80211_vif *vif, u16 ac,
+		       const struct ieee80211_tx_queue_params *params);
+	u64 (*get_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
+	void (*set_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			u64 tsf);
+	void (*reset_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
+	int (*tx_last_beacon)(struct ieee80211_hw *hw);
+	int (*ampdu_action)(struct ieee80211_hw *hw,
+			    struct ieee80211_vif *vif,
+			    enum ieee80211_ampdu_mlme_action action,
+			    struct ieee80211_sta *sta, u16 tid, u16 *ssn,
+			    u8 buf_size);
+	int (*get_survey)(struct ieee80211_hw *hw, int idx,
+		struct survey_info *survey);
+	void (*rfkill_poll)(struct ieee80211_hw *hw);
+	void (*set_coverage_class)(struct ieee80211_hw *hw, u8 coverage_class);
+#ifdef CONFIG_NL80211_TESTMODE
+	int (*testmode_cmd)(struct ieee80211_hw *hw, void *data, int len);
+	int (*testmode_dump)(struct ieee80211_hw *hw, struct sk_buff *skb,
+			     struct netlink_callback *cb,
+			     void *data, int len);
+#endif
+	void (*flush)(struct ieee80211_hw *hw,
+		      struct ieee80211_vif *vif,
+		      bool drop);
+	void (*channel_switch)(struct ieee80211_hw *hw,
+			       struct ieee80211_channel_switch *ch_switch);
+	int (*napi_poll)(struct ieee80211_hw *hw, int budget);
+	int (*set_antenna)(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant);
+	int (*get_antenna)(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant);
+
+	int (*remain_on_channel)(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif,
+				 struct ieee80211_channel *chan,
+				 enum nl80211_channel_type channel_type,
+				 int duration, u64 cookie);
+	int (*cancel_remain_on_channel)(struct ieee80211_hw *hw);
+	int (*set_ringparam)(struct ieee80211_hw *hw, u32 tx, u32 rx);
+	void (*get_ringparam)(struct ieee80211_hw *hw,
+			      u32 *tx, u32 *tx_max, u32 *rx, u32 *rx_max);
+	bool (*tx_frames_pending)(struct ieee80211_hw *hw);
+	int (*set_bitrate_mask)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+				const struct cfg80211_bitrate_mask *mask);
+	void (*rssi_callback)(struct ieee80211_hw *hw,
+			      enum ieee80211_rssi_event rssi_event);
+
+	void (*allow_buffered_frames)(struct ieee80211_hw *hw,
+				      struct ieee80211_sta *sta,
+				      u16 tids, int num_frames,
+				      enum ieee80211_frame_release_type reason,
+				      bool more_data);
+	void (*release_buffered_frames)(struct ieee80211_hw *hw,
+					struct ieee80211_sta *sta,
+					u16 tids, int num_frames,
+					enum ieee80211_frame_release_type reason,
+					bool more_data);
+	void (*set_data_filter)(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif,
+				void *data,
+				int len);
+	int (*change_mac)(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif,
+				struct sockaddr *sa);
+};
+
+/**
+ * mac80211_alloc_hw -  Allocate a new hardware device
+ *
+ * This must be called once for each hardware device. The returned pointer
+ * must be used to refer to this device when calling other functions.
+ * mac80211 allocates a private data area for the driver pointed to by
+ * @priv in &struct ieee80211_hw, the size of this area is given as
+ * @priv_data_len.
+ *
+ * @priv_data_len: length of private data
+ * @ops: callbacks for this device
+ */
+struct ieee80211_hw *mac80211_alloc_hw(size_t priv_data_len,
+					const struct ieee80211_ops *ops);
+
+/**
+ * mac80211_register_hw - Register hardware device
+ *
+ * You must call this function before any other functions in
+ * mac80211. Note that before a hardware can be registered, you
+ * need to fill the contained wiphy's information.
+ *
+ * @hw: the device to register as returned by mac80211_alloc_hw()
+ */
+int mac80211_register_hw(struct ieee80211_hw *hw);
+
+/**
+ * struct ieee80211_tpt_blink - throughput blink description
+ * @throughput: throughput in Kbit/sec
+ * @blink_time: blink time in milliseconds
+ *	(full cycle, ie. one off + one on period)
+ */
+struct ieee80211_tpt_blink {
+	int throughput;
+	int blink_time;
+};
+
+/**
+ * enum ieee80211_tpt_led_trigger_flags - throughput trigger flags
+ * @IEEE80211_TPT_LEDTRIG_FL_RADIO: enable blinking with radio
+ * @IEEE80211_TPT_LEDTRIG_FL_WORK: enable blinking when working
+ * @IEEE80211_TPT_LEDTRIG_FL_CONNECTED: enable blinking when at least one
+ *	interface is connected in some way, including being an AP
+ */
+enum ieee80211_tpt_led_trigger_flags {
+	IEEE80211_TPT_LEDTRIG_FL_RADIO		= BIT(0),
+	IEEE80211_TPT_LEDTRIG_FL_WORK		= BIT(1),
+	IEEE80211_TPT_LEDTRIG_FL_CONNECTED	= BIT(2),
+};
+
+#ifdef CONFIG_XRMAC_LEDS
+extern char *__ieee80211_get_tx_led_name(struct ieee80211_hw *hw);
+extern char *__ieee80211_get_rx_led_name(struct ieee80211_hw *hw);
+extern char *__ieee80211_get_assoc_led_name(struct ieee80211_hw *hw);
+extern char *__ieee80211_get_radio_led_name(struct ieee80211_hw *hw);
+extern char *__ieee80211_create_tpt_led_trigger(
+				struct ieee80211_hw *hw, unsigned int flags,
+				const struct ieee80211_tpt_blink *blink_table,
+				unsigned int blink_table_len);
+#endif
+/**
+ * ieee80211_get_tx_led_name - get name of TX LED
+ *
+ * mac80211 creates a transmit LED trigger for each wireless hardware
+ * that can be used to drive LEDs if your driver registers a LED device.
+ * This function returns the name (or %NULL if not configured for LEDs)
+ * of the trigger so you can automatically link the LED device.
+ *
+ * @hw: the hardware to get the LED trigger name for
+ */
+static inline char *ieee80211_get_tx_led_name(struct ieee80211_hw *hw)
+{
+#ifdef CONFIG_XRMAC_LEDS
+	return __ieee80211_get_tx_led_name(hw);
+#else
+	return NULL;
+#endif
+}
+
+/**
+ * ieee80211_get_rx_led_name - get name of RX LED
+ *
+ * mac80211 creates a receive LED trigger for each wireless hardware
+ * that can be used to drive LEDs if your driver registers a LED device.
+ * This function returns the name (or %NULL if not configured for LEDs)
+ * of the trigger so you can automatically link the LED device.
+ *
+ * @hw: the hardware to get the LED trigger name for
+ */
+static inline char *ieee80211_get_rx_led_name(struct ieee80211_hw *hw)
+{
+#ifdef CONFIG_XRMAC_LEDS
+	return __ieee80211_get_rx_led_name(hw);
+#else
+	return NULL;
+#endif
+}
+
+/**
+ * ieee80211_get_assoc_led_name - get name of association LED
+ *
+ * mac80211 creates a association LED trigger for each wireless hardware
+ * that can be used to drive LEDs if your driver registers a LED device.
+ * This function returns the name (or %NULL if not configured for LEDs)
+ * of the trigger so you can automatically link the LED device.
+ *
+ * @hw: the hardware to get the LED trigger name for
+ */
+static inline char *ieee80211_get_assoc_led_name(struct ieee80211_hw *hw)
+{
+#ifdef CONFIG_XRMAC_LEDS
+	return __ieee80211_get_assoc_led_name(hw);
+#else
+	return NULL;
+#endif
+}
+
+/**
+ * ieee80211_get_radio_led_name - get name of radio LED
+ *
+ * mac80211 creates a radio change LED trigger for each wireless hardware
+ * that can be used to drive LEDs if your driver registers a LED device.
+ * This function returns the name (or %NULL if not configured for LEDs)
+ * of the trigger so you can automatically link the LED device.
+ *
+ * @hw: the hardware to get the LED trigger name for
+ */
+static inline char *ieee80211_get_radio_led_name(struct ieee80211_hw *hw)
+{
+#ifdef CONFIG_XRMAC_LEDS
+	return __ieee80211_get_radio_led_name(hw);
+#else
+	return NULL;
+#endif
+}
+
+/**
+ * ieee80211_create_tpt_led_trigger - create throughput LED trigger
+ * @hw: the hardware to create the trigger for
+ * @flags: trigger flags, see &enum ieee80211_tpt_led_trigger_flags
+ * @blink_table: the blink table -- needs to be ordered by throughput
+ * @blink_table_len: size of the blink table
+ *
+ * This function returns %NULL (in case of error, or if no LED
+ * triggers are configured) or the name of the new trigger.
+ * This function must be called before mac80211_register_hw().
+ */
+static inline char *
+ieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw, unsigned int flags,
+				 const struct ieee80211_tpt_blink *blink_table,
+				 unsigned int blink_table_len)
+{
+#ifdef CONFIG_XRMAC_LEDS
+	return __ieee80211_create_tpt_led_trigger(hw, flags, blink_table,
+						  blink_table_len);
+#else
+	return NULL;
+#endif
+}
+
+/**
+ * mac80211_unregister_hw - Unregister a hardware device
+ *
+ * This function instructs mac80211 to free allocated resources
+ * and unregister netdevices from the networking subsystem.
+ *
+ * @hw: the hardware to unregister
+ */
+void mac80211_unregister_hw(struct ieee80211_hw *hw);
+
+/**
+ * mac80211_free_hw - free hardware descriptor
+ *
+ * This function frees everything that was allocated, including the
+ * private data for the driver. You must call mac80211_unregister_hw()
+ * before calling this function.
+ *
+ * @hw: the hardware to free
+ */
+void mac80211_free_hw(struct ieee80211_hw *hw);
+
+/**
+ * mac80211_restart_hw - restart hardware completely
+ *
+ * Call this function when the hardware was restarted for some reason
+ * (hardware error, ...) and the driver is unable to restore its state
+ * by itself. mac80211 assumes that at this point the driver/hardware
+ * is completely uninitialised and stopped, it starts the process by
+ * calling the ->start() operation. The driver will need to reset all
+ * internal state that it has prior to calling this function.
+ *
+ * @hw: the hardware to restart
+ */
+void mac80211_restart_hw(struct ieee80211_hw *hw);
+
+int mac80211_ifdev_move(struct ieee80211_hw *hw,
+		struct device *new_parent, int dpm_order);
+
+/**
+ * ieee80211_rx - receive frame
+ *
+ * Use this function to hand received frames to mac80211. The receive
+ * buffer in @skb must start with an IEEE 802.11 header. In case of a
+ * paged @skb is used, the driver is recommended to put the ieee80211
+ * header of the frame on the linear part of the @skb to avoid memory
+ * allocation and/or memcpy by the stack.
+ *
+ * This function may not be called in IRQ context. Calls to this function
+ * for a single hardware must be synchronized against each other. Calls to
+ * this function, ieee80211_rx_ni() and mac80211_rx_irqsafe() may not be
+ * mixed for a single hardware.
+ *
+ * In process context use instead ieee80211_rx_ni().
+ *
+ * @hw: the hardware this frame came in on
+ * @skb: the buffer to receive, owned by mac80211 after this call
+ */
+void mac80211_rx(struct ieee80211_hw *hw, struct sk_buff *skb);
+
+/**
+ * mac80211_rx_irqsafe - receive frame
+ *
+ * Like ieee80211_rx() but can be called in IRQ context
+ * (internally defers to a tasklet.)
+ *
+ * Calls to this function, ieee80211_rx() or ieee80211_rx_ni() may not
+ * be mixed for a single hardware.
+ *
+ * @hw: the hardware this frame came in on
+ * @skb: the buffer to receive, owned by mac80211 after this call
+ */
+void mac80211_rx_irqsafe(struct ieee80211_hw *hw, struct sk_buff *skb);
+
+/**
+ * ieee80211_rx_ni - receive frame (in process context)
+ *
+ * Like ieee80211_rx() but can be called in process context
+ * (internally disables bottom halves).
+ *
+ * Calls to this function, ieee80211_rx() and mac80211_rx_irqsafe() may
+ * not be mixed for a single hardware.
+ *
+ * @hw: the hardware this frame came in on
+ * @skb: the buffer to receive, owned by mac80211 after this call
+ */
+static inline void ieee80211_rx_ni(struct ieee80211_hw *hw,
+				   struct sk_buff *skb)
+{
+	local_bh_disable();
+	mac80211_rx(hw, skb);
+	local_bh_enable();
+}
+
+/**
+ * mac80211_sta_ps_transition - PS transition for connected sta
+ *
+ * When operating in AP mode with the %IEEE80211_HW_AP_LINK_PS
+ * flag set, use this function to inform mac80211 about a connected station
+ * entering/leaving PS mode.
+ *
+ * This function may not be called in IRQ context or with softirqs enabled.
+ *
+ * Calls to this function for a single hardware must be synchronized against
+ * each other.
+ *
+ * The function returns -EINVAL when the requested PS mode is already set.
+ *
+ * @sta: currently connected sta
+ * @start: start or stop PS
+ */
+int mac80211_sta_ps_transition(struct ieee80211_sta *sta, bool start);
+
+/**
+ * mac80211_sta_ps_transition_ni - PS transition for connected sta
+ *                                  (in process context)
+ *
+ * Like mac80211_sta_ps_transition() but can be called in process context
+ * (internally disables bottom halves). Concurrent call restriction still
+ * applies.
+ *
+ * @sta: currently connected sta
+ * @start: start or stop PS
+ */
+static inline int mac80211_sta_ps_transition_ni(struct ieee80211_sta *sta,
+						  bool start)
+{
+	int ret;
+
+	local_bh_disable();
+	ret = mac80211_sta_ps_transition(sta, start);
+	local_bh_enable();
+
+	return ret;
+}
+
+/*
+ * The TX headroom reserved by mac80211 for its own tx_status functions.
+ * This is enough for the radiotap header.
+ */
+#define IEEE80211_TX_STATUS_HEADROOM	14
+
+/**
+ * mac80211_sta_set_buffered - inform mac80211 about driver-buffered frames
+ * @sta: &struct ieee80211_sta pointer for the sleeping station
+ * @tid: the TID that has buffered frames
+ * @buffered: indicates whether or not frames are buffered for this TID
+ *
+ * If a driver buffers frames for a powersave station instead of passing
+ * them back to mac80211 for retransmission, the station may still need
+ * to be told that there are buffered frames via the TIM bit.
+ *
+ * This function informs mac80211 whether or not there are frames that are
+ * buffered in the driver for a given TID; mac80211 can then use this data
+ * to set the TIM bit (NOTE: This may call back into the driver's set_tim
+ * call! Beware of the locking!)
+ *
+ * If all frames are released to the station (due to PS-poll or uAPSD)
+ * then the driver needs to inform mac80211 that there no longer are
+ * frames buffered. However, when the station wakes up mac80211 assumes
+ * that all buffered frames will be transmitted and clears this data,
+ * drivers need to make sure they inform mac80211 about all buffered
+ * frames on the sleep transition (sta_notify() with %STA_NOTIFY_SLEEP).
+ *
+ * Note that technically mac80211 only needs to know this per AC, not per
+ * TID, but since driver buffering will inevitably happen per TID (since
+ * it is related to aggregation) it is easier to make mac80211 map the
+ * TID to the AC as required instead of keeping track in all drivers that
+ * use this API.
+ */
+void mac80211_sta_set_buffered(struct ieee80211_sta *sta,
+				u8 tid, bool buffered);
+
+/**
+ * mac80211_tx_status - transmit status callback
+ *
+ * Call this function for all transmitted frames after they have been
+ * transmitted. It is permissible to not call this function for
+ * multicast frames but this can affect statistics.
+ *
+ * This function may not be called in IRQ context. Calls to this function
+ * for a single hardware must be synchronized against each other. Calls
+ * to this function, mac80211_tx_status_ni() and mac80211_tx_status_irqsafe()
+ * may not be mixed for a single hardware.
+ *
+ * @hw: the hardware the frame was transmitted by
+ * @skb: the frame that was transmitted, owned by mac80211 after this call
+ */
+void mac80211_tx_status(struct ieee80211_hw *hw,
+			 struct sk_buff *skb);
+
+/**
+ * mac80211_tx_status_ni - transmit status callback (in process context)
+ *
+ * Like mac80211_tx_status() but can be called in process context.
+ *
+ * Calls to this function, mac80211_tx_status() and
+ * mac80211_tx_status_irqsafe() may not be mixed
+ * for a single hardware.
+ *
+ * @hw: the hardware the frame was transmitted by
+ * @skb: the frame that was transmitted, owned by mac80211 after this call
+ */
+static inline void mac80211_tx_status_ni(struct ieee80211_hw *hw,
+					  struct sk_buff *skb)
+{
+	local_bh_disable();
+	mac80211_tx_status(hw, skb);
+	local_bh_enable();
+}
+
+/**
+ * mac80211_tx_status_irqsafe - IRQ-safe transmit status callback
+ *
+ * Like mac80211_tx_status() but can be called in IRQ context
+ * (internally defers to a tasklet.)
+ *
+ * Calls to this function, mac80211_tx_status() and
+ * mac80211_tx_status_ni() may not be mixed for a single hardware.
+ *
+ * @hw: the hardware the frame was transmitted by
+ * @skb: the frame that was transmitted, owned by mac80211 after this call
+ */
+void mac80211_tx_status_irqsafe(struct ieee80211_hw *hw,
+				 struct sk_buff *skb);
+
+/**
+ * mac80211_report_low_ack - report non-responding station
+ *
+ * When operating in AP-mode, call this function to report a non-responding
+ * connected STA.
+ *
+ * @sta: the non-responding connected sta
+ * @num_packets: number of packets sent to @sta without a response
+ */
+void mac80211_report_low_ack(struct ieee80211_sta *sta, u32 num_packets);
+
+/**
+ * mac80211_beacon_get_tim - beacon generation function
+ * @hw: pointer obtained from mac80211_alloc_hw().
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ * @tim_offset: pointer to variable that will receive the TIM IE offset.
+ *	Set to 0 if invalid (in non-AP modes).
+ * @tim_length: pointer to variable that will receive the TIM IE length,
+ *	(including the ID and length bytes!).
+ *	Set to 0 if invalid (in non-AP modes).
+ *
+ * If the driver implements beaconing modes, it must use this function to
+ * obtain the beacon frame/template.
+ *
+ * If the beacon frames are generated by the host system (i.e., not in
+ * hardware/firmware), the driver uses this function to get each beacon
+ * frame from mac80211 -- it is responsible for calling this function
+ * before the beacon is needed (e.g. based on hardware interrupt).
+ *
+ * If the beacon frames are generated by the device, then the driver
+ * must use the returned beacon as the template and change the TIM IE
+ * according to the current DTIM parameters/TIM bitmap.
+ *
+ * The driver is responsible for freeing the returned skb.
+ */
+struct sk_buff *mac80211_beacon_get_tim(struct ieee80211_hw *hw,
+					 struct ieee80211_vif *vif,
+					 u16 *tim_offset, u16 *tim_length);
+
+/**
+ * ieee80211_beacon_get - beacon generation function
+ * @hw: pointer obtained from mac80211_alloc_hw().
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ *
+ * See mac80211_beacon_get_tim().
+ */
+static inline struct sk_buff *ieee80211_beacon_get(struct ieee80211_hw *hw,
+						   struct ieee80211_vif *vif)
+{
+	return mac80211_beacon_get_tim(hw, vif, NULL, NULL);
+}
+
+#ifdef PROBE_RESP_EXTRA_IE
+/**
+ * mac80211_proberesp_get - probe response generation function
+ * @hw: pointer obtained from mac80211_alloc_hw().
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ */
+struct sk_buff *mac80211_proberesp_get(struct ieee80211_hw *hw,
+						   struct ieee80211_vif *vif);
+#endif
+
+/**
+ * mac80211_pspoll_get - retrieve a PS Poll template
+ * @hw: pointer obtained from mac80211_alloc_hw().
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ *
+ * Creates a PS Poll a template which can, for example, uploaded to
+ * hardware. The template must be updated after association so that correct
+ * AID, BSSID and MAC address is used.
+ *
+ * Note: Caller (or hardware) is responsible for setting the
+ * &IEEE80211_FCTL_PM bit.
+ */
+struct sk_buff *mac80211_pspoll_get(struct ieee80211_hw *hw,
+				     struct ieee80211_vif *vif);
+
+/**
+ * mac80211_nullfunc_get - retrieve a nullfunc template
+ * @hw: pointer obtained from mac80211_alloc_hw().
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ *
+ * Creates a Nullfunc template which can, for example, uploaded to
+ * hardware. The template must be updated after association so that correct
+ * BSSID and address is used.
+ *
+ * Note: Caller (or hardware) is responsible for setting the
+ * &IEEE80211_FCTL_PM bit as well as Duration and Sequence Control fields.
+ */
+struct sk_buff *mac80211_nullfunc_get(struct ieee80211_hw *hw,
+				       struct ieee80211_vif *vif);
+
+/**
+ * ieee80211_qosnullfunc_get - retrieve a qos nullfunc template
+ * @hw: pointer obtained from mac80211_alloc_hw().
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ *
+ * Creates a QOS Nullfunc template which can, for example, be uploaded to
+ * hardware. The template must be updated after association so that correct
+ * BSSID and address is used.
+ *
+ * Note: Caller (or hardware) is responsible for setting the
+ * &IEEE80211_FCTL_PM bit as well as Duration and Sequence Control fields.
+ * The qos ctl field is set to zero by the function. Caller must
+ * fill up proper value.
+ */
+struct sk_buff *ieee80211_qosnullfunc_get(struct ieee80211_hw *hw,
+					  struct ieee80211_vif *vif);
+/**
+ * mac80211_probereq_get - retrieve a Probe Request template
+ * @hw: pointer obtained from mac80211_alloc_hw().
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ * @ssid: SSID buffer
+ * @ssid_len: length of SSID
+ * @ie: buffer containing all IEs except SSID for the template
+ * @ie_len: length of the IE buffer
+ *
+ * Creates a Probe Request template which can, for example, be uploaded to
+ * hardware.
+ */
+struct sk_buff *mac80211_probereq_get(struct ieee80211_hw *hw,
+				       struct ieee80211_vif *vif,
+				       const u8 *ssid, size_t ssid_len,
+				       const u8 *ie, size_t ie_len);
+
+/**
+ * mac80211_rts_get - RTS frame generation function
+ * @hw: pointer obtained from mac80211_alloc_hw().
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ * @frame: pointer to the frame that is going to be protected by the RTS.
+ * @frame_len: the frame length (in octets).
+ * @frame_txctl: &struct ieee80211_tx_info of the frame.
+ * @rts: The buffer where to store the RTS frame.
+ *
+ * If the RTS frames are generated by the host system (i.e., not in
+ * hardware/firmware), the low-level driver uses this function to receive
+ * the next RTS frame from the 802.11 code. The low-level is responsible
+ * for calling this function before and RTS frame is needed.
+ */
+void mac80211_rts_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		       const void *frame, size_t frame_len,
+		       const struct ieee80211_tx_info *frame_txctl,
+		       struct ieee80211_rts *rts);
+
+/**
+ * mac80211_rts_duration - Get the duration field for an RTS frame
+ * @hw: pointer obtained from mac80211_alloc_hw().
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ * @frame_len: the length of the frame that is going to be protected by the RTS.
+ * @frame_txctl: &struct ieee80211_tx_info of the frame.
+ *
+ * If the RTS is generated in firmware, but the host system must provide
+ * the duration field, the low-level driver uses this function to receive
+ * the duration field value in little-endian byteorder.
+ */
+__le16 mac80211_rts_duration(struct ieee80211_hw *hw,
+			      struct ieee80211_vif *vif, size_t frame_len,
+			      const struct ieee80211_tx_info *frame_txctl);
+
+/**
+ * mac80211_ctstoself_get - CTS-to-self frame generation function
+ * @hw: pointer obtained from mac80211_alloc_hw().
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ * @frame: pointer to the frame that is going to be protected by the CTS-to-self.
+ * @frame_len: the frame length (in octets).
+ * @frame_txctl: &struct ieee80211_tx_info of the frame.
+ * @cts: The buffer where to store the CTS-to-self frame.
+ *
+ * If the CTS-to-self frames are generated by the host system (i.e., not in
+ * hardware/firmware), the low-level driver uses this function to receive
+ * the next CTS-to-self frame from the 802.11 code. The low-level is responsible
+ * for calling this function before and CTS-to-self frame is needed.
+ */
+void mac80211_ctstoself_get(struct ieee80211_hw *hw,
+			     struct ieee80211_vif *vif,
+			     const void *frame, size_t frame_len,
+			     const struct ieee80211_tx_info *frame_txctl,
+			     struct ieee80211_cts *cts);
+
+/**
+ * mac80211_ctstoself_duration - Get the duration field for a CTS-to-self frame
+ * @hw: pointer obtained from mac80211_alloc_hw().
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ * @frame_len: the length of the frame that is going to be protected by the CTS-to-self.
+ * @frame_txctl: &struct ieee80211_tx_info of the frame.
+ *
+ * If the CTS-to-self is generated in firmware, but the host system must provide
+ * the duration field, the low-level driver uses this function to receive
+ * the duration field value in little-endian byteorder.
+ */
+__le16 mac80211_ctstoself_duration(struct ieee80211_hw *hw,
+				    struct ieee80211_vif *vif,
+				    size_t frame_len,
+				    const struct ieee80211_tx_info *frame_txctl);
+
+/**
+ * mac80211_generic_frame_duration - Calculate the duration field for a frame
+ * @hw: pointer obtained from mac80211_alloc_hw().
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ * @frame_len: the length of the frame.
+ * @rate: the rate at which the frame is going to be transmitted.
+ *
+ * Calculate the duration field of some generic frame, given its
+ * length and transmission rate (in 100kbps).
+ */
+__le16 mac80211_generic_frame_duration(struct ieee80211_hw *hw,
+					struct ieee80211_vif *vif,
+					enum nl80211_band band,
+					size_t frame_len,
+					struct ieee80211_rate *rate);
+
+/**
+ * mac80211_get_buffered_bc - accessing buffered broadcast and multicast frames
+ * @hw: pointer as obtained from mac80211_alloc_hw().
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ *
+ * Function for accessing buffered broadcast and multicast frames. If
+ * hardware/firmware does not implement buffering of broadcast/multicast
+ * frames when power saving is used, 802.11 code buffers them in the host
+ * memory. The low-level driver uses this function to fetch next buffered
+ * frame. In most cases, this is used when generating beacon frame. This
+ * function returns a pointer to the next buffered skb or NULL if no more
+ * buffered frames are available.
+ *
+ * Note: buffered frames are returned only after DTIM beacon frame was
+ * generated with ieee80211_beacon_get() and the low-level driver must thus
+ * call ieee80211_beacon_get() first. mac80211_get_buffered_bc() returns
+ * NULL if the previous generated beacon was not DTIM, so the low-level driver
+ * does not need to check for DTIM beacons separately and should be able to
+ * use common code for all beacons.
+ */
+struct sk_buff *
+mac80211_get_buffered_bc(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
+
+/**
+ * mac80211_get_tkip_p1k_iv - get a TKIP phase 1 key for IV32
+ *
+ * This function returns the TKIP phase 1 key for the given IV32.
+ *
+ * @keyconf: the parameter passed with the set key
+ * @iv32: IV32 to get the P1K for
+ * @p1k: a buffer to which the key will be written, as 5 u16 values
+ */
+void mac80211_get_tkip_p1k_iv(struct ieee80211_key_conf *keyconf,
+			       u32 iv32, u16 *p1k);
+
+/**
+ * ieee80211_get_tkip_p1k - get a TKIP phase 1 key
+ *
+ * This function returns the TKIP phase 1 key for the IV32 taken
+ * from the given packet.
+ *
+ * @keyconf: the parameter passed with the set key
+ * @skb: the packet to take the IV32 value from that will be encrypted
+ *	with this P1K
+ * @p1k: a buffer to which the key will be written, as 5 u16 values
+ */
+static inline void ieee80211_get_tkip_p1k(struct ieee80211_key_conf *keyconf,
+					  struct sk_buff *skb, u16 *p1k)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+	const u8 *data = (u8 *)hdr + ieee80211_hdrlen(hdr->frame_control);
+	u32 iv32 = get_unaligned_le32(&data[4]);
+
+	mac80211_get_tkip_p1k_iv(keyconf, iv32, p1k);
+}
+
+/**
+ * mac80211_get_tkip_rx_p1k - get a TKIP phase 1 key for RX
+ *
+ * This function returns the TKIP phase 1 key for the given IV32
+ * and transmitter address.
+ *
+ * @keyconf: the parameter passed with the set key
+ * @ta: TA that will be used with the key
+ * @iv32: IV32 to get the P1K for
+ * @p1k: a buffer to which the key will be written, as 5 u16 values
+ */
+void mac80211_get_tkip_rx_p1k(struct ieee80211_key_conf *keyconf,
+			       const u8 *ta, u32 iv32, u16 *p1k);
+
+/**
+ * mac80211_get_tkip_p2k - get a TKIP phase 2 key
+ *
+ * This function computes the TKIP RC4 key for the IV values
+ * in the packet.
+ *
+ * @keyconf: the parameter passed with the set key
+ * @skb: the packet to take the IV32/IV16 values from that will be
+ *	encrypted with this key
+ * @p2k: a buffer to which the key will be written, 16 bytes
+ */
+void mac80211_get_tkip_p2k(struct ieee80211_key_conf *keyconf,
+			    struct sk_buff *skb, u8 *p2k);
+
+/**
+ * struct ieee80211_key_seq - key sequence counter
+ *
+ * @tkip: TKIP data, containing IV32 and IV16 in host byte order
+ * @ccmp: PN data, most significant byte first (big endian,
+ *	reverse order than in packet)
+ * @aes_cmac: PN data, most significant byte first (big endian,
+ *	reverse order than in packet)
+ */
+struct ieee80211_key_seq {
+	union {
+		struct {
+			u32 iv32;
+			u16 iv16;
+		} tkip;
+		struct {
+			u8 pn[6];
+		} ccmp;
+		struct {
+			u8 pn[6];
+		} aes_cmac;
+	};
+};
+
+/**
+ * mac80211_get_key_tx_seq - get key TX sequence counter
+ *
+ * @keyconf: the parameter passed with the set key
+ * @seq: buffer to receive the sequence data
+ *
+ * This function allows a driver to retrieve the current TX IV/PN
+ * for the given key. It must not be called if IV generation is
+ * offloaded to the device.
+ *
+ * Note that this function may only be called when no TX processing
+ * can be done concurrently, for example when queues are stopped
+ * and the stop has been synchronized.
+ */
+void mac80211_get_key_tx_seq(struct ieee80211_key_conf *keyconf,
+			      struct ieee80211_key_seq *seq);
+
+/**
+ * mac80211_get_key_rx_seq - get key RX sequence counter
+ *
+ * @keyconf: the parameter passed with the set key
+ * @tid: The TID, or -1 for the management frame value (CCMP only);
+ *	the value on TID 0 is also used for non-QoS frames. For
+ *	CMAC, only TID 0 is valid.
+ * @seq: buffer to receive the sequence data
+ *
+ * This function allows a driver to retrieve the current RX IV/PNs
+ * for the given key. It must not be called if IV checking is done
+ * by the device and not by mac80211.
+ *
+ * Note that this function may only be called when no RX processing
+ * can be done concurrently.
+ */
+void mac80211_get_key_rx_seq(struct ieee80211_key_conf *keyconf,
+			      int tid, struct ieee80211_key_seq *seq);
+
+/**
+ * mac80211_gtk_rekey_notify - notify userspace supplicant of rekeying
+ * @vif: virtual interface the rekeying was done on
+ * @bssid: The BSSID of the AP, for checking association
+ * @replay_ctr: the new replay counter after GTK rekeying
+ * @gfp: allocation flags
+ */
+void mac80211_gtk_rekey_notify(struct ieee80211_vif *vif, const u8 *bssid,
+				const u8 *replay_ctr, gfp_t gfp);
+
+/**
+ * mac80211_wake_queue - wake specific queue
+ * @hw: pointer as obtained from mac80211_alloc_hw().
+ * @queue: queue number (counted from zero).
+ *
+ * Drivers should use this function instead of netif_wake_queue.
+ */
+void mac80211_wake_queue(struct ieee80211_hw *hw, int queue);
+
+/**
+ * mac80211_stop_queue - stop specific queue
+ * @hw: pointer as obtained from mac80211_alloc_hw().
+ * @queue: queue number (counted from zero).
+ *
+ * Drivers should use this function instead of netif_stop_queue.
+ */
+void mac80211_stop_queue(struct ieee80211_hw *hw, int queue);
+
+/**
+ * mac80211_queue_stopped - test status of the queue
+ * @hw: pointer as obtained from mac80211_alloc_hw().
+ * @queue: queue number (counted from zero).
+ *
+ * Drivers should use this function instead of netif_stop_queue.
+ */
+
+int mac80211_queue_stopped(struct ieee80211_hw *hw, int queue);
+
+/**
+ * mac80211_stop_queues - stop all queues
+ * @hw: pointer as obtained from mac80211_alloc_hw().
+ *
+ * Drivers should use this function instead of netif_stop_queue.
+ */
+void mac80211_stop_queues(struct ieee80211_hw *hw);
+
+/**
+ * mac80211_wake_queues - wake all queues
+ * @hw: pointer as obtained from mac80211_alloc_hw().
+ *
+ * Drivers should use this function instead of netif_wake_queue.
+ */
+void mac80211_wake_queues(struct ieee80211_hw *hw);
+
+/**
+ * mac80211_scan_completed - completed hardware scan
+ *
+ * When hardware scan offload is used (i.e. the hw_scan() callback is
+ * assigned) this function needs to be called by the driver to notify
+ * mac80211 that the scan finished. This function can be called from
+ * any context, including hardirq context.
+ *
+ * @hw: the hardware that finished the scan
+ * @info: information about the completed scan
+ */
+void mac80211_scan_completed(struct ieee80211_hw *hw,
+			      struct cfg80211_scan_info *info);
+
+/**
+ * mac80211_sched_scan_results - got results from scheduled scan
+ *
+ * When a scheduled scan is running, this function needs to be called by the
+ * driver whenever there are new scan results available.
+ *
+ * @hw: the hardware that is performing scheduled scans
+ */
+void mac80211_sched_scan_results(struct ieee80211_hw *hw);
+
+/**
+ * mac80211_sched_scan_stopped - inform that the scheduled scan has stopped
+ *
+ * When a scheduled scan is running, this function can be called by
+ * the driver if it needs to stop the scan to perform another task.
+ * Usual scenarios are drivers that cannot continue the scheduled scan
+ * while associating, for instance.
+ *
+ * @hw: the hardware that is performing scheduled scans
+ */
+void mac80211_sched_scan_stopped(struct ieee80211_hw *hw);
+
+/**
+ * mac80211_iterate_active_interfaces - iterate active interfaces
+ *
+ * This function iterates over the interfaces associated with a given
+ * hardware that are currently active and calls the callback for them.
+ * This function allows the iterator function to sleep, when the iterator
+ * function is atomic @mac80211_iterate_active_interfaces_atomic can
+ * be used.
+ * Does not iterate over a new interface during add_interface()
+ *
+ * @hw: the hardware struct of which the interfaces should be iterated over
+ * @iterator: the iterator function to call
+ * @data: first argument of the iterator function
+ */
+void mac80211_iterate_active_interfaces(struct ieee80211_hw *hw,
+					 void (*iterator)(void *data, u8 *mac,
+						struct ieee80211_vif *vif),
+					 void *data);
+
+/**
+ * mac80211_iterate_active_interfaces_atomic - iterate active interfaces
+ *
+ * This function iterates over the interfaces associated with a given
+ * hardware that are currently active and calls the callback for them.
+ * This function requires the iterator callback function to be atomic,
+ * if that is not desired, use @mac80211_iterate_active_interfaces instead.
+ * Does not iterate over a new interface during add_interface()
+ *
+ * @hw: the hardware struct of which the interfaces should be iterated over
+ * @iterator: the iterator function to call, cannot sleep
+ * @data: first argument of the iterator function
+ */
+void mac80211_iterate_active_interfaces_atomic(struct ieee80211_hw *hw,
+						void (*iterator)(void *data,
+						    u8 *mac,
+						    struct ieee80211_vif *vif),
+						void *data);
+
+/**
+ * mac80211_queue_work - add work onto the mac80211 workqueue
+ *
+ * Drivers and mac80211 use this to add work onto the mac80211 workqueue.
+ * This helper ensures drivers are not queueing work when they should not be.
+ *
+ * @hw: the hardware struct for the interface we are adding work for
+ * @work: the work we want to add onto the mac80211 workqueue
+ */
+void mac80211_queue_work(struct ieee80211_hw *hw, struct work_struct *work);
+
+/**
+ * mac80211_queue_delayed_work - add work onto the mac80211 workqueue
+ *
+ * Drivers and mac80211 use this to queue delayed work onto the mac80211
+ * workqueue.
+ *
+ * @hw: the hardware struct for the interface we are adding work for
+ * @dwork: delayable work to queue onto the mac80211 workqueue
+ * @delay: number of jiffies to wait before queueing
+ */
+void mac80211_queue_delayed_work(struct ieee80211_hw *hw,
+				  struct delayed_work *dwork,
+				  unsigned long delay);
+
+/**
+ * mac80211_start_tx_ba_session - Start a tx Block Ack session.
+ * @sta: the station for which to start a BA session
+ * @tid: the TID to BA on.
+ * @timeout: session timeout value (in TUs)
+ *
+ * Return: success if addBA request was sent, failure otherwise
+ *
+ * Although mac80211/low level driver/user space application can estimate
+ * the need to start aggregation on a certain RA/TID, the session level
+ * will be managed by the mac80211.
+ */
+int mac80211_start_tx_ba_session(struct ieee80211_sta *sta, u16 tid,
+				  u16 timeout);
+
+/**
+ * mac80211_start_tx_ba_cb_irqsafe - low level driver ready to aggregate.
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback
+ * @ra: receiver address of the BA session recipient.
+ * @tid: the TID to BA on.
+ *
+ * This function must be called by low level driver once it has
+ * finished with preparations for the BA session. It can be called
+ * from any context.
+ */
+void mac80211_start_tx_ba_cb_irqsafe(struct ieee80211_vif *vif, const u8 *ra,
+				      u16 tid);
+
+/**
+ * mac80211_stop_tx_ba_session - Stop a Block Ack session.
+ * @sta: the station whose BA session to stop
+ * @tid: the TID to stop BA.
+ *
+ * Return: negative error if the TID is invalid, or no aggregation active
+ *
+ * Although mac80211/low level driver/user space application can estimate
+ * the need to stop aggregation on a certain RA/TID, the session level
+ * will be managed by the mac80211.
+ */
+int mac80211_stop_tx_ba_session(struct ieee80211_sta *sta, u16 tid);
+
+/**
+ * mac80211_stop_tx_ba_cb_irqsafe - low level driver ready to stop aggregate.
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback
+ * @ra: receiver address of the BA session recipient.
+ * @tid: the desired TID to BA on.
+ *
+ * This function must be called by low level driver once it has
+ * finished with preparations for the BA session tear down. It
+ * can be called from any context.
+ */
+void mac80211_stop_tx_ba_cb_irqsafe(struct ieee80211_vif *vif, const u8 *ra,
+				     u16 tid);
+
+/**
+ * mac80211_find_sta - find a station
+ *
+ * @vif: virtual interface to look for station on
+ * @addr: station's address
+ *
+ * This function must be called under RCU lock and the
+ * resulting pointer is only valid under RCU lock as well.
+ */
+struct ieee80211_sta *mac80211_find_sta(struct ieee80211_vif *vif,
+					 const u8 *addr);
+
+/**
+ * mac80211_find_sta_by_ifaddr - find a station on hardware
+ *
+ * @hw: pointer as obtained from mac80211_alloc_hw()
+ * @addr: remote station's address
+ * @localaddr: local address (vif->sdata->vif.addr). Use NULL for 'any'.
+ *
+ * This function must be called under RCU lock and the
+ * resulting pointer is only valid under RCU lock as well.
+ *
+ * NOTE: You may pass NULL for localaddr, but then you will just get
+ *      the first STA that matches the remote address 'addr'.
+ *      We can have multiple STA associated with multiple
+ *      logical stations (e.g. consider a station connecting to another
+ *      BSSID on the same AP hardware without disconnecting first).
+ *      In this case, the result of this method with localaddr NULL
+ *      is not reliable.
+ *
+ * DO NOT USE THIS FUNCTION with localaddr NULL if at all possible.
+ */
+struct ieee80211_sta *mac80211_find_sta_by_ifaddr(struct ieee80211_hw *hw,
+					       const u8 *addr,
+					       const u8 *localaddr);
+
+/**
+ * mac80211_sta_block_awake - block station from waking up
+ * @hw: the hardware
+ * @pubsta: the station
+ * @block: whether to block or unblock
+ *
+ * Some devices require that all frames that are on the queues
+ * for a specific station that went to sleep are flushed before
+ * a poll response or frames after the station woke up can be
+ * delivered to that it. Note that such frames must be rejected
+ * by the driver as filtered, with the appropriate status flag.
+ *
+ * This function allows implementing this mode in a race-free
+ * manner.
+ *
+ * To do this, a driver must keep track of the number of frames
+ * still enqueued for a specific station. If this number is not
+ * zero when the station goes to sleep, the driver must call
+ * this function to force mac80211 to consider the station to
+ * be asleep regardless of the station's actual state. Once the
+ * number of outstanding frames reaches zero, the driver must
+ * call this function again to unblock the station. That will
+ * cause mac80211 to be able to send ps-poll responses, and if
+ * the station queried in the meantime then frames will also
+ * be sent out as a result of this. Additionally, the driver
+ * will be notified that the station woke up some time after
+ * it is unblocked, regardless of whether the station actually
+ * woke up while blocked or not.
+ */
+void mac80211_sta_block_awake(struct ieee80211_hw *hw,
+			       struct ieee80211_sta *pubsta, bool block);
+
+/**
+ * ieee80211_sta_eosp - notify mac80211 about end of SP
+ * @pubsta: the station
+ *
+ * When a device transmits frames in a way that it can't tell
+ * mac80211 in the TX status about the EOSP, it must clear the
+ * %IEEE80211_TX_STATUS_EOSP bit and call this function instead.
+ * This applies for PS-Poll as well as uAPSD.
+ *
+ * Note that there is no non-_irqsafe version right now as
+ * it wasn't needed, but just like _tx_status() and _rx()
+ * must not be mixed in irqsafe/non-irqsafe versions, this
+ * function must not be mixed with those either. Use the
+ * all irqsafe, or all non-irqsafe, don't mix! If you need
+ * the non-irqsafe version of this, you need to add it.
+ */
+void mac80211_sta_eosp_irqsafe(struct ieee80211_sta *pubsta);
+
+/**
+ * mac80211_iter_keys - iterate keys programmed into the device
+ * @hw: pointer obtained from mac80211_alloc_hw()
+ * @vif: virtual interface to iterate, may be %NULL for all
+ * @iter: iterator function that will be called for each key
+ * @iter_data: custom data to pass to the iterator function
+ *
+ * This function can be used to iterate all the keys known to
+ * mac80211, even those that weren't previously programmed into
+ * the device. This is intended for use in WoWLAN if the device
+ * needs reprogramming of the keys during suspend. Note that due
+ * to locking reasons, it is also only safe to call this at few
+ * spots since it must hold the RTNL and be able to sleep.
+ *
+ * The order in which the keys are iterated matches the order
+ * in which they were originally installed and handed to the
+ * set_key callback.
+ */
+void mac80211_iter_keys(struct ieee80211_hw *hw,
+			 struct ieee80211_vif *vif,
+			 void (*iter)(struct ieee80211_hw *hw,
+				      struct ieee80211_vif *vif,
+				      struct ieee80211_sta *sta,
+				      struct ieee80211_key_conf *key,
+				      void *data),
+			 void *iter_data);
+
+/**
+ * mac80211_ap_probereq_get - retrieve a Probe Request template
+ * @hw: pointer obtained from mac80211_alloc_hw().
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ *
+ * Creates a Probe Request template which can, for example, be uploaded to
+ * hardware. The template is filled with bssid, ssid and supported rate
+ * information. This function must only be called from within the
+ * .bss_info_changed callback function and only in managed mode. The function
+ * is only useful when the interface is associated, otherwise it will return
+ * NULL.
+ */
+struct sk_buff *mac80211_ap_probereq_get(struct ieee80211_hw *hw,
+					  struct ieee80211_vif *vif);
+
+/**
+ * mac80211_beacon_loss - inform hardware does not receive beacons
+ *
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ *
+ * When beacon filtering is enabled with %IEEE80211_HW_BEACON_FILTER and
+ * %IEEE80211_CONF_PS is set, the driver needs to inform whenever the
+ * hardware is not receiving beacons with this function.
+ */
+void mac80211_beacon_loss(struct ieee80211_vif *vif);
+
+/**
+ * mac80211_connection_loss - inform hardware has lost connection to the AP
+ *
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ *
+ * When beacon filtering is enabled with %IEEE80211_HW_BEACON_FILTER, and
+ * %IEEE80211_CONF_PS and %IEEE80211_HW_CONNECTION_MONITOR are set, the driver
+ * needs to inform if the connection to the AP has been lost.
+ *
+ * This function will cause immediate change to disassociated state,
+ * without connection recovery attempts.
+ */
+void mac80211_connection_loss(struct ieee80211_vif *vif);
+
+/**
+ * mac80211_resume_disconnect - disconnect from AP after resume
+ *
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ *
+ * Instructs mac80211 to disconnect from the AP after resume.
+ * Drivers can use this after WoWLAN if they know that the
+ * connection cannot be kept up, for example because keys were
+ * used while the device was asleep but the replay counters or
+ * similar cannot be retrieved from the device during resume.
+ *
+ * Note that due to implementation issues, if the driver uses
+ * the reconfiguration functionality during resume the interface
+ * will still be added as associated first during resume and then
+ * disconnect normally later.
+ *
+ * This function can only be called from the resume callback and
+ * the driver must not be holding any of its own locks while it
+ * calls this function, or at least not any locks it needs in the
+ * key configuration paths (if it supports HW crypto).
+ */
+void mac80211_resume_disconnect(struct ieee80211_vif *vif);
+
+/**
+ * mac80211_disable_dyn_ps - force mac80211 to temporarily disable dynamic psm
+ *
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ *
+ * Some hardware require full power save to manage simultaneous BT traffic
+ * on the WLAN frequency. Full PSM is required periodically, whenever there are
+ * burst of BT traffic. The hardware gets information of BT traffic via
+ * hardware co-existence lines, and consequentially requests mac80211 to
+ * (temporarily) enter full psm.
+ * This function will only temporarily disable dynamic PS, not enable PSM if
+ * it was not already enabled.
+ * The driver must make sure to re-enable dynamic PS using
+ * mac80211_enable_dyn_ps() if the driver has disabled it.
+ *
+ */
+void mac80211_disable_dyn_ps(struct ieee80211_vif *vif);
+
+/**
+ * mac80211_enable_dyn_ps - restore dynamic psm after being disabled
+ *
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ *
+ * This function restores dynamic PS after being temporarily disabled via
+ * mac80211_disable_dyn_ps(). Each mac80211_disable_dyn_ps() call must
+ * be coupled with an eventual call to this function.
+ *
+ */
+void mac80211_enable_dyn_ps(struct ieee80211_vif *vif);
+
+/**
+ * mac80211_cqm_rssi_notify - inform a configured connection quality monitoring
+ *	rssi threshold triggered
+ *
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ * @rssi_event: the RSSI trigger event type
+ * @gfp: context flags
+ *
+ * When the %IEEE80211_HW_SUPPORTS_CQM_RSSI is set, and a connection quality
+ * monitoring is configured with an rssi threshold, the driver will inform
+ * whenever the rssi level reaches the threshold.
+ */
+void mac80211_cqm_rssi_notify(struct ieee80211_vif *vif,
+			       enum nl80211_cqm_rssi_threshold_event rssi_event,
+			       s32 rssi_level, gfp_t gfp);
+
+/**
+ * mac80211_get_operstate - get the operstate of the vif
+ *
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ *
+ * The driver might need to know the operstate of the net_device
+ * (specifically, whether the link is IF_OPER_UP after resume)
+ */
+unsigned char mac80211_get_operstate(struct ieee80211_vif *vif);
+
+/**
+ * ieee80211_cqm_beacon_miss_notify - inform a configured connection quality
+ *	monitoring beacon miss threshold triggered
+ *
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ * @gfp: context flag
+ *
+ * When the %IEEE80211_HW_SUPPORTS_CQM_BEACON_MISS is set, and a connection
+ * quality monitoring is configured with an beacon miss threshold, the driver
+ * will inform whenever the desired amount of consecutive beacons is missed.
+ */
+void ieee80211_cqm_beacon_miss_notify(struct ieee80211_vif *vif,
+				      gfp_t gfp);
+
+/**
+ * ieee80211_cqm_tx_fail_notify - inform a configured connection quality
+ *	monitoring beacon miss threshold triggered
+ *
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ * @gfp: context flag
+ *
+ * When the %IEEE80211_HW_SUPPORTS_CQM_TX_FAIL is set, and a connection
+ * quality monitoring is configured with an tx failure threshold, the driver
+ * whenever the desired amount of consecutive TX attempts is failed.
+ */
+void ieee80211_cqm_tx_fail_notify(struct ieee80211_vif *vif,
+				  gfp_t gfp);
+
+/**
+ * ieee80211_p2p_noa_notify - driver set/change NOA params
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ * @p2p_ps: new NOA params set/change by driver
+ * @gfp: context flag
+ *
+ * Inform upper layer about NOA change
+ */
+void ieee80211_p2p_noa_notify(struct ieee80211_vif *vif,
+			      struct cfg80211_p2p_ps *p2p_ps,
+			      gfp_t gfp);
+
+/**
+ * ieee80211_driver_hang_notify - inform upper layer about driver hang
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ * @gfp: context flag
+ *
+ * In case of FW/driver failure, send a notification to upper layers
+ * to take a recovery actions.
+ */
+void ieee80211_driver_hang_notify(struct ieee80211_vif *vif, gfp_t gfp);
+
+/**
+ * mac80211_chswitch_done - Complete channel switch process
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ * @success: make the channel switch successful or not
+ *
+ * Complete the channel switch post-process: set the new operational channel
+ * and wake up the suspended queues.
+ */
+void mac80211_chswitch_done(struct ieee80211_vif *vif, bool success);
+
+/**
+ * mac80211_request_smps - request SM PS transition
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ * @smps_mode: new SM PS mode
+ *
+ * This allows the driver to request an SM PS transition in managed
+ * mode. This is useful when the driver has more information than
+ * the stack about possible interference, for example by bluetooth.
+ */
+void mac80211_request_smps(struct ieee80211_vif *vif,
+			    enum ieee80211_smps_mode smps_mode);
+
+/**
+ * mac80211_key_removed - disable hw acceleration for key
+ * @key_conf: The key hw acceleration should be disabled for
+ *
+ * This allows drivers to indicate that the given key has been
+ * removed from hardware acceleration, due to a new key that
+ * was added. Don't use this if the key can continue to be used
+ * for TX, if the key restriction is on RX only it is permitted
+ * to keep the key for TX only and not call this function.
+ *
+ * Due to locking constraints, it may only be called during
+ * @set_key. This function must be allowed to sleep, and the
+ * key it tries to disable may still be used until it returns.
+ */
+void mac80211_key_removed(struct ieee80211_key_conf *key_conf);
+
+/**
+ * mac80211_ready_on_channel - notification of remain-on-channel start
+ * @hw: pointer as obtained from mac80211_alloc_hw()
+ */
+void mac80211_ready_on_channel(struct ieee80211_hw *hw);
+
+/**
+ * mac80211_remain_on_channel_expired - remain_on_channel duration expired
+ * @hw: pointer as obtained from mac80211_alloc_hw()
+ */
+void mac80211_remain_on_channel_expired(struct ieee80211_hw *hw, u64 cookie);
+
+/**
+ * mac80211_stop_rx_ba_session - callback to stop existing BA sessions
+ *
+ * in order not to harm the system performance and user experience, the device
+ * may request not to allow any rx ba session and tear down existing rx ba
+ * sessions based on system constraints such as periodic BT activity that needs
+ * to limit wlan activity (eg.sco or a2dp)."
+ * in such cases, the intention is to limit the duration of the rx ppdu and
+ * therefore prevent the peer device to use a-mpdu aggregation.
+ *
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ * @ba_rx_bitmap: Bit map of open rx ba per tid
+ * @addr: & to bssid mac address
+ */
+void mac80211_stop_rx_ba_session(struct ieee80211_vif *vif, u16 ba_rx_bitmap,
+				  const u8 *addr);
+
+/**
+ * mac80211_send_bar - send a BlockAckReq frame
+ *
+ * can be used to flush pending frames from the peer's aggregation reorder
+ * buffer.
+ *
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ * @ra: the peer's destination address
+ * @tid: the TID of the aggregation session
+ * @ssn: the new starting sequence number for the receiver
+ */
+void mac80211_send_bar(struct ieee80211_vif *vif, u8 *ra, u16 tid, u16 ssn);
+
+/* Rate control API */
+
+/**
+ * enum rate_control_changed - flags to indicate which parameter changed
+ *
+ * @IEEE80211_RC_HT_CHANGED: The HT parameters of the operating channel have
+ *	changed, rate control algorithm can update its internal state if needed.
+ */
+enum rate_control_changed {
+	IEEE80211_RC_HT_CHANGED = BIT(0)
+};
+
+/**
+ * struct ieee80211_tx_rate_control - rate control information for/from RC algo
+ *
+ * @hw: The hardware the algorithm is invoked for.
+ * @sband: The band this frame is being transmitted on.
+ * @bss_conf: the current BSS configuration
+ * @reported_rate: The rate control algorithm can fill this in to indicate
+ *	which rate should be reported to userspace as the current rate and
+ *	used for rate calculations in the mesh network.
+ * @rts: whether RTS will be used for this frame because it is longer than the
+ *	RTS threshold
+ * @short_preamble: whether mac80211 will request short-preamble transmission
+ *	if the selected rate supports it
+ * @max_rate_idx: user-requested maximum rate (not MCS for now)
+ *	(deprecated; this will be removed once drivers get updated to use
+ *	rate_idx_mask)
+ * @rate_idx_mask: user-requested rate mask (not MCS for now)
+ * @skb: the skb that will be transmitted, the control information in it needs
+ *	to be filled in
+ * @bss: whether this frame is sent out in AP or IBSS mode
+ */
+struct ieee80211_tx_rate_control {
+	struct ieee80211_hw *hw;
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_bss_conf *bss_conf;
+	struct sk_buff *skb;
+	struct ieee80211_tx_rate reported_rate;
+	bool rts, short_preamble;
+	u8 max_rate_idx;
+	u32 rate_idx_mask;
+	bool bss;
+};
+
+struct rate_control_ops {
+	struct module *module;
+	const char *name;
+	void *(*alloc)(struct ieee80211_hw *hw, struct dentry *debugfsdir);
+	void (*free)(void *priv);
+
+	void *(*alloc_sta)(void *priv, struct ieee80211_sta *sta, gfp_t gfp);
+	void (*rate_init)(void *priv, struct ieee80211_supported_band *sband,
+			  struct ieee80211_sta *sta, void *priv_sta);
+	void (*rate_update)(void *priv, struct ieee80211_supported_band *sband,
+			    struct ieee80211_sta *sta,
+			    void *priv_sta, u32 changed,
+			    enum nl80211_channel_type oper_chan_type);
+	void (*free_sta)(void *priv, struct ieee80211_sta *sta,
+			 void *priv_sta);
+
+	void (*tx_status)(void *priv, struct ieee80211_supported_band *sband,
+			  struct ieee80211_sta *sta, void *priv_sta,
+			  struct sk_buff *skb);
+	void (*get_rate)(void *priv, struct ieee80211_sta *sta, void *priv_sta,
+			 struct ieee80211_tx_rate_control *txrc);
+
+	void (*add_sta_debugfs)(void *priv, void *priv_sta,
+				struct dentry *dir);
+	void (*remove_sta_debugfs)(void *priv, void *priv_sta);
+};
+
+static inline int rate_supported(struct ieee80211_sta *sta,
+				 enum nl80211_band band,
+				 int index)
+{
+	return (sta == NULL || sta->supp_rates[band] & BIT(index));
+}
+
+/**
+ * xrmac_rate_control_send_low - helper for drivers for management/no-ack frames
+ *
+ * Rate control algorithms that agree to use the lowest rate to
+ * send management frames and NO_ACK data with the respective hw
+ * retries should use this in the beginning of their mac80211 get_rate
+ * callback. If true is returned the rate control can simply return.
+ * If false is returned we guarantee that sta and sta and priv_sta is
+ * not null.
+ *
+ * Rate control algorithms wishing to do more intelligent selection of
+ * rate for multicast/broadcast frames may choose to not use this.
+ *
+ * @sta: &struct ieee80211_sta pointer to the target destination. Note
+ * 	that this may be null.
+ * @priv_sta: private rate control structure. This may be null.
+ * @txrc: rate control information we sholud populate for mac80211.
+ */
+bool xrmac_rate_control_send_low(struct ieee80211_sta *sta,
+			   void *priv_sta,
+			   struct ieee80211_tx_rate_control *txrc);
+
+
+static inline s8
+rate_lowest_index(struct ieee80211_supported_band *sband,
+		  struct ieee80211_sta *sta)
+{
+	int i;
+
+	for (i = 0; i < sband->n_bitrates; i++)
+		if (rate_supported(sta, sband->band, i))
+			return i;
+
+	/* warn when we cannot find a rate. */
+	WARN_ON_ONCE(1);
+
+	/* and return 0 (the lowest index) */
+	return 0;
+}
+
+static inline
+bool rate_usable_index_exists(struct ieee80211_supported_band *sband,
+			      struct ieee80211_sta *sta)
+{
+	unsigned int i;
+
+	for (i = 0; i < sband->n_bitrates; i++)
+		if (rate_supported(sta, sband->band, i))
+			return true;
+	return false;
+}
+
+int mac80211_rate_control_register(struct rate_control_ops *ops);
+void mac80211_rate_control_unregister(struct rate_control_ops *ops);
+
+static inline bool
+conf_is_ht20(struct ieee80211_channel_conf *conf)
+{
+	return conf->channel_type == NL80211_CHAN_HT20;
+}
+
+static inline bool
+conf_is_ht40_minus(struct ieee80211_channel_conf *conf)
+{
+	return conf->channel_type == NL80211_CHAN_HT40MINUS;
+}
+
+static inline bool
+conf_is_ht40_plus(struct ieee80211_channel_conf *conf)
+{
+	return conf->channel_type == NL80211_CHAN_HT40PLUS;
+}
+
+static inline bool
+conf_is_ht40(struct ieee80211_channel_conf *conf)
+{
+	return conf_is_ht40_minus(conf) || conf_is_ht40_plus(conf);
+}
+
+static inline bool
+conf_is_ht(struct ieee80211_channel_conf *conf)
+{
+	return conf->channel_type != NL80211_CHAN_NO_HT;
+}
+
+static inline enum nl80211_iftype
+ieee80211_iftype_p2p(enum nl80211_iftype type, bool p2p)
+{
+	if (p2p) {
+		switch (type) {
+		case NL80211_IFTYPE_STATION:
+			return NL80211_IFTYPE_P2P_CLIENT;
+		case NL80211_IFTYPE_AP:
+			return NL80211_IFTYPE_P2P_GO;
+		default:
+			break;
+		}
+	}
+	return type;
+}
+
+static inline enum nl80211_iftype
+ieee80211_vif_type_p2p(struct ieee80211_vif *vif)
+{
+	return ieee80211_iftype_p2p(vif->type, vif->p2p);
+}
+
+void mac80211_enable_rssi_reports(struct ieee80211_vif *vif,
+				   int rssi_min_thold,
+				   int rssi_max_thold);
+
+void mac80211_disable_rssi_reports(struct ieee80211_vif *vif);
+
+int mac80211_add_srates_ie(struct ieee80211_vif *vif, struct sk_buff *skb);
+
+int mac80211_add_ext_srates_ie(struct ieee80211_vif *vif,
+				struct sk_buff *skb);
+#endif /* MAC80211_H */
diff -Naurp a/drivers/net/wireless/xr829/include/net/net_namespace.h b/drivers/net/wireless/xr829/include/net/net_namespace.h
--- a/drivers/net/wireless/xr829/include/net/net_namespace.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/net/net_namespace.h	2022-08-27 01:22:42.926539756 +0300
@@ -0,0 +1,10 @@
+#ifndef _COMPAT_NET_NET_NAMESPACE_H
+#define _COMPAT_NET_NET_NAMESPACE_H 1
+
+#include <generated/uapi/linux/version.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 23))
+#include_next <net/net_namespace.h>
+#endif /* (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 23)) */
+
+#endif	/* _COMPAT_NET_NET_NAMESPACE_H */
diff -Naurp a/drivers/net/wireless/xr829/include/net/regulatory.h b/drivers/net/wireless/xr829/include/net/regulatory.h
--- a/drivers/net/wireless/xr829/include/net/regulatory.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/net/regulatory.h	2022-08-27 01:22:42.926539756 +0300
@@ -0,0 +1,225 @@
+#ifndef __NET_REGULATORY_H
+#define __NET_REGULATORY_H
+/*
+ * regulatory support structures
+ *
+ * Copyright 2008-2009	Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/**
+ * enum environment_cap - Environment parsed from country IE
+ * @ENVIRON_ANY: indicates country IE applies to both indoor and
+ *	outdoor operation.
+ * @ENVIRON_INDOOR: indicates country IE applies only to indoor operation
+ * @ENVIRON_OUTDOOR: indicates country IE applies only to outdoor operation
+ */
+enum environment_cap {
+	ENVIRON_ANY,
+	ENVIRON_INDOOR,
+	ENVIRON_OUTDOOR,
+};
+
+/**
+ * struct regulatory_request - used to keep track of regulatory requests
+ *
+ * @rcu_head: RCU head struct used to free the request
+ * @wiphy_idx: this is set if this request's initiator is
+ *	%REGDOM_SET_BY_COUNTRY_IE or %REGDOM_SET_BY_DRIVER. This
+ *	can be used by the wireless core to deal with conflicts
+ *	and potentially inform users of which devices specifically
+ *	cased the conflicts.
+ * @initiator: indicates who sent this request, could be any of
+ *	of those set in nl80211_reg_initiator (%NL80211_REGDOM_SET_BY_*)
+ * @alpha2: the ISO / IEC 3166 alpha2 country code of the requested
+ *	regulatory domain. We have a few special codes:
+ *	00 - World regulatory domain
+ *	99 - built by driver but a specific alpha2 cannot be determined
+ *	98 - result of an intersection between two regulatory domains
+ *	97 - regulatory domain has not yet been configured
+ * @dfs_region: If CRDA responded with a regulatory domain that requires
+ *	DFS master operation on a known DFS region (NL80211_DFS_*),
+ *	dfs_region represents that region. Drivers can use this and the
+ *	@alpha2 to adjust their device's DFS parameters as required.
+ * @user_reg_hint_type: if the @initiator was of type
+ *	%NL80211_REGDOM_SET_BY_USER, this classifies the type
+ *	of hint passed. This could be any of the %NL80211_USER_REG_HINT_*
+ *	types.
+ * @intersect: indicates whether the wireless core should intersect
+ *	the requested regulatory domain with the presently set regulatory
+ *	domain.
+ * @processed: indicates whether or not this requests has already been
+ *	processed. When the last request is processed it means that the
+ *	currently regulatory domain set on cfg80211 is updated from
+ *	CRDA and can be used by other regulatory requests. When a
+ *	the last request is not yet processed we must yield until it
+ *	is processed before processing any new requests.
+ * @country_ie_checksum: checksum of the last processed and accepted
+ *	country IE
+ * @country_ie_env: lets us know if the AP is telling us we are outdoor,
+ *	indoor, or if it doesn't matter
+ * @list: used to insert into the reg_requests_list linked list
+ */
+struct regulatory_request {
+	struct rcu_head rcu_head;
+	int wiphy_idx;
+	enum nl80211_reg_initiator initiator;
+	enum nl80211_user_reg_hint_type user_reg_hint_type;
+	char alpha2[2];
+	enum nl80211_dfs_regions dfs_region;
+	bool intersect;
+	bool processed;
+	enum environment_cap country_ie_env;
+	struct list_head list;
+};
+
+/**
+ * enum ieee80211_regulatory_flags - device regulatory flags
+ *
+ * @REGULATORY_CUSTOM_REG: tells us the driver for this device
+ *	has its own custom regulatory domain and cannot identify the
+ *	ISO / IEC 3166 alpha2 it belongs to. When this is enabled
+ *	we will disregard the first regulatory hint (when the
+ *	initiator is %REGDOM_SET_BY_CORE). Drivers that use
+ *	wiphy_apply_custom_regulatory() should have this flag set
+ *	or the regulatory core will set it for the wiphy.
+ *	If you use regulatory_hint() *after* using
+ *	wiphy_apply_custom_regulatory() the wireless core will
+ *	clear the REGULATORY_CUSTOM_REG for your wiphy as it would be
+ *	implied that the device somehow gained knowledge of its region.
+ * @REGULATORY_STRICT_REG: tells us that the wiphy for this device
+ *	has regulatory domain that it wishes to be considered as the
+ *	superset for regulatory rules. After this device gets its regulatory
+ *	domain programmed further regulatory hints shall only be considered
+ *	for this device to enhance regulatory compliance, forcing the
+ *	device to only possibly use subsets of the original regulatory
+ *	rules. For example if channel 13 and 14 are disabled by this
+ *	device's regulatory domain no user specified regulatory hint which
+ *	has these channels enabled would enable them for this wiphy,
+ *	the device's original regulatory domain will be trusted as the
+ *	base. You can program the superset of regulatory rules for this
+ *	wiphy with regulatory_hint() for cards programmed with an
+ *	ISO3166-alpha2 country code. wiphys that use regulatory_hint()
+ *	will have their wiphy->regd programmed once the regulatory
+ *	domain is set, and all other regulatory hints will be ignored
+ *	until their own regulatory domain gets programmed.
+ * @REGULATORY_DISABLE_BEACON_HINTS: enable this if your driver needs to
+ *	ensure that passive scan flags and beaconing flags may not be lifted by
+ *	cfg80211 due to regulatory beacon hints. For more information on beacon
+ *	hints read the documenation for regulatory_hint_found_beacon()
+ * @REGULATORY_COUNTRY_IE_FOLLOW_POWER:  for devices that have a preference
+ *	that even though they may have programmed their own custom power
+ *	setting prior to wiphy registration, they want to ensure their channel
+ *	power settings are updated for this connection with the power settings
+ *	derived from the regulatory domain. The regulatory domain used will be
+ *	based on the ISO3166-alpha2 from country IE provided through
+ *	regulatory_hint_country_ie()
+ * @REGULATORY_COUNTRY_IE_IGNORE: for devices that have a preference to ignore
+ * 	all country IE information processed by the regulatory core. This will
+ * 	override %REGULATORY_COUNTRY_IE_FOLLOW_POWER as all country IEs will
+ * 	be ignored.
+ * @REGULATORY_ENABLE_RELAX_NO_IR: for devices that wish to allow the
+ *      NO_IR relaxation, which enables transmissions on channels on which
+ *      otherwise initiating radiation is not allowed. This will enable the
+ *      relaxations enabled under the CFG80211_REG_RELAX_NO_IR configuration
+ *      option
+ * @REGULATORY_IGNORE_STALE_KICKOFF: the regulatory core will _not_ make sure
+ *	all interfaces on this wiphy reside on allowed channels. If this flag
+ *	is not set, upon a regdomain change, the interfaces are given a grace
+ *	period (currently 60 seconds) to disconnect or move to an allowed
+ *	channel. Interfaces on forbidden channels are forcibly disconnected.
+ *	Currently these types of interfaces are supported for enforcement:
+ *	NL80211_IFTYPE_ADHOC, NL80211_IFTYPE_STATION, NL80211_IFTYPE_AP,
+ *	NL80211_IFTYPE_AP_VLAN, NL80211_IFTYPE_MONITOR,
+ *	NL80211_IFTYPE_P2P_CLIENT, NL80211_IFTYPE_P2P_GO,
+ *	NL80211_IFTYPE_P2P_DEVICE. The flag will be set by default if a device
+ *	includes any modes unsupported for enforcement checking.
+ * @REGULATORY_WIPHY_SELF_MANAGED: for devices that employ wiphy-specific
+ *	regdom management. These devices will ignore all regdom changes not
+ *	originating from their own wiphy.
+ *	A self-managed wiphys only employs regulatory information obtained from
+ *	the FW and driver and does not use other cfg80211 sources like
+ *	beacon-hints, country-code IEs and hints from other devices on the same
+ *	system. Conversely, a self-managed wiphy does not share its regulatory
+ *	hints with other devices in the system. If a system contains several
+ *	devices, one or more of which are self-managed, there might be
+ *	contradictory regulatory settings between them. Usage of flag is
+ *	generally discouraged. Only use it if the FW/driver is incompatible
+ *	with non-locally originated hints.
+ *	This flag is incompatible with the flags: %REGULATORY_CUSTOM_REG,
+ *	%REGULATORY_STRICT_REG, %REGULATORY_COUNTRY_IE_FOLLOW_POWER,
+ *	%REGULATORY_COUNTRY_IE_IGNORE and %REGULATORY_DISABLE_BEACON_HINTS.
+ *	Mixing any of the above flags with this flag will result in a failure
+ *	to register the wiphy. This flag implies
+ *	%REGULATORY_DISABLE_BEACON_HINTS and %REGULATORY_COUNTRY_IE_IGNORE.
+ */
+enum ieee80211_regulatory_flags {
+	REGULATORY_CUSTOM_REG			= BIT(0),
+	REGULATORY_STRICT_REG			= BIT(1),
+	REGULATORY_DISABLE_BEACON_HINTS		= BIT(2),
+	REGULATORY_COUNTRY_IE_FOLLOW_POWER	= BIT(3),
+	REGULATORY_COUNTRY_IE_IGNORE		= BIT(4),
+	REGULATORY_ENABLE_RELAX_NO_IR           = BIT(5),
+	REGULATORY_IGNORE_STALE_KICKOFF         = BIT(6),
+	REGULATORY_WIPHY_SELF_MANAGED		= BIT(7),
+};
+
+struct ieee80211_freq_range {
+	u32 start_freq_khz;
+	u32 end_freq_khz;
+	u32 max_bandwidth_khz;
+};
+
+struct ieee80211_power_rule {
+	u32 max_antenna_gain;
+	u32 max_eirp;
+};
+
+struct ieee80211_reg_rule {
+	struct ieee80211_freq_range freq_range;
+	struct ieee80211_power_rule power_rule;
+	u32 flags;
+	u32 dfs_cac_ms;
+};
+
+struct ieee80211_regdomain {
+	struct rcu_head rcu_head;
+	u32 n_reg_rules;
+	char alpha2[3];
+	enum nl80211_dfs_regions dfs_region;
+	struct ieee80211_reg_rule reg_rules[];
+};
+
+#define MHZ_TO_KHZ(freq) ((freq) * 1000)
+#define KHZ_TO_MHZ(freq) ((freq) / 1000)
+#define DBI_TO_MBI(gain) ((gain) * 100)
+#define MBI_TO_DBI(gain) ((gain) / 100)
+#define DBM_TO_MBM(gain) ((gain) * 100)
+#define MBM_TO_DBM(gain) ((gain) / 100)
+
+#define REG_RULE_EXT(start, end, bw, gain, eirp, dfs_cac, reg_flags)	\
+{									\
+	.freq_range.start_freq_khz = MHZ_TO_KHZ(start),			\
+	.freq_range.end_freq_khz = MHZ_TO_KHZ(end),			\
+	.freq_range.max_bandwidth_khz = MHZ_TO_KHZ(bw),			\
+	.power_rule.max_antenna_gain = DBI_TO_MBI(gain),		\
+	.power_rule.max_eirp = DBM_TO_MBM(eirp),			\
+	.flags = reg_flags,						\
+	.dfs_cac_ms = dfs_cac,						\
+}
+
+#define REG_RULE(start, end, bw, gain, eirp, reg_flags) \
+	REG_RULE_EXT(start, end, bw, gain, eirp, 0, reg_flags)
+
+#endif
diff -Naurp a/drivers/net/wireless/xr829/include/trace/define_trace.h b/drivers/net/wireless/xr829/include/trace/define_trace.h
--- a/drivers/net/wireless/xr829/include/trace/define_trace.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/trace/define_trace.h	2022-08-27 01:22:42.926539756 +0300
@@ -0,0 +1,5 @@
+#include <generated/uapi/linux/version.h>
+
+#if (KERNEL_VERSION(2, 6, 30) < LINUX_VERSION_CODE)
+#include_next <trace/define_trace.h>
+#endif /* (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 30)) */
diff -Naurp a/drivers/net/wireless/xr829/include/uapi/linux/nl80211.h b/drivers/net/wireless/xr829/include/uapi/linux/nl80211.h
--- a/drivers/net/wireless/xr829/include/uapi/linux/nl80211.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/include/uapi/linux/nl80211.h	2022-08-27 01:22:42.930539771 +0300
@@ -0,0 +1,6768 @@
+#ifndef __LINUX_NL80211_H
+#define __LINUX_NL80211_H
+/*
+ * 802.11 netlink interface public header
+ *
+ * Copyright 2006-2010 Johannes Berg <johannes@sipsolutions.net>
+ * Copyright 2008 Michael Wu <flamingice@sourmilk.net>
+ * Copyright 2008 Luis Carlos Cobo <luisca@cozybit.com>
+ * Copyright 2008 Michael Buesch <m@bues.ch>
+ * Copyright 2008, 2009 Luis R. Rodriguez <lrodriguez@atheros.com>
+ * Copyright 2008 Jouni Malinen <jouni.malinen@atheros.com>
+ * Copyright 2008 Colin McCabe <colin@cozybit.com>
+ * Copyright 2015-2017	Intel Deutschland GmbH
+ * Copyright (C) 2018-2019 Intel Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+/*
+ * This header file defines the userspace API to the wireless stack. Please
+ * be careful not to break things - i.e. don't move anything around or so
+ * unless you can demonstrate that it breaks neither API nor ABI.
+ *
+ * Additions to the API should be accompanied by actual implementations in
+ * an upstream driver, so that example implementations exist in case there
+ * are ever concerns about the precise semantics of the API or changes are
+ * needed, and to ensure that code for dead (no longer implemented) API
+ * can actually be identified and removed.
+ * Nonetheless, semantics should also be documented carefully in this file.
+ */
+
+#include <linux/types.h>
+
+#define NL80211_GENL_NAME "nl80211"
+
+#define NL80211_MULTICAST_GROUP_CONFIG		"config"
+#define NL80211_MULTICAST_GROUP_SCAN		"scan"
+#define NL80211_MULTICAST_GROUP_REG		"regulatory"
+#define NL80211_MULTICAST_GROUP_MLME		"mlme"
+#define NL80211_MULTICAST_GROUP_VENDOR		"vendor"
+#define NL80211_MULTICAST_GROUP_NAN		"nan"
+#define NL80211_MULTICAST_GROUP_TESTMODE	"testmode"
+
+#define NL80211_EDMG_BW_CONFIG_MIN	4
+#define NL80211_EDMG_BW_CONFIG_MAX	15
+#define NL80211_EDMG_CHANNELS_MIN	1
+#define NL80211_EDMG_CHANNELS_MAX	0x3c /* 0b00111100 */
+
+/**
+ * DOC: Station handling
+ *
+ * Stations are added per interface, but a special case exists with VLAN
+ * interfaces. When a station is bound to an AP interface, it may be moved
+ * into a VLAN identified by a VLAN interface index (%NL80211_ATTR_STA_VLAN).
+ * The station is still assumed to belong to the AP interface it was added
+ * to.
+ *
+ * Station handling varies per interface type and depending on the driver's
+ * capabilities.
+ *
+ * For drivers supporting TDLS with external setup (WIPHY_FLAG_SUPPORTS_TDLS
+ * and WIPHY_FLAG_TDLS_EXTERNAL_SETUP), the station lifetime is as follows:
+ *  - a setup station entry is added, not yet authorized, without any rate
+ *    or capability information, this just exists to avoid race conditions
+ *  - when the TDLS setup is done, a single NL80211_CMD_SET_STATION is valid
+ *    to add rate and capability information to the station and at the same
+ *    time mark it authorized.
+ *  - %NL80211_TDLS_ENABLE_LINK is then used
+ *  - after this, the only valid operation is to remove it by tearing down
+ *    the TDLS link (%NL80211_TDLS_DISABLE_LINK)
+ *
+ * TODO: need more info for other interface types
+ */
+
+/**
+ * DOC: Frame transmission/registration support
+ *
+ * Frame transmission and registration support exists to allow userspace
+ * management entities such as wpa_supplicant react to management frames
+ * that are not being handled by the kernel. This includes, for example,
+ * certain classes of action frames that cannot be handled in the kernel
+ * for various reasons.
+ *
+ * Frame registration is done on a per-interface basis and registrations
+ * cannot be removed other than by closing the socket. It is possible to
+ * specify a registration filter to register, for example, only for a
+ * certain type of action frame. In particular with action frames, those
+ * that userspace registers for will not be returned as unhandled by the
+ * driver, so that the registered application has to take responsibility
+ * for doing that.
+ *
+ * The type of frame that can be registered for is also dependent on the
+ * driver and interface type. The frame types are advertised in wiphy
+ * attributes so applications know what to expect.
+ *
+ * NOTE: When an interface changes type while registrations are active,
+ *       these registrations are ignored until the interface type is
+ *       changed again. This means that changing the interface type can
+ *       lead to a situation that couldn't otherwise be produced, but
+ *       any such registrations will be dormant in the sense that they
+ *       will not be serviced, i.e. they will not receive any frames.
+ *
+ * Frame transmission allows userspace to send for example the required
+ * responses to action frames. It is subject to some sanity checking,
+ * but many frames can be transmitted. When a frame was transmitted, its
+ * status is indicated to the sending socket.
+ *
+ * For more technical details, see the corresponding command descriptions
+ * below.
+ */
+
+/**
+ * DOC: Virtual interface / concurrency capabilities
+ *
+ * Some devices are able to operate with virtual MACs, they can have
+ * more than one virtual interface. The capability handling for this
+ * is a bit complex though, as there may be a number of restrictions
+ * on the types of concurrency that are supported.
+ *
+ * To start with, each device supports the interface types listed in
+ * the %NL80211_ATTR_SUPPORTED_IFTYPES attribute, but by listing the
+ * types there no concurrency is implied.
+ *
+ * Once concurrency is desired, more attributes must be observed:
+ * To start with, since some interface types are purely managed in
+ * software, like the AP-VLAN type in mac80211 for example, there's
+ * an additional list of these, they can be added at any time and
+ * are only restricted by some semantic restrictions (e.g. AP-VLAN
+ * cannot be added without a corresponding AP interface). This list
+ * is exported in the %NL80211_ATTR_SOFTWARE_IFTYPES attribute.
+ *
+ * Further, the list of supported combinations is exported. This is
+ * in the %NL80211_ATTR_INTERFACE_COMBINATIONS attribute. Basically,
+ * it exports a list of "groups", and at any point in time the
+ * interfaces that are currently active must fall into any one of
+ * the advertised groups. Within each group, there are restrictions
+ * on the number of interfaces of different types that are supported
+ * and also the number of different channels, along with potentially
+ * some other restrictions. See &enum nl80211_if_combination_attrs.
+ *
+ * All together, these attributes define the concurrency of virtual
+ * interfaces that a given device supports.
+ */
+
+/**
+ * DOC: packet coalesce support
+ *
+ * In most cases, host that receives IPv4 and IPv6 multicast/broadcast
+ * packets does not do anything with these packets. Therefore the
+ * reception of these unwanted packets causes unnecessary processing
+ * and power consumption.
+ *
+ * Packet coalesce feature helps to reduce number of received interrupts
+ * to host by buffering these packets in firmware/hardware for some
+ * predefined time. Received interrupt will be generated when one of the
+ * following events occur.
+ * a) Expiration of hardware timer whose expiration time is set to maximum
+ * coalescing delay of matching coalesce rule.
+ * b) Coalescing buffer in hardware reaches it's limit.
+ * c) Packet doesn't match any of the configured coalesce rules.
+ *
+ * User needs to configure following parameters for creating a coalesce
+ * rule.
+ * a) Maximum coalescing delay
+ * b) List of packet patterns which needs to be matched
+ * c) Condition for coalescence. pattern 'match' or 'no match'
+ * Multiple such rules can be created.
+ */
+
+/**
+ * DOC: WPA/WPA2 EAPOL handshake offload
+ *
+ * By setting @NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_PSK flag drivers
+ * can indicate they support offloading EAPOL handshakes for WPA/WPA2
+ * preshared key authentication. In %NL80211_CMD_CONNECT the preshared
+ * key should be specified using %NL80211_ATTR_PMK. Drivers supporting
+ * this offload may reject the %NL80211_CMD_CONNECT when no preshared
+ * key material is provided, for example when that driver does not
+ * support setting the temporal keys through %CMD_NEW_KEY.
+ *
+ * Similarly @NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X flag can be
+ * set by drivers indicating offload support of the PTK/GTK EAPOL
+ * handshakes during 802.1X authentication. In order to use the offload
+ * the %NL80211_CMD_CONNECT should have %NL80211_ATTR_WANT_1X_4WAY_HS
+ * attribute flag. Drivers supporting this offload may reject the
+ * %NL80211_CMD_CONNECT when the attribute flag is not present.
+ *
+ * For 802.1X the PMK or PMK-R0 are set by providing %NL80211_ATTR_PMK
+ * using %NL80211_CMD_SET_PMK. For offloaded FT support also
+ * %NL80211_ATTR_PMKR0_NAME must be provided.
+ */
+
+/**
+ * DOC: FILS shared key authentication offload
+ *
+ * FILS shared key authentication offload can be advertized by drivers by
+ * setting @NL80211_EXT_FEATURE_FILS_SK_OFFLOAD flag. The drivers that support
+ * FILS shared key authentication offload should be able to construct the
+ * authentication and association frames for FILS shared key authentication and
+ * eventually do a key derivation as per IEEE 802.11ai. The below additional
+ * parameters should be given to driver in %NL80211_CMD_CONNECT and/or in
+ * %NL80211_CMD_UPDATE_CONNECT_PARAMS.
+ *	%NL80211_ATTR_FILS_ERP_USERNAME - used to construct keyname_nai
+ *	%NL80211_ATTR_FILS_ERP_REALM - used to construct keyname_nai
+ *	%NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM - used to construct erp message
+ *	%NL80211_ATTR_FILS_ERP_RRK - used to generate the rIK and rMSK
+ * rIK should be used to generate an authentication tag on the ERP message and
+ * rMSK should be used to derive a PMKSA.
+ * rIK, rMSK should be generated and keyname_nai, sequence number should be used
+ * as specified in IETF RFC 6696.
+ *
+ * When FILS shared key authentication is completed, driver needs to provide the
+ * below additional parameters to userspace, which can be either after setting
+ * up a connection or after roaming.
+ *	%NL80211_ATTR_FILS_KEK - used for key renewal
+ *	%NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM - used in further EAP-RP exchanges
+ *	%NL80211_ATTR_PMKID - used to identify the PMKSA used/generated
+ *	%Nl80211_ATTR_PMK - used to update PMKSA cache in userspace
+ * The PMKSA can be maintained in userspace persistently so that it can be used
+ * later after reboots or wifi turn off/on also.
+ *
+ * %NL80211_ATTR_FILS_CACHE_ID is the cache identifier advertized by a FILS
+ * capable AP supporting PMK caching. It specifies the scope within which the
+ * PMKSAs are cached in an ESS. %NL80211_CMD_SET_PMKSA and
+ * %NL80211_CMD_DEL_PMKSA are enhanced to allow support for PMKSA caching based
+ * on FILS cache identifier. Additionally %NL80211_ATTR_PMK is used with
+ * %NL80211_SET_PMKSA to specify the PMK corresponding to a PMKSA for driver to
+ * use in a FILS shared key connection with PMKSA caching.
+ */
+
+/**
+ * DOC: SAE authentication offload
+ *
+ * By setting @NL80211_EXT_FEATURE_SAE_OFFLOAD flag drivers can indicate they
+ * support offloading SAE authentication for WPA3-Personal networks. In
+ * %NL80211_CMD_CONNECT the password for SAE should be specified using
+ * %NL80211_ATTR_SAE_PASSWORD.
+ */
+
+/**
+ * DOC: VLAN offload support for setting group keys and binding STAs to VLANs
+ *
+ * By setting @NL80211_EXT_FEATURE_VLAN_OFFLOAD flag drivers can indicate they
+ * support offloading VLAN functionality in a manner where the driver exposes a
+ * single netdev that uses VLAN tagged frames and separate VLAN-specific netdevs
+ * can then be added using RTM_NEWLINK/IFLA_VLAN_ID similarly to the Ethernet
+ * case. Frames received from stations that are not assigned to any VLAN are
+ * delivered on the main netdev and frames to such stations can be sent through
+ * that main netdev.
+ *
+ * %NL80211_CMD_NEW_KEY (for group keys), %NL80211_CMD_NEW_STATION, and
+ * %NL80211_CMD_SET_STATION will optionally specify vlan_id using
+ * %NL80211_ATTR_VLAN_ID.
+ */
+
+/**
+ * DOC: TID configuration
+ *
+ * TID config support can be checked in the %NL80211_ATTR_TID_CONFIG
+ * attribute given in wiphy capabilities.
+ *
+ * The necessary configuration parameters are mentioned in
+ * &enum nl80211_tid_config_attr and it will be passed to the
+ * %NL80211_CMD_SET_TID_CONFIG command in %NL80211_ATTR_TID_CONFIG.
+ *
+ * If the configuration needs to be applied for specific peer then the MAC
+ * address of the peer needs to be passed in %NL80211_ATTR_MAC, otherwise the
+ * configuration will be applied for all the connected peers in the vif except
+ * any peers that have peer specific configuration for the TID by default; if
+ * the %NL80211_TID_CONFIG_ATTR_OVERRIDE flag is set, peer specific values
+ * will be overwritten.
+ *
+ * All this configuration is valid only for STA's current connection
+ * i.e. the configuration will be reset to default when the STA connects back
+ * after disconnection/roaming, and this configuration will be cleared when
+ * the interface goes down.
+ */
+
+/**
+ * enum nl80211_commands - supported nl80211 commands
+ *
+ * @NL80211_CMD_UNSPEC: unspecified command to catch errors
+ *
+ * @NL80211_CMD_GET_WIPHY: request information about a wiphy or dump request
+ *	to get a list of all present wiphys.
+ * @NL80211_CMD_SET_WIPHY: set wiphy parameters, needs %NL80211_ATTR_WIPHY or
+ *	%NL80211_ATTR_IFINDEX; can be used to set %NL80211_ATTR_WIPHY_NAME,
+ *	%NL80211_ATTR_WIPHY_TXQ_PARAMS, %NL80211_ATTR_WIPHY_FREQ (and the
+ *	attributes determining the channel width; this is used for setting
+ *	monitor mode channel),  %NL80211_ATTR_WIPHY_RETRY_SHORT,
+ *	%NL80211_ATTR_WIPHY_RETRY_LONG, %NL80211_ATTR_WIPHY_FRAG_THRESHOLD,
+ *	and/or %NL80211_ATTR_WIPHY_RTS_THRESHOLD.
+ *	However, for setting the channel, see %NL80211_CMD_SET_CHANNEL
+ *	instead, the support here is for backward compatibility only.
+ * @NL80211_CMD_NEW_WIPHY: Newly created wiphy, response to get request
+ *	or rename notification. Has attributes %NL80211_ATTR_WIPHY and
+ *	%NL80211_ATTR_WIPHY_NAME.
+ * @NL80211_CMD_DEL_WIPHY: Wiphy deleted. Has attributes
+ *	%NL80211_ATTR_WIPHY and %NL80211_ATTR_WIPHY_NAME.
+ *
+ * @NL80211_CMD_GET_INTERFACE: Request an interface's configuration;
+ *	either a dump request for all interfaces or a specific get with a
+ *	single %NL80211_ATTR_IFINDEX is supported.
+ * @NL80211_CMD_SET_INTERFACE: Set type of a virtual interface, requires
+ *	%NL80211_ATTR_IFINDEX and %NL80211_ATTR_IFTYPE.
+ * @NL80211_CMD_NEW_INTERFACE: Newly created virtual interface or response
+ *	to %NL80211_CMD_GET_INTERFACE. Has %NL80211_ATTR_IFINDEX,
+ *	%NL80211_ATTR_WIPHY and %NL80211_ATTR_IFTYPE attributes. Can also
+ *	be sent from userspace to request creation of a new virtual interface,
+ *	then requires attributes %NL80211_ATTR_WIPHY, %NL80211_ATTR_IFTYPE and
+ *	%NL80211_ATTR_IFNAME.
+ * @NL80211_CMD_DEL_INTERFACE: Virtual interface was deleted, has attributes
+ *	%NL80211_ATTR_IFINDEX and %NL80211_ATTR_WIPHY. Can also be sent from
+ *	userspace to request deletion of a virtual interface, then requires
+ *	attribute %NL80211_ATTR_IFINDEX.
+ *
+ * @NL80211_CMD_GET_KEY: Get sequence counter information for a key specified
+ *	by %NL80211_ATTR_KEY_IDX and/or %NL80211_ATTR_MAC.
+ * @NL80211_CMD_SET_KEY: Set key attributes %NL80211_ATTR_KEY_DEFAULT,
+ *	%NL80211_ATTR_KEY_DEFAULT_MGMT, or %NL80211_ATTR_KEY_THRESHOLD.
+ * @NL80211_CMD_NEW_KEY: add a key with given %NL80211_ATTR_KEY_DATA,
+ *	%NL80211_ATTR_KEY_IDX, %NL80211_ATTR_MAC, %NL80211_ATTR_KEY_CIPHER,
+ *	and %NL80211_ATTR_KEY_SEQ attributes.
+ * @NL80211_CMD_DEL_KEY: delete a key identified by %NL80211_ATTR_KEY_IDX
+ *	or %NL80211_ATTR_MAC.
+ *
+ * @NL80211_CMD_GET_BEACON: (not used)
+ * @NL80211_CMD_SET_BEACON: change the beacon on an access point interface
+ *	using the %NL80211_ATTR_BEACON_HEAD and %NL80211_ATTR_BEACON_TAIL
+ *	attributes. For drivers that generate the beacon and probe responses
+ *	internally, the following attributes must be provided: %NL80211_ATTR_IE,
+ *	%NL80211_ATTR_IE_PROBE_RESP and %NL80211_ATTR_IE_ASSOC_RESP.
+ * @NL80211_CMD_START_AP: Start AP operation on an AP interface, parameters
+ *	are like for %NL80211_CMD_SET_BEACON, and additionally parameters that
+ *	do not change are used, these include %NL80211_ATTR_BEACON_INTERVAL,
+ *	%NL80211_ATTR_DTIM_PERIOD, %NL80211_ATTR_SSID,
+ *	%NL80211_ATTR_HIDDEN_SSID, %NL80211_ATTR_CIPHERS_PAIRWISE,
+ *	%NL80211_ATTR_CIPHER_GROUP, %NL80211_ATTR_WPA_VERSIONS,
+ *	%NL80211_ATTR_AKM_SUITES, %NL80211_ATTR_PRIVACY,
+ *	%NL80211_ATTR_AUTH_TYPE, %NL80211_ATTR_INACTIVITY_TIMEOUT,
+ *	%NL80211_ATTR_ACL_POLICY and %NL80211_ATTR_MAC_ADDRS.
+ *	The channel to use can be set on the interface or be given using the
+ *	%NL80211_ATTR_WIPHY_FREQ and the attributes determining channel width.
+ * @NL80211_CMD_NEW_BEACON: old alias for %NL80211_CMD_START_AP
+ * @NL80211_CMD_STOP_AP: Stop AP operation on the given interface
+ * @NL80211_CMD_DEL_BEACON: old alias for %NL80211_CMD_STOP_AP
+ *
+ * @NL80211_CMD_GET_STATION: Get station attributes for station identified by
+ *	%NL80211_ATTR_MAC on the interface identified by %NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_SET_STATION: Set station attributes for station identified by
+ *	%NL80211_ATTR_MAC on the interface identified by %NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_NEW_STATION: Add a station with given attributes to the
+ *	the interface identified by %NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_DEL_STATION: Remove a station identified by %NL80211_ATTR_MAC
+ *	or, if no MAC address given, all stations, on the interface identified
+ *	by %NL80211_ATTR_IFINDEX. %NL80211_ATTR_MGMT_SUBTYPE and
+ *	%NL80211_ATTR_REASON_CODE can optionally be used to specify which type
+ *	of disconnection indication should be sent to the station
+ *	(Deauthentication or Disassociation frame and reason code for that
+ *	frame).
+ *
+ * @NL80211_CMD_GET_MPATH: Get mesh path attributes for mesh path to
+ * 	destination %NL80211_ATTR_MAC on the interface identified by
+ * 	%NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_SET_MPATH:  Set mesh path attributes for mesh path to
+ * 	destination %NL80211_ATTR_MAC on the interface identified by
+ * 	%NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_NEW_MPATH: Create a new mesh path for the destination given by
+ *	%NL80211_ATTR_MAC via %NL80211_ATTR_MPATH_NEXT_HOP.
+ * @NL80211_CMD_DEL_MPATH: Delete a mesh path to the destination given by
+ *	%NL80211_ATTR_MAC.
+ * @NL80211_CMD_NEW_PATH: Add a mesh path with given attributes to the
+ *	the interface identified by %NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_DEL_PATH: Remove a mesh path identified by %NL80211_ATTR_MAC
+ *	or, if no MAC address given, all mesh paths, on the interface identified
+ *	by %NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_SET_BSS: Set BSS attributes for BSS identified by
+ *	%NL80211_ATTR_IFINDEX.
+ *
+ * @NL80211_CMD_GET_REG: ask the wireless core to send us its currently set
+ *	regulatory domain. If %NL80211_ATTR_WIPHY is specified and the device
+ *	has a private regulatory domain, it will be returned. Otherwise, the
+ *	global regdomain will be returned.
+ *	A device will have a private regulatory domain if it uses the
+ *	regulatory_hint() API. Even when a private regdomain is used the channel
+ *	information will still be mended according to further hints from
+ *	the regulatory core to help with compliance. A dump version of this API
+ *	is now available which will returns the global regdomain as well as
+ *	all private regdomains of present wiphys (for those that have it).
+ *	If a wiphy is self-managed (%NL80211_ATTR_WIPHY_SELF_MANAGED_REG), then
+ *	its private regdomain is the only valid one for it. The regulatory
+ *	core is not used to help with compliance in this case.
+ * @NL80211_CMD_SET_REG: Set current regulatory domain. CRDA sends this command
+ *	after being queried by the kernel. CRDA replies by sending a regulatory
+ *	domain structure which consists of %NL80211_ATTR_REG_ALPHA set to our
+ *	current alpha2 if it found a match. It also provides
+ * 	NL80211_ATTR_REG_RULE_FLAGS, and a set of regulatory rules. Each
+ * 	regulatory rule is a nested set of attributes  given by
+ * 	%NL80211_ATTR_REG_RULE_FREQ_[START|END] and
+ * 	%NL80211_ATTR_FREQ_RANGE_MAX_BW with an attached power rule given by
+ * 	%NL80211_ATTR_REG_RULE_POWER_MAX_ANT_GAIN and
+ * 	%NL80211_ATTR_REG_RULE_POWER_MAX_EIRP.
+ * @NL80211_CMD_REQ_SET_REG: ask the wireless core to set the regulatory domain
+ * 	to the specified ISO/IEC 3166-1 alpha2 country code. The core will
+ * 	store this as a valid request and then query userspace for it.
+ *
+ * @NL80211_CMD_GET_MESH_CONFIG: Get mesh networking properties for the
+ *	interface identified by %NL80211_ATTR_IFINDEX
+ *
+ * @NL80211_CMD_SET_MESH_CONFIG: Set mesh networking properties for the
+ *      interface identified by %NL80211_ATTR_IFINDEX
+ *
+ * @NL80211_CMD_SET_MGMT_EXTRA_IE: Set extra IEs for management frames. The
+ *	interface is identified with %NL80211_ATTR_IFINDEX and the management
+ *	frame subtype with %NL80211_ATTR_MGMT_SUBTYPE. The extra IE data to be
+ *	added to the end of the specified management frame is specified with
+ *	%NL80211_ATTR_IE. If the command succeeds, the requested data will be
+ *	added to all specified management frames generated by
+ *	kernel/firmware/driver.
+ *	Note: This command has been removed and it is only reserved at this
+ *	point to avoid re-using existing command number. The functionality this
+ *	command was planned for has been provided with cleaner design with the
+ *	option to specify additional IEs in NL80211_CMD_TRIGGER_SCAN,
+ *	NL80211_CMD_AUTHENTICATE, NL80211_CMD_ASSOCIATE,
+ *	NL80211_CMD_DEAUTHENTICATE, and NL80211_CMD_DISASSOCIATE.
+ *
+ * @NL80211_CMD_GET_SCAN: get scan results
+ * @NL80211_CMD_TRIGGER_SCAN: trigger a new scan with the given parameters
+ *	%NL80211_ATTR_TX_NO_CCK_RATE is used to decide whether to send the
+ *	probe requests at CCK rate or not. %NL80211_ATTR_BSSID can be used to
+ *	specify a BSSID to scan for; if not included, the wildcard BSSID will
+ *	be used.
+ * @NL80211_CMD_NEW_SCAN_RESULTS: scan notification (as a reply to
+ *	NL80211_CMD_GET_SCAN and on the "scan" multicast group)
+ * @NL80211_CMD_SCAN_ABORTED: scan was aborted, for unspecified reasons,
+ *	partial scan results may be available
+ *
+ * @NL80211_CMD_START_SCHED_SCAN: start a scheduled scan at certain
+ *	intervals and certain number of cycles, as specified by
+ *	%NL80211_ATTR_SCHED_SCAN_PLANS. If %NL80211_ATTR_SCHED_SCAN_PLANS is
+ *	not specified and only %NL80211_ATTR_SCHED_SCAN_INTERVAL is specified,
+ *	scheduled scan will run in an infinite loop with the specified interval.
+ *	These attributes are mutually exculsive,
+ *	i.e. NL80211_ATTR_SCHED_SCAN_INTERVAL must not be passed if
+ *	NL80211_ATTR_SCHED_SCAN_PLANS is defined.
+ *	If for some reason scheduled scan is aborted by the driver, all scan
+ *	plans are canceled (including scan plans that did not start yet).
+ *	Like with normal scans, if SSIDs (%NL80211_ATTR_SCAN_SSIDS)
+ *	are passed, they are used in the probe requests.  For
+ *	broadcast, a broadcast SSID must be passed (ie. an empty
+ *	string).  If no SSID is passed, no probe requests are sent and
+ *	a passive scan is performed.  %NL80211_ATTR_SCAN_FREQUENCIES,
+ *	if passed, define which channels should be scanned; if not
+ *	passed, all channels allowed for the current regulatory domain
+ *	are used.  Extra IEs can also be passed from the userspace by
+ *	using the %NL80211_ATTR_IE attribute.  The first cycle of the
+ *	scheduled scan can be delayed by %NL80211_ATTR_SCHED_SCAN_DELAY
+ *	is supplied. If the device supports multiple concurrent scheduled
+ *	scans, it will allow such when the caller provides the flag attribute
+ *	%NL80211_ATTR_SCHED_SCAN_MULTI to indicate user-space support for it.
+ * @NL80211_CMD_STOP_SCHED_SCAN: stop a scheduled scan. Returns -ENOENT if
+ *	scheduled scan is not running. The caller may assume that as soon
+ *	as the call returns, it is safe to start a new scheduled scan again.
+ * @NL80211_CMD_SCHED_SCAN_RESULTS: indicates that there are scheduled scan
+ *	results available.
+ * @NL80211_CMD_SCHED_SCAN_STOPPED: indicates that the scheduled scan has
+ *	stopped.  The driver may issue this event at any time during a
+ *	scheduled scan.  One reason for stopping the scan is if the hardware
+ *	does not support starting an association or a normal scan while running
+ *	a scheduled scan.  This event is also sent when the
+ *	%NL80211_CMD_STOP_SCHED_SCAN command is received or when the interface
+ *	is brought down while a scheduled scan was running.
+ *
+ * @NL80211_CMD_GET_SURVEY: get survey resuls, e.g. channel occupation
+ *      or noise level
+ * @NL80211_CMD_NEW_SURVEY_RESULTS: survey data notification (as a reply to
+ *	NL80211_CMD_GET_SURVEY and on the "scan" multicast group)
+ *
+ * @NL80211_CMD_SET_PMKSA: Add a PMKSA cache entry using %NL80211_ATTR_MAC
+ *	(for the BSSID), %NL80211_ATTR_PMKID, and optionally %NL80211_ATTR_PMK
+ *	(PMK is used for PTKSA derivation in case of FILS shared key offload) or
+ *	using %NL80211_ATTR_SSID, %NL80211_ATTR_FILS_CACHE_ID,
+ *	%NL80211_ATTR_PMKID, and %NL80211_ATTR_PMK in case of FILS
+ *	authentication where %NL80211_ATTR_FILS_CACHE_ID is the identifier
+ *	advertized by a FILS capable AP identifying the scope of PMKSA in an
+ *	ESS.
+ * @NL80211_CMD_DEL_PMKSA: Delete a PMKSA cache entry, using %NL80211_ATTR_MAC
+ *	(for the BSSID) and %NL80211_ATTR_PMKID or using %NL80211_ATTR_SSID,
+ *	%NL80211_ATTR_FILS_CACHE_ID, and %NL80211_ATTR_PMKID in case of FILS
+ *	authentication.
+ * @NL80211_CMD_FLUSH_PMKSA: Flush all PMKSA cache entries.
+ *
+ * @NL80211_CMD_REG_CHANGE: indicates to userspace the regulatory domain
+ * 	has been changed and provides details of the request information
+ * 	that caused the change such as who initiated the regulatory request
+ * 	(%NL80211_ATTR_REG_INITIATOR), the wiphy_idx
+ * 	(%NL80211_ATTR_REG_ALPHA2) on which the request was made from if
+ * 	the initiator was %NL80211_REGDOM_SET_BY_COUNTRY_IE or
+ * 	%NL80211_REGDOM_SET_BY_DRIVER, the type of regulatory domain
+ * 	set (%NL80211_ATTR_REG_TYPE), if the type of regulatory domain is
+ * 	%NL80211_REG_TYPE_COUNTRY the alpha2 to which we have moved on
+ * 	to (%NL80211_ATTR_REG_ALPHA2).
+ * @NL80211_CMD_REG_BEACON_HINT: indicates to userspace that an AP beacon
+ * 	has been found while world roaming thus enabling active scan or
+ * 	any mode of operation that initiates TX (beacons) on a channel
+ * 	where we would not have been able to do either before. As an example
+ * 	if you are world roaming (regulatory domain set to world or if your
+ * 	driver is using a custom world roaming regulatory domain) and while
+ * 	doing a passive scan on the 5 GHz band you find an AP there (if not
+ * 	on a DFS channel) you will now be able to actively scan for that AP
+ * 	or use AP mode on your card on that same channel. Note that this will
+ * 	never be used for channels 1-11 on the 2 GHz band as they are always
+ * 	enabled world wide. This beacon hint is only sent if your device had
+ * 	either disabled active scanning or beaconing on a channel. We send to
+ * 	userspace the wiphy on which we removed a restriction from
+ * 	(%NL80211_ATTR_WIPHY) and the channel on which this occurred
+ * 	before (%NL80211_ATTR_FREQ_BEFORE) and after (%NL80211_ATTR_FREQ_AFTER)
+ * 	the beacon hint was processed.
+ *
+ * @NL80211_CMD_AUTHENTICATE: authentication request and notification.
+ *	This command is used both as a command (request to authenticate) and
+ *	as an event on the "mlme" multicast group indicating completion of the
+ *	authentication process.
+ *	When used as a command, %NL80211_ATTR_IFINDEX is used to identify the
+ *	interface. %NL80211_ATTR_MAC is used to specify PeerSTAAddress (and
+ *	BSSID in case of station mode). %NL80211_ATTR_SSID is used to specify
+ *	the SSID (mainly for association, but is included in authentication
+ *	request, too, to help BSS selection. %NL80211_ATTR_WIPHY_FREQ is used
+ *	to specify the frequence of the channel in MHz. %NL80211_ATTR_AUTH_TYPE
+ *	is used to specify the authentication type. %NL80211_ATTR_IE is used to
+ *	define IEs (VendorSpecificInfo, but also including RSN IE and FT IEs)
+ *	to be added to the frame.
+ *	When used as an event, this reports reception of an Authentication
+ *	frame in station and IBSS modes when the local MLME processed the
+ *	frame, i.e., it was for the local STA and was received in correct
+ *	state. This is similar to MLME-AUTHENTICATE.confirm primitive in the
+ *	MLME SAP interface (kernel providing MLME, userspace SME). The
+ *	included %NL80211_ATTR_FRAME attribute contains the management frame
+ *	(including both the header and frame body, but not FCS). This event is
+ *	also used to indicate if the authentication attempt timed out. In that
+ *	case the %NL80211_ATTR_FRAME attribute is replaced with a
+ *	%NL80211_ATTR_TIMED_OUT flag (and %NL80211_ATTR_MAC to indicate which
+ *	pending authentication timed out).
+ * @NL80211_CMD_ASSOCIATE: association request and notification; like
+ *	NL80211_CMD_AUTHENTICATE but for Association and Reassociation
+ *	(similar to MLME-ASSOCIATE.request, MLME-REASSOCIATE.request,
+ *	MLME-ASSOCIATE.confirm or MLME-REASSOCIATE.confirm primitives). The
+ *	%NL80211_ATTR_PREV_BSSID attribute is used to specify whether the
+ *	request is for the initial association to an ESS (that attribute not
+ *	included) or for reassociation within the ESS (that attribute is
+ *	included).
+ * @NL80211_CMD_DEAUTHENTICATE: deauthentication request and notification; like
+ *	NL80211_CMD_AUTHENTICATE but for Deauthentication frames (similar to
+ *	MLME-DEAUTHENTICATION.request and MLME-DEAUTHENTICATE.indication
+ *	primitives).
+ * @NL80211_CMD_DISASSOCIATE: disassociation request and notification; like
+ *	NL80211_CMD_AUTHENTICATE but for Disassociation frames (similar to
+ *	MLME-DISASSOCIATE.request and MLME-DISASSOCIATE.indication primitives).
+ *
+ * @NL80211_CMD_MICHAEL_MIC_FAILURE: notification of a locally detected Michael
+ *	MIC (part of TKIP) failure; sent on the "mlme" multicast group; the
+ *	event includes %NL80211_ATTR_MAC to describe the source MAC address of
+ *	the frame with invalid MIC, %NL80211_ATTR_KEY_TYPE to show the key
+ *	type, %NL80211_ATTR_KEY_IDX to indicate the key identifier, and
+ *	%NL80211_ATTR_KEY_SEQ to indicate the TSC value of the frame; this
+ *	event matches with MLME-MICHAELMICFAILURE.indication() primitive
+ *
+ * @NL80211_CMD_JOIN_IBSS: Join a new IBSS -- given at least an SSID and a
+ *	FREQ attribute (for the initial frequency if no peer can be found)
+ *	and optionally a MAC (as BSSID) and FREQ_FIXED attribute if those
+ *	should be fixed rather than automatically determined. Can only be
+ *	executed on a network interface that is UP, and fixed BSSID/FREQ
+ *	may be rejected. Another optional parameter is the beacon interval,
+ *	given in the %NL80211_ATTR_BEACON_INTERVAL attribute, which if not
+ *	given defaults to 100 TU (102.4ms).
+ * @NL80211_CMD_LEAVE_IBSS: Leave the IBSS -- no special arguments, the IBSS is
+ *	determined by the network interface.
+ *
+ * @NL80211_CMD_TESTMODE: testmode command, takes a wiphy (or ifindex) attribute
+ *	to identify the device, and the TESTDATA blob attribute to pass through
+ *	to the driver.
+ *
+ * @NL80211_CMD_CONNECT: connection request and notification; this command
+ *	requests to connect to a specified network but without separating
+ *	auth and assoc steps. For this, you need to specify the SSID in a
+ *	%NL80211_ATTR_SSID attribute, and can optionally specify the association
+ *	IEs in %NL80211_ATTR_IE, %NL80211_ATTR_AUTH_TYPE, %NL80211_ATTR_USE_MFP,
+ *	%NL80211_ATTR_MAC, %NL80211_ATTR_WIPHY_FREQ, %NL80211_ATTR_CONTROL_PORT,
+ *	%NL80211_ATTR_CONTROL_PORT_ETHERTYPE,
+ *	%NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT,
+ *	%NL80211_ATTR_CONTROL_PORT_OVER_NL80211, %NL80211_ATTR_MAC_HINT, and
+ *	%NL80211_ATTR_WIPHY_FREQ_HINT.
+ *	If included, %NL80211_ATTR_MAC and %NL80211_ATTR_WIPHY_FREQ are
+ *	restrictions on BSS selection, i.e., they effectively prevent roaming
+ *	within the ESS. %NL80211_ATTR_MAC_HINT and %NL80211_ATTR_WIPHY_FREQ_HINT
+ *	can be included to provide a recommendation of the initial BSS while
+ *	allowing the driver to roam to other BSSes within the ESS and also to
+ *	ignore this recommendation if the indicated BSS is not ideal. Only one
+ *	set of BSSID,frequency parameters is used (i.e., either the enforcing
+ *	%NL80211_ATTR_MAC,%NL80211_ATTR_WIPHY_FREQ or the less strict
+ *	%NL80211_ATTR_MAC_HINT and %NL80211_ATTR_WIPHY_FREQ_HINT).
+ *	%NL80211_ATTR_PREV_BSSID can be used to request a reassociation within
+ *	the ESS in case the device is already associated and an association with
+ *	a different BSS is desired.
+ *	Background scan period can optionally be
+ *	specified in %NL80211_ATTR_BG_SCAN_PERIOD,
+ *	if not specified default background scan configuration
+ *	in driver is used and if period value is 0, bg scan will be disabled.
+ *	This attribute is ignored if driver does not support roam scan.
+ *	It is also sent as an event, with the BSSID and response IEs when the
+ *	connection is established or failed to be established. This can be
+ *	determined by the %NL80211_ATTR_STATUS_CODE attribute (0 = success,
+ *	non-zero = failure). If %NL80211_ATTR_TIMED_OUT is included in the
+ *	event, the connection attempt failed due to not being able to initiate
+ *	authentication/association or not receiving a response from the AP.
+ *	Non-zero %NL80211_ATTR_STATUS_CODE value is indicated in that case as
+ *	well to remain backwards compatible.
+ *	When establishing a security association, drivers that support 4 way
+ *	handshake offload should send %NL80211_CMD_PORT_AUTHORIZED event when
+ *	the 4 way handshake is completed successfully.
+ * @NL80211_CMD_ROAM: Notification indicating the card/driver roamed by itself.
+ *	When a security association was established with the new AP (e.g. if
+ *	the FT protocol was used for roaming or the driver completed the 4 way
+ *	handshake), this event should be followed by an
+ *	%NL80211_CMD_PORT_AUTHORIZED event.
+ * @NL80211_CMD_DISCONNECT: drop a given connection; also used to notify
+ *	userspace that a connection was dropped by the AP or due to other
+ *	reasons, for this the %NL80211_ATTR_DISCONNECTED_BY_AP and
+ *	%NL80211_ATTR_REASON_CODE attributes are used.
+ *
+ * @NL80211_CMD_SET_WIPHY_NETNS: Set a wiphy's netns. Note that all devices
+ *	associated with this wiphy must be down and will follow.
+ *
+ * @NL80211_CMD_REMAIN_ON_CHANNEL: Request to remain awake on the specified
+ *	channel for the specified amount of time. This can be used to do
+ *	off-channel operations like transmit a Public Action frame and wait for
+ *	a response while being associated to an AP on another channel.
+ *	%NL80211_ATTR_IFINDEX is used to specify which interface (and thus
+ *	radio) is used. %NL80211_ATTR_WIPHY_FREQ is used to specify the
+ *	frequency for the operation.
+ *	%NL80211_ATTR_DURATION is used to specify the duration in milliseconds
+ *	to remain on the channel. This command is also used as an event to
+ *	notify when the requested duration starts (it may take a while for the
+ *	driver to schedule this time due to other concurrent needs for the
+ *	radio).
+ *	When called, this operation returns a cookie (%NL80211_ATTR_COOKIE)
+ *	that will be included with any events pertaining to this request;
+ *	the cookie is also used to cancel the request.
+ * @NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL: This command can be used to cancel a
+ *	pending remain-on-channel duration if the desired operation has been
+ *	completed prior to expiration of the originally requested duration.
+ *	%NL80211_ATTR_WIPHY or %NL80211_ATTR_IFINDEX is used to specify the
+ *	radio. The %NL80211_ATTR_COOKIE attribute must be given as well to
+ *	uniquely identify the request.
+ *	This command is also used as an event to notify when a requested
+ *	remain-on-channel duration has expired.
+ *
+ * @NL80211_CMD_SET_TX_BITRATE_MASK: Set the mask of rates to be used in TX
+ *	rate selection. %NL80211_ATTR_IFINDEX is used to specify the interface
+ *	and @NL80211_ATTR_TX_RATES the set of allowed rates.
+ *
+ * @NL80211_CMD_REGISTER_FRAME: Register for receiving certain mgmt frames
+ *	(via @NL80211_CMD_FRAME) for processing in userspace. This command
+ *	requires an interface index, a frame type attribute (optional for
+ *	backward compatibility reasons, if not given assumes action frames)
+ *	and a match attribute containing the first few bytes of the frame
+ *	that should match, e.g. a single byte for only a category match or
+ *	four bytes for vendor frames including the OUI. The registration
+ *	cannot be dropped, but is removed automatically when the netlink
+ *	socket is closed. Multiple registrations can be made.
+ * @NL80211_CMD_REGISTER_ACTION: Alias for @NL80211_CMD_REGISTER_FRAME for
+ *	backward compatibility
+ * @NL80211_CMD_FRAME: Management frame TX request and RX notification. This
+ *	command is used both as a request to transmit a management frame and
+ *	as an event indicating reception of a frame that was not processed in
+ *	kernel code, but is for us (i.e., which may need to be processed in a
+ *	user space application). %NL80211_ATTR_FRAME is used to specify the
+ *	frame contents (including header). %NL80211_ATTR_WIPHY_FREQ is used
+ *	to indicate on which channel the frame is to be transmitted or was
+ *	received. If this channel is not the current channel (remain-on-channel
+ *	or the operational channel) the device will switch to the given channel
+ *	and transmit the frame, optionally waiting for a response for the time
+ *	specified using %NL80211_ATTR_DURATION. When called, this operation
+ *	returns a cookie (%NL80211_ATTR_COOKIE) that will be included with the
+ *	TX status event pertaining to the TX request.
+ *	%NL80211_ATTR_TX_NO_CCK_RATE is used to decide whether to send the
+ *	management frames at CCK rate or not in 2GHz band.
+ *	%NL80211_ATTR_CSA_C_OFFSETS_TX is an array of offsets to CSA
+ *	counters which will be updated to the current value. This attribute
+ *	is used during CSA period.
+ * @NL80211_CMD_FRAME_WAIT_CANCEL: When an off-channel TX was requested, this
+ *	command may be used with the corresponding cookie to cancel the wait
+ *	time if it is known that it is no longer necessary.  This command is
+ *	also sent as an event whenever the driver has completed the off-channel
+ *	wait time.
+ * @NL80211_CMD_ACTION: Alias for @NL80211_CMD_FRAME for backward compatibility.
+ * @NL80211_CMD_FRAME_TX_STATUS: Report TX status of a management frame
+ *	transmitted with %NL80211_CMD_FRAME. %NL80211_ATTR_COOKIE identifies
+ *	the TX command and %NL80211_ATTR_FRAME includes the contents of the
+ *	frame. %NL80211_ATTR_ACK flag is included if the recipient acknowledged
+ *	the frame.
+ * @NL80211_CMD_ACTION_TX_STATUS: Alias for @NL80211_CMD_FRAME_TX_STATUS for
+ *	backward compatibility.
+ *
+ * @NL80211_CMD_SET_POWER_SAVE: Set powersave, using %NL80211_ATTR_PS_STATE
+ * @NL80211_CMD_GET_POWER_SAVE: Get powersave status in %NL80211_ATTR_PS_STATE
+ *
+ * @NL80211_CMD_SET_CQM: Connection quality monitor configuration. This command
+ *	is used to configure connection quality monitoring notification trigger
+ *	levels.
+ * @NL80211_CMD_NOTIFY_CQM: Connection quality monitor notification. This
+ *	command is used as an event to indicate the that a trigger level was
+ *	reached.
+ * @NL80211_CMD_SET_CHANNEL: Set the channel (using %NL80211_ATTR_WIPHY_FREQ
+ *	and the attributes determining channel width) the given interface
+ *	(identifed by %NL80211_ATTR_IFINDEX) shall operate on.
+ *	In case multiple channels are supported by the device, the mechanism
+ *	with which it switches channels is implementation-defined.
+ *	When a monitor interface is given, it can only switch channel while
+ *	no other interfaces are operating to avoid disturbing the operation
+ *	of any other interfaces, and other interfaces will again take
+ *	precedence when they are used.
+ *
+ * @NL80211_CMD_SET_WDS_PEER: Set the MAC address of the peer on a WDS interface.
+ *
+ * @NL80211_CMD_SET_MULTICAST_TO_UNICAST: Configure if this AP should perform
+ *	multicast to unicast conversion. When enabled, all multicast packets
+ *	with ethertype ARP, IPv4 or IPv6 (possibly within an 802.1Q header)
+ *	will be sent out to each station once with the destination (multicast)
+ *	MAC address replaced by the station's MAC address. Note that this may
+ *	break certain expectations of the receiver, e.g. the ability to drop
+ *	unicast IP packets encapsulated in multicast L2 frames, or the ability
+ *	to not send destination unreachable messages in such cases.
+ *	This can only be toggled per BSS. Configure this on an interface of
+ *	type %NL80211_IFTYPE_AP. It applies to all its VLAN interfaces
+ *	(%NL80211_IFTYPE_AP_VLAN), except for those in 4addr (WDS) mode.
+ *	If %NL80211_ATTR_MULTICAST_TO_UNICAST_ENABLED is not present with this
+ *	command, the feature is disabled.
+ *
+ * @NL80211_CMD_JOIN_MESH: Join a mesh. The mesh ID must be given, and initial
+ *	mesh config parameters may be given.
+ * @NL80211_CMD_LEAVE_MESH: Leave the mesh network -- no special arguments, the
+ *	network is determined by the network interface.
+ *
+ * @NL80211_CMD_UNPROT_DEAUTHENTICATE: Unprotected deauthentication frame
+ *	notification. This event is used to indicate that an unprotected
+ *	deauthentication frame was dropped when MFP is in use.
+ * @NL80211_CMD_UNPROT_DISASSOCIATE: Unprotected disassociation frame
+ *	notification. This event is used to indicate that an unprotected
+ *	disassociation frame was dropped when MFP is in use.
+ *
+ * @NL80211_CMD_NEW_PEER_CANDIDATE: Notification on the reception of a
+ *      beacon or probe response from a compatible mesh peer.  This is only
+ *      sent while no station information (sta_info) exists for the new peer
+ *      candidate and when @NL80211_MESH_SETUP_USERSPACE_AUTH,
+ *      @NL80211_MESH_SETUP_USERSPACE_AMPE, or
+ *      @NL80211_MESH_SETUP_USERSPACE_MPM is set.  On reception of this
+ *      notification, userspace may decide to create a new station
+ *      (@NL80211_CMD_NEW_STATION).  To stop this notification from
+ *      reoccurring, the userspace authentication daemon may want to create the
+ *      new station with the AUTHENTICATED flag unset and maybe change it later
+ *      depending on the authentication result.
+ *
+ * @NL80211_CMD_GET_WOWLAN: get Wake-on-Wireless-LAN (WoWLAN) settings.
+ * @NL80211_CMD_SET_WOWLAN: set Wake-on-Wireless-LAN (WoWLAN) settings.
+ *	Since wireless is more complex than wired ethernet, it supports
+ *	various triggers. These triggers can be configured through this
+ *	command with the %NL80211_ATTR_WOWLAN_TRIGGERS attribute. For
+ *	more background information, see
+ *	http://wireless.kernel.org/en/users/Documentation/WoWLAN.
+ *	The @NL80211_CMD_SET_WOWLAN command can also be used as a notification
+ *	from the driver reporting the wakeup reason. In this case, the
+ *	@NL80211_ATTR_WOWLAN_TRIGGERS attribute will contain the reason
+ *	for the wakeup, if it was caused by wireless. If it is not present
+ *	in the wakeup notification, the wireless device didn't cause the
+ *	wakeup but reports that it was woken up.
+ *
+ * @NL80211_CMD_SET_REKEY_OFFLOAD: This command is used give the driver
+ *	the necessary information for supporting GTK rekey offload. This
+ *	feature is typically used during WoWLAN. The configuration data
+ *	is contained in %NL80211_ATTR_REKEY_DATA (which is nested and
+ *	contains the data in sub-attributes). After rekeying happened,
+ *	this command may also be sent by the driver as an MLME event to
+ *	inform userspace of the new replay counter.
+ *
+ * @NL80211_CMD_PMKSA_CANDIDATE: This is used as an event to inform userspace
+ *	of PMKSA caching dandidates.
+ *
+ * @NL80211_CMD_TDLS_OPER: Perform a high-level TDLS command (e.g. link setup).
+ *	In addition, this can be used as an event to request userspace to take
+ *	actions on TDLS links (set up a new link or tear down an existing one).
+ *	In such events, %NL80211_ATTR_TDLS_OPERATION indicates the requested
+ *	operation, %NL80211_ATTR_MAC contains the peer MAC address, and
+ *	%NL80211_ATTR_REASON_CODE the reason code to be used (only with
+ *	%NL80211_TDLS_TEARDOWN).
+ * @NL80211_CMD_TDLS_MGMT: Send a TDLS management frame. The
+ *	%NL80211_ATTR_TDLS_ACTION attribute determines the type of frame to be
+ *	sent. Public Action codes (802.11-2012 8.1.5.1) will be sent as
+ *	802.11 management frames, while TDLS action codes (802.11-2012
+ *	8.5.13.1) will be encapsulated and sent as data frames. The currently
+ *	supported Public Action code is %WLAN_PUB_ACTION_TDLS_DISCOVER_RES
+ *	and the currently supported TDLS actions codes are given in
+ *	&enum ieee80211_tdls_actioncode.
+ *
+ * @NL80211_CMD_UNEXPECTED_FRAME: Used by an application controlling an AP
+ *	(or GO) interface (i.e. hostapd) to ask for unexpected frames to
+ *	implement sending deauth to stations that send unexpected class 3
+ *	frames. Also used as the event sent by the kernel when such a frame
+ *	is received.
+ *	For the event, the %NL80211_ATTR_MAC attribute carries the TA and
+ *	other attributes like the interface index are present.
+ *	If used as the command it must have an interface index and you can
+ *	only unsubscribe from the event by closing the socket. Subscription
+ *	is also for %NL80211_CMD_UNEXPECTED_4ADDR_FRAME events.
+ *
+ * @NL80211_CMD_UNEXPECTED_4ADDR_FRAME: Sent as an event indicating that the
+ *	associated station identified by %NL80211_ATTR_MAC sent a 4addr frame
+ *	and wasn't already in a 4-addr VLAN. The event will be sent similarly
+ *	to the %NL80211_CMD_UNEXPECTED_FRAME event, to the same listener.
+ *
+ * @NL80211_CMD_PROBE_CLIENT: Probe an associated station on an AP interface
+ *	by sending a null data frame to it and reporting when the frame is
+ *	acknowleged. This is used to allow timing out inactive clients. Uses
+ *	%NL80211_ATTR_IFINDEX and %NL80211_ATTR_MAC. The command returns a
+ *	direct reply with an %NL80211_ATTR_COOKIE that is later used to match
+ *	up the event with the request. The event includes the same data and
+ *	has %NL80211_ATTR_ACK set if the frame was ACKed.
+ *
+ * @NL80211_CMD_REGISTER_BEACONS: Register this socket to receive beacons from
+ *	other BSSes when any interfaces are in AP mode. This helps implement
+ *	OLBC handling in hostapd. Beacons are reported in %NL80211_CMD_FRAME
+ *	messages. Note that per PHY only one application may register.
+ *
+ * @NL80211_CMD_SET_NOACK_MAP: sets a bitmap for the individual TIDs whether
+ *      No Acknowledgement Policy should be applied.
+ *
+ * @NL80211_CMD_CH_SWITCH_NOTIFY: An AP or GO may decide to switch channels
+ *	independently of the userspace SME, send this event indicating
+ *	%NL80211_ATTR_IFINDEX is now on %NL80211_ATTR_WIPHY_FREQ and the
+ *	attributes determining channel width.  This indication may also be
+ *	sent when a remotely-initiated switch (e.g., when a STA receives a CSA
+ *	from the remote AP) is completed;
+ *
+ * @NL80211_CMD_CH_SWITCH_STARTED_NOTIFY: Notify that a channel switch
+ *	has been started on an interface, regardless of the initiator
+ *	(ie. whether it was requested from a remote device or
+ *	initiated on our own).  It indicates that
+ *	%NL80211_ATTR_IFINDEX will be on %NL80211_ATTR_WIPHY_FREQ
+ *	after %NL80211_ATTR_CH_SWITCH_COUNT TBTT's.  The userspace may
+ *	decide to react to this indication by requesting other
+ *	interfaces to change channel as well.
+ *
+ * @NL80211_CMD_START_P2P_DEVICE: Start the given P2P Device, identified by
+ *	its %NL80211_ATTR_WDEV identifier. It must have been created with
+ *	%NL80211_CMD_NEW_INTERFACE previously. After it has been started, the
+ *	P2P Device can be used for P2P operations, e.g. remain-on-channel and
+ *	public action frame TX.
+ * @NL80211_CMD_STOP_P2P_DEVICE: Stop the given P2P Device, identified by
+ *	its %NL80211_ATTR_WDEV identifier.
+ *
+ * @NL80211_CMD_CONN_FAILED: connection request to an AP failed; used to
+ *	notify userspace that AP has rejected the connection request from a
+ *	station, due to particular reason. %NL80211_ATTR_CONN_FAILED_REASON
+ *	is used for this.
+ *
+ * @NL80211_CMD_SET_MCAST_RATE: Change the rate used to send multicast frames
+ *	for IBSS or MESH vif.
+ *
+ * @NL80211_CMD_SET_MAC_ACL: sets ACL for MAC address based access control.
+ *	This is to be used with the drivers advertising the support of MAC
+ *	address based access control. List of MAC addresses is passed in
+ *	%NL80211_ATTR_MAC_ADDRS and ACL policy is passed in
+ *	%NL80211_ATTR_ACL_POLICY. Driver will enable ACL with this list, if it
+ *	is not already done. The new list will replace any existing list. Driver
+ *	will clear its ACL when the list of MAC addresses passed is empty. This
+ *	command is used in AP/P2P GO mode. Driver has to make sure to clear its
+ *	ACL list during %NL80211_CMD_STOP_AP.
+ *
+ * @NL80211_CMD_RADAR_DETECT: Start a Channel availability check (CAC). Once
+ *	a radar is detected or the channel availability scan (CAC) has finished
+ *	or was aborted, or a radar was detected, usermode will be notified with
+ *	this event. This command is also used to notify userspace about radars
+ *	while operating on this channel.
+ *	%NL80211_ATTR_RADAR_EVENT is used to inform about the type of the
+ *	event.
+ *
+ * @NL80211_CMD_GET_PROTOCOL_FEATURES: Get global nl80211 protocol features,
+ *	i.e. features for the nl80211 protocol rather than device features.
+ *	Returns the features in the %NL80211_ATTR_PROTOCOL_FEATURES bitmap.
+ *
+ * @NL80211_CMD_UPDATE_FT_IES: Pass down the most up-to-date Fast Transition
+ *	Information Element to the WLAN driver
+ *
+ * @NL80211_CMD_FT_EVENT: Send a Fast transition event from the WLAN driver
+ *	to the supplicant. This will carry the target AP's MAC address along
+ *	with the relevant Information Elements. This event is used to report
+ *	received FT IEs (MDIE, FTIE, RSN IE, TIE, RICIE).
+ *
+ * @NL80211_CMD_CRIT_PROTOCOL_START: Indicates user-space will start running
+ *	a critical protocol that needs more reliability in the connection to
+ *	complete.
+ *
+ * @NL80211_CMD_CRIT_PROTOCOL_STOP: Indicates the connection reliability can
+ *	return back to normal.
+ *
+ * @NL80211_CMD_GET_COALESCE: Get currently supported coalesce rules.
+ * @NL80211_CMD_SET_COALESCE: Configure coalesce rules or clear existing rules.
+ *
+ * @NL80211_CMD_CHANNEL_SWITCH: Perform a channel switch by announcing the
+ *	the new channel information (Channel Switch Announcement - CSA)
+ *	in the beacon for some time (as defined in the
+ *	%NL80211_ATTR_CH_SWITCH_COUNT parameter) and then change to the
+ *	new channel. Userspace provides the new channel information (using
+ *	%NL80211_ATTR_WIPHY_FREQ and the attributes determining channel
+ *	width). %NL80211_ATTR_CH_SWITCH_BLOCK_TX may be supplied to inform
+ *	other station that transmission must be blocked until the channel
+ *	switch is complete.
+ *
+ * @NL80211_CMD_VENDOR: Vendor-specified command/event. The command is specified
+ *	by the %NL80211_ATTR_VENDOR_ID attribute and a sub-command in
+ *	%NL80211_ATTR_VENDOR_SUBCMD. Parameter(s) can be transported in
+ *	%NL80211_ATTR_VENDOR_DATA.
+ *	For feature advertisement, the %NL80211_ATTR_VENDOR_DATA attribute is
+ *	used in the wiphy data as a nested attribute containing descriptions
+ *	(&struct nl80211_vendor_cmd_info) of the supported vendor commands.
+ *	This may also be sent as an event with the same attributes.
+ *
+ * @NL80211_CMD_SET_QOS_MAP: Set Interworking QoS mapping for IP DSCP values.
+ *	The QoS mapping information is included in %NL80211_ATTR_QOS_MAP. If
+ *	that attribute is not included, QoS mapping is disabled. Since this
+ *	QoS mapping is relevant for IP packets, it is only valid during an
+ *	association. This is cleared on disassociation and AP restart.
+ *
+ * @NL80211_CMD_ADD_TX_TS: Ask the kernel to add a traffic stream for the given
+ *	%NL80211_ATTR_TSID and %NL80211_ATTR_MAC with %NL80211_ATTR_USER_PRIO
+ *	and %NL80211_ATTR_ADMITTED_TIME parameters.
+ *	Note that the action frame handshake with the AP shall be handled by
+ *	userspace via the normal management RX/TX framework, this only sets
+ *	up the TX TS in the driver/device.
+ *	If the admitted time attribute is not added then the request just checks
+ *	if a subsequent setup could be successful, the intent is to use this to
+ *	avoid setting up a session with the AP when local restrictions would
+ *	make that impossible. However, the subsequent "real" setup may still
+ *	fail even if the check was successful.
+ * @NL80211_CMD_DEL_TX_TS: Remove an existing TS with the %NL80211_ATTR_TSID
+ *	and %NL80211_ATTR_MAC parameters. It isn't necessary to call this
+ *	before removing a station entry entirely, or before disassociating
+ *	or similar, cleanup will happen in the driver/device in this case.
+ *
+ * @NL80211_CMD_GET_MPP: Get mesh path attributes for mesh proxy path to
+ *	destination %NL80211_ATTR_MAC on the interface identified by
+ *	%NL80211_ATTR_IFINDEX.
+ *
+ * @NL80211_CMD_JOIN_OCB: Join the OCB network. The center frequency and
+ *	bandwidth of a channel must be given.
+ * @NL80211_CMD_LEAVE_OCB: Leave the OCB network -- no special arguments, the
+ *	network is determined by the network interface.
+ *
+ * @NL80211_CMD_TDLS_CHANNEL_SWITCH: Start channel-switching with a TDLS peer,
+ *	identified by the %NL80211_ATTR_MAC parameter. A target channel is
+ *	provided via %NL80211_ATTR_WIPHY_FREQ and other attributes determining
+ *	channel width/type. The target operating class is given via
+ *	%NL80211_ATTR_OPER_CLASS.
+ *	The driver is responsible for continually initiating channel-switching
+ *	operations and returning to the base channel for communication with the
+ *	AP.
+ * @NL80211_CMD_TDLS_CANCEL_CHANNEL_SWITCH: Stop channel-switching with a TDLS
+ *	peer given by %NL80211_ATTR_MAC. Both peers must be on the base channel
+ *	when this command completes.
+ *
+ * @NL80211_CMD_WIPHY_REG_CHANGE: Similar to %NL80211_CMD_REG_CHANGE, but used
+ *	as an event to indicate changes for devices with wiphy-specific regdom
+ *	management.
+ *
+ * @NL80211_CMD_ABORT_SCAN: Stop an ongoing scan. Returns -ENOENT if a scan is
+ *	not running. The driver indicates the status of the scan through
+ *	cfg80211_scan_done().
+ *
+ * @NL80211_CMD_START_NAN: Start NAN operation, identified by its
+ *	%NL80211_ATTR_WDEV interface. This interface must have been
+ *	previously created with %NL80211_CMD_NEW_INTERFACE. After it
+ *	has been started, the NAN interface will create or join a
+ *	cluster. This command must have a valid
+ *	%NL80211_ATTR_NAN_MASTER_PREF attribute and optional
+ *	%NL80211_ATTR_BANDS attributes.  If %NL80211_ATTR_BANDS is
+ *	omitted or set to 0, it means don't-care and the device will
+ *	decide what to use.  After this command NAN functions can be
+ *	added.
+ * @NL80211_CMD_STOP_NAN: Stop the NAN operation, identified by
+ *	its %NL80211_ATTR_WDEV interface.
+ * @NL80211_CMD_ADD_NAN_FUNCTION: Add a NAN function. The function is defined
+ *	with %NL80211_ATTR_NAN_FUNC nested attribute. When called, this
+ *	operation returns the strictly positive and unique instance id
+ *	(%NL80211_ATTR_NAN_FUNC_INST_ID) and a cookie (%NL80211_ATTR_COOKIE)
+ *	of the function upon success.
+ *	Since instance ID's can be re-used, this cookie is the right
+ *	way to identify the function. This will avoid races when a termination
+ *	event is handled by the user space after it has already added a new
+ *	function that got the same instance id from the kernel as the one
+ *	which just terminated.
+ *	This cookie may be used in NAN events even before the command
+ *	returns, so userspace shouldn't process NAN events until it processes
+ *	the response to this command.
+ *	Look at %NL80211_ATTR_SOCKET_OWNER as well.
+ * @NL80211_CMD_DEL_NAN_FUNCTION: Delete a NAN function by cookie.
+ *	This command is also used as a notification sent when a NAN function is
+ *	terminated. This will contain a %NL80211_ATTR_NAN_FUNC_INST_ID
+ *	and %NL80211_ATTR_COOKIE attributes.
+ * @NL80211_CMD_CHANGE_NAN_CONFIG: Change current NAN
+ *	configuration. NAN must be operational (%NL80211_CMD_START_NAN
+ *	was executed).  It must contain at least one of the following
+ *	attributes: %NL80211_ATTR_NAN_MASTER_PREF,
+ *	%NL80211_ATTR_BANDS.  If %NL80211_ATTR_BANDS is omitted, the
+ *	current configuration is not changed.  If it is present but
+ *	set to zero, the configuration is changed to don't-care
+ *	(i.e. the device can decide what to do).
+ * @NL80211_CMD_NAN_FUNC_MATCH: Notification sent when a match is reported.
+ *	This will contain a %NL80211_ATTR_NAN_MATCH nested attribute and
+ *	%NL80211_ATTR_COOKIE.
+ *
+ * @NL80211_CMD_UPDATE_CONNECT_PARAMS: Update one or more connect parameters
+ *	for subsequent roaming cases if the driver or firmware uses internal
+ *	BSS selection. This command can be issued only while connected and it
+ *	does not result in a change for the current association. Currently,
+ *	only the %NL80211_ATTR_IE data is used and updated with this command.
+ *
+ * @NL80211_CMD_SET_PMK: For offloaded 4-Way handshake, set the PMK or PMK-R0
+ *	for the given authenticator address (specified with %NL80211_ATTR_MAC).
+ *	When %NL80211_ATTR_PMKR0_NAME is set, %NL80211_ATTR_PMK specifies the
+ *	PMK-R0, otherwise it specifies the PMK.
+ * @NL80211_CMD_DEL_PMK: For offloaded 4-Way handshake, delete the previously
+ *	configured PMK for the authenticator address identified by
+ *	%NL80211_ATTR_MAC.
+ * @NL80211_CMD_PORT_AUTHORIZED: An event that indicates that the 4 way
+ *	handshake was completed successfully by the driver. The BSSID is
+ *	specified with %NL80211_ATTR_MAC. Drivers that support 4 way handshake
+ *	offload should send this event after indicating 802.11 association with
+ *	%NL80211_CMD_CONNECT or %NL80211_CMD_ROAM. If the 4 way handshake failed
+ *	%NL80211_CMD_DISCONNECT should be indicated instead.
+ *
+ * @NL80211_CMD_CONTROL_PORT_FRAME: Control Port (e.g. PAE) frame TX request
+ *	and RX notification.  This command is used both as a request to transmit
+ *	a control port frame and as a notification that a control port frame
+ *	has been received. %NL80211_ATTR_FRAME is used to specify the
+ *	frame contents.  The frame is the raw EAPoL data, without ethernet or
+ *	802.11 headers.
+ *	When used as an event indication %NL80211_ATTR_CONTROL_PORT_ETHERTYPE,
+ *	%NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT and %NL80211_ATTR_MAC are added
+ *	indicating the protocol type of the received frame; whether the frame
+ *	was received unencrypted and the MAC address of the peer respectively.
+ *
+ * @NL80211_CMD_RELOAD_REGDB: Request that the regdb firmware file is reloaded.
+ *
+ * @NL80211_CMD_EXTERNAL_AUTH: This interface is exclusively defined for host
+ *	drivers that do not define separate commands for authentication and
+ *	association, but rely on user space for the authentication to happen.
+ *	This interface acts both as the event request (driver to user space)
+ *	to trigger the authentication and command response (userspace to
+ *	driver) to indicate the authentication status.
+ *
+ *	User space uses the %NL80211_CMD_CONNECT command to the host driver to
+ *	trigger a connection. The host driver selects a BSS and further uses
+ *	this interface to offload only the authentication part to the user
+ *	space. Authentication frames are passed between the driver and user
+ *	space through the %NL80211_CMD_FRAME interface. Host driver proceeds
+ *	further with the association after getting successful authentication
+ *	status. User space indicates the authentication status through
+ *	%NL80211_ATTR_STATUS_CODE attribute in %NL80211_CMD_EXTERNAL_AUTH
+ *	command interface.
+ *
+ *	Host driver reports this status on an authentication failure to the
+ *	user space through the connect result as the user space would have
+ *	initiated the connection through the connect request.
+ *
+ * @NL80211_CMD_STA_OPMODE_CHANGED: An event that notify station's
+ *	ht opmode or vht opmode changes using any of %NL80211_ATTR_SMPS_MODE,
+ *	%NL80211_ATTR_CHANNEL_WIDTH,%NL80211_ATTR_NSS attributes with its
+ *	address(specified in %NL80211_ATTR_MAC).
+ *
+ * @NL80211_CMD_GET_FTM_RESPONDER_STATS: Retrieve FTM responder statistics, in
+ *	the %NL80211_ATTR_FTM_RESPONDER_STATS attribute.
+ *
+ * @NL80211_CMD_PEER_MEASUREMENT_START: start a (set of) peer measurement(s)
+ *	with the given parameters, which are encapsulated in the nested
+ *	%NL80211_ATTR_PEER_MEASUREMENTS attribute. Optionally, MAC address
+ *	randomization may be enabled and configured by specifying the
+ *	%NL80211_ATTR_MAC and %NL80211_ATTR_MAC_MASK attributes.
+ *	If a timeout is requested, use the %NL80211_ATTR_TIMEOUT attribute.
+ *	A u64 cookie for further %NL80211_ATTR_COOKIE use is is returned in
+ *	the netlink extended ack message.
+ *
+ *	To cancel a measurement, close the socket that requested it.
+ *
+ *	Measurement results are reported to the socket that requested the
+ *	measurement using @NL80211_CMD_PEER_MEASUREMENT_RESULT when they
+ *	become available, so applications must ensure a large enough socket
+ *	buffer size.
+ *
+ *	Depending on driver support it may or may not be possible to start
+ *	multiple concurrent measurements.
+ * @NL80211_CMD_PEER_MEASUREMENT_RESULT: This command number is used for the
+ *	result notification from the driver to the requesting socket.
+ * @NL80211_CMD_PEER_MEASUREMENT_COMPLETE: Notification only, indicating that
+ *	the measurement completed, using the measurement cookie
+ *	(%NL80211_ATTR_COOKIE).
+ *
+ * @NL80211_CMD_NOTIFY_RADAR: Notify the kernel that a radar signal was
+ *	detected and reported by a neighboring device on the channel
+ *	indicated by %NL80211_ATTR_WIPHY_FREQ and other attributes
+ *	determining the width and type.
+ *
+ * @NL80211_CMD_UPDATE_OWE_INFO: This interface allows the host driver to
+ *	offload OWE processing to user space. This intends to support
+ *	OWE AKM by the host drivers that implement SME but rely
+ *	on the user space for the cryptographic/DH IE processing in AP mode.
+ *
+ * @NL80211_CMD_PROBE_MESH_LINK: The requirement for mesh link metric
+ *	refreshing, is that from one mesh point we be able to send some data
+ *	frames to other mesh points which are not currently selected as a
+ *	primary traffic path, but which are only 1 hop away. The absence of
+ *	the primary path to the chosen node makes it necessary to apply some
+ *	form of marking on a chosen packet stream so that the packets can be
+ *	properly steered to the selected node for testing, and not by the
+ *	regular mesh path lookup. Further, the packets must be of type data
+ *	so that the rate control (often embedded in firmware) is used for
+ *	rate selection.
+ *
+ *	Here attribute %NL80211_ATTR_MAC is used to specify connected mesh
+ *	peer MAC address and %NL80211_ATTR_FRAME is used to specify the frame
+ *	content. The frame is ethernet data.
+ *
+ * @NL80211_CMD_SET_TID_CONFIG: Data frame TID specific configuration
+ *	is passed using %NL80211_ATTR_TID_CONFIG attribute.
+ *
+ * @NL80211_CMD_MAX: highest used command number
+ * @__NL80211_CMD_AFTER_LAST: internal use
+ */
+enum nl80211_commands {
+/* don't change the order or add anything between, this is ABI! */
+	NL80211_CMD_UNSPEC,
+
+	NL80211_CMD_GET_WIPHY,		/* can dump */
+	NL80211_CMD_SET_WIPHY,
+	NL80211_CMD_NEW_WIPHY,
+	NL80211_CMD_DEL_WIPHY,
+
+	NL80211_CMD_GET_INTERFACE,	/* can dump */
+	NL80211_CMD_SET_INTERFACE,
+	NL80211_CMD_NEW_INTERFACE,
+	NL80211_CMD_DEL_INTERFACE,
+
+	NL80211_CMD_GET_KEY,
+	NL80211_CMD_SET_KEY,
+	NL80211_CMD_NEW_KEY,
+	NL80211_CMD_DEL_KEY,
+
+	NL80211_CMD_GET_BEACON,
+	NL80211_CMD_SET_BEACON,
+	NL80211_CMD_START_AP,
+	NL80211_CMD_NEW_BEACON = NL80211_CMD_START_AP,
+	NL80211_CMD_STOP_AP,
+	NL80211_CMD_DEL_BEACON = NL80211_CMD_STOP_AP,
+
+	NL80211_CMD_GET_STATION,
+	NL80211_CMD_SET_STATION,
+	NL80211_CMD_NEW_STATION,
+	NL80211_CMD_DEL_STATION,
+
+	NL80211_CMD_GET_MPATH,
+	NL80211_CMD_SET_MPATH,
+	NL80211_CMD_NEW_MPATH,
+	NL80211_CMD_DEL_MPATH,
+
+	NL80211_CMD_SET_BSS,
+
+	NL80211_CMD_SET_REG,
+	NL80211_CMD_REQ_SET_REG,
+
+	NL80211_CMD_GET_MESH_CONFIG,
+	NL80211_CMD_SET_MESH_CONFIG,
+
+	NL80211_CMD_SET_MGMT_EXTRA_IE /* reserved; not used */,
+
+	NL80211_CMD_GET_REG,
+
+	NL80211_CMD_GET_SCAN,
+	NL80211_CMD_TRIGGER_SCAN,
+	NL80211_CMD_NEW_SCAN_RESULTS,
+	NL80211_CMD_SCAN_ABORTED,
+
+	NL80211_CMD_REG_CHANGE,
+
+	NL80211_CMD_AUTHENTICATE,
+	NL80211_CMD_ASSOCIATE,
+	NL80211_CMD_DEAUTHENTICATE,
+	NL80211_CMD_DISASSOCIATE,
+
+	NL80211_CMD_MICHAEL_MIC_FAILURE,
+
+	NL80211_CMD_REG_BEACON_HINT,
+
+	NL80211_CMD_JOIN_IBSS,
+	NL80211_CMD_LEAVE_IBSS,
+
+	NL80211_CMD_TESTMODE,
+
+	NL80211_CMD_CONNECT,
+	NL80211_CMD_ROAM,
+	NL80211_CMD_DISCONNECT,
+
+	NL80211_CMD_SET_WIPHY_NETNS,
+
+	NL80211_CMD_GET_SURVEY,
+	NL80211_CMD_NEW_SURVEY_RESULTS,
+
+	NL80211_CMD_SET_PMKSA,
+	NL80211_CMD_DEL_PMKSA,
+	NL80211_CMD_FLUSH_PMKSA,
+
+	NL80211_CMD_REMAIN_ON_CHANNEL,
+	NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL,
+
+	NL80211_CMD_SET_TX_BITRATE_MASK,
+
+	NL80211_CMD_REGISTER_FRAME,
+	NL80211_CMD_REGISTER_ACTION = NL80211_CMD_REGISTER_FRAME,
+	NL80211_CMD_FRAME,
+	NL80211_CMD_ACTION = NL80211_CMD_FRAME,
+	NL80211_CMD_FRAME_TX_STATUS,
+	NL80211_CMD_ACTION_TX_STATUS = NL80211_CMD_FRAME_TX_STATUS,
+
+	NL80211_CMD_SET_POWER_SAVE,
+	NL80211_CMD_GET_POWER_SAVE,
+
+	NL80211_CMD_SET_CQM,
+	NL80211_CMD_NOTIFY_CQM,
+
+	NL80211_CMD_SET_CHANNEL,
+	NL80211_CMD_SET_WDS_PEER,
+
+	NL80211_CMD_FRAME_WAIT_CANCEL,
+
+	NL80211_CMD_JOIN_MESH,
+	NL80211_CMD_LEAVE_MESH,
+
+	NL80211_CMD_UNPROT_DEAUTHENTICATE,
+	NL80211_CMD_UNPROT_DISASSOCIATE,
+
+	NL80211_CMD_NEW_PEER_CANDIDATE,
+
+	NL80211_CMD_GET_WOWLAN,
+	NL80211_CMD_SET_WOWLAN,
+
+	NL80211_CMD_START_SCHED_SCAN,
+	NL80211_CMD_STOP_SCHED_SCAN,
+	NL80211_CMD_SCHED_SCAN_RESULTS,
+	NL80211_CMD_SCHED_SCAN_STOPPED,
+
+	NL80211_CMD_SET_REKEY_OFFLOAD,
+
+	NL80211_CMD_PMKSA_CANDIDATE,
+
+	NL80211_CMD_TDLS_OPER,
+	NL80211_CMD_TDLS_MGMT,
+
+	NL80211_CMD_UNEXPECTED_FRAME,
+
+	NL80211_CMD_PROBE_CLIENT,
+
+	NL80211_CMD_REGISTER_BEACONS,
+
+	NL80211_CMD_UNEXPECTED_4ADDR_FRAME,
+
+	NL80211_CMD_SET_NOACK_MAP,
+
+	NL80211_CMD_CH_SWITCH_NOTIFY,
+
+	NL80211_CMD_START_P2P_DEVICE,
+	NL80211_CMD_STOP_P2P_DEVICE,
+
+	NL80211_CMD_CONN_FAILED,
+
+	NL80211_CMD_SET_MCAST_RATE,
+
+	NL80211_CMD_SET_MAC_ACL,
+
+	NL80211_CMD_RADAR_DETECT,
+
+	NL80211_CMD_GET_PROTOCOL_FEATURES,
+
+	NL80211_CMD_UPDATE_FT_IES,
+	NL80211_CMD_FT_EVENT,
+
+	NL80211_CMD_CRIT_PROTOCOL_START,
+	NL80211_CMD_CRIT_PROTOCOL_STOP,
+
+	NL80211_CMD_GET_COALESCE,
+	NL80211_CMD_SET_COALESCE,
+
+	NL80211_CMD_CHANNEL_SWITCH,
+
+	NL80211_CMD_VENDOR,
+
+	NL80211_CMD_SET_QOS_MAP,
+
+	NL80211_CMD_ADD_TX_TS,
+	NL80211_CMD_DEL_TX_TS,
+
+	NL80211_CMD_GET_MPP,
+
+	NL80211_CMD_JOIN_OCB,
+	NL80211_CMD_LEAVE_OCB,
+
+	NL80211_CMD_CH_SWITCH_STARTED_NOTIFY,
+
+	NL80211_CMD_TDLS_CHANNEL_SWITCH,
+	NL80211_CMD_TDLS_CANCEL_CHANNEL_SWITCH,
+
+	NL80211_CMD_WIPHY_REG_CHANGE,
+
+	NL80211_CMD_ABORT_SCAN,
+
+	NL80211_CMD_START_NAN,
+	NL80211_CMD_STOP_NAN,
+	NL80211_CMD_ADD_NAN_FUNCTION,
+	NL80211_CMD_DEL_NAN_FUNCTION,
+	NL80211_CMD_CHANGE_NAN_CONFIG,
+	NL80211_CMD_NAN_MATCH,
+
+	NL80211_CMD_SET_MULTICAST_TO_UNICAST,
+
+	NL80211_CMD_UPDATE_CONNECT_PARAMS,
+
+	NL80211_CMD_SET_PMK,
+	NL80211_CMD_DEL_PMK,
+
+	NL80211_CMD_PORT_AUTHORIZED,
+
+	NL80211_CMD_RELOAD_REGDB,
+
+	NL80211_CMD_EXTERNAL_AUTH,
+
+	NL80211_CMD_STA_OPMODE_CHANGED,
+
+	NL80211_CMD_CONTROL_PORT_FRAME,
+
+	NL80211_CMD_GET_FTM_RESPONDER_STATS,
+
+	NL80211_CMD_PEER_MEASUREMENT_START,
+	NL80211_CMD_PEER_MEASUREMENT_RESULT,
+	NL80211_CMD_PEER_MEASUREMENT_COMPLETE,
+
+	NL80211_CMD_NOTIFY_RADAR,
+
+	NL80211_CMD_UPDATE_OWE_INFO,
+
+	NL80211_CMD_PROBE_MESH_LINK,
+
+	NL80211_CMD_SET_TID_CONFIG,
+
+	/* add new commands above here */
+
+	/* used to define NL80211_CMD_MAX below */
+	__NL80211_CMD_AFTER_LAST,
+	NL80211_CMD_MAX = __NL80211_CMD_AFTER_LAST - 1
+};
+
+/*
+ * Allow user space programs to use #ifdef on new commands by defining them
+ * here
+ */
+#define NL80211_CMD_SET_BSS NL80211_CMD_SET_BSS
+#define NL80211_CMD_SET_MGMT_EXTRA_IE NL80211_CMD_SET_MGMT_EXTRA_IE
+#define NL80211_CMD_REG_CHANGE NL80211_CMD_REG_CHANGE
+#define NL80211_CMD_AUTHENTICATE NL80211_CMD_AUTHENTICATE
+#define NL80211_CMD_ASSOCIATE NL80211_CMD_ASSOCIATE
+#define NL80211_CMD_DEAUTHENTICATE NL80211_CMD_DEAUTHENTICATE
+#define NL80211_CMD_DISASSOCIATE NL80211_CMD_DISASSOCIATE
+#define NL80211_CMD_REG_BEACON_HINT NL80211_CMD_REG_BEACON_HINT
+
+#define NL80211_ATTR_FEATURE_FLAGS NL80211_ATTR_FEATURE_FLAGS
+
+/* source-level API compatibility */
+#define NL80211_CMD_GET_MESH_PARAMS NL80211_CMD_GET_MESH_CONFIG
+#define NL80211_CMD_SET_MESH_PARAMS NL80211_CMD_SET_MESH_CONFIG
+#define NL80211_MESH_SETUP_VENDOR_PATH_SEL_IE NL80211_MESH_SETUP_IE
+
+/**
+ * enum nl80211_attrs - nl80211 netlink attributes
+ *
+ * @NL80211_ATTR_UNSPEC: unspecified attribute to catch errors
+ *
+ * @NL80211_ATTR_WIPHY: index of wiphy to operate on, cf.
+ *	/sys/class/ieee80211/<phyname>/index
+ * @NL80211_ATTR_WIPHY_NAME: wiphy name (used for renaming)
+ * @NL80211_ATTR_WIPHY_TXQ_PARAMS: a nested array of TX queue parameters
+ * @NL80211_ATTR_WIPHY_FREQ: frequency of the selected channel in MHz,
+ *	defines the channel together with the (deprecated)
+ *	%NL80211_ATTR_WIPHY_CHANNEL_TYPE attribute or the attributes
+ *	%NL80211_ATTR_CHANNEL_WIDTH and if needed %NL80211_ATTR_CENTER_FREQ1
+ *	and %NL80211_ATTR_CENTER_FREQ2
+ * @NL80211_ATTR_CHANNEL_WIDTH: u32 attribute containing one of the values
+ *	of &enum nl80211_chan_width, describing the channel width. See the
+ *	documentation of the enum for more information.
+ * @NL80211_ATTR_CENTER_FREQ1: Center frequency of the first part of the
+ *	channel, used for anything but 20 MHz bandwidth
+ * @NL80211_ATTR_CENTER_FREQ2: Center frequency of the second part of the
+ *	channel, used only for 80+80 MHz bandwidth
+ * @NL80211_ATTR_WIPHY_CHANNEL_TYPE: included with NL80211_ATTR_WIPHY_FREQ
+ *	if HT20 or HT40 are to be used (i.e., HT disabled if not included):
+ *	NL80211_CHAN_NO_HT = HT not allowed (i.e., same as not including
+ *		this attribute)
+ *	NL80211_CHAN_HT20 = HT20 only
+ *	NL80211_CHAN_HT40MINUS = secondary channel is below the primary channel
+ *	NL80211_CHAN_HT40PLUS = secondary channel is above the primary channel
+ *	This attribute is now deprecated.
+ * @NL80211_ATTR_WIPHY_RETRY_SHORT: TX retry limit for frames whose length is
+ *	less than or equal to the RTS threshold; allowed range: 1..255;
+ *	dot11ShortRetryLimit; u8
+ * @NL80211_ATTR_WIPHY_RETRY_LONG: TX retry limit for frames whose length is
+ *	greater than the RTS threshold; allowed range: 1..255;
+ *	dot11ShortLongLimit; u8
+ * @NL80211_ATTR_WIPHY_FRAG_THRESHOLD: fragmentation threshold, i.e., maximum
+ *	length in octets for frames; allowed range: 256..8000, disable
+ *	fragmentation with (u32)-1; dot11FragmentationThreshold; u32
+ * @NL80211_ATTR_WIPHY_RTS_THRESHOLD: RTS threshold (TX frames with length
+ *	larger than or equal to this use RTS/CTS handshake); allowed range:
+ *	0..65536, disable with (u32)-1; dot11RTSThreshold; u32
+ * @NL80211_ATTR_WIPHY_COVERAGE_CLASS: Coverage Class as defined by IEEE 802.11
+ *	section 7.3.2.9; dot11CoverageClass; u8
+ *
+ * @NL80211_ATTR_IFINDEX: network interface index of the device to operate on
+ * @NL80211_ATTR_IFNAME: network interface name
+ * @NL80211_ATTR_IFTYPE: type of virtual interface, see &enum nl80211_iftype
+ *
+ * @NL80211_ATTR_WDEV: wireless device identifier, used for pseudo-devices
+ *	that don't have a netdev (u64)
+ *
+ * @NL80211_ATTR_MAC: MAC address (various uses)
+ *
+ * @NL80211_ATTR_KEY_DATA: (temporal) key data; for TKIP this consists of
+ *	16 bytes encryption key followed by 8 bytes each for TX and RX MIC
+ *	keys
+ * @NL80211_ATTR_KEY_IDX: key ID (u8, 0-3)
+ * @NL80211_ATTR_KEY_CIPHER: key cipher suite (u32, as defined by IEEE 802.11
+ *	section 7.3.2.25.1, e.g. 0x000FAC04)
+ * @NL80211_ATTR_KEY_SEQ: transmit key sequence number (IV/PN) for TKIP and
+ *	CCMP keys, each six bytes in little endian
+ * @NL80211_ATTR_KEY_DEFAULT: Flag attribute indicating the key is default key
+ * @NL80211_ATTR_KEY_DEFAULT_MGMT: Flag attribute indicating the key is the
+ *	default management key
+ * @NL80211_ATTR_CIPHER_SUITES_PAIRWISE: For crypto settings for connect or
+ *	other commands, indicates which pairwise cipher suites are used
+ * @NL80211_ATTR_CIPHER_SUITE_GROUP: For crypto settings for connect or
+ *	other commands, indicates which group cipher suite is used
+ *
+ * @NL80211_ATTR_BEACON_INTERVAL: beacon interval in TU
+ * @NL80211_ATTR_DTIM_PERIOD: DTIM period for beaconing
+ * @NL80211_ATTR_BEACON_HEAD: portion of the beacon before the TIM IE
+ * @NL80211_ATTR_BEACON_TAIL: portion of the beacon after the TIM IE
+ *
+ * @NL80211_ATTR_STA_AID: Association ID for the station (u16)
+ * @NL80211_ATTR_STA_FLAGS: flags, nested element with NLA_FLAG attributes of
+ *	&enum nl80211_sta_flags (deprecated, use %NL80211_ATTR_STA_FLAGS2)
+ * @NL80211_ATTR_STA_LISTEN_INTERVAL: listen interval as defined by
+ *	IEEE 802.11 7.3.1.6 (u16).
+ * @NL80211_ATTR_STA_SUPPORTED_RATES: supported rates, array of supported
+ *	rates as defined by IEEE 802.11 7.3.2.2 but without the length
+ *	restriction (at most %NL80211_MAX_SUPP_RATES).
+ * @NL80211_ATTR_STA_VLAN: interface index of VLAN interface to move station
+ *	to, or the AP interface the station was originally added to to.
+ * @NL80211_ATTR_STA_INFO: information about a station, part of station info
+ *	given for %NL80211_CMD_GET_STATION, nested attribute containing
+ *	info as possible, see &enum nl80211_sta_info.
+ *
+ * @NL80211_ATTR_WIPHY_BANDS: Information about an operating bands,
+ *	consisting of a nested array.
+ *
+ * @NL80211_ATTR_MESH_ID: mesh id (1-32 bytes).
+ * @NL80211_ATTR_STA_PLINK_ACTION: action to perform on the mesh peer link
+ *	(see &enum nl80211_plink_action).
+ * @NL80211_ATTR_MPATH_NEXT_HOP: MAC address of the next hop for a mesh path.
+ * @NL80211_ATTR_MPATH_INFO: information about a mesh_path, part of mesh path
+ * 	info given for %NL80211_CMD_GET_MPATH, nested attribute described at
+ *	&enum nl80211_mpath_info.
+ *
+ * @NL80211_ATTR_MNTR_FLAGS: flags, nested element with NLA_FLAG attributes of
+ *      &enum nl80211_mntr_flags.
+ *
+ * @NL80211_ATTR_REG_ALPHA2: an ISO-3166-alpha2 country code for which the
+ * 	current regulatory domain should be set to or is already set to.
+ * 	For example, 'CR', for Costa Rica. This attribute is used by the kernel
+ * 	to query the CRDA to retrieve one regulatory domain. This attribute can
+ * 	also be used by userspace to query the kernel for the currently set
+ * 	regulatory domain. We chose an alpha2 as that is also used by the
+ * 	IEEE-802.11 country information element to identify a country.
+ * 	Users can also simply ask the wireless core to set regulatory domain
+ * 	to a specific alpha2.
+ * @NL80211_ATTR_REG_RULES: a nested array of regulatory domain regulatory
+ *	rules.
+ *
+ * @NL80211_ATTR_BSS_CTS_PROT: whether CTS protection is enabled (u8, 0 or 1)
+ * @NL80211_ATTR_BSS_SHORT_PREAMBLE: whether short preamble is enabled
+ *	(u8, 0 or 1)
+ * @NL80211_ATTR_BSS_SHORT_SLOT_TIME: whether short slot time enabled
+ *	(u8, 0 or 1)
+ * @NL80211_ATTR_BSS_BASIC_RATES: basic rates, array of basic
+ *	rates in format defined by IEEE 802.11 7.3.2.2 but without the length
+ *	restriction (at most %NL80211_MAX_SUPP_RATES).
+ *
+ * @NL80211_ATTR_HT_CAPABILITY: HT Capability information element (from
+ *	association request when used with NL80211_CMD_NEW_STATION)
+ *
+ * @NL80211_ATTR_SUPPORTED_IFTYPES: nested attribute containing all
+ *	supported interface types, each a flag attribute with the number
+ *	of the interface mode.
+ *
+ * @NL80211_ATTR_MGMT_SUBTYPE: Management frame subtype for
+ *	%NL80211_CMD_SET_MGMT_EXTRA_IE.
+ *
+ * @NL80211_ATTR_IE: Information element(s) data (used, e.g., with
+ *	%NL80211_CMD_SET_MGMT_EXTRA_IE).
+ *
+ * @NL80211_ATTR_MAX_NUM_SCAN_SSIDS: number of SSIDs you can scan with
+ *	a single scan request, a wiphy attribute.
+ * @NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS: number of SSIDs you can
+ *	scan with a single scheduled scan request, a wiphy attribute.
+ * @NL80211_ATTR_MAX_SCAN_IE_LEN: maximum length of information elements
+ *	that can be added to a scan request
+ * @NL80211_ATTR_MAX_SCHED_SCAN_IE_LEN: maximum length of information
+ *	elements that can be added to a scheduled scan request
+ * @NL80211_ATTR_MAX_MATCH_SETS: maximum number of sets that can be
+ *	used with @NL80211_ATTR_SCHED_SCAN_MATCH, a wiphy attribute.
+ *
+ * @NL80211_ATTR_SCAN_FREQUENCIES: nested attribute with frequencies (in MHz)
+ * @NL80211_ATTR_SCAN_SSIDS: nested attribute with SSIDs, leave out for passive
+ *	scanning and include a zero-length SSID (wildcard) for wildcard scan
+ * @NL80211_ATTR_BSS: scan result BSS
+ *
+ * @NL80211_ATTR_REG_INITIATOR: indicates who requested the regulatory domain
+ * 	currently in effect. This could be any of the %NL80211_REGDOM_SET_BY_*
+ * @NL80211_ATTR_REG_TYPE: indicates the type of the regulatory domain currently
+ * 	set. This can be one of the nl80211_reg_type (%NL80211_REGDOM_TYPE_*)
+ *
+ * @NL80211_ATTR_SUPPORTED_COMMANDS: wiphy attribute that specifies
+ *	an array of command numbers (i.e. a mapping index to command number)
+ *	that the driver for the given wiphy supports.
+ *
+ * @NL80211_ATTR_FRAME: frame data (binary attribute), including frame header
+ *	and body, but not FCS; used, e.g., with NL80211_CMD_AUTHENTICATE and
+ *	NL80211_CMD_ASSOCIATE events
+ * @NL80211_ATTR_SSID: SSID (binary attribute, 0..32 octets)
+ * @NL80211_ATTR_AUTH_TYPE: AuthenticationType, see &enum nl80211_auth_type,
+ *	represented as a u32
+ * @NL80211_ATTR_REASON_CODE: ReasonCode for %NL80211_CMD_DEAUTHENTICATE and
+ *	%NL80211_CMD_DISASSOCIATE, u16
+ *
+ * @NL80211_ATTR_KEY_TYPE: Key Type, see &enum nl80211_key_type, represented as
+ *	a u32
+ *
+ * @NL80211_ATTR_FREQ_BEFORE: A channel which has suffered a regulatory change
+ * 	due to considerations from a beacon hint. This attribute reflects
+ * 	the state of the channel _before_ the beacon hint processing. This
+ * 	attributes consists of a nested attribute containing
+ * 	NL80211_FREQUENCY_ATTR_*
+ * @NL80211_ATTR_FREQ_AFTER: A channel which has suffered a regulatory change
+ * 	due to considerations from a beacon hint. This attribute reflects
+ * 	the state of the channel _after_ the beacon hint processing. This
+ * 	attributes consists of a nested attribute containing
+ * 	NL80211_FREQUENCY_ATTR_*
+ *
+ * @NL80211_ATTR_CIPHER_SUITES: a set of u32 values indicating the supported
+ *	cipher suites
+ *
+ * @NL80211_ATTR_FREQ_FIXED: a flag indicating the IBSS should not try to look
+ *	for other networks on different channels
+ *
+ * @NL80211_ATTR_TIMED_OUT: a flag indicating than an operation timed out; this
+ *	is used, e.g., with %NL80211_CMD_AUTHENTICATE event
+ *
+ * @NL80211_ATTR_USE_MFP: Whether management frame protection (IEEE 802.11w) is
+ *	used for the association (&enum nl80211_mfp, represented as a u32);
+ *	this attribute can be used with %NL80211_CMD_ASSOCIATE and
+ *	%NL80211_CMD_CONNECT requests. %NL80211_MFP_OPTIONAL is not allowed for
+ *	%NL80211_CMD_ASSOCIATE since user space SME is expected and hence, it
+ *	must have decided whether to use management frame protection or not.
+ *	Setting %NL80211_MFP_OPTIONAL with a %NL80211_CMD_CONNECT request will
+ *	let the driver (or the firmware) decide whether to use MFP or not.
+ *
+ * @NL80211_ATTR_STA_FLAGS2: Attribute containing a
+ *	&struct nl80211_sta_flag_update.
+ *
+ * @NL80211_ATTR_CONTROL_PORT: A flag indicating whether user space controls
+ *	IEEE 802.1X port, i.e., sets/clears %NL80211_STA_FLAG_AUTHORIZED, in
+ *	station mode. If the flag is included in %NL80211_CMD_ASSOCIATE
+ *	request, the driver will assume that the port is unauthorized until
+ *	authorized by user space. Otherwise, port is marked authorized by
+ *	default in station mode.
+ * @NL80211_ATTR_CONTROL_PORT_ETHERTYPE: A 16-bit value indicating the
+ *	ethertype that will be used for key negotiation. It can be
+ *	specified with the associate and connect commands. If it is not
+ *	specified, the value defaults to 0x888E (PAE, 802.1X). This
+ *	attribute is also used as a flag in the wiphy information to
+ *	indicate that protocols other than PAE are supported.
+ * @NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT: When included along with
+ *	%NL80211_ATTR_CONTROL_PORT_ETHERTYPE, indicates that the custom
+ *	ethertype frames used for key negotiation must not be encrypted.
+ * @NL80211_ATTR_CONTROL_PORT_OVER_NL80211: A flag indicating whether control
+ *	port frames (e.g. of type given in %NL80211_ATTR_CONTROL_PORT_ETHERTYPE)
+ *	will be sent directly to the network interface or sent via the NL80211
+ *	socket.  If this attribute is missing, then legacy behavior of sending
+ *	control port frames directly to the network interface is used.  If the
+ *	flag is included, then control port frames are sent over NL80211 instead
+ *	using %CMD_CONTROL_PORT_FRAME.  If control port routing over NL80211 is
+ *	to be used then userspace must also use the %NL80211_ATTR_SOCKET_OWNER
+ *	flag. When used with %NL80211_ATTR_CONTROL_PORT_NO_PREAUTH, pre-auth
+ *	frames are not forwared over the control port.
+ *
+ * @NL80211_ATTR_TESTDATA: Testmode data blob, passed through to the driver.
+ *	We recommend using nested, driver-specific attributes within this.
+ *
+ * @NL80211_ATTR_DISCONNECTED_BY_AP: A flag indicating that the DISCONNECT
+ *	event was due to the AP disconnecting the station, and not due to
+ *	a local disconnect request.
+ * @NL80211_ATTR_STATUS_CODE: StatusCode for the %NL80211_CMD_CONNECT
+ *	event (u16)
+ * @NL80211_ATTR_PRIVACY: Flag attribute, used with connect(), indicating
+ *	that protected APs should be used. This is also used with NEW_BEACON to
+ *	indicate that the BSS is to use protection.
+ *
+ * @NL80211_ATTR_CIPHERS_PAIRWISE: Used with CONNECT, ASSOCIATE, and NEW_BEACON
+ *	to indicate which unicast key ciphers will be used with the connection
+ *	(an array of u32).
+ * @NL80211_ATTR_CIPHER_GROUP: Used with CONNECT, ASSOCIATE, and NEW_BEACON to
+ *	indicate which group key cipher will be used with the connection (a
+ *	u32).
+ * @NL80211_ATTR_WPA_VERSIONS: Used with CONNECT, ASSOCIATE, and NEW_BEACON to
+ *	indicate which WPA version(s) the AP we want to associate with is using
+ *	(a u32 with flags from &enum nl80211_wpa_versions).
+ * @NL80211_ATTR_AKM_SUITES: Used with CONNECT, ASSOCIATE, and NEW_BEACON to
+ *	indicate which key management algorithm(s) to use (an array of u32).
+ *	This attribute is also sent in response to @NL80211_CMD_GET_WIPHY,
+ *	indicating the supported AKM suites, intended for specific drivers which
+ *	implement SME and have constraints on which AKMs are supported and also
+ *	the cases where an AKM support is offloaded to the driver/firmware.
+ *	If there is no such notification from the driver, user space should
+ *	assume the driver supports all the AKM suites.
+ *
+ * @NL80211_ATTR_REQ_IE: (Re)association request information elements as
+ *	sent out by the card, for ROAM and successful CONNECT events.
+ * @NL80211_ATTR_RESP_IE: (Re)association response information elements as
+ *	sent by peer, for ROAM and successful CONNECT events.
+ *
+ * @NL80211_ATTR_PREV_BSSID: previous BSSID, to be used in ASSOCIATE and CONNECT
+ *	commands to specify a request to reassociate within an ESS, i.e., to use
+ *	Reassociate Request frame (with the value of this attribute in the
+ *	Current AP address field) instead of Association Request frame which is
+ *	used for the initial association to an ESS.
+ *
+ * @NL80211_ATTR_KEY: key information in a nested attribute with
+ *	%NL80211_KEY_* sub-attributes
+ * @NL80211_ATTR_KEYS: array of keys for static WEP keys for connect()
+ *	and join_ibss(), key information is in a nested attribute each
+ *	with %NL80211_KEY_* sub-attributes
+ *
+ * @NL80211_ATTR_PID: Process ID of a network namespace.
+ *
+ * @NL80211_ATTR_GENERATION: Used to indicate consistent snapshots for
+ *	dumps. This number increases whenever the object list being
+ *	dumped changes, and as such userspace can verify that it has
+ *	obtained a complete and consistent snapshot by verifying that
+ *	all dump messages contain the same generation number. If it
+ *	changed then the list changed and the dump should be repeated
+ *	completely from scratch.
+ *
+ * @NL80211_ATTR_4ADDR: Use 4-address frames on a virtual interface
+ *
+ * @NL80211_ATTR_SURVEY_INFO: survey information about a channel, part of
+ *      the survey response for %NL80211_CMD_GET_SURVEY, nested attribute
+ *      containing info as possible, see &enum survey_info.
+ *
+ * @NL80211_ATTR_PMKID: PMK material for PMKSA caching.
+ * @NL80211_ATTR_MAX_NUM_PMKIDS: maximum number of PMKIDs a firmware can
+ *	cache, a wiphy attribute.
+ *
+ * @NL80211_ATTR_DURATION: Duration of an operation in milliseconds, u32.
+ * @NL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION: Device attribute that
+ *	specifies the maximum duration that can be requested with the
+ *	remain-on-channel operation, in milliseconds, u32.
+ *
+ * @NL80211_ATTR_COOKIE: Generic 64-bit cookie to identify objects.
+ *
+ * @NL80211_ATTR_TX_RATES: Nested set of attributes
+ *	(enum nl80211_tx_rate_attributes) describing TX rates per band. The
+ *	enum nl80211_band value is used as the index (nla_type() of the nested
+ *	data. If a band is not included, it will be configured to allow all
+ *	rates based on negotiated supported rates information. This attribute
+ *	is used with %NL80211_CMD_SET_TX_BITRATE_MASK and with starting AP,
+ *	and joining mesh networks (not IBSS yet). In the later case, it must
+ *	specify just a single bitrate, which is to be used for the beacon.
+ *	The driver must also specify support for this with the extended
+ *	features NL80211_EXT_FEATURE_BEACON_RATE_LEGACY,
+ *	NL80211_EXT_FEATURE_BEACON_RATE_HT and
+ *	NL80211_EXT_FEATURE_BEACON_RATE_VHT.
+ *
+ * @NL80211_ATTR_FRAME_MATCH: A binary attribute which typically must contain
+ *	at least one byte, currently used with @NL80211_CMD_REGISTER_FRAME.
+ * @NL80211_ATTR_FRAME_TYPE: A u16 indicating the frame type/subtype for the
+ *	@NL80211_CMD_REGISTER_FRAME command.
+ * @NL80211_ATTR_TX_FRAME_TYPES: wiphy capability attribute, which is a
+ *	nested attribute of %NL80211_ATTR_FRAME_TYPE attributes, containing
+ *	information about which frame types can be transmitted with
+ *	%NL80211_CMD_FRAME.
+ * @NL80211_ATTR_RX_FRAME_TYPES: wiphy capability attribute, which is a
+ *	nested attribute of %NL80211_ATTR_FRAME_TYPE attributes, containing
+ *	information about which frame types can be registered for RX.
+ *
+ * @NL80211_ATTR_ACK: Flag attribute indicating that the frame was
+ *	acknowledged by the recipient.
+ *
+ * @NL80211_ATTR_PS_STATE: powersave state, using &enum nl80211_ps_state values.
+ *
+ * @NL80211_ATTR_CQM: connection quality monitor configuration in a
+ *	nested attribute with %NL80211_ATTR_CQM_* sub-attributes.
+ *
+ * @NL80211_ATTR_LOCAL_STATE_CHANGE: Flag attribute to indicate that a command
+ *	is requesting a local authentication/association state change without
+ *	invoking actual management frame exchange. This can be used with
+ *	NL80211_CMD_AUTHENTICATE, NL80211_CMD_DEAUTHENTICATE,
+ *	NL80211_CMD_DISASSOCIATE.
+ *
+ * @NL80211_ATTR_AP_ISOLATE: (AP mode) Do not forward traffic between stations
+ *	connected to this BSS.
+ *
+ * @NL80211_ATTR_WIPHY_TX_POWER_SETTING: Transmit power setting type. See
+ *      &enum nl80211_tx_power_setting for possible values.
+ * @NL80211_ATTR_WIPHY_TX_POWER_LEVEL: Transmit power level in signed mBm units.
+ *      This is used in association with @NL80211_ATTR_WIPHY_TX_POWER_SETTING
+ *      for non-automatic settings.
+ *
+ * @NL80211_ATTR_SUPPORT_IBSS_RSN: The device supports IBSS RSN, which mostly
+ *	means support for per-station GTKs.
+ *
+ * @NL80211_ATTR_WIPHY_ANTENNA_TX: Bitmap of allowed antennas for transmitting.
+ *	This can be used to mask out antennas which are not attached or should
+ *	not be used for transmitting. If an antenna is not selected in this
+ *	bitmap the hardware is not allowed to transmit on this antenna.
+ *
+ *	Each bit represents one antenna, starting with antenna 1 at the first
+ *	bit. Depending on which antennas are selected in the bitmap, 802.11n
+ *	drivers can derive which chainmasks to use (if all antennas belonging to
+ *	a particular chain are disabled this chain should be disabled) and if
+ *	a chain has diversity antennas wether diversity should be used or not.
+ *	HT capabilities (STBC, TX Beamforming, Antenna selection) can be
+ *	derived from the available chains after applying the antenna mask.
+ *	Non-802.11n drivers can derive wether to use diversity or not.
+ *	Drivers may reject configurations or RX/TX mask combinations they cannot
+ *	support by returning -EINVAL.
+ *
+ * @NL80211_ATTR_WIPHY_ANTENNA_RX: Bitmap of allowed antennas for receiving.
+ *	This can be used to mask out antennas which are not attached or should
+ *	not be used for receiving. If an antenna is not selected in this bitmap
+ *	the hardware should not be configured to receive on this antenna.
+ *	For a more detailed description see @NL80211_ATTR_WIPHY_ANTENNA_TX.
+ *
+ * @NL80211_ATTR_WIPHY_ANTENNA_AVAIL_TX: Bitmap of antennas which are available
+ *	for configuration as TX antennas via the above parameters.
+ *
+ * @NL80211_ATTR_WIPHY_ANTENNA_AVAIL_RX: Bitmap of antennas which are available
+ *	for configuration as RX antennas via the above parameters.
+ *
+ * @NL80211_ATTR_MCAST_RATE: Multicast tx rate (in 100 kbps) for IBSS
+ *
+ * @NL80211_ATTR_OFFCHANNEL_TX_OK: For management frame TX, the frame may be
+ *	transmitted on another channel when the channel given doesn't match
+ *	the current channel. If the current channel doesn't match and this
+ *	flag isn't set, the frame will be rejected. This is also used as an
+ *	nl80211 capability flag.
+ *
+ * @NL80211_ATTR_BSS_HT_OPMODE: HT operation mode (u16)
+ *
+ * @NL80211_ATTR_KEY_DEFAULT_TYPES: A nested attribute containing flags
+ *	attributes, specifying what a key should be set as default as.
+ *	See &enum nl80211_key_default_types.
+ *
+ * @NL80211_ATTR_MESH_SETUP: Optional mesh setup parameters.  These cannot be
+ *	changed once the mesh is active.
+ * @NL80211_ATTR_MESH_CONFIG: Mesh configuration parameters, a nested attribute
+ *	containing attributes from &enum nl80211_meshconf_params.
+ * @NL80211_ATTR_SUPPORT_MESH_AUTH: Currently, this means the underlying driver
+ *	allows auth frames in a mesh to be passed to userspace for processing via
+ *	the @NL80211_MESH_SETUP_USERSPACE_AUTH flag.
+ * @NL80211_ATTR_STA_PLINK_STATE: The state of a mesh peer link as defined in
+ *	&enum nl80211_plink_state. Used when userspace is driving the peer link
+ *	management state machine.  @NL80211_MESH_SETUP_USERSPACE_AMPE or
+ *	@NL80211_MESH_SETUP_USERSPACE_MPM must be enabled.
+ *
+ * @NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED: indicates, as part of the wiphy
+ *	capabilities, the supported WoWLAN triggers
+ * @NL80211_ATTR_WOWLAN_TRIGGERS: used by %NL80211_CMD_SET_WOWLAN to
+ *	indicate which WoW triggers should be enabled. This is also
+ *	used by %NL80211_CMD_GET_WOWLAN to get the currently enabled WoWLAN
+ *	triggers.
+ *
+ * @NL80211_ATTR_SCHED_SCAN_INTERVAL: Interval between scheduled scan
+ *	cycles, in msecs.
+ *
+ * @NL80211_ATTR_SCHED_SCAN_MATCH: Nested attribute with one or more
+ *	sets of attributes to match during scheduled scans.  Only BSSs
+ *	that match any of the sets will be reported.  These are
+ *	pass-thru filter rules.
+ *	For a match to succeed, the BSS must match all attributes of a
+ *	set.  Since not every hardware supports matching all types of
+ *	attributes, there is no guarantee that the reported BSSs are
+ *	fully complying with the match sets and userspace needs to be
+ *	able to ignore them by itself.
+ *	Thus, the implementation is somewhat hardware-dependent, but
+ *	this is only an optimization and the userspace application
+ *	needs to handle all the non-filtered results anyway.
+ *	If the match attributes don't make sense when combined with
+ *	the values passed in @NL80211_ATTR_SCAN_SSIDS (eg. if an SSID
+ *	is included in the probe request, but the match attributes
+ *	will never let it go through), -EINVAL may be returned.
+ *	If omitted, no filtering is done.
+ *
+ * @NL80211_ATTR_INTERFACE_COMBINATIONS: Nested attribute listing the supported
+ *	interface combinations. In each nested item, it contains attributes
+ *	defined in &enum nl80211_if_combination_attrs.
+ * @NL80211_ATTR_SOFTWARE_IFTYPES: Nested attribute (just like
+ *	%NL80211_ATTR_SUPPORTED_IFTYPES) containing the interface types that
+ *	are managed in software: interfaces of these types aren't subject to
+ *	any restrictions in their number or combinations.
+ *
+ * @NL80211_ATTR_REKEY_DATA: nested attribute containing the information
+ *	necessary for GTK rekeying in the device, see &enum nl80211_rekey_data.
+ *
+ * @NL80211_ATTR_SCAN_SUPP_RATES: rates per to be advertised as supported in scan,
+ *	nested array attribute containing an entry for each band, with the entry
+ *	being a list of supported rates as defined by IEEE 802.11 7.3.2.2 but
+ *	without the length restriction (at most %NL80211_MAX_SUPP_RATES).
+ *
+ * @NL80211_ATTR_HIDDEN_SSID: indicates whether SSID is to be hidden from Beacon
+ *	and Probe Response (when response to wildcard Probe Request); see
+ *	&enum nl80211_hidden_ssid, represented as a u32
+ *
+ * @NL80211_ATTR_IE_PROBE_RESP: Information element(s) for Probe Response frame.
+ *	This is used with %NL80211_CMD_NEW_BEACON and %NL80211_CMD_SET_BEACON to
+ *	provide extra IEs (e.g., WPS/P2P IE) into Probe Response frames when the
+ *	driver (or firmware) replies to Probe Request frames.
+ * @NL80211_ATTR_IE_ASSOC_RESP: Information element(s) for (Re)Association
+ *	Response frames. This is used with %NL80211_CMD_NEW_BEACON and
+ *	%NL80211_CMD_SET_BEACON to provide extra IEs (e.g., WPS/P2P IE) into
+ *	(Re)Association Response frames when the driver (or firmware) replies to
+ *	(Re)Association Request frames.
+ *
+ * @NL80211_ATTR_STA_WME: Nested attribute containing the wme configuration
+ *	of the station, see &enum nl80211_sta_wme_attr.
+ * @NL80211_ATTR_SUPPORT_AP_UAPSD: the device supports uapsd when working
+ *	as AP.
+ *
+ * @NL80211_ATTR_ROAM_SUPPORT: Indicates whether the firmware is capable of
+ *	roaming to another AP in the same ESS if the signal lever is low.
+ *
+ * @NL80211_ATTR_PMKSA_CANDIDATE: Nested attribute containing the PMKSA caching
+ *	candidate information, see &enum nl80211_pmksa_candidate_attr.
+ *
+ * @NL80211_ATTR_TX_NO_CCK_RATE: Indicates whether to use CCK rate or not
+ *	for management frames transmission. In order to avoid p2p probe/action
+ *	frames are being transmitted at CCK rate in 2GHz band, the user space
+ *	applications use this attribute.
+ *	This attribute is used with %NL80211_CMD_TRIGGER_SCAN and
+ *	%NL80211_CMD_FRAME commands.
+ *
+ * @NL80211_ATTR_TDLS_ACTION: Low level TDLS action code (e.g. link setup
+ *	request, link setup confirm, link teardown, etc.). Values are
+ *	described in the TDLS (802.11z) specification.
+ * @NL80211_ATTR_TDLS_DIALOG_TOKEN: Non-zero token for uniquely identifying a
+ *	TDLS conversation between two devices.
+ * @NL80211_ATTR_TDLS_OPERATION: High level TDLS operation; see
+ *	&enum nl80211_tdls_operation, represented as a u8.
+ * @NL80211_ATTR_TDLS_SUPPORT: A flag indicating the device can operate
+ *	as a TDLS peer sta.
+ * @NL80211_ATTR_TDLS_EXTERNAL_SETUP: The TDLS discovery/setup and teardown
+ *	procedures should be performed by sending TDLS packets via
+ *	%NL80211_CMD_TDLS_MGMT. Otherwise %NL80211_CMD_TDLS_OPER should be
+ *	used for asking the driver to perform a TDLS operation.
+ *
+ * @NL80211_ATTR_DEVICE_AP_SME: This u32 attribute may be listed for devices
+ *	that have AP support to indicate that they have the AP SME integrated
+ *	with support for the features listed in this attribute, see
+ *	&enum nl80211_ap_sme_features.
+ *
+ * @NL80211_ATTR_DONT_WAIT_FOR_ACK: Used with %NL80211_CMD_FRAME, this tells
+ *	the driver to not wait for an acknowledgement. Note that due to this,
+ *	it will also not give a status callback nor return a cookie. This is
+ *	mostly useful for probe responses to save airtime.
+ *
+ * @NL80211_ATTR_FEATURE_FLAGS: This u32 attribute contains flags from
+ *	&enum nl80211_feature_flags and is advertised in wiphy information.
+ * @NL80211_ATTR_PROBE_RESP_OFFLOAD: Indicates that the HW responds to probe
+ *	requests while operating in AP-mode.
+ *	This attribute holds a bitmap of the supported protocols for
+ *	offloading (see &enum nl80211_probe_resp_offload_support_attr).
+ *
+ * @NL80211_ATTR_PROBE_RESP: Probe Response template data. Contains the entire
+ *	probe-response frame. The DA field in the 802.11 header is zero-ed out,
+ *	to be filled by the FW.
+ * @NL80211_ATTR_DISABLE_HT:  Force HT capable interfaces to disable
+ *      this feature.  Currently, only supported in mac80211 drivers.
+ * @NL80211_ATTR_HT_CAPABILITY_MASK: Specify which bits of the
+ *      ATTR_HT_CAPABILITY to which attention should be paid.
+ *      Currently, only mac80211 NICs support this feature.
+ *      The values that may be configured are:
+ *       MCS rates, MAX-AMSDU, HT-20-40 and HT_CAP_SGI_40
+ *       AMPDU density and AMPDU factor.
+ *      All values are treated as suggestions and may be ignored
+ *      by the driver as required.  The actual values may be seen in
+ *      the station debugfs ht_caps file.
+ *
+ * @NL80211_ATTR_DFS_REGION: region for regulatory rules which this country
+ *    abides to when initiating radiation on DFS channels. A country maps
+ *    to one DFS region.
+ *
+ * @NL80211_ATTR_NOACK_MAP: This u16 bitmap contains the No Ack Policy of
+ *      up to 16 TIDs.
+ *
+ * @NL80211_ATTR_INACTIVITY_TIMEOUT: timeout value in seconds, this can be
+ *	used by the drivers which has MLME in firmware and does not have support
+ *	to report per station tx/rx activity to free up the station entry from
+ *	the list. This needs to be used when the driver advertises the
+ *	capability to timeout the stations.
+ *
+ * @NL80211_ATTR_RX_SIGNAL_DBM: signal strength in dBm (as a 32-bit int);
+ *	this attribute is (depending on the driver capabilities) added to
+ *	received frames indicated with %NL80211_CMD_FRAME.
+ *
+ * @NL80211_ATTR_BG_SCAN_PERIOD: Background scan period in seconds
+ *      or 0 to disable background scan.
+ *
+ * @NL80211_ATTR_USER_REG_HINT_TYPE: type of regulatory hint passed from
+ *	userspace. If unset it is assumed the hint comes directly from
+ *	a user. If set code could specify exactly what type of source
+ *	was used to provide the hint. For the different types of
+ *	allowed user regulatory hints see nl80211_user_reg_hint_type.
+ *
+ * @NL80211_ATTR_CONN_FAILED_REASON: The reason for which AP has rejected
+ *	the connection request from a station. nl80211_connect_failed_reason
+ *	enum has different reasons of connection failure.
+ *
+ * @NL80211_ATTR_AUTH_DATA: Fields and elements in Authentication frames.
+ *	This contains the authentication frame body (non-IE and IE data),
+ *	excluding the Authentication algorithm number, i.e., starting at the
+ *	Authentication transaction sequence number field. It is used with
+ *	authentication algorithms that need special fields to be added into
+ *	the frames (SAE and FILS). Currently, only the SAE cases use the
+ *	initial two fields (Authentication transaction sequence number and
+ *	Status code). However, those fields are included in the attribute data
+ *	for all authentication algorithms to keep the attribute definition
+ *	consistent.
+ *
+ * @NL80211_ATTR_VHT_CAPABILITY: VHT Capability information element (from
+ *	association request when used with NL80211_CMD_NEW_STATION)
+ *
+ * @NL80211_ATTR_SCAN_FLAGS: scan request control flags (u32)
+ *
+ * @NL80211_ATTR_P2P_CTWINDOW: P2P GO Client Traffic Window (u8), used with
+ *	the START_AP and SET_BSS commands
+ * @NL80211_ATTR_P2P_OPPPS: P2P GO opportunistic PS (u8), used with the
+ *	START_AP and SET_BSS commands. This can have the values 0 or 1;
+ *	if not given in START_AP 0 is assumed, if not given in SET_BSS
+ *	no change is made.
+ *
+ * @NL80211_ATTR_LOCAL_MESH_POWER_MODE: local mesh STA link-specific power mode
+ *	defined in &enum nl80211_mesh_power_mode.
+ *
+ * @NL80211_ATTR_ACL_POLICY: ACL policy, see &enum nl80211_acl_policy,
+ *	carried in a u32 attribute
+ *
+ * @NL80211_ATTR_MAC_ADDRS: Array of nested MAC addresses, used for
+ *	MAC ACL.
+ *
+ * @NL80211_ATTR_MAC_ACL_MAX: u32 attribute to advertise the maximum
+ *	number of MAC addresses that a device can support for MAC
+ *	ACL.
+ *
+ * @NL80211_ATTR_RADAR_EVENT: Type of radar event for notification to userspace,
+ *	contains a value of enum nl80211_radar_event (u32).
+ *
+ * @NL80211_ATTR_EXT_CAPA: 802.11 extended capabilities that the kernel driver
+ *	has and handles. The format is the same as the IE contents. See
+ *	802.11-2012 8.4.2.29 for more information.
+ * @NL80211_ATTR_EXT_CAPA_MASK: Extended capabilities that the kernel driver
+ *	has set in the %NL80211_ATTR_EXT_CAPA value, for multibit fields.
+ *
+ * @NL80211_ATTR_STA_CAPABILITY: Station capabilities (u16) are advertised to
+ *	the driver, e.g., to enable TDLS power save (PU-APSD).
+ *
+ * @NL80211_ATTR_STA_EXT_CAPABILITY: Station extended capabilities are
+ *	advertised to the driver, e.g., to enable TDLS off channel operations
+ *	and PU-APSD.
+ *
+ * @NL80211_ATTR_PROTOCOL_FEATURES: global nl80211 feature flags, see
+ *	&enum nl80211_protocol_features, the attribute is a u32.
+ *
+ * @NL80211_ATTR_SPLIT_WIPHY_DUMP: flag attribute, userspace supports
+ *	receiving the data for a single wiphy split across multiple
+ *	messages, given with wiphy dump message
+ *
+ * @NL80211_ATTR_MDID: Mobility Domain Identifier
+ *
+ * @NL80211_ATTR_IE_RIC: Resource Information Container Information
+ *	Element
+ *
+ * @NL80211_ATTR_CRIT_PROT_ID: critical protocol identifier requiring increased
+ *	reliability, see &enum nl80211_crit_proto_id (u16).
+ * @NL80211_ATTR_MAX_CRIT_PROT_DURATION: duration in milliseconds in which
+ *      the connection should have increased reliability (u16).
+ *
+ * @NL80211_ATTR_PEER_AID: Association ID for the peer TDLS station (u16).
+ *	This is similar to @NL80211_ATTR_STA_AID but with a difference of being
+ *	allowed to be used with the first @NL80211_CMD_SET_STATION command to
+ *	update a TDLS peer STA entry.
+ *
+ * @NL80211_ATTR_COALESCE_RULE: Coalesce rule information.
+ *
+ * @NL80211_ATTR_CH_SWITCH_COUNT: u32 attribute specifying the number of TBTT's
+ *	until the channel switch event.
+ * @NL80211_ATTR_CH_SWITCH_BLOCK_TX: flag attribute specifying that transmission
+ *	must be blocked on the current channel (before the channel switch
+ *	operation).
+ * @NL80211_ATTR_CSA_IES: Nested set of attributes containing the IE information
+ *	for the time while performing a channel switch.
+ * @NL80211_ATTR_CSA_C_OFF_BEACON: An array of offsets (u16) to the channel
+ *	switch counters in the beacons tail (%NL80211_ATTR_BEACON_TAIL).
+ * @NL80211_ATTR_CSA_C_OFF_PRESP: An array of offsets (u16) to the channel
+ *	switch counters in the probe response (%NL80211_ATTR_PROBE_RESP).
+ *
+ * @NL80211_ATTR_RXMGMT_FLAGS: flags for nl80211_send_mgmt(), u32.
+ *	As specified in the &enum nl80211_rxmgmt_flags.
+ *
+ * @NL80211_ATTR_STA_SUPPORTED_CHANNELS: array of supported channels.
+ *
+ * @NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES: array of supported
+ *      supported operating classes.
+ *
+ * @NL80211_ATTR_HANDLE_DFS: A flag indicating whether user space
+ *	controls DFS operation in IBSS mode. If the flag is included in
+ *	%NL80211_CMD_JOIN_IBSS request, the driver will allow use of DFS
+ *	channels and reports radar events to userspace. Userspace is required
+ *	to react to radar events, e.g. initiate a channel switch or leave the
+ *	IBSS network.
+ *
+ * @NL80211_ATTR_SUPPORT_5_MHZ: A flag indicating that the device supports
+ *	5 MHz channel bandwidth.
+ * @NL80211_ATTR_SUPPORT_10_MHZ: A flag indicating that the device supports
+ *	10 MHz channel bandwidth.
+ *
+ * @NL80211_ATTR_OPMODE_NOTIF: Operating mode field from Operating Mode
+ *	Notification Element based on association request when used with
+ *	%NL80211_CMD_NEW_STATION or %NL80211_CMD_SET_STATION (only when
+ *	%NL80211_FEATURE_FULL_AP_CLIENT_STATE is supported, or with TDLS);
+ *	u8 attribute.
+ *
+ * @NL80211_ATTR_VENDOR_ID: The vendor ID, either a 24-bit OUI or, if
+ *	%NL80211_VENDOR_ID_IS_LINUX is set, a special Linux ID (not used yet)
+ * @NL80211_ATTR_VENDOR_SUBCMD: vendor sub-command
+ * @NL80211_ATTR_VENDOR_DATA: data for the vendor command, if any; this
+ *	attribute is also used for vendor command feature advertisement
+ * @NL80211_ATTR_VENDOR_EVENTS: used for event list advertising in the wiphy
+ *	info, containing a nested array of possible events
+ *
+ * @NL80211_ATTR_QOS_MAP: IP DSCP mapping for Interworking QoS mapping. This
+ *	data is in the format defined for the payload of the QoS Map Set element
+ *	in IEEE Std 802.11-2012, 8.4.2.97.
+ *
+ * @NL80211_ATTR_MAC_HINT: MAC address recommendation as initial BSS
+ * @NL80211_ATTR_WIPHY_FREQ_HINT: frequency of the recommended initial BSS
+ *
+ * @NL80211_ATTR_MAX_AP_ASSOC_STA: Device attribute that indicates how many
+ *	associated stations are supported in AP mode (including P2P GO); u32.
+ *	Since drivers may not have a fixed limit on the maximum number (e.g.,
+ *	other concurrent operations may affect this), drivers are allowed to
+ *	advertise values that cannot always be met. In such cases, an attempt
+ *	to add a new station entry with @NL80211_CMD_NEW_STATION may fail.
+ *
+ * @NL80211_ATTR_CSA_C_OFFSETS_TX: An array of csa counter offsets (u16) which
+ *	should be updated when the frame is transmitted.
+ * @NL80211_ATTR_MAX_CSA_COUNTERS: U8 attribute used to advertise the maximum
+ *	supported number of csa counters.
+ *
+ * @NL80211_ATTR_TDLS_PEER_CAPABILITY: flags for TDLS peer capabilities, u32.
+ *	As specified in the &enum nl80211_tdls_peer_capability.
+ *
+ * @NL80211_ATTR_SOCKET_OWNER: Flag attribute, if set during interface
+ *	creation then the new interface will be owned by the netlink socket
+ *	that created it and will be destroyed when the socket is closed.
+ *	If set during scheduled scan start then the new scan req will be
+ *	owned by the netlink socket that created it and the scheduled scan will
+ *	be stopped when the socket is closed.
+ *	If set during configuration of regulatory indoor operation then the
+ *	regulatory indoor configuration would be owned by the netlink socket
+ *	that configured the indoor setting, and the indoor operation would be
+ *	cleared when the socket is closed.
+ *	If set during NAN interface creation, the interface will be destroyed
+ *	if the socket is closed just like any other interface. Moreover, NAN
+ *	notifications will be sent in unicast to that socket. Without this
+ *	attribute, the notifications will be sent to the %NL80211_MCGRP_NAN
+ *	multicast group.
+ *	If set during %NL80211_CMD_ASSOCIATE or %NL80211_CMD_CONNECT the
+ *	station will deauthenticate when the socket is closed.
+ *	If set during %NL80211_CMD_JOIN_IBSS the IBSS will be automatically
+ *	torn down when the socket is closed.
+ *	If set during %NL80211_CMD_JOIN_MESH the mesh setup will be
+ *	automatically torn down when the socket is closed.
+ *	If set during %NL80211_CMD_START_AP the AP will be automatically
+ *	disabled when the socket is closed.
+ *
+ * @NL80211_ATTR_TDLS_INITIATOR: flag attribute indicating the current end is
+ *	the TDLS link initiator.
+ *
+ * @NL80211_ATTR_USE_RRM: flag for indicating whether the current connection
+ *	shall support Radio Resource Measurements (11k). This attribute can be
+ *	used with %NL80211_CMD_ASSOCIATE and %NL80211_CMD_CONNECT requests.
+ *	User space applications are expected to use this flag only if the
+ *	underlying device supports these minimal RRM features:
+ *		%NL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES,
+ *		%NL80211_FEATURE_QUIET,
+ *	Or, if global RRM is supported, see:
+ *		%NL80211_EXT_FEATURE_RRM
+ *	If this flag is used, driver must add the Power Capabilities IE to the
+ *	association request. In addition, it must also set the RRM capability
+ *	flag in the association request's Capability Info field.
+ *
+ * @NL80211_ATTR_WIPHY_DYN_ACK: flag attribute used to enable ACK timeout
+ *	estimation algorithm (dynack). In order to activate dynack
+ *	%NL80211_FEATURE_ACKTO_ESTIMATION feature flag must be set by lower
+ *	drivers to indicate dynack capability. Dynack is automatically disabled
+ *	setting valid value for coverage class.
+ *
+ * @NL80211_ATTR_TSID: a TSID value (u8 attribute)
+ * @NL80211_ATTR_USER_PRIO: user priority value (u8 attribute)
+ * @NL80211_ATTR_ADMITTED_TIME: admitted time in units of 32 microseconds
+ *	(per second) (u16 attribute)
+ *
+ * @NL80211_ATTR_SMPS_MODE: SMPS mode to use (ap mode). see
+ *	&enum nl80211_smps_mode.
+ *
+ * @NL80211_ATTR_OPER_CLASS: operating class
+ *
+ * @NL80211_ATTR_MAC_MASK: MAC address mask
+ *
+ * @NL80211_ATTR_WIPHY_SELF_MANAGED_REG: flag attribute indicating this device
+ *	is self-managing its regulatory information and any regulatory domain
+ *	obtained from it is coming from the device's wiphy and not the global
+ *	cfg80211 regdomain.
+ *
+ * @NL80211_ATTR_EXT_FEATURES: extended feature flags contained in a byte
+ *	array. The feature flags are identified by their bit index (see &enum
+ *	nl80211_ext_feature_index). The bit index is ordered starting at the
+ *	least-significant bit of the first byte in the array, ie. bit index 0
+ *	is located at bit 0 of byte 0. bit index 25 would be located at bit 1
+ *	of byte 3 (u8 array).
+ *
+ * @NL80211_ATTR_SURVEY_RADIO_STATS: Request overall radio statistics to be
+ *	returned along with other survey data. If set, @NL80211_CMD_GET_SURVEY
+ *	may return a survey entry without a channel indicating global radio
+ *	statistics (only some values are valid and make sense.)
+ *	For devices that don't return such an entry even then, the information
+ *	should be contained in the result as the sum of the respective counters
+ *	over all channels.
+ *
+ * @NL80211_ATTR_SCHED_SCAN_DELAY: delay before the first cycle of a
+ *	scheduled scan is started.  Or the delay before a WoWLAN
+ *	net-detect scan is started, counting from the moment the
+ *	system is suspended.  This value is a u32, in seconds.
+
+ * @NL80211_ATTR_REG_INDOOR: flag attribute, if set indicates that the device
+ *      is operating in an indoor environment.
+ *
+ * @NL80211_ATTR_MAX_NUM_SCHED_SCAN_PLANS: maximum number of scan plans for
+ *	scheduled scan supported by the device (u32), a wiphy attribute.
+ * @NL80211_ATTR_MAX_SCAN_PLAN_INTERVAL: maximum interval (in seconds) for
+ *	a scan plan (u32), a wiphy attribute.
+ * @NL80211_ATTR_MAX_SCAN_PLAN_ITERATIONS: maximum number of iterations in
+ *	a scan plan (u32), a wiphy attribute.
+ * @NL80211_ATTR_SCHED_SCAN_PLANS: a list of scan plans for scheduled scan.
+ *	Each scan plan defines the number of scan iterations and the interval
+ *	between scans. The last scan plan will always run infinitely,
+ *	thus it must not specify the number of iterations, only the interval
+ *	between scans. The scan plans are executed sequentially.
+ *	Each scan plan is a nested attribute of &enum nl80211_sched_scan_plan.
+ * @NL80211_ATTR_PBSS: flag attribute. If set it means operate
+ *	in a PBSS. Specified in %NL80211_CMD_CONNECT to request
+ *	connecting to a PCP, and in %NL80211_CMD_START_AP to start
+ *	a PCP instead of AP. Relevant for DMG networks only.
+ * @NL80211_ATTR_BSS_SELECT: nested attribute for driver supporting the
+ *	BSS selection feature. When used with %NL80211_CMD_GET_WIPHY it contains
+ *	attributes according &enum nl80211_bss_select_attr to indicate what
+ *	BSS selection behaviours are supported. When used with %NL80211_CMD_CONNECT
+ *	it contains the behaviour-specific attribute containing the parameters for
+ *	BSS selection to be done by driver and/or firmware.
+ *
+ * @NL80211_ATTR_STA_SUPPORT_P2P_PS: whether P2P PS mechanism supported
+ *	or not. u8, one of the values of &enum nl80211_sta_p2p_ps_status
+ *
+ * @NL80211_ATTR_PAD: attribute used for padding for 64-bit alignment
+ *
+ * @NL80211_ATTR_IFTYPE_EXT_CAPA: Nested attribute of the following attributes:
+ *	%NL80211_ATTR_IFTYPE, %NL80211_ATTR_EXT_CAPA,
+ *	%NL80211_ATTR_EXT_CAPA_MASK, to specify the extended capabilities per
+ *	interface type.
+ *
+ * @NL80211_ATTR_MU_MIMO_GROUP_DATA: array of 24 bytes that defines a MU-MIMO
+ *	groupID for monitor mode.
+ *	The first 8 bytes are a mask that defines the membership in each
+ *	group (there are 64 groups, group 0 and 63 are reserved),
+ *	each bit represents a group and set to 1 for being a member in
+ *	that group and 0 for not being a member.
+ *	The remaining 16 bytes define the position in each group: 2 bits for
+ *	each group.
+ *	(smaller group numbers represented on most significant bits and bigger
+ *	group numbers on least significant bits.)
+ *	This attribute is used only if all interfaces are in monitor mode.
+ *	Set this attribute in order to monitor packets using the given MU-MIMO
+ *	groupID data.
+ *	to turn off that feature set all the bits of the groupID to zero.
+ * @NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR: mac address for the sniffer to follow
+ *	when using MU-MIMO air sniffer.
+ *	to turn that feature off set an invalid mac address
+ *	(e.g. FF:FF:FF:FF:FF:FF)
+ *
+ * @NL80211_ATTR_SCAN_START_TIME_TSF: The time at which the scan was actually
+ *	started (u64). The time is the TSF of the BSS the interface that
+ *	requested the scan is connected to (if available, otherwise this
+ *	attribute must not be included).
+ * @NL80211_ATTR_SCAN_START_TIME_TSF_BSSID: The BSS according to which
+ *	%NL80211_ATTR_SCAN_START_TIME_TSF is set.
+ * @NL80211_ATTR_MEASUREMENT_DURATION: measurement duration in TUs (u16). If
+ *	%NL80211_ATTR_MEASUREMENT_DURATION_MANDATORY is not set, this is the
+ *	maximum measurement duration allowed. This attribute is used with
+ *	measurement requests. It can also be used with %NL80211_CMD_TRIGGER_SCAN
+ *	if the scan is used for beacon report radio measurement.
+ * @NL80211_ATTR_MEASUREMENT_DURATION_MANDATORY: flag attribute that indicates
+ *	that the duration specified with %NL80211_ATTR_MEASUREMENT_DURATION is
+ *	mandatory. If this flag is not set, the duration is the maximum duration
+ *	and the actual measurement duration may be shorter.
+ *
+ * @NL80211_ATTR_MESH_PEER_AID: Association ID for the mesh peer (u16). This is
+ *	used to pull the stored data for mesh peer in power save state.
+ *
+ * @NL80211_ATTR_NAN_MASTER_PREF: the master preference to be used by
+ *	%NL80211_CMD_START_NAN and optionally with
+ *	%NL80211_CMD_CHANGE_NAN_CONFIG. Its type is u8 and it can't be 0.
+ *	Also, values 1 and 255 are reserved for certification purposes and
+ *	should not be used during a normal device operation.
+ * @NL80211_ATTR_BANDS: operating bands configuration.  This is a u32
+ *	bitmask of BIT(NL80211_BAND_*) as described in %enum
+ *	nl80211_band.  For instance, for NL80211_BAND_2GHZ, bit 0
+ *	would be set.  This attribute is used with
+ *	%NL80211_CMD_START_NAN and %NL80211_CMD_CHANGE_NAN_CONFIG, and
+ *	it is optional.  If no bands are set, it means don't-care and
+ *	the device will decide what to use.
+ * @NL80211_ATTR_NAN_FUNC: a function that can be added to NAN. See
+ *	&enum nl80211_nan_func_attributes for description of this nested
+ *	attribute.
+ * @NL80211_ATTR_NAN_MATCH: used to report a match. This is a nested attribute.
+ *	See &enum nl80211_nan_match_attributes.
+ * @NL80211_ATTR_FILS_KEK: KEK for FILS (Re)Association Request/Response frame
+ *	protection.
+ * @NL80211_ATTR_FILS_NONCES: Nonces (part of AAD) for FILS (Re)Association
+ *	Request/Response frame protection. This attribute contains the 16 octet
+ *	STA Nonce followed by 16 octets of AP Nonce.
+ *
+ * @NL80211_ATTR_MULTICAST_TO_UNICAST_ENABLED: Indicates whether or not multicast
+ *	packets should be send out as unicast to all stations (flag attribute).
+ *
+ * @NL80211_ATTR_BSSID: The BSSID of the AP. Note that %NL80211_ATTR_MAC is also
+ *	used in various commands/events for specifying the BSSID.
+ *
+ * @NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI: Relative RSSI threshold by which
+ *	other BSSs has to be better or slightly worse than the current
+ *	connected BSS so that they get reported to user space.
+ *	This will give an opportunity to userspace to consider connecting to
+ *	other matching BSSs which have better or slightly worse RSSI than
+ *	the current connected BSS by using an offloaded operation to avoid
+ *	unnecessary wakeups.
+ *
+ * @NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST: When present the RSSI level for BSSs in
+ *	the specified band is to be adjusted before doing
+ *	%NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI based comparison to figure out
+ *	better BSSs. The attribute value is a packed structure
+ *	value as specified by &struct nl80211_bss_select_rssi_adjust.
+ *
+ * @NL80211_ATTR_TIMEOUT_REASON: The reason for which an operation timed out.
+ *	u32 attribute with an &enum nl80211_timeout_reason value. This is used,
+ *	e.g., with %NL80211_CMD_CONNECT event.
+ *
+ * @NL80211_ATTR_FILS_ERP_USERNAME: EAP Re-authentication Protocol (ERP)
+ *	username part of NAI used to refer keys rRK and rIK. This is used with
+ *	%NL80211_CMD_CONNECT.
+ *
+ * @NL80211_ATTR_FILS_ERP_REALM: EAP Re-authentication Protocol (ERP) realm part
+ *	of NAI specifying the domain name of the ER server. This is used with
+ *	%NL80211_CMD_CONNECT.
+ *
+ * @NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM: Unsigned 16-bit ERP next sequence number
+ *	to use in ERP messages. This is used in generating the FILS wrapped data
+ *	for FILS authentication and is used with %NL80211_CMD_CONNECT.
+ *
+ * @NL80211_ATTR_FILS_ERP_RRK: ERP re-authentication Root Key (rRK) for the
+ *	NAI specified by %NL80211_ATTR_FILS_ERP_USERNAME and
+ *	%NL80211_ATTR_FILS_ERP_REALM. This is used for generating rIK and rMSK
+ *	from successful FILS authentication and is used with
+ *	%NL80211_CMD_CONNECT.
+ *
+ * @NL80211_ATTR_FILS_CACHE_ID: A 2-octet identifier advertized by a FILS AP
+ *	identifying the scope of PMKSAs. This is used with
+ *	@NL80211_CMD_SET_PMKSA and @NL80211_CMD_DEL_PMKSA.
+ *
+ * @NL80211_ATTR_PMK: attribute for passing PMK key material. Used with
+ *	%NL80211_CMD_SET_PMKSA for the PMKSA identified by %NL80211_ATTR_PMKID.
+ *	For %NL80211_CMD_CONNECT it is used to provide PSK for offloading 4-way
+ *	handshake for WPA/WPA2-PSK networks. For 802.1X authentication it is
+ *	used with %NL80211_CMD_SET_PMK. For offloaded FT support this attribute
+ *	specifies the PMK-R0 if NL80211_ATTR_PMKR0_NAME is included as well.
+ *
+ * @NL80211_ATTR_SCHED_SCAN_MULTI: flag attribute which user-space shall use to
+ *	indicate that it supports multiple active scheduled scan requests.
+ * @NL80211_ATTR_SCHED_SCAN_MAX_REQS: indicates maximum number of scheduled
+ *	scan request that may be active for the device (u32).
+ *
+ * @NL80211_ATTR_WANT_1X_4WAY_HS: flag attribute which user-space can include
+ *	in %NL80211_CMD_CONNECT to indicate that for 802.1X authentication it
+ *	wants to use the supported offload of the 4-way handshake.
+ * @NL80211_ATTR_PMKR0_NAME: PMK-R0 Name for offloaded FT.
+ * @NL80211_ATTR_PORT_AUTHORIZED: (reserved)
+ *
+ * @NL80211_ATTR_EXTERNAL_AUTH_ACTION: Identify the requested external
+ *     authentication operation (u32 attribute with an
+ *     &enum nl80211_external_auth_action value). This is used with the
+ *     %NL80211_CMD_EXTERNAL_AUTH request event.
+ * @NL80211_ATTR_EXTERNAL_AUTH_SUPPORT: Flag attribute indicating that the user
+ *	space supports external authentication. This attribute shall be used
+ *	with %NL80211_CMD_CONNECT and %NL80211_CMD_START_AP request. The driver
+ *	may offload authentication processing to user space if this capability
+ *	is indicated in the respective requests from the user space.
+ *
+ * @NL80211_ATTR_NSS: Station's New/updated  RX_NSS value notified using this
+ *	u8 attribute. This is used with %NL80211_CMD_STA_OPMODE_CHANGED.
+ *
+ * @NL80211_ATTR_TXQ_STATS: TXQ statistics (nested attribute, see &enum
+ *      nl80211_txq_stats)
+ * @NL80211_ATTR_TXQ_LIMIT: Total packet limit for the TXQ queues for this phy.
+ *      The smaller of this and the memory limit is enforced.
+ * @NL80211_ATTR_TXQ_MEMORY_LIMIT: Total memory memory limit (in bytes) for the
+ *      TXQ queues for this phy. The smaller of this and the packet limit is
+ *      enforced.
+ * @NL80211_ATTR_TXQ_QUANTUM: TXQ scheduler quantum (bytes). Number of bytes
+ *      a flow is assigned on each round of the DRR scheduler.
+ * @NL80211_ATTR_HE_CAPABILITY: HE Capability information element (from
+ *	association request when used with NL80211_CMD_NEW_STATION). Can be set
+ *	only if %NL80211_STA_FLAG_WME is set.
+ *
+ * @NL80211_ATTR_FTM_RESPONDER: nested attribute which user-space can include
+ *	in %NL80211_CMD_START_AP or %NL80211_CMD_SET_BEACON for fine timing
+ *	measurement (FTM) responder functionality and containing parameters as
+ *	possible, see &enum nl80211_ftm_responder_attr
+ *
+ * @NL80211_ATTR_FTM_RESPONDER_STATS: Nested attribute with FTM responder
+ *	statistics, see &enum nl80211_ftm_responder_stats.
+ *
+ * @NL80211_ATTR_TIMEOUT: Timeout for the given operation in milliseconds (u32),
+ *	if the attribute is not given no timeout is requested. Note that 0 is an
+ *	invalid value.
+ *
+ * @NL80211_ATTR_PEER_MEASUREMENTS: peer measurements request (and result)
+ *	data, uses nested attributes specified in
+ *	&enum nl80211_peer_measurement_attrs.
+ *	This is also used for capability advertisement in the wiphy information,
+ *	with the appropriate sub-attributes.
+ *
+ * @NL80211_ATTR_AIRTIME_WEIGHT: Station's weight when scheduled by the airtime
+ *	scheduler.
+ *
+ * @NL80211_ATTR_STA_TX_POWER_SETTING: Transmit power setting type (u8) for
+ *	station associated with the AP. See &enum nl80211_tx_power_setting for
+ *	possible values.
+ * @NL80211_ATTR_STA_TX_POWER: Transmit power level (s16) in dBm units. This
+ *	allows to set Tx power for a station. If this attribute is not included,
+ *	the default per-interface tx power setting will be overriding. Driver
+ *	should be picking up the lowest tx power, either tx power per-interface
+ *	or per-station.
+ *
+ * @NL80211_ATTR_SAE_PASSWORD: attribute for passing SAE password material. It
+ *	is used with %NL80211_CMD_CONNECT to provide password for offloading
+ *	SAE authentication for WPA3-Personal networks.
+ *
+ * @NL80211_ATTR_TWT_RESPONDER: Enable target wait time responder support.
+ *
+ * @NL80211_ATTR_HE_OBSS_PD: nested attribute for OBSS Packet Detection
+ *	functionality.
+ *
+ * @NL80211_ATTR_WIPHY_EDMG_CHANNELS: bitmap that indicates the 2.16 GHz
+ *	channel(s) that are allowed to be used for EDMG transmissions.
+ *	Defined by IEEE P802.11ay/D4.0 section 9.4.2.251. (u8 attribute)
+ * @NL80211_ATTR_WIPHY_EDMG_BW_CONFIG: Channel BW Configuration subfield encodes
+ *	the allowed channel bandwidth configurations. (u8 attribute)
+ *	Defined by IEEE P802.11ay/D4.0 section 9.4.2.251, Table 13.
+ *
+ * @NL80211_ATTR_VLAN_ID: VLAN ID (1..4094) for the station and VLAN group key
+ *	(u16).
+ *
+ * @NL80211_ATTR_HE_BSS_COLOR: nested attribute for BSS Color Settings.
+ *
+ * @NL80211_ATTR_IFTYPE_AKM_SUITES: nested array attribute, with each entry
+ *	using attributes from &enum nl80211_iftype_akm_attributes. This
+ *	attribute is sent in a response to %NL80211_CMD_GET_WIPHY indicating
+ *	supported AKM suites capability per interface. AKMs advertised in
+ *	%NL80211_ATTR_AKM_SUITES are default capabilities if AKM suites not
+ *	advertised for a specific interface type.
+ *
+ * @NL80211_ATTR_TID_CONFIG: TID specific configuration in a
+ *	nested attribute with &enum nl80211_tid_config_attr sub-attributes;
+ *	on output (in wiphy attributes) it contains only the feature sub-
+ *	attributes.
+ *
+ * @NL80211_ATTR_CONTROL_PORT_NO_PREAUTH: disable preauth frame rx on control
+ *	port in order to forward/receive them as ordinary data frames.
+ *
+ * @NL80211_ATTR_PMK_LIFETIME: Maximum lifetime for PMKSA in seconds (u32,
+ *	dot11RSNAConfigPMKReauthThreshold; 0 is not a valid value).
+ *	An optional parameter configured through %NL80211_CMD_SET_PMKSA.
+ *	Drivers that trigger roaming need to know the lifetime of the
+ *	configured PMKSA for triggering the full vs. PMKSA caching based
+ *	authentication. This timeout helps authentication methods like SAE,
+ *	where PMK gets updated only by going through a full (new SAE)
+ *	authentication instead of getting updated during an association for EAP
+ *	authentication. No new full authentication within the PMK expiry shall
+ *	result in a disassociation at the end of the lifetime.
+ *
+ * @NL80211_ATTR_PMK_REAUTH_THRESHOLD: Reauthentication threshold time, in
+ *	terms of percentage of %NL80211_ATTR_PMK_LIFETIME
+ *	(u8, dot11RSNAConfigPMKReauthThreshold, 1..100). This is an optional
+ *	parameter configured through %NL80211_CMD_SET_PMKSA. Requests the
+ *	driver to trigger a full authentication roam (without PMKSA caching)
+ *	after the reauthentication threshold time, but before the PMK lifetime
+ *	has expired.
+ *
+ *	Authentication methods like SAE need to be able to generate a new PMKSA
+ *	entry without having to force a disconnection after the PMK timeout. If
+ *	no roaming occurs between the reauth threshold and PMK expiration,
+ *	disassociation is still forced.
+ *
+ * @NL80211_ATTR_HE_6GHZ_CAPABILITY: HE 6 GHz Band Capability element (from
+ *	association request when used with NL80211_CMD_NEW_STATION).
+ *
+ * @NUM_NL80211_ATTR: total number of nl80211_attrs available
+ * @NL80211_ATTR_MAX: highest attribute number currently defined
+ * @__NL80211_ATTR_AFTER_LAST: internal use
+ */
+enum nl80211_attrs {
+/* don't change the order or add anything between, this is ABI! */
+	NL80211_ATTR_UNSPEC,
+
+	NL80211_ATTR_WIPHY,
+	NL80211_ATTR_WIPHY_NAME,
+
+	NL80211_ATTR_IFINDEX,
+	NL80211_ATTR_IFNAME,
+	NL80211_ATTR_IFTYPE,
+
+	NL80211_ATTR_MAC,
+
+	NL80211_ATTR_KEY_DATA,
+	NL80211_ATTR_KEY_IDX,
+	NL80211_ATTR_KEY_CIPHER,
+	NL80211_ATTR_KEY_SEQ,
+	NL80211_ATTR_KEY_DEFAULT,
+
+	NL80211_ATTR_BEACON_INTERVAL,
+	NL80211_ATTR_DTIM_PERIOD,
+	NL80211_ATTR_BEACON_HEAD,
+	NL80211_ATTR_BEACON_TAIL,
+
+	NL80211_ATTR_STA_AID,
+	NL80211_ATTR_STA_FLAGS,
+	NL80211_ATTR_STA_LISTEN_INTERVAL,
+	NL80211_ATTR_STA_SUPPORTED_RATES,
+	NL80211_ATTR_STA_VLAN,
+	NL80211_ATTR_STA_INFO,
+
+	NL80211_ATTR_WIPHY_BANDS,
+
+	NL80211_ATTR_MNTR_FLAGS,
+
+	NL80211_ATTR_MESH_ID,
+	NL80211_ATTR_STA_PLINK_ACTION,
+	NL80211_ATTR_MPATH_NEXT_HOP,
+	NL80211_ATTR_MPATH_INFO,
+
+	NL80211_ATTR_BSS_CTS_PROT,
+	NL80211_ATTR_BSS_SHORT_PREAMBLE,
+	NL80211_ATTR_BSS_SHORT_SLOT_TIME,
+
+	NL80211_ATTR_HT_CAPABILITY,
+
+	NL80211_ATTR_SUPPORTED_IFTYPES,
+
+	NL80211_ATTR_REG_ALPHA2,
+	NL80211_ATTR_REG_RULES,
+
+	NL80211_ATTR_MESH_CONFIG,
+
+	NL80211_ATTR_BSS_BASIC_RATES,
+
+	NL80211_ATTR_WIPHY_TXQ_PARAMS,
+	NL80211_ATTR_WIPHY_FREQ,
+	NL80211_ATTR_WIPHY_CHANNEL_TYPE,
+
+	NL80211_ATTR_KEY_DEFAULT_MGMT,
+
+	NL80211_ATTR_MGMT_SUBTYPE,
+	NL80211_ATTR_IE,
+
+	NL80211_ATTR_MAX_NUM_SCAN_SSIDS,
+
+	NL80211_ATTR_SCAN_FREQUENCIES,
+	NL80211_ATTR_SCAN_SSIDS,
+	NL80211_ATTR_GENERATION, /* replaces old SCAN_GENERATION */
+	NL80211_ATTR_BSS,
+
+	NL80211_ATTR_REG_INITIATOR,
+	NL80211_ATTR_REG_TYPE,
+
+	NL80211_ATTR_SUPPORTED_COMMANDS,
+
+	NL80211_ATTR_FRAME,
+	NL80211_ATTR_SSID,
+	NL80211_ATTR_AUTH_TYPE,
+	NL80211_ATTR_REASON_CODE,
+
+	NL80211_ATTR_KEY_TYPE,
+
+	NL80211_ATTR_MAX_SCAN_IE_LEN,
+	NL80211_ATTR_CIPHER_SUITES,
+
+	NL80211_ATTR_FREQ_BEFORE,
+	NL80211_ATTR_FREQ_AFTER,
+
+	NL80211_ATTR_FREQ_FIXED,
+
+
+	NL80211_ATTR_WIPHY_RETRY_SHORT,
+	NL80211_ATTR_WIPHY_RETRY_LONG,
+	NL80211_ATTR_WIPHY_FRAG_THRESHOLD,
+	NL80211_ATTR_WIPHY_RTS_THRESHOLD,
+
+	NL80211_ATTR_TIMED_OUT,
+
+	NL80211_ATTR_USE_MFP,
+
+	NL80211_ATTR_STA_FLAGS2,
+
+	NL80211_ATTR_CONTROL_PORT,
+
+	NL80211_ATTR_TESTDATA,
+
+	NL80211_ATTR_PRIVACY,
+
+	NL80211_ATTR_DISCONNECTED_BY_AP,
+	NL80211_ATTR_STATUS_CODE,
+
+	NL80211_ATTR_CIPHER_SUITES_PAIRWISE,
+	NL80211_ATTR_CIPHER_SUITE_GROUP,
+	NL80211_ATTR_WPA_VERSIONS,
+	NL80211_ATTR_AKM_SUITES,
+
+	NL80211_ATTR_REQ_IE,
+	NL80211_ATTR_RESP_IE,
+
+	NL80211_ATTR_PREV_BSSID,
+
+	NL80211_ATTR_KEY,
+	NL80211_ATTR_KEYS,
+
+	NL80211_ATTR_PID,
+
+	NL80211_ATTR_4ADDR,
+
+	NL80211_ATTR_SURVEY_INFO,
+
+	NL80211_ATTR_PMKID,
+	NL80211_ATTR_MAX_NUM_PMKIDS,
+
+	NL80211_ATTR_DURATION,
+
+	NL80211_ATTR_COOKIE,
+
+	NL80211_ATTR_WIPHY_COVERAGE_CLASS,
+
+	NL80211_ATTR_TX_RATES,
+
+	NL80211_ATTR_FRAME_MATCH,
+
+	NL80211_ATTR_ACK,
+
+	NL80211_ATTR_PS_STATE,
+
+	NL80211_ATTR_CQM,
+
+	NL80211_ATTR_LOCAL_STATE_CHANGE,
+
+	NL80211_ATTR_AP_ISOLATE,
+
+	NL80211_ATTR_WIPHY_TX_POWER_SETTING,
+	NL80211_ATTR_WIPHY_TX_POWER_LEVEL,
+
+	NL80211_ATTR_TX_FRAME_TYPES,
+	NL80211_ATTR_RX_FRAME_TYPES,
+	NL80211_ATTR_FRAME_TYPE,
+
+	NL80211_ATTR_CONTROL_PORT_ETHERTYPE,
+	NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT,
+
+	NL80211_ATTR_SUPPORT_IBSS_RSN,
+
+	NL80211_ATTR_WIPHY_ANTENNA_TX,
+	NL80211_ATTR_WIPHY_ANTENNA_RX,
+
+	NL80211_ATTR_MCAST_RATE,
+
+	NL80211_ATTR_OFFCHANNEL_TX_OK,
+
+	NL80211_ATTR_BSS_HT_OPMODE,
+
+	NL80211_ATTR_KEY_DEFAULT_TYPES,
+
+	NL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION,
+
+	NL80211_ATTR_MESH_SETUP,
+
+	NL80211_ATTR_WIPHY_ANTENNA_AVAIL_TX,
+	NL80211_ATTR_WIPHY_ANTENNA_AVAIL_RX,
+
+	NL80211_ATTR_SUPPORT_MESH_AUTH,
+	NL80211_ATTR_STA_PLINK_STATE,
+
+	NL80211_ATTR_WOWLAN_TRIGGERS,
+	NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED,
+
+	NL80211_ATTR_SCHED_SCAN_INTERVAL,
+
+	NL80211_ATTR_INTERFACE_COMBINATIONS,
+	NL80211_ATTR_SOFTWARE_IFTYPES,
+
+	NL80211_ATTR_REKEY_DATA,
+
+	NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS,
+	NL80211_ATTR_MAX_SCHED_SCAN_IE_LEN,
+
+	NL80211_ATTR_SCAN_SUPP_RATES,
+
+	NL80211_ATTR_HIDDEN_SSID,
+
+	NL80211_ATTR_IE_PROBE_RESP,
+	NL80211_ATTR_IE_ASSOC_RESP,
+
+	NL80211_ATTR_STA_WME,
+	NL80211_ATTR_SUPPORT_AP_UAPSD,
+
+	NL80211_ATTR_ROAM_SUPPORT,
+
+	NL80211_ATTR_SCHED_SCAN_MATCH,
+	NL80211_ATTR_MAX_MATCH_SETS,
+
+	NL80211_ATTR_PMKSA_CANDIDATE,
+
+	NL80211_ATTR_TX_NO_CCK_RATE,
+
+	NL80211_ATTR_TDLS_ACTION,
+	NL80211_ATTR_TDLS_DIALOG_TOKEN,
+	NL80211_ATTR_TDLS_OPERATION,
+	NL80211_ATTR_TDLS_SUPPORT,
+	NL80211_ATTR_TDLS_EXTERNAL_SETUP,
+
+	NL80211_ATTR_DEVICE_AP_SME,
+
+	NL80211_ATTR_DONT_WAIT_FOR_ACK,
+
+	NL80211_ATTR_FEATURE_FLAGS,
+
+	NL80211_ATTR_PROBE_RESP_OFFLOAD,
+
+	NL80211_ATTR_PROBE_RESP,
+
+	NL80211_ATTR_DFS_REGION,
+
+	NL80211_ATTR_DISABLE_HT,
+	NL80211_ATTR_HT_CAPABILITY_MASK,
+
+	NL80211_ATTR_NOACK_MAP,
+
+	NL80211_ATTR_INACTIVITY_TIMEOUT,
+
+	NL80211_ATTR_RX_SIGNAL_DBM,
+
+	NL80211_ATTR_BG_SCAN_PERIOD,
+
+	NL80211_ATTR_WDEV,
+
+	NL80211_ATTR_USER_REG_HINT_TYPE,
+
+	NL80211_ATTR_CONN_FAILED_REASON,
+
+	NL80211_ATTR_AUTH_DATA,
+
+	NL80211_ATTR_VHT_CAPABILITY,
+
+	NL80211_ATTR_SCAN_FLAGS,
+
+	NL80211_ATTR_CHANNEL_WIDTH,
+	NL80211_ATTR_CENTER_FREQ1,
+	NL80211_ATTR_CENTER_FREQ2,
+
+	NL80211_ATTR_P2P_CTWINDOW,
+	NL80211_ATTR_P2P_OPPPS,
+
+	NL80211_ATTR_LOCAL_MESH_POWER_MODE,
+
+	NL80211_ATTR_ACL_POLICY,
+
+	NL80211_ATTR_MAC_ADDRS,
+
+	NL80211_ATTR_MAC_ACL_MAX,
+
+	NL80211_ATTR_RADAR_EVENT,
+
+	NL80211_ATTR_EXT_CAPA,
+	NL80211_ATTR_EXT_CAPA_MASK,
+
+	NL80211_ATTR_STA_CAPABILITY,
+	NL80211_ATTR_STA_EXT_CAPABILITY,
+
+	NL80211_ATTR_PROTOCOL_FEATURES,
+	NL80211_ATTR_SPLIT_WIPHY_DUMP,
+
+	NL80211_ATTR_DISABLE_VHT,
+	NL80211_ATTR_VHT_CAPABILITY_MASK,
+
+	NL80211_ATTR_MDID,
+	NL80211_ATTR_IE_RIC,
+
+	NL80211_ATTR_CRIT_PROT_ID,
+	NL80211_ATTR_MAX_CRIT_PROT_DURATION,
+
+	NL80211_ATTR_PEER_AID,
+
+	NL80211_ATTR_COALESCE_RULE,
+
+	NL80211_ATTR_CH_SWITCH_COUNT,
+	NL80211_ATTR_CH_SWITCH_BLOCK_TX,
+	NL80211_ATTR_CSA_IES,
+	NL80211_ATTR_CSA_C_OFF_BEACON,
+	NL80211_ATTR_CSA_C_OFF_PRESP,
+
+	NL80211_ATTR_RXMGMT_FLAGS,
+
+	NL80211_ATTR_STA_SUPPORTED_CHANNELS,
+
+	NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES,
+
+	NL80211_ATTR_HANDLE_DFS,
+
+	NL80211_ATTR_SUPPORT_5_MHZ,
+	NL80211_ATTR_SUPPORT_10_MHZ,
+
+	NL80211_ATTR_OPMODE_NOTIF,
+
+	NL80211_ATTR_VENDOR_ID,
+	NL80211_ATTR_VENDOR_SUBCMD,
+	NL80211_ATTR_VENDOR_DATA,
+	NL80211_ATTR_VENDOR_EVENTS,
+
+	NL80211_ATTR_QOS_MAP,
+
+	NL80211_ATTR_MAC_HINT,
+	NL80211_ATTR_WIPHY_FREQ_HINT,
+
+	NL80211_ATTR_MAX_AP_ASSOC_STA,
+
+	NL80211_ATTR_TDLS_PEER_CAPABILITY,
+
+	NL80211_ATTR_SOCKET_OWNER,
+
+	NL80211_ATTR_CSA_C_OFFSETS_TX,
+	NL80211_ATTR_MAX_CSA_COUNTERS,
+
+	NL80211_ATTR_TDLS_INITIATOR,
+
+	NL80211_ATTR_USE_RRM,
+
+	NL80211_ATTR_WIPHY_DYN_ACK,
+
+	NL80211_ATTR_TSID,
+	NL80211_ATTR_USER_PRIO,
+	NL80211_ATTR_ADMITTED_TIME,
+
+	NL80211_ATTR_SMPS_MODE,
+
+	NL80211_ATTR_OPER_CLASS,
+
+	NL80211_ATTR_MAC_MASK,
+
+	NL80211_ATTR_WIPHY_SELF_MANAGED_REG,
+
+	NL80211_ATTR_EXT_FEATURES,
+
+	NL80211_ATTR_SURVEY_RADIO_STATS,
+
+	NL80211_ATTR_NETNS_FD,
+
+	NL80211_ATTR_SCHED_SCAN_DELAY,
+
+	NL80211_ATTR_REG_INDOOR,
+
+	NL80211_ATTR_MAX_NUM_SCHED_SCAN_PLANS,
+	NL80211_ATTR_MAX_SCAN_PLAN_INTERVAL,
+	NL80211_ATTR_MAX_SCAN_PLAN_ITERATIONS,
+	NL80211_ATTR_SCHED_SCAN_PLANS,
+
+	NL80211_ATTR_PBSS,
+
+	NL80211_ATTR_BSS_SELECT,
+
+	NL80211_ATTR_STA_SUPPORT_P2P_PS,
+
+	NL80211_ATTR_PAD,
+
+	NL80211_ATTR_IFTYPE_EXT_CAPA,
+
+	NL80211_ATTR_MU_MIMO_GROUP_DATA,
+	NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR,
+
+	NL80211_ATTR_SCAN_START_TIME_TSF,
+	NL80211_ATTR_SCAN_START_TIME_TSF_BSSID,
+	NL80211_ATTR_MEASUREMENT_DURATION,
+	NL80211_ATTR_MEASUREMENT_DURATION_MANDATORY,
+
+	NL80211_ATTR_MESH_PEER_AID,
+
+	NL80211_ATTR_NAN_MASTER_PREF,
+	NL80211_ATTR_BANDS,
+	NL80211_ATTR_NAN_FUNC,
+	NL80211_ATTR_NAN_MATCH,
+
+	NL80211_ATTR_FILS_KEK,
+	NL80211_ATTR_FILS_NONCES,
+
+	NL80211_ATTR_MULTICAST_TO_UNICAST_ENABLED,
+
+	NL80211_ATTR_BSSID,
+
+	NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI,
+	NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST,
+
+	NL80211_ATTR_TIMEOUT_REASON,
+
+	NL80211_ATTR_FILS_ERP_USERNAME,
+	NL80211_ATTR_FILS_ERP_REALM,
+	NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM,
+	NL80211_ATTR_FILS_ERP_RRK,
+	NL80211_ATTR_FILS_CACHE_ID,
+
+	NL80211_ATTR_PMK,
+
+	NL80211_ATTR_SCHED_SCAN_MULTI,
+	NL80211_ATTR_SCHED_SCAN_MAX_REQS,
+
+	NL80211_ATTR_WANT_1X_4WAY_HS,
+	NL80211_ATTR_PMKR0_NAME,
+	NL80211_ATTR_PORT_AUTHORIZED,
+
+	NL80211_ATTR_EXTERNAL_AUTH_ACTION,
+	NL80211_ATTR_EXTERNAL_AUTH_SUPPORT,
+
+	NL80211_ATTR_NSS,
+	NL80211_ATTR_ACK_SIGNAL,
+
+	NL80211_ATTR_CONTROL_PORT_OVER_NL80211,
+
+	NL80211_ATTR_TXQ_STATS,
+	NL80211_ATTR_TXQ_LIMIT,
+	NL80211_ATTR_TXQ_MEMORY_LIMIT,
+	NL80211_ATTR_TXQ_QUANTUM,
+
+	NL80211_ATTR_HE_CAPABILITY,
+
+	NL80211_ATTR_FTM_RESPONDER,
+
+	NL80211_ATTR_FTM_RESPONDER_STATS,
+
+	NL80211_ATTR_TIMEOUT,
+
+	NL80211_ATTR_PEER_MEASUREMENTS,
+
+	NL80211_ATTR_AIRTIME_WEIGHT,
+	NL80211_ATTR_STA_TX_POWER_SETTING,
+	NL80211_ATTR_STA_TX_POWER,
+
+	NL80211_ATTR_SAE_PASSWORD,
+
+	NL80211_ATTR_TWT_RESPONDER,
+
+	NL80211_ATTR_HE_OBSS_PD,
+
+	NL80211_ATTR_WIPHY_EDMG_CHANNELS,
+	NL80211_ATTR_WIPHY_EDMG_BW_CONFIG,
+
+	NL80211_ATTR_VLAN_ID,
+
+	NL80211_ATTR_HE_BSS_COLOR,
+
+	NL80211_ATTR_IFTYPE_AKM_SUITES,
+
+	NL80211_ATTR_TID_CONFIG,
+
+	NL80211_ATTR_CONTROL_PORT_NO_PREAUTH,
+
+	NL80211_ATTR_PMK_LIFETIME,
+	NL80211_ATTR_PMK_REAUTH_THRESHOLD,
+
+	NL80211_ATTR_HE_6GHZ_CAPABILITY,
+
+	/* add attributes here, update the policy in nl80211.c */
+
+	__NL80211_ATTR_AFTER_LAST,
+	NUM_NL80211_ATTR = __NL80211_ATTR_AFTER_LAST,
+	NL80211_ATTR_MAX = __NL80211_ATTR_AFTER_LAST - 1
+};
+
+/* source-level API compatibility */
+#define NL80211_ATTR_SCAN_GENERATION NL80211_ATTR_GENERATION
+#define	NL80211_ATTR_MESH_PARAMS NL80211_ATTR_MESH_CONFIG
+#define NL80211_ATTR_IFACE_SOCKET_OWNER NL80211_ATTR_SOCKET_OWNER
+#define NL80211_ATTR_SAE_DATA NL80211_ATTR_AUTH_DATA
+
+/*
+ * Allow user space programs to use #ifdef on new attributes by defining them
+ * here
+ */
+#define NL80211_CMD_CONNECT NL80211_CMD_CONNECT
+#define NL80211_ATTR_HT_CAPABILITY NL80211_ATTR_HT_CAPABILITY
+#define NL80211_ATTR_BSS_BASIC_RATES NL80211_ATTR_BSS_BASIC_RATES
+#define NL80211_ATTR_WIPHY_TXQ_PARAMS NL80211_ATTR_WIPHY_TXQ_PARAMS
+#define NL80211_ATTR_WIPHY_FREQ NL80211_ATTR_WIPHY_FREQ
+#define NL80211_ATTR_WIPHY_CHANNEL_TYPE NL80211_ATTR_WIPHY_CHANNEL_TYPE
+#define NL80211_ATTR_MGMT_SUBTYPE NL80211_ATTR_MGMT_SUBTYPE
+#define NL80211_ATTR_IE NL80211_ATTR_IE
+#define NL80211_ATTR_REG_INITIATOR NL80211_ATTR_REG_INITIATOR
+#define NL80211_ATTR_REG_TYPE NL80211_ATTR_REG_TYPE
+#define NL80211_ATTR_FRAME NL80211_ATTR_FRAME
+#define NL80211_ATTR_SSID NL80211_ATTR_SSID
+#define NL80211_ATTR_AUTH_TYPE NL80211_ATTR_AUTH_TYPE
+#define NL80211_ATTR_REASON_CODE NL80211_ATTR_REASON_CODE
+#define NL80211_ATTR_CIPHER_SUITES_PAIRWISE NL80211_ATTR_CIPHER_SUITES_PAIRWISE
+#define NL80211_ATTR_CIPHER_SUITE_GROUP NL80211_ATTR_CIPHER_SUITE_GROUP
+#define NL80211_ATTR_WPA_VERSIONS NL80211_ATTR_WPA_VERSIONS
+#define NL80211_ATTR_AKM_SUITES NL80211_ATTR_AKM_SUITES
+#define NL80211_ATTR_KEY NL80211_ATTR_KEY
+#define NL80211_ATTR_KEYS NL80211_ATTR_KEYS
+#define NL80211_ATTR_FEATURE_FLAGS NL80211_ATTR_FEATURE_FLAGS
+
+#define NL80211_WIPHY_NAME_MAXLEN		64
+
+#define NL80211_MAX_SUPP_RATES			32
+#define NL80211_MAX_SUPP_HT_RATES		77
+#define NL80211_MAX_SUPP_REG_RULES		128
+#define NL80211_TKIP_DATA_OFFSET_ENCR_KEY	0
+#define NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY	16
+#define NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY	24
+#define NL80211_HT_CAPABILITY_LEN		26
+#define NL80211_VHT_CAPABILITY_LEN		12
+#define NL80211_HE_MIN_CAPABILITY_LEN           16
+#define NL80211_HE_MAX_CAPABILITY_LEN           54
+#define NL80211_MAX_NR_CIPHER_SUITES		5
+#define NL80211_MAX_NR_AKM_SUITES		2
+
+#define NL80211_MIN_REMAIN_ON_CHANNEL_TIME	10
+
+/* default RSSI threshold for scan results if none specified. */
+#define NL80211_SCAN_RSSI_THOLD_OFF		-300
+
+#define NL80211_CQM_TXE_MAX_INTVL		1800
+
+/**
+ * enum nl80211_iftype - (virtual) interface types
+ *
+ * @NL80211_IFTYPE_UNSPECIFIED: unspecified type, driver decides
+ * @NL80211_IFTYPE_ADHOC: independent BSS member
+ * @NL80211_IFTYPE_STATION: managed BSS member
+ * @NL80211_IFTYPE_AP: access point
+ * @NL80211_IFTYPE_AP_VLAN: VLAN interface for access points; VLAN interfaces
+ *	are a bit special in that they must always be tied to a pre-existing
+ *	AP type interface.
+ * @NL80211_IFTYPE_WDS: wireless distribution interface
+ * @NL80211_IFTYPE_MONITOR: monitor interface receiving all frames
+ * @NL80211_IFTYPE_MESH_POINT: mesh point
+ * @NL80211_IFTYPE_P2P_CLIENT: P2P client
+ * @NL80211_IFTYPE_P2P_GO: P2P group owner
+ * @NL80211_IFTYPE_P2P_DEVICE: P2P device interface type, this is not a netdev
+ *	and therefore can't be created in the normal ways, use the
+ *	%NL80211_CMD_START_P2P_DEVICE and %NL80211_CMD_STOP_P2P_DEVICE
+ *	commands to create and destroy one
+ * @NL80211_IF_TYPE_OCB: Outside Context of a BSS
+ *	This mode corresponds to the MIB variable dot11OCBActivated=true
+ * @NL80211_IFTYPE_NAN: NAN device interface type (not a netdev)
+ * @NL80211_IFTYPE_MAX: highest interface type number currently defined
+ * @NUM_NL80211_IFTYPES: number of defined interface types
+ *
+ * These values are used with the %NL80211_ATTR_IFTYPE
+ * to set the type of an interface.
+ *
+ */
+enum nl80211_iftype {
+	NL80211_IFTYPE_UNSPECIFIED,
+	NL80211_IFTYPE_ADHOC,
+	NL80211_IFTYPE_STATION,
+	NL80211_IFTYPE_AP,
+	NL80211_IFTYPE_AP_VLAN,
+	NL80211_IFTYPE_WDS,
+	NL80211_IFTYPE_MONITOR,
+	NL80211_IFTYPE_MESH_POINT,
+	NL80211_IFTYPE_P2P_CLIENT,
+	NL80211_IFTYPE_P2P_GO,
+	NL80211_IFTYPE_P2P_DEVICE,
+	NL80211_IFTYPE_OCB,
+	NL80211_IFTYPE_NAN,
+
+	/* keep last */
+	NUM_NL80211_IFTYPES,
+	NL80211_IFTYPE_MAX = NUM_NL80211_IFTYPES - 1
+};
+
+/**
+ * enum nl80211_sta_flags - station flags
+ *
+ * Station flags. When a station is added to an AP interface, it is
+ * assumed to be already associated (and hence authenticated.)
+ *
+ * @__NL80211_STA_FLAG_INVALID: attribute number 0 is reserved
+ * @NL80211_STA_FLAG_AUTHORIZED: station is authorized (802.1X)
+ * @NL80211_STA_FLAG_SHORT_PREAMBLE: station is capable of receiving frames
+ *	with short barker preamble
+ * @NL80211_STA_FLAG_WME: station is WME/QoS capable
+ * @NL80211_STA_FLAG_MFP: station uses management frame protection
+ * @NL80211_STA_FLAG_AUTHENTICATED: station is authenticated
+ * @NL80211_STA_FLAG_TDLS_PEER: station is a TDLS peer -- this flag should
+ *	only be used in managed mode (even in the flags mask). Note that the
+ *	flag can't be changed, it is only valid while adding a station, and
+ *	attempts to change it will silently be ignored (rather than rejected
+ *	as errors.)
+ * @NL80211_STA_FLAG_ASSOCIATED: station is associated; used with drivers
+ *	that support %NL80211_FEATURE_FULL_AP_CLIENT_STATE to transition a
+ *	previously added station into associated state
+ * @NL80211_STA_FLAG_MAX: highest station flag number currently defined
+ * @__NL80211_STA_FLAG_AFTER_LAST: internal use
+ */
+enum nl80211_sta_flags {
+	__NL80211_STA_FLAG_INVALID,
+	NL80211_STA_FLAG_AUTHORIZED,
+	NL80211_STA_FLAG_SHORT_PREAMBLE,
+	NL80211_STA_FLAG_WME,
+	NL80211_STA_FLAG_MFP,
+	NL80211_STA_FLAG_AUTHENTICATED,
+	NL80211_STA_FLAG_TDLS_PEER,
+	NL80211_STA_FLAG_ASSOCIATED,
+
+	/* keep last */
+	__NL80211_STA_FLAG_AFTER_LAST,
+	NL80211_STA_FLAG_MAX = __NL80211_STA_FLAG_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_sta_p2p_ps_status - station support of P2P PS
+ *
+ * @NL80211_P2P_PS_UNSUPPORTED: station doesn't support P2P PS mechanism
+ * @@NL80211_P2P_PS_SUPPORTED: station supports P2P PS mechanism
+ * @NUM_NL80211_P2P_PS_STATUS: number of values
+ */
+enum nl80211_sta_p2p_ps_status {
+	NL80211_P2P_PS_UNSUPPORTED = 0,
+	NL80211_P2P_PS_SUPPORTED,
+
+	NUM_NL80211_P2P_PS_STATUS,
+};
+
+#define NL80211_STA_FLAG_MAX_OLD_API	NL80211_STA_FLAG_TDLS_PEER
+
+/**
+ * struct nl80211_sta_flag_update - station flags mask/set
+ * @mask: mask of station flags to set
+ * @set: which values to set them to
+ *
+ * Both mask and set contain bits as per &enum nl80211_sta_flags.
+ */
+struct nl80211_sta_flag_update {
+	__u32 mask;
+	__u32 set;
+} __attribute__((packed));
+
+/**
+ * enum nl80211_he_gi - HE guard interval
+ * @NL80211_RATE_INFO_HE_GI_0_8: 0.8 usec
+ * @NL80211_RATE_INFO_HE_GI_1_6: 1.6 usec
+ * @NL80211_RATE_INFO_HE_GI_3_2: 3.2 usec
+ */
+enum nl80211_he_gi {
+	NL80211_RATE_INFO_HE_GI_0_8,
+	NL80211_RATE_INFO_HE_GI_1_6,
+	NL80211_RATE_INFO_HE_GI_3_2,
+};
+
+/**
+ * enum nl80211_he_ru_alloc - HE RU allocation values
+ * @NL80211_RATE_INFO_HE_RU_ALLOC_26: 26-tone RU allocation
+ * @NL80211_RATE_INFO_HE_RU_ALLOC_52: 52-tone RU allocation
+ * @NL80211_RATE_INFO_HE_RU_ALLOC_106: 106-tone RU allocation
+ * @NL80211_RATE_INFO_HE_RU_ALLOC_242: 242-tone RU allocation
+ * @NL80211_RATE_INFO_HE_RU_ALLOC_484: 484-tone RU allocation
+ * @NL80211_RATE_INFO_HE_RU_ALLOC_996: 996-tone RU allocation
+ * @NL80211_RATE_INFO_HE_RU_ALLOC_2x996: 2x996-tone RU allocation
+ */
+enum nl80211_he_ru_alloc {
+	NL80211_RATE_INFO_HE_RU_ALLOC_26,
+	NL80211_RATE_INFO_HE_RU_ALLOC_52,
+	NL80211_RATE_INFO_HE_RU_ALLOC_106,
+	NL80211_RATE_INFO_HE_RU_ALLOC_242,
+	NL80211_RATE_INFO_HE_RU_ALLOC_484,
+	NL80211_RATE_INFO_HE_RU_ALLOC_996,
+	NL80211_RATE_INFO_HE_RU_ALLOC_2x996,
+};
+
+/**
+ * enum nl80211_rate_info - bitrate information
+ *
+ * These attribute types are used with %NL80211_STA_INFO_TXRATE
+ * when getting information about the bitrate of a station.
+ * There are 2 attributes for bitrate, a legacy one that represents
+ * a 16-bit value, and new one that represents a 32-bit value.
+ * If the rate value fits into 16 bit, both attributes are reported
+ * with the same value. If the rate is too high to fit into 16 bits
+ * (>6.5535Gbps) only 32-bit attribute is included.
+ * User space tools encouraged to use the 32-bit attribute and fall
+ * back to the 16-bit one for compatibility with older kernels.
+ *
+ * @__NL80211_RATE_INFO_INVALID: attribute number 0 is reserved
+ * @NL80211_RATE_INFO_BITRATE: total bitrate (u16, 100kbit/s)
+ * @NL80211_RATE_INFO_MCS: mcs index for 802.11n (u8)
+ * @NL80211_RATE_INFO_40_MHZ_WIDTH: 40 MHz dualchannel bitrate
+ * @NL80211_RATE_INFO_SHORT_GI: 400ns guard interval
+ * @NL80211_RATE_INFO_BITRATE32: total bitrate (u32, 100kbit/s)
+ * @NL80211_RATE_INFO_MAX: highest rate_info number currently defined
+ * @NL80211_RATE_INFO_VHT_MCS: MCS index for VHT (u8)
+ * @NL80211_RATE_INFO_VHT_NSS: number of streams in VHT (u8)
+ * @NL80211_RATE_INFO_80_MHZ_WIDTH: 80 MHz VHT rate
+ * @NL80211_RATE_INFO_80P80_MHZ_WIDTH: unused - 80+80 is treated the
+ *	same as 160 for purposes of the bitrates
+ * @NL80211_RATE_INFO_160_MHZ_WIDTH: 160 MHz VHT rate
+ * @NL80211_RATE_INFO_10_MHZ_WIDTH: 10 MHz width - note that this is
+ *	a legacy rate and will be reported as the actual bitrate, i.e.
+ *	half the base (20 MHz) rate
+ * @NL80211_RATE_INFO_5_MHZ_WIDTH: 5 MHz width - note that this is
+ *	a legacy rate and will be reported as the actual bitrate, i.e.
+ *	a quarter of the base (20 MHz) rate
+ * @NL80211_RATE_INFO_HE_MCS: HE MCS index (u8, 0-11)
+ * @NL80211_RATE_INFO_HE_NSS: HE NSS value (u8, 1-8)
+ * @NL80211_RATE_INFO_HE_GI: HE guard interval identifier
+ *	(u8, see &enum nl80211_he_gi)
+ * @NL80211_RATE_INFO_HE_DCM: HE DCM value (u8, 0/1)
+ * @NL80211_RATE_INFO_RU_ALLOC: HE RU allocation, if not present then
+ *	non-OFDMA was used (u8, see &enum nl80211_he_ru_alloc)
+ * @__NL80211_RATE_INFO_AFTER_LAST: internal use
+ */
+enum nl80211_rate_info {
+	__NL80211_RATE_INFO_INVALID,
+	NL80211_RATE_INFO_BITRATE,
+	NL80211_RATE_INFO_MCS,
+	NL80211_RATE_INFO_40_MHZ_WIDTH,
+	NL80211_RATE_INFO_SHORT_GI,
+	NL80211_RATE_INFO_BITRATE32,
+	NL80211_RATE_INFO_VHT_MCS,
+	NL80211_RATE_INFO_VHT_NSS,
+	NL80211_RATE_INFO_80_MHZ_WIDTH,
+	NL80211_RATE_INFO_80P80_MHZ_WIDTH,
+	NL80211_RATE_INFO_160_MHZ_WIDTH,
+	NL80211_RATE_INFO_10_MHZ_WIDTH,
+	NL80211_RATE_INFO_5_MHZ_WIDTH,
+	NL80211_RATE_INFO_HE_MCS,
+	NL80211_RATE_INFO_HE_NSS,
+	NL80211_RATE_INFO_HE_GI,
+	NL80211_RATE_INFO_HE_DCM,
+	NL80211_RATE_INFO_HE_RU_ALLOC,
+
+	/* keep last */
+	__NL80211_RATE_INFO_AFTER_LAST,
+	NL80211_RATE_INFO_MAX = __NL80211_RATE_INFO_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_sta_bss_param - BSS information collected by STA
+ *
+ * These attribute types are used with %NL80211_STA_INFO_BSS_PARAM
+ * when getting information about the bitrate of a station.
+ *
+ * @__NL80211_STA_BSS_PARAM_INVALID: attribute number 0 is reserved
+ * @NL80211_STA_BSS_PARAM_CTS_PROT: whether CTS protection is enabled (flag)
+ * @NL80211_STA_BSS_PARAM_SHORT_PREAMBLE:  whether short preamble is enabled
+ *	(flag)
+ * @NL80211_STA_BSS_PARAM_SHORT_SLOT_TIME:  whether short slot time is enabled
+ *	(flag)
+ * @NL80211_STA_BSS_PARAM_DTIM_PERIOD: DTIM period for beaconing (u8)
+ * @NL80211_STA_BSS_PARAM_BEACON_INTERVAL: Beacon interval (u16)
+ * @NL80211_STA_BSS_PARAM_MAX: highest sta_bss_param number currently defined
+ * @__NL80211_STA_BSS_PARAM_AFTER_LAST: internal use
+ */
+enum nl80211_sta_bss_param {
+	__NL80211_STA_BSS_PARAM_INVALID,
+	NL80211_STA_BSS_PARAM_CTS_PROT,
+	NL80211_STA_BSS_PARAM_SHORT_PREAMBLE,
+	NL80211_STA_BSS_PARAM_SHORT_SLOT_TIME,
+	NL80211_STA_BSS_PARAM_DTIM_PERIOD,
+	NL80211_STA_BSS_PARAM_BEACON_INTERVAL,
+
+	/* keep last */
+	__NL80211_STA_BSS_PARAM_AFTER_LAST,
+	NL80211_STA_BSS_PARAM_MAX = __NL80211_STA_BSS_PARAM_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_sta_info - station information
+ *
+ * These attribute types are used with %NL80211_ATTR_STA_INFO
+ * when getting information about a station.
+ *
+ * @__NL80211_STA_INFO_INVALID: attribute number 0 is reserved
+ * @NL80211_STA_INFO_INACTIVE_TIME: time since last activity (u32, msecs)
+ * @NL80211_STA_INFO_RX_BYTES: total received bytes (MPDU length)
+ *	(u32, from this station)
+ * @NL80211_STA_INFO_TX_BYTES: total transmitted bytes (MPDU length)
+ *	(u32, to this station)
+ * @NL80211_STA_INFO_RX_BYTES64: total received bytes (MPDU length)
+ *	(u64, from this station)
+ * @NL80211_STA_INFO_TX_BYTES64: total transmitted bytes (MPDU length)
+ *	(u64, to this station)
+ * @NL80211_STA_INFO_SIGNAL: signal strength of last received PPDU (u8, dBm)
+ * @NL80211_STA_INFO_TX_BITRATE: current unicast tx rate, nested attribute
+ * 	containing info as possible, see &enum nl80211_rate_info
+ * @NL80211_STA_INFO_RX_PACKETS: total received packet (MSDUs and MMPDUs)
+ *	(u32, from this station)
+ * @NL80211_STA_INFO_TX_PACKETS: total transmitted packets (MSDUs and MMPDUs)
+ *	(u32, to this station)
+ * @NL80211_STA_INFO_TX_RETRIES: total retries (MPDUs) (u32, to this station)
+ * @NL80211_STA_INFO_TX_FAILED: total failed packets (MPDUs)
+ *	(u32, to this station)
+ * @NL80211_STA_INFO_SIGNAL_AVG: signal strength average (u8, dBm)
+ * @NL80211_STA_INFO_LLID: the station's mesh LLID
+ * @NL80211_STA_INFO_PLID: the station's mesh PLID
+ * @NL80211_STA_INFO_PLINK_STATE: peer link state for the station
+ *	(see %enum nl80211_plink_state)
+ * @NL80211_STA_INFO_RX_BITRATE: last unicast data frame rx rate, nested
+ *	attribute, like NL80211_STA_INFO_TX_BITRATE.
+ * @NL80211_STA_INFO_BSS_PARAM: current station's view of BSS, nested attribute
+ *     containing info as possible, see &enum nl80211_sta_bss_param
+ * @NL80211_STA_INFO_CONNECTED_TIME: time since the station is last connected
+ * @NL80211_STA_INFO_STA_FLAGS: Contains a struct nl80211_sta_flag_update.
+ * @NL80211_STA_INFO_BEACON_LOSS: count of times beacon loss was detected (u32)
+ * @NL80211_STA_INFO_T_OFFSET: timing offset with respect to this STA (s64)
+ * @NL80211_STA_INFO_LOCAL_PM: local mesh STA link-specific power mode
+ * @NL80211_STA_INFO_PEER_PM: peer mesh STA link-specific power mode
+ * @NL80211_STA_INFO_NONPEER_PM: neighbor mesh STA power save mode towards
+ *	non-peer STA
+ * @NL80211_STA_INFO_CHAIN_SIGNAL: per-chain signal strength of last PPDU
+ *	Contains a nested array of signal strength attributes (u8, dBm)
+ * @NL80211_STA_INFO_CHAIN_SIGNAL_AVG: per-chain signal strength average
+ *	Same format as NL80211_STA_INFO_CHAIN_SIGNAL.
+ * @NL80211_STA_EXPECTED_THROUGHPUT: expected throughput considering also the
+ *	802.11 header (u32, kbps)
+ * @NL80211_STA_INFO_RX_DROP_MISC: RX packets dropped for unspecified reasons
+ *	(u64)
+ * @NL80211_STA_INFO_BEACON_RX: number of beacons received from this peer (u64)
+ * @NL80211_STA_INFO_BEACON_SIGNAL_AVG: signal strength average
+ *	for beacons only (u8, dBm)
+ * @NL80211_STA_INFO_TID_STATS: per-TID statistics (see &enum nl80211_tid_stats)
+ *	This is a nested attribute where each the inner attribute number is the
+ *	TID+1 and the special TID 16 (i.e. value 17) is used for non-QoS frames;
+ *	each one of those is again nested with &enum nl80211_tid_stats
+ *	attributes carrying the actual values.
+ * @NL80211_STA_INFO_RX_DURATION: aggregate PPDU duration for all frames
+ *	received from the station (u64, usec)
+ * @NL80211_STA_INFO_PAD: attribute used for padding for 64-bit alignment
+ * @NL80211_STA_INFO_ACK_SIGNAL: signal strength of the last ACK frame(u8, dBm)
+ * @NL80211_STA_INFO_ACK_SIGNAL_AVG: avg signal strength of ACK frames (s8, dBm)
+ * @NL80211_STA_INFO_RX_MPDUS: total number of received packets (MPDUs)
+ *	(u32, from this station)
+ * @NL80211_STA_INFO_FCS_ERROR_COUNT: total number of packets (MPDUs) received
+ *	with an FCS error (u32, from this station). This count may not include
+ *	some packets with an FCS error due to TA corruption. Hence this counter
+ *	might not be fully accurate.
+ * @NL80211_STA_INFO_CONNECTED_TO_GATE: set to true if STA has a path to a
+ *	mesh gate (u8, 0 or 1)
+ * @NL80211_STA_INFO_TX_DURATION: aggregate PPDU duration for all frames
+ *	sent to the station (u64, usec)
+ * @NL80211_STA_INFO_AIRTIME_WEIGHT: current airtime weight for station (u16)
+ * @NL80211_STA_INFO_AIRTIME_LINK_METRIC: airtime link metric for mesh station
+ * @NL80211_STA_INFO_ASSOC_AT_BOOTTIME: Timestamp (CLOCK_BOOTTIME, nanoseconds)
+ *	of STA's association
+ * @__NL80211_STA_INFO_AFTER_LAST: internal
+ * @NL80211_STA_INFO_MAX: highest possible station info attribute
+ */
+enum nl80211_sta_info {
+	__NL80211_STA_INFO_INVALID,
+	NL80211_STA_INFO_INACTIVE_TIME,
+	NL80211_STA_INFO_RX_BYTES,
+	NL80211_STA_INFO_TX_BYTES,
+	NL80211_STA_INFO_LLID,
+	NL80211_STA_INFO_PLID,
+	NL80211_STA_INFO_PLINK_STATE,
+	NL80211_STA_INFO_SIGNAL,
+	NL80211_STA_INFO_TX_BITRATE,
+	NL80211_STA_INFO_RX_PACKETS,
+	NL80211_STA_INFO_TX_PACKETS,
+	NL80211_STA_INFO_TX_RETRIES,
+	NL80211_STA_INFO_TX_FAILED,
+	NL80211_STA_INFO_SIGNAL_AVG,
+	NL80211_STA_INFO_RX_BITRATE,
+	NL80211_STA_INFO_BSS_PARAM,
+	NL80211_STA_INFO_CONNECTED_TIME,
+	NL80211_STA_INFO_STA_FLAGS,
+	NL80211_STA_INFO_BEACON_LOSS,
+	NL80211_STA_INFO_T_OFFSET,
+	NL80211_STA_INFO_LOCAL_PM,
+	NL80211_STA_INFO_PEER_PM,
+	NL80211_STA_INFO_NONPEER_PM,
+	NL80211_STA_INFO_RX_BYTES64,
+	NL80211_STA_INFO_TX_BYTES64,
+	NL80211_STA_INFO_CHAIN_SIGNAL,
+	NL80211_STA_INFO_CHAIN_SIGNAL_AVG,
+	NL80211_STA_INFO_EXPECTED_THROUGHPUT,
+	NL80211_STA_INFO_RX_DROP_MISC,
+	NL80211_STA_INFO_BEACON_RX,
+	NL80211_STA_INFO_BEACON_SIGNAL_AVG,
+	NL80211_STA_INFO_TID_STATS,
+	NL80211_STA_INFO_RX_DURATION,
+	NL80211_STA_INFO_PAD,
+	NL80211_STA_INFO_ACK_SIGNAL,
+	NL80211_STA_INFO_ACK_SIGNAL_AVG,
+	NL80211_STA_INFO_RX_MPDUS,
+	NL80211_STA_INFO_FCS_ERROR_COUNT,
+	NL80211_STA_INFO_CONNECTED_TO_GATE,
+	NL80211_STA_INFO_TX_DURATION,
+	NL80211_STA_INFO_AIRTIME_WEIGHT,
+	NL80211_STA_INFO_AIRTIME_LINK_METRIC,
+	NL80211_STA_INFO_ASSOC_AT_BOOTTIME,
+
+	/* keep last */
+	__NL80211_STA_INFO_AFTER_LAST,
+	NL80211_STA_INFO_MAX = __NL80211_STA_INFO_AFTER_LAST - 1
+};
+
+/* we renamed this - stay compatible */
+#define NL80211_STA_INFO_DATA_ACK_SIGNAL_AVG NL80211_STA_INFO_ACK_SIGNAL_AVG
+
+
+/**
+ * enum nl80211_tid_stats - per TID statistics attributes
+ * @__NL80211_TID_STATS_INVALID: attribute number 0 is reserved
+ * @NL80211_TID_STATS_RX_MSDU: number of MSDUs received (u64)
+ * @NL80211_TID_STATS_TX_MSDU: number of MSDUs transmitted (or
+ *	attempted to transmit; u64)
+ * @NL80211_TID_STATS_TX_MSDU_RETRIES: number of retries for
+ *	transmitted MSDUs (not counting the first attempt; u64)
+ * @NL80211_TID_STATS_TX_MSDU_FAILED: number of failed transmitted
+ *	MSDUs (u64)
+ * @NL80211_TID_STATS_PAD: attribute used for padding for 64-bit alignment
+ * @NL80211_TID_STATS_TXQ_STATS: TXQ stats (nested attribute)
+ * @NUM_NL80211_TID_STATS: number of attributes here
+ * @NL80211_TID_STATS_MAX: highest numbered attribute here
+ */
+enum nl80211_tid_stats {
+	__NL80211_TID_STATS_INVALID,
+	NL80211_TID_STATS_RX_MSDU,
+	NL80211_TID_STATS_TX_MSDU,
+	NL80211_TID_STATS_TX_MSDU_RETRIES,
+	NL80211_TID_STATS_TX_MSDU_FAILED,
+	NL80211_TID_STATS_PAD,
+	NL80211_TID_STATS_TXQ_STATS,
+
+	/* keep last */
+	NUM_NL80211_TID_STATS,
+	NL80211_TID_STATS_MAX = NUM_NL80211_TID_STATS - 1
+};
+
+/**
+ * enum nl80211_txq_stats - per TXQ statistics attributes
+ * @__NL80211_TXQ_STATS_INVALID: attribute number 0 is reserved
+ * @NUM_NL80211_TXQ_STATS: number of attributes here
+ * @NL80211_TXQ_STATS_BACKLOG_BYTES: number of bytes currently backlogged
+ * @NL80211_TXQ_STATS_BACKLOG_PACKETS: number of packets currently
+ *      backlogged
+ * @NL80211_TXQ_STATS_FLOWS: total number of new flows seen
+ * @NL80211_TXQ_STATS_DROPS: total number of packet drops
+ * @NL80211_TXQ_STATS_ECN_MARKS: total number of packet ECN marks
+ * @NL80211_TXQ_STATS_OVERLIMIT: number of drops due to queue space overflow
+ * @NL80211_TXQ_STATS_OVERMEMORY: number of drops due to memory limit overflow
+ *      (only for per-phy stats)
+ * @NL80211_TXQ_STATS_COLLISIONS: number of hash collisions
+ * @NL80211_TXQ_STATS_TX_BYTES: total number of bytes dequeued from TXQ
+ * @NL80211_TXQ_STATS_TX_PACKETS: total number of packets dequeued from TXQ
+ * @NL80211_TXQ_STATS_MAX_FLOWS: number of flow buckets for PHY
+ * @NL80211_TXQ_STATS_MAX: highest numbered attribute here
+ */
+enum nl80211_txq_stats {
+	__NL80211_TXQ_STATS_INVALID,
+	NL80211_TXQ_STATS_BACKLOG_BYTES,
+	NL80211_TXQ_STATS_BACKLOG_PACKETS,
+	NL80211_TXQ_STATS_FLOWS,
+	NL80211_TXQ_STATS_DROPS,
+	NL80211_TXQ_STATS_ECN_MARKS,
+	NL80211_TXQ_STATS_OVERLIMIT,
+	NL80211_TXQ_STATS_OVERMEMORY,
+	NL80211_TXQ_STATS_COLLISIONS,
+	NL80211_TXQ_STATS_TX_BYTES,
+	NL80211_TXQ_STATS_TX_PACKETS,
+	NL80211_TXQ_STATS_MAX_FLOWS,
+
+	/* keep last */
+	NUM_NL80211_TXQ_STATS,
+	NL80211_TXQ_STATS_MAX = NUM_NL80211_TXQ_STATS - 1
+};
+
+/**
+ * enum nl80211_mpath_flags - nl80211 mesh path flags
+ *
+ * @NL80211_MPATH_FLAG_ACTIVE: the mesh path is active
+ * @NL80211_MPATH_FLAG_RESOLVING: the mesh path discovery process is running
+ * @NL80211_MPATH_FLAG_SN_VALID: the mesh path contains a valid SN
+ * @NL80211_MPATH_FLAG_FIXED: the mesh path has been manually set
+ * @NL80211_MPATH_FLAG_RESOLVED: the mesh path discovery process succeeded
+ */
+enum nl80211_mpath_flags {
+	NL80211_MPATH_FLAG_ACTIVE =	1<<0,
+	NL80211_MPATH_FLAG_RESOLVING =	1<<1,
+	NL80211_MPATH_FLAG_SN_VALID =	1<<2,
+	NL80211_MPATH_FLAG_FIXED =	1<<3,
+	NL80211_MPATH_FLAG_RESOLVED =	1<<4,
+};
+
+/**
+ * enum nl80211_mpath_info - mesh path information
+ *
+ * These attribute types are used with %NL80211_ATTR_MPATH_INFO when getting
+ * information about a mesh path.
+ *
+ * @__NL80211_MPATH_INFO_INVALID: attribute number 0 is reserved
+ * @NL80211_MPATH_INFO_FRAME_QLEN: number of queued frames for this destination
+ * @NL80211_MPATH_INFO_SN: destination sequence number
+ * @NL80211_MPATH_INFO_METRIC: metric (cost) of this mesh path
+ * @NL80211_MPATH_INFO_EXPTIME: expiration time for the path, in msec from now
+ * @NL80211_MPATH_INFO_FLAGS: mesh path flags, enumerated in
+ * 	&enum nl80211_mpath_flags;
+ * @NL80211_MPATH_INFO_DISCOVERY_TIMEOUT: total path discovery timeout, in msec
+ * @NL80211_MPATH_INFO_DISCOVERY_RETRIES: mesh path discovery retries
+ * @NL80211_MPATH_INFO_HOP_COUNT: hop count to destination
+ * @NL80211_MPATH_INFO_PATH_CHANGE: total number of path changes to destination
+ * @NL80211_MPATH_INFO_MAX: highest mesh path information attribute number
+ *	currently defined
+ * @__NL80211_MPATH_INFO_AFTER_LAST: internal use
+ */
+enum nl80211_mpath_info {
+	__NL80211_MPATH_INFO_INVALID,
+	NL80211_MPATH_INFO_FRAME_QLEN,
+	NL80211_MPATH_INFO_SN,
+	NL80211_MPATH_INFO_METRIC,
+	NL80211_MPATH_INFO_EXPTIME,
+	NL80211_MPATH_INFO_FLAGS,
+	NL80211_MPATH_INFO_DISCOVERY_TIMEOUT,
+	NL80211_MPATH_INFO_DISCOVERY_RETRIES,
+	NL80211_MPATH_INFO_HOP_COUNT,
+	NL80211_MPATH_INFO_PATH_CHANGE,
+
+	/* keep last */
+	__NL80211_MPATH_INFO_AFTER_LAST,
+	NL80211_MPATH_INFO_MAX = __NL80211_MPATH_INFO_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_band_iftype_attr - Interface type data attributes
+ *
+ * @__NL80211_BAND_IFTYPE_ATTR_INVALID: attribute number 0 is reserved
+ * @NL80211_BAND_IFTYPE_ATTR_IFTYPES: nested attribute containing a flag attribute
+ *     for each interface type that supports the band data
+ * @NL80211_BAND_IFTYPE_ATTR_HE_CAP_MAC: HE MAC capabilities as in HE
+ *     capabilities IE
+ * @NL80211_BAND_IFTYPE_ATTR_HE_CAP_PHY: HE PHY capabilities as in HE
+ *     capabilities IE
+ * @NL80211_BAND_IFTYPE_ATTR_HE_CAP_MCS_SET: HE supported NSS/MCS as in HE
+ *     capabilities IE
+ * @NL80211_BAND_IFTYPE_ATTR_HE_CAP_PPE: HE PPE thresholds information as
+ *     defined in HE capabilities IE
+ * @NL80211_BAND_IFTYPE_ATTR_MAX: highest band HE capability attribute currently
+ *     defined
+ * @NL80211_BAND_IFTYPE_ATTR_HE_6GHZ_CAPA: HE 6GHz band capabilities (__le16),
+ *	given for all 6 GHz band channels
+ * @__NL80211_BAND_IFTYPE_ATTR_AFTER_LAST: internal use
+ */
+enum nl80211_band_iftype_attr {
+	__NL80211_BAND_IFTYPE_ATTR_INVALID,
+
+	NL80211_BAND_IFTYPE_ATTR_IFTYPES,
+	NL80211_BAND_IFTYPE_ATTR_HE_CAP_MAC,
+	NL80211_BAND_IFTYPE_ATTR_HE_CAP_PHY,
+	NL80211_BAND_IFTYPE_ATTR_HE_CAP_MCS_SET,
+	NL80211_BAND_IFTYPE_ATTR_HE_CAP_PPE,
+	NL80211_BAND_IFTYPE_ATTR_HE_6GHZ_CAPA,
+
+	/* keep last */
+	__NL80211_BAND_IFTYPE_ATTR_AFTER_LAST,
+	NL80211_BAND_IFTYPE_ATTR_MAX = __NL80211_BAND_IFTYPE_ATTR_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_band_attr - band attributes
+ * @__NL80211_BAND_ATTR_INVALID: attribute number 0 is reserved
+ * @NL80211_BAND_ATTR_FREQS: supported frequencies in this band,
+ *	an array of nested frequency attributes
+ * @NL80211_BAND_ATTR_RATES: supported bitrates in this band,
+ *	an array of nested bitrate attributes
+ * @NL80211_BAND_ATTR_HT_MCS_SET: 16-byte attribute containing the MCS set as
+ *	defined in 802.11n
+ * @NL80211_BAND_ATTR_HT_CAPA: HT capabilities, as in the HT information IE
+ * @NL80211_BAND_ATTR_HT_AMPDU_FACTOR: A-MPDU factor, as in 11n
+ * @NL80211_BAND_ATTR_HT_AMPDU_DENSITY: A-MPDU density, as in 11n
+ * @NL80211_BAND_ATTR_VHT_MCS_SET: 32-byte attribute containing the MCS set as
+ *	defined in 802.11ac
+ * @NL80211_BAND_ATTR_VHT_CAPA: VHT capabilities, as in the HT information IE
+ * @NL80211_BAND_ATTR_IFTYPE_DATA: nested array attribute, with each entry using
+ *	attributes from &enum nl80211_band_iftype_attr
+ * @NL80211_BAND_ATTR_EDMG_CHANNELS: bitmap that indicates the 2.16 GHz
+ *	channel(s) that are allowed to be used for EDMG transmissions.
+ *	Defined by IEEE P802.11ay/D4.0 section 9.4.2.251.
+ * @NL80211_BAND_ATTR_EDMG_BW_CONFIG: Channel BW Configuration subfield encodes
+ *	the allowed channel bandwidth configurations.
+ *	Defined by IEEE P802.11ay/D4.0 section 9.4.2.251, Table 13.
+ * @NL80211_BAND_ATTR_MAX: highest band attribute currently defined
+ * @__NL80211_BAND_ATTR_AFTER_LAST: internal use
+ */
+enum nl80211_band_attr {
+	__NL80211_BAND_ATTR_INVALID,
+	NL80211_BAND_ATTR_FREQS,
+	NL80211_BAND_ATTR_RATES,
+
+	NL80211_BAND_ATTR_HT_MCS_SET,
+	NL80211_BAND_ATTR_HT_CAPA,
+	NL80211_BAND_ATTR_HT_AMPDU_FACTOR,
+	NL80211_BAND_ATTR_HT_AMPDU_DENSITY,
+
+	NL80211_BAND_ATTR_VHT_MCS_SET,
+	NL80211_BAND_ATTR_VHT_CAPA,
+	NL80211_BAND_ATTR_IFTYPE_DATA,
+
+	NL80211_BAND_ATTR_EDMG_CHANNELS,
+	NL80211_BAND_ATTR_EDMG_BW_CONFIG,
+
+	/* keep last */
+	__NL80211_BAND_ATTR_AFTER_LAST,
+	NL80211_BAND_ATTR_MAX = __NL80211_BAND_ATTR_AFTER_LAST - 1
+};
+
+#define NL80211_BAND_ATTR_HT_CAPA NL80211_BAND_ATTR_HT_CAPA
+
+/**
+ * enum nl80211_wmm_rule - regulatory wmm rule
+ *
+ * @__NL80211_WMMR_INVALID: attribute number 0 is reserved
+ * @NL80211_WMMR_CW_MIN: Minimum contention window slot.
+ * @NL80211_WMMR_CW_MAX: Maximum contention window slot.
+ * @NL80211_WMMR_AIFSN: Arbitration Inter Frame Space.
+ * @NL80211_WMMR_TXOP: Maximum allowed tx operation time.
+ * @nl80211_WMMR_MAX: highest possible wmm rule.
+ * @__NL80211_WMMR_LAST: Internal use.
+ */
+enum nl80211_wmm_rule {
+	__NL80211_WMMR_INVALID,
+	NL80211_WMMR_CW_MIN,
+	NL80211_WMMR_CW_MAX,
+	NL80211_WMMR_AIFSN,
+	NL80211_WMMR_TXOP,
+
+	/* keep last */
+	__NL80211_WMMR_LAST,
+	NL80211_WMMR_MAX = __NL80211_WMMR_LAST - 1
+};
+
+/**
+ * enum nl80211_frequency_attr - frequency attributes
+ * @__NL80211_FREQUENCY_ATTR_INVALID: attribute number 0 is reserved
+ * @NL80211_FREQUENCY_ATTR_FREQ: Frequency in MHz
+ * @NL80211_FREQUENCY_ATTR_DISABLED: Channel is disabled in current
+ *	regulatory domain.
+ * @NL80211_FREQUENCY_ATTR_NO_IR: no mechanisms that initiate radiation
+ * 	are permitted on this channel, this includes sending probe
+ * 	requests, or modes of operation that require beaconing.
+ * @NL80211_FREQUENCY_ATTR_RADAR: Radar detection is mandatory
+ *	on this channel in current regulatory domain.
+ * @NL80211_FREQUENCY_ATTR_MAX_TX_POWER: Maximum transmission power in mBm
+ *	(100 * dBm).
+ * @NL80211_FREQUENCY_ATTR_DFS_STATE: current state for DFS
+ *	(enum nl80211_dfs_state)
+ * @NL80211_FREQUENCY_ATTR_DFS_TIME: time in miliseconds for how long
+ *	this channel is in this DFS state.
+ * @NL80211_FREQUENCY_ATTR_NO_HT40_MINUS: HT40- isn't possible with this
+ *	channel as the control channel
+ * @NL80211_FREQUENCY_ATTR_NO_HT40_PLUS: HT40+ isn't possible with this
+ *	channel as the control channel
+ * @NL80211_FREQUENCY_ATTR_NO_80MHZ: any 80 MHz channel using this channel
+ *	as the primary or any of the secondary channels isn't possible,
+ *	this includes 80+80 channels
+ * @NL80211_FREQUENCY_ATTR_NO_160MHZ: any 160 MHz (but not 80+80) channel
+ *	using this channel as the primary or any of the secondary channels
+ *	isn't possible
+ * @NL80211_FREQUENCY_ATTR_DFS_CAC_TIME: DFS CAC time in milliseconds.
+ * @NL80211_FREQUENCY_ATTR_INDOOR_ONLY: Only indoor use is permitted on this
+ *	channel. A channel that has the INDOOR_ONLY attribute can only be
+ *	used when there is a clear assessment that the device is operating in
+ *	an indoor surroundings, i.e., it is connected to AC power (and not
+ *	through portable DC inverters) or is under the control of a master
+ *	that is acting as an AP and is connected to AC power.
+ * @NL80211_FREQUENCY_ATTR_IR_CONCURRENT: IR operation is allowed on this
+ *	channel if it's connected concurrently to a BSS on the same channel on
+ *	the 2 GHz band or to a channel in the same UNII band (on the 5 GHz
+ *	band), and IEEE80211_CHAN_RADAR is not set. Instantiating a GO or TDLS
+ *	off-channel on a channel that has the IR_CONCURRENT attribute set can be
+ *	done when there is a clear assessment that the device is operating under
+ *	the guidance of an authorized master, i.e., setting up a GO or TDLS
+ *	off-channel while the device is also connected to an AP with DFS and
+ *	radar detection on the UNII band (it is up to user-space, i.e.,
+ *	wpa_supplicant to perform the required verifications). Using this
+ *	attribute for IR is disallowed for master interfaces (IBSS, AP).
+ * @NL80211_FREQUENCY_ATTR_NO_20MHZ: 20 MHz operation is not allowed
+ *	on this channel in current regulatory domain.
+ * @NL80211_FREQUENCY_ATTR_NO_10MHZ: 10 MHz operation is not allowed
+ *	on this channel in current regulatory domain.
+ * @NL80211_FREQUENCY_ATTR_WMM: this channel has wmm limitations.
+ *	This is a nested attribute that contains the wmm limitation per AC.
+ *	(see &enum nl80211_wmm_rule)
+ * @NL80211_FREQUENCY_ATTR_MAX: highest frequency attribute number
+ *	currently defined
+ * @__NL80211_FREQUENCY_ATTR_AFTER_LAST: internal use
+ *
+ * See https://apps.fcc.gov/eas/comments/GetPublishedDocument.html?id=327&tn=528122
+ * for more information on the FCC description of the relaxations allowed
+ * by NL80211_FREQUENCY_ATTR_INDOOR_ONLY and
+ * NL80211_FREQUENCY_ATTR_IR_CONCURRENT.
+ */
+enum nl80211_frequency_attr {
+	__NL80211_FREQUENCY_ATTR_INVALID,
+	NL80211_FREQUENCY_ATTR_FREQ,
+	NL80211_FREQUENCY_ATTR_DISABLED,
+	NL80211_FREQUENCY_ATTR_NO_IR,
+	__NL80211_FREQUENCY_ATTR_NO_IBSS,
+	NL80211_FREQUENCY_ATTR_RADAR,
+	NL80211_FREQUENCY_ATTR_MAX_TX_POWER,
+	NL80211_FREQUENCY_ATTR_DFS_STATE,
+	NL80211_FREQUENCY_ATTR_DFS_TIME,
+	NL80211_FREQUENCY_ATTR_NO_HT40_MINUS,
+	NL80211_FREQUENCY_ATTR_NO_HT40_PLUS,
+	NL80211_FREQUENCY_ATTR_NO_80MHZ,
+	NL80211_FREQUENCY_ATTR_NO_160MHZ,
+	NL80211_FREQUENCY_ATTR_DFS_CAC_TIME,
+	NL80211_FREQUENCY_ATTR_INDOOR_ONLY,
+	NL80211_FREQUENCY_ATTR_IR_CONCURRENT,
+	NL80211_FREQUENCY_ATTR_NO_20MHZ,
+	NL80211_FREQUENCY_ATTR_NO_10MHZ,
+	NL80211_FREQUENCY_ATTR_WMM,
+
+	/* keep last */
+	__NL80211_FREQUENCY_ATTR_AFTER_LAST,
+	NL80211_FREQUENCY_ATTR_MAX = __NL80211_FREQUENCY_ATTR_AFTER_LAST - 1
+};
+
+#define NL80211_FREQUENCY_ATTR_MAX_TX_POWER NL80211_FREQUENCY_ATTR_MAX_TX_POWER
+#define NL80211_FREQUENCY_ATTR_PASSIVE_SCAN	NL80211_FREQUENCY_ATTR_NO_IR
+#define NL80211_FREQUENCY_ATTR_NO_IBSS		NL80211_FREQUENCY_ATTR_NO_IR
+#define NL80211_FREQUENCY_ATTR_NO_IR		NL80211_FREQUENCY_ATTR_NO_IR
+#define NL80211_FREQUENCY_ATTR_GO_CONCURRENT \
+					NL80211_FREQUENCY_ATTR_IR_CONCURRENT
+
+/**
+ * enum nl80211_bitrate_attr - bitrate attributes
+ * @__NL80211_BITRATE_ATTR_INVALID: attribute number 0 is reserved
+ * @NL80211_BITRATE_ATTR_RATE: Bitrate in units of 100 kbps
+ * @NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE: Short preamble supported
+ *	in 2.4 GHz band.
+ * @NL80211_BITRATE_ATTR_MAX: highest bitrate attribute number
+ *	currently defined
+ * @__NL80211_BITRATE_ATTR_AFTER_LAST: internal use
+ */
+enum nl80211_bitrate_attr {
+	__NL80211_BITRATE_ATTR_INVALID,
+	NL80211_BITRATE_ATTR_RATE,
+	NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE,
+
+	/* keep last */
+	__NL80211_BITRATE_ATTR_AFTER_LAST,
+	NL80211_BITRATE_ATTR_MAX = __NL80211_BITRATE_ATTR_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_initiator - Indicates the initiator of a reg domain request
+ * @NL80211_REGDOM_SET_BY_CORE: Core queried CRDA for a dynamic world
+ * 	regulatory domain.
+ * @NL80211_REGDOM_SET_BY_USER: User asked the wireless core to set the
+ * 	regulatory domain.
+ * @NL80211_REGDOM_SET_BY_DRIVER: a wireless drivers has hinted to the
+ * 	wireless core it thinks its knows the regulatory domain we should be in.
+ * @NL80211_REGDOM_SET_BY_COUNTRY_IE: the wireless core has received an
+ * 	802.11 country information element with regulatory information it
+ * 	thinks we should consider. cfg80211 only processes the country
+ *	code from the IE, and relies on the regulatory domain information
+ *	structure passed by userspace (CRDA) from our wireless-regdb.
+ *	If a channel is enabled but the country code indicates it should
+ *	be disabled we disable the channel and re-enable it upon disassociation.
+ */
+enum nl80211_reg_initiator {
+	NL80211_REGDOM_SET_BY_CORE,
+	NL80211_REGDOM_SET_BY_USER,
+	NL80211_REGDOM_SET_BY_DRIVER,
+	NL80211_REGDOM_SET_BY_COUNTRY_IE,
+};
+
+/**
+ * enum nl80211_reg_type - specifies the type of regulatory domain
+ * @NL80211_REGDOM_TYPE_COUNTRY: the regulatory domain set is one that pertains
+ *	to a specific country. When this is set you can count on the
+ *	ISO / IEC 3166 alpha2 country code being valid.
+ * @NL80211_REGDOM_TYPE_WORLD: the regulatory set domain is the world regulatory
+ * 	domain.
+ * @NL80211_REGDOM_TYPE_CUSTOM_WORLD: the regulatory domain set is a custom
+ * 	driver specific world regulatory domain. These do not apply system-wide
+ * 	and are only applicable to the individual devices which have requested
+ * 	them to be applied.
+ * @NL80211_REGDOM_TYPE_INTERSECTION: the regulatory domain set is the product
+ *	of an intersection between two regulatory domains -- the previously
+ *	set regulatory domain on the system and the last accepted regulatory
+ *	domain request to be processed.
+ */
+enum nl80211_reg_type {
+	NL80211_REGDOM_TYPE_COUNTRY,
+	NL80211_REGDOM_TYPE_WORLD,
+	NL80211_REGDOM_TYPE_CUSTOM_WORLD,
+	NL80211_REGDOM_TYPE_INTERSECTION,
+};
+
+/**
+ * enum nl80211_reg_rule_attr - regulatory rule attributes
+ * @__NL80211_REG_RULE_ATTR_INVALID: attribute number 0 is reserved
+ * @NL80211_ATTR_REG_RULE_FLAGS: a set of flags which specify additional
+ * 	considerations for a given frequency range. These are the
+ * 	&enum nl80211_reg_rule_flags.
+ * @NL80211_ATTR_FREQ_RANGE_START: starting frequencry for the regulatory
+ * 	rule in KHz. This is not a center of frequency but an actual regulatory
+ * 	band edge.
+ * @NL80211_ATTR_FREQ_RANGE_END: ending frequency for the regulatory rule
+ * 	in KHz. This is not a center a frequency but an actual regulatory
+ * 	band edge.
+ * @NL80211_ATTR_FREQ_RANGE_MAX_BW: maximum allowed bandwidth for this
+ *	frequency range, in KHz.
+ * @NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN: the maximum allowed antenna gain
+ * 	for a given frequency range. The value is in mBi (100 * dBi).
+ * 	If you don't have one then don't send this.
+ * @NL80211_ATTR_POWER_RULE_MAX_EIRP: the maximum allowed EIRP for
+ * 	a given frequency range. The value is in mBm (100 * dBm).
+ * @NL80211_ATTR_DFS_CAC_TIME: DFS CAC time in milliseconds.
+ *	If not present or 0 default CAC time will be used.
+ * @NL80211_REG_RULE_ATTR_MAX: highest regulatory rule attribute number
+ *	currently defined
+ * @__NL80211_REG_RULE_ATTR_AFTER_LAST: internal use
+ */
+enum nl80211_reg_rule_attr {
+	__NL80211_REG_RULE_ATTR_INVALID,
+	NL80211_ATTR_REG_RULE_FLAGS,
+
+	NL80211_ATTR_FREQ_RANGE_START,
+	NL80211_ATTR_FREQ_RANGE_END,
+	NL80211_ATTR_FREQ_RANGE_MAX_BW,
+
+	NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN,
+	NL80211_ATTR_POWER_RULE_MAX_EIRP,
+
+	NL80211_ATTR_DFS_CAC_TIME,
+
+	/* keep last */
+	__NL80211_REG_RULE_ATTR_AFTER_LAST,
+	NL80211_REG_RULE_ATTR_MAX = __NL80211_REG_RULE_ATTR_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_sched_scan_match_attr - scheduled scan match attributes
+ * @__NL80211_SCHED_SCAN_MATCH_ATTR_INVALID: attribute number 0 is reserved
+ * @NL80211_SCHED_SCAN_MATCH_ATTR_SSID: SSID to be used for matching,
+ *	only report BSS with matching SSID.
+ *	(This cannot be used together with BSSID.)
+ * @NL80211_SCHED_SCAN_MATCH_ATTR_RSSI: RSSI threshold (in dBm) for reporting a
+ *	BSS in scan results. Filtering is turned off if not specified. Note that
+ *	if this attribute is in a match set of its own, then it is treated as
+ *	the default value for all matchsets with an SSID, rather than being a
+ *	matchset of its own without an RSSI filter. This is due to problems with
+ *	how this API was implemented in the past. Also, due to the same problem,
+ *	the only way to create a matchset with only an RSSI filter (with this
+ *	attribute) is if there's only a single matchset with the RSSI attribute.
+ * @NL80211_SCHED_SCAN_MATCH_ATTR_RELATIVE_RSSI: Flag indicating whether
+ *	%NL80211_SCHED_SCAN_MATCH_ATTR_RSSI to be used as absolute RSSI or
+ *	relative to current bss's RSSI.
+ * @NL80211_SCHED_SCAN_MATCH_ATTR_RSSI_ADJUST: When present the RSSI level for
+ *	BSS-es in the specified band is to be adjusted before doing
+ *	RSSI-based BSS selection. The attribute value is a packed structure
+ *	value as specified by &struct nl80211_bss_select_rssi_adjust.
+ * @NL80211_SCHED_SCAN_MATCH_ATTR_BSSID: BSSID to be used for matching
+ *	(this cannot be used together with SSID).
+ * @NL80211_SCHED_SCAN_MATCH_PER_BAND_RSSI: Nested attribute that carries the
+ *	band specific minimum rssi thresholds for the bands defined in
+ *	enum nl80211_band. The minimum rssi threshold value(s32) specific to a
+ *	band shall be encapsulated in attribute with type value equals to one
+ *	of the NL80211_BAND_* defined in enum nl80211_band. For example, the
+ *	minimum rssi threshold value for 2.4GHZ band shall be encapsulated
+ *	within an attribute of type NL80211_BAND_2GHZ. And one or more of such
+ *	attributes will be nested within this attribute.
+ * @NL80211_SCHED_SCAN_MATCH_ATTR_MAX: highest scheduled scan filter
+ *	attribute number currently defined
+ * @__NL80211_SCHED_SCAN_MATCH_ATTR_AFTER_LAST: internal use
+ */
+enum nl80211_sched_scan_match_attr {
+	__NL80211_SCHED_SCAN_MATCH_ATTR_INVALID,
+
+	NL80211_SCHED_SCAN_MATCH_ATTR_SSID,
+	NL80211_SCHED_SCAN_MATCH_ATTR_RSSI,
+	NL80211_SCHED_SCAN_MATCH_ATTR_RELATIVE_RSSI,
+	NL80211_SCHED_SCAN_MATCH_ATTR_RSSI_ADJUST,
+	NL80211_SCHED_SCAN_MATCH_ATTR_BSSID,
+	NL80211_SCHED_SCAN_MATCH_PER_BAND_RSSI,
+
+	/* keep last */
+	__NL80211_SCHED_SCAN_MATCH_ATTR_AFTER_LAST,
+	NL80211_SCHED_SCAN_MATCH_ATTR_MAX =
+		__NL80211_SCHED_SCAN_MATCH_ATTR_AFTER_LAST - 1
+};
+
+/* only for backward compatibility */
+#define NL80211_ATTR_SCHED_SCAN_MATCH_SSID NL80211_SCHED_SCAN_MATCH_ATTR_SSID
+
+/**
+ * enum nl80211_reg_rule_flags - regulatory rule flags
+ *
+ * @NL80211_RRF_NO_OFDM: OFDM modulation not allowed
+ * @NL80211_RRF_NO_CCK: CCK modulation not allowed
+ * @NL80211_RRF_NO_INDOOR: indoor operation not allowed
+ * @NL80211_RRF_NO_OUTDOOR: outdoor operation not allowed
+ * @NL80211_RRF_DFS: DFS support is required to be used
+ * @NL80211_RRF_PTP_ONLY: this is only for Point To Point links
+ * @NL80211_RRF_PTMP_ONLY: this is only for Point To Multi Point links
+ * @NL80211_RRF_NO_IR: no mechanisms that initiate radiation are allowed,
+ * 	this includes probe requests or modes of operation that require
+ * 	beaconing.
+ * @NL80211_RRF_AUTO_BW: maximum available bandwidth should be calculated
+ *	base on contiguous rules and wider channels will be allowed to cross
+ *	multiple contiguous/overlapping frequency ranges.
+ * @NL80211_RRF_IR_CONCURRENT: See %NL80211_FREQUENCY_ATTR_IR_CONCURRENT
+ * @NL80211_RRF_NO_HT40MINUS: channels can't be used in HT40- operation
+ * @NL80211_RRF_NO_HT40PLUS: channels can't be used in HT40+ operation
+ * @NL80211_RRF_NO_80MHZ: 80MHz operation not allowed
+ * @NL80211_RRF_NO_160MHZ: 160MHz operation not allowed
+ */
+enum nl80211_reg_rule_flags {
+	NL80211_RRF_NO_OFDM		= 1<<0,
+	NL80211_RRF_NO_CCK		= 1<<1,
+	NL80211_RRF_NO_INDOOR		= 1<<2,
+	NL80211_RRF_NO_OUTDOOR		= 1<<3,
+	NL80211_RRF_DFS			= 1<<4,
+	NL80211_RRF_PTP_ONLY		= 1<<5,
+	NL80211_RRF_PTMP_ONLY		= 1<<6,
+	NL80211_RRF_NO_IR		= 1<<7,
+	__NL80211_RRF_NO_IBSS		= 1<<8,
+	NL80211_RRF_AUTO_BW		= 1<<11,
+	NL80211_RRF_IR_CONCURRENT	= 1<<12,
+	NL80211_RRF_NO_HT40MINUS	= 1<<13,
+	NL80211_RRF_NO_HT40PLUS		= 1<<14,
+	NL80211_RRF_NO_80MHZ		= 1<<15,
+	NL80211_RRF_NO_160MHZ		= 1<<16,
+};
+
+#define NL80211_RRF_PASSIVE_SCAN	NL80211_RRF_NO_IR
+#define NL80211_RRF_NO_IBSS		NL80211_RRF_NO_IR
+#define NL80211_RRF_NO_IR		NL80211_RRF_NO_IR
+#define NL80211_RRF_NO_HT40		(NL80211_RRF_NO_HT40MINUS |\
+					 NL80211_RRF_NO_HT40PLUS)
+#define NL80211_RRF_GO_CONCURRENT	NL80211_RRF_IR_CONCURRENT
+
+/* For backport compatibility with older userspace */
+#define NL80211_RRF_NO_IR_ALL		(NL80211_RRF_NO_IR | __NL80211_RRF_NO_IBSS)
+
+/**
+ * enum nl80211_dfs_regions - regulatory DFS regions
+ *
+ * @NL80211_DFS_UNSET: Country has no DFS master region specified
+ * @NL80211_DFS_FCC: Country follows DFS master rules from FCC
+ * @NL80211_DFS_ETSI: Country follows DFS master rules from ETSI
+ * @NL80211_DFS_JP: Country follows DFS master rules from JP/MKK/Telec
+ */
+enum nl80211_dfs_regions {
+	NL80211_DFS_UNSET	= 0,
+	NL80211_DFS_FCC		= 1,
+	NL80211_DFS_ETSI	= 2,
+	NL80211_DFS_JP		= 3,
+};
+
+/**
+ * enum nl80211_user_reg_hint_type - type of user regulatory hint
+ *
+ * @NL80211_USER_REG_HINT_USER: a user sent the hint. This is always
+ *	assumed if the attribute is not set.
+ * @NL80211_USER_REG_HINT_CELL_BASE: the hint comes from a cellular
+ *	base station. Device drivers that have been tested to work
+ *	properly to support this type of hint can enable these hints
+ *	by setting the NL80211_FEATURE_CELL_BASE_REG_HINTS feature
+ *	capability on the struct wiphy. The wireless core will
+ *	ignore all cell base station hints until at least one device
+ *	present has been registered with the wireless core that
+ *	has listed NL80211_FEATURE_CELL_BASE_REG_HINTS as a
+ *	supported feature.
+ * @NL80211_USER_REG_HINT_INDOOR: a user sent an hint indicating that the
+ *	platform is operating in an indoor environment.
+ */
+enum nl80211_user_reg_hint_type {
+	NL80211_USER_REG_HINT_USER	= 0,
+	NL80211_USER_REG_HINT_CELL_BASE = 1,
+	NL80211_USER_REG_HINT_INDOOR    = 2,
+};
+
+/**
+ * enum nl80211_survey_info - survey information
+ *
+ * These attribute types are used with %NL80211_ATTR_SURVEY_INFO
+ * when getting information about a survey.
+ *
+ * @__NL80211_SURVEY_INFO_INVALID: attribute number 0 is reserved
+ * @NL80211_SURVEY_INFO_FREQUENCY: center frequency of channel
+ * @NL80211_SURVEY_INFO_NOISE: noise level of channel (u8, dBm)
+ * @NL80211_SURVEY_INFO_IN_USE: channel is currently being used
+ * @NL80211_SURVEY_INFO_TIME: amount of time (in ms) that the radio
+ *	was turned on (on channel or globally)
+ * @NL80211_SURVEY_INFO_TIME_BUSY: amount of the time the primary
+ *	channel was sensed busy (either due to activity or energy detect)
+ * @NL80211_SURVEY_INFO_TIME_EXT_BUSY: amount of time the extension
+ *	channel was sensed busy
+ * @NL80211_SURVEY_INFO_TIME_RX: amount of time the radio spent
+ *	receiving data (on channel or globally)
+ * @NL80211_SURVEY_INFO_TIME_TX: amount of time the radio spent
+ *	transmitting data (on channel or globally)
+ * @NL80211_SURVEY_INFO_TIME_SCAN: time the radio spent for scan
+ *	(on this channel or globally)
+ * @NL80211_SURVEY_INFO_PAD: attribute used for padding for 64-bit alignment
+ * @NL80211_SURVEY_INFO_TIME_BSS_RX: amount of time the radio spent
+ *	receiving frames destined to the local BSS
+ * @NL80211_SURVEY_INFO_MAX: highest survey info attribute number
+ *	currently defined
+ * @__NL80211_SURVEY_INFO_AFTER_LAST: internal use
+ */
+enum nl80211_survey_info {
+	__NL80211_SURVEY_INFO_INVALID,
+	NL80211_SURVEY_INFO_FREQUENCY,
+	NL80211_SURVEY_INFO_NOISE,
+	NL80211_SURVEY_INFO_IN_USE,
+	NL80211_SURVEY_INFO_TIME,
+	NL80211_SURVEY_INFO_TIME_BUSY,
+	NL80211_SURVEY_INFO_TIME_EXT_BUSY,
+	NL80211_SURVEY_INFO_TIME_RX,
+	NL80211_SURVEY_INFO_TIME_TX,
+	NL80211_SURVEY_INFO_TIME_SCAN,
+	NL80211_SURVEY_INFO_PAD,
+	NL80211_SURVEY_INFO_TIME_BSS_RX,
+
+	/* keep last */
+	__NL80211_SURVEY_INFO_AFTER_LAST,
+	NL80211_SURVEY_INFO_MAX = __NL80211_SURVEY_INFO_AFTER_LAST - 1
+};
+
+/* keep old names for compatibility */
+#define NL80211_SURVEY_INFO_CHANNEL_TIME		NL80211_SURVEY_INFO_TIME
+#define NL80211_SURVEY_INFO_CHANNEL_TIME_BUSY		NL80211_SURVEY_INFO_TIME_BUSY
+#define NL80211_SURVEY_INFO_CHANNEL_TIME_EXT_BUSY	NL80211_SURVEY_INFO_TIME_EXT_BUSY
+#define NL80211_SURVEY_INFO_CHANNEL_TIME_RX		NL80211_SURVEY_INFO_TIME_RX
+#define NL80211_SURVEY_INFO_CHANNEL_TIME_TX		NL80211_SURVEY_INFO_TIME_TX
+
+/**
+ * enum nl80211_mntr_flags - monitor configuration flags
+ *
+ * Monitor configuration flags.
+ *
+ * @__NL80211_MNTR_FLAG_INVALID: reserved
+ *
+ * @NL80211_MNTR_FLAG_FCSFAIL: pass frames with bad FCS
+ * @NL80211_MNTR_FLAG_PLCPFAIL: pass frames with bad PLCP
+ * @NL80211_MNTR_FLAG_CONTROL: pass control frames
+ * @NL80211_MNTR_FLAG_OTHER_BSS: disable BSSID filtering
+ * @NL80211_MNTR_FLAG_COOK_FRAMES: report frames after processing.
+ *	overrides all other flags.
+ * @NL80211_MNTR_FLAG_ACTIVE: use the configured MAC address
+ *	and ACK incoming unicast packets.
+ *
+ * @__NL80211_MNTR_FLAG_AFTER_LAST: internal use
+ * @NL80211_MNTR_FLAG_MAX: highest possible monitor flag
+ */
+enum nl80211_mntr_flags {
+	__NL80211_MNTR_FLAG_INVALID,
+	NL80211_MNTR_FLAG_FCSFAIL,
+	NL80211_MNTR_FLAG_PLCPFAIL,
+	NL80211_MNTR_FLAG_CONTROL,
+	NL80211_MNTR_FLAG_OTHER_BSS,
+	NL80211_MNTR_FLAG_COOK_FRAMES,
+	NL80211_MNTR_FLAG_ACTIVE,
+
+	/* keep last */
+	__NL80211_MNTR_FLAG_AFTER_LAST,
+	NL80211_MNTR_FLAG_MAX = __NL80211_MNTR_FLAG_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_mesh_power_mode - mesh power save modes
+ *
+ * @NL80211_MESH_POWER_UNKNOWN: The mesh power mode of the mesh STA is
+ *	not known or has not been set yet.
+ * @NL80211_MESH_POWER_ACTIVE: Active mesh power mode. The mesh STA is
+ *	in Awake state all the time.
+ * @NL80211_MESH_POWER_LIGHT_SLEEP: Light sleep mode. The mesh STA will
+ *	alternate between Active and Doze states, but will wake up for
+ *	neighbor's beacons.
+ * @NL80211_MESH_POWER_DEEP_SLEEP: Deep sleep mode. The mesh STA will
+ *	alternate between Active and Doze states, but may not wake up
+ *	for neighbor's beacons.
+ *
+ * @__NL80211_MESH_POWER_AFTER_LAST - internal use
+ * @NL80211_MESH_POWER_MAX - highest possible power save level
+ */
+
+enum nl80211_mesh_power_mode {
+	NL80211_MESH_POWER_UNKNOWN,
+	NL80211_MESH_POWER_ACTIVE,
+	NL80211_MESH_POWER_LIGHT_SLEEP,
+	NL80211_MESH_POWER_DEEP_SLEEP,
+
+	__NL80211_MESH_POWER_AFTER_LAST,
+	NL80211_MESH_POWER_MAX = __NL80211_MESH_POWER_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_meshconf_params - mesh configuration parameters
+ *
+ * Mesh configuration parameters. These can be changed while the mesh is
+ * active.
+ *
+ * @__NL80211_MESHCONF_INVALID: internal use
+ *
+ * @NL80211_MESHCONF_RETRY_TIMEOUT: specifies the initial retry timeout in
+ *	millisecond units, used by the Peer Link Open message
+ *
+ * @NL80211_MESHCONF_CONFIRM_TIMEOUT: specifies the initial confirm timeout, in
+ *	millisecond units, used by the peer link management to close a peer link
+ *
+ * @NL80211_MESHCONF_HOLDING_TIMEOUT: specifies the holding timeout, in
+ *	millisecond units
+ *
+ * @NL80211_MESHCONF_MAX_PEER_LINKS: maximum number of peer links allowed
+ *	on this mesh interface
+ *
+ * @NL80211_MESHCONF_MAX_RETRIES: specifies the maximum number of peer link
+ *	open retries that can be sent to establish a new peer link instance in a
+ *	mesh
+ *
+ * @NL80211_MESHCONF_TTL: specifies the value of TTL field set at a source mesh
+ *	point.
+ *
+ * @NL80211_MESHCONF_AUTO_OPEN_PLINKS: whether we should automatically open
+ *	peer links when we detect compatible mesh peers. Disabled if
+ *	@NL80211_MESH_SETUP_USERSPACE_MPM or @NL80211_MESH_SETUP_USERSPACE_AMPE are
+ *	set.
+ *
+ * @NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES: the number of action frames
+ *	containing a PREQ that an MP can send to a particular destination (path
+ *	target)
+ *
+ * @NL80211_MESHCONF_PATH_REFRESH_TIME: how frequently to refresh mesh paths
+ *	(in milliseconds)
+ *
+ * @NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT: minimum length of time to wait
+ *	until giving up on a path discovery (in milliseconds)
+ *
+ * @NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT: The time (in TUs) for which mesh
+ *	points receiving a PREQ shall consider the forwarding information from
+ *	the root to be valid. (TU = time unit)
+ *
+ * @NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL: The minimum interval of time (in
+ *	TUs) during which an MP can send only one action frame containing a PREQ
+ *	reference element
+ *
+ * @NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME: The interval of time (in TUs)
+ *	that it takes for an HWMP information element to propagate across the
+ *	mesh
+ *
+ * @NL80211_MESHCONF_HWMP_ROOTMODE: whether root mode is enabled or not
+ *
+ * @NL80211_MESHCONF_ELEMENT_TTL: specifies the value of TTL field set at a
+ *	source mesh point for path selection elements.
+ *
+ * @NL80211_MESHCONF_HWMP_RANN_INTERVAL:  The interval of time (in TUs) between
+ *	root announcements are transmitted.
+ *
+ * @NL80211_MESHCONF_GATE_ANNOUNCEMENTS: Advertise that this mesh station has
+ *	access to a broader network beyond the MBSS.  This is done via Root
+ *	Announcement frames.
+ *
+ * @NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL: The minimum interval of time (in
+ *	TUs) during which a mesh STA can send only one Action frame containing a
+ *	PERR element.
+ *
+ * @NL80211_MESHCONF_FORWARDING: set Mesh STA as forwarding or non-forwarding
+ *	or forwarding entity (default is TRUE - forwarding entity)
+ *
+ * @NL80211_MESHCONF_RSSI_THRESHOLD: RSSI threshold in dBm. This specifies the
+ *	threshold for average signal strength of candidate station to establish
+ *	a peer link.
+ *
+ * @NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR: maximum number of neighbors
+ *	to synchronize to for 11s default synchronization method
+ *	(see 11C.12.2.2)
+ *
+ * @NL80211_MESHCONF_HT_OPMODE: set mesh HT protection mode.
+ *
+ * @NL80211_MESHCONF_ATTR_MAX: highest possible mesh configuration attribute
+ *
+ * @NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT: The time (in TUs) for
+ *	which mesh STAs receiving a proactive PREQ shall consider the forwarding
+ *	information to the root mesh STA to be valid.
+ *
+ * @NL80211_MESHCONF_HWMP_ROOT_INTERVAL: The interval of time (in TUs) between
+ *	proactive PREQs are transmitted.
+ *
+ * @NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL: The minimum interval of time
+ *	(in TUs) during which a mesh STA can send only one Action frame
+ *	containing a PREQ element for root path confirmation.
+ *
+ * @NL80211_MESHCONF_POWER_MODE: Default mesh power mode for new peer links.
+ *	type &enum nl80211_mesh_power_mode (u32)
+ *
+ * @NL80211_MESHCONF_AWAKE_WINDOW: awake window duration (in TUs)
+ *
+ * @NL80211_MESHCONF_PLINK_TIMEOUT: If no tx activity is seen from a STA we've
+ *	established peering with for longer than this time (in seconds), then
+ *	remove it from the STA's list of peers. You may set this to 0 to disable
+ *	the removal of the STA. Default is 30 minutes.
+ *
+ * @NL80211_MESHCONF_CONNECTED_TO_GATE: If set to true then this mesh STA
+ *	will advertise that it is connected to a gate in the mesh formation
+ *	field.  If left unset then the mesh formation field will only
+ *	advertise such if there is an active root mesh path.
+ *
+ * @__NL80211_MESHCONF_ATTR_AFTER_LAST: internal use
+ */
+enum nl80211_meshconf_params {
+	__NL80211_MESHCONF_INVALID,
+	NL80211_MESHCONF_RETRY_TIMEOUT,
+	NL80211_MESHCONF_CONFIRM_TIMEOUT,
+	NL80211_MESHCONF_HOLDING_TIMEOUT,
+	NL80211_MESHCONF_MAX_PEER_LINKS,
+	NL80211_MESHCONF_MAX_RETRIES,
+	NL80211_MESHCONF_TTL,
+	NL80211_MESHCONF_AUTO_OPEN_PLINKS,
+	NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES,
+	NL80211_MESHCONF_PATH_REFRESH_TIME,
+	NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT,
+	NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT,
+	NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL,
+	NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME,
+	NL80211_MESHCONF_HWMP_ROOTMODE,
+	NL80211_MESHCONF_ELEMENT_TTL,
+	NL80211_MESHCONF_HWMP_RANN_INTERVAL,
+	NL80211_MESHCONF_GATE_ANNOUNCEMENTS,
+	NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL,
+	NL80211_MESHCONF_FORWARDING,
+	NL80211_MESHCONF_RSSI_THRESHOLD,
+	NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR,
+	NL80211_MESHCONF_HT_OPMODE,
+	NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT,
+	NL80211_MESHCONF_HWMP_ROOT_INTERVAL,
+	NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL,
+	NL80211_MESHCONF_POWER_MODE,
+	NL80211_MESHCONF_AWAKE_WINDOW,
+	NL80211_MESHCONF_PLINK_TIMEOUT,
+	NL80211_MESHCONF_CONNECTED_TO_GATE,
+
+	/* keep last */
+	__NL80211_MESHCONF_ATTR_AFTER_LAST,
+	NL80211_MESHCONF_ATTR_MAX = __NL80211_MESHCONF_ATTR_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_mesh_setup_params - mesh setup parameters
+ *
+ * Mesh setup parameters.  These are used to start/join a mesh and cannot be
+ * changed while the mesh is active.
+ *
+ * @__NL80211_MESH_SETUP_INVALID: Internal use
+ *
+ * @NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL: Enable this option to use a
+ *	vendor specific path selection algorithm or disable it to use the
+ *	default HWMP.
+ *
+ * @NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC: Enable this option to use a
+ *	vendor specific path metric or disable it to use the default Airtime
+ *	metric.
+ *
+ * @NL80211_MESH_SETUP_IE: Information elements for this mesh, for instance, a
+ *	robust security network ie, or a vendor specific information element
+ *	that vendors will use to identify the path selection methods and
+ *	metrics in use.
+ *
+ * @NL80211_MESH_SETUP_USERSPACE_AUTH: Enable this option if an authentication
+ *	daemon will be authenticating mesh candidates.
+ *
+ * @NL80211_MESH_SETUP_USERSPACE_AMPE: Enable this option if an authentication
+ *	daemon will be securing peer link frames.  AMPE is a secured version of
+ *	Mesh Peering Management (MPM) and is implemented with the assistance of
+ *	a userspace daemon.  When this flag is set, the kernel will send peer
+ *	management frames to a userspace daemon that will implement AMPE
+ *	functionality (security capabilities selection, key confirmation, and
+ *	key management).  When the flag is unset (default), the kernel can
+ *	autonomously complete (unsecured) mesh peering without the need of a
+ *	userspace daemon.
+ *
+ * @NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC: Enable this option to use a
+ *	vendor specific synchronization method or disable it to use the default
+ *	neighbor offset synchronization
+ *
+ * @NL80211_MESH_SETUP_USERSPACE_MPM: Enable this option if userspace will
+ *	implement an MPM which handles peer allocation and state.
+ *
+ * @NL80211_MESH_SETUP_AUTH_PROTOCOL: Inform the kernel of the authentication
+ *	method (u8, as defined in IEEE 8.4.2.100.6, e.g. 0x1 for SAE).
+ *	Default is no authentication method required.
+ *
+ * @NL80211_MESH_SETUP_ATTR_MAX: highest possible mesh setup attribute number
+ *
+ * @__NL80211_MESH_SETUP_ATTR_AFTER_LAST: Internal use
+ */
+enum nl80211_mesh_setup_params {
+	__NL80211_MESH_SETUP_INVALID,
+	NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL,
+	NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC,
+	NL80211_MESH_SETUP_IE,
+	NL80211_MESH_SETUP_USERSPACE_AUTH,
+	NL80211_MESH_SETUP_USERSPACE_AMPE,
+	NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC,
+	NL80211_MESH_SETUP_USERSPACE_MPM,
+	NL80211_MESH_SETUP_AUTH_PROTOCOL,
+
+	/* keep last */
+	__NL80211_MESH_SETUP_ATTR_AFTER_LAST,
+	NL80211_MESH_SETUP_ATTR_MAX = __NL80211_MESH_SETUP_ATTR_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_txq_attr - TX queue parameter attributes
+ * @__NL80211_TXQ_ATTR_INVALID: Attribute number 0 is reserved
+ * @NL80211_TXQ_ATTR_AC: AC identifier (NL80211_AC_*)
+ * @NL80211_TXQ_ATTR_TXOP: Maximum burst time in units of 32 usecs, 0 meaning
+ *	disabled
+ * @NL80211_TXQ_ATTR_CWMIN: Minimum contention window [a value of the form
+ *	2^n-1 in the range 1..32767]
+ * @NL80211_TXQ_ATTR_CWMAX: Maximum contention window [a value of the form
+ *	2^n-1 in the range 1..32767]
+ * @NL80211_TXQ_ATTR_AIFS: Arbitration interframe space [0..255]
+ * @__NL80211_TXQ_ATTR_AFTER_LAST: Internal
+ * @NL80211_TXQ_ATTR_MAX: Maximum TXQ attribute number
+ */
+enum nl80211_txq_attr {
+	__NL80211_TXQ_ATTR_INVALID,
+	NL80211_TXQ_ATTR_AC,
+	NL80211_TXQ_ATTR_TXOP,
+	NL80211_TXQ_ATTR_CWMIN,
+	NL80211_TXQ_ATTR_CWMAX,
+	NL80211_TXQ_ATTR_AIFS,
+
+	/* keep last */
+	__NL80211_TXQ_ATTR_AFTER_LAST,
+	NL80211_TXQ_ATTR_MAX = __NL80211_TXQ_ATTR_AFTER_LAST - 1
+};
+
+enum nl80211_ac {
+	NL80211_AC_VO,
+	NL80211_AC_VI,
+	NL80211_AC_BE,
+	NL80211_AC_BK,
+	NL80211_NUM_ACS
+};
+
+/* backward compat */
+#define NL80211_TXQ_ATTR_QUEUE	NL80211_TXQ_ATTR_AC
+#define NL80211_TXQ_Q_VO	NL80211_AC_VO
+#define NL80211_TXQ_Q_VI	NL80211_AC_VI
+#define NL80211_TXQ_Q_BE	NL80211_AC_BE
+#define NL80211_TXQ_Q_BK	NL80211_AC_BK
+
+/**
+ * enum nl80211_channel_type - channel type
+ * @NL80211_CHAN_NO_HT: 20 MHz, non-HT channel
+ * @NL80211_CHAN_HT20: 20 MHz HT channel
+ * @NL80211_CHAN_HT40MINUS: HT40 channel, secondary channel
+ *	below the control channel
+ * @NL80211_CHAN_HT40PLUS: HT40 channel, secondary channel
+ *	above the control channel
+ */
+enum nl80211_channel_type {
+	NL80211_CHAN_NO_HT,
+	NL80211_CHAN_HT20,
+	NL80211_CHAN_HT40MINUS,
+	NL80211_CHAN_HT40PLUS
+};
+
+/**
+ * enum nl80211_key_mode - Key mode
+ *
+ * @NL80211_KEY_RX_TX: (Default)
+ *	Key can be used for Rx and Tx immediately
+ *
+ * The following modes can only be selected for unicast keys and when the
+ * driver supports @NL80211_EXT_FEATURE_EXT_KEY_ID:
+ *
+ * @NL80211_KEY_NO_TX: Only allowed in combination with @NL80211_CMD_NEW_KEY:
+ *	Unicast key can only be used for Rx, Tx not allowed, yet
+ * @NL80211_KEY_SET_TX: Only allowed in combination with @NL80211_CMD_SET_KEY:
+ *	The unicast key identified by idx and mac is cleared for Tx and becomes
+ *	the preferred Tx key for the station.
+ */
+enum nl80211_key_mode {
+	NL80211_KEY_RX_TX,
+	NL80211_KEY_NO_TX,
+	NL80211_KEY_SET_TX
+};
+
+/**
+ * enum nl80211_chan_width - channel width definitions
+ *
+ * These values are used with the %NL80211_ATTR_CHANNEL_WIDTH
+ * attribute.
+ *
+ * @NL80211_CHAN_WIDTH_20_NOHT: 20 MHz, non-HT channel
+ * @NL80211_CHAN_WIDTH_20: 20 MHz HT channel
+ * @NL80211_CHAN_WIDTH_40: 40 MHz channel, the %NL80211_ATTR_CENTER_FREQ1
+ *	attribute must be provided as well
+ * @NL80211_CHAN_WIDTH_80: 80 MHz channel, the %NL80211_ATTR_CENTER_FREQ1
+ *	attribute must be provided as well
+ * @NL80211_CHAN_WIDTH_80P80: 80+80 MHz channel, the %NL80211_ATTR_CENTER_FREQ1
+ *	and %NL80211_ATTR_CENTER_FREQ2 attributes must be provided as well
+ * @NL80211_CHAN_WIDTH_160: 160 MHz channel, the %NL80211_ATTR_CENTER_FREQ1
+ *	attribute must be provided as well
+ * @NL80211_CHAN_WIDTH_5: 5 MHz OFDM channel
+ * @NL80211_CHAN_WIDTH_10: 10 MHz OFDM channel
+ */
+enum nl80211_chan_width {
+	NL80211_CHAN_WIDTH_20_NOHT,
+	NL80211_CHAN_WIDTH_20,
+	NL80211_CHAN_WIDTH_40,
+	NL80211_CHAN_WIDTH_80,
+	NL80211_CHAN_WIDTH_80P80,
+	NL80211_CHAN_WIDTH_160,
+	NL80211_CHAN_WIDTH_5,
+	NL80211_CHAN_WIDTH_10,
+};
+
+/**
+ * enum nl80211_bss_scan_width - control channel width for a BSS
+ *
+ * These values are used with the %NL80211_BSS_CHAN_WIDTH attribute.
+ *
+ * @NL80211_BSS_CHAN_WIDTH_20: control channel is 20 MHz wide or compatible
+ * @NL80211_BSS_CHAN_WIDTH_10: control channel is 10 MHz wide
+ * @NL80211_BSS_CHAN_WIDTH_5: control channel is 5 MHz wide
+ */
+enum nl80211_bss_scan_width {
+	NL80211_BSS_CHAN_WIDTH_20,
+	NL80211_BSS_CHAN_WIDTH_10,
+	NL80211_BSS_CHAN_WIDTH_5,
+};
+
+/**
+ * enum nl80211_bss - netlink attributes for a BSS
+ *
+ * @__NL80211_BSS_INVALID: invalid
+ * @NL80211_BSS_BSSID: BSSID of the BSS (6 octets)
+ * @NL80211_BSS_FREQUENCY: frequency in MHz (u32)
+ * @NL80211_BSS_TSF: TSF of the received probe response/beacon (u64)
+ *	(if @NL80211_BSS_PRESP_DATA is present then this is known to be
+ *	from a probe response, otherwise it may be from the same beacon
+ *	that the NL80211_BSS_BEACON_TSF will be from)
+ * @NL80211_BSS_BEACON_INTERVAL: beacon interval of the (I)BSS (u16)
+ * @NL80211_BSS_CAPABILITY: capability field (CPU order, u16)
+ * @NL80211_BSS_INFORMATION_ELEMENTS: binary attribute containing the
+ *	raw information elements from the probe response/beacon (bin);
+ *	if the %NL80211_BSS_BEACON_IES attribute is present and the data is
+ *	different then the IEs here are from a Probe Response frame; otherwise
+ *	they are from a Beacon frame.
+ *	However, if the driver does not indicate the source of the IEs, these
+ *	IEs may be from either frame subtype.
+ *	If present, the @NL80211_BSS_PRESP_DATA attribute indicates that the
+ *	data here is known to be from a probe response, without any heuristics.
+ * @NL80211_BSS_SIGNAL_MBM: signal strength of probe response/beacon
+ *	in mBm (100 * dBm) (s32)
+ * @NL80211_BSS_SIGNAL_UNSPEC: signal strength of the probe response/beacon
+ *	in unspecified units, scaled to 0..100 (u8)
+ * @NL80211_BSS_STATUS: status, if this BSS is "used"
+ * @NL80211_BSS_SEEN_MS_AGO: age of this BSS entry in ms
+ * @NL80211_BSS_BEACON_IES: binary attribute containing the raw information
+ *	elements from a Beacon frame (bin); not present if no Beacon frame has
+ *	yet been received
+ * @NL80211_BSS_CHAN_WIDTH: channel width of the control channel
+ *	(u32, enum nl80211_bss_scan_width)
+ * @NL80211_BSS_BEACON_TSF: TSF of the last received beacon (u64)
+ *	(not present if no beacon frame has been received yet)
+ * @NL80211_BSS_PRESP_DATA: the data in @NL80211_BSS_INFORMATION_ELEMENTS and
+ *	@NL80211_BSS_TSF is known to be from a probe response (flag attribute)
+ * @NL80211_BSS_LAST_SEEN_BOOTTIME: CLOCK_BOOTTIME timestamp when this entry
+ *	was last updated by a received frame. The value is expected to be
+ *	accurate to about 10ms. (u64, nanoseconds)
+ * @NL80211_BSS_PAD: attribute used for padding for 64-bit alignment
+ * @NL80211_BSS_PARENT_TSF: the time at the start of reception of the first
+ *	octet of the timestamp field of the last beacon/probe received for
+ *	this BSS. The time is the TSF of the BSS specified by
+ *	@NL80211_BSS_PARENT_BSSID. (u64).
+ * @NL80211_BSS_PARENT_BSSID: the BSS according to which @NL80211_BSS_PARENT_TSF
+ *	is set.
+ * @NL80211_BSS_CHAIN_SIGNAL: per-chain signal strength of last BSS update.
+ *	Contains a nested array of signal strength attributes (u8, dBm),
+ *	using the nesting index as the antenna number.
+ * @__NL80211_BSS_AFTER_LAST: internal
+ * @NL80211_BSS_MAX: highest BSS attribute
+ */
+enum nl80211_bss {
+	__NL80211_BSS_INVALID,
+	NL80211_BSS_BSSID,
+	NL80211_BSS_FREQUENCY,
+	NL80211_BSS_TSF,
+	NL80211_BSS_BEACON_INTERVAL,
+	NL80211_BSS_CAPABILITY,
+	NL80211_BSS_INFORMATION_ELEMENTS,
+	NL80211_BSS_SIGNAL_MBM,
+	NL80211_BSS_SIGNAL_UNSPEC,
+	NL80211_BSS_STATUS,
+	NL80211_BSS_SEEN_MS_AGO,
+	NL80211_BSS_BEACON_IES,
+	NL80211_BSS_CHAN_WIDTH,
+	NL80211_BSS_BEACON_TSF,
+	NL80211_BSS_PRESP_DATA,
+	NL80211_BSS_LAST_SEEN_BOOTTIME,
+	NL80211_BSS_PAD,
+	NL80211_BSS_PARENT_TSF,
+	NL80211_BSS_PARENT_BSSID,
+	NL80211_BSS_CHAIN_SIGNAL,
+
+	/* keep last */
+	__NL80211_BSS_AFTER_LAST,
+	NL80211_BSS_MAX = __NL80211_BSS_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_bss_status - BSS "status"
+ * @NL80211_BSS_STATUS_AUTHENTICATED: Authenticated with this BSS.
+ *	Note that this is no longer used since cfg80211 no longer
+ *	keeps track of whether or not authentication was done with
+ *	a given BSS.
+ * @NL80211_BSS_STATUS_ASSOCIATED: Associated with this BSS.
+ * @NL80211_BSS_STATUS_IBSS_JOINED: Joined to this IBSS.
+ *
+ * The BSS status is a BSS attribute in scan dumps, which
+ * indicates the status the interface has wrt. this BSS.
+ */
+enum nl80211_bss_status {
+	NL80211_BSS_STATUS_AUTHENTICATED,
+	NL80211_BSS_STATUS_ASSOCIATED,
+	NL80211_BSS_STATUS_IBSS_JOINED,
+};
+
+/**
+ * enum nl80211_auth_type - AuthenticationType
+ *
+ * @NL80211_AUTHTYPE_OPEN_SYSTEM: Open System authentication
+ * @NL80211_AUTHTYPE_SHARED_KEY: Shared Key authentication (WEP only)
+ * @NL80211_AUTHTYPE_FT: Fast BSS Transition (IEEE 802.11r)
+ * @NL80211_AUTHTYPE_NETWORK_EAP: Network EAP (some Cisco APs and mainly LEAP)
+ * @NL80211_AUTHTYPE_SAE: Simultaneous authentication of equals
+ * @NL80211_AUTHTYPE_FILS_SK: Fast Initial Link Setup shared key
+ * @NL80211_AUTHTYPE_FILS_SK_PFS: Fast Initial Link Setup shared key with PFS
+ * @NL80211_AUTHTYPE_FILS_PK: Fast Initial Link Setup public key
+ * @__NL80211_AUTHTYPE_NUM: internal
+ * @NL80211_AUTHTYPE_MAX: maximum valid auth algorithm
+ * @NL80211_AUTHTYPE_AUTOMATIC: determine automatically (if necessary by
+ *	trying multiple times); this is invalid in netlink -- leave out
+ *	the attribute for this on CONNECT commands.
+ */
+enum nl80211_auth_type {
+	NL80211_AUTHTYPE_OPEN_SYSTEM,
+	NL80211_AUTHTYPE_SHARED_KEY,
+	NL80211_AUTHTYPE_FT,
+	NL80211_AUTHTYPE_NETWORK_EAP,
+	NL80211_AUTHTYPE_SAE,
+	NL80211_AUTHTYPE_FILS_SK,
+	NL80211_AUTHTYPE_FILS_SK_PFS,
+	NL80211_AUTHTYPE_FILS_PK,
+
+	/* keep last */
+	__NL80211_AUTHTYPE_NUM,
+	NL80211_AUTHTYPE_MAX = __NL80211_AUTHTYPE_NUM - 1,
+	NL80211_AUTHTYPE_AUTOMATIC
+};
+
+/**
+ * enum nl80211_key_type - Key Type
+ * @NL80211_KEYTYPE_GROUP: Group (broadcast/multicast) key
+ * @NL80211_KEYTYPE_PAIRWISE: Pairwise (unicast/individual) key
+ * @NL80211_KEYTYPE_PEERKEY: PeerKey (DLS)
+ * @NUM_NL80211_KEYTYPES: number of defined key types
+ */
+enum nl80211_key_type {
+	NL80211_KEYTYPE_GROUP,
+	NL80211_KEYTYPE_PAIRWISE,
+	NL80211_KEYTYPE_PEERKEY,
+
+	NUM_NL80211_KEYTYPES
+};
+
+/**
+ * enum nl80211_mfp - Management frame protection state
+ * @NL80211_MFP_NO: Management frame protection not used
+ * @NL80211_MFP_REQUIRED: Management frame protection required
+ * @NL80211_MFP_OPTIONAL: Management frame protection is optional
+ */
+enum nl80211_mfp {
+	NL80211_MFP_NO,
+	NL80211_MFP_REQUIRED,
+	NL80211_MFP_OPTIONAL,
+};
+
+enum nl80211_wpa_versions {
+	NL80211_WPA_VERSION_1 = 1 << 0,
+	NL80211_WPA_VERSION_2 = 1 << 1,
+	NL80211_WPA_VERSION_3 = 1 << 2,
+};
+
+/**
+ * enum nl80211_key_default_types - key default types
+ * @__NL80211_KEY_DEFAULT_TYPE_INVALID: invalid
+ * @NL80211_KEY_DEFAULT_TYPE_UNICAST: key should be used as default
+ *	unicast key
+ * @NL80211_KEY_DEFAULT_TYPE_MULTICAST: key should be used as default
+ *	multicast key
+ * @NUM_NL80211_KEY_DEFAULT_TYPES: number of default types
+ */
+enum nl80211_key_default_types {
+	__NL80211_KEY_DEFAULT_TYPE_INVALID,
+	NL80211_KEY_DEFAULT_TYPE_UNICAST,
+	NL80211_KEY_DEFAULT_TYPE_MULTICAST,
+
+	NUM_NL80211_KEY_DEFAULT_TYPES
+};
+
+/**
+ * enum nl80211_key_attributes - key attributes
+ * @__NL80211_KEY_INVALID: invalid
+ * @NL80211_KEY_DATA: (temporal) key data; for TKIP this consists of
+ *	16 bytes encryption key followed by 8 bytes each for TX and RX MIC
+ *	keys
+ * @NL80211_KEY_IDX: key ID (u8, 0-3)
+ * @NL80211_KEY_CIPHER: key cipher suite (u32, as defined by IEEE 802.11
+ *	section 7.3.2.25.1, e.g. 0x000FAC04)
+ * @NL80211_KEY_SEQ: transmit key sequence number (IV/PN) for TKIP and
+ *	CCMP keys, each six bytes in little endian
+ * @NL80211_KEY_DEFAULT: flag indicating default key
+ * @NL80211_KEY_DEFAULT_MGMT: flag indicating default management key
+ * @NL80211_KEY_TYPE: the key type from enum nl80211_key_type, if not
+ *	specified the default depends on whether a MAC address was
+ *	given with the command using the key or not (u32)
+ * @NL80211_KEY_DEFAULT_TYPES: A nested attribute containing flags
+ *	attributes, specifying what a key should be set as default as.
+ *	See &enum nl80211_key_default_types.
+ * @NL80211_KEY_MODE: the mode from enum nl80211_key_mode.
+ *	Defaults to @NL80211_KEY_RX_TX.
+ * @NL80211_KEY_DEFAULT_BEACON: flag indicating default Beacon frame key
+ *
+ * @__NL80211_KEY_AFTER_LAST: internal
+ * @NL80211_KEY_MAX: highest key attribute
+ */
+enum nl80211_key_attributes {
+	__NL80211_KEY_INVALID,
+	NL80211_KEY_DATA,
+	NL80211_KEY_IDX,
+	NL80211_KEY_CIPHER,
+	NL80211_KEY_SEQ,
+	NL80211_KEY_DEFAULT,
+	NL80211_KEY_DEFAULT_MGMT,
+	NL80211_KEY_TYPE,
+	NL80211_KEY_DEFAULT_TYPES,
+	NL80211_KEY_MODE,
+	NL80211_KEY_DEFAULT_BEACON,
+
+	/* keep last */
+	__NL80211_KEY_AFTER_LAST,
+	NL80211_KEY_MAX = __NL80211_KEY_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_tx_rate_attributes - TX rate set attributes
+ * @__NL80211_TXRATE_INVALID: invalid
+ * @NL80211_TXRATE_LEGACY: Legacy (non-MCS) rates allowed for TX rate selection
+ *	in an array of rates as defined in IEEE 802.11 7.3.2.2 (u8 values with
+ *	1 = 500 kbps) but without the IE length restriction (at most
+ *	%NL80211_MAX_SUPP_RATES in a single array).
+ * @NL80211_TXRATE_HT: HT (MCS) rates allowed for TX rate selection
+ *	in an array of MCS numbers.
+ * @NL80211_TXRATE_VHT: VHT rates allowed for TX rate selection,
+ *	see &struct nl80211_txrate_vht
+ * @NL80211_TXRATE_GI: configure GI, see &enum nl80211_txrate_gi
+ * @__NL80211_TXRATE_AFTER_LAST: internal
+ * @NL80211_TXRATE_MAX: highest TX rate attribute
+ */
+enum nl80211_tx_rate_attributes {
+	__NL80211_TXRATE_INVALID,
+	NL80211_TXRATE_LEGACY,
+	NL80211_TXRATE_HT,
+	NL80211_TXRATE_VHT,
+	NL80211_TXRATE_GI,
+
+	/* keep last */
+	__NL80211_TXRATE_AFTER_LAST,
+	NL80211_TXRATE_MAX = __NL80211_TXRATE_AFTER_LAST - 1
+};
+
+#define NL80211_TXRATE_MCS NL80211_TXRATE_HT
+#define NL80211_VHT_NSS_MAX		8
+
+/**
+ * struct nl80211_txrate_vht - VHT MCS/NSS txrate bitmap
+ * @mcs: MCS bitmap table for each NSS (array index 0 for 1 stream, etc.)
+ */
+struct nl80211_txrate_vht {
+	__u16 mcs[NL80211_VHT_NSS_MAX];
+};
+
+enum nl80211_txrate_gi {
+	NL80211_TXRATE_DEFAULT_GI,
+	NL80211_TXRATE_FORCE_SGI,
+	NL80211_TXRATE_FORCE_LGI,
+};
+
+/**
+ * enum nl80211_band - Frequency band
+ * @NL80211_BAND_2GHZ: 2.4 GHz ISM band
+ * @NL80211_BAND_5GHZ: around 5 GHz band (4.9 - 5.7 GHz)
+ * @NL80211_BAND_60GHZ: around 60 GHz band (58.32 - 69.12 GHz)
+ * @NL80211_BAND_6GHZ: around 6 GHz band (5.9 - 7.2 GHz)
+ * @NUM_NL80211_BANDS: number of bands, avoid using this in userspace
+ *	since newer kernel versions may support more bands
+ */
+enum nl80211_band {
+	NL80211_BAND_2GHZ,
+	NL80211_BAND_5GHZ,
+	NL80211_BAND_60GHZ,
+	NL80211_BAND_6GHZ,
+
+	NUM_NL80211_BANDS,
+};
+
+/**
+ * enum nl80211_ps_state - powersave state
+ * @NL80211_PS_DISABLED: powersave is disabled
+ * @NL80211_PS_ENABLED: powersave is enabled
+ */
+enum nl80211_ps_state {
+	NL80211_PS_DISABLED,
+	NL80211_PS_ENABLED,
+};
+
+/**
+ * enum nl80211_attr_cqm - connection quality monitor attributes
+ * @__NL80211_ATTR_CQM_INVALID: invalid
+ * @NL80211_ATTR_CQM_RSSI_THOLD: RSSI threshold in dBm. This value specifies
+ *	the threshold for the RSSI level at which an event will be sent. Zero
+ *	to disable.  Alternatively, if %NL80211_EXT_FEATURE_CQM_RSSI_LIST is
+ *	set, multiple values can be supplied as a low-to-high sorted array of
+ *	threshold values in dBm.  Events will be sent when the RSSI value
+ *	crosses any of the thresholds.
+ * @NL80211_ATTR_CQM_RSSI_HYST: RSSI hysteresis in dBm. This value specifies
+ *	the minimum amount the RSSI level must change after an event before a
+ *	new event may be issued (to reduce effects of RSSI oscillation).
+ * @NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT: RSSI threshold event
+ * @NL80211_ATTR_CQM_PKT_LOSS_EVENT: a u32 value indicating that this many
+ *	consecutive packets were not acknowledged by the peer
+ * @NL80211_ATTR_CQM_TXE_RATE: TX error rate in %. Minimum % of TX failures
+ *	during the given %NL80211_ATTR_CQM_TXE_INTVL before an
+ *	%NL80211_CMD_NOTIFY_CQM with reported %NL80211_ATTR_CQM_TXE_RATE and
+ *	%NL80211_ATTR_CQM_TXE_PKTS is generated.
+ * @NL80211_ATTR_CQM_TXE_PKTS: number of attempted packets in a given
+ *	%NL80211_ATTR_CQM_TXE_INTVL before %NL80211_ATTR_CQM_TXE_RATE is
+ *	checked.
+ * @NL80211_ATTR_CQM_TXE_INTVL: interval in seconds. Specifies the periodic
+ *	interval in which %NL80211_ATTR_CQM_TXE_PKTS and
+ *	%NL80211_ATTR_CQM_TXE_RATE must be satisfied before generating an
+ *	%NL80211_CMD_NOTIFY_CQM. Set to 0 to turn off TX error reporting.
+ * @NL80211_ATTR_CQM_BEACON_LOSS_EVENT: flag attribute that's set in a beacon
+ *	loss event
+ * @NL80211_ATTR_CQM_RSSI_LEVEL: the RSSI value in dBm that triggered the
+ *	RSSI threshold event.
+ * @__NL80211_ATTR_CQM_AFTER_LAST: internal
+ * @NL80211_ATTR_CQM_MAX: highest key attribute
+ */
+enum nl80211_attr_cqm {
+	__NL80211_ATTR_CQM_INVALID,
+	NL80211_ATTR_CQM_RSSI_THOLD,
+	NL80211_ATTR_CQM_RSSI_HYST,
+	NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT,
+	NL80211_ATTR_CQM_PKT_LOSS_EVENT,
+	NL80211_ATTR_CQM_TXE_RATE,
+	NL80211_ATTR_CQM_TXE_PKTS,
+	NL80211_ATTR_CQM_TXE_INTVL,
+	NL80211_ATTR_CQM_BEACON_LOSS_EVENT,
+	NL80211_ATTR_CQM_RSSI_LEVEL,
+
+	/* keep last */
+	__NL80211_ATTR_CQM_AFTER_LAST,
+	NL80211_ATTR_CQM_MAX = __NL80211_ATTR_CQM_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_cqm_rssi_threshold_event - RSSI threshold event
+ * @NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW: The RSSI level is lower than the
+ *      configured threshold
+ * @NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH: The RSSI is higher than the
+ *      configured threshold
+ * @NL80211_CQM_RSSI_BEACON_LOSS_EVENT: (reserved, never sent)
+ */
+enum nl80211_cqm_rssi_threshold_event {
+	NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
+	NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,
+	NL80211_CQM_RSSI_BEACON_LOSS_EVENT,
+};
+
+
+/**
+ * enum nl80211_tx_power_setting - TX power adjustment
+ * @NL80211_TX_POWER_AUTOMATIC: automatically determine transmit power
+ * @NL80211_TX_POWER_LIMITED: limit TX power by the mBm parameter
+ * @NL80211_TX_POWER_FIXED: fix TX power to the mBm parameter
+ */
+enum nl80211_tx_power_setting {
+	NL80211_TX_POWER_AUTOMATIC,
+	NL80211_TX_POWER_LIMITED,
+	NL80211_TX_POWER_FIXED,
+};
+
+/**
+ * enum nl80211_tid_config - TID config state
+ * @NL80211_TID_CONFIG_ENABLE: Enable config for the TID
+ * @NL80211_TID_CONFIG_DISABLE: Disable config for the TID
+ */
+enum nl80211_tid_config {
+	NL80211_TID_CONFIG_ENABLE,
+	NL80211_TID_CONFIG_DISABLE,
+};
+
+/* enum nl80211_tid_config_attr - TID specific configuration.
+ * @NL80211_TID_CONFIG_ATTR_PAD: pad attribute for 64-bit values
+ * @NL80211_TID_CONFIG_ATTR_VIF_SUPP: a bitmap (u64) of attributes supported
+ *	for per-vif configuration; doesn't list the ones that are generic
+ *	(%NL80211_TID_CONFIG_ATTR_TIDS, %NL80211_TID_CONFIG_ATTR_OVERRIDE).
+ * @NL80211_TID_CONFIG_ATTR_PEER_SUPP: same as the previous per-vif one, but
+ *	per peer instead.
+ * @NL80211_TID_CONFIG_ATTR_OVERRIDE: flag attribue, if no peer
+ *	is selected, if set indicates that the new configuration overrides
+ *	all previous peer configurations, otherwise previous peer specific
+ *	configurations should be left untouched. If peer is selected then
+ *	it will reset particular TID configuration of that peer and it will
+ *	not accept other TID config attributes along with peer.
+ * @NL80211_TID_CONFIG_ATTR_TIDS: a bitmask value of TIDs (bit 0 to 7)
+ *	Its type is u16.
+ * @NL80211_TID_CONFIG_ATTR_NOACK: Configure ack policy for the TID.
+ *	specified in %NL80211_TID_CONFIG_ATTR_TID. see %enum nl80211_tid_config.
+ *	Its type is u8.
+ */
+enum nl80211_tid_config_attr {
+	__NL80211_TID_CONFIG_ATTR_INVALID,
+	NL80211_TID_CONFIG_ATTR_PAD,
+	NL80211_TID_CONFIG_ATTR_VIF_SUPP,
+	NL80211_TID_CONFIG_ATTR_PEER_SUPP,
+	NL80211_TID_CONFIG_ATTR_OVERRIDE,
+	NL80211_TID_CONFIG_ATTR_TIDS,
+	NL80211_TID_CONFIG_ATTR_NOACK,
+
+	/* keep last */
+	__NL80211_TID_CONFIG_ATTR_AFTER_LAST,
+	NL80211_TID_CONFIG_ATTR_MAX = __NL80211_TID_CONFIG_ATTR_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_packet_pattern_attr - packet pattern attribute
+ * @__NL80211_PKTPAT_INVALID: invalid number for nested attribute
+ * @NL80211_PKTPAT_PATTERN: the pattern, values where the mask has
+ *	a zero bit are ignored
+ * @NL80211_PKTPAT_MASK: pattern mask, must be long enough to have
+ *	a bit for each byte in the pattern. The lowest-order bit corresponds
+ *	to the first byte of the pattern, but the bytes of the pattern are
+ *	in a little-endian-like format, i.e. the 9th byte of the pattern
+ *	corresponds to the lowest-order bit in the second byte of the mask.
+ *	For example: The match 00:xx:00:00:xx:00:00:00:00:xx:xx:xx (where
+ *	xx indicates "don't care") would be represented by a pattern of
+ *	twelve zero bytes, and a mask of "0xed,0x01".
+ *	Note that the pattern matching is done as though frames were not
+ *	802.11 frames but 802.3 frames, i.e. the frame is fully unpacked
+ *	first (including SNAP header unpacking) and then matched.
+ * @NL80211_PKTPAT_OFFSET: packet offset, pattern is matched after
+ *	these fixed number of bytes of received packet
+ * @NUM_NL80211_PKTPAT: number of attributes
+ * @MAX_NL80211_PKTPAT: max attribute number
+ */
+enum nl80211_packet_pattern_attr {
+	__NL80211_PKTPAT_INVALID,
+	NL80211_PKTPAT_MASK,
+	NL80211_PKTPAT_PATTERN,
+	NL80211_PKTPAT_OFFSET,
+
+	NUM_NL80211_PKTPAT,
+	MAX_NL80211_PKTPAT = NUM_NL80211_PKTPAT - 1,
+};
+
+/**
+ * struct nl80211_pattern_support - packet pattern support information
+ * @max_patterns: maximum number of patterns supported
+ * @min_pattern_len: minimum length of each pattern
+ * @max_pattern_len: maximum length of each pattern
+ * @max_pkt_offset: maximum Rx packet offset
+ *
+ * This struct is carried in %NL80211_WOWLAN_TRIG_PKT_PATTERN when
+ * that is part of %NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED or in
+ * %NL80211_ATTR_COALESCE_RULE_PKT_PATTERN when that is part of
+ * %NL80211_ATTR_COALESCE_RULE in the capability information given
+ * by the kernel to userspace.
+ */
+struct nl80211_pattern_support {
+	__u32 max_patterns;
+	__u32 min_pattern_len;
+	__u32 max_pattern_len;
+	__u32 max_pkt_offset;
+} __attribute__((packed));
+
+/* only for backward compatibility */
+#define __NL80211_WOWLAN_PKTPAT_INVALID __NL80211_PKTPAT_INVALID
+#define NL80211_WOWLAN_PKTPAT_MASK NL80211_PKTPAT_MASK
+#define NL80211_WOWLAN_PKTPAT_PATTERN NL80211_PKTPAT_PATTERN
+#define NL80211_WOWLAN_PKTPAT_OFFSET NL80211_PKTPAT_OFFSET
+#define NUM_NL80211_WOWLAN_PKTPAT NUM_NL80211_PKTPAT
+#define MAX_NL80211_WOWLAN_PKTPAT MAX_NL80211_PKTPAT
+#define nl80211_wowlan_pattern_support nl80211_pattern_support
+
+/**
+ * enum nl80211_wowlan_triggers - WoWLAN trigger definitions
+ * @__NL80211_WOWLAN_TRIG_INVALID: invalid number for nested attributes
+ * @NL80211_WOWLAN_TRIG_ANY: wake up on any activity, do not really put
+ *	the chip into a special state -- works best with chips that have
+ *	support for low-power operation already (flag)
+ *	Note that this mode is incompatible with all of the others, if
+ *	any others are even supported by the device.
+ * @NL80211_WOWLAN_TRIG_DISCONNECT: wake up on disconnect, the way disconnect
+ *	is detected is implementation-specific (flag)
+ * @NL80211_WOWLAN_TRIG_MAGIC_PKT: wake up on magic packet (6x 0xff, followed
+ *	by 16 repetitions of MAC addr, anywhere in payload) (flag)
+ * @NL80211_WOWLAN_TRIG_PKT_PATTERN: wake up on the specified packet patterns
+ *	which are passed in an array of nested attributes, each nested attribute
+ *	defining a with attributes from &struct nl80211_wowlan_trig_pkt_pattern.
+ *	Each pattern defines a wakeup packet. Packet offset is associated with
+ *	each pattern which is used while matching the pattern. The matching is
+ *	done on the MSDU, i.e. as though the packet was an 802.3 packet, so the
+ *	pattern matching is done after the packet is converted to the MSDU.
+ *
+ *	In %NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED, it is a binary attribute
+ *	carrying a &struct nl80211_pattern_support.
+ *
+ *	When reporting wakeup. it is a u32 attribute containing the 0-based
+ *	index of the pattern that caused the wakeup, in the patterns passed
+ *	to the kernel when configuring.
+ * @NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED: Not a real trigger, and cannot be
+ *	used when setting, used only to indicate that GTK rekeying is supported
+ *	by the device (flag)
+ * @NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE: wake up on GTK rekey failure (if
+ *	done by the device) (flag)
+ * @NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST: wake up on EAP Identity Request
+ *	packet (flag)
+ * @NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE: wake up on 4-way handshake (flag)
+ * @NL80211_WOWLAN_TRIG_RFKILL_RELEASE: wake up when rfkill is released
+ *	(on devices that have rfkill in the device) (flag)
+ * @NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211: For wakeup reporting only, contains
+ *	the 802.11 packet that caused the wakeup, e.g. a deauth frame. The frame
+ *	may be truncated, the @NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211_LEN
+ *	attribute contains the original length.
+ * @NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211_LEN: Original length of the 802.11
+ *	packet, may be bigger than the @NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211
+ *	attribute if the packet was truncated somewhere.
+ * @NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023: For wakeup reporting only, contains the
+ *	802.11 packet that caused the wakeup, e.g. a magic packet. The frame may
+ *	be truncated, the @NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023_LEN attribute
+ *	contains the original length.
+ * @NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023_LEN: Original length of the 802.3
+ *	packet, may be bigger than the @NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023
+ *	attribute if the packet was truncated somewhere.
+ * @NL80211_WOWLAN_TRIG_TCP_CONNECTION: TCP connection wake, see DOC section
+ *	"TCP connection wakeup" for more details. This is a nested attribute
+ *	containing the exact information for establishing and keeping alive
+ *	the TCP connection.
+ * @NL80211_WOWLAN_TRIG_TCP_WAKEUP_MATCH: For wakeup reporting only, the
+ *	wakeup packet was received on the TCP connection
+ * @NL80211_WOWLAN_TRIG_WAKEUP_TCP_CONNLOST: For wakeup reporting only, the
+ *	TCP connection was lost or failed to be established
+ * @NL80211_WOWLAN_TRIG_WAKEUP_TCP_NOMORETOKENS: For wakeup reporting only,
+ *	the TCP connection ran out of tokens to use for data to send to the
+ *	service
+ * @NL80211_WOWLAN_TRIG_NET_DETECT: wake up when a configured network
+ *	is detected.  This is a nested attribute that contains the
+ *	same attributes used with @NL80211_CMD_START_SCHED_SCAN.  It
+ *	specifies how the scan is performed (e.g. the interval, the
+ *	channels to scan and the initial delay) as well as the scan
+ *	results that will trigger a wake (i.e. the matchsets).  This
+ *	attribute is also sent in a response to
+ *	@NL80211_CMD_GET_WIPHY, indicating the number of match sets
+ *	supported by the driver (u32).
+ * @NL80211_WOWLAN_TRIG_NET_DETECT_RESULTS: nested attribute
+ *	containing an array with information about what triggered the
+ *	wake up.  If no elements are present in the array, it means
+ *	that the information is not available.  If more than one
+ *	element is present, it means that more than one match
+ *	occurred.
+ *	Each element in the array is a nested attribute that contains
+ *	one optional %NL80211_ATTR_SSID attribute and one optional
+ *	%NL80211_ATTR_SCAN_FREQUENCIES attribute.  At least one of
+ *	these attributes must be present.  If
+ *	%NL80211_ATTR_SCAN_FREQUENCIES contains more than one
+ *	frequency, it means that the match occurred in more than one
+ *	channel.
+ * @NUM_NL80211_WOWLAN_TRIG: number of wake on wireless triggers
+ * @MAX_NL80211_WOWLAN_TRIG: highest wowlan trigger attribute number
+ *
+ * These nested attributes are used to configure the wakeup triggers and
+ * to report the wakeup reason(s).
+ */
+enum nl80211_wowlan_triggers {
+	__NL80211_WOWLAN_TRIG_INVALID,
+	NL80211_WOWLAN_TRIG_ANY,
+	NL80211_WOWLAN_TRIG_DISCONNECT,
+	NL80211_WOWLAN_TRIG_MAGIC_PKT,
+	NL80211_WOWLAN_TRIG_PKT_PATTERN,
+	NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED,
+	NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE,
+	NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST,
+	NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE,
+	NL80211_WOWLAN_TRIG_RFKILL_RELEASE,
+	NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211,
+	NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211_LEN,
+	NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023,
+	NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023_LEN,
+	NL80211_WOWLAN_TRIG_TCP_CONNECTION,
+	NL80211_WOWLAN_TRIG_WAKEUP_TCP_MATCH,
+	NL80211_WOWLAN_TRIG_WAKEUP_TCP_CONNLOST,
+	NL80211_WOWLAN_TRIG_WAKEUP_TCP_NOMORETOKENS,
+	NL80211_WOWLAN_TRIG_NET_DETECT,
+	NL80211_WOWLAN_TRIG_NET_DETECT_RESULTS,
+
+	/* keep last */
+	NUM_NL80211_WOWLAN_TRIG,
+	MAX_NL80211_WOWLAN_TRIG = NUM_NL80211_WOWLAN_TRIG - 1
+};
+
+/**
+ * DOC: TCP connection wakeup
+ *
+ * Some devices can establish a TCP connection in order to be woken up by a
+ * packet coming in from outside their network segment, or behind NAT. If
+ * configured, the device will establish a TCP connection to the given
+ * service, and periodically send data to that service. The first data
+ * packet is usually transmitted after SYN/ACK, also ACKing the SYN/ACK.
+ * The data packets can optionally include a (little endian) sequence
+ * number (in the TCP payload!) that is generated by the device, and, also
+ * optionally, a token from a list of tokens. This serves as a keep-alive
+ * with the service, and for NATed connections, etc.
+ *
+ * During this keep-alive period, the server doesn't send any data to the
+ * client. When receiving data, it is compared against the wakeup pattern
+ * (and mask) and if it matches, the host is woken up. Similarly, if the
+ * connection breaks or cannot be established to start with, the host is
+ * also woken up.
+ *
+ * Developer's note: ARP offload is required for this, otherwise TCP
+ * response packets might not go through correctly.
+ */
+
+/**
+ * struct nl80211_wowlan_tcp_data_seq - WoWLAN TCP data sequence
+ * @start: starting value
+ * @offset: offset of sequence number in packet
+ * @len: length of the sequence value to write, 1 through 4
+ *
+ * Note: don't confuse with the TCP sequence number(s), this is for the
+ * keepalive packet payload. The actual value is written into the packet
+ * in little endian.
+ */
+struct nl80211_wowlan_tcp_data_seq {
+	__u32 start, offset, len;
+};
+
+/**
+ * struct nl80211_wowlan_tcp_data_token - WoWLAN TCP data token config
+ * @offset: offset of token in packet
+ * @len: length of each token
+ * @token_stream: stream of data to be used for the tokens, the length must
+ *	be a multiple of @len for this to make sense
+ */
+struct nl80211_wowlan_tcp_data_token {
+	__u32 offset, len;
+	__u8 token_stream[];
+};
+
+/**
+ * struct nl80211_wowlan_tcp_data_token_feature - data token features
+ * @min_len: minimum token length
+ * @max_len: maximum token length
+ * @bufsize: total available token buffer size (max size of @token_stream)
+ */
+struct nl80211_wowlan_tcp_data_token_feature {
+	__u32 min_len, max_len, bufsize;
+};
+
+/**
+ * enum nl80211_wowlan_tcp_attrs - WoWLAN TCP connection parameters
+ * @__NL80211_WOWLAN_TCP_INVALID: invalid number for nested attributes
+ * @NL80211_WOWLAN_TCP_SRC_IPV4: source IPv4 address (in network byte order)
+ * @NL80211_WOWLAN_TCP_DST_IPV4: destination IPv4 address
+ *	(in network byte order)
+ * @NL80211_WOWLAN_TCP_DST_MAC: destination MAC address, this is given because
+ *	route lookup when configured might be invalid by the time we suspend,
+ *	and doing a route lookup when suspending is no longer possible as it
+ *	might require ARP querying.
+ * @NL80211_WOWLAN_TCP_SRC_PORT: source port (u16); optional, if not given a
+ *	socket and port will be allocated
+ * @NL80211_WOWLAN_TCP_DST_PORT: destination port (u16)
+ * @NL80211_WOWLAN_TCP_DATA_PAYLOAD: data packet payload, at least one byte.
+ *	For feature advertising, a u32 attribute holding the maximum length
+ *	of the data payload.
+ * @NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ: data packet sequence configuration
+ *	(if desired), a &struct nl80211_wowlan_tcp_data_seq. For feature
+ *	advertising it is just a flag
+ * @NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN: data packet token configuration,
+ *	see &struct nl80211_wowlan_tcp_data_token and for advertising see
+ *	&struct nl80211_wowlan_tcp_data_token_feature.
+ * @NL80211_WOWLAN_TCP_DATA_INTERVAL: data interval in seconds, maximum
+ *	interval in feature advertising (u32)
+ * @NL80211_WOWLAN_TCP_WAKE_PAYLOAD: wake packet payload, for advertising a
+ *	u32 attribute holding the maximum length
+ * @NL80211_WOWLAN_TCP_WAKE_MASK: Wake packet payload mask, not used for
+ *	feature advertising. The mask works like @NL80211_PKTPAT_MASK
+ *	but on the TCP payload only.
+ * @NUM_NL80211_WOWLAN_TCP: number of TCP attributes
+ * @MAX_NL80211_WOWLAN_TCP: highest attribute number
+ */
+enum nl80211_wowlan_tcp_attrs {
+	__NL80211_WOWLAN_TCP_INVALID,
+	NL80211_WOWLAN_TCP_SRC_IPV4,
+	NL80211_WOWLAN_TCP_DST_IPV4,
+	NL80211_WOWLAN_TCP_DST_MAC,
+	NL80211_WOWLAN_TCP_SRC_PORT,
+	NL80211_WOWLAN_TCP_DST_PORT,
+	NL80211_WOWLAN_TCP_DATA_PAYLOAD,
+	NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ,
+	NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN,
+	NL80211_WOWLAN_TCP_DATA_INTERVAL,
+	NL80211_WOWLAN_TCP_WAKE_PAYLOAD,
+	NL80211_WOWLAN_TCP_WAKE_MASK,
+
+	/* keep last */
+	NUM_NL80211_WOWLAN_TCP,
+	MAX_NL80211_WOWLAN_TCP = NUM_NL80211_WOWLAN_TCP - 1
+};
+
+/**
+ * struct nl80211_coalesce_rule_support - coalesce rule support information
+ * @max_rules: maximum number of rules supported
+ * @pat: packet pattern support information
+ * @max_delay: maximum supported coalescing delay in msecs
+ *
+ * This struct is carried in %NL80211_ATTR_COALESCE_RULE in the
+ * capability information given by the kernel to userspace.
+ */
+struct nl80211_coalesce_rule_support {
+	__u32 max_rules;
+	struct nl80211_pattern_support pat;
+	__u32 max_delay;
+} __attribute__((packed));
+
+/**
+ * enum nl80211_attr_coalesce_rule - coalesce rule attribute
+ * @__NL80211_COALESCE_RULE_INVALID: invalid number for nested attribute
+ * @NL80211_ATTR_COALESCE_RULE_DELAY: delay in msecs used for packet coalescing
+ * @NL80211_ATTR_COALESCE_RULE_CONDITION: condition for packet coalescence,
+ *	see &enum nl80211_coalesce_condition.
+ * @NL80211_ATTR_COALESCE_RULE_PKT_PATTERN: packet offset, pattern is matched
+ *	after these fixed number of bytes of received packet
+ * @NUM_NL80211_ATTR_COALESCE_RULE: number of attributes
+ * @NL80211_ATTR_COALESCE_RULE_MAX: max attribute number
+ */
+enum nl80211_attr_coalesce_rule {
+	__NL80211_COALESCE_RULE_INVALID,
+	NL80211_ATTR_COALESCE_RULE_DELAY,
+	NL80211_ATTR_COALESCE_RULE_CONDITION,
+	NL80211_ATTR_COALESCE_RULE_PKT_PATTERN,
+
+	/* keep last */
+	NUM_NL80211_ATTR_COALESCE_RULE,
+	NL80211_ATTR_COALESCE_RULE_MAX = NUM_NL80211_ATTR_COALESCE_RULE - 1
+};
+
+/**
+ * enum nl80211_coalesce_condition - coalesce rule conditions
+ * @NL80211_COALESCE_CONDITION_MATCH: coalaesce Rx packets when patterns
+ *	in a rule are matched.
+ * @NL80211_COALESCE_CONDITION_NO_MATCH: coalesce Rx packets when patterns
+ *	in a rule are not matched.
+ */
+enum nl80211_coalesce_condition {
+	NL80211_COALESCE_CONDITION_MATCH,
+	NL80211_COALESCE_CONDITION_NO_MATCH
+};
+
+/**
+ * enum nl80211_iface_limit_attrs - limit attributes
+ * @NL80211_IFACE_LIMIT_UNSPEC: (reserved)
+ * @NL80211_IFACE_LIMIT_MAX: maximum number of interfaces that
+ *	can be chosen from this set of interface types (u32)
+ * @NL80211_IFACE_LIMIT_TYPES: nested attribute containing a
+ *	flag attribute for each interface type in this set
+ * @NUM_NL80211_IFACE_LIMIT: number of attributes
+ * @MAX_NL80211_IFACE_LIMIT: highest attribute number
+ */
+enum nl80211_iface_limit_attrs {
+	NL80211_IFACE_LIMIT_UNSPEC,
+	NL80211_IFACE_LIMIT_MAX,
+	NL80211_IFACE_LIMIT_TYPES,
+
+	/* keep last */
+	NUM_NL80211_IFACE_LIMIT,
+	MAX_NL80211_IFACE_LIMIT = NUM_NL80211_IFACE_LIMIT - 1
+};
+
+/**
+ * enum nl80211_if_combination_attrs -- interface combination attributes
+ *
+ * @NL80211_IFACE_COMB_UNSPEC: (reserved)
+ * @NL80211_IFACE_COMB_LIMITS: Nested attributes containing the limits
+ *	for given interface types, see &enum nl80211_iface_limit_attrs.
+ * @NL80211_IFACE_COMB_MAXNUM: u32 attribute giving the total number of
+ *	interfaces that can be created in this group. This number doesn't
+ *	apply to interfaces purely managed in software, which are listed
+ *	in a separate attribute %NL80211_ATTR_INTERFACES_SOFTWARE.
+ * @NL80211_IFACE_COMB_STA_AP_BI_MATCH: flag attribute specifying that
+ *	beacon intervals within this group must be all the same even for
+ *	infrastructure and AP/GO combinations, i.e. the GO(s) must adopt
+ *	the infrastructure network's beacon interval.
+ * @NL80211_IFACE_COMB_NUM_CHANNELS: u32 attribute specifying how many
+ *	different channels may be used within this group.
+ * @NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS: u32 attribute containing the bitmap
+ *	of supported channel widths for radar detection.
+ * @NL80211_IFACE_COMB_RADAR_DETECT_REGIONS: u32 attribute containing the bitmap
+ *	of supported regulatory regions for radar detection.
+ * @NL80211_IFACE_COMB_BI_MIN_GCD: u32 attribute specifying the minimum GCD of
+ *	different beacon intervals supported by all the interface combinations
+ *	in this group (if not present, all beacon intervals be identical).
+ * @NUM_NL80211_IFACE_COMB: number of attributes
+ * @MAX_NL80211_IFACE_COMB: highest attribute number
+ *
+ * Examples:
+ *	limits = [ #{STA} <= 1, #{AP} <= 1 ], matching BI, channels = 1, max = 2
+ *	=> allows an AP and a STA that must match BIs
+ *
+ *	numbers = [ #{AP, P2P-GO} <= 8 ], BI min gcd, channels = 1, max = 8,
+ *	=> allows 8 of AP/GO that can have BI gcd >= min gcd
+ *
+ *	numbers = [ #{STA} <= 2 ], channels = 2, max = 2
+ *	=> allows two STAs on different channels
+ *
+ *	numbers = [ #{STA} <= 1, #{P2P-client,P2P-GO} <= 3 ], max = 4
+ *	=> allows a STA plus three P2P interfaces
+ *
+ * The list of these four possibilities could completely be contained
+ * within the %NL80211_ATTR_INTERFACE_COMBINATIONS attribute to indicate
+ * that any of these groups must match.
+ *
+ * "Combinations" of just a single interface will not be listed here,
+ * a single interface of any valid interface type is assumed to always
+ * be possible by itself. This means that implicitly, for each valid
+ * interface type, the following group always exists:
+ *	numbers = [ #{<type>} <= 1 ], channels = 1, max = 1
+ */
+enum nl80211_if_combination_attrs {
+	NL80211_IFACE_COMB_UNSPEC,
+	NL80211_IFACE_COMB_LIMITS,
+	NL80211_IFACE_COMB_MAXNUM,
+	NL80211_IFACE_COMB_STA_AP_BI_MATCH,
+	NL80211_IFACE_COMB_NUM_CHANNELS,
+	NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS,
+	NL80211_IFACE_COMB_RADAR_DETECT_REGIONS,
+	NL80211_IFACE_COMB_BI_MIN_GCD,
+
+	/* keep last */
+	NUM_NL80211_IFACE_COMB,
+	MAX_NL80211_IFACE_COMB = NUM_NL80211_IFACE_COMB - 1
+};
+
+
+/**
+ * enum nl80211_plink_state - state of a mesh peer link finite state machine
+ *
+ * @NL80211_PLINK_LISTEN: initial state, considered the implicit
+ *	state of non existent mesh peer links
+ * @NL80211_PLINK_OPN_SNT: mesh plink open frame has been sent to
+ *	this mesh peer
+ * @NL80211_PLINK_OPN_RCVD: mesh plink open frame has been received
+ *	from this mesh peer
+ * @NL80211_PLINK_CNF_RCVD: mesh plink confirm frame has been
+ *	received from this mesh peer
+ * @NL80211_PLINK_ESTAB: mesh peer link is established
+ * @NL80211_PLINK_HOLDING: mesh peer link is being closed or cancelled
+ * @NL80211_PLINK_BLOCKED: all frames transmitted from this mesh
+ *	plink are discarded
+ * @NUM_NL80211_PLINK_STATES: number of peer link states
+ * @MAX_NL80211_PLINK_STATES: highest numerical value of plink states
+ */
+enum nl80211_plink_state {
+	NL80211_PLINK_LISTEN,
+	NL80211_PLINK_OPN_SNT,
+	NL80211_PLINK_OPN_RCVD,
+	NL80211_PLINK_CNF_RCVD,
+	NL80211_PLINK_ESTAB,
+	NL80211_PLINK_HOLDING,
+	NL80211_PLINK_BLOCKED,
+
+	/* keep last */
+	NUM_NL80211_PLINK_STATES,
+	MAX_NL80211_PLINK_STATES = NUM_NL80211_PLINK_STATES - 1
+};
+
+/**
+ * enum nl80211_plink_action - actions to perform in mesh peers
+ *
+ * @NL80211_PLINK_ACTION_NO_ACTION: perform no action
+ * @NL80211_PLINK_ACTION_OPEN: start mesh peer link establishment
+ * @NL80211_PLINK_ACTION_BLOCK: block traffic from this mesh peer
+ * @NUM_NL80211_PLINK_ACTIONS: number of possible actions
+ */
+enum plink_actions {
+	NL80211_PLINK_ACTION_NO_ACTION,
+	NL80211_PLINK_ACTION_OPEN,
+	NL80211_PLINK_ACTION_BLOCK,
+
+	NUM_NL80211_PLINK_ACTIONS,
+};
+
+
+#define NL80211_KCK_LEN			16
+#define NL80211_KEK_LEN			16
+#define NL80211_REPLAY_CTR_LEN		8
+
+/**
+ * enum nl80211_rekey_data - attributes for GTK rekey offload
+ * @__NL80211_REKEY_DATA_INVALID: invalid number for nested attributes
+ * @NL80211_REKEY_DATA_KEK: key encryption key (binary)
+ * @NL80211_REKEY_DATA_KCK: key confirmation key (binary)
+ * @NL80211_REKEY_DATA_REPLAY_CTR: replay counter (binary)
+ * @NUM_NL80211_REKEY_DATA: number of rekey attributes (internal)
+ * @MAX_NL80211_REKEY_DATA: highest rekey attribute (internal)
+ */
+enum nl80211_rekey_data {
+	__NL80211_REKEY_DATA_INVALID,
+	NL80211_REKEY_DATA_KEK,
+	NL80211_REKEY_DATA_KCK,
+	NL80211_REKEY_DATA_REPLAY_CTR,
+
+	/* keep last */
+	NUM_NL80211_REKEY_DATA,
+	MAX_NL80211_REKEY_DATA = NUM_NL80211_REKEY_DATA - 1
+};
+
+/**
+ * enum nl80211_hidden_ssid - values for %NL80211_ATTR_HIDDEN_SSID
+ * @NL80211_HIDDEN_SSID_NOT_IN_USE: do not hide SSID (i.e., broadcast it in
+ *	Beacon frames)
+ * @NL80211_HIDDEN_SSID_ZERO_LEN: hide SSID by using zero-length SSID element
+ *	in Beacon frames
+ * @NL80211_HIDDEN_SSID_ZERO_CONTENTS: hide SSID by using correct length of SSID
+ *	element in Beacon frames but zero out each byte in the SSID
+ */
+enum nl80211_hidden_ssid {
+	NL80211_HIDDEN_SSID_NOT_IN_USE,
+	NL80211_HIDDEN_SSID_ZERO_LEN,
+	NL80211_HIDDEN_SSID_ZERO_CONTENTS
+};
+
+/**
+ * enum nl80211_sta_wme_attr - station WME attributes
+ * @__NL80211_STA_WME_INVALID: invalid number for nested attribute
+ * @NL80211_STA_WME_UAPSD_QUEUES: bitmap of uapsd queues. the format
+ *	is the same as the AC bitmap in the QoS info field.
+ * @NL80211_STA_WME_MAX_SP: max service period. the format is the same
+ *	as the MAX_SP field in the QoS info field (but already shifted down).
+ * @__NL80211_STA_WME_AFTER_LAST: internal
+ * @NL80211_STA_WME_MAX: highest station WME attribute
+ */
+enum nl80211_sta_wme_attr {
+	__NL80211_STA_WME_INVALID,
+	NL80211_STA_WME_UAPSD_QUEUES,
+	NL80211_STA_WME_MAX_SP,
+
+	/* keep last */
+	__NL80211_STA_WME_AFTER_LAST,
+	NL80211_STA_WME_MAX = __NL80211_STA_WME_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_pmksa_candidate_attr - attributes for PMKSA caching candidates
+ * @__NL80211_PMKSA_CANDIDATE_INVALID: invalid number for nested attributes
+ * @NL80211_PMKSA_CANDIDATE_INDEX: candidate index (u32; the smaller, the higher
+ *	priority)
+ * @NL80211_PMKSA_CANDIDATE_BSSID: candidate BSSID (6 octets)
+ * @NL80211_PMKSA_CANDIDATE_PREAUTH: RSN pre-authentication supported (flag)
+ * @NUM_NL80211_PMKSA_CANDIDATE: number of PMKSA caching candidate attributes
+ *	(internal)
+ * @MAX_NL80211_PMKSA_CANDIDATE: highest PMKSA caching candidate attribute
+ *	(internal)
+ */
+enum nl80211_pmksa_candidate_attr {
+	__NL80211_PMKSA_CANDIDATE_INVALID,
+	NL80211_PMKSA_CANDIDATE_INDEX,
+	NL80211_PMKSA_CANDIDATE_BSSID,
+	NL80211_PMKSA_CANDIDATE_PREAUTH,
+
+	/* keep last */
+	NUM_NL80211_PMKSA_CANDIDATE,
+	MAX_NL80211_PMKSA_CANDIDATE = NUM_NL80211_PMKSA_CANDIDATE - 1
+};
+
+/**
+ * enum nl80211_tdls_operation - values for %NL80211_ATTR_TDLS_OPERATION
+ * @NL80211_TDLS_DISCOVERY_REQ: Send a TDLS discovery request
+ * @NL80211_TDLS_SETUP: Setup TDLS link
+ * @NL80211_TDLS_TEARDOWN: Teardown a TDLS link which is already established
+ * @NL80211_TDLS_ENABLE_LINK: Enable TDLS link
+ * @NL80211_TDLS_DISABLE_LINK: Disable TDLS link
+ */
+enum nl80211_tdls_operation {
+	NL80211_TDLS_DISCOVERY_REQ,
+	NL80211_TDLS_SETUP,
+	NL80211_TDLS_TEARDOWN,
+	NL80211_TDLS_ENABLE_LINK,
+	NL80211_TDLS_DISABLE_LINK,
+};
+
+/*
+ * enum nl80211_ap_sme_features - device-integrated AP features
+ * Reserved for future use, no bits are defined in
+ * NL80211_ATTR_DEVICE_AP_SME yet.
+enum nl80211_ap_sme_features {
+};
+ */
+
+/**
+ * enum nl80211_feature_flags - device/driver features
+ * @NL80211_FEATURE_SK_TX_STATUS: This driver supports reflecting back
+ *	TX status to the socket error queue when requested with the
+ *	socket option.
+ * @NL80211_FEATURE_HT_IBSS: This driver supports IBSS with HT datarates.
+ * @NL80211_FEATURE_INACTIVITY_TIMER: This driver takes care of freeing up
+ *	the connected inactive stations in AP mode.
+ * @NL80211_FEATURE_CELL_BASE_REG_HINTS: This driver has been tested
+ *	to work properly to suppport receiving regulatory hints from
+ *	cellular base stations.
+ * @NL80211_FEATURE_P2P_DEVICE_NEEDS_CHANNEL: (no longer available, only
+ *	here to reserve the value for API/ABI compatibility)
+ * @NL80211_FEATURE_SAE: This driver supports simultaneous authentication of
+ *	equals (SAE) with user space SME (NL80211_CMD_AUTHENTICATE) in station
+ *	mode
+ * @NL80211_FEATURE_LOW_PRIORITY_SCAN: This driver supports low priority scan
+ * @NL80211_FEATURE_SCAN_FLUSH: Scan flush is supported
+ * @NL80211_FEATURE_AP_SCAN: Support scanning using an AP vif
+ * @NL80211_FEATURE_VIF_TXPOWER: The driver supports per-vif TX power setting
+ * @NL80211_FEATURE_NEED_OBSS_SCAN: The driver expects userspace to perform
+ *	OBSS scans and generate 20/40 BSS coex reports. This flag is used only
+ *	for drivers implementing the CONNECT API, for AUTH/ASSOC it is implied.
+ * @NL80211_FEATURE_P2P_GO_CTWIN: P2P GO implementation supports CT Window
+ *	setting
+ * @NL80211_FEATURE_P2P_GO_OPPPS: P2P GO implementation supports opportunistic
+ *	powersave
+ * @NL80211_FEATURE_FULL_AP_CLIENT_STATE: The driver supports full state
+ *	transitions for AP clients. Without this flag (and if the driver
+ *	doesn't have the AP SME in the device) the driver supports adding
+ *	stations only when they're associated and adds them in associated
+ *	state (to later be transitioned into authorized), with this flag
+ *	they should be added before even sending the authentication reply
+ *	and then transitioned into authenticated, associated and authorized
+ *	states using station flags.
+ *	Note that even for drivers that support this, the default is to add
+ *	stations in authenticated/associated state, so to add unauthenticated
+ *	stations the authenticated/associated bits have to be set in the mask.
+ * @NL80211_FEATURE_ADVERTISE_CHAN_LIMITS: cfg80211 advertises channel limits
+ *	(HT40, VHT 80/160 MHz) if this flag is set
+ * @NL80211_FEATURE_USERSPACE_MPM: This driver supports a userspace Mesh
+ *	Peering Management entity which may be implemented by registering for
+ *	beacons or NL80211_CMD_NEW_PEER_CANDIDATE events. The mesh beacon is
+ *	still generated by the driver.
+ * @NL80211_FEATURE_ACTIVE_MONITOR: This driver supports an active monitor
+ *	interface. An active monitor interface behaves like a normal monitor
+ *	interface, but gets added to the driver. It ensures that incoming
+ *	unicast packets directed at the configured interface address get ACKed.
+ * @NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE: This driver supports dynamic
+ *	channel bandwidth change (e.g., HT 20 <-> 40 MHz channel) during the
+ *	lifetime of a BSS.
+ * @NL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES: This device adds a DS Parameter
+ *	Set IE to probe requests.
+ * @NL80211_FEATURE_WFA_TPC_IE_IN_PROBES: This device adds a WFA TPC Report IE
+ *	to probe requests.
+ * @NL80211_FEATURE_QUIET: This device, in client mode, supports Quiet Period
+ *	requests sent to it by an AP.
+ * @NL80211_FEATURE_TX_POWER_INSERTION: This device is capable of inserting the
+ *	current tx power value into the TPC Report IE in the spectrum
+ *	management TPC Report action frame, and in the Radio Measurement Link
+ *	Measurement Report action frame.
+ * @NL80211_FEATURE_ACKTO_ESTIMATION: This driver supports dynamic ACK timeout
+ *	estimation (dynack). %NL80211_ATTR_WIPHY_DYN_ACK flag attribute is used
+ *	to enable dynack.
+ * @NL80211_FEATURE_STATIC_SMPS: Device supports static spatial
+ *	multiplexing powersave, ie. can turn off all but one chain
+ *	even on HT connections that should be using more chains.
+ * @NL80211_FEATURE_DYNAMIC_SMPS: Device supports dynamic spatial
+ *	multiplexing powersave, ie. can turn off all but one chain
+ *	and then wake the rest up as required after, for example,
+ *	rts/cts handshake.
+ * @NL80211_FEATURE_SUPPORTS_WMM_ADMISSION: the device supports setting up WMM
+ *	TSPEC sessions (TID aka TSID 0-7) with the %NL80211_CMD_ADD_TX_TS
+ *	command. Standard IEEE 802.11 TSPEC setup is not yet supported, it
+ *	needs to be able to handle Block-Ack agreements and other things.
+ * @NL80211_FEATURE_MAC_ON_CREATE: Device supports configuring
+ *	the vif's MAC address upon creation.
+ *	See 'macaddr' field in the vif_params (cfg80211.h).
+ * @NL80211_FEATURE_TDLS_CHANNEL_SWITCH: Driver supports channel switching when
+ *	operating as a TDLS peer.
+ * @NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR: This device/driver supports using a
+ *	random MAC address during scan (if the device is unassociated); the
+ *	%NL80211_SCAN_FLAG_RANDOM_ADDR flag may be set for scans and the MAC
+ *	address mask/value will be used.
+ * @NL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR: This device/driver supports
+ *	using a random MAC address for every scan iteration during scheduled
+ *	scan (while not associated), the %NL80211_SCAN_FLAG_RANDOM_ADDR may
+ *	be set for scheduled scan and the MAC address mask/value will be used.
+ * @NL80211_FEATURE_ND_RANDOM_MAC_ADDR: This device/driver supports using a
+ *	random MAC address for every scan iteration during "net detect", i.e.
+ *	scan in unassociated WoWLAN, the %NL80211_SCAN_FLAG_RANDOM_ADDR may
+ *	be set for scheduled scan and the MAC address mask/value will be used.
+ */
+enum nl80211_feature_flags {
+	NL80211_FEATURE_SK_TX_STATUS			= 1 << 0,
+	NL80211_FEATURE_HT_IBSS				= 1 << 1,
+	NL80211_FEATURE_INACTIVITY_TIMER		= 1 << 2,
+	NL80211_FEATURE_CELL_BASE_REG_HINTS		= 1 << 3,
+	NL80211_FEATURE_P2P_DEVICE_NEEDS_CHANNEL	= 1 << 4,
+	NL80211_FEATURE_SAE				= 1 << 5,
+	NL80211_FEATURE_LOW_PRIORITY_SCAN		= 1 << 6,
+	NL80211_FEATURE_SCAN_FLUSH			= 1 << 7,
+	NL80211_FEATURE_AP_SCAN				= 1 << 8,
+	NL80211_FEATURE_VIF_TXPOWER			= 1 << 9,
+	NL80211_FEATURE_NEED_OBSS_SCAN			= 1 << 10,
+	NL80211_FEATURE_P2P_GO_CTWIN			= 1 << 11,
+	NL80211_FEATURE_P2P_GO_OPPPS			= 1 << 12,
+	/* bit 13 is reserved */
+	NL80211_FEATURE_ADVERTISE_CHAN_LIMITS		= 1 << 14,
+	NL80211_FEATURE_FULL_AP_CLIENT_STATE		= 1 << 15,
+	NL80211_FEATURE_USERSPACE_MPM			= 1 << 16,
+	NL80211_FEATURE_ACTIVE_MONITOR			= 1 << 17,
+	NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE	= 1 << 18,
+	NL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES	= 1 << 19,
+	NL80211_FEATURE_WFA_TPC_IE_IN_PROBES		= 1 << 20,
+	NL80211_FEATURE_QUIET				= 1 << 21,
+	NL80211_FEATURE_TX_POWER_INSERTION		= 1 << 22,
+	NL80211_FEATURE_ACKTO_ESTIMATION		= 1 << 23,
+	NL80211_FEATURE_STATIC_SMPS			= 1 << 24,
+	NL80211_FEATURE_DYNAMIC_SMPS			= 1 << 25,
+	NL80211_FEATURE_SUPPORTS_WMM_ADMISSION		= 1 << 26,
+	NL80211_FEATURE_MAC_ON_CREATE			= 1 << 27,
+	NL80211_FEATURE_TDLS_CHANNEL_SWITCH		= 1 << 28,
+	NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR		= 1 << 29,
+	NL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR	= 1 << 30,
+	NL80211_FEATURE_ND_RANDOM_MAC_ADDR		= 1U << 31,
+};
+
+/**
+ * enum nl80211_ext_feature_index - bit index of extended features.
+ * @NL80211_EXT_FEATURE_VHT_IBSS: This driver supports IBSS with VHT datarates.
+ * @NL80211_EXT_FEATURE_RRM: This driver supports RRM. When featured, user can
+ *	can request to use RRM (see %NL80211_ATTR_USE_RRM) with
+ *	%NL80211_CMD_ASSOCIATE and %NL80211_CMD_CONNECT requests, which will set
+ *	the ASSOC_REQ_USE_RRM flag in the association request even if
+ *	NL80211_FEATURE_QUIET is not advertized.
+ * @NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER: This device supports MU-MIMO air
+ *	sniffer which means that it can be configured to hear packets from
+ *	certain groups which can be configured by the
+ *	%NL80211_ATTR_MU_MIMO_GROUP_DATA attribute,
+ *	or can be configured to follow a station by configuring the
+ *	%NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR attribute.
+ * @NL80211_EXT_FEATURE_SCAN_START_TIME: This driver includes the actual
+ *	time the scan started in scan results event. The time is the TSF of
+ *	the BSS that the interface that requested the scan is connected to
+ *	(if available).
+ * @NL80211_EXT_FEATURE_BSS_PARENT_TSF: Per BSS, this driver reports the
+ *	time the last beacon/probe was received. The time is the TSF of the
+ *	BSS that the interface that requested the scan is connected to
+ *	(if available).
+ * @NL80211_EXT_FEATURE_SET_SCAN_DWELL: This driver supports configuration of
+ *	channel dwell time.
+ * @NL80211_EXT_FEATURE_BEACON_RATE_LEGACY: Driver supports beacon rate
+ *	configuration (AP/mesh), supporting a legacy (non HT/VHT) rate.
+ * @NL80211_EXT_FEATURE_BEACON_RATE_HT: Driver supports beacon rate
+ *	configuration (AP/mesh) with HT rates.
+ * @NL80211_EXT_FEATURE_BEACON_RATE_VHT: Driver supports beacon rate
+ *	configuration (AP/mesh) with VHT rates.
+ * @NL80211_EXT_FEATURE_FILS_STA: This driver supports Fast Initial Link Setup
+ *	with user space SME (NL80211_CMD_AUTHENTICATE) in station mode.
+ * @NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA: This driver supports randomized TA
+ *	in @NL80211_CMD_FRAME while not associated.
+ * @NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA_CONNECTED: This driver supports
+ *	randomized TA in @NL80211_CMD_FRAME while associated.
+ * @NL80211_EXT_FEATURE_SCHED_SCAN_RELATIVE_RSSI: The driver supports sched_scan
+ *	for reporting BSSs with better RSSI than the current connected BSS
+ *	(%NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI).
+ * @NL80211_EXT_FEATURE_CQM_RSSI_LIST: With this driver the
+ *	%NL80211_ATTR_CQM_RSSI_THOLD attribute accepts a list of zero or more
+ *	RSSI threshold values to monitor rather than exactly one threshold.
+ * @NL80211_EXT_FEATURE_FILS_SK_OFFLOAD: Driver SME supports FILS shared key
+ *	authentication with %NL80211_CMD_CONNECT.
+ * @NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_PSK: Device wants to do 4-way
+ *	handshake with PSK in station mode (PSK is passed as part of the connect
+ *	and associate commands), doing it in the host might not be supported.
+ * @NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X: Device wants to do doing 4-way
+ *	handshake with 802.1X in station mode (will pass EAP frames to the host
+ *	and accept the set_pmk/del_pmk commands), doing it in the host might not
+ *	be supported.
+ * @NL80211_EXT_FEATURE_FILS_MAX_CHANNEL_TIME: Driver is capable of overriding
+ *	the max channel attribute in the FILS request params IE with the
+ *	actual dwell time.
+ * @NL80211_EXT_FEATURE_ACCEPT_BCAST_PROBE_RESP: Driver accepts broadcast probe
+ *	response
+ * @NL80211_EXT_FEATURE_OCE_PROBE_REQ_HIGH_TX_RATE: Driver supports sending
+ *	the first probe request in each channel at rate of at least 5.5Mbps.
+ * @NL80211_EXT_FEATURE_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION: Driver supports
+ *	probe request tx deferral and suppression
+ * @NL80211_EXT_FEATURE_MFP_OPTIONAL: Driver supports the %NL80211_MFP_OPTIONAL
+ *	value in %NL80211_ATTR_USE_MFP.
+ * @NL80211_EXT_FEATURE_LOW_SPAN_SCAN: Driver supports low span scan.
+ * @NL80211_EXT_FEATURE_LOW_POWER_SCAN: Driver supports low power scan.
+ * @NL80211_EXT_FEATURE_HIGH_ACCURACY_SCAN: Driver supports high accuracy scan.
+ * @NL80211_EXT_FEATURE_DFS_OFFLOAD: HW/driver will offload DFS actions.
+ *	Device or driver will do all DFS-related actions by itself,
+ *	informing user-space about CAC progress, radar detection event,
+ *	channel change triggered by radar detection event.
+ *	No need to start CAC from user-space, no need to react to
+ *	"radar detected" event.
+ * @NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211: Driver supports sending and
+ *	receiving control port frames over nl80211 instead of the netdevice.
+ * @NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT: This driver/device supports
+ *	(average) ACK signal strength reporting.
+ * @NL80211_EXT_FEATURE_TXQS: Driver supports FQ-CoDel-enabled intermediate
+ *      TXQs.
+ * @NL80211_EXT_FEATURE_SCAN_RANDOM_SN: Driver/device supports randomizing the
+ *	SN in probe request frames if requested by %NL80211_SCAN_FLAG_RANDOM_SN.
+ * @NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT: Driver/device can omit all data
+ *	except for supported rates from the probe request content if requested
+ *	by the %NL80211_SCAN_FLAG_MIN_PREQ_CONTENT flag.
+ * @NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER: Driver supports enabling fine
+ *	timing measurement responder role.
+ *
+ * @NL80211_EXT_FEATURE_CAN_REPLACE_PTK0: Driver/device confirm that they are
+ *      able to rekey an in-use key correctly. Userspace must not rekey PTK keys
+ *      if this flag is not set. Ignoring this can leak clear text packets and/or
+ *      freeze the connection.
+ * @NL80211_EXT_FEATURE_EXT_KEY_ID: Driver supports "Extended Key ID for
+ *      Individually Addressed Frames" from IEEE802.11-2016.
+ *
+ * @NL80211_EXT_FEATURE_AIRTIME_FAIRNESS: Driver supports getting airtime
+ *	fairness for transmitted packets and has enabled airtime fairness
+ *	scheduling.
+ *
+ * @NL80211_EXT_FEATURE_AP_PMKSA_CACHING: Driver/device supports PMKSA caching
+ *	(set/del PMKSA operations) in AP mode.
+ *
+ * @NL80211_EXT_FEATURE_SCHED_SCAN_BAND_SPECIFIC_RSSI_THOLD: Driver supports
+ *	filtering of sched scan results using band specific RSSI thresholds.
+ *
+ * @NL80211_EXT_FEATURE_STA_TX_PWR: This driver supports controlling tx power
+ *	to a station.
+ *
+ * @NL80211_EXT_FEATURE_SAE_OFFLOAD: Device wants to do SAE authentication in
+ *	station mode (SAE password is passed as part of the connect command).
+ *
+ * @NL80211_EXT_FEATURE_VLAN_OFFLOAD: The driver supports a single netdev
+ *	with VLAN tagged frames and separate VLAN-specific netdevs added using
+ *	vconfig similarly to the Ethernet case.
+ *
+ * @NL80211_EXT_FEATURE_BEACON_PROTECTION: The driver supports Beacon protection
+ *	and can receive key configuration for BIGTK using key indexes 6 and 7.
+ *
+ * @NL80211_EXT_FEATURE_CONTROL_PORT_NO_PREAUTH: The driver can disable the
+ *	forwarding of preauth frames over the control port. They are then
+ *	handled as ordinary data frames.
+ *
+ * @NUM_NL80211_EXT_FEATURES: number of extended features.
+ * @MAX_NL80211_EXT_FEATURES: highest extended feature index.
+ */
+enum nl80211_ext_feature_index {
+	NL80211_EXT_FEATURE_VHT_IBSS,
+	NL80211_EXT_FEATURE_RRM,
+	NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER,
+	NL80211_EXT_FEATURE_SCAN_START_TIME,
+	NL80211_EXT_FEATURE_BSS_PARENT_TSF,
+	NL80211_EXT_FEATURE_SET_SCAN_DWELL,
+	NL80211_EXT_FEATURE_BEACON_RATE_LEGACY,
+	NL80211_EXT_FEATURE_BEACON_RATE_HT,
+	NL80211_EXT_FEATURE_BEACON_RATE_VHT,
+	NL80211_EXT_FEATURE_FILS_STA,
+	NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA,
+	NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA_CONNECTED,
+	NL80211_EXT_FEATURE_SCHED_SCAN_RELATIVE_RSSI,
+	NL80211_EXT_FEATURE_CQM_RSSI_LIST,
+	NL80211_EXT_FEATURE_FILS_SK_OFFLOAD,
+	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_PSK,
+	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X,
+	NL80211_EXT_FEATURE_FILS_MAX_CHANNEL_TIME,
+	NL80211_EXT_FEATURE_ACCEPT_BCAST_PROBE_RESP,
+	NL80211_EXT_FEATURE_OCE_PROBE_REQ_HIGH_TX_RATE,
+	NL80211_EXT_FEATURE_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION,
+	NL80211_EXT_FEATURE_MFP_OPTIONAL,
+	NL80211_EXT_FEATURE_LOW_SPAN_SCAN,
+	NL80211_EXT_FEATURE_LOW_POWER_SCAN,
+	NL80211_EXT_FEATURE_HIGH_ACCURACY_SCAN,
+	NL80211_EXT_FEATURE_DFS_OFFLOAD,
+	NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211,
+	NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT,
+	/* we renamed this - stay compatible */
+	NL80211_EXT_FEATURE_DATA_ACK_SIGNAL_SUPPORT = NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT,
+	NL80211_EXT_FEATURE_TXQS,
+	NL80211_EXT_FEATURE_SCAN_RANDOM_SN,
+	NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT,
+	NL80211_EXT_FEATURE_CAN_REPLACE_PTK0,
+	NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER,
+	NL80211_EXT_FEATURE_AIRTIME_FAIRNESS,
+	NL80211_EXT_FEATURE_AP_PMKSA_CACHING,
+	NL80211_EXT_FEATURE_SCHED_SCAN_BAND_SPECIFIC_RSSI_THOLD,
+	NL80211_EXT_FEATURE_EXT_KEY_ID,
+	NL80211_EXT_FEATURE_STA_TX_PWR,
+	NL80211_EXT_FEATURE_SAE_OFFLOAD,
+	NL80211_EXT_FEATURE_VLAN_OFFLOAD,
+	NL80211_EXT_FEATURE_AQL,
+	NL80211_EXT_FEATURE_BEACON_PROTECTION,
+	NL80211_EXT_FEATURE_CONTROL_PORT_NO_PREAUTH,
+
+	/* add new features before the definition below */
+	NUM_NL80211_EXT_FEATURES,
+	MAX_NL80211_EXT_FEATURES = NUM_NL80211_EXT_FEATURES - 1
+};
+
+/**
+ * enum nl80211_probe_resp_offload_support_attr - optional supported
+ *	protocols for probe-response offloading by the driver/FW.
+ *	To be used with the %NL80211_ATTR_PROBE_RESP_OFFLOAD attribute.
+ *	Each enum value represents a bit in the bitmap of supported
+ *	protocols. Typically a subset of probe-requests belonging to a
+ *	supported protocol will be excluded from offload and uploaded
+ *	to the host.
+ *
+ * @NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS: Support for WPS ver. 1
+ * @NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2: Support for WPS ver. 2
+ * @NL80211_PROBE_RESP_OFFLOAD_SUPPORT_P2P: Support for P2P
+ * @NL80211_PROBE_RESP_OFFLOAD_SUPPORT_80211U: Support for 802.11u
+ */
+enum nl80211_probe_resp_offload_support_attr {
+	NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS =	1<<0,
+	NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2 =	1<<1,
+	NL80211_PROBE_RESP_OFFLOAD_SUPPORT_P2P =	1<<2,
+	NL80211_PROBE_RESP_OFFLOAD_SUPPORT_80211U =	1<<3,
+};
+
+/**
+ * enum nl80211_connect_failed_reason - connection request failed reasons
+ * @NL80211_CONN_FAIL_MAX_CLIENTS: Maximum number of clients that can be
+ *	handled by the AP is reached.
+ * @NL80211_CONN_FAIL_BLOCKED_CLIENT: Connection request is rejected due to ACL.
+ */
+enum nl80211_connect_failed_reason {
+	NL80211_CONN_FAIL_MAX_CLIENTS,
+	NL80211_CONN_FAIL_BLOCKED_CLIENT,
+};
+
+/**
+ * enum nl80211_timeout_reason - timeout reasons
+ *
+ * @NL80211_TIMEOUT_UNSPECIFIED: Timeout reason unspecified.
+ * @NL80211_TIMEOUT_SCAN: Scan (AP discovery) timed out.
+ * @NL80211_TIMEOUT_AUTH: Authentication timed out.
+ * @NL80211_TIMEOUT_ASSOC: Association timed out.
+ */
+enum nl80211_timeout_reason {
+	NL80211_TIMEOUT_UNSPECIFIED,
+	NL80211_TIMEOUT_SCAN,
+	NL80211_TIMEOUT_AUTH,
+	NL80211_TIMEOUT_ASSOC,
+};
+
+/**
+ * enum nl80211_scan_flags -  scan request control flags
+ *
+ * Scan request control flags are used to control the handling
+ * of NL80211_CMD_TRIGGER_SCAN and NL80211_CMD_START_SCHED_SCAN
+ * requests.
+ *
+ * NL80211_SCAN_FLAG_LOW_SPAN, NL80211_SCAN_FLAG_LOW_POWER, and
+ * NL80211_SCAN_FLAG_HIGH_ACCURACY flags are exclusive of each other, i.e., only
+ * one of them can be used in the request.
+ *
+ * @NL80211_SCAN_FLAG_LOW_PRIORITY: scan request has low priority
+ * @NL80211_SCAN_FLAG_FLUSH: flush cache before scanning
+ * @NL80211_SCAN_FLAG_AP: force a scan even if the interface is configured
+ *	as AP and the beaconing has already been configured. This attribute is
+ *	dangerous because will destroy stations performance as a lot of frames
+ *	will be lost while scanning off-channel, therefore it must be used only
+ *	when really needed
+ * @NL80211_SCAN_FLAG_RANDOM_ADDR: use a random MAC address for this scan (or
+ *	for scheduled scan: a different one for every scan iteration). When the
+ *	flag is set, depending on device capabilities the @NL80211_ATTR_MAC and
+ *	@NL80211_ATTR_MAC_MASK attributes may also be given in which case only
+ *	the masked bits will be preserved from the MAC address and the remainder
+ *	randomised. If the attributes are not given full randomisation (46 bits,
+ *	locally administered 1, multicast 0) is assumed.
+ *	This flag must not be requested when the feature isn't supported, check
+ *	the nl80211 feature flags for the device.
+ * @NL80211_SCAN_FLAG_FILS_MAX_CHANNEL_TIME: fill the dwell time in the FILS
+ *	request parameters IE in the probe request
+ * @NL80211_SCAN_FLAG_ACCEPT_BCAST_PROBE_RESP: accept broadcast probe responses
+ * @NL80211_SCAN_FLAG_OCE_PROBE_REQ_HIGH_TX_RATE: send probe request frames at
+ *	rate of at least 5.5M. In case non OCE AP is discovered in the channel,
+ *	only the first probe req in the channel will be sent in high rate.
+ * @NL80211_SCAN_FLAG_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION: allow probe request
+ *	tx deferral (dot11FILSProbeDelay shall be set to 15ms)
+ *	and suppression (if it has received a broadcast Probe Response frame,
+ *	Beacon frame or FILS Discovery frame from an AP that the STA considers
+ *	a suitable candidate for (re-)association - suitable in terms of
+ *	SSID and/or RSSI.
+ * @NL80211_SCAN_FLAG_LOW_SPAN: Span corresponds to the total time taken to
+ *	accomplish the scan. Thus, this flag intends the driver to perform the
+ *	scan request with lesser span/duration. It is specific to the driver
+ *	implementations on how this is accomplished. Scan accuracy may get
+ *	impacted with this flag.
+ * @NL80211_SCAN_FLAG_LOW_POWER: This flag intends the scan attempts to consume
+ *	optimal possible power. Drivers can resort to their specific means to
+ *	optimize the power. Scan accuracy may get impacted with this flag.
+ * @NL80211_SCAN_FLAG_HIGH_ACCURACY: Accuracy here intends to the extent of scan
+ *	results obtained. Thus HIGH_ACCURACY scan flag aims to get maximum
+ *	possible scan results. This flag hints the driver to use the best
+ *	possible scan configuration to improve the accuracy in scanning.
+ *	Latency and power use may get impacted with this flag.
+ * @NL80211_SCAN_FLAG_RANDOM_SN: randomize the sequence number in probe
+ *	request frames from this scan to avoid correlation/tracking being
+ *	possible.
+ * @NL80211_SCAN_FLAG_MIN_PREQ_CONTENT: minimize probe request content to
+ *	only have supported rates and no additional capabilities (unless
+ *	added by userspace explicitly.)
+ */
+enum nl80211_scan_flags {
+	NL80211_SCAN_FLAG_LOW_PRIORITY				= 1<<0,
+	NL80211_SCAN_FLAG_FLUSH					= 1<<1,
+	NL80211_SCAN_FLAG_AP					= 1<<2,
+	NL80211_SCAN_FLAG_RANDOM_ADDR				= 1<<3,
+	NL80211_SCAN_FLAG_FILS_MAX_CHANNEL_TIME			= 1<<4,
+	NL80211_SCAN_FLAG_ACCEPT_BCAST_PROBE_RESP		= 1<<5,
+	NL80211_SCAN_FLAG_OCE_PROBE_REQ_HIGH_TX_RATE		= 1<<6,
+	NL80211_SCAN_FLAG_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION	= 1<<7,
+	NL80211_SCAN_FLAG_LOW_SPAN				= 1<<8,
+	NL80211_SCAN_FLAG_LOW_POWER				= 1<<9,
+	NL80211_SCAN_FLAG_HIGH_ACCURACY				= 1<<10,
+	NL80211_SCAN_FLAG_RANDOM_SN				= 1<<11,
+	NL80211_SCAN_FLAG_MIN_PREQ_CONTENT			= 1<<12,
+};
+
+/**
+ * enum nl80211_acl_policy - access control policy
+ *
+ * Access control policy is applied on a MAC list set by
+ * %NL80211_CMD_START_AP and %NL80211_CMD_SET_MAC_ACL, to
+ * be used with %NL80211_ATTR_ACL_POLICY.
+ *
+ * @NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED: Deny stations which are
+ *	listed in ACL, i.e. allow all the stations which are not listed
+ *	in ACL to authenticate.
+ * @NL80211_ACL_POLICY_DENY_UNLESS_LISTED: Allow the stations which are listed
+ *	in ACL, i.e. deny all the stations which are not listed in ACL.
+ */
+enum nl80211_acl_policy {
+	NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED,
+	NL80211_ACL_POLICY_DENY_UNLESS_LISTED,
+};
+
+/**
+ * enum nl80211_smps_mode - SMPS mode
+ *
+ * Requested SMPS mode (for AP mode)
+ *
+ * @NL80211_SMPS_OFF: SMPS off (use all antennas).
+ * @NL80211_SMPS_STATIC: static SMPS (use a single antenna)
+ * @NL80211_SMPS_DYNAMIC: dynamic smps (start with a single antenna and
+ *	turn on other antennas after CTS/RTS).
+ */
+enum nl80211_smps_mode {
+	NL80211_SMPS_OFF,
+	NL80211_SMPS_STATIC,
+	NL80211_SMPS_DYNAMIC,
+
+	__NL80211_SMPS_AFTER_LAST,
+	NL80211_SMPS_MAX = __NL80211_SMPS_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_radar_event - type of radar event for DFS operation
+ *
+ * Type of event to be used with NL80211_ATTR_RADAR_EVENT to inform userspace
+ * about detected radars or success of the channel available check (CAC)
+ *
+ * @NL80211_RADAR_DETECTED: A radar pattern has been detected. The channel is
+ *	now unusable.
+ * @NL80211_RADAR_CAC_FINISHED: Channel Availability Check has been finished,
+ *	the channel is now available.
+ * @NL80211_RADAR_CAC_ABORTED: Channel Availability Check has been aborted, no
+ *	change to the channel status.
+ * @NL80211_RADAR_NOP_FINISHED: The Non-Occupancy Period for this channel is
+ *	over, channel becomes usable.
+ * @NL80211_RADAR_PRE_CAC_EXPIRED: Channel Availability Check done on this
+ *	non-operating channel is expired and no longer valid. New CAC must
+ *	be done on this channel before starting the operation. This is not
+ *	applicable for ETSI dfs domain where pre-CAC is valid for ever.
+ * @NL80211_RADAR_CAC_STARTED: Channel Availability Check has been started,
+ *	should be generated by HW if NL80211_EXT_FEATURE_DFS_OFFLOAD is enabled.
+ */
+enum nl80211_radar_event {
+	NL80211_RADAR_DETECTED,
+	NL80211_RADAR_CAC_FINISHED,
+	NL80211_RADAR_CAC_ABORTED,
+	NL80211_RADAR_NOP_FINISHED,
+	NL80211_RADAR_PRE_CAC_EXPIRED,
+	NL80211_RADAR_CAC_STARTED,
+};
+
+/**
+ * enum nl80211_dfs_state - DFS states for channels
+ *
+ * Channel states used by the DFS code.
+ *
+ * @NL80211_DFS_USABLE: The channel can be used, but channel availability
+ *	check (CAC) must be performed before using it for AP or IBSS.
+ * @NL80211_DFS_UNAVAILABLE: A radar has been detected on this channel, it
+ *	is therefore marked as not available.
+ * @NL80211_DFS_AVAILABLE: The channel has been CAC checked and is available.
+ */
+enum nl80211_dfs_state {
+	NL80211_DFS_USABLE,
+	NL80211_DFS_UNAVAILABLE,
+	NL80211_DFS_AVAILABLE,
+};
+
+/**
+ * enum enum nl80211_protocol_features - nl80211 protocol features
+ * @NL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP: nl80211 supports splitting
+ *	wiphy dumps (if requested by the application with the attribute
+ *	%NL80211_ATTR_SPLIT_WIPHY_DUMP. Also supported is filtering the
+ *	wiphy dump by %NL80211_ATTR_WIPHY, %NL80211_ATTR_IFINDEX or
+ *	%NL80211_ATTR_WDEV.
+ */
+enum nl80211_protocol_features {
+	NL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP =	1 << 0,
+};
+
+/**
+ * enum nl80211_crit_proto_id - nl80211 critical protocol identifiers
+ *
+ * @NL80211_CRIT_PROTO_UNSPEC: protocol unspecified.
+ * @NL80211_CRIT_PROTO_DHCP: BOOTP or DHCPv6 protocol.
+ * @NL80211_CRIT_PROTO_EAPOL: EAPOL protocol.
+ * @NL80211_CRIT_PROTO_APIPA: APIPA protocol.
+ * @NUM_NL80211_CRIT_PROTO: must be kept last.
+ */
+enum nl80211_crit_proto_id {
+	NL80211_CRIT_PROTO_UNSPEC,
+	NL80211_CRIT_PROTO_DHCP,
+	NL80211_CRIT_PROTO_EAPOL,
+	NL80211_CRIT_PROTO_APIPA,
+	/* add other protocols before this one */
+	NUM_NL80211_CRIT_PROTO
+};
+
+/* maximum duration for critical protocol measures */
+#define NL80211_CRIT_PROTO_MAX_DURATION		5000 /* msec */
+
+/**
+ * enum nl80211_rxmgmt_flags - flags for received management frame.
+ *
+ * Used by cfg80211_rx_mgmt()
+ *
+ * @NL80211_RXMGMT_FLAG_ANSWERED: frame was answered by device/driver.
+ * @NL80211_RXMGMT_FLAG_EXTERNAL_AUTH: Host driver intends to offload
+ *	the authentication. Exclusively defined for host drivers that
+ *	advertises the SME functionality but would like the userspace
+ *	to handle certain authentication algorithms (e.g. SAE).
+ */
+enum nl80211_rxmgmt_flags {
+	NL80211_RXMGMT_FLAG_ANSWERED = 1 << 0,
+	NL80211_RXMGMT_FLAG_EXTERNAL_AUTH = 1 << 1,
+};
+
+/*
+ * If this flag is unset, the lower 24 bits are an OUI, if set
+ * a Linux nl80211 vendor ID is used (no such IDs are allocated
+ * yet, so that's not valid so far)
+ */
+#define NL80211_VENDOR_ID_IS_LINUX	0x80000000
+
+/**
+ * struct nl80211_vendor_cmd_info - vendor command data
+ * @vendor_id: If the %NL80211_VENDOR_ID_IS_LINUX flag is clear, then the
+ *	value is a 24-bit OUI; if it is set then a separately allocated ID
+ *	may be used, but no such IDs are allocated yet. New IDs should be
+ *	added to this file when needed.
+ * @subcmd: sub-command ID for the command
+ */
+struct nl80211_vendor_cmd_info {
+	__u32 vendor_id;
+	__u32 subcmd;
+};
+
+/**
+ * enum nl80211_tdls_peer_capability - TDLS peer flags.
+ *
+ * Used by tdls_mgmt() to determine which conditional elements need
+ * to be added to TDLS Setup frames.
+ *
+ * @NL80211_TDLS_PEER_HT: TDLS peer is HT capable.
+ * @NL80211_TDLS_PEER_VHT: TDLS peer is VHT capable.
+ * @NL80211_TDLS_PEER_WMM: TDLS peer is WMM capable.
+ */
+enum nl80211_tdls_peer_capability {
+	NL80211_TDLS_PEER_HT = 1<<0,
+	NL80211_TDLS_PEER_VHT = 1<<1,
+	NL80211_TDLS_PEER_WMM = 1<<2,
+};
+
+/**
+ * enum nl80211_sched_scan_plan - scanning plan for scheduled scan
+ * @__NL80211_SCHED_SCAN_PLAN_INVALID: attribute number 0 is reserved
+ * @NL80211_SCHED_SCAN_PLAN_INTERVAL: interval between scan iterations. In
+ *	seconds (u32).
+ * @NL80211_SCHED_SCAN_PLAN_ITERATIONS: number of scan iterations in this
+ *	scan plan (u32). The last scan plan must not specify this attribute
+ *	because it will run infinitely. A value of zero is invalid as it will
+ *	make the scan plan meaningless.
+ * @NL80211_SCHED_SCAN_PLAN_MAX: highest scheduled scan plan attribute number
+ *	currently defined
+ * @__NL80211_SCHED_SCAN_PLAN_AFTER_LAST: internal use
+ */
+enum nl80211_sched_scan_plan {
+	__NL80211_SCHED_SCAN_PLAN_INVALID,
+	NL80211_SCHED_SCAN_PLAN_INTERVAL,
+	NL80211_SCHED_SCAN_PLAN_ITERATIONS,
+
+	/* keep last */
+	__NL80211_SCHED_SCAN_PLAN_AFTER_LAST,
+	NL80211_SCHED_SCAN_PLAN_MAX =
+		__NL80211_SCHED_SCAN_PLAN_AFTER_LAST - 1
+};
+
+/**
+ * struct nl80211_bss_select_rssi_adjust - RSSI adjustment parameters.
+ *
+ * @band: band of BSS that must match for RSSI value adjustment. The value
+ *	of this field is according to &enum nl80211_band.
+ * @delta: value used to adjust the RSSI value of matching BSS in dB.
+ */
+struct nl80211_bss_select_rssi_adjust {
+	__u8 band;
+	__s8 delta;
+} __attribute__((packed));
+
+/**
+ * enum nl80211_bss_select_attr - attributes for bss selection.
+ *
+ * @__NL80211_BSS_SELECT_ATTR_INVALID: reserved.
+ * @NL80211_BSS_SELECT_ATTR_RSSI: Flag indicating only RSSI-based BSS selection
+ *	is requested.
+ * @NL80211_BSS_SELECT_ATTR_BAND_PREF: attribute indicating BSS
+ *	selection should be done such that the specified band is preferred.
+ *	When there are multiple BSS-es in the preferred band, the driver
+ *	shall use RSSI-based BSS selection as a second step. The value of
+ *	this attribute is according to &enum nl80211_band (u32).
+ * @NL80211_BSS_SELECT_ATTR_RSSI_ADJUST: When present the RSSI level for
+ *	BSS-es in the specified band is to be adjusted before doing
+ *	RSSI-based BSS selection. The attribute value is a packed structure
+ *	value as specified by &struct nl80211_bss_select_rssi_adjust.
+ * @NL80211_BSS_SELECT_ATTR_MAX: highest bss select attribute number.
+ * @__NL80211_BSS_SELECT_ATTR_AFTER_LAST: internal use.
+ *
+ * One and only one of these attributes are found within %NL80211_ATTR_BSS_SELECT
+ * for %NL80211_CMD_CONNECT. It specifies the required BSS selection behaviour
+ * which the driver shall use.
+ */
+enum nl80211_bss_select_attr {
+	__NL80211_BSS_SELECT_ATTR_INVALID,
+	NL80211_BSS_SELECT_ATTR_RSSI,
+	NL80211_BSS_SELECT_ATTR_BAND_PREF,
+	NL80211_BSS_SELECT_ATTR_RSSI_ADJUST,
+
+	/* keep last */
+	__NL80211_BSS_SELECT_ATTR_AFTER_LAST,
+	NL80211_BSS_SELECT_ATTR_MAX = __NL80211_BSS_SELECT_ATTR_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_nan_function_type - NAN function type
+ *
+ * Defines the function type of a NAN function
+ *
+ * @NL80211_NAN_FUNC_PUBLISH: function is publish
+ * @NL80211_NAN_FUNC_SUBSCRIBE: function is subscribe
+ * @NL80211_NAN_FUNC_FOLLOW_UP: function is follow-up
+ */
+enum nl80211_nan_function_type {
+	NL80211_NAN_FUNC_PUBLISH,
+	NL80211_NAN_FUNC_SUBSCRIBE,
+	NL80211_NAN_FUNC_FOLLOW_UP,
+
+	/* keep last */
+	__NL80211_NAN_FUNC_TYPE_AFTER_LAST,
+	NL80211_NAN_FUNC_MAX_TYPE = __NL80211_NAN_FUNC_TYPE_AFTER_LAST - 1,
+};
+
+/**
+ * enum nl80211_nan_publish_type - NAN publish tx type
+ *
+ * Defines how to send publish Service Discovery Frames
+ *
+ * @NL80211_NAN_SOLICITED_PUBLISH: publish function is solicited
+ * @NL80211_NAN_UNSOLICITED_PUBLISH: publish function is unsolicited
+ */
+enum nl80211_nan_publish_type {
+	NL80211_NAN_SOLICITED_PUBLISH = 1 << 0,
+	NL80211_NAN_UNSOLICITED_PUBLISH = 1 << 1,
+};
+
+/**
+ * enum nl80211_nan_func_term_reason - NAN functions termination reason
+ *
+ * Defines termination reasons of a NAN function
+ *
+ * @NL80211_NAN_FUNC_TERM_REASON_USER_REQUEST: requested by user
+ * @NL80211_NAN_FUNC_TERM_REASON_TTL_EXPIRED: timeout
+ * @NL80211_NAN_FUNC_TERM_REASON_ERROR: errored
+ */
+enum nl80211_nan_func_term_reason {
+	NL80211_NAN_FUNC_TERM_REASON_USER_REQUEST,
+	NL80211_NAN_FUNC_TERM_REASON_TTL_EXPIRED,
+	NL80211_NAN_FUNC_TERM_REASON_ERROR,
+};
+
+#define NL80211_NAN_FUNC_SERVICE_ID_LEN 6
+#define NL80211_NAN_FUNC_SERVICE_SPEC_INFO_MAX_LEN 0xff
+#define NL80211_NAN_FUNC_SRF_MAX_LEN 0xff
+
+/**
+ * enum nl80211_nan_func_attributes - NAN function attributes
+ * @__NL80211_NAN_FUNC_INVALID: invalid
+ * @NL80211_NAN_FUNC_TYPE: &enum nl80211_nan_function_type (u8).
+ * @NL80211_NAN_FUNC_SERVICE_ID: 6 bytes of the service ID hash as
+ *	specified in NAN spec. This is a binary attribute.
+ * @NL80211_NAN_FUNC_PUBLISH_TYPE: relevant if the function's type is
+ *	publish. Defines the transmission type for the publish Service Discovery
+ *	Frame, see &enum nl80211_nan_publish_type. Its type is u8.
+ * @NL80211_NAN_FUNC_PUBLISH_BCAST: relevant if the function is a solicited
+ *	publish. Should the solicited publish Service Discovery Frame be sent to
+ *	the NAN Broadcast address. This is a flag.
+ * @NL80211_NAN_FUNC_SUBSCRIBE_ACTIVE: relevant if the function's type is
+ *	subscribe. Is the subscribe active. This is a flag.
+ * @NL80211_NAN_FUNC_FOLLOW_UP_ID: relevant if the function's type is follow up.
+ *	The instance ID for the follow up Service Discovery Frame. This is u8.
+ * @NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID: relevant if the function's type
+ *	is follow up. This is a u8.
+ *	The requestor instance ID for the follow up Service Discovery Frame.
+ * @NL80211_NAN_FUNC_FOLLOW_UP_DEST: the MAC address of the recipient of the
+ *	follow up Service Discovery Frame. This is a binary attribute.
+ * @NL80211_NAN_FUNC_CLOSE_RANGE: is this function limited for devices in a
+ *	close range. The range itself (RSSI) is defined by the device.
+ *	This is a flag.
+ * @NL80211_NAN_FUNC_TTL: strictly positive number of DWs this function should
+ *	stay active. If not present infinite TTL is assumed. This is a u32.
+ * @NL80211_NAN_FUNC_SERVICE_INFO: array of bytes describing the service
+ *	specific info. This is a binary attribute.
+ * @NL80211_NAN_FUNC_SRF: Service Receive Filter. This is a nested attribute.
+ *	See &enum nl80211_nan_srf_attributes.
+ * @NL80211_NAN_FUNC_RX_MATCH_FILTER: Receive Matching filter. This is a nested
+ *	attribute. It is a list of binary values.
+ * @NL80211_NAN_FUNC_TX_MATCH_FILTER: Transmit Matching filter. This is a
+ *	nested attribute. It is a list of binary values.
+ * @NL80211_NAN_FUNC_INSTANCE_ID: The instance ID of the function.
+ *	Its type is u8 and it cannot be 0.
+ * @NL80211_NAN_FUNC_TERM_REASON: NAN function termination reason.
+ *	See &enum nl80211_nan_func_term_reason.
+ *
+ * @NUM_NL80211_NAN_FUNC_ATTR: internal
+ * @NL80211_NAN_FUNC_ATTR_MAX: highest NAN function attribute
+ */
+enum nl80211_nan_func_attributes {
+	__NL80211_NAN_FUNC_INVALID,
+	NL80211_NAN_FUNC_TYPE,
+	NL80211_NAN_FUNC_SERVICE_ID,
+	NL80211_NAN_FUNC_PUBLISH_TYPE,
+	NL80211_NAN_FUNC_PUBLISH_BCAST,
+	NL80211_NAN_FUNC_SUBSCRIBE_ACTIVE,
+	NL80211_NAN_FUNC_FOLLOW_UP_ID,
+	NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID,
+	NL80211_NAN_FUNC_FOLLOW_UP_DEST,
+	NL80211_NAN_FUNC_CLOSE_RANGE,
+	NL80211_NAN_FUNC_TTL,
+	NL80211_NAN_FUNC_SERVICE_INFO,
+	NL80211_NAN_FUNC_SRF,
+	NL80211_NAN_FUNC_RX_MATCH_FILTER,
+	NL80211_NAN_FUNC_TX_MATCH_FILTER,
+	NL80211_NAN_FUNC_INSTANCE_ID,
+	NL80211_NAN_FUNC_TERM_REASON,
+
+	/* keep last */
+	NUM_NL80211_NAN_FUNC_ATTR,
+	NL80211_NAN_FUNC_ATTR_MAX = NUM_NL80211_NAN_FUNC_ATTR - 1
+};
+
+/**
+ * enum nl80211_nan_srf_attributes - NAN Service Response filter attributes
+ * @__NL80211_NAN_SRF_INVALID: invalid
+ * @NL80211_NAN_SRF_INCLUDE: present if the include bit of the SRF set.
+ *	This is a flag.
+ * @NL80211_NAN_SRF_BF: Bloom Filter. Present if and only if
+ *	%NL80211_NAN_SRF_MAC_ADDRS isn't present. This attribute is binary.
+ * @NL80211_NAN_SRF_BF_IDX: index of the Bloom Filter. Mandatory if
+ *	%NL80211_NAN_SRF_BF is present. This is a u8.
+ * @NL80211_NAN_SRF_MAC_ADDRS: list of MAC addresses for the SRF. Present if
+ *	and only if %NL80211_NAN_SRF_BF isn't present. This is a nested
+ *	attribute. Each nested attribute is a MAC address.
+ * @NUM_NL80211_NAN_SRF_ATTR: internal
+ * @NL80211_NAN_SRF_ATTR_MAX: highest NAN SRF attribute
+ */
+enum nl80211_nan_srf_attributes {
+	__NL80211_NAN_SRF_INVALID,
+	NL80211_NAN_SRF_INCLUDE,
+	NL80211_NAN_SRF_BF,
+	NL80211_NAN_SRF_BF_IDX,
+	NL80211_NAN_SRF_MAC_ADDRS,
+
+	/* keep last */
+	NUM_NL80211_NAN_SRF_ATTR,
+	NL80211_NAN_SRF_ATTR_MAX = NUM_NL80211_NAN_SRF_ATTR - 1,
+};
+
+/**
+ * enum nl80211_nan_match_attributes - NAN match attributes
+ * @__NL80211_NAN_MATCH_INVALID: invalid
+ * @NL80211_NAN_MATCH_FUNC_LOCAL: the local function that had the
+ *	match. This is a nested attribute.
+ *	See &enum nl80211_nan_func_attributes.
+ * @NL80211_NAN_MATCH_FUNC_PEER: the peer function
+ *	that caused the match. This is a nested attribute.
+ *	See &enum nl80211_nan_func_attributes.
+ *
+ * @NUM_NL80211_NAN_MATCH_ATTR: internal
+ * @NL80211_NAN_MATCH_ATTR_MAX: highest NAN match attribute
+ */
+enum nl80211_nan_match_attributes {
+	__NL80211_NAN_MATCH_INVALID,
+	NL80211_NAN_MATCH_FUNC_LOCAL,
+	NL80211_NAN_MATCH_FUNC_PEER,
+
+	/* keep last */
+	NUM_NL80211_NAN_MATCH_ATTR,
+	NL80211_NAN_MATCH_ATTR_MAX = NUM_NL80211_NAN_MATCH_ATTR - 1
+};
+
+/**
+ * nl80211_external_auth_action - Action to perform with external
+ *     authentication request. Used by NL80211_ATTR_EXTERNAL_AUTH_ACTION.
+ * @NL80211_EXTERNAL_AUTH_START: Start the authentication.
+ * @NL80211_EXTERNAL_AUTH_ABORT: Abort the ongoing authentication.
+ */
+enum nl80211_external_auth_action {
+	NL80211_EXTERNAL_AUTH_START,
+	NL80211_EXTERNAL_AUTH_ABORT,
+};
+
+/**
+ * enum nl80211_ftm_responder_attributes - fine timing measurement
+ *	responder attributes
+ * @__NL80211_FTM_RESP_ATTR_INVALID: Invalid
+ * @NL80211_FTM_RESP_ATTR_ENABLED: FTM responder is enabled
+ * @NL80211_FTM_RESP_ATTR_LCI: The content of Measurement Report Element
+ *	(9.4.2.22 in 802.11-2016) with type 8 - LCI (9.4.2.22.10),
+ *	i.e. starting with the measurement token
+ * @NL80211_FTM_RESP_ATTR_CIVIC: The content of Measurement Report Element
+ *	(9.4.2.22 in 802.11-2016) with type 11 - Civic (Section 9.4.2.22.13),
+ *	i.e. starting with the measurement token
+ * @__NL80211_FTM_RESP_ATTR_LAST: Internal
+ * @NL80211_FTM_RESP_ATTR_MAX: highest FTM responder attribute.
+ */
+enum nl80211_ftm_responder_attributes {
+	__NL80211_FTM_RESP_ATTR_INVALID,
+
+	NL80211_FTM_RESP_ATTR_ENABLED,
+	NL80211_FTM_RESP_ATTR_LCI,
+	NL80211_FTM_RESP_ATTR_CIVICLOC,
+
+	/* keep last */
+	__NL80211_FTM_RESP_ATTR_LAST,
+	NL80211_FTM_RESP_ATTR_MAX = __NL80211_FTM_RESP_ATTR_LAST - 1,
+};
+
+/*
+ * enum nl80211_ftm_responder_stats - FTM responder statistics
+ *
+ * These attribute types are used with %NL80211_ATTR_FTM_RESPONDER_STATS
+ * when getting FTM responder statistics.
+ *
+ * @__NL80211_FTM_STATS_INVALID: attribute number 0 is reserved
+ * @NL80211_FTM_STATS_SUCCESS_NUM: number of FTM sessions in which all frames
+ *	were ssfully answered (u32)
+ * @NL80211_FTM_STATS_PARTIAL_NUM: number of FTM sessions in which part of the
+ *	frames were successfully answered (u32)
+ * @NL80211_FTM_STATS_FAILED_NUM: number of failed FTM sessions (u32)
+ * @NL80211_FTM_STATS_ASAP_NUM: number of ASAP sessions (u32)
+ * @NL80211_FTM_STATS_NON_ASAP_NUM: number of non-ASAP sessions (u32)
+ * @NL80211_FTM_STATS_TOTAL_DURATION_MSEC: total sessions durations - gives an
+ *	indication of how much time the responder was busy (u64, msec)
+ * @NL80211_FTM_STATS_UNKNOWN_TRIGGERS_NUM: number of unknown FTM triggers -
+ *	triggers from initiators that didn't finish successfully the negotiation
+ *	phase with the responder (u32)
+ * @NL80211_FTM_STATS_RESCHEDULE_REQUESTS_NUM: number of FTM reschedule requests
+ *	- initiator asks for a new scheduling although it already has scheduled
+ *	FTM slot (u32)
+ * @NL80211_FTM_STATS_OUT_OF_WINDOW_TRIGGERS_NUM: number of FTM triggers out of
+ *	scheduled window (u32)
+ * @NL80211_FTM_STATS_PAD: used for padding, ignore
+ * @__NL80211_TXQ_ATTR_AFTER_LAST: Internal
+ * @NL80211_FTM_STATS_MAX: highest possible FTM responder stats attribute
+ */
+enum nl80211_ftm_responder_stats {
+	__NL80211_FTM_STATS_INVALID,
+	NL80211_FTM_STATS_SUCCESS_NUM,
+	NL80211_FTM_STATS_PARTIAL_NUM,
+	NL80211_FTM_STATS_FAILED_NUM,
+	NL80211_FTM_STATS_ASAP_NUM,
+	NL80211_FTM_STATS_NON_ASAP_NUM,
+	NL80211_FTM_STATS_TOTAL_DURATION_MSEC,
+	NL80211_FTM_STATS_UNKNOWN_TRIGGERS_NUM,
+	NL80211_FTM_STATS_RESCHEDULE_REQUESTS_NUM,
+	NL80211_FTM_STATS_OUT_OF_WINDOW_TRIGGERS_NUM,
+	NL80211_FTM_STATS_PAD,
+
+	/* keep last */
+	__NL80211_FTM_STATS_AFTER_LAST,
+	NL80211_FTM_STATS_MAX = __NL80211_FTM_STATS_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_preamble - frame preamble types
+ * @NL80211_PREAMBLE_LEGACY: legacy (HR/DSSS, OFDM, ERP PHY) preamble
+ * @NL80211_PREAMBLE_HT: HT preamble
+ * @NL80211_PREAMBLE_VHT: VHT preamble
+ * @NL80211_PREAMBLE_DMG: DMG preamble
+ */
+enum nl80211_preamble {
+	NL80211_PREAMBLE_LEGACY,
+	NL80211_PREAMBLE_HT,
+	NL80211_PREAMBLE_VHT,
+	NL80211_PREAMBLE_DMG,
+};
+
+/**
+ * enum nl80211_peer_measurement_type - peer measurement types
+ * @NL80211_PMSR_TYPE_INVALID: invalid/unused, needed as we use
+ *	these numbers also for attributes
+ *
+ * @NL80211_PMSR_TYPE_FTM: flight time measurement
+ *
+ * @NUM_NL80211_PMSR_TYPES: internal
+ * @NL80211_PMSR_TYPE_MAX: highest type number
+ */
+enum nl80211_peer_measurement_type {
+	NL80211_PMSR_TYPE_INVALID,
+
+	NL80211_PMSR_TYPE_FTM,
+
+	NUM_NL80211_PMSR_TYPES,
+	NL80211_PMSR_TYPE_MAX = NUM_NL80211_PMSR_TYPES - 1
+};
+
+/**
+ * enum nl80211_peer_measurement_status - peer measurement status
+ * @NL80211_PMSR_STATUS_SUCCESS: measurement completed successfully
+ * @NL80211_PMSR_STATUS_REFUSED: measurement was locally refused
+ * @NL80211_PMSR_STATUS_TIMEOUT: measurement timed out
+ * @NL80211_PMSR_STATUS_FAILURE: measurement failed, a type-dependent
+ *	reason may be available in the response data
+ */
+enum nl80211_peer_measurement_status {
+	NL80211_PMSR_STATUS_SUCCESS,
+	NL80211_PMSR_STATUS_REFUSED,
+	NL80211_PMSR_STATUS_TIMEOUT,
+	NL80211_PMSR_STATUS_FAILURE,
+};
+
+/**
+ * enum nl80211_peer_measurement_req - peer measurement request attributes
+ * @__NL80211_PMSR_REQ_ATTR_INVALID: invalid
+ *
+ * @NL80211_PMSR_REQ_ATTR_DATA: This is a nested attribute with measurement
+ *	type-specific request data inside. The attributes used are from the
+ *	enums named nl80211_peer_measurement_<type>_req.
+ * @NL80211_PMSR_REQ_ATTR_GET_AP_TSF: include AP TSF timestamp, if supported
+ *	(flag attribute)
+ *
+ * @NUM_NL80211_PMSR_REQ_ATTRS: internal
+ * @NL80211_PMSR_REQ_ATTR_MAX: highest attribute number
+ */
+enum nl80211_peer_measurement_req {
+	__NL80211_PMSR_REQ_ATTR_INVALID,
+
+	NL80211_PMSR_REQ_ATTR_DATA,
+	NL80211_PMSR_REQ_ATTR_GET_AP_TSF,
+
+	/* keep last */
+	NUM_NL80211_PMSR_REQ_ATTRS,
+	NL80211_PMSR_REQ_ATTR_MAX = NUM_NL80211_PMSR_REQ_ATTRS - 1
+};
+
+/**
+ * enum nl80211_peer_measurement_resp - peer measurement response attributes
+ * @__NL80211_PMSR_RESP_ATTR_INVALID: invalid
+ *
+ * @NL80211_PMSR_RESP_ATTR_DATA: This is a nested attribute with measurement
+ *	type-specific results inside. The attributes used are from the enums
+ *	named nl80211_peer_measurement_<type>_resp.
+ * @NL80211_PMSR_RESP_ATTR_STATUS: u32 value with the measurement status
+ *	(using values from &enum nl80211_peer_measurement_status.)
+ * @NL80211_PMSR_RESP_ATTR_HOST_TIME: host time (%CLOCK_BOOTTIME) when the
+ *	result was measured; this value is not expected to be accurate to
+ *	more than 20ms. (u64, nanoseconds)
+ * @NL80211_PMSR_RESP_ATTR_AP_TSF: TSF of the AP that the interface
+ *	doing the measurement is connected to when the result was measured.
+ *	This shall be accurately reported if supported and requested
+ *	(u64, usec)
+ * @NL80211_PMSR_RESP_ATTR_FINAL: If results are sent to the host partially
+ *	(*e.g. with FTM per-burst data) this flag will be cleared on all but
+ *	the last result; if all results are combined it's set on the single
+ *	result.
+ * @NL80211_PMSR_RESP_ATTR_PAD: padding for 64-bit attributes, ignore
+ *
+ * @NUM_NL80211_PMSR_RESP_ATTRS: internal
+ * @NL80211_PMSR_RESP_ATTR_MAX: highest attribute number
+ */
+enum nl80211_peer_measurement_resp {
+	__NL80211_PMSR_RESP_ATTR_INVALID,
+
+	NL80211_PMSR_RESP_ATTR_DATA,
+	NL80211_PMSR_RESP_ATTR_STATUS,
+	NL80211_PMSR_RESP_ATTR_HOST_TIME,
+	NL80211_PMSR_RESP_ATTR_AP_TSF,
+	NL80211_PMSR_RESP_ATTR_FINAL,
+	NL80211_PMSR_RESP_ATTR_PAD,
+
+	/* keep last */
+	NUM_NL80211_PMSR_RESP_ATTRS,
+	NL80211_PMSR_RESP_ATTR_MAX = NUM_NL80211_PMSR_RESP_ATTRS - 1
+};
+
+/**
+ * enum nl80211_peer_measurement_peer_attrs - peer attributes for measurement
+ * @__NL80211_PMSR_PEER_ATTR_INVALID: invalid
+ *
+ * @NL80211_PMSR_PEER_ATTR_ADDR: peer's MAC address
+ * @NL80211_PMSR_PEER_ATTR_CHAN: channel definition, nested, using top-level
+ *	attributes like %NL80211_ATTR_WIPHY_FREQ etc.
+ * @NL80211_PMSR_PEER_ATTR_REQ: This is a nested attribute indexed by
+ *	measurement type, with attributes from the
+ *	&enum nl80211_peer_measurement_req inside.
+ * @NL80211_PMSR_PEER_ATTR_RESP: This is a nested attribute indexed by
+ *	measurement type, with attributes from the
+ *	&enum nl80211_peer_measurement_resp inside.
+ *
+ * @NUM_NL80211_PMSR_PEER_ATTRS: internal
+ * @NL80211_PMSR_PEER_ATTR_MAX: highest attribute number
+ */
+enum nl80211_peer_measurement_peer_attrs {
+	__NL80211_PMSR_PEER_ATTR_INVALID,
+
+	NL80211_PMSR_PEER_ATTR_ADDR,
+	NL80211_PMSR_PEER_ATTR_CHAN,
+	NL80211_PMSR_PEER_ATTR_REQ,
+	NL80211_PMSR_PEER_ATTR_RESP,
+
+	/* keep last */
+	NUM_NL80211_PMSR_PEER_ATTRS,
+	NL80211_PMSR_PEER_ATTR_MAX = NUM_NL80211_PMSR_PEER_ATTRS - 1,
+};
+
+/**
+ * enum nl80211_peer_measurement_attrs - peer measurement attributes
+ * @__NL80211_PMSR_ATTR_INVALID: invalid
+ *
+ * @NL80211_PMSR_ATTR_MAX_PEERS: u32 attribute used for capability
+ *	advertisement only, indicates the maximum number of peers
+ *	measurements can be done with in a single request
+ * @NL80211_PMSR_ATTR_REPORT_AP_TSF: flag attribute in capability
+ *	indicating that the connected AP's TSF can be reported in
+ *	measurement results
+ * @NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR: flag attribute in capability
+ *	indicating that MAC address randomization is supported.
+ * @NL80211_PMSR_ATTR_TYPE_CAPA: capabilities reported by the device,
+ *	this contains a nesting indexed by measurement type, and
+ *	type-specific capabilities inside, which are from the enums
+ *	named nl80211_peer_measurement_<type>_capa.
+ * @NL80211_PMSR_ATTR_PEERS: nested attribute, the nesting index is
+ *	meaningless, just a list of peers to measure with, with the
+ *	sub-attributes taken from
+ *	&enum nl80211_peer_measurement_peer_attrs.
+ *
+ * @NUM_NL80211_PMSR_ATTR: internal
+ * @NL80211_PMSR_ATTR_MAX: highest attribute number
+ */
+enum nl80211_peer_measurement_attrs {
+	__NL80211_PMSR_ATTR_INVALID,
+
+	NL80211_PMSR_ATTR_MAX_PEERS,
+	NL80211_PMSR_ATTR_REPORT_AP_TSF,
+	NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR,
+	NL80211_PMSR_ATTR_TYPE_CAPA,
+	NL80211_PMSR_ATTR_PEERS,
+
+	/* keep last */
+	NUM_NL80211_PMSR_ATTR,
+	NL80211_PMSR_ATTR_MAX = NUM_NL80211_PMSR_ATTR - 1
+};
+
+/**
+ * enum nl80211_peer_measurement_ftm_capa - FTM capabilities
+ * @__NL80211_PMSR_FTM_CAPA_ATTR_INVALID: invalid
+ *
+ * @NL80211_PMSR_FTM_CAPA_ATTR_ASAP: flag attribute indicating ASAP mode
+ *	is supported
+ * @NL80211_PMSR_FTM_CAPA_ATTR_NON_ASAP: flag attribute indicating non-ASAP
+ *	mode is supported
+ * @NL80211_PMSR_FTM_CAPA_ATTR_REQ_LCI: flag attribute indicating if LCI
+ *	data can be requested during the measurement
+ * @NL80211_PMSR_FTM_CAPA_ATTR_REQ_CIVICLOC: flag attribute indicating if civic
+ *	location data can be requested during the measurement
+ * @NL80211_PMSR_FTM_CAPA_ATTR_PREAMBLES: u32 bitmap attribute of bits
+ *	from &enum nl80211_preamble.
+ * @NL80211_PMSR_FTM_CAPA_ATTR_BANDWIDTHS: bitmap of values from
+ *	&enum nl80211_chan_width indicating the supported channel
+ *	bandwidths for FTM. Note that a higher channel bandwidth may be
+ *	configured to allow for other measurements types with different
+ *	bandwidth requirement in the same measurement.
+ * @NL80211_PMSR_FTM_CAPA_ATTR_MAX_BURSTS_EXPONENT: u32 attribute indicating
+ *	the maximum bursts exponent that can be used (if not present anything
+ *	is valid)
+ * @NL80211_PMSR_FTM_CAPA_ATTR_MAX_FTMS_PER_BURST: u32 attribute indicating
+ *	the maximum FTMs per burst (if not present anything is valid)
+ *
+ * @NUM_NL80211_PMSR_FTM_CAPA_ATTR: internal
+ * @NL80211_PMSR_FTM_CAPA_ATTR_MAX: highest attribute number
+ */
+enum nl80211_peer_measurement_ftm_capa {
+	__NL80211_PMSR_FTM_CAPA_ATTR_INVALID,
+
+	NL80211_PMSR_FTM_CAPA_ATTR_ASAP,
+	NL80211_PMSR_FTM_CAPA_ATTR_NON_ASAP,
+	NL80211_PMSR_FTM_CAPA_ATTR_REQ_LCI,
+	NL80211_PMSR_FTM_CAPA_ATTR_REQ_CIVICLOC,
+	NL80211_PMSR_FTM_CAPA_ATTR_PREAMBLES,
+	NL80211_PMSR_FTM_CAPA_ATTR_BANDWIDTHS,
+	NL80211_PMSR_FTM_CAPA_ATTR_MAX_BURSTS_EXPONENT,
+	NL80211_PMSR_FTM_CAPA_ATTR_MAX_FTMS_PER_BURST,
+
+	/* keep last */
+	NUM_NL80211_PMSR_FTM_CAPA_ATTR,
+	NL80211_PMSR_FTM_CAPA_ATTR_MAX = NUM_NL80211_PMSR_FTM_CAPA_ATTR - 1
+};
+
+/**
+ * enum nl80211_peer_measurement_ftm_req - FTM request attributes
+ * @__NL80211_PMSR_FTM_REQ_ATTR_INVALID: invalid
+ *
+ * @NL80211_PMSR_FTM_REQ_ATTR_ASAP: ASAP mode requested (flag)
+ * @NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE: preamble type (see
+ *	&enum nl80211_preamble), optional for DMG (u32)
+ * @NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP: number of bursts exponent as in
+ *	802.11-2016 9.4.2.168 "Fine Timing Measurement Parameters element"
+ *	(u8, 0-15, optional with default 15 i.e. "no preference")
+ * @NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD: interval between bursts in units
+ *	of 100ms (u16, optional with default 0)
+ * @NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION: burst duration, as in 802.11-2016
+ *	Table 9-257 "Burst Duration field encoding" (u8, 0-15, optional with
+ *	default 15 i.e. "no preference")
+ * @NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST: number of successful FTM frames
+ *	requested per burst
+ *	(u8, 0-31, optional with default 0 i.e. "no preference")
+ * @NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES: number of FTMR frame retries
+ *	(u8, default 3)
+ * @NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI: request LCI data (flag)
+ * @NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC: request civic location data
+ *	(flag)
+ *
+ * @NUM_NL80211_PMSR_FTM_REQ_ATTR: internal
+ * @NL80211_PMSR_FTM_REQ_ATTR_MAX: highest attribute number
+ */
+enum nl80211_peer_measurement_ftm_req {
+	__NL80211_PMSR_FTM_REQ_ATTR_INVALID,
+
+	NL80211_PMSR_FTM_REQ_ATTR_ASAP,
+	NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE,
+	NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP,
+	NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD,
+	NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION,
+	NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST,
+	NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES,
+	NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI,
+	NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC,
+
+	/* keep last */
+	NUM_NL80211_PMSR_FTM_REQ_ATTR,
+	NL80211_PMSR_FTM_REQ_ATTR_MAX = NUM_NL80211_PMSR_FTM_REQ_ATTR - 1
+};
+
+/**
+ * enum nl80211_peer_measurement_ftm_failure_reasons - FTM failure reasons
+ * @NL80211_PMSR_FTM_FAILURE_UNSPECIFIED: unspecified failure, not used
+ * @NL80211_PMSR_FTM_FAILURE_NO_RESPONSE: no response from the FTM responder
+ * @NL80211_PMSR_FTM_FAILURE_REJECTED: FTM responder rejected measurement
+ * @NL80211_PMSR_FTM_FAILURE_WRONG_CHANNEL: we already know the peer is
+ *	on a different channel, so can't measure (if we didn't know, we'd
+ *	try and get no response)
+ * @NL80211_PMSR_FTM_FAILURE_PEER_NOT_CAPABLE: peer can't actually do FTM
+ * @NL80211_PMSR_FTM_FAILURE_INVALID_TIMESTAMP: invalid T1/T4 timestamps
+ *	received
+ * @NL80211_PMSR_FTM_FAILURE_PEER_BUSY: peer reports busy, you may retry
+ *	later (see %NL80211_PMSR_FTM_RESP_ATTR_BUSY_RETRY_TIME)
+ * @NL80211_PMSR_FTM_FAILURE_BAD_CHANGED_PARAMS: parameters were changed
+ *	by the peer and are no longer supported
+ */
+enum nl80211_peer_measurement_ftm_failure_reasons {
+	NL80211_PMSR_FTM_FAILURE_UNSPECIFIED,
+	NL80211_PMSR_FTM_FAILURE_NO_RESPONSE,
+	NL80211_PMSR_FTM_FAILURE_REJECTED,
+	NL80211_PMSR_FTM_FAILURE_WRONG_CHANNEL,
+	NL80211_PMSR_FTM_FAILURE_PEER_NOT_CAPABLE,
+	NL80211_PMSR_FTM_FAILURE_INVALID_TIMESTAMP,
+	NL80211_PMSR_FTM_FAILURE_PEER_BUSY,
+	NL80211_PMSR_FTM_FAILURE_BAD_CHANGED_PARAMS,
+};
+
+/**
+ * enum nl80211_peer_measurement_ftm_resp - FTM response attributes
+ * @__NL80211_PMSR_FTM_RESP_ATTR_INVALID: invalid
+ *
+ * @NL80211_PMSR_FTM_RESP_ATTR_FAIL_REASON: FTM-specific failure reason
+ *	(u32, optional)
+ * @NL80211_PMSR_FTM_RESP_ATTR_BURST_INDEX: optional, if bursts are reported
+ *	as separate results then it will be the burst index 0...(N-1) and
+ *	the top level will indicate partial results (u32)
+ * @NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_ATTEMPTS: number of FTM Request frames
+ *	transmitted (u32, optional)
+ * @NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_SUCCESSES: number of FTM Request frames
+ *	that were acknowleged (u32, optional)
+ * @NL80211_PMSR_FTM_RESP_ATTR_BUSY_RETRY_TIME: retry time received from the
+ *	busy peer (u32, seconds)
+ * @NL80211_PMSR_FTM_RESP_ATTR_NUM_BURSTS_EXP: actual number of bursts exponent
+ *	used by the responder (similar to request, u8)
+ * @NL80211_PMSR_FTM_RESP_ATTR_BURST_DURATION: actual burst duration used by
+ *	the responder (similar to request, u8)
+ * @NL80211_PMSR_FTM_RESP_ATTR_FTMS_PER_BURST: actual FTMs per burst used
+ *	by the responder (similar to request, u8)
+ * @NL80211_PMSR_FTM_RESP_ATTR_RSSI_AVG: average RSSI across all FTM action
+ *	frames (optional, s32, 1/2 dBm)
+ * @NL80211_PMSR_FTM_RESP_ATTR_RSSI_SPREAD: RSSI spread across all FTM action
+ *	frames (optional, s32, 1/2 dBm)
+ * @NL80211_PMSR_FTM_RESP_ATTR_TX_RATE: bitrate we used for the response to the
+ *	FTM action frame (optional, nested, using &enum nl80211_rate_info
+ *	attributes)
+ * @NL80211_PMSR_FTM_RESP_ATTR_RX_RATE: bitrate the responder used for the FTM
+ *	action frame (optional, nested, using &enum nl80211_rate_info attrs)
+ * @NL80211_PMSR_FTM_RESP_ATTR_RTT_AVG: average RTT (s64, picoseconds, optional
+ *	but one of RTT/DIST must be present)
+ * @NL80211_PMSR_FTM_RESP_ATTR_RTT_VARIANCE: RTT variance (u64, ps^2, note that
+ *	standard deviation is the square root of variance, optional)
+ * @NL80211_PMSR_FTM_RESP_ATTR_RTT_SPREAD: RTT spread (u64, picoseconds,
+ *	optional)
+ * @NL80211_PMSR_FTM_RESP_ATTR_DIST_AVG: average distance (s64, mm, optional
+ *	but one of RTT/DIST must be present)
+ * @NL80211_PMSR_FTM_RESP_ATTR_DIST_VARIANCE: distance variance (u64, mm^2, note
+ *	that standard deviation is the square root of variance, optional)
+ * @NL80211_PMSR_FTM_RESP_ATTR_DIST_SPREAD: distance spread (u64, mm, optional)
+ * @NL80211_PMSR_FTM_RESP_ATTR_LCI: LCI data from peer (binary, optional);
+ *	this is the contents of the Measurement Report Element (802.11-2016
+ *	9.4.2.22.1) starting with the Measurement Token, with Measurement
+ *	Type 8.
+ * @NL80211_PMSR_FTM_RESP_ATTR_CIVICLOC: civic location data from peer
+ *	(binary, optional);
+ *	this is the contents of the Measurement Report Element (802.11-2016
+ *	9.4.2.22.1) starting with the Measurement Token, with Measurement
+ *	Type 11.
+ * @NL80211_PMSR_FTM_RESP_ATTR_PAD: ignore, for u64/s64 padding only
+ *
+ * @NUM_NL80211_PMSR_FTM_RESP_ATTR: internal
+ * @NL80211_PMSR_FTM_RESP_ATTR_MAX: highest attribute number
+ */
+enum nl80211_peer_measurement_ftm_resp {
+	__NL80211_PMSR_FTM_RESP_ATTR_INVALID,
+
+	NL80211_PMSR_FTM_RESP_ATTR_FAIL_REASON,
+	NL80211_PMSR_FTM_RESP_ATTR_BURST_INDEX,
+	NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_ATTEMPTS,
+	NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_SUCCESSES,
+	NL80211_PMSR_FTM_RESP_ATTR_BUSY_RETRY_TIME,
+	NL80211_PMSR_FTM_RESP_ATTR_NUM_BURSTS_EXP,
+	NL80211_PMSR_FTM_RESP_ATTR_BURST_DURATION,
+	NL80211_PMSR_FTM_RESP_ATTR_FTMS_PER_BURST,
+	NL80211_PMSR_FTM_RESP_ATTR_RSSI_AVG,
+	NL80211_PMSR_FTM_RESP_ATTR_RSSI_SPREAD,
+	NL80211_PMSR_FTM_RESP_ATTR_TX_RATE,
+	NL80211_PMSR_FTM_RESP_ATTR_RX_RATE,
+	NL80211_PMSR_FTM_RESP_ATTR_RTT_AVG,
+	NL80211_PMSR_FTM_RESP_ATTR_RTT_VARIANCE,
+	NL80211_PMSR_FTM_RESP_ATTR_RTT_SPREAD,
+	NL80211_PMSR_FTM_RESP_ATTR_DIST_AVG,
+	NL80211_PMSR_FTM_RESP_ATTR_DIST_VARIANCE,
+	NL80211_PMSR_FTM_RESP_ATTR_DIST_SPREAD,
+	NL80211_PMSR_FTM_RESP_ATTR_LCI,
+	NL80211_PMSR_FTM_RESP_ATTR_CIVICLOC,
+	NL80211_PMSR_FTM_RESP_ATTR_PAD,
+
+	/* keep last */
+	NUM_NL80211_PMSR_FTM_RESP_ATTR,
+	NL80211_PMSR_FTM_RESP_ATTR_MAX = NUM_NL80211_PMSR_FTM_RESP_ATTR - 1
+};
+
+/**
+ * enum nl80211_obss_pd_attributes - OBSS packet detection attributes
+ * @__NL80211_HE_OBSS_PD_ATTR_INVALID: Invalid
+ *
+ * @NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET: the OBSS PD minimum tx power offset.
+ * @NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET: the OBSS PD maximum tx power offset.
+ *
+ * @__NL80211_HE_OBSS_PD_ATTR_LAST: Internal
+ * @NL80211_HE_OBSS_PD_ATTR_MAX: highest OBSS PD attribute.
+ */
+enum nl80211_obss_pd_attributes {
+	__NL80211_HE_OBSS_PD_ATTR_INVALID,
+
+	NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET,
+	NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET,
+
+	/* keep last */
+	__NL80211_HE_OBSS_PD_ATTR_LAST,
+	NL80211_HE_OBSS_PD_ATTR_MAX = __NL80211_HE_OBSS_PD_ATTR_LAST - 1,
+};
+
+/**
+ * enum nl80211_bss_color_attributes - BSS Color attributes
+ * @__NL80211_HE_BSS_COLOR_ATTR_INVALID: Invalid
+ *
+ * @NL80211_HE_BSS_COLOR_ATTR_COLOR: the current BSS Color.
+ * @NL80211_HE_BSS_COLOR_ATTR_DISABLED: is BSS coloring disabled.
+ * @NL80211_HE_BSS_COLOR_ATTR_PARTIAL: the AID equation to be used..
+ *
+ * @__NL80211_HE_BSS_COLOR_ATTR_LAST: Internal
+ * @NL80211_HE_BSS_COLOR_ATTR_MAX: highest BSS Color attribute.
+ */
+enum nl80211_bss_color_attributes {
+	__NL80211_HE_BSS_COLOR_ATTR_INVALID,
+
+	NL80211_HE_BSS_COLOR_ATTR_COLOR,
+	NL80211_HE_BSS_COLOR_ATTR_DISABLED,
+	NL80211_HE_BSS_COLOR_ATTR_PARTIAL,
+
+	/* keep last */
+	__NL80211_HE_BSS_COLOR_ATTR_LAST,
+	NL80211_HE_BSS_COLOR_ATTR_MAX = __NL80211_HE_BSS_COLOR_ATTR_LAST - 1,
+};
+
+/**
+ * enum nl80211_iftype_akm_attributes - interface type AKM attributes
+ * @__NL80211_IFTYPE_AKM_ATTR_INVALID: Invalid
+ *
+ * @NL80211_IFTYPE_AKM_ATTR_IFTYPES: nested attribute containing a flag
+ *	attribute for each interface type that supports AKM suites specified in
+ *	%NL80211_IFTYPE_AKM_ATTR_SUITES
+ * @NL80211_IFTYPE_AKM_ATTR_SUITES: an array of u32. Used to indicate supported
+ *	AKM suites for the specified interface types.
+ *
+ * @__NL80211_IFTYPE_AKM_ATTR_LAST: Internal
+ * @NL80211_IFTYPE_AKM_ATTR_MAX: highest interface type AKM attribute.
+ */
+enum nl80211_iftype_akm_attributes {
+	__NL80211_IFTYPE_AKM_ATTR_INVALID,
+
+	NL80211_IFTYPE_AKM_ATTR_IFTYPES,
+	NL80211_IFTYPE_AKM_ATTR_SUITES,
+
+	/* keep last */
+	__NL80211_IFTYPE_AKM_ATTR_LAST,
+	NL80211_IFTYPE_AKM_ATTR_MAX = __NL80211_IFTYPE_AKM_ATTR_LAST - 1,
+};
+
+#endif /* __LINUX_NL80211_H */
diff -Naurp a/drivers/net/wireless/xr829/readme.md b/drivers/net/wireless/xr829/readme.md
--- a/drivers/net/wireless/xr829/readme.md	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/readme.md	2022-08-27 01:22:42.930539771 +0300
@@ -0,0 +1,5 @@
+# Allwinner/XRadio XR829 Module
+
+**STILL WIP!**
+
+Based on linux kernel 5.4.61 in Allwinner's D1 SDK. Just about to compile separately, not yet tested. 
diff -Naurp a/drivers/net/wireless/xr829/umac/aes_ccm.c b/drivers/net/wireless/xr829/umac/aes_ccm.c
--- a/drivers/net/wireless/xr829/umac/aes_ccm.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/aes_ccm.c	2022-08-27 01:22:42.930539771 +0300
@@ -0,0 +1,150 @@
+/*
+ * Copyright 2003-2004, Instant802 Networks, Inc.
+ * Copyright 2005-2006, Devicescape Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/crypto.h>
+#include <linux/err.h>
+#include <crypto/aes.h>
+
+#include <net/mac80211.h>
+#include "key.h"
+#include "aes_ccm.h"
+
+static void aes_ccm_prepare(struct crypto_cipher *tfm, u8 *scratch, u8 *a)
+{
+	int i;
+	u8 *b_0, *aad, *b, *s_0;
+
+	b_0 = scratch + 3 * AES_BLOCK_SIZE;
+	aad = scratch + 4 * AES_BLOCK_SIZE;
+	b = scratch;
+	s_0 = scratch + AES_BLOCK_SIZE;
+
+	crypto_cipher_encrypt_one(tfm, b, b_0);
+
+	/* Extra Authenticate-only data (always two AES blocks) */
+	for (i = 0; i < AES_BLOCK_SIZE; i++)
+		aad[i] ^= b[i];
+	crypto_cipher_encrypt_one(tfm, b, aad);
+
+	aad += AES_BLOCK_SIZE;
+
+	for (i = 0; i < AES_BLOCK_SIZE; i++)
+		aad[i] ^= b[i];
+	crypto_cipher_encrypt_one(tfm, a, aad);
+
+	/* Mask out bits from auth-only-b_0 */
+	b_0[0] &= 0x07;
+
+	/* S_0 is used to encrypt T (= MIC) */
+	b_0[14] = 0;
+	b_0[15] = 0;
+	crypto_cipher_encrypt_one(tfm, s_0, b_0);
+}
+
+
+void mac80211_aes_ccm_encrypt(struct crypto_cipher *tfm, u8 *scratch,
+			       u8 *data, size_t data_len,
+			       u8 *cdata, u8 *mic)
+{
+	int i, j, last_len, num_blocks;
+	u8 *pos, *cpos, *b, *s_0, *e, *b_0;
+
+	b = scratch;
+	s_0 = scratch + AES_BLOCK_SIZE;
+	e = scratch + 2 * AES_BLOCK_SIZE;
+	b_0 = scratch + 3 * AES_BLOCK_SIZE;
+
+	num_blocks = DIV_ROUND_UP(data_len, AES_BLOCK_SIZE);
+	last_len = data_len % AES_BLOCK_SIZE;
+	aes_ccm_prepare(tfm, scratch, b);
+
+	/* Process payload blocks */
+	pos = data;
+	cpos = cdata;
+	for (j = 1; j <= num_blocks; j++) {
+		int blen = (j == num_blocks && last_len) ?
+			last_len : AES_BLOCK_SIZE;
+
+		/* Authentication followed by encryption */
+		for (i = 0; i < blen; i++)
+			b[i] ^= pos[i];
+		crypto_cipher_encrypt_one(tfm, b, b);
+
+		b_0[14] = (j >> 8) & 0xff;
+		b_0[15] = j & 0xff;
+		crypto_cipher_encrypt_one(tfm, e, b_0);
+		for (i = 0; i < blen; i++)
+			*cpos++ = *pos++ ^ e[i];
+	}
+
+	for (i = 0; i < CCMP_MIC_LEN; i++)
+		mic[i] = b[i] ^ s_0[i];
+}
+
+
+int mac80211_aes_ccm_decrypt(struct crypto_cipher *tfm, u8 *scratch,
+			      u8 *cdata, size_t data_len, u8 *mic, u8 *data)
+{
+	int i, j, last_len, num_blocks;
+	u8 *pos, *cpos, *b, *s_0, *a, *b_0;
+
+	b = scratch;
+	s_0 = scratch + AES_BLOCK_SIZE;
+	a = scratch + 2 * AES_BLOCK_SIZE;
+	b_0 = scratch + 3 * AES_BLOCK_SIZE;
+
+	num_blocks = DIV_ROUND_UP(data_len, AES_BLOCK_SIZE);
+	last_len = data_len % AES_BLOCK_SIZE;
+	aes_ccm_prepare(tfm, scratch, a);
+
+	/* Process payload blocks */
+	cpos = cdata;
+	pos = data;
+	for (j = 1; j <= num_blocks; j++) {
+		int blen = (j == num_blocks && last_len) ?
+			last_len : AES_BLOCK_SIZE;
+
+		/* Decryption followed by authentication */
+		b_0[14] = (j >> 8) & 0xff;
+		b_0[15] = j & 0xff;
+		crypto_cipher_encrypt_one(tfm, b, b_0);
+		for (i = 0; i < blen; i++) {
+			*pos = *cpos++ ^ b[i];
+			a[i] ^= *pos++;
+		}
+		crypto_cipher_encrypt_one(tfm, a, a);
+	}
+
+	for (i = 0; i < CCMP_MIC_LEN; i++) {
+		if ((mic[i] ^ s_0[i]) != a[i])
+			return -1;
+	}
+
+	return 0;
+}
+
+
+struct crypto_cipher *mac80211_aes_key_setup_encrypt(const u8 key[])
+{
+	struct crypto_cipher *tfm;
+
+	tfm = crypto_alloc_cipher("aes", 0, CRYPTO_ALG_ASYNC);
+	if (!IS_ERR(tfm))
+		crypto_cipher_setkey(tfm, key, ALG_CCMP_KEY_LEN);
+
+	return tfm;
+}
+
+
+void mac80211_aes_key_free(struct crypto_cipher *tfm)
+{
+	crypto_free_cipher(tfm);
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/aes_ccm.h b/drivers/net/wireless/xr829/umac/aes_ccm.h
--- a/drivers/net/wireless/xr829/umac/aes_ccm.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/aes_ccm.h	2022-08-27 01:22:42.930539771 +0300
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2003-2004, Instant802 Networks, Inc.
+ * Copyright 2006, Devicescape Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef AES_CCM_H
+#define AES_CCM_H
+
+#include <linux/crypto.h>
+
+struct crypto_cipher *mac80211_aes_key_setup_encrypt(const u8 key[]);
+void mac80211_aes_ccm_encrypt(struct crypto_cipher *tfm, u8 *scratch,
+			       u8 *data, size_t data_len,
+			       u8 *cdata, u8 *mic);
+int mac80211_aes_ccm_decrypt(struct crypto_cipher *tfm, u8 *scratch,
+			      u8 *cdata, size_t data_len,
+			      u8 *mic, u8 *data);
+void mac80211_aes_key_free(struct crypto_cipher *tfm);
+
+#endif /* AES_CCM_H */
diff -Naurp a/drivers/net/wireless/xr829/umac/aes_cmac.c b/drivers/net/wireless/xr829/umac/aes_cmac.c
--- a/drivers/net/wireless/xr829/umac/aes_cmac.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/aes_cmac.c	2022-08-27 01:22:42.934539786 +0300
@@ -0,0 +1,132 @@
+/*
+ * AES-128-CMAC with TLen 16 for IEEE 802.11w BIP
+ * Copyright 2008, Jouni Malinen <j@w1.fi>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/crypto.h>
+#include <linux/err.h>
+#include <crypto/aes.h>
+
+#include <net/mac80211.h>
+#include "key.h"
+#include "aes_cmac.h"
+
+#define AES_CMAC_KEY_LEN 16
+#define CMAC_TLEN 8 /* CMAC TLen = 64 bits (8 octets) */
+#define AAD_LEN 20
+
+
+static void gf_mulx(u8 *pad)
+{
+	int i, carry;
+
+	carry = pad[0] & 0x80;
+	for (i = 0; i < AES_BLOCK_SIZE - 1; i++)
+		pad[i] = (pad[i] << 1) | (pad[i + 1] >> 7);
+	pad[AES_BLOCK_SIZE - 1] <<= 1;
+	if (carry)
+		pad[AES_BLOCK_SIZE - 1] ^= 0x87;
+}
+
+
+static void aes_128_cmac_vector(struct crypto_cipher *tfm, size_t num_elem,
+				const u8 *addr[], const size_t *len, u8 *mac)
+{
+	u8 scratch[2 * AES_BLOCK_SIZE];
+	u8 *cbc, *pad;
+	const u8 *pos, *end;
+	size_t i, e, left, total_len;
+
+	cbc = scratch;
+	pad = scratch + AES_BLOCK_SIZE;
+
+	memset(cbc, 0, AES_BLOCK_SIZE);
+
+	total_len = 0;
+	for (e = 0; e < num_elem; e++)
+		total_len += len[e];
+	left = total_len;
+
+	e = 0;
+	pos = addr[0];
+	end = pos + len[0];
+
+	while (left >= AES_BLOCK_SIZE) {
+		for (i = 0; i < AES_BLOCK_SIZE; i++) {
+			cbc[i] ^= *pos++;
+			if (pos >= end) {
+				e++;
+				pos = addr[e];
+				end = pos + len[e];
+			}
+		}
+		if (left > AES_BLOCK_SIZE)
+			crypto_cipher_encrypt_one(tfm, cbc, cbc);
+		left -= AES_BLOCK_SIZE;
+	}
+
+	memset(pad, 0, AES_BLOCK_SIZE);
+	crypto_cipher_encrypt_one(tfm, pad, pad);
+	gf_mulx(pad);
+
+	if (left || total_len == 0) {
+		for (i = 0; i < left; i++) {
+			cbc[i] ^= *pos++;
+			if (pos >= end) {
+				e++;
+				pos = addr[e];
+				end = pos + len[e];
+			}
+		}
+		cbc[left] ^= 0x80;
+		gf_mulx(pad);
+	}
+
+	for (i = 0; i < AES_BLOCK_SIZE; i++)
+		pad[i] ^= cbc[i];
+	crypto_cipher_encrypt_one(tfm, pad, pad);
+	memcpy(mac, pad, CMAC_TLEN);
+}
+
+
+void mac80211_aes_cmac(struct crypto_cipher *tfm, const u8 *aad,
+			const u8 *data, size_t data_len, u8 *mic)
+{
+	const u8 *addr[3];
+	size_t len[3];
+	u8 zero[CMAC_TLEN];
+
+	memset(zero, 0, CMAC_TLEN);
+	addr[0] = aad;
+	len[0] = AAD_LEN;
+	addr[1] = data;
+	len[1] = data_len - CMAC_TLEN;
+	addr[2] = zero;
+	len[2] = CMAC_TLEN;
+
+	aes_128_cmac_vector(tfm, 3, addr, len, mic);
+}
+
+
+struct crypto_cipher *mac80211_aes_cmac_key_setup(const u8 key[])
+{
+	struct crypto_cipher *tfm;
+
+	tfm = crypto_alloc_cipher("aes", 0, CRYPTO_ALG_ASYNC);
+	if (!IS_ERR(tfm))
+		crypto_cipher_setkey(tfm, key, AES_CMAC_KEY_LEN);
+
+	return tfm;
+}
+
+
+void mac80211_aes_cmac_key_free(struct crypto_cipher *tfm)
+{
+	crypto_free_cipher(tfm);
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/aes_cmac.h b/drivers/net/wireless/xr829/umac/aes_cmac.h
--- a/drivers/net/wireless/xr829/umac/aes_cmac.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/aes_cmac.h	2022-08-27 01:22:42.934539786 +0300
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2008, Jouni Malinen <j@w1.fi>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef AES_CMAC_H
+#define AES_CMAC_H
+
+#include <linux/crypto.h>
+
+struct crypto_cipher *mac80211_aes_cmac_key_setup(const u8 key[]);
+void mac80211_aes_cmac(struct crypto_cipher *tfm, const u8 *aad,
+			const u8 *data, size_t data_len, u8 *mic);
+void mac80211_aes_cmac_key_free(struct crypto_cipher *tfm);
+
+#endif /* AES_CMAC_H */
diff -Naurp a/drivers/net/wireless/xr829/umac/agg-rx.c b/drivers/net/wireless/xr829/umac/agg-rx.c
--- a/drivers/net/wireless/xr829/umac/agg-rx.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/agg-rx.c	2022-08-27 01:22:42.934539786 +0300
@@ -0,0 +1,341 @@
+/*
+ * HT handling
+ *
+ * Copyright 2003, Jouni Malinen <jkmaline@cc.hut.fi>
+ * Copyright 2002-2005, Instant802 Networks, Inc.
+ * Copyright 2005-2006, Devicescape Software, Inc.
+ * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
+ * Copyright 2007, Michael Wu <flamingice@sourmilk.net>
+ * Copyright 2007-2010, Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/**
+ * DOC: RX A-MPDU aggregation
+ *
+ * Aggregation on the RX side requires only implementing the
+ * @ampdu_action callback that is invoked to start/stop any
+ * block-ack sessions for RX aggregation.
+ *
+ * When RX aggregation is started by the peer, the driver is
+ * notified via @ampdu_action function, with the
+ * %IEEE80211_AMPDU_RX_START action, and may reject the request
+ * in which case a negative response is sent to the peer, if it
+ * accepts it a positive response is sent.
+ *
+ * While the session is active, the device/driver are required
+ * to de-aggregate frames and pass them up one by one to mac80211,
+ * which will handle the reorder buffer.
+ *
+ * When the aggregation session is stopped again by the peer or
+ * ourselves, the driver's @ampdu_action function will be called
+ * with the action %IEEE80211_AMPDU_RX_STOP. In this case, the
+ * call must not fail.
+ */
+
+#include <linux/ieee80211.h>
+#include <linux/slab.h>
+#include <linux/export.h>
+#include <net/mac80211.h>
+#include "ieee80211_i.h"
+#include "driver-ops.h"
+
+static void ieee80211_free_tid_rx(struct rcu_head *h)
+{
+	struct tid_ampdu_rx *tid_rx =
+		container_of(h, struct tid_ampdu_rx, rcu_head);
+	int i;
+
+	for (i = 0; i < tid_rx->buf_size; i++)
+		dev_kfree_skb(tid_rx->reorder_buf[i]);
+	kfree(tid_rx->reorder_buf);
+	kfree(tid_rx->reorder_time);
+	kfree(tid_rx);
+}
+
+void ___mac80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,
+				     u16 initiator, u16 reason, bool tx)
+{
+	struct ieee80211_local *local = sta->local;
+	struct tid_ampdu_rx *tid_rx;
+
+	lockdep_assert_held(&sta->ampdu_mlme.mtx);
+
+	tid_rx = rcu_dereference_protected(sta->ampdu_mlme.tid_rx[tid],
+					lockdep_is_held(&sta->ampdu_mlme.mtx));
+
+	if (!tid_rx)
+		return;
+
+	RCU_INIT_POINTER(sta->ampdu_mlme.tid_rx[tid], NULL);
+
+#ifdef CONFIG_XRMAC_HT_DEBUG
+	printk(KERN_DEBUG "Rx BA session stop requested for %pM tid %u\n",
+	       sta->sta.addr, tid);
+#endif /* CONFIG_XRMAC_HT_DEBUG */
+
+	if (drv_ampdu_action(local, sta->sdata, IEEE80211_AMPDU_RX_STOP,
+			     &sta->sta, tid, NULL, 0))
+		printk(KERN_DEBUG "HW problem - can not stop rx "
+				"aggregation for tid %d\n", tid);
+
+	/* check if this is a self generated aggregation halt */
+	if (initiator == WLAN_BACK_RECIPIENT && tx)
+		mac80211_send_delba(sta->sdata, sta->sta.addr,
+				     tid, 0, reason);
+
+	del_timer_sync(&tid_rx->session_timer);
+	del_timer_sync(&tid_rx->reorder_timer);
+
+	call_rcu(&tid_rx->rcu_head, ieee80211_free_tid_rx);
+}
+
+void __mac80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,
+				    u16 initiator, u16 reason, bool tx)
+{
+	mutex_lock(&sta->ampdu_mlme.mtx);
+	___mac80211_stop_rx_ba_session(sta, tid, initiator, reason, tx);
+	mutex_unlock(&sta->ampdu_mlme.mtx);
+}
+
+void mac80211_stop_rx_ba_session(struct ieee80211_vif *vif, u16 ba_rx_bitmap,
+				  const u8 *addr)
+{
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+	struct sta_info *sta;
+	int i;
+
+	rcu_read_lock();
+	sta = xrmac_sta_info_get(sdata, addr);
+	if (!sta) {
+		rcu_read_unlock();
+		return;
+	}
+
+	for (i = 0; i < STA_TID_NUM; i++)
+		if (ba_rx_bitmap & BIT(i))
+			set_bit(i, sta->ampdu_mlme.tid_rx_stop_requested);
+
+	mac80211_queue_work(&sta->local->hw, &sta->ampdu_mlme.work);
+	rcu_read_unlock();
+}
+
+/*
+ * After accepting the AddBA Request we activated a timer,
+ * resetting it after each frame that arrives from the originator.
+ */
+static void sta_rx_agg_session_timer_expired(struct timer_list *t)
+{
+	struct tid_ampdu_rx *tid_rx = from_timer(tid_rx, t, session_timer);
+	struct sta_info *sta = tid_rx->sta;
+	u8 tid = tid_rx->tid;
+	unsigned long timeout;
+
+	timeout = tid_rx->last_rx + TU_TO_JIFFIES(tid_rx->timeout);
+	if (time_is_after_jiffies(timeout)) {
+		mod_timer(&tid_rx->session_timer, timeout);
+		return;
+	}
+
+#ifdef CONFIG_XRMAC_HT_DEBUG
+	printk(KERN_DEBUG  "RX session timer expired on %pM tid %d\n",
+			sta->sta.addr, tid);
+#endif
+
+	set_bit(tid, sta->ampdu_mlme.tid_rx_timer_expired);
+	mac80211_queue_work(&sta->local->hw, &sta->ampdu_mlme.work);
+}
+
+static void sta_rx_agg_reorder_timer_expired(struct timer_list *t)
+{
+	struct tid_ampdu_rx *tid_rx = from_timer(tid_rx, t, reorder_timer);
+
+	rcu_read_lock();
+	mac80211_release_reorder_timeout(tid_rx->sta, tid_rx->tid);
+	rcu_read_unlock();
+}
+
+static void ieee80211_send_addba_resp(struct ieee80211_sub_if_data *sdata, u8 *da, u16 tid,
+				      u8 dialog_token, u16 status, u16 policy,
+				      u16 buf_size, u16 timeout)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct sk_buff *skb;
+	struct ieee80211_mgmt *mgmt;
+	u16 capab;
+
+	skb = dev_alloc_skb(sizeof(*mgmt) + local->hw.extra_tx_headroom);
+	if (!skb)
+		return;
+
+	skb_reserve(skb, local->hw.extra_tx_headroom);
+	mgmt = (struct ieee80211_mgmt *) skb_put(skb, 24);
+	memset(mgmt, 0, 24);
+	memcpy(mgmt->da, da, ETH_ALEN);
+	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
+	if (sdata->vif.type == NL80211_IFTYPE_AP ||
+	    sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
+		memcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);
+	else if (sdata->vif.type == NL80211_IFTYPE_STATION)
+		memcpy(mgmt->bssid, sdata->u.mgd.bssid, ETH_ALEN);
+
+	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+					  IEEE80211_STYPE_ACTION);
+
+	skb_put(skb, 1 + sizeof(mgmt->u.action.u.addba_resp));
+	mgmt->u.action.category = WLAN_CATEGORY_BACK;
+	mgmt->u.action.u.addba_resp.action_code = WLAN_ACTION_ADDBA_RESP;
+	mgmt->u.action.u.addba_resp.dialog_token = dialog_token;
+
+	capab = (u16)(policy << 1);	/* bit 1 aggregation policy */
+	capab |= (u16)(tid << 2); 	/* bit 5:2 TID number */
+	capab |= (u16)(buf_size << 6);	/* bit 15:6 max size of aggregation */
+
+	mgmt->u.action.u.addba_resp.capab = cpu_to_le16(capab);
+	mgmt->u.action.u.addba_resp.timeout = cpu_to_le16(timeout);
+	mgmt->u.action.u.addba_resp.status = cpu_to_le16(status);
+
+	ieee80211_tx_skb(sdata, skb);
+}
+
+void mac80211_process_addba_request(struct ieee80211_local *local,
+				     struct sta_info *sta,
+				     struct ieee80211_mgmt *mgmt,
+				     size_t len)
+{
+	struct tid_ampdu_rx *tid_agg_rx;
+	u16 capab, tid, timeout, ba_policy, buf_size, start_seq_num, status;
+	u8 dialog_token;
+	int ret = -EOPNOTSUPP;
+
+	/* extract session parameters from addba request frame */
+	dialog_token = mgmt->u.action.u.addba_req.dialog_token;
+	timeout = le16_to_cpu(mgmt->u.action.u.addba_req.timeout);
+	start_seq_num =
+		le16_to_cpu(mgmt->u.action.u.addba_req.start_seq_num) >> 4;
+
+	capab = le16_to_cpu(mgmt->u.action.u.addba_req.capab);
+	ba_policy = (capab & IEEE80211_ADDBA_PARAM_POLICY_MASK) >> 1;
+	tid = (capab & IEEE80211_ADDBA_PARAM_TID_MASK) >> 2;
+	buf_size = (capab & IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK) >> 6;
+
+	status = WLAN_STATUS_REQUEST_DECLINED;
+
+	if (test_sta_flag(sta, WLAN_STA_BLOCK_BA)) {
+#ifdef CONFIG_XRMAC_HT_DEBUG
+		printk(KERN_DEBUG "Suspend in progress. "
+		       "Denying ADDBA request\n");
+#endif
+		goto end_no_lock;
+	}
+
+	/* sanity check for incoming parameters:
+	 * check if configuration can support the BA policy
+	 * and if buffer size does not exceeds max value */
+	/* XXX: check own ht delayed BA capability?? */
+	if (((ba_policy != 1) &&
+	     (!(sta->sta.ht_cap.cap & IEEE80211_HT_CAP_DELAY_BA))) ||
+	    (buf_size > IEEE80211_MAX_AMPDU_BUF)) {
+		status = WLAN_STATUS_INVALID_QOS_PARAM;
+#ifdef CONFIG_XRMAC_HT_DEBUG
+		if (net_ratelimit())
+			printk(KERN_DEBUG "AddBA Req with bad params from "
+				"%pM on tid %u. policy %d, buffer size %d\n",
+				mgmt->sa, tid, ba_policy,
+				buf_size);
+#endif /* CONFIG_XRMAC_HT_DEBUG */
+		goto end_no_lock;
+	}
+	/* determine default buffer size */
+	if (buf_size == 0)
+		buf_size = IEEE80211_MAX_AMPDU_BUF;
+
+	/* make sure the size doesn't exceed the maximum supported by the hw */
+	if (buf_size > local->hw.max_rx_aggregation_subframes)
+		buf_size = local->hw.max_rx_aggregation_subframes;
+
+	/* examine state machine */
+	mutex_lock(&sta->ampdu_mlme.mtx);
+
+	if (sta->ampdu_mlme.tid_rx[tid]) {
+#ifdef CONFIG_XRMAC_HT_DEBUG
+		if (net_ratelimit())
+			printk(KERN_DEBUG "unexpected AddBA Req from "
+				"%pM on tid %u\n",
+				mgmt->sa, tid);
+#endif /* CONFIG_XRMAC_HT_DEBUG */
+
+		/* delete existing Rx BA session on the same tid */
+		___mac80211_stop_rx_ba_session(sta, tid, WLAN_BACK_RECIPIENT,
+						WLAN_STATUS_UNSPECIFIED_QOS,
+						false);
+	}
+
+	/* prepare A-MPDU MLME for Rx aggregation */
+	tid_agg_rx = kmalloc(sizeof(struct tid_ampdu_rx), GFP_KERNEL);
+	if (!tid_agg_rx)
+		goto end;
+
+	spin_lock_init(&tid_agg_rx->reorder_lock);
+
+	/* rx timer */
+	timer_setup(&tid_agg_rx->session_timer,
+		    sta_rx_agg_session_timer_expired, TIMER_DEFERRABLE);
+
+	/* rx reorder timer */
+	timer_setup(&tid_agg_rx->reorder_timer,
+		    sta_rx_agg_reorder_timer_expired, 0);
+
+	/* prepare reordering buffer */
+	tid_agg_rx->reorder_buf =
+		kcalloc(buf_size, sizeof(struct sk_buff *), GFP_KERNEL);
+	tid_agg_rx->reorder_time =
+		kcalloc(buf_size, sizeof(unsigned long), GFP_KERNEL);
+	if (!tid_agg_rx->reorder_buf || !tid_agg_rx->reorder_time) {
+		kfree(tid_agg_rx->reorder_buf);
+		kfree(tid_agg_rx->reorder_time);
+		kfree(tid_agg_rx);
+		goto end;
+	}
+
+	ret = drv_ampdu_action(local, sta->sdata, IEEE80211_AMPDU_RX_START,
+			       &sta->sta, tid, &start_seq_num, 0);
+#ifdef CONFIG_XRMAC_HT_DEBUG
+	printk(KERN_DEBUG "Rx A-MPDU request on tid %d result %d\n", tid, ret);
+#endif /* CONFIG_XRMAC_HT_DEBUG */
+
+	if (ret) {
+		kfree(tid_agg_rx->reorder_buf);
+		kfree(tid_agg_rx->reorder_time);
+		kfree(tid_agg_rx);
+		goto end;
+	}
+
+	/* update data */
+	tid_agg_rx->dialog_token = dialog_token;
+	tid_agg_rx->ssn = start_seq_num;
+	tid_agg_rx->head_seq_num = start_seq_num;
+	tid_agg_rx->buf_size = buf_size;
+	tid_agg_rx->timeout = timeout;
+	tid_agg_rx->stored_mpdu_num = 0;
+	tid_agg_rx->reorder_buf_filtered = 0;
+	tid_agg_rx->tid = tid;
+	tid_agg_rx->sta = sta;
+	status = WLAN_STATUS_SUCCESS;
+
+	/* activate it for RX */
+	rcu_assign_pointer(sta->ampdu_mlme.tid_rx[tid], tid_agg_rx);
+
+	if (timeout)
+		mod_timer(&tid_agg_rx->session_timer, TU_TO_EXP_TIME(timeout));
+
+end:
+	mutex_unlock(&sta->ampdu_mlme.mtx);
+
+end_no_lock:
+	ieee80211_send_addba_resp(sta->sdata, sta->sta.addr, tid,
+				  dialog_token, status, 1, buf_size, timeout);
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/agg-tx.c b/drivers/net/wireless/xr829/umac/agg-tx.c
--- a/drivers/net/wireless/xr829/umac/agg-tx.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/agg-tx.c	2022-08-27 01:22:42.934539786 +0300
@@ -0,0 +1,834 @@
+/*
+ * HT handling
+ *
+ * Copyright 2003, Jouni Malinen <jkmaline@cc.hut.fi>
+ * Copyright 2002-2005, Instant802 Networks, Inc.
+ * Copyright 2005-2006, Devicescape Software, Inc.
+ * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
+ * Copyright 2007, Michael Wu <flamingice@sourmilk.net>
+ * Copyright 2007-2010, Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/ieee80211.h>
+#include <linux/slab.h>
+#include <linux/export.h>
+#include <net/mac80211.h>
+#include "ieee80211_i.h"
+#include "driver-ops.h"
+#include "wme.h"
+
+/**
+ * DOC: TX A-MPDU aggregation
+ *
+ * Aggregation on the TX side requires setting the hardware flag
+ * %IEEE80211_HW_AMPDU_AGGREGATION. The driver will then be handed
+ * packets with a flag indicating A-MPDU aggregation. The driver
+ * or device is responsible for actually aggregating the frames,
+ * as well as deciding how many and which to aggregate.
+ *
+ * When TX aggregation is started by some subsystem (usually the rate
+ * control algorithm would be appropriate) by calling the
+ * mac80211_start_tx_ba_session() function, the driver will be
+ * notified via its @ampdu_action function, with the
+ * %IEEE80211_AMPDU_TX_START action.
+ *
+ * In response to that, the driver is later required to call the
+ * mac80211_start_tx_ba_cb_irqsafe() function, which will really
+ * start the aggregation session after the peer has also responded.
+ * If the peer responds negatively, the session will be stopped
+ * again right away. Note that it is possible for the aggregation
+ * session to be stopped before the driver has indicated that it
+ * is done setting it up, in which case it must not indicate the
+ * setup completion.
+ *
+ * Also note that, since we also need to wait for a response from
+ * the peer, the driver is notified of the completion of the
+ * handshake by the %IEEE80211_AMPDU_TX_OPERATIONAL action to the
+ * @ampdu_action callback.
+ *
+ * Similarly, when the aggregation session is stopped by the peer
+ * or something calling mac80211_stop_tx_ba_session(), the driver's
+ * @ampdu_action function will be called with the action
+ * %IEEE80211_AMPDU_TX_STOP. In this case, the call must not fail,
+ * and the driver must later call mac80211_stop_tx_ba_cb_irqsafe().
+ */
+
+static void ieee80211_send_addba_request(struct ieee80211_sub_if_data *sdata,
+					 const u8 *da, u16 tid,
+					 u8 dialog_token, u16 start_seq_num,
+					 u16 agg_size, u16 timeout)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct sk_buff *skb;
+	struct ieee80211_mgmt *mgmt;
+	u16 capab;
+
+	skb = dev_alloc_skb(sizeof(*mgmt) + local->hw.extra_tx_headroom);
+
+	if (!skb)
+		return;
+
+	skb_reserve(skb, local->hw.extra_tx_headroom);
+	mgmt = (struct ieee80211_mgmt *) skb_put(skb, 24);
+	memset(mgmt, 0, 24);
+	memcpy(mgmt->da, da, ETH_ALEN);
+	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
+	if (sdata->vif.type == NL80211_IFTYPE_AP ||
+	    sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
+		memcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);
+	else if (sdata->vif.type == NL80211_IFTYPE_STATION)
+		memcpy(mgmt->bssid, sdata->u.mgd.bssid, ETH_ALEN);
+
+	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+					  IEEE80211_STYPE_ACTION);
+
+	skb_put(skb, 1 + sizeof(mgmt->u.action.u.addba_req));
+
+	mgmt->u.action.category = WLAN_CATEGORY_BACK;
+	mgmt->u.action.u.addba_req.action_code = WLAN_ACTION_ADDBA_REQ;
+
+	mgmt->u.action.u.addba_req.dialog_token = dialog_token;
+	capab = (u16)(1 << 1);		/* bit 1 aggregation policy */
+	capab |= (u16)(tid << 2); 	/* bit 5:2 TID number */
+	capab |= (u16)(agg_size << 6);	/* bit 15:6 max size of aggergation */
+
+	mgmt->u.action.u.addba_req.capab = cpu_to_le16(capab);
+
+	mgmt->u.action.u.addba_req.timeout = cpu_to_le16(timeout);
+	mgmt->u.action.u.addba_req.start_seq_num =
+					cpu_to_le16(start_seq_num << 4);
+
+	ieee80211_tx_skb(sdata, skb);
+}
+
+void mac80211_send_bar(struct ieee80211_vif *vif, u8 *ra, u16 tid, u16 ssn)
+{
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+	struct ieee80211_local *local = sdata->local;
+	struct sk_buff *skb;
+	struct ieee80211_bar *bar;
+	u16 bar_control = 0;
+
+	skb = dev_alloc_skb(sizeof(*bar) + local->hw.extra_tx_headroom);
+	if (!skb)
+		return;
+
+	skb_reserve(skb, local->hw.extra_tx_headroom);
+	bar = (struct ieee80211_bar *)skb_put(skb, sizeof(*bar));
+	memset(bar, 0, sizeof(*bar));
+	bar->frame_control = cpu_to_le16(IEEE80211_FTYPE_CTL |
+					 IEEE80211_STYPE_BACK_REQ);
+	memcpy(bar->ra, ra, ETH_ALEN);
+	memcpy(bar->ta, sdata->vif.addr, ETH_ALEN);
+	bar_control |= (u16)IEEE80211_BAR_CTRL_ACK_POLICY_NORMAL;
+	bar_control |= (u16)IEEE80211_BAR_CTRL_CBMTID_COMPRESSED_BA;
+	bar_control |= (u16)(tid << IEEE80211_BAR_CTRL_TID_INFO_SHIFT);
+	bar->control = cpu_to_le16(bar_control);
+	bar->start_seq_num = cpu_to_le16(ssn);
+
+	IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
+	ieee80211_tx_skb(sdata, skb);
+}
+
+void mac80211_assign_tid_tx(struct sta_info *sta, int tid,
+			     struct tid_ampdu_tx *tid_tx)
+{
+	lockdep_assert_held(&sta->ampdu_mlme.mtx);
+	lockdep_assert_held(&sta->lock);
+	rcu_assign_pointer(sta->ampdu_mlme.tid_tx[tid], tid_tx);
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 40))
+static void kfree_tid_tx(struct rcu_head *rcu_head)
+{
+	struct tid_ampdu_tx *tid_tx =
+	    container_of(rcu_head, struct tid_ampdu_tx, rcu_head);
+
+	kfree(tid_tx);
+}
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 40)) */
+
+int ___mac80211_stop_tx_ba_session(struct sta_info *sta, u16 tid,
+				    enum ieee80211_back_parties initiator,
+				    bool tx)
+{
+	struct ieee80211_local *local = sta->local;
+	struct tid_ampdu_tx *tid_tx;
+	int ret;
+
+	lockdep_assert_held(&sta->ampdu_mlme.mtx);
+
+	spin_lock_bh(&sta->lock);
+
+	tid_tx = rcu_dereference_protected_tid_tx(sta, tid);
+	if (!tid_tx) {
+		spin_unlock_bh(&sta->lock);
+		return -ENOENT;
+	}
+
+	/* if we're already stopping ignore any new requests to stop */
+	if (test_bit(HT_AGG_STATE_STOPPING, &tid_tx->state)) {
+		spin_unlock_bh(&sta->lock);
+		return -EALREADY;
+	}
+
+	if (test_bit(HT_AGG_STATE_WANT_START, &tid_tx->state)) {
+		/* not even started yet! */
+		mac80211_assign_tid_tx(sta, tid, NULL);
+		spin_unlock_bh(&sta->lock);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 40))
+		kfree_rcu(tid_tx, rcu_head);
+#else
+		call_rcu(&tid_tx->rcu_head, kfree_tid_tx);
+#endif
+		return 0;
+	}
+
+	set_bit(HT_AGG_STATE_STOPPING, &tid_tx->state);
+
+	spin_unlock_bh(&sta->lock);
+
+#ifdef CONFIG_XRMAC_HT_DEBUG
+	printk(KERN_DEBUG "Tx BA session stop requested for %pM tid %u\n",
+	       sta->sta.addr, tid);
+#endif /* CONFIG_XRMAC_HT_DEBUG */
+
+	del_timer_sync(&tid_tx->addba_resp_timer);
+
+	/*
+	 * After this packets are no longer handed right through
+	 * to the driver but are put onto tid_tx->pending instead,
+	 * with locking to ensure proper access.
+	 */
+	clear_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state);
+
+	/*
+	 * There might be a few packets being processed right now (on
+	 * another CPU) that have already gotten past the aggregation
+	 * check when it was still OPERATIONAL and consequently have
+	 * IEEE80211_TX_CTL_AMPDU set. In that case, this code might
+	 * call into the driver at the same time or even before the
+	 * TX paths calls into it, which could confuse the driver.
+	 *
+	 * Wait for all currently running TX paths to finish before
+	 * telling the driver. New packets will not go through since
+	 * the aggregation session is no longer OPERATIONAL.
+	 */
+	synchronize_net();
+
+	tid_tx->stop_initiator = initiator;
+	tid_tx->tx_stop = tx;
+
+	ret = drv_ampdu_action(local, sta->sdata,
+			       IEEE80211_AMPDU_TX_STOP,
+			       &sta->sta, tid, NULL, 0);
+
+	/* HW shall not deny going back to legacy */
+	if (WARN_ON(ret)) {
+		/*
+		 * We may have pending packets get stuck in this case...
+		 * Not bothering with a workaround for now.
+		 */
+	}
+
+	return ret;
+}
+
+/*
+ * After sending add Block Ack request we activated a timer until
+ * add Block Ack response will arrive from the recipient.
+ * If this timer expires sta_addba_resp_timer_expired will be executed.
+ */
+static void sta_addba_resp_timer_expired(struct timer_list *t)
+{
+	struct tid_ampdu_tx *tid_tx = from_timer(tid_tx, t, addba_resp_timer);
+	struct sta_info *sta = tid_tx->sta;
+	u8 tid = tid_tx->tid;
+
+	/* check if the TID waits for addBA response */
+	if (!tid_tx ||
+		test_bit(HT_AGG_STATE_RESPONSE_RECEIVED, &tid_tx->state)) {
+		rcu_read_unlock();
+#ifdef CONFIG_XRMAC_HT_DEBUG
+			printk(KERN_DEBUG "timer expired on tid %d but we are not "
+					"(or no longer) expecting addBA response there\n",
+				tid);
+#endif
+		return;
+	}
+#ifdef CONFIG_XRMAC_HT_DEBUG
+			printk(KERN_DEBUG "addBA response timer expired on tid %d\n", tid);
+#endif
+
+	mac80211_stop_tx_ba_session(&sta->sta, tid);
+	rcu_read_unlock();
+}
+
+
+static inline int ieee80211_ac_from_tid(int tid)
+{
+	return mac802_1d_to_ac[tid & 7];
+}
+
+/*
+ * When multiple aggregation sessions on multiple stations
+ * are being created/destroyed simultaneously, we need to
+ * refcount the global queue stop caused by that in order
+ * to not get into a situation where one of the aggregation
+ * setup or teardown re-enables queues before the other is
+ * ready to handle that.
+ *
+ * These two functions take care of this issue by keeping
+ * a global "agg_queue_stop" refcount.
+ */
+static void __acquires(agg_queue)
+mac80211_stop_queue_agg(struct ieee80211_sub_if_data *sdata, int tid)
+{
+	int queue = sdata->vif.hw_queue[ieee80211_ac_from_tid(tid)];
+
+	if (atomic_inc_return(&sdata->local->agg_queue_stop[queue]) == 1)
+		mac80211_stop_queue_by_reason(
+			&sdata->local->hw, queue,
+			IEEE80211_QUEUE_STOP_REASON_AGGREGATION);
+	__acquire(agg_queue);
+}
+
+static void __releases(agg_queue)
+mac80211_wake_queue_agg(struct ieee80211_sub_if_data *sdata, int tid)
+{
+	int queue = sdata->vif.hw_queue[ieee80211_ac_from_tid(tid)];
+
+	if (atomic_dec_return(&sdata->local->agg_queue_stop[queue]) == 0)
+		mac80211_wake_queue_by_reason(
+			&sdata->local->hw, queue,
+			IEEE80211_QUEUE_STOP_REASON_AGGREGATION);
+	__release(agg_queue);
+}
+
+/*
+ * splice packets from the STA's pending to the local pending,
+ * requires a call to ieee80211_agg_splice_finish later
+ */
+static void __acquires(agg_queue)
+ieee80211_agg_splice_packets(struct ieee80211_sub_if_data *sdata,
+			     struct tid_ampdu_tx *tid_tx, u16 tid)
+{
+	struct ieee80211_local *local = sdata->local;
+	int queue = sdata->vif.hw_queue[ieee80211_ac_from_tid(tid)];
+	unsigned long flags;
+
+	mac80211_stop_queue_agg(sdata, tid);
+
+	if (WARN(!tid_tx, "TID %d gone but expected when splicing aggregates"
+			  " from the pending queue\n", tid))
+		return;
+
+	if (!skb_queue_empty(&tid_tx->pending)) {
+		spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
+		/* copy over remaining packets */
+		skb_queue_splice_tail_init(&tid_tx->pending,
+					   &local->pending[queue]);
+		spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
+	}
+}
+
+static void __releases(agg_queue)
+ieee80211_agg_splice_finish(struct ieee80211_sub_if_data *sdata, u16 tid)
+{
+	mac80211_wake_queue_agg(sdata, tid);
+}
+
+void mac80211_tx_ba_session_handle_start(struct sta_info *sta, int tid)
+{
+	struct tid_ampdu_tx *tid_tx;
+	struct ieee80211_local *local = sta->local;
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
+	u16 start_seq_num;
+	int ret;
+
+	tid_tx = rcu_dereference_protected_tid_tx(sta, tid);
+
+	/*
+	 * Start queuing up packets for this aggregation session.
+	 * We're going to release them once the driver is OK with
+	 * that.
+	 */
+	clear_bit(HT_AGG_STATE_WANT_START, &tid_tx->state);
+
+	/*
+	 * Make sure no packets are being processed. This ensures that
+	 * we have a valid starting sequence number and that in-flight
+	 * packets have been flushed out and no packets for this TID
+	 * will go into the driver during the ampdu_action call.
+	 */
+	synchronize_net();
+
+	start_seq_num = sta->tid_seq[tid] >> 4;
+
+	ret = drv_ampdu_action(local, sdata, IEEE80211_AMPDU_TX_START,
+			       &sta->sta, tid, &start_seq_num, 0);
+	if (ret) {
+#ifdef CONFIG_XRMAC_HT_DEBUG
+		printk(KERN_DEBUG "BA request denied - HW unavailable for"
+					" tid %d\n", tid);
+#endif
+		spin_lock_bh(&sta->lock);
+		ieee80211_agg_splice_packets(sdata, tid_tx, tid);
+		mac80211_assign_tid_tx(sta, tid, NULL);
+		ieee80211_agg_splice_finish(sdata, tid);
+		spin_unlock_bh(&sta->lock);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 40))
+		kfree_rcu(tid_tx, rcu_head);
+#else
+		call_rcu(&tid_tx->rcu_head, kfree_tid_tx);
+#endif
+		return;
+	}
+
+	/* activate the timer for the recipient's addBA response */
+	mod_timer(&tid_tx->addba_resp_timer, jiffies + ADDBA_RESP_INTERVAL);
+#ifdef CONFIG_XRMAC_HT_DEBUG
+	printk(KERN_DEBUG "activated addBA response timer on tid %d\n", tid);
+#endif
+
+	spin_lock_bh(&sta->lock);
+	sta->ampdu_mlme.addba_req_num[tid]++;
+	spin_unlock_bh(&sta->lock);
+
+	/* send AddBA request */
+	ieee80211_send_addba_request(sdata, sta->sta.addr, tid,
+				     tid_tx->dialog_token, start_seq_num,
+				     local->hw.max_tx_aggregation_subframes,
+				     tid_tx->timeout);
+}
+
+int mac80211_start_tx_ba_session(struct ieee80211_sta *pubsta, u16 tid,
+				  u16 timeout)
+{
+	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
+	struct ieee80211_local *local = sdata->local;
+	struct tid_ampdu_tx *tid_tx;
+	int ret = 0;
+
+	trace_api_start_tx_ba_session(pubsta, tid);
+
+	if (WARN_ON(!local->ops->ampdu_action))
+		return -EINVAL;
+
+	if ((tid >= STA_TID_NUM) ||
+	    !(local->hw.flags & IEEE80211_HW_AMPDU_AGGREGATION) ||
+	    (local->hw.flags & IEEE80211_HW_TX_AMPDU_SETUP_IN_HW))
+		return -EINVAL;
+
+#ifdef CONFIG_XRMAC_HT_DEBUG
+	printk(KERN_DEBUG "Open BA session requested for %pM tid %u\n",
+	       pubsta->addr, tid);
+#endif /* CONFIG_XRMAC_HT_DEBUG */
+
+	/*
+	 * The aggregation code is not prepared to handle
+	 * anything but STA/AP due to the BSSID handling.
+	 * IBSS could work in the code but isn't supported
+	 * by drivers or the standard.
+	 */
+	if (sdata->vif.type != NL80211_IFTYPE_STATION &&
+	    sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&
+	    sdata->vif.type != NL80211_IFTYPE_AP)
+		return -EINVAL;
+
+	if (test_sta_flag(sta, WLAN_STA_BLOCK_BA)) {
+#ifdef CONFIG_XRMAC_HT_DEBUG
+		printk(KERN_DEBUG "BA sessions blocked. "
+		       "Denying BA session request\n");
+#endif
+		return -EINVAL;
+	}
+
+	spin_lock_bh(&sta->lock);
+
+	/* we have tried too many times, receiver does not want A-MPDU */
+	if (sta->ampdu_mlme.addba_req_num[tid] > HT_AGG_MAX_RETRIES) {
+		ret = -EBUSY;
+		goto err_unlock_sta;
+	}
+
+	tid_tx = rcu_dereference_protected_tid_tx(sta, tid);
+	/* check if the TID is not in aggregation flow already */
+	if (tid_tx || sta->ampdu_mlme.tid_start_tx[tid]) {
+#ifdef CONFIG_XRMAC_HT_DEBUG
+		printk(KERN_DEBUG "BA request denied - session is not "
+				 "idle on tid %u\n", tid);
+#endif /* CONFIG_XRMAC_HT_DEBUG */
+		ret = -EAGAIN;
+		goto err_unlock_sta;
+	}
+
+	/* prepare A-MPDU MLME for Tx aggregation */
+	tid_tx = kzalloc(sizeof(struct tid_ampdu_tx), GFP_ATOMIC);
+	if (!tid_tx) {
+		ret = -ENOMEM;
+		goto err_unlock_sta;
+	}
+
+	skb_queue_head_init(&tid_tx->pending);
+	__set_bit(HT_AGG_STATE_WANT_START, &tid_tx->state);
+
+	tid_tx->timeout = timeout;
+	tid_tx->sta = sta;
+	tid_tx->tid = tid;
+
+	/* response timer */
+	timer_setup(&tid_tx->addba_resp_timer, sta_addba_resp_timer_expired, 0);
+
+	/* assign a dialog token */
+	sta->ampdu_mlme.dialog_token_allocator++;
+	tid_tx->dialog_token = sta->ampdu_mlme.dialog_token_allocator;
+
+	/*
+	 * Finally, assign it to the start array; the work item will
+	 * collect it and move it to the normal array.
+	 */
+	sta->ampdu_mlme.tid_start_tx[tid] = tid_tx;
+
+	mac80211_queue_work(&local->hw, &sta->ampdu_mlme.work);
+
+	/* this flow continues off the work */
+ err_unlock_sta:
+	spin_unlock_bh(&sta->lock);
+	return ret;
+}
+
+static void ieee80211_agg_tx_operational(struct ieee80211_local *local,
+					 struct sta_info *sta, u16 tid)
+{
+	struct tid_ampdu_tx *tid_tx;
+
+	lockdep_assert_held(&sta->ampdu_mlme.mtx);
+
+	tid_tx = rcu_dereference_protected_tid_tx(sta, tid);
+
+#ifdef CONFIG_XRMAC_HT_DEBUG
+	printk(KERN_DEBUG "Aggregation is on for tid %d\n", tid);
+#endif
+
+	drv_ampdu_action(local, sta->sdata,
+			 IEEE80211_AMPDU_TX_OPERATIONAL,
+			 &sta->sta, tid, NULL, tid_tx->buf_size);
+
+	/*
+	 * synchronize with TX path, while splicing the TX path
+	 * should block so it won't put more packets onto pending.
+	 */
+	spin_lock_bh(&sta->lock);
+
+	ieee80211_agg_splice_packets(sta->sdata, tid_tx, tid);
+	/*
+	 * Now mark as operational. This will be visible
+	 * in the TX path, and lets it go lock-free in
+	 * the common case.
+	 */
+	set_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state);
+	ieee80211_agg_splice_finish(sta->sdata, tid);
+
+	spin_unlock_bh(&sta->lock);
+}
+
+void mac80211_start_tx_ba_cb(struct ieee80211_vif *vif, u8 *ra, u16 tid)
+{
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+	struct ieee80211_local *local = sdata->local;
+	struct sta_info *sta;
+	struct tid_ampdu_tx *tid_tx;
+
+	trace_api_start_tx_ba_cb(sdata, ra, tid);
+
+	if (tid >= STA_TID_NUM) {
+#ifdef CONFIG_XRMAC_HT_DEBUG
+		printk(KERN_DEBUG "Bad TID value: tid = %d (>= %d)\n",
+				tid, STA_TID_NUM);
+#endif
+		return;
+	}
+
+	mutex_lock(&local->sta_mtx);
+	sta = xrmac_sta_info_get(sdata, ra);
+	if (!sta) {
+		mutex_unlock(&local->sta_mtx);
+#ifdef CONFIG_XRMAC_HT_DEBUG
+		printk(KERN_DEBUG "Could not find station: %pM\n", ra);
+#endif
+		return;
+	}
+
+	mutex_lock(&sta->ampdu_mlme.mtx);
+	tid_tx = rcu_dereference_protected_tid_tx(sta, tid);
+
+	if (WARN_ON(!tid_tx)) {
+#ifdef CONFIG_XRMAC_HT_DEBUG
+		printk(KERN_DEBUG "addBA was not requested!\n");
+#endif
+		goto unlock;
+	}
+
+	if (WARN_ON(test_and_set_bit(HT_AGG_STATE_DRV_READY, &tid_tx->state)))
+		goto unlock;
+
+	if (test_bit(HT_AGG_STATE_RESPONSE_RECEIVED, &tid_tx->state))
+		ieee80211_agg_tx_operational(local, sta, tid);
+
+ unlock:
+	mutex_unlock(&sta->ampdu_mlme.mtx);
+	mutex_unlock(&local->sta_mtx);
+}
+
+void mac80211_start_tx_ba_cb_irqsafe(struct ieee80211_vif *vif,
+				      const u8 *ra, u16 tid)
+{
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_ra_tid *ra_tid;
+	struct sk_buff *skb = dev_alloc_skb(0);
+
+	if (unlikely(!skb))
+		return;
+
+	ra_tid = (struct ieee80211_ra_tid *) &skb->cb;
+	memcpy(&ra_tid->ra, ra, ETH_ALEN);
+	ra_tid->tid = tid;
+
+	skb->pkt_type = IEEE80211_SDATA_QUEUE_AGG_START;
+	skb_queue_tail(&sdata->skb_queue, skb);
+	mac80211_queue_work(&local->hw, &sdata->work);
+}
+
+int __mac80211_stop_tx_ba_session(struct sta_info *sta, u16 tid,
+				   enum ieee80211_back_parties initiator,
+				   bool tx)
+{
+	int ret;
+
+	mutex_lock(&sta->ampdu_mlme.mtx);
+
+	ret = ___mac80211_stop_tx_ba_session(sta, tid, initiator, tx);
+
+	mutex_unlock(&sta->ampdu_mlme.mtx);
+
+	return ret;
+}
+
+int mac80211_stop_tx_ba_session(struct ieee80211_sta *pubsta, u16 tid)
+{
+	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
+	struct ieee80211_local *local = sdata->local;
+	struct tid_ampdu_tx *tid_tx;
+	int ret = 0;
+
+	trace_api_stop_tx_ba_session(pubsta, tid);
+
+	if (!local->ops->ampdu_action)
+		return -EINVAL;
+
+	if (tid >= STA_TID_NUM)
+		return -EINVAL;
+
+	spin_lock_bh(&sta->lock);
+	tid_tx = rcu_dereference_protected_tid_tx(sta, tid);
+
+	if (!tid_tx) {
+		ret = -ENOENT;
+		goto unlock;
+	}
+
+	if (test_bit(HT_AGG_STATE_STOPPING, &tid_tx->state)) {
+		/* already in progress stopping it */
+		ret = 0;
+		goto unlock;
+	}
+
+	set_bit(HT_AGG_STATE_WANT_STOP, &tid_tx->state);
+	mac80211_queue_work(&local->hw, &sta->ampdu_mlme.work);
+
+ unlock:
+	spin_unlock_bh(&sta->lock);
+	return ret;
+}
+
+void mac80211_stop_tx_ba_cb(struct ieee80211_vif *vif, u8 *ra, u8 tid)
+{
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+	struct ieee80211_local *local = sdata->local;
+	struct sta_info *sta;
+	struct tid_ampdu_tx *tid_tx;
+
+	trace_api_stop_tx_ba_cb(sdata, ra, tid);
+
+	if (tid >= STA_TID_NUM) {
+#ifdef CONFIG_XRMAC_HT_DEBUG
+		printk(KERN_DEBUG "Bad TID value: tid = %d (>= %d)\n",
+				tid, STA_TID_NUM);
+#endif
+		return;
+	}
+
+#ifdef CONFIG_XRMAC_HT_DEBUG
+	printk(KERN_DEBUG "Stopping Tx BA session for %pM tid %d\n",
+	       ra, tid);
+#endif /* CONFIG_XRMAC_HT_DEBUG */
+
+	mutex_lock(&local->sta_mtx);
+
+	sta = xrmac_sta_info_get(sdata, ra);
+	if (!sta) {
+#ifdef CONFIG_XRMAC_HT_DEBUG
+		printk(KERN_DEBUG "Could not find station: %pM\n", ra);
+#endif
+		goto unlock;
+	}
+
+	mutex_lock(&sta->ampdu_mlme.mtx);
+	spin_lock_bh(&sta->lock);
+	tid_tx = rcu_dereference_protected_tid_tx(sta, tid);
+
+	if (!tid_tx || !test_bit(HT_AGG_STATE_STOPPING, &tid_tx->state)) {
+#ifdef CONFIG_XRMAC_HT_DEBUG
+		printk(KERN_DEBUG "unexpected callback to A-MPDU stop\n");
+#endif
+		goto unlock_sta;
+	}
+
+	if (tid_tx->stop_initiator == WLAN_BACK_INITIATOR && tid_tx->tx_stop)
+		mac80211_send_delba(sta->sdata, ra, tid,
+			WLAN_BACK_INITIATOR, WLAN_REASON_QSTA_NOT_USE);
+
+	/*
+	 * When we get here, the TX path will not be lockless any more wrt.
+	 * aggregation, since the OPERATIONAL bit has long been cleared.
+	 * Thus it will block on getting the lock, if it occurs. So if we
+	 * stop the queue now, we will not get any more packets, and any
+	 * that might be being processed will wait for us here, thereby
+	 * guaranteeing that no packets go to the tid_tx pending queue any
+	 * more.
+	 */
+
+	ieee80211_agg_splice_packets(sta->sdata, tid_tx, tid);
+
+	/* future packets must not find the tid_tx struct any more */
+	mac80211_assign_tid_tx(sta, tid, NULL);
+
+	ieee80211_agg_splice_finish(sta->sdata, tid);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 40))
+	kfree_rcu(tid_tx, rcu_head);
+#else
+	call_rcu(&tid_tx->rcu_head, kfree_tid_tx);
+#endif
+
+ unlock_sta:
+	spin_unlock_bh(&sta->lock);
+	mutex_unlock(&sta->ampdu_mlme.mtx);
+ unlock:
+	mutex_unlock(&local->sta_mtx);
+}
+
+void mac80211_stop_tx_ba_cb_irqsafe(struct ieee80211_vif *vif,
+				     const u8 *ra, u16 tid)
+{
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_ra_tid *ra_tid;
+	struct sk_buff *skb = dev_alloc_skb(0);
+
+	if (unlikely(!skb))
+		return;
+
+	ra_tid = (struct ieee80211_ra_tid *) &skb->cb;
+	memcpy(&ra_tid->ra, ra, ETH_ALEN);
+	ra_tid->tid = tid;
+
+	skb->pkt_type = IEEE80211_SDATA_QUEUE_AGG_STOP;
+	skb_queue_tail(&sdata->skb_queue, skb);
+	mac80211_queue_work(&local->hw, &sdata->work);
+}
+
+void mac80211_process_addba_resp(struct ieee80211_local *local,
+				  struct sta_info *sta,
+				  struct ieee80211_mgmt *mgmt,
+				  size_t len)
+{
+	struct tid_ampdu_tx *tid_tx;
+	u16 capab, tid;
+	u8 buf_size;
+
+	capab = le16_to_cpu(mgmt->u.action.u.addba_resp.capab);
+	tid = (capab & IEEE80211_ADDBA_PARAM_TID_MASK) >> 2;
+	buf_size = (capab & IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK) >> 6;
+
+	mutex_lock(&sta->ampdu_mlme.mtx);
+
+	tid_tx = rcu_dereference_protected_tid_tx(sta, tid);
+	if (!tid_tx)
+		goto out;
+
+	if (mgmt->u.action.u.addba_resp.dialog_token != tid_tx->dialog_token) {
+#ifdef CONFIG_XRMAC_HT_DEBUG
+		printk(KERN_DEBUG "wrong addBA response token, tid %d\n", tid);
+#endif
+		goto out;
+	}
+
+	del_timer_sync(&tid_tx->addba_resp_timer);
+
+#ifdef CONFIG_XRMAC_HT_DEBUG
+	printk(KERN_DEBUG "switched off addBA timer for tid %d\n", tid);
+#endif
+
+	/*
+	 * addba_resp_timer may have fired before we got here, and
+	 * caused WANT_STOP to be set. If the stop then was already
+	 * processed further, STOPPING might be set.
+	 */
+	if (test_bit(HT_AGG_STATE_WANT_STOP, &tid_tx->state) ||
+	    test_bit(HT_AGG_STATE_STOPPING, &tid_tx->state)) {
+#ifdef CONFIG_XRMAC_HT_DEBUG
+		printk(KERN_DEBUG
+		       "got addBA resp for tid %d but we already gave up\n",
+		       tid);
+#endif
+		goto out;
+	}
+
+	/*
+	 * IEEE 802.11-2007 7.3.1.14:
+	 * In an ADDBA Response frame, when the Status Code field
+	 * is set to 0, the Buffer Size subfield is set to a value
+	 * of at least 1.
+	 */
+	if (le16_to_cpu(mgmt->u.action.u.addba_resp.status)
+			== WLAN_STATUS_SUCCESS && buf_size) {
+		if (test_and_set_bit(HT_AGG_STATE_RESPONSE_RECEIVED,
+				     &tid_tx->state)) {
+			/* ignore duplicate response */
+			goto out;
+		}
+
+		tid_tx->buf_size = buf_size;
+
+		if (test_bit(HT_AGG_STATE_DRV_READY, &tid_tx->state))
+			ieee80211_agg_tx_operational(local, sta, tid);
+
+		sta->ampdu_mlme.addba_req_num[tid] = 0;
+	} else {
+		___mac80211_stop_tx_ba_session(sta, tid, WLAN_BACK_INITIATOR,
+						true);
+	}
+
+ out:
+	mutex_unlock(&sta->ampdu_mlme.mtx);
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/average.c b/drivers/net/wireless/xr829/umac/average.c
--- a/drivers/net/wireless/xr829/umac/average.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/average.c	2022-08-27 01:22:42.934539786 +0300
@@ -0,0 +1,60 @@
+/*
+ * lib/average.c
+ *
+ * This source code is licensed under the GNU General Public License,
+ * Version 2.  See the file COPYING for more details.
+ */
+
+#include <linux/export.h>
+#include <linux/average.h>
+#include <linux/kernel.h>
+#include <linux/bug.h>
+#include <linux/log2.h>
+
+/**
+ * DOC: Exponentially Weighted Moving Average (EWMA)
+ *
+ * These are generic functions for calculating Exponentially Weighted Moving
+ * Averages (EWMA). We keep a structure with the EWMA parameters and a scaled
+ * up internal representation of the average value to prevent rounding errors.
+ * The factor for scaling up and the exponential weight (or decay rate) have to
+ * be specified thru the init fuction. The structure should not be accessed
+ * directly but only thru the helper functions.
+ */
+
+/**
+ * ewma_init() - Initialize EWMA parameters
+ * @avg: Average structure
+ * @factor: Factor to use for the scaled up internal value. The maximum value
+ *	of averages can be ULONG_MAX/(factor*weight). For performance reasons
+ *	factor has to be a power of 2.
+ * @weight: Exponential weight, or decay rate. This defines how fast the
+ *	influence of older values decreases. For performance reasons weight has
+ *	to be a power of 2.
+ *
+ * Initialize the EWMA parameters for a given struct ewma @avg.
+ */
+void ewma_init(struct ewma *avg, unsigned long factor, unsigned long weight)
+{
+	WARN_ON(!is_power_of_2(weight) || !is_power_of_2(factor));
+
+	avg->weight = ilog2(weight);
+	avg->factor = ilog2(factor);
+	avg->internal = 0;
+}
+
+/**
+ * ewma_add() - Exponentially weighted moving average (EWMA)
+ * @avg: Average structure
+ * @val: Current value
+ *
+ * Add a sample to the average.
+ */
+struct ewma *ewma_add(struct ewma *avg, unsigned long val)
+{
+	avg->internal = avg->internal  ?
+		(((avg->internal << avg->weight) - avg->internal) +
+			(val << avg->factor)) >> avg->weight :
+		(val << avg->factor);
+	return avg;
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/cfg.c b/drivers/net/wireless/xr829/umac/cfg.c
--- a/drivers/net/wireless/xr829/umac/cfg.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/cfg.c	2022-08-27 01:22:42.934539786 +0300
@@ -0,0 +1,3431 @@
+/*
+ * mac80211 configuration hooks for cfg80211
+ *
+ * Copyright 2006-2010	Johannes Berg <johannes@sipsolutions.net>
+ *
+ * This file is GPLv2 as found in COPYING.
+ */
+
+#include <generated/uapi/linux/version.h>
+#include <linux/ieee80211.h>
+#include <uapi/linux/nl80211.h>
+#include <linux/rtnetlink.h>
+#include <linux/slab.h>
+#include <net/net_namespace.h>
+#include <linux/rcupdate.h>
+#include <linux/fips.h>
+#include <linux/if_ether.h>
+#include <net/cfg80211.h>
+#include <linux/time64.h>
+#include "ieee80211_i.h"
+#include "driver-ops.h"
+#include "cfg.h"
+#include "rate.h"
+#include "mesh.h"
+
+static struct wireless_dev *ieee80211_add_iface(struct wiphy *wiphy,
+						const char *name,
+						unsigned char name_assign_type,
+						enum nl80211_iftype type,
+						//u32 *flags,
+						struct vif_params *params)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+	struct net_device *dev;
+	static struct wireless_dev *wdev;
+	struct ieee80211_sub_if_data *sdata;
+	int err;
+	u32 *flags = &params->flags;
+	(void)dev;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	err = mac80211_if_add(local, name, name_assign_type, &wdev, type, params);
+	if (err)
+		return ERR_PTR(err);
+	sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);
+#else
+	err = mac80211_if_add(local, name, &dev, type, params);
+	if (err)
+		return ERR_PTR(err);
+	sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	wdev = &sdata->wdev;
+#endif
+
+	if (type == NL80211_IFTYPE_MONITOR && flags) {
+		sdata->u.mntr_flags = *flags;
+	}
+
+	return wdev;
+}
+
+static int ieee80211_del_iface(struct wiphy *wiphy, struct wireless_dev *wdev)
+{
+	mac80211_if_remove(IEEE80211_WDEV_TO_SUB_IF(wdev));
+
+	return 0;
+}
+
+#if 0
+static int ieee80211_del_iface(struct wiphy *wiphy, struct net_device *dev)
+{
+	mac80211_if_remove(IEEE80211_DEV_TO_SUB_IF(dev));
+
+	return 0;
+}
+#endif
+
+static int ieee80211_change_iface(struct wiphy *wiphy,
+				  struct net_device *dev,
+				  enum nl80211_iftype type,// u32 *flags,
+				  struct vif_params *params)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	int ret;
+	u32 *flags = &params->flags;
+
+	ret = mac80211_if_change_type(sdata, type);
+	if (ret)
+		return ret;
+
+	if (type == NL80211_IFTYPE_AP_VLAN &&
+	    params && params->use_4addr == 0)
+		RCU_INIT_POINTER(sdata->u.vlan.sta, NULL);
+	else if (type == NL80211_IFTYPE_STATION &&
+		 params && params->use_4addr >= 0)
+		sdata->u.mgd.use_4addr = params->use_4addr;
+
+	if (sdata->vif.type == NL80211_IFTYPE_MONITOR && flags) {
+
+		if (ieee80211_sdata_running(sdata)) {
+			/*
+			 * Prohibit MONITOR_FLAG_COOK_FRAMES to be
+			 * changed while the interface is up.
+			 * Else we would need to add a lot of cruft
+			 * to update everything:
+			 *	cooked_mntrs, monitor and all fif_* counters
+			 *	reconfigure hardware
+			 */
+			if ((*flags & MONITOR_FLAG_COOK_FRAMES) !=
+			    (sdata->u.mntr_flags & MONITOR_FLAG_COOK_FRAMES))
+				return -EBUSY;
+
+			mac80211_adjust_monitor_flags(sdata, -1);
+			sdata->u.mntr_flags = *flags;
+			mac80211_adjust_monitor_flags(sdata, 1);
+
+			mac80211_configure_filter(sdata);
+		} else {
+			/*
+			 * Because the interface is down, ieee80211_do_stop
+			 * and ieee80211_do_open take care of "everything"
+			 * mentioned in the comment above.
+			 */
+			sdata->u.mntr_flags = *flags;
+		}
+	}
+
+	return 0;
+}
+
+static int ieee80211_start_p2p_device(struct wiphy *wiphy,
+				      struct wireless_dev *wdev)
+{
+	return ieee80211_do_open(wdev, true);
+}
+
+static void ieee80211_stop_p2p_device(struct wiphy *wiphy,
+				      struct wireless_dev *wdev)
+{
+	ieee80211_sdata_stop(IEEE80211_WDEV_TO_SUB_IF(wdev));
+}
+
+static int ieee80211_add_key(struct wiphy *wiphy, struct net_device *dev,
+			     u8 key_idx, bool pairwise, const u8 *mac_addr,
+			     struct key_params *params)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	//struct ieee80211_local *local = sdata->local;
+	struct sta_info *sta = NULL;
+	struct ieee80211_key *key;
+	const struct ieee80211_cipher_scheme *cs = NULL;
+	int err;
+
+	if (!ieee80211_sdata_running(sdata))
+		return -ENETDOWN;
+
+	/* reject WEP and TKIP keys if WEP failed to initialize */
+	switch (params->cipher) {
+	case WLAN_CIPHER_SUITE_WEP40:
+	case WLAN_CIPHER_SUITE_TKIP:
+	case WLAN_CIPHER_SUITE_WEP104:
+		if (WARN_ON_ONCE(fips_enabled))
+			return -EINVAL;
+		break;
+	case WLAN_CIPHER_SUITE_CCMP:
+	case WLAN_CIPHER_SUITE_AES_CMAC:
+	case WLAN_CIPHER_SUITE_GCMP:
+		break;
+	default:
+		cs = ieee80211_cs_get(sdata->local, params->cipher, sdata->vif.type);
+		break;
+	}
+
+	key = mac80211_key_alloc(params->cipher, key_idx, params->key_len,
+				  params->key, params->seq_len, params->seq);
+	if (IS_ERR(key))
+		return PTR_ERR(key);
+
+	if (pairwise)
+		key->conf.flags |= IEEE80211_KEY_FLAG_PAIRWISE;
+
+	if (pairwise && sdata->vif.type == NL80211_IFTYPE_STATION) {
+		int ret = 0;
+		/*
+		* Fix a bug that in some case Add_key is before
+		* 4-way handshake fourth frame sending while will cause 4-way handshake failed.
+		* If and only if the sta has associated the ap and
+		* start 4-way handshake but no finish(FINISH2), Add_key will
+		* be delay until 4-way handshake finish(FINISH4)
+		*/
+		ret = wait_event_timeout(sdata->setkey_wq,
+			!((sdata->u.mgd.associated != NULL) && (sdata->fourway_state == SDATA_4WAY_STATE_FINISH2)), 0.5 * HZ);
+		if (ret == 0) {
+			sdata->fourway_state = SDATA_4WAY_STATE_NONE;
+			printk(KERN_WARNING "[XRADIO]4-Way Handshake timeout.\n");
+		}
+	}
+
+	mutex_lock(&sdata->local->sta_mtx);
+
+	if (mac_addr) {
+		if (ieee80211_vif_is_mesh(&sdata->vif))
+			sta = xrmac_sta_info_get(sdata, mac_addr);
+		else
+			sta = xrmac_sta_info_get_bss(sdata, mac_addr);
+		if (!sta) {
+			mac80211_key_free(sdata->local, key);
+			err = -ENOENT;
+			goto out_unlock;
+		}
+	}
+
+	err = mac80211_key_link(key, sdata, sta);
+	if (err)
+		mac80211_key_free(sdata->local, key);
+
+ out_unlock:
+	mutex_unlock(&sdata->local->sta_mtx);
+
+	return err;
+}
+
+static int ieee80211_del_key(struct wiphy *wiphy, struct net_device *dev,
+			     u8 key_idx, bool pairwise, const u8 *mac_addr)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_local *local = sdata->local;
+	struct sta_info *sta;
+	struct ieee80211_key *key = NULL;
+	int ret;
+
+	mutex_lock(&local->sta_mtx);
+	mutex_lock(&local->key_mtx);
+
+	if (mac_addr) {
+		ret = -ENOENT;
+
+		sta = xrmac_sta_info_get_bss(sdata, mac_addr);
+		if (!sta)
+			goto out_unlock;
+
+		if (pairwise)
+			key = key_mtx_dereference(local, sta->ptk);
+		else
+			key = key_mtx_dereference(local, sta->gtk[key_idx]);
+	} else
+		key = key_mtx_dereference(local, sdata->keys[key_idx]);
+
+	if (!key) {
+		ret = -ENOENT;
+		goto out_unlock;
+	}
+
+	__mac80211_key_free(key);
+
+	ret = 0;
+ out_unlock:
+	mutex_unlock(&local->key_mtx);
+	mutex_unlock(&local->sta_mtx);
+
+	return ret;
+}
+
+static int ieee80211_get_key(struct wiphy *wiphy, struct net_device *dev,
+			     u8 key_idx, bool pairwise, const u8 *mac_addr,
+			     void *cookie,
+			     void (*callback)(void *cookie,
+					      struct key_params *params))
+{
+	struct ieee80211_sub_if_data *sdata;
+	struct sta_info *sta = NULL;
+	u8 seq[6] = {0};
+	struct key_params params;
+	struct ieee80211_key *key = NULL;
+	u64 pn64;
+	u32 iv32;
+	u16 iv16;
+	int err = -ENOENT;
+
+	sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	rcu_read_lock();
+
+	if (mac_addr) {
+		sta = xrmac_sta_info_get_bss(sdata, mac_addr);
+		if (!sta)
+			goto out;
+
+		if (pairwise)
+			key = rcu_dereference(sta->ptk);
+		else if (key_idx < NUM_DEFAULT_KEYS)
+			key = rcu_dereference(sta->gtk[key_idx]);
+	} else
+		key = rcu_dereference(sdata->keys[key_idx]);
+
+	if (!key)
+		goto out;
+
+	memset(&params, 0, sizeof(params));
+
+	params.cipher = key->conf.cipher;
+
+	switch (key->conf.cipher) {
+	case WLAN_CIPHER_SUITE_TKIP:
+		iv32 = key->u.tkip.tx.iv32;
+		iv16 = key->u.tkip.tx.iv16;
+
+		if (key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE)
+			drv_get_tkip_seq(sdata->local,
+					 key->conf.hw_key_idx,
+					 &iv32, &iv16);
+
+		seq[0] = iv16 & 0xff;
+		seq[1] = (iv16 >> 8) & 0xff;
+		seq[2] = iv32 & 0xff;
+		seq[3] = (iv32 >> 8) & 0xff;
+		seq[4] = (iv32 >> 16) & 0xff;
+		seq[5] = (iv32 >> 24) & 0xff;
+		params.seq = seq;
+		params.seq_len = 6;
+		break;
+	case WLAN_CIPHER_SUITE_CCMP:
+		pn64 = atomic64_read(&key->u.ccmp.tx_pn);
+		seq[0] = pn64;
+		seq[1] = pn64 >> 8;
+		seq[2] = pn64 >> 16;
+		seq[3] = pn64 >> 24;
+		seq[4] = pn64 >> 32;
+		seq[5] = pn64 >> 40;
+		params.seq = seq;
+		params.seq_len = 6;
+		break;
+	case WLAN_CIPHER_SUITE_AES_CMAC:
+		pn64 = atomic64_read(&key->u.aes_cmac.tx_pn);
+		seq[0] = pn64;
+		seq[1] = pn64 >> 8;
+		seq[2] = pn64 >> 16;
+		seq[3] = pn64 >> 24;
+		seq[4] = pn64 >> 32;
+		seq[5] = pn64 >> 40;
+		params.seq = seq;
+		params.seq_len = 6;
+		break;
+	}
+
+	params.key = key->conf.key;
+	params.key_len = key->conf.keylen;
+
+	callback(cookie, &params);
+	err = 0;
+
+ out:
+	rcu_read_unlock();
+	return err;
+}
+
+static int ieee80211_config_default_key(struct wiphy *wiphy,
+					struct net_device *dev,
+					u8 key_idx, bool uni,
+					bool multi)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	mac80211_set_default_key(sdata, key_idx, uni, multi);
+
+	return 0;
+}
+
+static int ieee80211_config_default_mgmt_key(struct wiphy *wiphy,
+					     struct net_device *dev,
+					     u8 key_idx)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	mac80211_set_default_mgmt_key(sdata, key_idx);
+
+	return 0;
+}
+
+static void rate_idx_to_bitrate(struct rate_info *rate, struct sta_info *sta, int idx)
+{
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(sta->local, sta->sdata);
+	if (!(rate->flags & RATE_INFO_FLAGS_MCS)) {
+		struct ieee80211_supported_band *sband;
+		sband = sta->local->hw.wiphy->bands[
+				chan_state->conf.channel->band];
+		rate->legacy = sband->bitrates[idx].bitrate;
+	} else
+		rate->mcs = idx;
+}
+
+static void sta_set_sinfo(struct sta_info *sta, struct station_info *sinfo)
+{
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
+	struct timespec64 uptime;
+
+	sinfo->generation = sdata->local->sta_generation;
+
+	sinfo->filled = BIT(NL80211_STA_INFO_INACTIVE_TIME) |
+			BIT(NL80211_STA_INFO_RX_BYTES) |
+			BIT(NL80211_STA_INFO_TX_BYTES) |
+			BIT(NL80211_STA_INFO_RX_PACKETS) |
+			BIT(NL80211_STA_INFO_TX_PACKETS) |
+			BIT(NL80211_STA_INFO_TX_RETRIES) |
+			BIT(NL80211_STA_INFO_TX_FAILED) |
+			BIT(NL80211_STA_INFO_TX_BITRATE) |
+			BIT(NL80211_STA_INFO_RX_BITRATE) |
+			BIT(NL80211_STA_INFO_RX_DROP_MISC) |
+			BIT(NL80211_STA_INFO_BSS_PARAM) |
+			BIT(NL80211_STA_INFO_CONNECTED_TIME) |
+			BIT(NL80211_STA_INFO_STA_FLAGS);
+
+	ktime_get_ts(&uptime);
+	sinfo->connected_time = uptime.tv_sec - sta->last_connected;
+
+	sinfo->inactive_time = jiffies_to_msecs(jiffies - sta->last_rx);
+	sinfo->rx_bytes = sta->rx_bytes;
+	sinfo->tx_bytes = sta->tx_bytes;
+	sinfo->rx_packets = sta->rx_packets;
+	sinfo->tx_packets = sta->tx_packets;
+	sinfo->tx_retries = sta->tx_retry_count;
+	sinfo->tx_failed = sta->tx_retry_failed;
+	sinfo->rx_dropped_misc = sta->rx_dropped;
+
+	if ((sta->local->hw.flags & IEEE80211_HW_SIGNAL_DBM) ||
+	    (sta->local->hw.flags & IEEE80211_HW_SIGNAL_UNSPEC)) {
+		sinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL) | BIT(NL80211_STA_INFO_SIGNAL_AVG);
+		sinfo->signal = (s8)sta->last_signal;
+		sinfo->signal_avg = (s8) -ewma_read(&sta->avg_signal);
+	}
+
+	sinfo->txrate.flags = 0;
+	if (sta->last_tx_rate.flags & IEEE80211_TX_RC_MCS)
+		sinfo->txrate.flags |= RATE_INFO_FLAGS_MCS;
+	if (sta->last_tx_rate.flags & IEEE80211_TX_RC_40_MHZ_WIDTH)
+		sinfo->txrate.bw |= RATE_INFO_BW_40;
+	if (sta->last_tx_rate.flags & IEEE80211_TX_RC_SHORT_GI)
+		sinfo->txrate.flags |= RATE_INFO_FLAGS_SHORT_GI;
+	rate_idx_to_bitrate(&sinfo->txrate, sta, sta->last_tx_rate.idx);
+
+	sinfo->rxrate.flags = 0;
+	if (sta->last_rx_rate_flag & RX_FLAG_HT)
+		sinfo->rxrate.flags |= RATE_INFO_FLAGS_MCS;
+	if (sta->last_rx_rate_flag & RX_FLAG_40MHZ)
+		sinfo->rxrate.bw |= RATE_INFO_BW_40;
+	if (sta->last_rx_rate_flag & RX_FLAG_SHORT_GI)
+		sinfo->rxrate.flags |= RATE_INFO_FLAGS_SHORT_GI;
+	rate_idx_to_bitrate(&sinfo->rxrate, sta, sta->last_rx_rate_idx);
+
+	if (ieee80211_vif_is_mesh(&sdata->vif)) {
+#ifdef CONFIG_XRMAC_MESH
+		sinfo->filled |= BIT(NL80211_STA_INFO_LLID) |
+				 BIT(NL80211_STA_INFO_PLID) |
+				 BIT(NL80211_STA_INFO_PLINK_STATE);
+
+		sinfo->llid = le16_to_cpu(sta->llid);
+		sinfo->plid = le16_to_cpu(sta->plid);
+		sinfo->plink_state = sta->plink_state;
+#endif
+	}
+
+	sinfo->bss_param.flags = 0;
+	if (sdata->vif.bss_conf.use_cts_prot)
+		sinfo->bss_param.flags |= BSS_PARAM_FLAGS_CTS_PROT;
+	if (sdata->vif.bss_conf.use_short_preamble)
+		sinfo->bss_param.flags |= BSS_PARAM_FLAGS_SHORT_PREAMBLE;
+	if (sdata->vif.bss_conf.use_short_slot)
+		sinfo->bss_param.flags |= BSS_PARAM_FLAGS_SHORT_SLOT_TIME;
+	sinfo->bss_param.dtim_period = sdata->vif.bss_conf.ps_dtim_period;
+	sinfo->bss_param.beacon_interval = sdata->vif.bss_conf.beacon_int;
+
+	sinfo->sta_flags.set = 0;
+	sinfo->sta_flags.mask = BIT(NL80211_STA_FLAG_AUTHORIZED) |
+				BIT(NL80211_STA_FLAG_SHORT_PREAMBLE) |
+				BIT(NL80211_STA_FLAG_WME) |
+				BIT(NL80211_STA_FLAG_MFP) |
+				BIT(NL80211_STA_FLAG_AUTHENTICATED);
+	if (test_sta_flag(sta, WLAN_STA_AUTHORIZED))
+		sinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_AUTHORIZED);
+	if (test_sta_flag(sta, WLAN_STA_SHORT_PREAMBLE))
+		sinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_SHORT_PREAMBLE);
+	if (test_sta_flag(sta, WLAN_STA_WME))
+		sinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_WME);
+	if (test_sta_flag(sta, WLAN_STA_MFP))
+		sinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_MFP);
+	if (test_sta_flag(sta, WLAN_STA_AUTH))
+		sinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_AUTHENTICATED);
+}
+
+
+static int ieee80211_dump_station(struct wiphy *wiphy, struct net_device *dev,
+				 int idx, u8 *mac, struct station_info *sinfo)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct sta_info *sta;
+	int ret = -ENOENT;
+
+	rcu_read_lock();
+
+	sta = xrmac_sta_info_get_by_idx(sdata, idx);
+	if (sta) {
+		ret = 0;
+		memcpy(mac, sta->sta.addr, ETH_ALEN);
+		sta_set_sinfo(sta, sinfo);
+	}
+
+	rcu_read_unlock();
+
+	return ret;
+}
+
+static int ieee80211_dump_survey(struct wiphy *wiphy, struct net_device *dev,
+				 int idx, struct survey_info *survey)
+{
+	struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);
+
+	return drv_get_survey(local, idx, survey);
+}
+
+static int ieee80211_get_station(struct wiphy *wiphy, struct net_device *dev,
+				const u8 *mac, struct station_info *sinfo)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct sta_info *sta;
+	int ret = -ENOENT;
+
+	rcu_read_lock();
+
+	sta = xrmac_sta_info_get_bss(sdata, mac);
+	if (sta) {
+		ret = 0;
+		sta_set_sinfo(sta, sinfo);
+	}
+
+	rcu_read_unlock();
+
+	return ret;
+}
+
+static void ieee80211_config_ap_ssid(struct ieee80211_sub_if_data *sdata,
+				     struct cfg80211_ap_settings *params)
+{
+	struct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;
+
+	bss_conf->ssid_len = params->ssid_len;
+
+	if (params->ssid_len)
+		memcpy(bss_conf->ssid, params->ssid, params->ssid_len);
+
+	bss_conf->hidden_ssid =
+		(params->hidden_ssid != NL80211_HIDDEN_SSID_NOT_IN_USE);
+}
+
+static void free_old_beacon(struct rcu_head *rcu_head)
+{
+	struct beacon_data *old =
+			container_of(rcu_head, struct beacon_data, rcu_head);
+
+	kfree(old);
+}
+
+/*
+ * This handles both adding a beacon and setting new beacon info
+ */
+static int ieee80211_config_beacon(struct ieee80211_sub_if_data *sdata,
+				   struct cfg80211_ap_settings *params)
+{
+	struct beacon_data *new, *old;
+	int new_head_len, new_tail_len;
+	int size;
+	int err = -EINVAL;
+
+	old = rtnl_dereference(sdata->u.ap.beacon);
+
+	/* head must not be zero-length */
+	if (params->beacon.head && !params->beacon.head_len)
+		return -EINVAL;
+
+	/*
+	 * This is a kludge. beacon interval should really be part
+	 * of the beacon information.
+	 */
+	if (params->beacon_interval &&
+	    (sdata->vif.bss_conf.beacon_int != params->beacon_interval)) {
+		sdata->vif.bss_conf.beacon_int = params->beacon_interval;
+		mac80211_bss_info_change_notify(sdata,
+						 BSS_CHANGED_BEACON_INT);
+	}
+
+	/* Need to have a beacon head if we don't have one yet */
+	if (!params->beacon.head && !old)
+		return err;
+
+	/* sorry, no way to start beaconing without dtim period */
+	if (!params->dtim_period && !old)
+		return err;
+
+	/* new or old head? */
+	if (params->beacon.head)
+		new_head_len = params->beacon.head_len;
+	else
+		new_head_len = old->head_len;
+
+	/* new or old tail? */
+	if (params->beacon.tail || !old)
+		/* params->tail_len will be zero for !params->tail */
+		new_tail_len = params->beacon.tail_len;
+	else
+		new_tail_len = old->tail_len;
+
+	size = sizeof(*new) + new_head_len + new_tail_len;
+
+	new = kzalloc(size, GFP_KERNEL);
+	if (!new)
+		return -ENOMEM;
+
+	/* start filling the new info now */
+
+	/* new or old dtim period? */
+	if (params->dtim_period)
+		new->dtim_period = params->dtim_period;
+	else
+		new->dtim_period = old->dtim_period;
+
+	/*
+	 * pointers go into the block we allocated,
+	 * memory is | beacon_data | head | tail |
+	 */
+	new->head = ((u8 *) new) + sizeof(*new);
+	new->tail = new->head + new_head_len;
+	new->head_len = new_head_len;
+	new->tail_len = new_tail_len;
+
+	/* copy in head */
+	if (params->beacon.head)
+		memcpy(new->head, params->beacon.head, new_head_len);
+	else
+		memcpy(new->head, old->head, new_head_len);
+
+	/* copy in optional tail */
+	if (params->beacon.tail)
+		memcpy(new->tail, params->beacon.tail, new_tail_len);
+	else
+		if (old)
+			memcpy(new->tail, old->tail, new_tail_len);
+
+
+	sdata->vif.bss_conf.dtim_period = new->dtim_period;
+
+	rcu_assign_pointer(sdata->u.ap.beacon, new);
+
+	if (old)
+		call_rcu(&old->rcu_head, free_old_beacon);
+
+	ieee80211_config_ap_ssid(sdata, params);
+
+	mac80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON_ENABLED |
+						BSS_CHANGED_BEACON |
+						BSS_CHANGED_SSID);
+	mac80211_bss_info_change_notify(sdata, BSS_CHANGED_ARP_FILTER);
+
+#ifdef IPV6_FILTERING
+	mac80211_bss_info_change_notify(sdata, BSS_CHANGED_NDP_FILTER);
+#endif /*IPV6_FILTERING*/
+	return 0;
+}
+
+static int ieee80211_change_config_beacon(struct ieee80211_sub_if_data *sdata,
+				   struct cfg80211_beacon_data *params)
+{
+	struct beacon_data *new, *old;
+	int new_head_len, new_tail_len;
+	int size;
+	int err = -EINVAL;
+
+	old = rtnl_dereference(sdata->u.ap.beacon);
+
+	/* head must not be zero-length */
+	if (params->head && !params->head_len)
+		return -EINVAL;
+
+	/*
+	 * This is a kludge. beacon interval should really be part
+	 * of the beacon information.
+	 */
+
+#if 0
+	if (params->beacon_interval &&
+	    (sdata->vif.bss_conf.beacon_int != params->beacon_interval)) {
+		sdata->vif.bss_conf.beacon_int = params->beacon_interval;
+		mac80211_bss_info_change_notify(sdata,
+						 BSS_CHANGED_BEACON_INT);
+	}
+#endif
+	/* Need to have a beacon head if we don't have one yet */
+	if (!params->head && !old)
+		return err;
+
+	/* sorry, no way to start beaconing without dtim period */
+	/*
+	 if (!params->dtim_period && !old)
+		return err;
+	*/
+	/* new or old head? */
+	if (params->head)
+		new_head_len = params->head_len;
+	else
+		new_head_len = old->head_len;
+
+	/* new or old tail? */
+	if (params->tail || !old)
+		/* params->tail_len will be zero for !params->tail */
+		new_tail_len = params->tail_len;
+	else
+		new_tail_len = old->tail_len;
+
+	size = sizeof(*new) + new_head_len + new_tail_len;
+
+	new = kzalloc(size, GFP_KERNEL);
+	if (!new)
+		return -ENOMEM;
+
+	/* start filling the new info now */
+
+	/* new or old dtim period? */
+	/*
+	if (params->dtim_period)
+		new->dtim_period = params->dtim_period;
+	else
+	*/
+	new->dtim_period = old->dtim_period;
+
+	/*
+	 * pointers go into the block we allocated,
+	 * memory is | beacon_data | head | tail |
+	 */
+	new->head = ((u8 *) new) + sizeof(*new);
+	new->tail = new->head + new_head_len;
+	new->head_len = new_head_len;
+	new->tail_len = new_tail_len;
+
+	/* copy in head */
+	if (params->head)
+		memcpy(new->head, params->head, new_head_len);
+	else
+		memcpy(new->head, old->head, new_head_len);
+
+	/* copy in optional tail */
+	if (params->tail)
+		memcpy(new->tail, params->tail, new_tail_len);
+	else
+		if (old)
+			memcpy(new->tail, old->tail, new_tail_len);
+
+
+	/*sdata->vif.bss_conf.dtim_period = new->dtim_period;*/
+
+	rcu_assign_pointer(sdata->u.ap.beacon, new);
+
+	if (old)
+		call_rcu(&old->rcu_head, free_old_beacon);
+
+	/*ieee80211_config_ap_ssid(sdata, params);*/
+
+	mac80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON_ENABLED |
+						BSS_CHANGED_BEACON |
+						BSS_CHANGED_SSID);
+	mac80211_bss_info_change_notify(sdata, BSS_CHANGED_ARP_FILTER);
+
+#ifdef IPV6_FILTERING
+	mac80211_bss_info_change_notify(sdata, BSS_CHANGED_NDP_FILTER);
+#endif /*IPV6_FILTERING*/
+	return 0;
+}
+
+#ifdef PROBE_RESP_EXTRA_IE
+static int ieee80211_config_proberesp(struct ieee80211_sub_if_data *sdata,
+				   struct cfg80211_ap_settings *params)
+{
+	struct proberesp_data *new, *old;
+	int new_head_len, new_tail_len, new_proberesp_data_ies_len;
+	int size;
+	int err = -EINVAL;
+
+	old = rtnl_dereference(sdata->u.ap.proberesp);
+
+	/* head must not be zero-length */
+	if (params->beacon.head && !params->beacon.head_len)
+		return -EINVAL;
+
+	/* Need to have a probe response head if we don't have one yet */
+	if (!params->beacon.head && !old)
+		return err;
+
+	/* new or old head? */
+	if (params->beacon.head)
+		new_head_len = params->beacon.head_len;
+	else
+		new_head_len = old->head_len;
+
+	if (params->beacon.proberesp_ies || !old)
+		new_proberesp_data_ies_len = params->beacon.proberesp_ies_len;
+	else
+		new_proberesp_data_ies_len = old->proberesp_data_ies_len;
+
+	/* new or old tail? */
+	if (params->beacon.tail || !old)
+		/* params->tail_len will be zero for !params->tail */
+		new_tail_len = params->beacon.tail_len;
+	else
+		new_tail_len = old->tail_len;
+
+	size = sizeof(*new) + new_head_len + new_proberesp_data_ies_len + new_tail_len;
+
+	new = kzalloc(size, GFP_KERNEL);
+	if (!new)
+		return -ENOMEM;
+
+	new->head = ((u8 *) new) + sizeof(*new);
+	new->head_len = new_head_len;
+	new->tail = new->head + new->head_len;
+	new->tail_len = new_tail_len;
+
+	/* copy in head */
+	if (params->beacon.head)
+		memcpy(new->head, params->beacon.head, new_head_len);
+	else
+		memcpy(new->head, old->head, new_head_len);
+
+	*(__le16 *)new->head = __cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_PROBE_RESP);
+
+	/* copy in optional tail */
+	if (params->beacon.tail) {
+		memcpy(new->tail, params->beacon.tail, new_tail_len);
+	} else {
+		if (old)
+			memcpy(new->tail, old->tail, new_tail_len);
+	}
+
+	/*
+	 * Remove WPS IE and P2P IE from tail, as for probe response these IEs are
+	 * provided as part of proberesp_ies.
+	 */
+	if (params->beacon.tail) {
+		int tail_len;
+		volatile u8 *p = new->tail;
+		u8 ie_len;
+
+		tail_len = new->tail_len;
+
+		while (tail_len >= 6) {
+			ie_len = p[1] + 2;
+			tail_len -= ie_len;
+			if ((p[0] == WLAN_EID_VENDOR_SPECIFIC)
+				&& ((p[2] == 0x00 && p[3] == 0x50 && p[4] == 0xf2 && p[5] == 0x04)
+				|| (p[2] == 0x50 && p[3] == 0x6f && p[4] == 0x9a && p[5] == 0x09))) {
+
+				memmove((u8 *)p, (u8 *)p + ie_len, tail_len);
+				new->tail_len -= ie_len;
+			} else {
+				p += ie_len;
+			}
+		}
+	}
+
+	new->proberesp_data_ies = new->tail + new->tail_len;
+	new->proberesp_data_ies_len = new_proberesp_data_ies_len;
+
+	/* copy in optional probe response ies */
+	if (params->beacon.proberesp_ies)
+		memcpy(new->proberesp_data_ies, params->beacon.proberesp_ies, new_proberesp_data_ies_len);
+	else
+		if (old)
+			memcpy(new->proberesp_data_ies, old->proberesp_data_ies, new_proberesp_data_ies_len);
+
+	rcu_assign_pointer(sdata->u.ap.proberesp, new);
+
+	synchronize_rcu();
+
+	kfree(old);
+
+	return 0;
+}
+#endif
+
+#ifdef PROBE_RESP_EXTRA_IE
+static int ieee80211_change_config_proberesp(struct ieee80211_sub_if_data *sdata,
+				   struct cfg80211_beacon_data *params)
+{
+	struct proberesp_data *new, *old;
+	int new_head_len, new_tail_len, new_proberesp_data_ies_len;
+	int size;
+	int err = -EINVAL;
+
+	old = rtnl_dereference(sdata->u.ap.proberesp);
+
+	/* head must not be zero-length */
+	if (params->head && !params->head_len)
+		return -EINVAL;
+
+	/* Need to have a probe response head if we don't have one yet */
+	if (!params->head && !old)
+		return err;
+
+	/* new or old head? */
+	if (params->head)
+		new_head_len = params->head_len;
+	else
+		new_head_len = old->head_len;
+
+	if (params->proberesp_ies || !old)
+		new_proberesp_data_ies_len = params->proberesp_ies_len;
+	else
+		new_proberesp_data_ies_len = old->proberesp_data_ies_len;
+
+	/* new or old tail? */
+	if (params->tail || !old)
+		/* params->tail_len will be zero for !params->tail */
+		new_tail_len = params->tail_len;
+	else
+		new_tail_len = old->tail_len;
+
+	size = sizeof(*new) + new_head_len + new_proberesp_data_ies_len + new_tail_len;
+
+	new = kzalloc(size, GFP_KERNEL);
+	if (!new)
+		return -ENOMEM;
+
+	new->head = ((u8 *) new) + sizeof(*new);
+	new->head_len = new_head_len;
+	new->tail = new->head + new->head_len;
+	new->tail_len = new_tail_len;
+
+	/* copy in head */
+	if (params->head)
+		memcpy(new->head, params->head, new_head_len);
+	else
+		memcpy(new->head, old->head, new_head_len);
+
+	*(__le16 *)new->head = __cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_PROBE_RESP);
+
+	/* copy in optional tail */
+	if (params->tail) {
+		memcpy(new->tail, params->tail, new_tail_len);
+	} else {
+		if (old)
+			memcpy(new->tail, old->tail, new_tail_len);
+	}
+
+	/*
+	 * Remove WPS IE and P2P IE from tail, as for probe response these IEs are
+	 * provided as part of proberesp_ies.
+	 */
+	if (params->tail) {
+		int tail_len;
+		volatile u8 *p = new->tail;
+		u8 ie_len;
+
+		tail_len = new->tail_len;
+
+		while (tail_len >= 6) {
+			ie_len = p[1] + 2;
+			tail_len -= ie_len;
+			if ((p[0] == WLAN_EID_VENDOR_SPECIFIC)
+				&& ((p[2] == 0x00 && p[3] == 0x50 && p[4] == 0xf2 && p[5] == 0x04)
+				|| (p[2] == 0x50 && p[3] == 0x6f && p[4] == 0x9a && p[5] == 0x09))) {
+
+				memmove((u8 *)p, (u8 *)p + ie_len, tail_len);
+				new->tail_len -= ie_len;
+			} else {
+				p += ie_len;
+			}
+		}
+	}
+
+	new->proberesp_data_ies = new->tail + new->tail_len;
+	new->proberesp_data_ies_len = new_proberesp_data_ies_len;
+
+	/* copy in optional probe response ies */
+	if (params->proberesp_ies)
+		memcpy(new->proberesp_data_ies, params->proberesp_ies, new_proberesp_data_ies_len);
+	else
+		if (old)
+			memcpy(new->proberesp_data_ies, old->proberesp_data_ies, new_proberesp_data_ies_len);
+
+	rcu_assign_pointer(sdata->u.ap.proberesp, new);
+
+	synchronize_rcu();
+
+	kfree(old);
+
+	return 0;
+}
+#endif
+
+static int ieee80211_set_channel(struct wiphy *wiphy,
+				 struct net_device *netdev,
+				 struct ieee80211_channel *chan,
+				 enum nl80211_channel_type channel_type)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+	struct ieee80211_channel_state *chan_state;
+	struct ieee80211_sub_if_data *sdata = NULL;
+	struct ieee80211_channel *old_oper;
+	enum nl80211_channel_type old_oper_type;
+	enum nl80211_channel_type old_vif_oper_type = NL80211_CHAN_NO_HT;
+
+	if (WARN(!netdev, "Cannot set channel without a specific interface. \n"
+				"Monitor interface cannot have a channel set, yet. \n")) {
+		return -ENOTSUPP;
+	}
+
+	sdata = IEEE80211_DEV_TO_SUB_IF(netdev);
+	chan_state = ieee80211_get_channel_state(local, sdata);
+
+	switch (mac80211_get_channel_mode(local, NULL)) {
+	case CHAN_MODE_HOPPING:
+		return -EBUSY;
+	case CHAN_MODE_FIXED:
+		if (!sdata && chan_state->_oper_channel_type == channel_type)
+			return 0;
+		break;
+	case CHAN_MODE_UNDEFINED:
+		break;
+	}
+
+	if (sdata)
+		old_vif_oper_type = sdata->vif.bss_conf.channel_type;
+	old_oper_type = chan_state->_oper_channel_type;
+
+	if (!mac80211_set_channel_type(local, sdata, channel_type))
+		return -EBUSY;
+
+	old_oper = chan_state->oper_channel;
+	chan_state->oper_channel = chan;
+
+	/* Update driver if changes were actually made. */
+	if ((old_oper != chan_state->oper_channel) ||
+	    (old_oper_type != chan_state->_oper_channel_type))
+		mac80211_hw_config(local, IEEE80211_CONF_CHANGE_CHANNEL);
+
+	if ((sdata && sdata->vif.type != NL80211_IFTYPE_MONITOR) &&
+	    old_vif_oper_type != sdata->vif.bss_conf.channel_type)
+		mac80211_bss_info_change_notify(sdata, BSS_CHANGED_HT);
+
+	return 0;
+}
+
+static int ieee80211_start_ap(struct wiphy *wiphy, struct net_device *dev,
+			      struct cfg80211_ap_settings *params)
+{
+	struct ieee80211_sub_if_data *sdata;
+	struct beacon_data *old;
+	enum nl80211_channel_type channel_type = NL80211_CHAN_NO_HT;
+#ifdef PROBE_RESP_EXTRA_IE
+	struct proberesp_data *old_proberesp;
+	int ret = 0;
+#endif
+
+	sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	switch (params->chandef.width) {
+	case NL80211_CHAN_WIDTH_20_NOHT:
+		channel_type = NL80211_CHAN_NO_HT;
+		break;
+	case NL80211_CHAN_WIDTH_20:
+		channel_type = NL80211_CHAN_HT20;
+		break;
+	case NL80211_CHAN_WIDTH_40:
+		if (params->chandef.center_freq1 == params->chandef.chan->center_freq + 10)
+			channel_type = NL80211_CHAN_HT40PLUS;
+		else if (params->chandef.center_freq1 == params->chandef.chan->center_freq - 10)
+			channel_type = NL80211_CHAN_HT40MINUS;
+		break;
+	case NL80211_CHAN_WIDTH_80:
+	case NL80211_CHAN_WIDTH_80P80:
+	case NL80211_CHAN_WIDTH_160:
+		printk(KERN_ERR "can't support bigger 40 width mode");
+		return -ENOTSUPP;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = ieee80211_set_channel(wiphy,
+					dev, params->chandef.chan, channel_type);
+	if (ret)
+		return ret;
+	old = rtnl_dereference(sdata->u.ap.beacon);
+	if (old)
+		return -EALREADY;
+#ifdef PROBE_RESP_EXTRA_IE
+	old_proberesp = rtnl_dereference(sdata->u.ap.proberesp);
+	if (old_proberesp)
+		return -EALREADY;
+	ret = ieee80211_config_proberesp(sdata, params);
+	if (!ret) {
+		netif_carrier_on(dev);
+		ret = ieee80211_config_beacon(sdata, params);
+	}
+	return ret;
+#else
+	netif_carrier_on(dev);
+	return ieee80211_config_beacon(sdata, params);
+#endif
+}
+
+
+static int ieee80211_change_beacon(struct wiphy *wiphy, struct net_device *dev,
+				   struct cfg80211_beacon_data *params)
+{
+	struct ieee80211_sub_if_data *sdata;
+	struct beacon_data *old;
+#ifdef PROBE_RESP_EXTRA_IE
+	struct proberesp_data *old_proberesp;
+	int ret = 0;
+#endif
+	sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	old = rtnl_dereference(sdata->u.ap.beacon);
+	if (!old)
+		return -ENOENT;
+
+#ifdef PROBE_RESP_EXTRA_IE
+	old_proberesp = rtnl_dereference(sdata->u.ap.proberesp);
+	if (!old_proberesp)
+		return -ENOENT;
+	ret = ieee80211_change_config_proberesp(sdata, params);
+	if (!ret)
+		ret = ieee80211_change_config_beacon(sdata, params);
+	return ret;
+#else
+
+	return ieee80211_change_config_beacon(sdata, params);
+#endif
+}
+
+static int ieee80211_stop_ap(struct wiphy *wiphy, struct net_device *dev)
+{
+	struct ieee80211_sub_if_data *sdata;
+	struct beacon_data *old;
+#ifdef PROBE_RESP_EXTRA_IE
+	struct proberesp_data *old_proberesp;
+#endif
+
+	sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	old = rtnl_dereference(sdata->u.ap.beacon);
+	if (!old)
+		return -ENOENT;
+	netif_carrier_off(dev);
+	RCU_INIT_POINTER(sdata->u.ap.beacon, NULL);
+	synchronize_rcu();
+	kfree(old);
+#ifdef PROBE_RESP_EXTRA_IE
+	old_proberesp = rtnl_dereference(sdata->u.ap.proberesp);
+	if (!old_proberesp)
+		return -ENOENT;
+
+	rcu_assign_pointer(sdata->u.ap.proberesp, NULL);
+	synchronize_rcu();
+	kfree(old_proberesp);
+#endif
+	mac80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON_ENABLED);
+	return 0;
+}
+
+static int ieee80211_set_monitor_channel(struct wiphy *wiphy,
+					 struct cfg80211_chan_def *chandef)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+	struct ieee80211_sub_if_data *sdata;
+	struct net_device *dev = NULL;
+	int ret = 0;
+	enum nl80211_channel_type channel_type = NL80211_CHAN_NO_HT;
+
+	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
+		if (sdata->vif.type != NL80211_IFTYPE_MONITOR)
+			continue;
+
+		if (sdata->u.mntr_flags & MONITOR_FLAG_COOK_FRAMES)
+			continue;
+
+		if (!ieee80211_sdata_running(sdata))
+			continue;
+
+		dev = sdata->dev;
+	}
+	switch (chandef->width) {
+	case NL80211_CHAN_WIDTH_20_NOHT:
+		channel_type = NL80211_CHAN_NO_HT;
+		break;
+	case NL80211_CHAN_WIDTH_20:
+		channel_type = NL80211_CHAN_HT20;
+		break;
+	case NL80211_CHAN_WIDTH_40:
+		if (chandef->center_freq1 == chandef->chan->center_freq + 10)
+			channel_type = NL80211_CHAN_HT40PLUS;
+		else if (chandef->center_freq1 == chandef->chan->center_freq - 10)
+			channel_type = NL80211_CHAN_HT40MINUS;
+		break;
+	case NL80211_CHAN_WIDTH_80:
+	case NL80211_CHAN_WIDTH_80P80:
+	case NL80211_CHAN_WIDTH_160:
+		printk(KERN_ERR "can't support bigger 40 width mode");
+		return -ENOTSUPP;
+	default:
+		return -EINVAL;
+	}
+
+	ret = ieee80211_set_channel(wiphy,
+					dev, chandef->chan, channel_type);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+/* Layer 2 Update frame (802.2 Type 1 LLC XID Update response) */
+struct iapp_layer2_update {
+	u8 da[ETH_ALEN];	/* broadcast */
+	u8 sa[ETH_ALEN];	/* STA addr */
+	__be16 len;		/* 6 */
+	u8 dsap;		/* 0 */
+	u8 ssap;		/* 0 */
+	u8 control;
+	u8 xid_info[3];
+} __packed;
+
+static void ieee80211_send_layer2_update(struct sta_info *sta)
+{
+	struct iapp_layer2_update *msg;
+	struct sk_buff *skb;
+
+	/* Send Level 2 Update Frame to update forwarding tables in layer 2
+	 * bridge devices */
+
+	skb = dev_alloc_skb(sizeof(*msg));
+	if (!skb)
+		return;
+	msg = (struct iapp_layer2_update *)skb_put(skb, sizeof(*msg));
+
+	/* 802.2 Type 1 Logical Link Control (LLC) Exchange Identifier (XID)
+	 * Update response frame; IEEE Std 802.2-1998, 5.4.1.2.1 */
+
+	memset(msg->da, 0xff, ETH_ALEN);
+	memcpy(msg->sa, sta->sta.addr, ETH_ALEN);
+	msg->len = htons(6);
+	msg->dsap = 0;
+	msg->ssap = 0x01;	/* NULL LSAP, CR Bit: Response */
+	msg->control = 0xaf;	/* XID response lsb.1111F101.
+				 * F=0 (no poll command; unsolicited frame) */
+	msg->xid_info[0] = 0x81;	/* XID format identifier */
+	msg->xid_info[1] = 1;	/* LLC types/classes: Type 1 LLC */
+	msg->xid_info[2] = 0;	/* XID sender's receive window size (RW) */
+
+	skb->dev = sta->sdata->dev;
+	skb->protocol = eth_type_trans(skb, sta->sdata->dev);
+	memset(skb->cb, 0, sizeof(skb->cb));
+	netif_rx_ni(skb);
+}
+
+static void sta_apply_parameters(struct ieee80211_local *local,
+				 struct sta_info *sta,
+				 struct station_parameters *params)
+{
+	u32 rates;
+	int i, j;
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sdata);
+	u32 mask, set;
+
+	sband = local->hw.wiphy->bands[chan_state->oper_channel->band];
+
+	mask = params->sta_flags_mask;
+	set = params->sta_flags_set;
+
+	if (mask & BIT(NL80211_STA_FLAG_AUTHORIZED)) {
+		if (set & BIT(NL80211_STA_FLAG_AUTHORIZED))
+			set_sta_flag(sta, WLAN_STA_AUTHORIZED);
+		else
+			clear_sta_flag(sta, WLAN_STA_AUTHORIZED);
+	}
+
+	if (mask & BIT(NL80211_STA_FLAG_SHORT_PREAMBLE)) {
+		if (set & BIT(NL80211_STA_FLAG_SHORT_PREAMBLE))
+			set_sta_flag(sta, WLAN_STA_SHORT_PREAMBLE);
+		else
+			clear_sta_flag(sta, WLAN_STA_SHORT_PREAMBLE);
+	}
+
+	if (mask & BIT(NL80211_STA_FLAG_WME)) {
+		if (set & BIT(NL80211_STA_FLAG_WME)) {
+			set_sta_flag(sta, WLAN_STA_WME);
+			sta->sta.wme = true;
+		} else {
+			clear_sta_flag(sta, WLAN_STA_WME);
+			sta->sta.wme = false;
+		}
+	}
+
+	if (mask & BIT(NL80211_STA_FLAG_MFP)) {
+		if (set & BIT(NL80211_STA_FLAG_MFP))
+			set_sta_flag(sta, WLAN_STA_MFP);
+		else
+			clear_sta_flag(sta, WLAN_STA_MFP);
+	}
+
+	if (mask & BIT(NL80211_STA_FLAG_AUTHENTICATED)) {
+		if (set & BIT(NL80211_STA_FLAG_AUTHENTICATED))
+			set_sta_flag(sta, WLAN_STA_AUTH);
+		else
+			clear_sta_flag(sta, WLAN_STA_AUTH);
+	}
+
+	if (mask & BIT(NL80211_STA_FLAG_TDLS_PEER)) {
+		if (set & BIT(NL80211_STA_FLAG_TDLS_PEER))
+			set_sta_flag(sta, WLAN_STA_TDLS_PEER);
+		else
+			clear_sta_flag(sta, WLAN_STA_TDLS_PEER);
+	}
+
+	if (params->sta_modify_mask & STATION_PARAM_APPLY_UAPSD) {
+		sta->sta.uapsd_queues = params->uapsd_queues;
+		sta->sta.max_sp = params->max_sp;
+	}
+
+	/*
+	 * cfg80211 validates this (1-2007) and allows setting the AID
+	 * only when creating a new station entry
+	 */
+	if (params->aid)
+		sta->sta.aid = params->aid;
+
+	/*
+	 * FIXME: updating the following information is racy when this
+	 *	  function is called from ieee80211_change_station().
+	 *	  However, all this information should be static so
+	 *	  maybe we should just reject attemps to change it.
+	 */
+
+	if (params->listen_interval >= 0)
+		sta->listen_interval = params->listen_interval;
+
+	if (params->supported_rates) {
+		rates = 0;
+
+		for (i = 0; i < params->supported_rates_len; i++) {
+			int rate = (params->supported_rates[i] & 0x7f) * 5;
+			for (j = 0; j < sband->n_bitrates; j++) {
+				if (sband->bitrates[j].bitrate == rate)
+					rates |= BIT(j);
+			}
+		}
+		sta->sta.supp_rates[chan_state->oper_channel->band] = rates;
+	}
+
+	if (params->ht_capa)
+		mac80211_ht_cap_ie_to_sta_ht_cap(sband,
+						  params->ht_capa,
+						  &sta->sta.ht_cap);
+
+	if (ieee80211_vif_is_mesh(&sdata->vif)) {
+#ifdef CONFIG_XRMAC_MESH
+		if (sdata->u.mesh.security & IEEE80211_MESH_SEC_SECURED)
+			switch (params->plink_state) {
+			case NL80211_PLINK_LISTEN:
+			case NL80211_PLINK_ESTAB:
+			case NL80211_PLINK_BLOCKED:
+				sta->plink_state = params->plink_state;
+				break;
+			default:
+				/*  nothing  */
+				break;
+			}
+		else
+			switch (params->plink_action) {
+			case PLINK_ACTION_OPEN:
+				xrmac_mesh_plink_open(sta);
+				break;
+			case PLINK_ACTION_BLOCK:
+				xrmac_mesh_plink_block(sta);
+				break;
+			}
+#endif
+	}
+}
+
+static int ieee80211_add_station(struct wiphy *wiphy, struct net_device *dev,
+				 const u8 *mac, struct station_parameters *params)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+	struct sta_info *sta;
+	struct ieee80211_sub_if_data *sdata;
+	int err;
+	int layer2_update;
+
+	if (params->vlan) {
+		sdata = IEEE80211_DEV_TO_SUB_IF(params->vlan);
+
+		if (sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&
+		    sdata->vif.type != NL80211_IFTYPE_AP)
+			return -EINVAL;
+	} else
+		sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	if (compare_ether_addr(mac, sdata->vif.addr) == 0)
+		return -EINVAL;
+
+	if (is_multicast_ether_addr(mac))
+		return -EINVAL;
+
+	/* Only TDLS-supporting stations can add TDLS peers */
+	if ((params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)) &&
+	    !((wiphy->flags & WIPHY_FLAG_SUPPORTS_TDLS) &&
+	      sdata->vif.type == NL80211_IFTYPE_STATION))
+		return -ENOTSUPP;
+
+	sta = xrmac_sta_info_alloc(sdata, mac, GFP_KERNEL);
+	if (!sta)
+		return -ENOMEM;
+
+	set_sta_flag(sta, WLAN_STA_AUTH);
+	set_sta_flag(sta, WLAN_STA_ASSOC);
+
+	sta_apply_parameters(local, sta, params);
+
+	rate_control_rate_init(sta);
+
+	layer2_update = sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||
+		sdata->vif.type == NL80211_IFTYPE_AP;
+
+	err = xrmac_sta_info_insert_rcu(sta);
+	if (err) {
+		rcu_read_unlock();
+		return err;
+	}
+
+	if (layer2_update)
+		ieee80211_send_layer2_update(sta);
+
+	rcu_read_unlock();
+
+	return 0;
+}
+
+static int ieee80211_del_station(struct wiphy *wiphy, struct net_device *dev,
+				 struct station_del_parameters *params)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+	struct ieee80211_sub_if_data *sdata;
+
+	sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	if (params->mac)
+		return xrmac_sta_info_destroy_addr_bss(sdata, params->mac);
+
+	xrmac_sta_info_flush(local, sdata);
+	return 0;
+}
+
+static int ieee80211_change_station(struct wiphy *wiphy,
+				    struct net_device *dev,
+				    const u8 *mac,
+				    struct station_parameters *params)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+	struct sta_info *sta;
+	struct ieee80211_sub_if_data *vlansdata;
+
+	rcu_read_lock();
+
+	sta = xrmac_sta_info_get_bss(sdata, mac);
+	if (!sta) {
+		rcu_read_unlock();
+		return -ENOENT;
+	}
+
+	/* The TDLS bit cannot be toggled after the STA was added */
+	if ((params->sta_flags_mask & BIT(NL80211_STA_FLAG_TDLS_PEER)) &&
+	    !!(params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)) !=
+	    !!test_sta_flag(sta, WLAN_STA_TDLS_PEER)) {
+		rcu_read_unlock();
+		return -EINVAL;
+	}
+
+	if (params->vlan && params->vlan != sta->sdata->dev) {
+		vlansdata = IEEE80211_DEV_TO_SUB_IF(params->vlan);
+
+		if (vlansdata->vif.type != NL80211_IFTYPE_AP_VLAN &&
+		    vlansdata->vif.type != NL80211_IFTYPE_AP) {
+			rcu_read_unlock();
+			return -EINVAL;
+		}
+
+		if (params->vlan->ieee80211_ptr->use_4addr) {
+			if (vlansdata->u.vlan.sta) {
+				rcu_read_unlock();
+				return -EBUSY;
+			}
+
+			rcu_assign_pointer(vlansdata->u.vlan.sta, sta);
+		}
+
+		sta->sdata = vlansdata;
+		ieee80211_send_layer2_update(sta);
+	}
+
+	sta_apply_parameters(local, sta, params);
+
+	rcu_read_unlock();
+
+	if (sdata->vif.type == NL80211_IFTYPE_STATION &&
+	    params->sta_flags_mask & BIT(NL80211_STA_FLAG_AUTHORIZED))
+		mac80211_recalc_ps(local, -1);
+
+	return 0;
+}
+
+#ifdef CONFIG_XRMAC_MESH
+static int ieee80211_add_mpath(struct wiphy *wiphy, struct net_device *dev,
+				 const u8 *dst, u8 *next_hop)
+{
+	struct ieee80211_sub_if_data *sdata;
+	struct mesh_path *mpath;
+	struct sta_info *sta;
+	int err;
+
+	sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	rcu_read_lock();
+	sta = xrmac_sta_info_get(sdata, next_hop);
+	if (!sta) {
+		rcu_read_unlock();
+		return -ENOENT;
+	}
+
+	err = xrmac_mesh_path_add(dst, sdata);
+	if (err) {
+		rcu_read_unlock();
+		return err;
+	}
+
+	mpath = xrmac_mesh_path_lookup(dst, sdata);
+	if (!mpath) {
+		rcu_read_unlock();
+		return -ENXIO;
+	}
+	xrmac_mesh_path_fix_nexthop(mpath, sta);
+
+	rcu_read_unlock();
+	return 0;
+}
+
+static int ieee80211_del_mpath(struct wiphy *wiphy, struct net_device *dev,
+				 u8 *dst)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	if (dst)
+		return xrmac_mesh_path_del(dst, sdata);
+
+	xrmac_mesh_path_flush_by_iface(sdata);
+	return 0;
+}
+
+static int ieee80211_change_mpath(struct wiphy *wiphy,
+				    struct net_device *dev,
+				    const u8 *dst, const u8 *next_hop)
+{
+	struct ieee80211_sub_if_data *sdata;
+	struct mesh_path *mpath;
+	struct sta_info *sta;
+
+	sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	rcu_read_lock();
+
+	sta = xrmac_sta_info_get(sdata, next_hop);
+	if (!sta) {
+		rcu_read_unlock();
+		return -ENOENT;
+	}
+
+	mpath = xrmac_mesh_path_lookup(dst, sdata);
+	if (!mpath) {
+		rcu_read_unlock();
+		return -ENOENT;
+	}
+
+	xrmac_mesh_path_fix_nexthop(mpath, sta);
+
+	rcu_read_unlock();
+	return 0;
+}
+
+static void mpath_set_pinfo(struct mesh_path *mpath, u8 *next_hop,
+			    struct mpath_info *pinfo)
+{
+	struct sta_info *next_hop_sta = rcu_dereference(mpath->next_hop);
+
+	if (next_hop_sta)
+		memcpy(next_hop, next_hop_sta->sta.addr, ETH_ALEN);
+	else
+		memset(next_hop, 0, ETH_ALEN);
+
+	pinfo->generation = xrmac_mesh_paths_generation;
+
+	pinfo->filled = MPATH_INFO_FRAME_QLEN |
+			MPATH_INFO_SN |
+			MPATH_INFO_METRIC |
+			MPATH_INFO_EXPTIME |
+			MPATH_INFO_DISCOVERY_TIMEOUT |
+			MPATH_INFO_DISCOVERY_RETRIES |
+			MPATH_INFO_FLAGS;
+
+	pinfo->frame_qlen = mpath->frame_queue.qlen;
+	pinfo->sn = mpath->sn;
+	pinfo->metric = mpath->metric;
+	if (time_before(jiffies, mpath->exp_time))
+		pinfo->exptime = jiffies_to_msecs(mpath->exp_time - jiffies);
+	pinfo->discovery_timeout =
+			jiffies_to_msecs(mpath->discovery_timeout);
+	pinfo->discovery_retries = mpath->discovery_retries;
+	pinfo->flags = 0;
+	if (mpath->flags & MESH_PATH_ACTIVE)
+		pinfo->flags |= NL80211_MPATH_FLAG_ACTIVE;
+	if (mpath->flags & MESH_PATH_RESOLVING)
+		pinfo->flags |= NL80211_MPATH_FLAG_RESOLVING;
+	if (mpath->flags & MESH_PATH_SN_VALID)
+		pinfo->flags |= NL80211_MPATH_FLAG_SN_VALID;
+	if (mpath->flags & MESH_PATH_FIXED)
+		pinfo->flags |= NL80211_MPATH_FLAG_FIXED;
+	if (mpath->flags & MESH_PATH_RESOLVING)
+		pinfo->flags |= NL80211_MPATH_FLAG_RESOLVING;
+
+	pinfo->flags = mpath->flags;
+}
+
+static int ieee80211_get_mpath(struct wiphy *wiphy, struct net_device *dev,
+			       u8 *dst, u8 *next_hop, struct mpath_info *pinfo)
+
+{
+	struct ieee80211_sub_if_data *sdata;
+	struct mesh_path *mpath;
+
+	sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	rcu_read_lock();
+	mpath = xrmac_mesh_path_lookup(dst, sdata);
+	if (!mpath) {
+		rcu_read_unlock();
+		return -ENOENT;
+	}
+	memcpy(dst, mpath->dst, ETH_ALEN);
+	mpath_set_pinfo(mpath, next_hop, pinfo);
+	rcu_read_unlock();
+	return 0;
+}
+
+static int ieee80211_dump_mpath(struct wiphy *wiphy, struct net_device *dev,
+				 int idx, u8 *dst, u8 *next_hop,
+				 struct mpath_info *pinfo)
+{
+	struct ieee80211_sub_if_data *sdata;
+	struct mesh_path *mpath;
+
+	sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	rcu_read_lock();
+	mpath = xrmac_mesh_path_lookup_by_idx(idx, sdata);
+	if (!mpath) {
+		rcu_read_unlock();
+		return -ENOENT;
+	}
+	memcpy(dst, mpath->dst, ETH_ALEN);
+	mpath_set_pinfo(mpath, next_hop, pinfo);
+	rcu_read_unlock();
+	return 0;
+}
+
+static int ieee80211_get_mesh_config(struct wiphy *wiphy,
+				struct net_device *dev,
+				struct mesh_config *conf)
+{
+	struct ieee80211_sub_if_data *sdata;
+	sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	memcpy(conf, &(sdata->u.mesh.mshcfg), sizeof(struct mesh_config));
+	return 0;
+}
+
+static inline bool _chg_mesh_attr(enum nl80211_meshconf_params parm, u32 mask)
+{
+	return (mask >> (parm-1)) & 0x1;
+}
+
+static int copy_mesh_setup(struct ieee80211_if_mesh *ifmsh,
+		const struct mesh_setup *setup)
+{
+	u8 *new_ie;
+	const u8 *old_ie;
+
+	/* allocate information elements */
+	new_ie = NULL;
+	old_ie = ifmsh->ie;
+
+	if (setup->ie_len) {
+		new_ie = kmemdup(setup->ie, setup->ie_len,
+				GFP_KERNEL);
+		if (!new_ie)
+			return -ENOMEM;
+	}
+	ifmsh->ie_len = setup->ie_len;
+	ifmsh->ie = new_ie;
+	kfree(old_ie);
+
+	/* now copy the rest of the setup parameters */
+	ifmsh->mesh_id_len = setup->mesh_id_len;
+	memcpy(ifmsh->mesh_id, setup->mesh_id, ifmsh->mesh_id_len);
+	ifmsh->mesh_pp_id = setup->path_sel_proto;
+	ifmsh->mesh_pm_id = setup->path_metric;
+	ifmsh->security = IEEE80211_MESH_SEC_NONE;
+	if (setup->is_authenticated)
+		ifmsh->security |= IEEE80211_MESH_SEC_AUTHED;
+	if (setup->is_secure)
+		ifmsh->security |= IEEE80211_MESH_SEC_SECURED;
+
+	return 0;
+}
+
+static int ieee80211_update_mesh_config(struct wiphy *wiphy,
+					struct net_device *dev, u32 mask,
+					const struct mesh_config *nconf)
+{
+	struct mesh_config *conf;
+	struct ieee80211_sub_if_data *sdata;
+	struct ieee80211_if_mesh *ifmsh;
+
+	sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	ifmsh = &sdata->u.mesh;
+
+	/* Set the config options which we are interested in setting */
+	conf = &(sdata->u.mesh.mshcfg);
+	if (_chg_mesh_attr(NL80211_MESHCONF_RETRY_TIMEOUT, mask))
+		conf->dot11MeshRetryTimeout = nconf->dot11MeshRetryTimeout;
+	if (_chg_mesh_attr(NL80211_MESHCONF_CONFIRM_TIMEOUT, mask))
+		conf->dot11MeshConfirmTimeout = nconf->dot11MeshConfirmTimeout;
+	if (_chg_mesh_attr(NL80211_MESHCONF_HOLDING_TIMEOUT, mask))
+		conf->dot11MeshHoldingTimeout = nconf->dot11MeshHoldingTimeout;
+	if (_chg_mesh_attr(NL80211_MESHCONF_MAX_PEER_LINKS, mask))
+		conf->dot11MeshMaxPeerLinks = nconf->dot11MeshMaxPeerLinks;
+	if (_chg_mesh_attr(NL80211_MESHCONF_MAX_RETRIES, mask))
+		conf->dot11MeshMaxRetries = nconf->dot11MeshMaxRetries;
+	if (_chg_mesh_attr(NL80211_MESHCONF_TTL, mask))
+		conf->dot11MeshTTL = nconf->dot11MeshTTL;
+	if (_chg_mesh_attr(NL80211_MESHCONF_ELEMENT_TTL, mask))
+		conf->dot11MeshTTL = nconf->element_ttl;
+	if (_chg_mesh_attr(NL80211_MESHCONF_AUTO_OPEN_PLINKS, mask))
+		conf->auto_open_plinks = nconf->auto_open_plinks;
+	if (_chg_mesh_attr(NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES, mask))
+		conf->dot11MeshHWMPmaxPREQretries =
+			nconf->dot11MeshHWMPmaxPREQretries;
+	if (_chg_mesh_attr(NL80211_MESHCONF_PATH_REFRESH_TIME, mask))
+		conf->path_refresh_time = nconf->path_refresh_time;
+	if (_chg_mesh_attr(NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT, mask))
+		conf->min_discovery_timeout = nconf->min_discovery_timeout;
+	if (_chg_mesh_attr(NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT, mask))
+		conf->dot11MeshHWMPactivePathTimeout =
+			nconf->dot11MeshHWMPactivePathTimeout;
+	if (_chg_mesh_attr(NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL, mask))
+		conf->dot11MeshHWMPpreqMinInterval =
+			nconf->dot11MeshHWMPpreqMinInterval;
+	if (_chg_mesh_attr(NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME,
+			   mask))
+		conf->dot11MeshHWMPnetDiameterTraversalTime =
+			nconf->dot11MeshHWMPnetDiameterTraversalTime;
+	if (_chg_mesh_attr(NL80211_MESHCONF_HWMP_ROOTMODE, mask)) {
+		conf->dot11MeshHWMPRootMode = nconf->dot11MeshHWMPRootMode;
+		mac80211_mesh_root_setup(ifmsh);
+	}
+	if (_chg_mesh_attr(NL80211_MESHCONF_GATE_ANNOUNCEMENTS, mask)) {
+		/* our current gate announcement implementation rides on root
+		 * announcements, so require this ifmsh to also be a root node
+		 * */
+		if (nconf->dot11MeshGateAnnouncementProtocol &&
+		    !conf->dot11MeshHWMPRootMode) {
+			conf->dot11MeshHWMPRootMode = 1;
+			mac80211_mesh_root_setup(ifmsh);
+		}
+		conf->dot11MeshGateAnnouncementProtocol =
+			nconf->dot11MeshGateAnnouncementProtocol;
+	}
+	if (_chg_mesh_attr(NL80211_MESHCONF_HWMP_RANN_INTERVAL, mask)) {
+		conf->dot11MeshHWMPRannInterval =
+			nconf->dot11MeshHWMPRannInterval;
+	}
+	return 0;
+}
+
+static int ieee80211_join_mesh(struct wiphy *wiphy, struct net_device *dev,
+			       const struct mesh_config *conf,
+			       const struct mesh_setup *setup)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+	int err;
+
+	memcpy(&ifmsh->mshcfg, conf, sizeof(struct mesh_config));
+	err = copy_mesh_setup(ifmsh, setup);
+	if (err)
+		return err;
+	mac80211_start_mesh(sdata);
+
+	return 0;
+}
+
+static int ieee80211_leave_mesh(struct wiphy *wiphy, struct net_device *dev)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	mac80211_stop_mesh(sdata);
+
+	return 0;
+}
+#endif
+
+static int ieee80211_change_bss(struct wiphy *wiphy,
+				struct net_device *dev,
+				struct bss_parameters *params)
+{
+	struct ieee80211_sub_if_data *sdata;
+	struct ieee80211_channel_state *chan_state;
+	u32 changed = 0;
+
+	sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	chan_state = ieee80211_get_channel_state(sdata->local, sdata);
+
+	if (params->use_cts_prot >= 0) {
+		sdata->vif.bss_conf.use_cts_prot = params->use_cts_prot;
+		changed |= BSS_CHANGED_ERP_CTS_PROT;
+	}
+	if (params->use_short_preamble >= 0) {
+		sdata->vif.bss_conf.use_short_preamble =
+			params->use_short_preamble;
+		changed |= BSS_CHANGED_ERP_PREAMBLE;
+	}
+
+	if (!sdata->vif.bss_conf.use_short_slot &&
+	    chan_state->conf.channel->band == NL80211_BAND_5GHZ) {
+		sdata->vif.bss_conf.use_short_slot = true;
+		changed |= BSS_CHANGED_ERP_SLOT;
+	}
+
+	if (params->use_short_slot_time >= 0) {
+		sdata->vif.bss_conf.use_short_slot =
+			params->use_short_slot_time;
+		changed |= BSS_CHANGED_ERP_SLOT;
+	}
+
+	if (params->basic_rates) {
+		int i, j;
+		u32 rates = 0;
+		struct ieee80211_supported_band *sband =
+			wiphy->bands[chan_state->oper_channel->band];
+
+		for (i = 0; i < params->basic_rates_len; i++) {
+			int rate = (params->basic_rates[i] & 0x7f) * 5;
+			for (j = 0; j < sband->n_bitrates; j++) {
+				if (sband->bitrates[j].bitrate == rate)
+					rates |= BIT(j);
+			}
+		}
+		sdata->vif.bss_conf.basic_rates = rates;
+		changed |= BSS_CHANGED_BASIC_RATES;
+	}
+
+	if (params->ap_isolate >= 0) {
+		if (params->ap_isolate)
+			sdata->flags |= IEEE80211_SDATA_DONT_BRIDGE_PACKETS;
+		else
+			sdata->flags &= ~IEEE80211_SDATA_DONT_BRIDGE_PACKETS;
+	}
+
+	if (params->ht_opmode >= 0) {
+		sdata->vif.bss_conf.ht_operation_mode =
+			(u16) params->ht_opmode;
+		changed |= BSS_CHANGED_HT;
+	}
+
+	mac80211_bss_info_change_notify(sdata, changed);
+
+	return 0;
+}
+
+static int ieee80211_set_txq_params(struct wiphy *wiphy,
+				    struct net_device *dev,
+				    struct ieee80211_txq_params *params)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_tx_queue_params p;
+
+	if (!local->ops->conf_tx)
+		return -EOPNOTSUPP;
+
+	if (local->hw.queues < IEEE80211_NUM_ACS)
+		return -EOPNOTSUPP;
+
+	memset(&p, 0, sizeof(p));
+	p.aifs = params->aifs;
+	p.cw_max = params->cwmax;
+	p.cw_min = params->cwmin;
+	p.txop = params->txop;
+
+	/*
+	 * Setting tx queue params disables u-apsd because it's only
+	 * called in master mode.
+	 */
+	p.uapsd = false;
+
+	if (params->ac >= local->hw.queues)
+		return -EINVAL;
+	sdata->tx_conf[params->ac] = p;
+	if (drv_conf_tx(local, sdata, params->ac, &p)) {
+		wiphy_debug(local->hw.wiphy,
+			    "failed to set TX queue parameters for queue %d\n",
+			    params->ac);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int ieee80211_suspend(struct wiphy *wiphy,
+			     struct cfg80211_wowlan *wowlan)
+{
+	return __mac80211_suspend(wiphy_priv(wiphy), wowlan);
+}
+
+static int ieee80211_resume(struct wiphy *wiphy)
+{
+	return __ieee80211_resume(wiphy_priv(wiphy));
+}
+#else
+#define ieee80211_suspend NULL
+#define ieee80211_resume NULL
+#endif
+
+static int ieee80211_scan(struct wiphy *wiphy,
+			  /*struct net_device *dev, */
+			  struct cfg80211_scan_request *req)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(req->wdev);
+
+	switch (ieee80211_vif_type_p2p(&sdata->vif)) {
+	case NL80211_IFTYPE_STATION:
+	case NL80211_IFTYPE_ADHOC:
+	case NL80211_IFTYPE_MESH_POINT:
+	case NL80211_IFTYPE_P2P_CLIENT:
+	case NL80211_IFTYPE_P2P_DEVICE:
+		break;
+	case NL80211_IFTYPE_P2P_GO:
+		if (sdata->local->ops->hw_scan)
+			break;
+		/*
+		 * FIXME: implement NoA while scanning in software,
+		 * for now fall through to allow scanning only when
+		 * beaconing hasn't been configured yet
+		 */
+	case NL80211_IFTYPE_AP:
+		if (sdata->u.ap.beacon &&
+		    (!(wiphy->features & NL80211_FEATURE_AP_SCAN) ||
+		     !(req->flags & NL80211_SCAN_FLAG_AP)))
+			return -EOPNOTSUPP;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return mac80211_request_scan(sdata, req);
+}
+
+static int
+ieee80211_sched_scan_start(struct wiphy *wiphy,
+			   struct net_device *dev,
+			   struct cfg80211_sched_scan_request *req)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	if (!sdata->local->ops->sched_scan_start)
+		return -EOPNOTSUPP;
+
+	return mac80211_request_sched_scan_start(sdata, req);
+}
+
+static int
+ieee80211_sched_scan_stop(struct wiphy *wiphy, struct net_device *dev,
+				   u64 reqid)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	if (!sdata->local->ops->sched_scan_stop)
+		return -EOPNOTSUPP;
+
+	return mac80211_request_sched_scan_stop(sdata);
+}
+
+static int ieee80211_auth(struct wiphy *wiphy, struct net_device *dev,
+			  struct cfg80211_auth_request *req)
+{
+	return mac80211_mgd_auth(IEEE80211_DEV_TO_SUB_IF(dev), req);
+}
+
+static int ieee80211_assoc(struct wiphy *wiphy, struct net_device *dev,
+			   struct cfg80211_assoc_request *req)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sdata);
+
+	switch (mac80211_get_channel_mode(local, sdata)) {
+	case CHAN_MODE_HOPPING:
+		return -EBUSY;
+	case CHAN_MODE_FIXED:
+		if (chan_state->oper_channel == req->bss->channel)
+			break;
+		return -EBUSY;
+	case CHAN_MODE_UNDEFINED:
+		break;
+	}
+
+	return mac80211_mgd_assoc(IEEE80211_DEV_TO_SUB_IF(dev), req);
+}
+
+static int ieee80211_deauth(struct wiphy *wiphy, struct net_device *dev,
+			    struct cfg80211_deauth_request *req)
+{
+	return mac80211_mgd_deauth(IEEE80211_DEV_TO_SUB_IF(dev), req);
+}
+
+static int ieee80211_disassoc(struct wiphy *wiphy, struct net_device *dev,
+			      struct cfg80211_disassoc_request *req)
+{
+	return mac80211_mgd_disassoc(IEEE80211_DEV_TO_SUB_IF(dev), req);
+}
+
+static int ieee80211_join_ibss(struct wiphy *wiphy, struct net_device *dev,
+			       struct cfg80211_ibss_params *params)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sdata);
+
+	switch (mac80211_get_channel_mode(local, sdata)) {
+	case CHAN_MODE_HOPPING:
+		return -EBUSY;
+	case CHAN_MODE_FIXED:
+		if (!params->channel_fixed)
+			return -EBUSY;
+		if (chan_state->oper_channel == params->chandef.chan)
+			break;
+		return -EBUSY;
+	case CHAN_MODE_UNDEFINED:
+		break;
+	}
+
+	return mac80211_ibss_join(sdata, params);
+}
+
+static int ieee80211_leave_ibss(struct wiphy *wiphy, struct net_device *dev)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	return mac80211_ibss_leave(sdata);
+}
+
+static int ieee80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+	struct ieee80211_sub_if_data *sdata;
+	int err;
+	u32 bss_changed = 0;
+
+	if (changed & WIPHY_PARAM_FRAG_THRESHOLD) {
+		err = drv_set_frag_threshold(local, wiphy->frag_threshold);
+
+		if (err)
+			return err;
+	}
+
+	if (changed & WIPHY_PARAM_COVERAGE_CLASS) {
+		err = drv_set_coverage_class(local, wiphy->coverage_class);
+
+		if (err)
+			return err;
+	}
+
+	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
+		if (!sdata)
+			continue;
+
+		if (changed & WIPHY_PARAM_RTS_THRESHOLD) {
+			err = drv_set_rts_threshold(local, sdata,
+							wiphy->rts_threshold);
+
+			if (err)
+				return err;
+		}
+
+		if ((changed & WIPHY_PARAM_RETRY_SHORT) ||
+			(changed & WIPHY_PARAM_RETRY_LONG)) {
+			sdata->vif.bss_conf.retry_short = wiphy->retry_short;
+			sdata->vif.bss_conf.retry_long = wiphy->retry_long;
+			bss_changed |= BSS_CHANGED_RETRY_LIMITS;
+		}
+
+		drv_bss_info_changed(local, sdata, &sdata->vif.bss_conf, bss_changed);
+	}
+
+	return 0;
+}
+
+/*
+static int ieee80211_set_tx_power(struct wiphy *wiphy,
+				  enum nl80211_tx_power_setting type, int mbm)
+*/
+static int ieee80211_set_tx_power(struct wiphy *wiphy,
+				  struct wireless_dev *wdev,
+				  enum nl80211_tx_power_setting type, int mbm)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+	struct ieee80211_sub_if_data *sdata;
+	struct ieee80211_channel *chan;
+	u32 changes = 0;
+
+	switch (type) {
+	case NL80211_TX_POWER_AUTOMATIC:
+		local->user_power_level = -1;
+		break;
+	case NL80211_TX_POWER_LIMITED:
+		if (mbm < 0 || (mbm % 100))
+			return -EOPNOTSUPP;
+		local->user_power_level = MBM_TO_DBM(mbm);
+		break;
+	case NL80211_TX_POWER_FIXED:
+		if (mbm < 0 || (mbm % 100))
+			return -EOPNOTSUPP;
+		/* TODO: move to cfg80211 when it knows the channel */
+		if (local->hw.flags & IEEE80211_HW_SUPPORTS_MULTI_CHANNEL) {
+			rcu_read_lock();
+			list_for_each_entry_rcu(sdata, &local->interfaces, list) {
+				chan = sdata->chan_state.conf.channel;
+				if (MBM_TO_DBM(mbm) > chan->max_power) {
+					rcu_read_unlock();
+					return -EINVAL;
+				}
+			}
+			rcu_read_unlock();
+		} else {
+			chan = local->chan_state.conf.channel;
+			if (MBM_TO_DBM(mbm) > chan->max_power)
+				return -EINVAL;
+		}
+		local->user_power_level = MBM_TO_DBM(mbm);
+		break;
+	}
+
+	mac80211_hw_config(local, changes);
+
+	return 0;
+}
+
+/*static int ieee80211_get_tx_power(struct wiphy *wiphy, int *dbm)*/
+static int ieee80211_get_tx_power(struct wiphy *wiphy,
+				  struct wireless_dev *wdev,
+				  int *dbm)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+
+	*dbm = local->hw.conf.power_level;
+
+	return 0;
+}
+
+static int ieee80211_set_wds_peer(struct wiphy *wiphy, struct net_device *dev,
+				  const u8 *addr)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	memcpy(&sdata->u.wds.remote_addr, addr, ETH_ALEN);
+
+	return 0;
+}
+
+static void ieee80211_rfkill_poll(struct wiphy *wiphy)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+
+	drv_rfkill_poll(local);
+}
+
+#ifdef CONFIG_NL80211_TESTMODE
+static int ieee80211_testmode_cmd(struct wiphy *wiphy, struct wireless_dev *wdev,
+								void *data, int len)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+
+	if (!local->ops->testmode_cmd)
+		return -EOPNOTSUPP;
+
+	return local->ops->testmode_cmd(&local->hw, data, len);
+}
+
+static int ieee80211_testmode_dump(struct wiphy *wiphy,
+				   struct sk_buff *skb,
+				   struct netlink_callback *cb,
+				   void *data, int len)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+
+	if (!local->ops->testmode_dump)
+		return -EOPNOTSUPP;
+
+	return local->ops->testmode_dump(&local->hw, skb, cb, data, len);
+}
+#endif
+
+int __mac80211_request_smps(struct ieee80211_sub_if_data *sdata,
+			     enum ieee80211_smps_mode smps_mode)
+{
+	const u8 *ap;
+	enum ieee80211_smps_mode old_req;
+	int err;
+
+	lockdep_assert_held(&sdata->u.mgd.mtx);
+
+	old_req = sdata->u.mgd.req_smps;
+	sdata->u.mgd.req_smps = smps_mode;
+
+	if (old_req == smps_mode &&
+	    smps_mode != IEEE80211_SMPS_AUTOMATIC)
+		return 0;
+
+	/*
+	 * If not associated, or current association is not an HT
+	 * association, there's no need to send an action frame.
+	 */
+	if (!sdata->u.mgd.associated ||
+	    sdata->vif.bss_conf.channel_type == NL80211_CHAN_NO_HT) {
+		mutex_lock(&sdata->local->iflist_mtx);
+		mac80211_recalc_smps(sdata->local);
+		mutex_unlock(&sdata->local->iflist_mtx);
+		return 0;
+	}
+
+	ap = sdata->u.mgd.associated->bssid;
+
+	if (smps_mode == IEEE80211_SMPS_AUTOMATIC) {
+		if (sdata->u.mgd.powersave)
+			smps_mode = IEEE80211_SMPS_DYNAMIC;
+		else
+			smps_mode = IEEE80211_SMPS_OFF;
+	}
+
+	/* send SM PS frame to AP */
+	err = mac80211_send_smps_action(sdata, smps_mode,
+					 ap, ap);
+	if (err)
+		sdata->u.mgd.req_smps = old_req;
+
+	return err;
+}
+
+static int ieee80211_set_power_mgmt(struct wiphy *wiphy, struct net_device *dev,
+				    bool enabled, int timeout)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);
+
+	if (sdata->vif.type != NL80211_IFTYPE_STATION)
+		return -EOPNOTSUPP;
+
+	if (!(local->hw.flags & IEEE80211_HW_SUPPORTS_PS))
+		return -EOPNOTSUPP;
+
+	if (enabled == sdata->u.mgd.powersave &&
+	    timeout == sdata->dynamic_ps_forced_timeout)
+		return 0;
+
+	sdata->u.mgd.powersave = enabled;
+	sdata->dynamic_ps_forced_timeout = timeout;
+
+	/* no change, but if automatic follow powersave */
+	mutex_lock(&sdata->u.mgd.mtx);
+	__mac80211_request_smps(sdata, sdata->u.mgd.req_smps);
+	mutex_unlock(&sdata->u.mgd.mtx);
+
+	if (local->hw.flags & IEEE80211_HW_SUPPORTS_DYNAMIC_PS)
+		mac80211_hw_config(local, IEEE80211_CONF_CHANGE_PS);
+
+	mac80211_recalc_ps(local, -1);
+
+	return 0;
+}
+
+#if 0
+static void ieee80211_update_p2p_ps(struct ieee80211_sub_if_data *sdata,
+				    struct cfg80211_p2p_ps *new_p2p_ps)
+{
+	struct ieee80211_bss_conf *conf = &sdata->vif.bss_conf;
+	struct cfg80211_p2p_ps *p2p_ps = &conf->p2p_ps;
+
+	if (new_p2p_ps->count != -1)
+		p2p_ps->count = new_p2p_ps->count;
+	if (new_p2p_ps->start != -1)
+		p2p_ps->start = new_p2p_ps->start;
+	if (new_p2p_ps->duration != -1)
+		p2p_ps->duration = new_p2p_ps->duration;
+	if (new_p2p_ps->interval != -1)
+		p2p_ps->interval = new_p2p_ps->interval;
+	if (new_p2p_ps->legacy_ps != -1)
+		p2p_ps->legacy_ps = new_p2p_ps->legacy_ps;
+	if (new_p2p_ps->opp_ps != -1)
+		p2p_ps->opp_ps = new_p2p_ps->opp_ps;
+	if (new_p2p_ps->ctwindow != -1)
+		p2p_ps->ctwindow = new_p2p_ps->ctwindow;
+	if (new_p2p_ps->index != -1)
+		p2p_ps->index = new_p2p_ps->index;
+
+}
+#endif
+
+#if 0
+static int ieee80211_set_p2p_power_mgmt(struct wiphy *wiphy,
+					struct net_device *dev,
+					struct cfg80211_p2p_ps *p2p_ps)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);
+
+	if (!sdata->vif.p2p)
+		return -EOPNOTSUPP;
+
+	if (!(local->hw.flags & IEEE80211_HW_SUPPORTS_P2P_PS))
+		return -EOPNOTSUPP;
+
+	ieee80211_update_p2p_ps(sdata, p2p_ps);
+	mac80211_bss_info_change_notify(sdata, BSS_CHANGED_P2P_PS);
+
+	return 0;
+}
+#endif
+
+static int ieee80211_set_cqm_rssi_config(struct wiphy *wiphy,
+					 struct net_device *dev,
+					 s32 rssi_thold, u32 rssi_hyst)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);
+	struct ieee80211_vif *vif = &sdata->vif;
+	struct ieee80211_bss_conf *bss_conf = &vif->bss_conf;
+
+	if (rssi_thold == bss_conf->cqm_rssi_thold &&
+	    rssi_hyst == bss_conf->cqm_rssi_hyst)
+		return 0;
+
+	bss_conf->cqm_rssi_thold = rssi_thold;
+	bss_conf->cqm_rssi_hyst = rssi_hyst;
+
+	if (!(local->hw.flags & IEEE80211_HW_SUPPORTS_CQM_RSSI)) {
+		if (sdata->vif.type != NL80211_IFTYPE_STATION)
+			return -EOPNOTSUPP;
+		return 0;
+	}
+
+	/* tell the driver upon association, unless already associated */
+	if (sdata->u.mgd.associated)
+		mac80211_bss_info_change_notify(sdata, BSS_CHANGED_CQM);
+
+	return 0;
+}
+
+#if 0
+static int ieee80211_set_cqm_beacon_miss_config(struct wiphy *wiphy,
+						struct net_device *dev,
+						u32 beacon_thold)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);
+	struct ieee80211_vif *vif = &sdata->vif;
+	struct ieee80211_bss_conf *bss_conf = &vif->bss_conf;
+
+	if (beacon_thold == bss_conf->cqm_beacon_miss_thold)
+		return 0;
+
+	bss_conf->cqm_beacon_miss_thold = beacon_thold;
+
+	if (!(local->hw.flags & IEEE80211_HW_SUPPORTS_CQM_BEACON_MISS)) {
+		if (sdata->vif.type != NL80211_IFTYPE_STATION)
+			return -EOPNOTSUPP;
+		return 0;
+	}
+
+	if (sdata->u.mgd.associated)
+		mac80211_bss_info_change_notify(sdata, BSS_CHANGED_CQM);
+
+	return 0;
+}
+
+static int ieee80211_set_cqm_tx_fail_config(struct wiphy *wiphy,
+					    struct net_device *dev,
+					    u32 tx_thold)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);
+	struct ieee80211_vif *vif = &sdata->vif;
+	struct ieee80211_bss_conf *bss_conf = &vif->bss_conf;
+
+	if (tx_thold == bss_conf->cqm_tx_fail_thold)
+		return 0;
+
+	bss_conf->cqm_tx_fail_thold = tx_thold;
+
+	if (!(local->hw.flags & IEEE80211_HW_SUPPORTS_CQM_TX_FAIL)) {
+		if (sdata->vif.type != NL80211_IFTYPE_STATION)
+			return -EOPNOTSUPP;
+		return 0;
+	}
+
+	if (sdata->u.mgd.associated)
+		mac80211_bss_info_change_notify(sdata, BSS_CHANGED_CQM);
+
+	return 0;
+}
+#endif
+
+static int ieee80211_set_bitrate_mask(struct wiphy *wiphy,
+				      struct net_device *dev,
+				      const u8 *addr,
+				      const struct cfg80211_bitrate_mask *mask)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);
+	int i, ret;
+
+	if (local->hw.flags & IEEE80211_HW_HAS_RATE_CONTROL) {
+		ret = drv_set_bitrate_mask(local, sdata, mask);
+		if (ret)
+			return ret;
+	}
+
+	for (i = 0; i < NUM_NL80211_BANDS; i++)
+		sdata->rc_rateidx_mask[i] = mask->control[i].legacy;
+
+	return 0;
+}
+
+static int ieee80211_start_roc_work(struct ieee80211_local *local,
+					struct net_device *dev,
+				    struct ieee80211_sub_if_data *sdata,
+				    struct ieee80211_channel *channel,
+				    /*enum nl80211_channel_type channel_type, */
+				    unsigned int duration, u64 *cookie,
+				    struct sk_buff *txskb)
+{
+	struct ieee80211_roc_work *roc, *tmp;
+	bool queued = false;
+	int ret;
+
+	lockdep_assert_held(&local->mtx);
+
+#if 0
+	if (local->use_chanctx && !local->ops->remain_on_channel)
+		return -EOPNOTSUPP;
+#endif
+
+	roc = kzalloc(sizeof(*roc), GFP_KERNEL);
+	if (!roc)
+		return -ENOMEM;
+
+	roc->hw_roc_dev = dev;
+	roc->chan = channel;
+	roc->duration = duration;
+	roc->req_duration = duration;
+	roc->frame = txskb;
+	roc->mgmt_tx_cookie = (unsigned long)txskb;
+	roc->sdata = sdata;
+	INIT_DELAYED_WORK(&roc->work, mac80211_sw_roc_work);
+	INIT_LIST_HEAD(&roc->dependents);
+
+	/* if there's one pending or we're scanning, queue this one */
+	if (!list_empty(&local->roc_list) || local->scanning)
+		goto out_check_combine;
+
+	/* if not HW assist, just queue & schedule work */
+	if (!local->ops->remain_on_channel) {
+		mac80211_queue_delayed_work(&local->hw, &roc->work, 0);
+		goto out_queue;
+	}
+
+	/* otherwise actually kick it off here (for error handling) */
+
+	/*
+	 * If the duration is zero, then the driver
+	 * wouldn't actually do anything. Set it to
+	 * 10 for now.
+	 *
+	 * TODO: cancel the off-channel operation
+	 *       when we get the SKB's TX status and
+	 *       the wait time was zero before.
+	 */
+	if (!duration)
+		duration = 100;
+
+	ret = drv_remain_on_channel(local, sdata, channel, NL80211_CHAN_NO_HT, duration,
+			(txskb ? roc->mgmt_tx_cookie : (local->roc_cookie_counter + 1)));
+	if (ret) {
+		kfree(roc);
+		return ret;
+	}
+	local->hw_roc_channel = channel;
+
+	roc->started = true;
+	goto out_queue;
+
+ out_check_combine:
+	list_for_each_entry(tmp, &local->roc_list, list) {
+		if (tmp->chan != channel || tmp->sdata != sdata)
+			continue;
+
+		/*
+		 * Extend this ROC if possible:
+		 *
+		 * If it hasn't started yet, just increase the duration
+		 * and add the new one to the list of dependents.
+		 */
+		if (!tmp->started) {
+			list_add_tail(&roc->list, &tmp->dependents);
+			tmp->duration = max(tmp->duration, roc->duration);
+			queued = true;
+			break;
+		}
+
+		/* If it has already started, it's more difficult ... */
+		if (local->ops->remain_on_channel) {
+			unsigned long j = jiffies;
+
+			/*
+			 * In the offloaded ROC case, if it hasn't begun, add
+			 * this new one to the dependent list to be handled
+			 * when the the master one begins. If it has begun,
+			 * check that there's still a minimum time left and
+			 * if so, start this one, transmitting the frame, but
+			 * add it to the list directly after this one with a
+			 * a reduced time so we'll ask the driver to execute
+			 * it right after finishing the previous one, in the
+			 * hope that it'll also be executed right afterwards,
+			 * effectively extending the old one.
+			 * If there's no minimum time left, just add it to the
+			 * normal list.
+			 */
+			if (!tmp->hw_begun) {
+				list_add_tail(&roc->list, &tmp->dependents);
+				queued = true;
+				break;
+			}
+
+			if (time_before(j + IEEE80211_ROC_MIN_LEFT,
+					tmp->hw_start_time +
+					msecs_to_jiffies(tmp->duration))) {
+				int new_dur;
+
+				mac80211_handle_roc_started(roc);
+
+				new_dur = roc->duration -
+					  jiffies_to_msecs(tmp->hw_start_time +
+							   msecs_to_jiffies(
+								tmp->duration) -
+							   j);
+
+				if (new_dur > 0) {
+					/* add right after tmp */
+					list_add(&roc->list, &tmp->list);
+				} else {
+					list_add_tail(&roc->list,
+						      &tmp->dependents);
+				}
+				queued = true;
+			}
+		} else if (del_timer_sync(&tmp->work.timer)) {
+			unsigned long new_end;
+
+			/*
+			 * In the software ROC case, cancel the timer, if
+			 * that fails then the finish work is already
+			 * queued/pending and thus we queue the new ROC
+			 * normally, if that succeeds then we can extend
+			 * the timer duration and TX the frame (if any.)
+			 */
+
+			list_add_tail(&roc->list, &tmp->dependents);
+			queued = true;
+
+			new_end = jiffies + msecs_to_jiffies(roc->duration);
+
+			/* ok, it was started & we canceled timer */
+			if (time_after(new_end, tmp->work.timer.expires))
+				mod_timer(&tmp->work.timer, new_end);
+			else
+				add_timer(&tmp->work.timer);
+
+			mac80211_handle_roc_started(roc);
+		}
+		break;
+	}
+
+ out_queue:
+	if (!queued)
+		list_add_tail(&roc->list, &local->roc_list);
+
+	/*
+	 * cookie is either the roc cookie (for normal roc)
+	 * or the SKB (for mgmt TX)
+	 */
+	if (!txskb) {
+		/* local->mtx protects this */
+		local->roc_cookie_counter++;
+		roc->cookie = local->roc_cookie_counter;
+		/* wow, you wrapped 64 bits ... more likely a bug */
+		if (WARN_ON(roc->cookie == 0)) {
+			roc->cookie = 1;
+			local->roc_cookie_counter++;
+		}
+		*cookie = roc->cookie;
+	} else {
+		*cookie = (unsigned long)txskb;
+	}
+
+	return 0;
+}
+
+/*
+static int ieee80211_remain_on_channel(struct wiphy *wiphy,
+				       struct net_device *dev,
+				       struct ieee80211_channel *chan,
+				       enum nl80211_channel_type channel_type,
+				       unsigned int duration,
+				       u64 *cookie)
+*/
+static int ieee80211_remain_on_channel(struct wiphy *wiphy,
+				       struct wireless_dev *wdev,
+				       struct ieee80211_channel *chan,
+				       unsigned int duration,
+				       u64 *cookie)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);
+	struct ieee80211_local *local = sdata->local;
+		int ret;
+
+		mutex_lock(&local->mtx);
+	ret = ieee80211_start_roc_work(local, sdata->dev, sdata, chan,
+				       duration, cookie, NULL);
+		mutex_unlock(&local->mtx);
+
+		return ret;
+	}
+
+static int ieee80211_cancel_roc(struct ieee80211_local *local,
+				u64 cookie, bool mgmt_tx)
+{
+	struct ieee80211_roc_work *roc, *tmp, *found = NULL;
+	int ret;
+
+	mutex_lock(&local->mtx);
+	list_for_each_entry_safe(roc, tmp, &local->roc_list, list) {
+		struct ieee80211_roc_work *dep, *tmp2;
+
+		list_for_each_entry_safe(dep, tmp2, &roc->dependents, list) {
+			if (!mgmt_tx && dep->cookie != cookie)
+				continue;
+			else if (mgmt_tx && dep->mgmt_tx_cookie != cookie)
+				continue;
+			/* found dependent item -- just remove it */
+			list_del(&dep->list);
+			mutex_unlock(&local->mtx);
+
+			mac80211_roc_notify_destroy(dep);
+			return 0;
+}
+
+		if (!mgmt_tx && roc->cookie != cookie)
+			continue;
+		else if (mgmt_tx && roc->mgmt_tx_cookie != cookie)
+			continue;
+
+		found = roc;
+		break;
+	}
+
+	if (!found) {
+		mutex_unlock(&local->mtx);
+		return -ENOENT;
+	}
+
+	/*
+	 * We found the item to cancel, so do that. Note that it
+	 * may have dependents, which we also cancel (and send
+	 * the expired signal for.) Not doing so would be quite
+	 * tricky here, but we may need to fix it later.
+	 */
+
+	if (local->ops->remain_on_channel) {
+		if (found->started) {
+	ret = drv_cancel_remain_on_channel(local);
+			if (WARN_ON_ONCE(ret)) {
+				mutex_unlock(&local->mtx);
+		return ret;
+			}
+			local->hw_roc_channel = NULL;
+		}
+
+		list_del(&found->list);
+
+		if (found->started)
+			mac80211_start_next_roc(local);
+		mutex_unlock(&local->mtx);
+
+		mac80211_roc_notify_destroy(found);
+	} else {
+		/* work may be pending so use it all the time */
+		found->abort = true;
+		mac80211_queue_delayed_work(&local->hw, &found->work, 0);
+
+		mutex_unlock(&local->mtx);
+
+		/* work will clean up etc */
+		flush_delayed_work(&found->work);
+	}
+
+	return 0;
+}
+static int ieee80211_cancel_remain_on_channel(struct wiphy *wiphy,
+					      struct wireless_dev *wdev,
+					      u64 cookie)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);
+	struct ieee80211_local *local = sdata->local;
+
+	return ieee80211_cancel_roc(local, cookie, false);
+}
+
+#if 0
+static int ieee80211_cancel_remain_on_channel(struct wiphy *wiphy,
+					      struct net_device *dev,
+					      u64 cookie)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_local *local = sdata->local;
+
+	return ieee80211_cancel_roc(local, cookie, false);
+}
+#endif
+
+/*
+static int ieee80211_mgmt_tx(struct wiphy *wiphy, struct net_device *dev,
+			     struct ieee80211_channel *chan, bool offchan,
+			     enum nl80211_channel_type channel_type,
+			     bool channel_type_valid, unsigned int wait,
+			     const u8 *buf, size_t len, bool no_cck,
+			     bool dont_wait_for_ack, u64 *cookie)
+*/
+static int ieee80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,
+					 struct cfg80211_mgmt_tx_params *params,
+					 u64 *cookie)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sdata);
+	struct sk_buff *skb;
+	struct sta_info *sta;
+	/* struct ieee80211_work *wk; */
+	const struct ieee80211_mgmt *mgmt = (void *)(params->buf);
+	u32 flags;
+	/*
+	u32 flags = IEEE80211_TX_INTFL_NL80211_FRAME_TX |
+			IEEE80211_TX_CTL_REQ_TX_STATUS;
+	*/
+	bool is_offchan = false;
+	int ret;
+	unsigned long j, rem = 0;
+	struct ieee80211_roc_work *roc = NULL;
+	if (params->dont_wait_for_ack)
+		flags = IEEE80211_TX_CTL_NO_ACK;
+	else
+		flags = IEEE80211_TX_INTFL_NL80211_FRAME_TX |
+			IEEE80211_TX_CTL_REQ_TX_STATUS;
+
+	/* Check that we are on the requested channel for transmission */
+	if (params->chan != chan_state->tmp_channel &&
+		params->chan != chan_state->oper_channel)
+		is_offchan = true;
+
+    /*
+	if (channel_type_valid &&
+		(channel_type != chan_state->tmp_channel_type &&
+		 channel_type != chan_state->_oper_channel_type))
+		 is_offchan = true;
+	*/
+
+	if (params->chan == local->hw_roc_channel) {
+		/* TODO: check channel type? */
+		is_offchan = false;
+		flags |= IEEE80211_TX_CTL_TX_OFFCHAN;
+	}
+
+	if (params->no_cck)
+		flags |= IEEE80211_TX_CTL_NO_CCK_RATE;
+
+	if (is_offchan && !params->offchan)
+		return -EBUSY;
+
+	switch (sdata->vif.type) {
+	case NL80211_IFTYPE_ADHOC:
+	case NL80211_IFTYPE_AP:
+	case NL80211_IFTYPE_AP_VLAN:
+	case NL80211_IFTYPE_P2P_GO:
+	case NL80211_IFTYPE_MESH_POINT:
+		if (!ieee80211_is_action(mgmt->frame_control) ||
+		    mgmt->u.action.category == WLAN_CATEGORY_PUBLIC)
+			break;
+		rcu_read_lock();
+		sta = xrmac_sta_info_get(sdata, mgmt->da);
+		rcu_read_unlock();
+		if (!sta)
+			return -ENOLINK;
+		break;
+	case NL80211_IFTYPE_STATION:
+	case NL80211_IFTYPE_P2P_CLIENT:
+	case NL80211_IFTYPE_P2P_DEVICE:
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	skb = dev_alloc_skb(local->hw.extra_tx_headroom + params->len);
+	if (!skb) {
+		return -ENOMEM;
+	}
+	skb_reserve(skb, local->hw.extra_tx_headroom);
+
+	memcpy(skb_put(skb, params->len), params->buf, params->len);
+
+	IEEE80211_SKB_CB(skb)->flags = flags;
+
+	if (flags & IEEE80211_TX_CTL_TX_OFFCHAN)
+		IEEE80211_SKB_CB(skb)->hw_queue =
+			local->hw.offchannel_tx_hw_queue;
+
+	skb->dev = sdata->dev;
+
+	mutex_lock(&local->mtx);
+	/*
+	 * Can transmit right away if the channel was the
+	 * right one and there's no wait involved... If a
+	 * wait is involved, we might otherwise not be on
+	 * the right channel for long enough!
+	 */
+	if (!list_empty(&local->roc_list)) {
+		roc = list_first_entry(&local->roc_list, struct ieee80211_roc_work,
+						list);
+		j = jiffies;
+		if (roc->started)
+			rem = jiffies_to_msecs(roc->hw_start_time + msecs_to_jiffies(roc->duration) - j);
+	}
+	/*if (!is_offchan && !wait && !sdata->vif.bss_conf.idle) {*/
+	if (!is_offchan && !ieee80211_is_probe_resp(mgmt->frame_control) &&
+			roc && roc->started && (rem < 20)) {
+		is_offchan = true;
+	}
+	mutex_unlock(&local->mtx);
+
+	if (!is_offchan) {
+		*cookie = (unsigned long) skb;
+		ieee80211_tx_skb(sdata, skb);
+		return 0;
+	}
+
+	mutex_lock(&local->mtx);
+
+	if (!params->wait)
+		params->wait = 100;
+	/* This will handle all kinds of coalescing and immediate TX */
+	ret = ieee80211_start_roc_work(local, sdata->dev, sdata, params->chan,
+					   params->wait, cookie, skb);
+	if (ret)
+		kfree_skb(skb);
+
+	mutex_unlock(&local->mtx);
+
+	return ret;
+}
+
+/*
+static int ieee80211_mgmt_tx_cancel_wait(struct wiphy *wiphy,
+					struct net_device *dev,
+					 u64 cookie)
+*/
+static int ieee80211_mgmt_tx_cancel_wait(struct wiphy *wiphy,
+					 struct wireless_dev *wdev,
+					 u64 cookie)
+{
+	/*struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);*/
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+
+	return ieee80211_cancel_roc(local, cookie, true);
+}
+
+static void ieee80211_mgmt_frame_register(struct wiphy *wiphy,
+					  struct wireless_dev *wdev,
+					  u16 frame_type, bool reg)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+	struct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);
+
+	if (frame_type != (IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_PROBE_REQ))
+		return;
+
+	if (reg)
+		sdata->req_filt_flags |= FIF_PROBE_REQ;
+	else
+		sdata->req_filt_flags &= ~FIF_PROBE_REQ;
+
+	mac80211_queue_work(&local->hw, &sdata->reconfig_filter);
+}
+
+static int ieee80211_set_antenna(struct wiphy *wiphy, u32 tx_ant, u32 rx_ant)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+
+	if (local->started)
+		return -EOPNOTSUPP;
+
+	return drv_set_antenna(local, tx_ant, rx_ant);
+}
+
+static int ieee80211_get_antenna(struct wiphy *wiphy, u32 *tx_ant, u32 *rx_ant)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+
+	return drv_get_antenna(local, tx_ant, rx_ant);
+}
+
+
+/* linux4.4 delete interface ieee80211_set_ringparam and ieee80211_get_ringparam */
+/*
+static int ieee80211_set_ringparam(struct wiphy *wiphy, u32 tx, u32 rx)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+
+	return drv_set_ringparam(local, tx, rx);
+}
+
+static void ieee80211_get_ringparam(struct wiphy *wiphy,
+				    u32 *tx, u32 *tx_max, u32 *rx, u32 *rx_max)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+
+	drv_get_ringparam(local, tx, tx_max, rx, rx_max);
+}
+*/
+
+#ifdef CONFIG_XRADIO_TESTMODE
+static int ieee80211_set_acm_up(struct wiphy *wiphy,
+				struct net_device *net_dev,
+				u8 enable_up, u8 update_up)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(net_dev);
+	struct ieee80211_local *local = sdata->local;
+	unsigned int access_category = 0;
+	switch (update_up) {
+	case 1:
+	case 2:
+		access_category |= BIT(1) | BIT(2); /* BK/- */
+		break;
+	case 4:
+	case 5:
+		access_category |= BIT(4) | BIT(5); /* CL/VI */
+		break;
+	case 6:
+	case 7:
+		access_category |= BIT(6) | BIT(7); /* VO/NC */
+		break;
+	default:
+		access_category |= BIT(0) | BIT(3); /* BE/EE */
+		break;
+	}
+
+	if (enable_up == 1)
+		local->wmm_admitted_ups |= access_category;
+	else
+		local->wmm_admitted_ups &= ~access_category;
+
+	return 0;
+}
+#endif /*CONFIG_XRADIO_TESTMODE*/
+static int ieee80211_set_rekey_data(struct wiphy *wiphy,
+				    struct net_device *dev,
+				    struct cfg80211_gtk_rekey_data *data)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	if (!local->ops->set_rekey_data)
+		return -EOPNOTSUPP;
+
+	drv_set_rekey_data(local, sdata, data);
+
+	return 0;
+}
+
+static void ieee80211_tdls_add_ext_capab(struct sk_buff *skb)
+{
+	u8 *pos = (void *)skb_put(skb, 7);
+
+	*pos++ = WLAN_EID_EXT_CAPABILITY;
+	*pos++ = 5; /* len */
+	*pos++ = 0x0;
+	*pos++ = 0x0;
+	*pos++ = 0x0;
+	*pos++ = 0x0;
+	*pos++ = WLAN_EXT_CAPA5_TDLS_ENABLED;
+}
+
+static u16 ieee80211_get_tdls_sta_capab(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sdata);
+	u16 capab;
+
+	capab = 0;
+	if (chan_state->oper_channel->band != NL80211_BAND_2GHZ)
+		return capab;
+
+	if (!(local->hw.flags & IEEE80211_HW_2GHZ_SHORT_SLOT_INCAPABLE))
+		capab |= WLAN_CAPABILITY_SHORT_SLOT_TIME;
+	if (!(local->hw.flags & IEEE80211_HW_2GHZ_SHORT_PREAMBLE_INCAPABLE))
+		capab |= WLAN_CAPABILITY_SHORT_PREAMBLE;
+
+	return capab;
+}
+
+static void ieee80211_tdls_add_link_ie(struct sk_buff *skb, const u8 *src_addr,
+				       const u8 *peer, u8 *bssid)
+{
+	struct ieee80211_tdls_lnkie *lnkid;
+
+	lnkid = (void *)skb_put(skb, sizeof(struct ieee80211_tdls_lnkie));
+
+	lnkid->ie_type = WLAN_EID_LINK_ID;
+	lnkid->ie_len = sizeof(struct ieee80211_tdls_lnkie) - 2;
+
+	memcpy(lnkid->bssid, bssid, ETH_ALEN);
+	memcpy(lnkid->init_sta, src_addr, ETH_ALEN);
+	memcpy(lnkid->resp_sta, peer, ETH_ALEN);
+}
+
+static int
+ieee80211_prep_tdls_encap_data(struct wiphy *wiphy, struct net_device *dev,
+			       const u8 *peer, u8 action_code, u8 dialog_token,
+			       u16 status_code, struct sk_buff *skb)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_tdls_data *tf;
+
+	tf = (void *)skb_put(skb, offsetof(struct ieee80211_tdls_data, u));
+
+	memcpy(tf->da, peer, ETH_ALEN);
+	memcpy(tf->sa, sdata->vif.addr, ETH_ALEN);
+	tf->ether_type = cpu_to_be16(ETH_P_TDLS);
+	tf->payload_type = WLAN_TDLS_SNAP_RFTYPE;
+
+	switch (action_code) {
+	case WLAN_TDLS_SETUP_REQUEST:
+		tf->category = WLAN_CATEGORY_TDLS;
+		tf->action_code = WLAN_TDLS_SETUP_REQUEST;
+
+		skb_put(skb, sizeof(tf->u.setup_req));
+		tf->u.setup_req.dialog_token = dialog_token;
+		tf->u.setup_req.capability =
+			cpu_to_le16(ieee80211_get_tdls_sta_capab(sdata));
+
+		mac80211_add_srates_ie(&sdata->vif, skb);
+		mac80211_add_ext_srates_ie(&sdata->vif, skb);
+		ieee80211_tdls_add_ext_capab(skb);
+		break;
+	case WLAN_TDLS_SETUP_RESPONSE:
+		tf->category = WLAN_CATEGORY_TDLS;
+		tf->action_code = WLAN_TDLS_SETUP_RESPONSE;
+
+		skb_put(skb, sizeof(tf->u.setup_resp));
+		tf->u.setup_resp.status_code = cpu_to_le16(status_code);
+		tf->u.setup_resp.dialog_token = dialog_token;
+		tf->u.setup_resp.capability =
+			cpu_to_le16(ieee80211_get_tdls_sta_capab(sdata));
+
+		mac80211_add_srates_ie(&sdata->vif, skb);
+		mac80211_add_ext_srates_ie(&sdata->vif, skb);
+		ieee80211_tdls_add_ext_capab(skb);
+		break;
+	case WLAN_TDLS_SETUP_CONFIRM:
+		tf->category = WLAN_CATEGORY_TDLS;
+		tf->action_code = WLAN_TDLS_SETUP_CONFIRM;
+
+		skb_put(skb, sizeof(tf->u.setup_cfm));
+		tf->u.setup_cfm.status_code = cpu_to_le16(status_code);
+		tf->u.setup_cfm.dialog_token = dialog_token;
+		break;
+	case WLAN_TDLS_TEARDOWN:
+		tf->category = WLAN_CATEGORY_TDLS;
+		tf->action_code = WLAN_TDLS_TEARDOWN;
+
+		skb_put(skb, sizeof(tf->u.teardown));
+		tf->u.teardown.reason_code = cpu_to_le16(status_code);
+		break;
+	case WLAN_TDLS_DISCOVERY_REQUEST:
+		tf->category = WLAN_CATEGORY_TDLS;
+		tf->action_code = WLAN_TDLS_DISCOVERY_REQUEST;
+
+		skb_put(skb, sizeof(tf->u.discover_req));
+		tf->u.discover_req.dialog_token = dialog_token;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int
+ieee80211_prep_tdls_direct(struct wiphy *wiphy, struct net_device *dev,
+			   const u8 *peer, u8 action_code, u8 dialog_token,
+			   u16 status_code, struct sk_buff *skb)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_mgmt *mgmt;
+
+	mgmt = (void *)skb_put(skb, 24);
+	memset(mgmt, 0, 24);
+	memcpy(mgmt->da, peer, ETH_ALEN);
+	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
+	memcpy(mgmt->bssid, sdata->u.mgd.bssid, ETH_ALEN);
+
+	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+					  IEEE80211_STYPE_ACTION);
+
+	switch (action_code) {
+	case WLAN_PUB_ACTION_TDLS_DISCOVER_RES:
+		skb_put(skb, 1 + sizeof(mgmt->u.action.u.tdls_discover_resp));
+		mgmt->u.action.category = WLAN_CATEGORY_PUBLIC;
+		mgmt->u.action.u.tdls_discover_resp.action_code =
+			WLAN_PUB_ACTION_TDLS_DISCOVER_RES;
+		mgmt->u.action.u.tdls_discover_resp.dialog_token =
+			dialog_token;
+		mgmt->u.action.u.tdls_discover_resp.capability =
+			cpu_to_le16(ieee80211_get_tdls_sta_capab(sdata));
+
+		mac80211_add_srates_ie(&sdata->vif, skb);
+		mac80211_add_ext_srates_ie(&sdata->vif, skb);
+		ieee80211_tdls_add_ext_capab(skb);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int ieee80211_tdls_mgmt(struct wiphy *wiphy, struct net_device *dev,
+			const u8 *peer, u8 action_code, u8 dialog_token,
+			u16 status_code, u32 peer_capability,
+			bool initiator, const u8 *extra_ies,
+			size_t extra_ies_len)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_tx_info *info;
+	struct sk_buff *skb = NULL;
+	bool send_direct;
+	int ret;
+
+	if (!(wiphy->flags & WIPHY_FLAG_SUPPORTS_TDLS))
+		return -ENOTSUPP;
+
+	/* make sure we are in managed mode, and associated */
+	if (sdata->vif.type != NL80211_IFTYPE_STATION ||
+	    !sdata->u.mgd.associated)
+		return -EINVAL;
+
+#ifdef CONFIG_XRMAC_VERBOSE_TDLS_DEBUG
+	printk(KERN_DEBUG "TDLS mgmt action %d peer %pM\n", action_code, peer);
+#endif
+
+	skb = dev_alloc_skb(local->hw.extra_tx_headroom +
+			    max(sizeof(struct ieee80211_mgmt),
+				sizeof(struct ieee80211_tdls_data)) +
+			    50 + /* supported rates */
+			    7 + /* ext capab */
+			    extra_ies_len +
+			    sizeof(struct ieee80211_tdls_lnkie));
+	if (!skb)
+		return -ENOMEM;
+
+	info = IEEE80211_SKB_CB(skb);
+	skb_reserve(skb, local->hw.extra_tx_headroom);
+
+	switch (action_code) {
+	case WLAN_TDLS_SETUP_REQUEST:
+	case WLAN_TDLS_SETUP_RESPONSE:
+	case WLAN_TDLS_SETUP_CONFIRM:
+	case WLAN_TDLS_TEARDOWN:
+	case WLAN_TDLS_DISCOVERY_REQUEST:
+		ret = ieee80211_prep_tdls_encap_data(wiphy, dev, peer,
+						     action_code, dialog_token,
+						     status_code, skb);
+		send_direct = false;
+		break;
+	case WLAN_PUB_ACTION_TDLS_DISCOVER_RES:
+		ret = ieee80211_prep_tdls_direct(wiphy, dev, peer, action_code,
+						 dialog_token, status_code,
+						 skb);
+		send_direct = true;
+		break;
+	default:
+		ret = -ENOTSUPP;
+		break;
+	}
+
+	if (ret < 0)
+		goto fail;
+
+	if (extra_ies_len)
+		memcpy(skb_put(skb, extra_ies_len), extra_ies, extra_ies_len);
+
+	/* the TDLS link IE is always added last */
+	switch (action_code) {
+	case WLAN_TDLS_SETUP_REQUEST:
+	case WLAN_TDLS_SETUP_CONFIRM:
+	case WLAN_TDLS_TEARDOWN:
+	case WLAN_TDLS_DISCOVERY_REQUEST:
+		/* we are the initiator */
+		ieee80211_tdls_add_link_ie(skb, sdata->vif.addr, peer,
+					   sdata->u.mgd.bssid);
+		break;
+	case WLAN_TDLS_SETUP_RESPONSE:
+	case WLAN_PUB_ACTION_TDLS_DISCOVER_RES:
+		/* we are the responder */
+		ieee80211_tdls_add_link_ie(skb, peer, sdata->vif.addr,
+					   sdata->u.mgd.bssid);
+		break;
+	default:
+		ret = -ENOTSUPP;
+		goto fail;
+	}
+
+	if (send_direct) {
+		ieee80211_tx_skb(sdata, skb);
+		return 0;
+	}
+
+	/*
+	 * According to 802.11z: Setup req/resp are sent in AC_BK, otherwise
+	 * we should default to AC_VI.
+	 */
+	switch (action_code) {
+	case WLAN_TDLS_SETUP_REQUEST:
+	case WLAN_TDLS_SETUP_RESPONSE:
+		skb_set_queue_mapping(skb, IEEE80211_AC_BK);
+		skb->priority = 2;
+		break;
+	default:
+		skb_set_queue_mapping(skb, IEEE80211_AC_VI);
+		skb->priority = 5;
+		break;
+	}
+
+	/* disable bottom halves when entering the Tx path */
+	local_bh_disable();
+	ret = mac80211_subif_start_xmit(skb, dev);
+	local_bh_enable();
+
+	return ret;
+
+fail:
+	dev_kfree_skb(skb);
+	return ret;
+}
+
+static int ieee80211_tdls_oper(struct wiphy *wiphy, struct net_device *dev,
+			       const u8 *peer, enum nl80211_tdls_operation oper)
+{
+	struct sta_info *sta;
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	if (!(wiphy->flags & WIPHY_FLAG_SUPPORTS_TDLS))
+		return -ENOTSUPP;
+
+	if (sdata->vif.type != NL80211_IFTYPE_STATION)
+		return -EINVAL;
+
+#ifdef CONFIG_XRMAC_VERBOSE_TDLS_DEBUG
+	printk(KERN_DEBUG "TDLS oper %d peer %pM\n", oper, peer);
+#endif
+
+	switch (oper) {
+	case NL80211_TDLS_ENABLE_LINK:
+		rcu_read_lock();
+		sta = xrmac_sta_info_get(sdata, peer);
+		if (!sta) {
+			rcu_read_unlock();
+			return -ENOLINK;
+		}
+
+		set_sta_flag(sta, WLAN_STA_TDLS_PEER_AUTH);
+		rcu_read_unlock();
+		break;
+	case NL80211_TDLS_DISABLE_LINK:
+		return xrmac_sta_info_destroy_addr(sdata, peer);
+	case NL80211_TDLS_TEARDOWN:
+	case NL80211_TDLS_SETUP:
+	case NL80211_TDLS_DISCOVERY_REQ:
+		/* We don't support in-driver setup/teardown/discovery */
+		return -ENOTSUPP;
+	default:
+		return -ENOTSUPP;
+	}
+
+	return 0;
+}
+
+#if 0
+static int ieee80211_set_data_filter(struct wiphy *wiphy,
+				      struct net_device *dev,
+				      void *data, int len)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	drv_set_data_filter(local, sdata, data, len);
+	return 0;
+}
+#endif
+
+struct cfg80211_ops xrmac_config_ops = {
+	.add_virtual_intf = ieee80211_add_iface,
+	.del_virtual_intf = ieee80211_del_iface,
+	.change_virtual_intf = ieee80211_change_iface,
+	.start_p2p_device = ieee80211_start_p2p_device,
+	.stop_p2p_device = ieee80211_stop_p2p_device,
+	.add_key = ieee80211_add_key,
+	.del_key = ieee80211_del_key,
+	.get_key = ieee80211_get_key,
+	.set_default_key = ieee80211_config_default_key,
+	.set_default_mgmt_key = ieee80211_config_default_mgmt_key,
+	.start_ap = ieee80211_start_ap,
+	.change_beacon = ieee80211_change_beacon,
+	.stop_ap = ieee80211_stop_ap,
+	.add_station = ieee80211_add_station,
+	.del_station = ieee80211_del_station,
+	.change_station = ieee80211_change_station,
+	.get_station = ieee80211_get_station,
+	.dump_station = ieee80211_dump_station,
+	.dump_survey = ieee80211_dump_survey,
+#ifdef CONFIG_XRMAC_MESH
+	.add_mpath = ieee80211_add_mpath,
+	.del_mpath = ieee80211_del_mpath,
+	.change_mpath = ieee80211_change_mpath,
+	.get_mpath = ieee80211_get_mpath,
+	.dump_mpath = ieee80211_dump_mpath,
+	.update_mesh_config = ieee80211_update_mesh_config,
+	.get_mesh_config = ieee80211_get_mesh_config,
+	.join_mesh = ieee80211_join_mesh,
+	.leave_mesh = ieee80211_leave_mesh,
+#endif
+	.change_bss = ieee80211_change_bss,
+	.set_txq_params = ieee80211_set_txq_params,
+	.set_monitor_channel = ieee80211_set_monitor_channel,
+	/*.set_channel = ieee80211_set_channel, */
+	.suspend = ieee80211_suspend,
+	.resume = ieee80211_resume,
+	.scan = ieee80211_scan,
+	.sched_scan_start = ieee80211_sched_scan_start,
+	.sched_scan_stop = ieee80211_sched_scan_stop,
+	.auth = ieee80211_auth,
+	.assoc = ieee80211_assoc,
+	.deauth = ieee80211_deauth,
+	.disassoc = ieee80211_disassoc,
+	.join_ibss = ieee80211_join_ibss,
+	.leave_ibss = ieee80211_leave_ibss,
+	.set_wiphy_params = ieee80211_set_wiphy_params,
+	.set_tx_power = ieee80211_set_tx_power,
+	.get_tx_power = ieee80211_get_tx_power,
+	.set_wds_peer = ieee80211_set_wds_peer,
+	.rfkill_poll = ieee80211_rfkill_poll,
+	CFG80211_TESTMODE_CMD(ieee80211_testmode_cmd)
+	CFG80211_TESTMODE_DUMP(ieee80211_testmode_dump)
+	.set_power_mgmt = ieee80211_set_power_mgmt,
+	.set_bitrate_mask = ieee80211_set_bitrate_mask,
+	.remain_on_channel = ieee80211_remain_on_channel,
+	.cancel_remain_on_channel = ieee80211_cancel_remain_on_channel,
+	.mgmt_tx = ieee80211_mgmt_tx,
+	.mgmt_tx_cancel_wait = ieee80211_mgmt_tx_cancel_wait,
+	.set_cqm_rssi_config = ieee80211_set_cqm_rssi_config,
+	/*
+	.set_cqm_beacon_miss_config = ieee80211_set_cqm_beacon_miss_config,
+	.set_cqm_tx_fail_config = ieee80211_set_cqm_tx_fail_config,
+	*/
+	.mgmt_frame_register = ieee80211_mgmt_frame_register,
+	.set_antenna = ieee80211_set_antenna,
+	.get_antenna = ieee80211_get_antenna,
+	.set_rekey_data = ieee80211_set_rekey_data,
+	.tdls_oper = ieee80211_tdls_oper,
+	.tdls_mgmt = ieee80211_tdls_mgmt,
+	/*
+	.set_p2p_power_mgmt = ieee80211_set_p2p_power_mgmt,
+	.set_data_filter = ieee80211_set_data_filter,
+#ifdef CONFIG_XRADIO_TESTMODE
+	.update_acm_up = ieee80211_set_acm_up,
+#endif  *//*CONFIG_XRADIO_TESTMODE*/
+};
diff -Naurp a/drivers/net/wireless/xr829/umac/cfg.h b/drivers/net/wireless/xr829/umac/cfg.h
--- a/drivers/net/wireless/xr829/umac/cfg.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/cfg.h	2022-08-27 01:22:42.934539786 +0300
@@ -0,0 +1,9 @@
+/*
+ * mac80211 configuration hooks for cfg80211
+ */
+#ifndef __CFG_H
+#define __CFG_H
+
+extern struct cfg80211_ops xrmac_config_ops;
+
+#endif /* __CFG_H */
diff -Naurp a/drivers/net/wireless/xr829/umac/chan.c b/drivers/net/wireless/xr829/umac/chan.c
--- a/drivers/net/wireless/xr829/umac/chan.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/chan.c	2022-08-27 01:22:42.934539786 +0300
@@ -0,0 +1,145 @@
+/*
+ * mac80211 - channel management
+ */
+
+#include <uapi/linux/nl80211.h>
+#include "ieee80211_i.h"
+
+static enum ieee80211_chan_mode
+__mac80211_get_channel_mode(struct ieee80211_local *local,
+			     struct ieee80211_sub_if_data *ignore)
+{
+	struct ieee80211_sub_if_data *sdata;
+
+	lockdep_assert_held(&local->iflist_mtx);
+
+	list_for_each_entry(sdata, &local->interfaces, list) {
+		if (sdata == ignore)
+			continue;
+
+		if (!ieee80211_sdata_running(sdata))
+			continue;
+
+		if (sdata->vif.type == NL80211_IFTYPE_MONITOR)
+			continue;
+
+		if (sdata->vif.type == NL80211_IFTYPE_P2P_DEVICE)
+			continue;
+
+		if (sdata->vif.type == NL80211_IFTYPE_STATION &&
+		    !sdata->u.mgd.associated)
+			continue;
+
+		if (sdata->vif.type == NL80211_IFTYPE_ADHOC) {
+			if (!sdata->u.ibss.ssid_len)
+				continue;
+			if (!sdata->u.ibss.fixed_channel)
+				return CHAN_MODE_HOPPING;
+		}
+
+		if (sdata->vif.type == NL80211_IFTYPE_AP &&
+		    !sdata->u.ap.beacon)
+			continue;
+
+		return CHAN_MODE_FIXED;
+	}
+
+	return CHAN_MODE_UNDEFINED;
+}
+
+enum ieee80211_chan_mode
+mac80211_get_channel_mode(struct ieee80211_local *local,
+			   struct ieee80211_sub_if_data *ignore)
+{
+	enum ieee80211_chan_mode mode;
+
+	mutex_lock(&local->iflist_mtx);
+	mode = __mac80211_get_channel_mode(local, ignore);
+	mutex_unlock(&local->iflist_mtx);
+
+	return mode;
+}
+
+bool mac80211_set_channel_type(struct ieee80211_local *local,
+				struct ieee80211_sub_if_data *sdata,
+				enum nl80211_channel_type chantype)
+{
+	struct ieee80211_channel_state *chan_state;
+	struct ieee80211_sub_if_data *tmp;
+	enum nl80211_channel_type superchan = NL80211_CHAN_NO_HT;
+	bool result;
+
+	mutex_lock(&local->iflist_mtx);
+
+	if (local->hw.flags & IEEE80211_HW_SUPPORTS_MULTI_CHANNEL) {
+		/* XXX: COMBO: TBD - is this ok? */
+		BUG_ON(!sdata);
+		sdata->chan_state._oper_channel_type = chantype;
+		sdata->vif.bss_conf.channel_type = chantype;
+		result = true;
+		goto out;
+	}
+
+	chan_state = ieee80211_get_channel_state(local, sdata);
+
+	list_for_each_entry(tmp, &local->interfaces, list) {
+		if (tmp == sdata)
+			continue;
+
+		if (!ieee80211_sdata_running(tmp))
+			continue;
+
+		switch (tmp->vif.bss_conf.channel_type) {
+		case NL80211_CHAN_NO_HT:
+		case NL80211_CHAN_HT20:
+			if (superchan > tmp->vif.bss_conf.channel_type)
+				break;
+
+			superchan = tmp->vif.bss_conf.channel_type;
+			break;
+		case NL80211_CHAN_HT40PLUS:
+			WARN_ON(superchan == NL80211_CHAN_HT40MINUS);
+			superchan = NL80211_CHAN_HT40PLUS;
+			break;
+		case NL80211_CHAN_HT40MINUS:
+			WARN_ON(superchan == NL80211_CHAN_HT40PLUS);
+			superchan = NL80211_CHAN_HT40MINUS;
+			break;
+		}
+	}
+
+	switch (superchan) {
+	case NL80211_CHAN_NO_HT:
+	case NL80211_CHAN_HT20:
+		/*
+		 * allow any change that doesn't go to no-HT
+		 * (if it already is no-HT no change is needed)
+		 */
+		if (chantype == NL80211_CHAN_NO_HT)
+			break;
+		superchan = chantype;
+		break;
+	case NL80211_CHAN_HT40PLUS:
+	case NL80211_CHAN_HT40MINUS:
+		/* allow smaller bandwidth and same */
+		if (chantype == NL80211_CHAN_NO_HT)
+			break;
+		if (chantype == NL80211_CHAN_HT20)
+			break;
+		if (superchan == chantype)
+			break;
+		result = false;
+		goto out;
+	}
+
+	chan_state->_oper_channel_type = superchan;
+
+	if (sdata)
+		sdata->vif.bss_conf.channel_type = chantype;
+
+	result = true;
+ out:
+	mutex_unlock(&local->iflist_mtx);
+
+	return result;
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/debugfs.c b/drivers/net/wireless/xr829/umac/debugfs.c
--- a/drivers/net/wireless/xr829/umac/debugfs.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/debugfs.c	2022-08-27 01:22:42.934539786 +0300
@@ -0,0 +1,533 @@
+
+/*
+ * mac80211 debugfs for wireless PHYs
+ *
+ * Copyright 2007	Johannes Berg <johannes@sipsolutions.net>
+ *
+ * GPLv2
+ *
+ */
+
+#include <linux/debugfs.h>
+#include <linux/rtnetlink.h>
+#include "ieee80211_i.h"
+#include "driver-ops.h"
+#include "rate.h"
+#include "debugfs.h"
+
+
+int mac80211_open_file_generic(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+#define DEBUGFS_FORMAT_BUFFER_SIZE 100
+
+int xrmac_format_buffer(char __user *userbuf, size_t count,
+				  loff_t *ppos, char *fmt, ...)
+{
+	va_list args;
+	char buf[DEBUGFS_FORMAT_BUFFER_SIZE];
+	int res;
+
+	va_start(args, fmt);
+	res = vscnprintf(buf, sizeof(buf), fmt, args);
+	va_end(args);
+
+	return simple_read_from_buffer(userbuf, count, ppos, buf, res);
+}
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+
+#define DEBUGFS_READONLY_FILE_FN(name, fmt, value...)			\
+static ssize_t name## _read(struct file *file, char __user *userbuf,	\
+			    size_t count, loff_t *ppos)			\
+{									\
+	struct ieee80211_local *local = file->private_data;		\
+									\
+	return xrmac_format_buffer(userbuf, count, ppos, 		\
+				      fmt "\n", ##value);		\
+}
+
+#define DEBUGFS_READONLY_FILE_OPS(name)			\
+static const struct file_operations name## _ops = {			\
+	.read = name## _read,						\
+	.open = mac80211_open_file_generic,				\
+	.llseek = generic_file_llseek,					\
+};
+
+#define DEBUGFS_ADD(name)						\
+	debugfs_create_file(#name, 0400, phyd, local, &name## _ops);
+
+#define DEBUGFS_ADD_MODE(name, mode)					\
+	debugfs_create_file(#name, mode, phyd, local, &name## _ops);
+
+
+DEBUGFS_READONLY_FILE_FN(user_power, "%d", local->user_power_level);
+DEBUGFS_READONLY_FILE_OPS(user_power);
+
+DEBUGFS_READONLY_FILE_FN(power, "%d",
+		      local->hw.conf.power_level);
+DEBUGFS_READONLY_FILE_OPS(power);
+
+DEBUGFS_READONLY_FILE_FN(frequency, "%d",
+		      local->hw.conf.chan_conf->channel->center_freq);
+DEBUGFS_READONLY_FILE_OPS(frequency);
+
+DEBUGFS_READONLY_FILE_FN(total_ps_buffered, "%d",
+		      local->total_ps_buffered);
+DEBUGFS_READONLY_FILE_OPS(total_ps_buffered);
+
+DEBUGFS_READONLY_FILE_FN(wep_iv, "%#08x",
+		      local->wep_iv & 0xffffff);
+DEBUGFS_READONLY_FILE_OPS(wep_iv);
+
+
+DEBUGFS_READONLY_FILE_FN(rate_ctrl_alg, "%s",
+	local->rate_ctrl ? local->rate_ctrl->ops->name : "hw/driver");
+DEBUGFS_READONLY_FILE_OPS(rate_ctrl_alg);
+
+static ssize_t reset_write(struct file *file, const char __user *user_buf,
+			   size_t count, loff_t *ppos)
+{
+	struct ieee80211_local *local = file->private_data;
+
+	rtnl_lock();
+	__mac80211_suspend(&local->hw, NULL);
+	__ieee80211_resume(&local->hw);
+	rtnl_unlock();
+
+	return count;
+}
+
+static const struct file_operations reset_ops = {
+	.write = reset_write,
+	.open = mac80211_open_file_generic,
+	.llseek = noop_llseek,
+};
+
+static ssize_t noack_read(struct file *file, char __user *user_buf,
+			  size_t count, loff_t *ppos)
+{
+	struct ieee80211_local *local = file->private_data;
+
+	return xrmac_format_buffer(user_buf, count, ppos, "%d\n",
+				      local->wifi_wme_noack_test);
+}
+
+static ssize_t noack_write(struct file *file,
+			   const char __user *user_buf,
+			   size_t count, loff_t *ppos)
+{
+	struct ieee80211_local *local = file->private_data;
+	char buf[10];
+	size_t len;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+	buf[len] = '\0';
+
+	local->wifi_wme_noack_test = !!simple_strtoul(buf, NULL, 0);
+
+	return count;
+}
+
+static const struct file_operations noack_ops = {
+	.read = noack_read,
+	.write = noack_write,
+	.open = mac80211_open_file_generic,
+	.llseek = default_llseek,
+};
+
+#ifdef USE_RSSI_SMOOTH
+static ssize_t rssi_smooth_read(struct file *file, char __user *user_buf,
+			  size_t count, loff_t *ppos)
+{
+	struct ieee80211_local *local = file->private_data;
+
+	return xrmac_format_buffer(user_buf, count, ppos, "%d\n",
+				      local->dis_rssi_smooth);
+}
+
+static ssize_t rssi_smooth_write(struct file *file,
+			   const char __user *user_buf,
+			   size_t count, loff_t *ppos)
+{
+	struct ieee80211_local *local = file->private_data;
+	char buf[10];
+	size_t len;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+	buf[len] = '\0';
+
+	local->dis_rssi_smooth = !!simple_strtoul(buf, NULL, 0);
+
+	return count;
+}
+
+static const struct file_operations dis_rssi_smooth_ops = {
+	.read = rssi_smooth_read,
+	.write = rssi_smooth_write,
+	.open = mac80211_open_file_generic,
+	.llseek = default_llseek,
+};
+#endif
+
+
+
+static ssize_t uapsd_queues_read(struct file *file, char __user *user_buf,
+				 size_t count, loff_t *ppos)
+{
+	struct ieee80211_local *local = file->private_data;
+	return xrmac_format_buffer(user_buf, count, ppos, "0x%x\n",
+				      local->uapsd_queues);
+}
+
+static ssize_t uapsd_queues_write(struct file *file,
+				  const char __user *user_buf,
+				  size_t count, loff_t *ppos)
+{
+	struct ieee80211_local *local = file->private_data;
+	u8 val;
+	int ret;
+
+	ret = kstrtou8_from_user(user_buf, count, 0, &val);
+	if (ret)
+		return ret;
+
+	if (val & ~IEEE80211_WMM_IE_STA_QOSINFO_AC_MASK)
+		return -ERANGE;
+
+	local->uapsd_queues = val;
+
+	return count;
+}
+
+static const struct file_operations uapsd_queues_ops = {
+	.read = uapsd_queues_read,
+	.write = uapsd_queues_write,
+	.open = mac80211_open_file_generic,
+	.llseek = default_llseek,
+};
+
+static ssize_t uapsd_max_sp_len_read(struct file *file, char __user *user_buf,
+				     size_t count, loff_t *ppos)
+{
+	struct ieee80211_local *local = file->private_data;
+
+	return xrmac_format_buffer(user_buf, count, ppos, "0x%x\n",
+				      local->uapsd_max_sp_len);
+}
+
+static ssize_t uapsd_max_sp_len_write(struct file *file,
+				      const char __user *user_buf,
+				      size_t count, loff_t *ppos)
+{
+	struct ieee80211_local *local = file->private_data;
+	unsigned long val;
+	char buf[10];
+	size_t len;
+	int ret;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+	buf[len] = '\0';
+
+	ret = kstrtoul(buf, 0, &val);
+
+	if (ret)
+		return -EINVAL;
+
+	if (val & ~IEEE80211_WMM_IE_STA_QOSINFO_SP_MASK)
+		return -ERANGE;
+
+	local->uapsd_max_sp_len = val;
+
+	return count;
+}
+
+static const struct file_operations uapsd_max_sp_len_ops = {
+	.read = uapsd_max_sp_len_read,
+	.write = uapsd_max_sp_len_write,
+	.open = mac80211_open_file_generic,
+	.llseek = default_llseek,
+};
+
+static ssize_t channel_type_read(struct file *file, char __user *user_buf,
+		       size_t count, loff_t *ppos)
+{
+	struct ieee80211_local *local = file->private_data;
+	struct ieee80211_channel_state *chan_state;
+	const char *buf;
+
+	/* XXX: COMBO: Todo, later*/
+	if (WARN(local->hw.flags & IEEE80211_HW_SUPPORTS_MULTI_CHANNEL,
+			"Cannot read channel type due to multi-channel operation. ")) {
+		buf = "notsupp";
+		return simple_read_from_buffer(user_buf, count, ppos, buf, strlen(buf));
+	}
+
+	chan_state = ieee80211_get_channel_state(local, NULL);
+
+	switch (chan_state->conf.channel_type) {
+	case NL80211_CHAN_NO_HT:
+		buf = "no ht\n";
+		break;
+	case NL80211_CHAN_HT20:
+		buf = "ht20\n";
+		break;
+	case NL80211_CHAN_HT40MINUS:
+		buf = "ht40-\n";
+		break;
+	case NL80211_CHAN_HT40PLUS:
+		buf = "ht40+\n";
+		break;
+	default:
+		buf = "???";
+		break;
+	}
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, strlen(buf));
+}
+
+static ssize_t hwflags_read(struct file *file, char __user *user_buf,
+			    size_t count, loff_t *ppos)
+{
+	struct ieee80211_local *local = file->private_data;
+	int mxln = 500;
+	ssize_t rv;
+	char *buf = kzalloc(mxln, GFP_KERNEL);
+	int sf = 0; /* how many written so far */
+
+	if (!buf)
+		return 0;
+
+	sf += snprintf(buf, mxln - sf, "0x%x\n", local->hw.flags);
+	if (local->hw.flags & IEEE80211_HW_HAS_RATE_CONTROL)
+		sf += snprintf(buf + sf, mxln - sf, "HAS_RATE_CONTROL\n");
+	if (local->hw.flags & IEEE80211_HW_RX_INCLUDES_FCS)
+		sf += snprintf(buf + sf, mxln - sf, "RX_INCLUDES_FCS\n");
+	if (local->hw.flags & IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING)
+		sf += snprintf(buf + sf, mxln - sf,
+			       "HOST_BCAST_PS_BUFFERING\n");
+	if (local->hw.flags & IEEE80211_HW_2GHZ_SHORT_SLOT_INCAPABLE)
+		sf += snprintf(buf + sf, mxln - sf,
+			       "2GHZ_SHORT_SLOT_INCAPABLE\n");
+	if (local->hw.flags & IEEE80211_HW_2GHZ_SHORT_PREAMBLE_INCAPABLE)
+		sf += snprintf(buf + sf, mxln - sf,
+			       "2GHZ_SHORT_PREAMBLE_INCAPABLE\n");
+	if (local->hw.flags & IEEE80211_HW_SIGNAL_UNSPEC)
+		sf += snprintf(buf + sf, mxln - sf, "SIGNAL_UNSPEC\n");
+	if (local->hw.flags & IEEE80211_HW_SIGNAL_DBM)
+		sf += snprintf(buf + sf, mxln - sf, "SIGNAL_DBM\n");
+	if (local->hw.flags & IEEE80211_HW_NEED_DTIM_PERIOD)
+		sf += snprintf(buf + sf, mxln - sf, "NEED_DTIM_PERIOD\n");
+	if (local->hw.flags & IEEE80211_HW_SPECTRUM_MGMT)
+		sf += snprintf(buf + sf, mxln - sf, "SPECTRUM_MGMT\n");
+	if (local->hw.flags & IEEE80211_HW_AMPDU_AGGREGATION)
+		sf += snprintf(buf + sf, mxln - sf, "AMPDU_AGGREGATION\n");
+	if (local->hw.flags & IEEE80211_HW_SUPPORTS_PS)
+		sf += snprintf(buf + sf, mxln - sf, "SUPPORTS_PS\n");
+	if (local->hw.flags & IEEE80211_HW_PS_NULLFUNC_STACK)
+		sf += snprintf(buf + sf, mxln - sf, "PS_NULLFUNC_STACK\n");
+	if (local->hw.flags & IEEE80211_HW_SUPPORTS_DYNAMIC_PS)
+		sf += snprintf(buf + sf, mxln - sf, "SUPPORTS_DYNAMIC_PS\n");
+	if (local->hw.flags & IEEE80211_HW_MFP_CAPABLE)
+		sf += snprintf(buf + sf, mxln - sf, "MFP_CAPABLE\n");
+	if (local->hw.flags & IEEE80211_HW_BEACON_FILTER)
+		sf += snprintf(buf + sf, mxln - sf, "BEACON_FILTER\n");
+	if (local->hw.flags & IEEE80211_HW_SUPPORTS_STATIC_SMPS)
+		sf += snprintf(buf + sf, mxln - sf, "SUPPORTS_STATIC_SMPS\n");
+	if (local->hw.flags & IEEE80211_HW_SUPPORTS_DYNAMIC_SMPS)
+		sf += snprintf(buf + sf, mxln - sf, "SUPPORTS_DYNAMIC_SMPS\n");
+	if (local->hw.flags & IEEE80211_HW_SUPPORTS_UAPSD)
+		sf += snprintf(buf + sf, mxln - sf, "SUPPORTS_UAPSD\n");
+	if (local->hw.flags & IEEE80211_HW_REPORTS_TX_ACK_STATUS)
+		sf += snprintf(buf + sf, mxln - sf, "REPORTS_TX_ACK_STATUS\n");
+	if (local->hw.flags & IEEE80211_HW_CONNECTION_MONITOR)
+		sf += snprintf(buf + sf, mxln - sf, "CONNECTION_MONITOR\n");
+	if (local->hw.flags & IEEE80211_HW_SUPPORTS_CQM_RSSI)
+		sf += snprintf(buf + sf, mxln - sf, "SUPPORTS_CQM_RSSI\n");
+	if (local->hw.flags & IEEE80211_HW_SUPPORTS_PER_STA_GTK)
+		sf += snprintf(buf + sf, mxln - sf, "SUPPORTS_PER_STA_GTK\n");
+	if (local->hw.flags & IEEE80211_HW_AP_LINK_PS)
+		sf += snprintf(buf + sf, mxln - sf, "AP_LINK_PS\n");
+	if (local->hw.flags & IEEE80211_HW_TX_AMPDU_SETUP_IN_HW)
+		sf += snprintf(buf + sf, mxln - sf, "TX_AMPDU_SETUP_IN_HW\n");
+
+	rv = simple_read_from_buffer(user_buf, count, ppos, buf, strlen(buf));
+	kfree(buf);
+	return rv;
+}
+
+static ssize_t queues_read(struct file *file, char __user *user_buf,
+			   size_t count, loff_t *ppos)
+{
+	struct ieee80211_local *local = file->private_data;
+	unsigned long flags;
+	char buf[IEEE80211_MAX_QUEUES * 20];
+	int q, res = 0;
+
+	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
+	for (q = 0; q < local->hw.queues; q++)
+		res += sprintf(buf + res, "%02d: %#.8lx/%d\n", q,
+				local->queue_stop_reasons[q],
+				skb_queue_len(&local->pending[q]));
+	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, res);
+}
+
+DEBUGFS_READONLY_FILE_OPS(hwflags);
+DEBUGFS_READONLY_FILE_OPS(channel_type);
+DEBUGFS_READONLY_FILE_OPS(queues);
+
+/* statistics stuff */
+
+static ssize_t format_devstat_counter(struct ieee80211_local *local,
+	char __user *userbuf,
+	size_t count, loff_t *ppos,
+	int (*printvalue)(struct ieee80211_low_level_stats *stats, char *buf,
+			  int buflen))
+{
+	struct ieee80211_low_level_stats stats;
+	char buf[20];
+	int res;
+
+	rtnl_lock();
+	res = drv_get_stats(local, &stats);
+	rtnl_unlock();
+	if (res)
+		return res;
+	res = printvalue(&stats, buf, sizeof(buf));
+	return simple_read_from_buffer(userbuf, count, ppos, buf, res);
+}
+
+#define DEBUGFS_DEVSTATS_FILE(name)					\
+static int print_devstats_##name(struct ieee80211_low_level_stats *stats, \
+				 char *buf, int buflen)			\
+{									\
+	return scnprintf(buf, buflen, "%u\n", stats->name);		\
+}									\
+static ssize_t stats_ ##name## _read(struct file *file,			\
+				     char __user *userbuf,		\
+				     size_t count, loff_t *ppos)	\
+{									\
+	return format_devstat_counter(file->private_data,		\
+				      userbuf,				\
+				      count,				\
+				      ppos,				\
+				      print_devstats_##name);		\
+}									\
+									\
+static const struct file_operations stats_ ##name## _ops = {		\
+	.read = stats_ ##name## _read,					\
+	.open = mac80211_open_file_generic,				\
+	.llseek = generic_file_llseek,					\
+};
+
+#define DEBUGFS_STATS_ADD(name, field)					\
+	debugfs_create_u32(#name, 0400, statsd, (u32 *) &field);
+#define DEBUGFS_DEVSTATS_ADD(name)					\
+	debugfs_create_file(#name, 0400, statsd, local, &stats_ ##name## _ops);
+
+DEBUGFS_DEVSTATS_FILE(dot11ACKFailureCount);
+DEBUGFS_DEVSTATS_FILE(dot11RTSFailureCount);
+DEBUGFS_DEVSTATS_FILE(dot11FCSErrorCount);
+DEBUGFS_DEVSTATS_FILE(dot11RTSSuccessCount);
+
+void xrmac_debugfs_hw_add(struct ieee80211_local *local)
+{
+	struct dentry *phyd = local->hw.wiphy->debugfsdir;
+	struct dentry *statsd;
+
+	if (!phyd)
+		return;
+
+	local->debugfs.keys = debugfs_create_dir("keys", phyd);
+
+	DEBUGFS_ADD(frequency);
+	DEBUGFS_ADD(total_ps_buffered);
+	DEBUGFS_ADD(wep_iv);
+	DEBUGFS_ADD(queues);
+	DEBUGFS_ADD_MODE(reset, 0200);
+	DEBUGFS_ADD(noack);
+	DEBUGFS_ADD(uapsd_queues);
+	DEBUGFS_ADD(uapsd_max_sp_len);
+	DEBUGFS_ADD(channel_type);
+	DEBUGFS_ADD(hwflags);
+	DEBUGFS_ADD(user_power);
+	DEBUGFS_ADD(power);
+#ifdef USE_RSSI_SMOOTH
+	DEBUGFS_ADD_MODE(dis_rssi_smooth, 0600);
+#endif
+
+	statsd = debugfs_create_dir("statistics", phyd);
+
+	/* if the dir failed, don't put all the other things into the root! */
+	if (!statsd)
+		return;
+
+	DEBUGFS_STATS_ADD(transmitted_fragment_count,
+		local->dot11TransmittedFragmentCount);
+	DEBUGFS_STATS_ADD(multicast_transmitted_frame_count,
+		local->dot11MulticastTransmittedFrameCount);
+	DEBUGFS_STATS_ADD(failed_count, local->dot11FailedCount);
+	DEBUGFS_STATS_ADD(retry_count, local->dot11RetryCount);
+	DEBUGFS_STATS_ADD(multiple_retry_count,
+		local->dot11MultipleRetryCount);
+	DEBUGFS_STATS_ADD(frame_duplicate_count,
+		local->dot11FrameDuplicateCount);
+	DEBUGFS_STATS_ADD(received_fragment_count,
+		local->dot11ReceivedFragmentCount);
+	DEBUGFS_STATS_ADD(multicast_received_frame_count,
+		local->dot11MulticastReceivedFrameCount);
+	DEBUGFS_STATS_ADD(transmitted_frame_count,
+		local->dot11TransmittedFrameCount);
+#ifdef CONFIG_XRMAC_DEBUG_COUNTERS
+	DEBUGFS_STATS_ADD(tx_handlers_drop, local->tx_handlers_drop);
+	DEBUGFS_STATS_ADD(tx_handlers_queued, local->tx_handlers_queued);
+	DEBUGFS_STATS_ADD(tx_handlers_drop_unencrypted,
+		local->tx_handlers_drop_unencrypted);
+	DEBUGFS_STATS_ADD(tx_handlers_drop_fragment,
+		local->tx_handlers_drop_fragment);
+	DEBUGFS_STATS_ADD(tx_handlers_drop_wep,
+		local->tx_handlers_drop_wep);
+	DEBUGFS_STATS_ADD(tx_handlers_drop_not_assoc,
+		local->tx_handlers_drop_not_assoc);
+	DEBUGFS_STATS_ADD(tx_handlers_drop_unauth_port,
+		local->tx_handlers_drop_unauth_port);
+	DEBUGFS_STATS_ADD(rx_handlers_drop, local->rx_handlers_drop);
+	DEBUGFS_STATS_ADD(rx_handlers_queued, local->rx_handlers_queued);
+	DEBUGFS_STATS_ADD(rx_handlers_drop_nullfunc,
+		local->rx_handlers_drop_nullfunc);
+	DEBUGFS_STATS_ADD(rx_handlers_drop_defrag,
+		local->rx_handlers_drop_defrag);
+	DEBUGFS_STATS_ADD(rx_handlers_drop_short,
+		local->rx_handlers_drop_short);
+	DEBUGFS_STATS_ADD(rx_handlers_drop_passive_scan,
+		local->rx_handlers_drop_passive_scan);
+	DEBUGFS_STATS_ADD(tx_expand_skb_head,
+		local->tx_expand_skb_head);
+	DEBUGFS_STATS_ADD(tx_expand_skb_head_cloned,
+		local->tx_expand_skb_head_cloned);
+	DEBUGFS_STATS_ADD(rx_expand_skb_head,
+		local->rx_expand_skb_head);
+	DEBUGFS_STATS_ADD(rx_expand_skb_head2,
+		local->rx_expand_skb_head2);
+	DEBUGFS_STATS_ADD(rx_handlers_fragments,
+		local->rx_handlers_fragments);
+	DEBUGFS_STATS_ADD(tx_status_drop, sfasd
+		local->tx_status_drop);
+#endif
+	DEBUGFS_DEVSTATS_ADD(dot11ACKFailureCount);
+	DEBUGFS_DEVSTATS_ADD(dot11RTSFailureCount);
+	DEBUGFS_DEVSTATS_ADD(dot11FCSErrorCount);
+	DEBUGFS_DEVSTATS_ADD(dot11RTSSuccessCount);
+}
+#endif /* CONFIG_XRMAC_DEBUGFS */
diff -Naurp a/drivers/net/wireless/xr829/umac/debugfs.h b/drivers/net/wireless/xr829/umac/debugfs.h
--- a/drivers/net/wireless/xr829/umac/debugfs.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/debugfs.h	2022-08-27 01:22:42.938539802 +0300
@@ -0,0 +1,15 @@
+#ifndef __XRMAC_DEBUGFS_H
+#define __XRMAC_DEBUGFS_H
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+extern void xrmac_debugfs_hw_add(struct ieee80211_local *local);
+extern int mac80211_open_file_generic(struct inode *inode, struct file *file);
+extern int xrmac_format_buffer(char __user *userbuf, size_t count,
+				  loff_t *ppos, char *fmt, ...);
+#else
+static inline void xrmac_debugfs_hw_add(struct ieee80211_local *local)
+{
+}
+#endif
+
+#endif /* __XRMAC_DEBUGFS_H */
diff -Naurp a/drivers/net/wireless/xr829/umac/debugfs_key.c b/drivers/net/wireless/xr829/umac/debugfs_key.c
--- a/drivers/net/wireless/xr829/umac/debugfs_key.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/debugfs_key.c	2022-08-27 01:22:42.938539802 +0300
@@ -0,0 +1,349 @@
+/*
+ * Copyright 2003-2005	Devicescape Software, Inc.
+ * Copyright (c) 2006	Jiri Benc <jbenc@suse.cz>
+ * Copyright 2007	Johannes Berg <johannes@sipsolutions.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kobject.h>
+#include <linux/slab.h>
+#include "ieee80211_i.h"
+#include "key.h"
+#include "debugfs.h"
+#include "debugfs_key.h"
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+
+#define KEY_READ(name, prop, format_string)				\
+static ssize_t key_##name##_read(struct file *file,			\
+				 char __user *userbuf,			\
+				 size_t count, loff_t *ppos)		\
+{									\
+	struct ieee80211_key *key = file->private_data;			\
+	return xrmac_format_buffer(userbuf, count, ppos, 		\
+				      format_string, key->prop);	\
+}
+#define KEY_READ_D(name) KEY_READ(name, name, "%d\n")
+#define KEY_READ_X(name) KEY_READ(name, name, "0x%x\n")
+
+#define KEY_OPS(name)							\
+static const struct file_operations key_ ##name## _ops = {		\
+	.read = key_##name##_read,					\
+	.open = mac80211_open_file_generic,				\
+	.llseek = generic_file_llseek,					\
+}
+
+#define KEY_CONF_READ(name, format_string)				\
+	KEY_READ(conf_##name, conf.name, format_string)
+#define KEY_CONF_READ_D(name) KEY_CONF_READ(name, "%d\n")
+
+#define KEY_CONF_OPS(name)						\
+static const struct file_operations key_ ##name## _ops = {		\
+	.read = key_conf_##name##_read,					\
+	.open = mac80211_open_file_generic,				\
+	.llseek = generic_file_llseek,					\
+}
+
+
+KEY_CONF_READ_D(keylen);
+KEY_CONF_OPS(keylen);
+
+KEY_CONF_READ_D(keyidx);
+KEY_CONF_OPS(keyidx);
+
+KEY_CONF_READ_D(hw_key_idx);
+KEY_CONF_OPS(hw_key_idx);
+
+KEY_READ_X(flags);
+KEY_OPS(flags);
+
+KEY_READ_D(tx_rx_count);
+KEY_OPS(tx_rx_count);
+
+KEY_READ(ifindex, sdata->name, "%s\n");
+KEY_OPS(ifindex);
+
+static ssize_t key_algorithm_read(struct file *file,
+				  char __user *userbuf,
+				  size_t count, loff_t *ppos)
+{
+	char buf[15];
+	struct ieee80211_key *key = file->private_data;
+	u32 c = key->conf.cipher;
+
+	sprintf(buf, "%.2x-%.2x-%.2x:%d\n",
+		c >> 24, (c >> 16) & 0xff, (c >> 8) & 0xff, c & 0xff);
+	return simple_read_from_buffer(userbuf, count, ppos, buf, strlen(buf));
+}
+KEY_OPS(algorithm);
+
+static ssize_t key_tx_spec_read(struct file *file, char __user *userbuf,
+				size_t count, loff_t *ppos)
+{
+	u64 pn;
+	char buf[20];
+	int len;
+	struct ieee80211_key *key = file->private_data;
+
+	switch (key->conf.cipher) {
+	case WLAN_CIPHER_SUITE_WEP40:
+	case WLAN_CIPHER_SUITE_WEP104:
+		len = scnprintf(buf, sizeof(buf), "\n");
+		break;
+	case WLAN_CIPHER_SUITE_TKIP:
+		len = scnprintf(buf, sizeof(buf), "%08x %04x\n",
+				key->u.tkip.tx.iv32,
+				key->u.tkip.tx.iv16);
+		break;
+	case WLAN_CIPHER_SUITE_CCMP:
+		pn = atomic64_read(&key->u.ccmp.tx_pn);
+		len = scnprintf(buf, sizeof(buf), "%02x%02x%02x%02x%02x%02x\n",
+				(u8)(pn >> 40), (u8)(pn >> 32), (u8)(pn >> 24),
+				(u8)(pn >> 16), (u8)(pn >> 8), (u8)pn);
+		break;
+	case WLAN_CIPHER_SUITE_AES_CMAC:
+		pn = atomic64_read(&key->u.aes_cmac.tx_pn);
+		len = scnprintf(buf, sizeof(buf), "%02x%02x%02x%02x%02x%02x\n",
+				(u8)(pn >> 40), (u8)(pn >> 32), (u8)(pn >> 24),
+				(u8)(pn >> 16), (u8)(pn >> 8), (u8)pn);
+		break;
+	default:
+		return 0;
+	}
+	return simple_read_from_buffer(userbuf, count, ppos, buf, len);
+}
+KEY_OPS(tx_spec);
+
+static ssize_t key_rx_spec_read(struct file *file, char __user *userbuf,
+				size_t count, loff_t *ppos)
+{
+	struct ieee80211_key *key = file->private_data;
+	char buf[14*NUM_RX_DATA_QUEUES+1], *p = buf;
+	int i, len;
+	const u8 *rpn;
+
+	switch (key->conf.cipher) {
+	case WLAN_CIPHER_SUITE_WEP40:
+	case WLAN_CIPHER_SUITE_WEP104:
+		len = scnprintf(buf, sizeof(buf), "\n");
+		break;
+	case WLAN_CIPHER_SUITE_TKIP:
+		for (i = 0; i < NUM_RX_DATA_QUEUES; i++)
+			p += scnprintf(p, sizeof(buf)+buf-p,
+				       "%08x %04x\n",
+				       key->u.tkip.rx[i].iv32,
+				       key->u.tkip.rx[i].iv16);
+		len = p - buf;
+		break;
+	case WLAN_CIPHER_SUITE_CCMP:
+		for (i = 0; i < NUM_RX_DATA_QUEUES + 1; i++) {
+			rpn = key->u.ccmp.rx_pn[i];
+			p += scnprintf(p, sizeof(buf)+buf-p,
+				       "%02x%02x%02x%02x%02x%02x\n",
+				       rpn[0], rpn[1], rpn[2],
+				       rpn[3], rpn[4], rpn[5]);
+		}
+		len = p - buf;
+		break;
+	case WLAN_CIPHER_SUITE_AES_CMAC:
+		rpn = key->u.aes_cmac.rx_pn;
+		p += scnprintf(p, sizeof(buf)+buf-p,
+			       "%02x%02x%02x%02x%02x%02x\n",
+			       rpn[0], rpn[1], rpn[2],
+			       rpn[3], rpn[4], rpn[5]);
+		len = p - buf;
+		break;
+	default:
+		return 0;
+	}
+	return simple_read_from_buffer(userbuf, count, ppos, buf, len);
+}
+KEY_OPS(rx_spec);
+
+static ssize_t key_replays_read(struct file *file, char __user *userbuf,
+				size_t count, loff_t *ppos)
+{
+	struct ieee80211_key *key = file->private_data;
+	char buf[20];
+	int len;
+
+	switch (key->conf.cipher) {
+	case WLAN_CIPHER_SUITE_CCMP:
+		len = scnprintf(buf, sizeof(buf), "%u\n", key->u.ccmp.replays);
+		break;
+	case WLAN_CIPHER_SUITE_AES_CMAC:
+		len = scnprintf(buf, sizeof(buf), "%u\n",
+				key->u.aes_cmac.replays);
+		break;
+	default:
+		return 0;
+	}
+	return simple_read_from_buffer(userbuf, count, ppos, buf, len);
+}
+KEY_OPS(replays);
+
+static ssize_t key_icverrors_read(struct file *file, char __user *userbuf,
+				  size_t count, loff_t *ppos)
+{
+	struct ieee80211_key *key = file->private_data;
+	char buf[20];
+	int len;
+
+	switch (key->conf.cipher) {
+	case WLAN_CIPHER_SUITE_AES_CMAC:
+		len = scnprintf(buf, sizeof(buf), "%u\n",
+				key->u.aes_cmac.icverrors);
+		break;
+	default:
+		return 0;
+	}
+	return simple_read_from_buffer(userbuf, count, ppos, buf, len);
+}
+KEY_OPS(icverrors);
+
+static ssize_t key_key_read(struct file *file, char __user *userbuf,
+			    size_t count, loff_t *ppos)
+{
+	struct ieee80211_key *key = file->private_data;
+	int i, bufsize = 2 * key->conf.keylen + 2;
+	char *buf = kmalloc(bufsize, GFP_KERNEL);
+	char *p = buf;
+	ssize_t res;
+
+	if (!buf)
+		return -ENOMEM;
+
+	for (i = 0; i < key->conf.keylen; i++)
+		p += scnprintf(p, bufsize + buf - p, "%02x", key->conf.key[i]);
+	p += scnprintf(p, bufsize+buf-p, "\n");
+	res = simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);
+	kfree(buf);
+	return res;
+}
+KEY_OPS(key);
+
+#define DEBUGFS_ADD(name) \
+	debugfs_create_file(#name, 0400, key->debugfs.dir, \
+			    key, &key_##name##_ops);
+
+void xrmac80211_debugfs_key_add(struct ieee80211_key *key)
+{
+	static int keycount;
+	char buf[50];
+	struct sta_info *sta;
+
+	if (!key->local->debugfs.keys)
+		return;
+
+	sprintf(buf, "%d", keycount);
+	key->debugfs.cnt = keycount;
+	keycount++;
+	key->debugfs.dir = debugfs_create_dir(buf,
+					key->local->debugfs.keys);
+
+	if (!key->debugfs.dir)
+		return;
+
+	sta = key->sta;
+	if (sta) {
+		sprintf(buf, "../../stations/%pM", sta->sta.addr);
+		key->debugfs.stalink =
+			debugfs_create_symlink("station", key->debugfs.dir, buf);
+	}
+
+	DEBUGFS_ADD(keylen);
+	DEBUGFS_ADD(flags);
+	DEBUGFS_ADD(keyidx);
+	DEBUGFS_ADD(hw_key_idx);
+	DEBUGFS_ADD(tx_rx_count);
+	DEBUGFS_ADD(algorithm);
+	DEBUGFS_ADD(tx_spec);
+	DEBUGFS_ADD(rx_spec);
+	DEBUGFS_ADD(replays);
+	DEBUGFS_ADD(icverrors);
+	DEBUGFS_ADD(key);
+	DEBUGFS_ADD(ifindex);
+};
+
+void mac80211_debugfs_key_remove(struct ieee80211_key *key)
+{
+	if (!key)
+		return;
+
+	debugfs_remove_recursive(key->debugfs.dir);
+	key->debugfs.dir = NULL;
+}
+
+void mac80211_debugfs_key_update_default(struct ieee80211_sub_if_data *sdata)
+{
+	char buf[50];
+	struct ieee80211_key *key;
+
+	if (!sdata->debugfs.dir)
+		return;
+
+	lockdep_assert_held(&sdata->local->key_mtx);
+
+	if (sdata->default_unicast_key) {
+		key = key_mtx_dereference(sdata->local,
+					  sdata->default_unicast_key);
+		sprintf(buf, "../keys/%d", key->debugfs.cnt);
+		sdata->debugfs.default_unicast_key =
+			debugfs_create_symlink("default_unicast_key",
+					       sdata->debugfs.dir, buf);
+	} else {
+		debugfs_remove(sdata->debugfs.default_unicast_key);
+		sdata->debugfs.default_unicast_key = NULL;
+	}
+
+	if (sdata->default_multicast_key) {
+		key = key_mtx_dereference(sdata->local,
+					  sdata->default_multicast_key);
+		sprintf(buf, "../keys/%d", key->debugfs.cnt);
+		sdata->debugfs.default_multicast_key =
+			debugfs_create_symlink("default_multicast_key",
+					       sdata->debugfs.dir, buf);
+	} else {
+		debugfs_remove(sdata->debugfs.default_multicast_key);
+		sdata->debugfs.default_multicast_key = NULL;
+	}
+}
+
+void mac80211_debugfs_key_add_mgmt_default(struct ieee80211_sub_if_data *sdata)
+{
+	char buf[50];
+	struct ieee80211_key *key;
+
+	if (!sdata->debugfs.dir)
+		return;
+
+	key = key_mtx_dereference(sdata->local,
+				  sdata->default_mgmt_key);
+	if (key) {
+		sprintf(buf, "../keys/%d", key->debugfs.cnt);
+		sdata->debugfs.default_mgmt_key =
+			debugfs_create_symlink("default_mgmt_key",
+					       sdata->debugfs.dir, buf);
+	} else
+		mac80211_debugfs_key_remove_mgmt_default(sdata);
+}
+
+void mac80211_debugfs_key_remove_mgmt_default(struct ieee80211_sub_if_data *sdata)
+{
+	if (!sdata)
+		return;
+
+	debugfs_remove(sdata->debugfs.default_mgmt_key);
+	sdata->debugfs.default_mgmt_key = NULL;
+}
+
+void mac80211_debugfs_key_sta_del(struct ieee80211_key *key,
+				   struct sta_info *sta)
+{
+	debugfs_remove(key->debugfs.stalink);
+	key->debugfs.stalink = NULL;
+}
+#endif /* CONFIG_XRMAC_DEBUGFS */
diff -Naurp a/drivers/net/wireless/xr829/umac/debugfs_key.h b/drivers/net/wireless/xr829/umac/debugfs_key.h
--- a/drivers/net/wireless/xr829/umac/debugfs_key.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/debugfs_key.h	2022-08-27 01:22:42.938539802 +0300
@@ -0,0 +1,33 @@
+#ifndef __XRMAC_DEBUGFS_KEY_H
+#define __XRMAC_DEBUGFS_KEY_H
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+void xrmac80211_debugfs_key_add(struct ieee80211_key *key);
+void mac80211_debugfs_key_remove(struct ieee80211_key *key);
+void mac80211_debugfs_key_update_default(struct ieee80211_sub_if_data *sdata);
+void mac80211_debugfs_key_add_mgmt_default(
+	struct ieee80211_sub_if_data *sdata);
+void mac80211_debugfs_key_remove_mgmt_default(
+	struct ieee80211_sub_if_data *sdata);
+void mac80211_debugfs_key_sta_del(struct ieee80211_key *key,
+				   struct sta_info *sta);
+#else
+static inline void xrmac80211_debugfs_key_add(struct ieee80211_key *key)
+{}
+static inline void mac80211_debugfs_key_remove(struct ieee80211_key *key)
+{}
+static inline void mac80211_debugfs_key_update_default(
+	struct ieee80211_sub_if_data *sdata)
+{}
+static inline void mac80211_debugfs_key_add_mgmt_default(
+	struct ieee80211_sub_if_data *sdata)
+{}
+static inline void mac80211_debugfs_key_remove_mgmt_default(
+	struct ieee80211_sub_if_data *sdata)
+{}
+static inline void mac80211_debugfs_key_sta_del(struct ieee80211_key *key,
+						 struct sta_info *sta)
+{}
+#endif
+
+#endif /* __XRMAC_DEBUGFS_KEY_H */
diff -Naurp a/drivers/net/wireless/xr829/umac/debugfs_netdev.c b/drivers/net/wireless/xr829/umac/debugfs_netdev.c
--- a/drivers/net/wireless/xr829/umac/debugfs_netdev.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/debugfs_netdev.c	2022-08-27 01:22:42.938539802 +0300
@@ -0,0 +1,665 @@
+/*
+ * Copyright (c) 2006	Jiri Benc <jbenc@suse.cz>
+ * Copyright 2007	Johannes Berg <johannes@sipsolutions.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/if.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/rtnetlink.h>
+#include <linux/slab.h>
+#include <linux/notifier.h>
+#include <net/mac80211.h>
+#include <net/cfg80211.h>
+#include "ieee80211_i.h"
+#include "rate.h"
+#include "debugfs.h"
+#include "debugfs_netdev.h"
+#include "driver-ops.h"
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+
+static ssize_t ieee80211_if_read(
+	struct ieee80211_sub_if_data *sdata,
+	char __user *userbuf,
+	size_t count, loff_t *ppos,
+	ssize_t (*format)(const struct ieee80211_sub_if_data *, char *, int))
+{
+	char buf[70];
+	ssize_t ret = -EINVAL;
+
+	read_lock(&dev_base_lock);
+	if (sdata->dev->reg_state == NETREG_REGISTERED)
+		ret = (*format)(sdata, buf, sizeof(buf));
+	read_unlock(&dev_base_lock);
+
+	if (ret >= 0)
+		ret = simple_read_from_buffer(userbuf, count, ppos, buf, ret);
+
+	return ret;
+}
+
+static ssize_t ieee80211_if_write(
+	struct ieee80211_sub_if_data *sdata,
+	const char __user *userbuf,
+	size_t count, loff_t *ppos,
+	ssize_t (*write)(struct ieee80211_sub_if_data *, const char *, int))
+{
+	u8 *buf;
+	ssize_t ret;
+
+	buf = kmalloc(count, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	ret = -EFAULT;
+	if (copy_from_user(buf, userbuf, count))
+		goto freebuf;
+
+	ret = -ENODEV;
+	rtnl_lock();
+	if (sdata->dev->reg_state == NETREG_REGISTERED)
+		ret = (*write)(sdata, buf, count);
+	rtnl_unlock();
+
+freebuf:
+	kfree(buf);
+	return ret;
+}
+
+#define IEEE80211_IF_FMT(name, field, format_string)			\
+static ssize_t ieee80211_if_fmt_##name(					\
+	const struct ieee80211_sub_if_data *sdata, char *buf,		\
+	int buflen)							\
+{									\
+	return scnprintf(buf, buflen, format_string, sdata->field);	\
+}
+#define IEEE80211_IF_FMT_DEC(name, field)				\
+		IEEE80211_IF_FMT(name, field, "%d\n")
+#define IEEE80211_IF_FMT_HEX(name, field)				\
+		IEEE80211_IF_FMT(name, field, "%#x\n")
+#define IEEE80211_IF_FMT_LHEX(name, field)				\
+		IEEE80211_IF_FMT(name, field, "%#lx\n")
+#define IEEE80211_IF_FMT_SIZE(name, field)				\
+		IEEE80211_IF_FMT(name, field, "%zd\n")
+
+#define IEEE80211_IF_FMT_ATOMIC(name, field)				\
+static ssize_t ieee80211_if_fmt_##name(					\
+	const struct ieee80211_sub_if_data *sdata,			\
+	char *buf, int buflen)						\
+{									\
+	return scnprintf(buf, buflen, "%d\n", atomic_read(&sdata->field));\
+}
+
+#define IEEE80211_IF_FMT_MAC(name, field)				\
+static ssize_t ieee80211_if_fmt_##name(					\
+	const struct ieee80211_sub_if_data *sdata, char *buf,		\
+	int buflen)							\
+{									\
+	return scnprintf(buf, buflen, "%pM\n", sdata->field);		\
+}
+
+#define IEEE80211_IF_FMT_DEC_DIV_16(name, field)			\
+static ssize_t ieee80211_if_fmt_##name(					\
+	const struct ieee80211_sub_if_data *sdata,			\
+	char *buf, int buflen)						\
+{									\
+	return scnprintf(buf, buflen, "%d\n", sdata->field / 16);	\
+}
+
+#define __IEEE80211_IF_FILE(name, _write)				\
+static ssize_t ieee80211_if_read_##name(struct file *file,		\
+					char __user *userbuf,		\
+					size_t count, loff_t *ppos)	\
+{									\
+	return ieee80211_if_read(file->private_data,			\
+				 userbuf, count, ppos,			\
+				 ieee80211_if_fmt_##name);		\
+}									\
+static const struct file_operations name##_ops = {			\
+	.read = ieee80211_if_read_##name,				\
+	.write = (_write),						\
+	.open = mac80211_open_file_generic,				\
+	.llseek = generic_file_llseek,					\
+}
+
+#define __IEEE80211_IF_FILE_W(name)					\
+static ssize_t ieee80211_if_write_##name(struct file *file,		\
+					 const char __user *userbuf,	\
+					 size_t count, loff_t *ppos)	\
+{									\
+	return ieee80211_if_write(file->private_data, userbuf, count,	\
+				  ppos, ieee80211_if_parse_##name);	\
+}									\
+__IEEE80211_IF_FILE(name, ieee80211_if_write_##name)
+
+/*
+#define IEEE80211_IF_FILE(name, field, format)				\
+		IEEE80211_IF_FMT_##format(name, field)			\
+		__IEEE80211_IF_FILE(name, NULL)
+*/
+
+/* common attributes */
+IEEE80211_IF_FMT_DEC(drop_unencrypted, drop_unencrypted);
+__IEEE80211_IF_FILE(drop_unencrypted, NULL);
+
+IEEE80211_IF_FMT_HEX(rc_rateidx_mask_2ghz, rc_rateidx_mask[NL80211_BAND_2GHZ]);
+__IEEE80211_IF_FILE(rc_rateidx_mask_2ghz, NULL);
+
+IEEE80211_IF_FMT_HEX(rc_rateidx_mask_5ghz, rc_rateidx_mask[NL80211_BAND_5GHZ]);
+__IEEE80211_IF_FILE(rc_rateidx_mask_5ghz, NULL);
+
+IEEE80211_IF_FMT_HEX(flags, flags);
+__IEEE80211_IF_FILE(flags, NULL);
+
+IEEE80211_IF_FMT_LHEX(state, state);
+__IEEE80211_IF_FILE(state, NULL);
+
+IEEE80211_IF_FMT_DEC(channel_type, vif.bss_conf.channel_type);
+__IEEE80211_IF_FILE(channel_type, NULL);
+
+IEEE80211_IF_FMT_DEC(rts_threshold, wdev.wiphy->rts_threshold);
+__IEEE80211_IF_FILE(rts_threshold, NULL);
+
+IEEE80211_IF_FMT_DEC(retry_short, wdev.wiphy->retry_short);
+__IEEE80211_IF_FILE(retry_short, NULL);
+
+IEEE80211_IF_FMT_DEC(retry_long, wdev.wiphy->retry_long);
+__IEEE80211_IF_FILE(retry_long, NULL);
+
+/* STA attributes */
+IEEE80211_IF_FMT_MAC(bssid, u.mgd.bssid);
+__IEEE80211_IF_FILE(bssid, NULL);
+
+IEEE80211_IF_FMT_DEC(aid, u.mgd.aid);
+__IEEE80211_IF_FILE(aid, NULL);
+
+IEEE80211_IF_FMT_DEC(last_beacon, u.mgd.last_beacon_signal);
+__IEEE80211_IF_FILE(last_beacon, NULL);
+
+/* IEEE80211_IF_FILE(ave_beacon, u.mgd.ave_beacon_signal, DEC_DIV_16); */
+IEEE80211_IF_FMT_DEC_DIV_16(ave_beacon, u.mgd.ave_beacon_signal);
+__IEEE80211_IF_FILE(ave_beacon, NULL);
+
+
+static int ieee80211_set_smps(struct ieee80211_sub_if_data *sdata,
+			      enum ieee80211_smps_mode smps_mode)
+{
+	struct ieee80211_local *local = sdata->local;
+	int err;
+
+	if (!(local->hw.flags & IEEE80211_HW_SUPPORTS_STATIC_SMPS) &&
+	    smps_mode == IEEE80211_SMPS_STATIC)
+		return -EINVAL;
+
+	/* auto should be dynamic if in PS mode */
+	if (!(local->hw.flags & IEEE80211_HW_SUPPORTS_DYNAMIC_SMPS) &&
+	    (smps_mode == IEEE80211_SMPS_DYNAMIC ||
+	     smps_mode == IEEE80211_SMPS_AUTOMATIC))
+		return -EINVAL;
+
+	/* supported only on managed interfaces for now */
+	if (sdata->vif.type != NL80211_IFTYPE_STATION)
+		return -EOPNOTSUPP;
+
+	mutex_lock(&sdata->u.mgd.mtx);
+	err = __mac80211_request_smps(sdata, smps_mode);
+	mutex_unlock(&sdata->u.mgd.mtx);
+
+	return err;
+}
+
+static const char *smps_modes[IEEE80211_SMPS_NUM_MODES] = {
+	[IEEE80211_SMPS_AUTOMATIC] = "auto",
+	[IEEE80211_SMPS_OFF] = "off",
+	[IEEE80211_SMPS_STATIC] = "static",
+	[IEEE80211_SMPS_DYNAMIC] = "dynamic",
+};
+
+static ssize_t ieee80211_if_fmt_smps(const struct ieee80211_sub_if_data *sdata,
+				     char *buf, int buflen)
+{
+	if (sdata->vif.type != NL80211_IFTYPE_STATION)
+		return -EOPNOTSUPP;
+
+	return snprintf(buf, buflen, "request: %s\nused: %s\n",
+			smps_modes[sdata->u.mgd.req_smps],
+			smps_modes[sdata->u.mgd.ap_smps]);
+}
+
+static ssize_t ieee80211_if_parse_smps(struct ieee80211_sub_if_data *sdata,
+				       const char *buf, int buflen)
+{
+	enum ieee80211_smps_mode mode;
+
+	for (mode = 0; mode < IEEE80211_SMPS_NUM_MODES; mode++) {
+		if (strncmp(buf, smps_modes[mode], buflen) == 0) {
+			int err = ieee80211_set_smps(sdata, mode);
+			if (!err)
+				return buflen;
+			return err;
+		}
+	}
+
+	return -EINVAL;
+}
+
+__IEEE80211_IF_FILE_W(smps);
+
+static ssize_t ieee80211_if_fmt_tkip_mic_test(
+	const struct ieee80211_sub_if_data *sdata, char *buf, int buflen)
+{
+	return -EOPNOTSUPP;
+}
+
+static int hwaddr_aton(const char *txt, u8 *addr)
+{
+	int i;
+
+	for (i = 0; i < ETH_ALEN; i++) {
+		int a, b;
+
+		a = hex_to_bin(*txt++);
+		if (a < 0)
+			return -1;
+		b = hex_to_bin(*txt++);
+		if (b < 0)
+			return -1;
+		*addr++ = (a << 4) | b;
+		if (i < 5 && *txt++ != ':')
+			return -1;
+	}
+
+	return 0;
+}
+
+static ssize_t ieee80211_if_parse_tkip_mic_test(
+	struct ieee80211_sub_if_data *sdata, const char *buf, int buflen)
+{
+	struct ieee80211_local *local = sdata->local;
+	u8 addr[ETH_ALEN];
+	struct sk_buff *skb;
+	struct ieee80211_hdr *hdr;
+	__le16 fc;
+
+	/*
+	 * Assume colon-delimited MAC address with possible white space
+	 * following.
+	 */
+	if (buflen < 3 * ETH_ALEN - 1)
+		return -EINVAL;
+	if (hwaddr_aton(buf, addr) < 0)
+		return -EINVAL;
+
+	if (!ieee80211_sdata_running(sdata))
+		return -ENOTCONN;
+
+	skb = dev_alloc_skb(local->hw.extra_tx_headroom + 24 + 100);
+	if (!skb)
+		return -ENOMEM;
+	skb_reserve(skb, local->hw.extra_tx_headroom);
+
+	hdr = (struct ieee80211_hdr *) skb_put(skb, 24);
+	memset(hdr, 0, 24);
+	fc = cpu_to_le16(IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA);
+
+	switch (sdata->vif.type) {
+	case NL80211_IFTYPE_AP:
+		fc |= cpu_to_le16(IEEE80211_FCTL_FROMDS);
+		/* DA BSSID SA */
+		memcpy(hdr->addr1, addr, ETH_ALEN);
+		memcpy(hdr->addr2, sdata->vif.addr, ETH_ALEN);
+		memcpy(hdr->addr3, sdata->vif.addr, ETH_ALEN);
+		break;
+	case NL80211_IFTYPE_STATION:
+		fc |= cpu_to_le16(IEEE80211_FCTL_TODS);
+		/* BSSID SA DA */
+		if (sdata->vif.bss_conf.bssid == NULL) {
+			dev_kfree_skb(skb);
+			return -ENOTCONN;
+		}
+		memcpy(hdr->addr1, sdata->vif.bss_conf.bssid, ETH_ALEN);
+		memcpy(hdr->addr2, sdata->vif.addr, ETH_ALEN);
+		memcpy(hdr->addr3, addr, ETH_ALEN);
+		break;
+	default:
+		dev_kfree_skb(skb);
+		return -EOPNOTSUPP;
+	}
+	hdr->frame_control = fc;
+
+	/*
+	 * Add some length to the test frame to make it look bit more valid.
+	 * The exact contents does not matter since the recipient is required
+	 * to drop this because of the Michael MIC failure.
+	 */
+	memset(skb_put(skb, 50), 0, 50);
+
+	IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_TKIP_MIC_FAILURE;
+
+	ieee80211_tx_skb(sdata, skb);
+
+	return buflen;
+}
+
+__IEEE80211_IF_FILE_W(tkip_mic_test);
+
+/* AP attributes */
+IEEE80211_IF_FILE(num_sta_ps, u.ap.num_sta_ps, ATOMIC);
+IEEE80211_IF_FILE(dtim_count, u.ap.dtim_count, DEC);
+
+static ssize_t ieee80211_if_fmt_num_buffered_multicast(
+	const struct ieee80211_sub_if_data *sdata, char *buf, int buflen)
+{
+	return scnprintf(buf, buflen, "%u\n",
+			 skb_queue_len(&sdata->u.ap.ps_bc_buf));
+}
+__IEEE80211_IF_FILE(num_buffered_multicast, NULL);
+
+/* IBSS attributes */
+static ssize_t ieee80211_if_fmt_tsf(
+	const struct ieee80211_sub_if_data *sdata, char *buf, int buflen)
+{
+	struct ieee80211_local *local = sdata->local;
+	u64 tsf;
+
+	tsf = drv_get_tsf(local, (struct ieee80211_sub_if_data *)sdata);
+
+	return scnprintf(buf, buflen, "0x%016llx\n", (unsigned long long) tsf);
+}
+
+static ssize_t ieee80211_if_parse_tsf(
+	struct ieee80211_sub_if_data *sdata, const char *buf, int buflen)
+{
+	struct ieee80211_local *local = sdata->local;
+	unsigned long long tsf;
+	int ret;
+
+	if (strncmp(buf, "reset", 5) == 0) {
+		if (local->ops->reset_tsf) {
+			drv_reset_tsf(local, sdata);
+			wiphy_info(local->hw.wiphy, "debugfs reset TSF\n");
+		}
+	} else {
+		ret = kstrtoull(buf, 10, &tsf);
+		if (ret < 0)
+			return -EINVAL;
+		if (local->ops->set_tsf) {
+			drv_set_tsf(local, sdata, tsf);
+			wiphy_info(local->hw.wiphy,
+				   "debugfs set TSF to %#018llx\n", tsf);
+		}
+	}
+
+	return buflen;
+}
+__IEEE80211_IF_FILE_W(tsf);
+
+
+/* WDS attributes */
+IEEE80211_IF_FILE(peer, u.wds.remote_addr, MAC);
+
+#ifdef CONFIG_XRMAC_MESH
+/* Mesh stats attributes */
+IEEE80211_IF_FILE(fwded_mcast, u.mesh.mshstats.fwded_mcast, DEC);
+IEEE80211_IF_FILE(fwded_unicast, u.mesh.mshstats.fwded_unicast, DEC);
+IEEE80211_IF_FILE(fwded_frames, u.mesh.mshstats.fwded_frames, DEC);
+IEEE80211_IF_FILE(dropped_frames_ttl, u.mesh.mshstats.dropped_frames_ttl, DEC);
+IEEE80211_IF_FILE(dropped_frames_congestion,
+		u.mesh.mshstats.dropped_frames_congestion, DEC);
+IEEE80211_IF_FILE(dropped_frames_no_route,
+		u.mesh.mshstats.dropped_frames_no_route, DEC);
+IEEE80211_IF_FILE(estab_plinks, u.mesh.mshstats.estab_plinks, ATOMIC);
+
+/* Mesh parameters */
+IEEE80211_IF_FILE(dot11MeshMaxRetries,
+		u.mesh.mshcfg.dot11MeshMaxRetries, DEC);
+IEEE80211_IF_FILE(dot11MeshRetryTimeout,
+		u.mesh.mshcfg.dot11MeshRetryTimeout, DEC);
+IEEE80211_IF_FILE(dot11MeshConfirmTimeout,
+		u.mesh.mshcfg.dot11MeshConfirmTimeout, DEC);
+IEEE80211_IF_FILE(dot11MeshHoldingTimeout,
+		u.mesh.mshcfg.dot11MeshHoldingTimeout, DEC);
+IEEE80211_IF_FILE(dot11MeshTTL, u.mesh.mshcfg.dot11MeshTTL, DEC);
+IEEE80211_IF_FILE(element_ttl, u.mesh.mshcfg.element_ttl, DEC);
+IEEE80211_IF_FILE(auto_open_plinks, u.mesh.mshcfg.auto_open_plinks, DEC);
+IEEE80211_IF_FILE(dot11MeshMaxPeerLinks,
+		u.mesh.mshcfg.dot11MeshMaxPeerLinks, DEC);
+IEEE80211_IF_FILE(dot11MeshHWMPactivePathTimeout,
+		u.mesh.mshcfg.dot11MeshHWMPactivePathTimeout, DEC);
+IEEE80211_IF_FILE(dot11MeshHWMPpreqMinInterval,
+		u.mesh.mshcfg.dot11MeshHWMPpreqMinInterval, DEC);
+IEEE80211_IF_FILE(dot11MeshHWMPnetDiameterTraversalTime,
+		u.mesh.mshcfg.dot11MeshHWMPnetDiameterTraversalTime, DEC);
+IEEE80211_IF_FILE(dot11MeshHWMPmaxPREQretries,
+		u.mesh.mshcfg.dot11MeshHWMPmaxPREQretries, DEC);
+IEEE80211_IF_FILE(path_refresh_time,
+		u.mesh.mshcfg.path_refresh_time, DEC);
+IEEE80211_IF_FILE(min_discovery_timeout,
+		u.mesh.mshcfg.min_discovery_timeout, DEC);
+IEEE80211_IF_FILE(dot11MeshHWMPRootMode,
+		u.mesh.mshcfg.dot11MeshHWMPRootMode, DEC);
+IEEE80211_IF_FILE(dot11MeshGateAnnouncementProtocol,
+		u.mesh.mshcfg.dot11MeshGateAnnouncementProtocol, DEC);
+IEEE80211_IF_FILE(dot11MeshHWMPRannInterval,
+		u.mesh.mshcfg.dot11MeshHWMPRannInterval, DEC);
+#endif
+
+
+#define DEBUGFS_ADD(name) \
+	debugfs_create_file(#name, 0400, sdata->debugfs.dir, \
+			    sdata, &name##_ops);
+
+#define DEBUGFS_ADD_MODE(name, mode) \
+	debugfs_create_file(#name, mode, sdata->debugfs.dir, \
+			    sdata, &name##_ops);
+
+static void add_sta_files(struct ieee80211_sub_if_data *sdata)
+{
+	DEBUGFS_ADD(drop_unencrypted);
+	DEBUGFS_ADD(flags);
+	DEBUGFS_ADD(state);
+	DEBUGFS_ADD(channel_type);
+	DEBUGFS_ADD(rc_rateidx_mask_2ghz);
+	DEBUGFS_ADD(rc_rateidx_mask_5ghz);
+	DEBUGFS_ADD(rts_threshold);
+	DEBUGFS_ADD(retry_long);
+	DEBUGFS_ADD(retry_short);
+
+	DEBUGFS_ADD(bssid);
+	DEBUGFS_ADD(aid);
+	DEBUGFS_ADD(last_beacon);
+	DEBUGFS_ADD(ave_beacon);
+	DEBUGFS_ADD_MODE(smps, 0600);
+	DEBUGFS_ADD_MODE(tkip_mic_test, 0200);
+}
+
+static void add_ap_files(struct ieee80211_sub_if_data *sdata)
+{
+	DEBUGFS_ADD(drop_unencrypted);
+	DEBUGFS_ADD(flags);
+	DEBUGFS_ADD(state);
+	DEBUGFS_ADD(channel_type);
+	DEBUGFS_ADD(rc_rateidx_mask_2ghz);
+	DEBUGFS_ADD(rc_rateidx_mask_5ghz);
+	DEBUGFS_ADD(rts_threshold);
+	DEBUGFS_ADD(retry_long);
+	DEBUGFS_ADD(retry_short);
+
+	DEBUGFS_ADD(num_sta_ps);
+	DEBUGFS_ADD(dtim_count);
+	DEBUGFS_ADD(num_buffered_multicast);
+	DEBUGFS_ADD_MODE(tkip_mic_test, 0200);
+}
+
+static void add_ibss_files(struct ieee80211_sub_if_data *sdata)
+{
+	DEBUGFS_ADD_MODE(tsf, 0600);
+}
+
+static void add_wds_files(struct ieee80211_sub_if_data *sdata)
+{
+	DEBUGFS_ADD(drop_unencrypted);
+	DEBUGFS_ADD(flags);
+	DEBUGFS_ADD(state);
+	DEBUGFS_ADD(channel_type);
+	DEBUGFS_ADD(rc_rateidx_mask_2ghz);
+	DEBUGFS_ADD(rc_rateidx_mask_5ghz);
+	DEBUGFS_ADD(rts_threshold);
+	DEBUGFS_ADD(retry_long);
+	DEBUGFS_ADD(retry_short);
+
+	DEBUGFS_ADD(peer);
+}
+
+static void add_vlan_files(struct ieee80211_sub_if_data *sdata)
+{
+	DEBUGFS_ADD(drop_unencrypted);
+	DEBUGFS_ADD(flags);
+	DEBUGFS_ADD(state);
+	DEBUGFS_ADD(channel_type);
+	DEBUGFS_ADD(rc_rateidx_mask_2ghz);
+	DEBUGFS_ADD(rc_rateidx_mask_5ghz);
+	DEBUGFS_ADD(rts_threshold);
+	DEBUGFS_ADD(retry_long);
+	DEBUGFS_ADD(retry_short);
+}
+
+static void add_monitor_files(struct ieee80211_sub_if_data *sdata)
+{
+	DEBUGFS_ADD(flags);
+	DEBUGFS_ADD(state);
+	DEBUGFS_ADD(channel_type);
+	DEBUGFS_ADD(rts_threshold);
+	DEBUGFS_ADD(retry_long);
+	DEBUGFS_ADD(retry_short);
+}
+
+#ifdef CONFIG_XRMAC_MESH
+
+static void add_mesh_stats(struct ieee80211_sub_if_data *sdata)
+{
+	struct dentry *dir = debugfs_create_dir("mesh_stats",
+						sdata->debugfs.dir);
+
+#define MESHSTATS_ADD(name)\
+	debugfs_create_file(#name, 0400, dir, sdata, &name##_ops);
+
+	MESHSTATS_ADD(fwded_mcast);
+	MESHSTATS_ADD(fwded_unicast);
+	MESHSTATS_ADD(fwded_frames);
+	MESHSTATS_ADD(dropped_frames_ttl);
+	MESHSTATS_ADD(dropped_frames_no_route);
+	MESHSTATS_ADD(dropped_frames_congestion);
+	MESHSTATS_ADD(estab_plinks);
+#undef MESHSTATS_ADD
+}
+
+static void add_mesh_config(struct ieee80211_sub_if_data *sdata)
+{
+	struct dentry *dir = debugfs_create_dir("mesh_config",
+						sdata->debugfs.dir);
+
+#define MESHPARAMS_ADD(name) \
+	debugfs_create_file(#name, 0600, dir, sdata, &name##_ops);
+
+	MESHPARAMS_ADD(dot11MeshMaxRetries);
+	MESHPARAMS_ADD(dot11MeshRetryTimeout);
+	MESHPARAMS_ADD(dot11MeshConfirmTimeout);
+	MESHPARAMS_ADD(dot11MeshHoldingTimeout);
+	MESHPARAMS_ADD(dot11MeshTTL);
+	MESHPARAMS_ADD(element_ttl);
+	MESHPARAMS_ADD(auto_open_plinks);
+	MESHPARAMS_ADD(dot11MeshMaxPeerLinks);
+	MESHPARAMS_ADD(dot11MeshHWMPactivePathTimeout);
+	MESHPARAMS_ADD(dot11MeshHWMPpreqMinInterval);
+	MESHPARAMS_ADD(dot11MeshHWMPnetDiameterTraversalTime);
+	MESHPARAMS_ADD(dot11MeshHWMPmaxPREQretries);
+	MESHPARAMS_ADD(path_refresh_time);
+	MESHPARAMS_ADD(min_discovery_timeout);
+	MESHPARAMS_ADD(dot11MeshHWMPRootMode);
+	MESHPARAMS_ADD(dot11MeshHWMPRannInterval);
+	MESHPARAMS_ADD(dot11MeshGateAnnouncementProtocol);
+#undef MESHPARAMS_ADD
+}
+#endif
+
+static void add_files(struct ieee80211_sub_if_data *sdata)
+{
+	if (!sdata->debugfs.dir)
+		return;
+
+	switch (sdata->vif.type) {
+	case NL80211_IFTYPE_MESH_POINT:
+#ifdef CONFIG_XRMAC_MESH
+		add_mesh_stats(sdata);
+		add_mesh_config(sdata);
+#endif
+		break;
+	case NL80211_IFTYPE_STATION:
+		add_sta_files(sdata);
+		break;
+	case NL80211_IFTYPE_ADHOC:
+		add_ibss_files(sdata);
+		break;
+	case NL80211_IFTYPE_AP:
+		add_ap_files(sdata);
+		break;
+	case NL80211_IFTYPE_WDS:
+		add_wds_files(sdata);
+		break;
+	case NL80211_IFTYPE_MONITOR:
+		add_monitor_files(sdata);
+		break;
+	case NL80211_IFTYPE_AP_VLAN:
+		add_vlan_files(sdata);
+		break;
+	default:
+		break;
+	}
+}
+
+void mac80211_debugfs_add_netdev(struct ieee80211_sub_if_data *sdata)
+{
+	char buf[10+IFNAMSIZ];
+
+	sprintf(buf, "netdev:%s", sdata->name);
+	sdata->debugfs.dir = debugfs_create_dir(buf,
+		sdata->local->hw.wiphy->debugfsdir);
+	if (sdata->debugfs.dir)
+		sdata->debugfs.subdir_stations = debugfs_create_dir("stations",
+			sdata->debugfs.dir);
+	add_files(sdata);
+}
+
+void mac80211_debugfs_remove_netdev(struct ieee80211_sub_if_data *sdata)
+{
+	if (!sdata->debugfs.dir)
+		return;
+
+	debugfs_remove_recursive(sdata->debugfs.dir);
+	sdata->debugfs.dir = NULL;
+}
+
+void mac80211_debugfs_rename_netdev(struct ieee80211_sub_if_data *sdata)
+{
+	struct dentry *dir;
+	char buf[10 + IFNAMSIZ];
+
+	dir = sdata->debugfs.dir;
+
+	if (!dir)
+		return;
+
+	sprintf(buf, "netdev:%s", sdata->name);
+	if (!debugfs_rename(dir->d_parent, dir, dir->d_parent, buf))
+		printk(KERN_ERR "mac80211: debugfs: failed to rename debugfs "
+		       "dir to %s\n", buf);
+}
+#endif /* CONFIG_XRMAC_DEBUGFS */
diff -Naurp a/drivers/net/wireless/xr829/umac/debugfs_netdev.h b/drivers/net/wireless/xr829/umac/debugfs_netdev.h
--- a/drivers/net/wireless/xr829/umac/debugfs_netdev.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/debugfs_netdev.h	2022-08-27 01:22:42.938539802 +0300
@@ -0,0 +1,22 @@
+/* routines exported for debugfs handling */
+
+#ifndef __IEEE80211_DEBUGFS_NETDEV_H
+#define __IEEE80211_DEBUGFS_NETDEV_H
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+void mac80211_debugfs_add_netdev(struct ieee80211_sub_if_data *sdata);
+void mac80211_debugfs_remove_netdev(struct ieee80211_sub_if_data *sdata);
+void mac80211_debugfs_rename_netdev(struct ieee80211_sub_if_data *sdata);
+#else
+static inline void mac80211_debugfs_add_netdev(
+	struct ieee80211_sub_if_data *sdata)
+{}
+static inline void mac80211_debugfs_remove_netdev(
+	struct ieee80211_sub_if_data *sdata)
+{}
+static inline void mac80211_debugfs_rename_netdev(
+	struct ieee80211_sub_if_data *sdata)
+{}
+#endif
+
+#endif /* __IEEE80211_DEBUGFS_NETDEV_H */
diff -Naurp a/drivers/net/wireless/xr829/umac/debugfs_sta.c b/drivers/net/wireless/xr829/umac/debugfs_sta.c
--- a/drivers/net/wireless/xr829/umac/debugfs_sta.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/debugfs_sta.c	2022-08-27 01:22:42.938539802 +0300
@@ -0,0 +1,392 @@
+/*
+ * Copyright 2003-2005	Devicescape Software, Inc.
+ * Copyright (c) 2006	Jiri Benc <jbenc@suse.cz>
+ * Copyright 2007	Johannes Berg <johannes@sipsolutions.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/debugfs.h>
+#include <linux/ieee80211.h>
+#include "ieee80211_i.h"
+#include "debugfs.h"
+#include "debugfs_sta.h"
+#include "sta_info.h"
+
+/* sta attributtes */
+#ifdef CONFIG_XRMAC_DEBUGFS
+
+#define STA_READ(name, field, format_string)				\
+static ssize_t sta_ ##name## _read(struct file *file,			\
+				   char __user *userbuf,		\
+				   size_t count, loff_t *ppos)		\
+{									\
+	struct sta_info *sta = file->private_data;			\
+	return xrmac_format_buffer(userbuf, count, ppos, 		\
+				      format_string, sta->field);	\
+}
+#define STA_READ_D(name, field) STA_READ(name, field, "%d\n")
+#define STA_READ_U(name, field) STA_READ(name, field, "%u\n")
+#define STA_READ_S(name, field) STA_READ(name, field, "%s\n")
+
+#define STA_OPS(name)							\
+static const struct file_operations sta_ ##name## _ops = {		\
+	.read = sta_##name##_read,					\
+	.open = mac80211_open_file_generic,				\
+	.llseek = generic_file_llseek,					\
+}
+
+#define STA_OPS_RW(name)						\
+static const struct file_operations sta_ ##name## _ops = {		\
+	.read = sta_##name##_read,					\
+	.write = sta_##name##_write,					\
+	.open = mac80211_open_file_generic,				\
+	.llseek = generic_file_llseek,					\
+}
+
+STA_READ_D(aid, sta.aid);
+STA_OPS(aid);
+
+STA_READ_S(dev, sdata->name);
+STA_OPS(dev);
+
+STA_READ_D(last_signal, last_signal);
+STA_OPS(last_signal);
+
+static ssize_t sta_flags_read(struct file *file, char __user *userbuf,
+			      size_t count, loff_t *ppos)
+{
+	char buf[121];
+	struct sta_info *sta = file->private_data;
+
+#define TEST(flg) \
+	test_sta_flag(sta, WLAN_STA_##flg) ? #flg "\n" : ""
+
+	int res = scnprintf(buf, sizeof(buf),
+			    "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
+			    TEST(AUTH), TEST(ASSOC), TEST(PS_STA),
+			    TEST(PS_DRIVER), TEST(AUTHORIZED),
+			    TEST(SHORT_PREAMBLE), TEST(ASSOC_AP),
+			    TEST(WME), TEST(WDS), TEST(CLEAR_PS_FILT),
+			    TEST(MFP), TEST(BLOCK_BA), TEST(PSPOLL),
+			    TEST(UAPSD), TEST(SP), TEST(TDLS_PEER),
+			    TEST(TDLS_PEER_AUTH));
+#undef TEST
+	return simple_read_from_buffer(userbuf, count, ppos, buf, res);
+}
+STA_OPS(flags);
+
+static ssize_t sta_num_ps_buf_frames_read(struct file *file,
+					  char __user *userbuf,
+					  size_t count, loff_t *ppos)
+{
+	struct sta_info *sta = file->private_data;
+	char buf[17*IEEE80211_NUM_ACS], *p = buf;
+	int ac;
+
+	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++)
+		p += scnprintf(p, sizeof(buf)+buf-p, "AC%d: %d\n", ac,
+			       skb_queue_len(&sta->ps_tx_buf[ac]) +
+			       skb_queue_len(&sta->tx_filtered[ac]));
+	return simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);
+}
+STA_OPS(num_ps_buf_frames);
+
+static ssize_t sta_inactive_ms_read(struct file *file, char __user *userbuf,
+				    size_t count, loff_t *ppos)
+{
+	struct sta_info *sta = file->private_data;
+	return xrmac_format_buffer(userbuf, count, ppos, "%d\n",
+				      jiffies_to_msecs(jiffies - sta->last_rx));
+}
+STA_OPS(inactive_ms);
+
+
+static ssize_t sta_connected_time_read(struct file *file, char __user *userbuf,
+					size_t count, loff_t *ppos)
+{
+	struct sta_info *sta = file->private_data;
+	struct timespec uptime;
+	struct tm result;
+	long connected_time_secs;
+	char buf[100];
+	int res;
+	ktime_get_ts(&uptime);
+	connected_time_secs = uptime.tv_sec - sta->last_connected;
+	time64_to_tm(connected_time_secs, 0, &result);
+	result.tm_year -= 70;
+	result.tm_mday -= 1;
+	res = scnprintf(buf, sizeof(buf),
+		"years  - %ld\nmonths - %d\ndays   - %d\nclock  - %d:%d:%d\n\n",
+			result.tm_year, result.tm_mon, result.tm_mday,
+			result.tm_hour, result.tm_min, result.tm_sec);
+	return simple_read_from_buffer(userbuf, count, ppos, buf, res);
+}
+STA_OPS(connected_time);
+
+
+
+static ssize_t sta_last_seq_ctrl_read(struct file *file, char __user *userbuf,
+				      size_t count, loff_t *ppos)
+{
+	char buf[15*NUM_RX_DATA_QUEUES], *p = buf;
+	int i;
+	struct sta_info *sta = file->private_data;
+	for (i = 0; i < NUM_RX_DATA_QUEUES; i++)
+		p += scnprintf(p, sizeof(buf)+buf-p, "%x ",
+			       le16_to_cpu(sta->last_seq_ctrl[i]));
+	p += scnprintf(p, sizeof(buf)+buf-p, "\n");
+	return simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);
+}
+STA_OPS(last_seq_ctrl);
+
+static ssize_t sta_agg_status_read(struct file *file, char __user *userbuf,
+					size_t count, loff_t *ppos)
+{
+	char buf[71 + STA_TID_NUM * 40], *p = buf;
+	int i;
+	struct sta_info *sta = file->private_data;
+	struct tid_ampdu_rx *tid_rx;
+	struct tid_ampdu_tx *tid_tx;
+
+	rcu_read_lock();
+
+	p += scnprintf(p, sizeof(buf) + buf - p, "next dialog_token: %#02x\n",
+			sta->ampdu_mlme.dialog_token_allocator + 1);
+	p += scnprintf(p, sizeof(buf) + buf - p,
+		       "TID\t\tRX active\tDTKN\tSSN\t\tTX\tDTKN\tpending\n");
+
+	for (i = 0; i < STA_TID_NUM; i++) {
+		tid_rx = rcu_dereference(sta->ampdu_mlme.tid_rx[i]);
+		tid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[i]);
+
+		p += scnprintf(p, sizeof(buf) + buf - p, "%02d", i);
+		p += scnprintf(p, sizeof(buf) + buf - p, "\t\t%x", !!tid_rx);
+		p += scnprintf(p, sizeof(buf) + buf - p, "\t%#.2x",
+				tid_rx ? tid_rx->dialog_token : 0);
+		p += scnprintf(p, sizeof(buf) + buf - p, "\t%#.3x",
+				tid_rx ? tid_rx->ssn : 0);
+
+		p += scnprintf(p, sizeof(buf) + buf - p, "\t\t%x", !!tid_tx);
+		p += scnprintf(p, sizeof(buf) + buf - p, "\t%#.2x",
+				tid_tx ? tid_tx->dialog_token : 0);
+		p += scnprintf(p, sizeof(buf) + buf - p, "\t%03d",
+				tid_tx ? skb_queue_len(&tid_tx->pending) : 0);
+		p += scnprintf(p, sizeof(buf) + buf - p, "\n");
+	}
+	rcu_read_unlock();
+
+	return simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);
+}
+
+static ssize_t sta_agg_status_write(struct file *file, const char __user *userbuf,
+				    size_t count, loff_t *ppos)
+{
+	char _buf[12], *buf = _buf;
+	struct sta_info *sta = file->private_data;
+	bool start, tx;
+	unsigned long tid;
+	int ret;
+
+	if (count > sizeof(_buf))
+		return -EINVAL;
+
+	if (copy_from_user(buf, userbuf, count))
+		return -EFAULT;
+
+	buf[sizeof(_buf) - 1] = '\0';
+
+	if (strncmp(buf, "tx ", 3) == 0) {
+		buf += 3;
+		tx = true;
+	} else if (strncmp(buf, "rx ", 3) == 0) {
+		buf += 3;
+		tx = false;
+	} else
+		return -EINVAL;
+
+	if (strncmp(buf, "start ", 6) == 0) {
+		buf += 6;
+		start = true;
+		if (!tx)
+			return -EINVAL;
+	} else if (strncmp(buf, "stop ", 5) == 0) {
+		buf += 5;
+		start = false;
+	} else
+		return -EINVAL;
+
+	tid = simple_strtoul(buf, NULL, 0);
+
+	if (tid >= STA_TID_NUM)
+		return -EINVAL;
+
+	if (tx) {
+		if (start)
+			ret = mac80211_start_tx_ba_session(&sta->sta, tid, 5000);
+		else
+			ret = mac80211_stop_tx_ba_session(&sta->sta, tid);
+	} else {
+		__mac80211_stop_rx_ba_session(sta, tid, WLAN_BACK_RECIPIENT,
+					       3, true);
+		ret = 0;
+	}
+
+	return ret ?: count;
+}
+STA_OPS_RW(agg_status);
+
+static ssize_t sta_ht_capa_read(struct file *file, char __user *userbuf,
+				size_t count, loff_t *ppos)
+{
+#define PRINT_HT_CAP(_cond, _str) \
+	do { \
+	if (_cond) \
+			p += scnprintf(p, sizeof(buf)+buf-p, "\t" _str "\n"); \
+	} while (0)
+	char buf[512], *p = buf;
+	int i;
+	struct sta_info *sta = file->private_data;
+	struct ieee80211_sta_ht_cap *htc = &sta->sta.ht_cap;
+
+	p += scnprintf(p, sizeof(buf) + buf - p, "ht %ssupported\n",
+			htc->ht_supported ? "" : "not ");
+	if (htc->ht_supported) {
+		p += scnprintf(p, sizeof(buf)+buf-p, "cap: %#.4x\n", htc->cap);
+
+		PRINT_HT_CAP((htc->cap & BIT(0)), "RX LDPC");
+		PRINT_HT_CAP((htc->cap & BIT(1)), "HT20/HT40");
+		PRINT_HT_CAP(!(htc->cap & BIT(1)), "HT20");
+
+		PRINT_HT_CAP(((htc->cap >> 2) & 0x3) == 0, "Static SM Power Save");
+		PRINT_HT_CAP(((htc->cap >> 2) & 0x3) == 1, "Dynamic SM Power Save");
+		PRINT_HT_CAP(((htc->cap >> 2) & 0x3) == 3, "SM Power Save disabled");
+
+		PRINT_HT_CAP((htc->cap & BIT(4)), "RX Greenfield");
+		PRINT_HT_CAP((htc->cap & BIT(5)), "RX HT20 SGI");
+		PRINT_HT_CAP((htc->cap & BIT(6)), "RX HT40 SGI");
+		PRINT_HT_CAP((htc->cap & BIT(7)), "TX STBC");
+
+		PRINT_HT_CAP(((htc->cap >> 8) & 0x3) == 0, "No RX STBC");
+		PRINT_HT_CAP(((htc->cap >> 8) & 0x3) == 1, "RX STBC 1-stream");
+		PRINT_HT_CAP(((htc->cap >> 8) & 0x3) == 2, "RX STBC 2-streams");
+		PRINT_HT_CAP(((htc->cap >> 8) & 0x3) == 3, "RX STBC 3-streams");
+
+		PRINT_HT_CAP((htc->cap & BIT(10)), "HT Delayed Block Ack");
+
+		PRINT_HT_CAP(!(htc->cap & BIT(11)), "Max AMSDU length: "
+			     "3839 bytes");
+		PRINT_HT_CAP((htc->cap & BIT(11)), "Max AMSDU length: "
+			     "7935 bytes");
+
+		/*
+		 * For beacons and probe response this would mean the BSS
+		 * does or does not allow the usage of DSSS/CCK HT40.
+		 * Otherwise it means the STA does or does not use
+		 * DSSS/CCK HT40.
+		 */
+		PRINT_HT_CAP((htc->cap & BIT(12)), "DSSS/CCK HT40");
+		PRINT_HT_CAP(!(htc->cap & BIT(12)), "No DSSS/CCK HT40");
+
+		/* BIT(13) is reserved */
+
+		PRINT_HT_CAP((htc->cap & BIT(14)), "40 MHz Intolerant");
+
+		PRINT_HT_CAP((htc->cap & BIT(15)), "L-SIG TXOP protection");
+
+		p += scnprintf(p, sizeof(buf)+buf-p, "ampdu factor/density: %d/%d\n",
+				htc->ampdu_factor, htc->ampdu_density);
+		p += scnprintf(p, sizeof(buf)+buf-p, "MCS mask:");
+
+		for (i = 0; i < IEEE80211_HT_MCS_MASK_LEN; i++)
+			p += scnprintf(p, sizeof(buf)+buf-p, " %.2x",
+					htc->mcs.rx_mask[i]);
+		p += scnprintf(p, sizeof(buf)+buf-p, "\n");
+
+		/* If not set this is meaningless */
+		if (le16_to_cpu(htc->mcs.rx_highest)) {
+			p += scnprintf(p, sizeof(buf)+buf-p,
+				       "MCS rx highest: %d Mbps\n",
+				       le16_to_cpu(htc->mcs.rx_highest));
+		}
+
+		p += scnprintf(p, sizeof(buf)+buf-p, "MCS tx params: %x\n",
+				htc->mcs.tx_params);
+	}
+
+	return simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);
+}
+STA_OPS(ht_capa);
+
+#define DEBUGFS_ADD(name) \
+	debugfs_create_file(#name, 0400, \
+		sta->debugfs.dir, sta, &sta_ ##name## _ops);
+
+#define DEBUGFS_ADD_COUNTER(name, field)				\
+do {												\
+	if (sizeof(sta->field) == sizeof(u32))				\
+		debugfs_create_u32(#name, 0400, sta->debugfs.dir,	\
+			(u32 *) &sta->field);				\
+	else								\
+		debugfs_create_u64(#name, 0400, sta->debugfs.dir,	\
+			(u64 *) &sta->field);							\
+} while (0)
+
+void mac80211_sta_debugfs_add(struct sta_info *sta)
+{
+	struct dentry *stations_dir = sta->sdata->debugfs.subdir_stations;
+	u8 mac[3*ETH_ALEN];
+
+	sta->debugfs.add_has_run = true;
+
+	if (!stations_dir)
+		return;
+
+	snprintf(mac, sizeof(mac), "%pM", sta->sta.addr);
+
+	/*
+	 * This might fail due to a race condition:
+	 * When mac80211 unlinks a station, the debugfs entries
+	 * remain, but it is already possible to link a new
+	 * station with the same address which triggers adding
+	 * it to debugfs; therefore, if the old station isn't
+	 * destroyed quickly enough the old station's debugfs
+	 * dir might still be around.
+	 */
+	sta->debugfs.dir = debugfs_create_dir(mac, stations_dir);
+	if (!sta->debugfs.dir)
+		return;
+
+	DEBUGFS_ADD(flags);
+	DEBUGFS_ADD(num_ps_buf_frames);
+	DEBUGFS_ADD(inactive_ms);
+	DEBUGFS_ADD(connected_time);
+	DEBUGFS_ADD(last_seq_ctrl);
+	DEBUGFS_ADD(agg_status);
+	DEBUGFS_ADD(dev);
+	DEBUGFS_ADD(last_signal);
+	DEBUGFS_ADD(ht_capa);
+
+	DEBUGFS_ADD_COUNTER(rx_packets, rx_packets);
+	DEBUGFS_ADD_COUNTER(tx_packets, tx_packets);
+	DEBUGFS_ADD_COUNTER(rx_bytes, rx_bytes);
+	DEBUGFS_ADD_COUNTER(tx_bytes, tx_bytes);
+	DEBUGFS_ADD_COUNTER(rx_duplicates, num_duplicates);
+	DEBUGFS_ADD_COUNTER(rx_fragments, rx_fragments);
+	DEBUGFS_ADD_COUNTER(rx_dropped, rx_dropped);
+	DEBUGFS_ADD_COUNTER(tx_fragments, tx_fragments);
+	DEBUGFS_ADD_COUNTER(tx_filtered, tx_filtered_count);
+	DEBUGFS_ADD_COUNTER(tx_retry_failed, tx_retry_failed);
+	DEBUGFS_ADD_COUNTER(tx_retry_count, tx_retry_count);
+	DEBUGFS_ADD_COUNTER(wep_weak_iv_count, wep_weak_iv_count);
+}
+
+void mac80211_sta_debugfs_remove(struct sta_info *sta)
+{
+	debugfs_remove_recursive(sta->debugfs.dir);
+	sta->debugfs.dir = NULL;
+}
+
+#endif /* CONFIG_XRMAC_DEBUGFS */
diff -Naurp a/drivers/net/wireless/xr829/umac/debugfs_sta.h b/drivers/net/wireless/xr829/umac/debugfs_sta.h
--- a/drivers/net/wireless/xr829/umac/debugfs_sta.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/debugfs_sta.h	2022-08-27 01:22:42.938539802 +0300
@@ -0,0 +1,14 @@
+#ifndef __XRMAC_DEBUGFS_STA_H
+#define __XRMAC_DEBUGFS_STA_H
+
+#include "sta_info.h"
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+void mac80211_sta_debugfs_add(struct sta_info *sta);
+void mac80211_sta_debugfs_remove(struct sta_info *sta);
+#else
+static inline void mac80211_sta_debugfs_add(struct sta_info *sta) {}
+static inline void mac80211_sta_debugfs_remove(struct sta_info *sta) {}
+#endif
+
+#endif /* __XRMAC_DEBUGFS_STA_H */
diff -Naurp a/drivers/net/wireless/xr829/umac/driver-ops.h b/drivers/net/wireless/xr829/umac/driver-ops.h
--- a/drivers/net/wireless/xr829/umac/driver-ops.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/driver-ops.h	2022-08-27 01:22:42.938539802 +0300
@@ -0,0 +1,749 @@
+#ifndef __MAC80211_DRIVER_OPS
+#define __MAC80211_DRIVER_OPS
+
+#include <net/mac80211.h>
+#include "ieee80211_i.h"
+#include "driver-trace.h"
+
+static inline void drv_tx(struct ieee80211_local *local, struct sk_buff *skb)
+{
+	local->ops->tx(&local->hw, skb);
+}
+
+static inline int drv_start(struct ieee80211_local *local)
+{
+	int ret;
+
+	might_sleep();
+
+	trace_drv_start(local);
+	local->started = true;
+	smp_mb();
+	ret = local->ops->start(&local->hw);
+	trace_drv_return_int(local, ret);
+	return ret;
+}
+
+static inline void drv_stop(struct ieee80211_local *local)
+{
+	might_sleep();
+
+	trace_drv_stop(local);
+	local->ops->stop(&local->hw);
+	trace_drv_return_void(local);
+
+	/* sync away all work on the tasklet before clearing started */
+	tasklet_disable(&local->tasklet);
+	tasklet_enable(&local->tasklet);
+
+	barrier();
+
+	local->started = false;
+}
+
+#ifdef CONFIG_PM
+static inline int drv_suspend(struct ieee80211_local *local,
+			      struct cfg80211_wowlan *wowlan)
+{
+	int ret;
+
+	might_sleep();
+
+	trace_drv_suspend(local);
+	ret = local->ops->suspend(&local->hw, wowlan);
+	trace_drv_return_int(local, ret);
+	return ret;
+}
+
+static inline int drv_resume(struct ieee80211_local *local)
+{
+	int ret;
+
+	might_sleep();
+
+	trace_drv_resume(local);
+	ret = local->ops->resume(&local->hw);
+	trace_drv_return_int(local, ret);
+	return ret;
+}
+#endif
+
+static inline int drv_add_interface(struct ieee80211_local *local,
+				    struct ieee80211_vif *vif)
+{
+	int ret;
+
+	might_sleep();
+
+	trace_drv_add_interface(local, vif_to_sdata(vif));
+	ret = local->ops->add_interface(&local->hw, vif);
+	trace_drv_return_int(local, ret);
+	return ret;
+}
+
+static inline int drv_change_interface(struct ieee80211_local *local,
+				       struct ieee80211_sub_if_data *sdata,
+				       enum nl80211_iftype type, bool p2p)
+{
+	int ret;
+
+	might_sleep();
+
+	trace_drv_change_interface(local, sdata, type, p2p);
+	ret = local->ops->change_interface(&local->hw, &sdata->vif, type, p2p);
+	trace_drv_return_int(local, ret);
+	return ret;
+}
+
+static inline void drv_remove_interface(struct ieee80211_local *local,
+					struct ieee80211_vif *vif)
+{
+	might_sleep();
+
+	trace_drv_remove_interface(local, vif_to_sdata(vif));
+	local->ops->remove_interface(&local->hw, vif);
+	trace_drv_return_void(local);
+}
+
+static inline int drv_config(struct ieee80211_local *local, u32 changed)
+{
+	int ret;
+
+	might_sleep();
+
+	trace_drv_config(local, changed);
+	ret = local->ops->config(&local->hw, changed);
+	trace_drv_return_int(local, ret);
+	return ret;
+}
+
+static inline void drv_bss_info_changed(struct ieee80211_local *local,
+					struct ieee80211_sub_if_data *sdata,
+					struct ieee80211_bss_conf *info,
+					u32 changed)
+{
+	might_sleep();
+
+	trace_drv_bss_info_changed(local, sdata, info, changed);
+	if (local->ops->bss_info_changed)
+		local->ops->bss_info_changed(&local->hw, &sdata->vif, info, changed);
+	trace_drv_return_void(local);
+}
+
+static inline int drv_tx_sync(struct ieee80211_local *local,
+			      struct ieee80211_sub_if_data *sdata,
+			      const u8 *bssid,
+			      enum ieee80211_tx_sync_type type)
+{
+	int ret = 0;
+
+	might_sleep();
+
+	trace_drv_tx_sync(local, sdata, bssid, type);
+	if (local->ops->tx_sync)
+		ret = local->ops->tx_sync(&local->hw, &sdata->vif,
+					  bssid, type);
+	trace_drv_return_int(local, ret);
+	return ret;
+}
+
+static inline void drv_finish_tx_sync(struct ieee80211_local *local,
+				      struct ieee80211_sub_if_data *sdata,
+				      const u8 *bssid,
+				      enum ieee80211_tx_sync_type type)
+{
+	might_sleep();
+
+	trace_drv_finish_tx_sync(local, sdata, bssid, type);
+	if (local->ops->finish_tx_sync)
+		local->ops->finish_tx_sync(&local->hw, &sdata->vif,
+					   bssid, type);
+	trace_drv_return_void(local);
+}
+
+static inline u64 drv_prepare_multicast(struct ieee80211_local *local,
+					struct ieee80211_sub_if_data *sdata,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
+					struct netdev_hw_addr_list *mc_list)
+#else
+					int mc_count,
+					struct dev_addr_list *mc_list)
+#endif
+{
+	u64 ret = 0;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
+	trace_drv_prepare_multicast(local, sdata, mc_list->count);
+#else
+	trace_drv_prepare_multicast(local, sdata, mc_count);
+#endif
+
+	if (local->ops->prepare_multicast)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
+		ret = local->ops->prepare_multicast(&local->hw, &sdata->vif,
+						    mc_list);
+#else
+		ret = local->ops->prepare_multicast(&local->hw, &sdata->vif,
+						    mc_count, mc_list);
+#endif
+
+	trace_drv_return_u64(local, ret);
+
+	return ret;
+}
+
+static inline void drv_configure_filter(struct ieee80211_local *local,
+					struct ieee80211_sub_if_data *sdata,
+					unsigned int changed_flags,
+					unsigned int *total_flags,
+					u64 multicast)
+{
+	might_sleep();
+
+	trace_drv_configure_filter(local, sdata, changed_flags, total_flags,
+				   multicast);
+	local->ops->configure_filter(&local->hw, &sdata->vif, changed_flags,
+				     total_flags, multicast);
+	trace_drv_return_void(local);
+}
+
+static inline int drv_set_tim(struct ieee80211_local *local,
+			      struct ieee80211_sta *sta, bool set)
+{
+	int ret = 0;
+	trace_drv_set_tim(local, sta, set);
+	if (local->ops->set_tim)
+		ret = local->ops->set_tim(&local->hw, sta, set);
+	trace_drv_return_int(local, ret);
+	return ret;
+}
+
+static inline int drv_set_key(struct ieee80211_local *local,
+			      enum set_key_cmd cmd,
+			      struct ieee80211_sub_if_data *sdata,
+			      struct ieee80211_sta *sta,
+			      struct ieee80211_key_conf *key)
+{
+	int ret;
+
+	might_sleep();
+
+	trace_drv_set_key(local, cmd, sdata, sta, key);
+	ret = local->ops->set_key(&local->hw, cmd, &sdata->vif, sta, key);
+	trace_drv_return_int(local, ret);
+	return ret;
+}
+
+static inline void drv_update_tkip_key(struct ieee80211_local *local,
+				       struct ieee80211_sub_if_data *sdata,
+				       struct ieee80211_key_conf *conf,
+				       struct sta_info *sta, u32 iv32,
+				       u16 *phase1key)
+{
+	struct ieee80211_sta *ista = NULL;
+
+	if (sta)
+		ista = &sta->sta;
+
+	trace_drv_update_tkip_key(local, sdata, conf, ista, iv32);
+	if (local->ops->update_tkip_key)
+		local->ops->update_tkip_key(&local->hw, &sdata->vif, conf,
+					    ista, iv32, phase1key);
+	trace_drv_return_void(local);
+}
+
+static inline int drv_hw_scan(struct ieee80211_local *local,
+			      struct ieee80211_sub_if_data *sdata,
+			      struct cfg80211_scan_request *req)
+{
+	int ret;
+
+	might_sleep();
+
+	trace_drv_hw_scan(local, sdata);
+	ret = local->ops->hw_scan(&local->hw, &sdata->vif, req);
+	trace_drv_return_int(local, ret);
+	return ret;
+}
+
+static inline void drv_cancel_hw_scan(struct ieee80211_local *local,
+				      struct ieee80211_sub_if_data *sdata)
+{
+	might_sleep();
+
+	trace_drv_cancel_hw_scan(local, sdata);
+	local->ops->cancel_hw_scan(&local->hw, &sdata->vif);
+	trace_drv_return_void(local);
+}
+
+static inline int
+drv_sched_scan_start(struct ieee80211_local *local,
+		     struct ieee80211_sub_if_data *sdata,
+		     struct cfg80211_sched_scan_request *req,
+		     struct ieee80211_sched_scan_ies *ies)
+{
+	int ret;
+
+	might_sleep();
+
+	trace_drv_sched_scan_start(local, sdata);
+	ret = local->ops->sched_scan_start(&local->hw, &sdata->vif,
+					      req, ies);
+	trace_drv_return_int(local, ret);
+	return ret;
+}
+
+static inline void drv_sched_scan_stop(struct ieee80211_local *local,
+				       struct ieee80211_sub_if_data *sdata)
+{
+	might_sleep();
+
+	trace_drv_sched_scan_stop(local, sdata);
+	local->ops->sched_scan_stop(&local->hw, &sdata->vif);
+	trace_drv_return_void(local);
+}
+
+static inline void drv_sw_scan_start(struct ieee80211_local *local)
+{
+	might_sleep();
+
+	trace_drv_sw_scan_start(local);
+	if (local->ops->sw_scan_start)
+		local->ops->sw_scan_start(&local->hw);
+	trace_drv_return_void(local);
+}
+
+static inline void drv_sw_scan_complete(struct ieee80211_local *local)
+{
+	might_sleep();
+
+	trace_drv_sw_scan_complete(local);
+	if (local->ops->sw_scan_complete)
+		local->ops->sw_scan_complete(&local->hw);
+	trace_drv_return_void(local);
+}
+
+static inline int drv_get_stats(struct ieee80211_local *local,
+				struct ieee80211_low_level_stats *stats)
+{
+	int ret = -EOPNOTSUPP;
+
+	might_sleep();
+
+	if (local->ops->get_stats)
+		ret = local->ops->get_stats(&local->hw, stats);
+	trace_drv_get_stats(local, stats, ret);
+
+	return ret;
+}
+
+static inline void drv_get_tkip_seq(struct ieee80211_local *local,
+				    u8 hw_key_idx, u32 *iv32, u16 *iv16)
+{
+	if (local->ops->get_tkip_seq)
+		local->ops->get_tkip_seq(&local->hw, hw_key_idx, iv32, iv16);
+	trace_drv_get_tkip_seq(local, hw_key_idx, iv32, iv16);
+}
+
+static inline int drv_set_frag_threshold(struct ieee80211_local *local,
+					u32 value)
+{
+	int ret = 0;
+
+	might_sleep();
+
+	trace_drv_set_frag_threshold(local, value);
+	if (local->ops->set_frag_threshold)
+		ret = local->ops->set_frag_threshold(&local->hw, value);
+	trace_drv_return_int(local, ret);
+	return ret;
+}
+
+static inline int drv_set_rts_threshold(struct ieee80211_local *local,
+					struct ieee80211_sub_if_data *sdata,
+					u32 value)
+{
+	int ret = 0;
+
+	might_sleep();
+
+	trace_drv_set_rts_threshold(local, sdata, value);
+	if (local->ops->set_rts_threshold)
+		ret = local->ops->set_rts_threshold(&local->hw, &sdata->vif,
+			value);
+	trace_drv_return_int(local, ret);
+	return ret;
+}
+
+static inline int drv_set_coverage_class(struct ieee80211_local *local,
+					 u8 value)
+{
+	int ret = 0;
+	might_sleep();
+
+	trace_drv_set_coverage_class(local, value);
+	if (local->ops->set_coverage_class)
+		local->ops->set_coverage_class(&local->hw, value);
+	else
+		ret = -EOPNOTSUPP;
+
+	trace_drv_return_int(local, ret);
+	return ret;
+}
+
+static inline void drv_sta_notify(struct ieee80211_local *local,
+				  struct ieee80211_sub_if_data *sdata,
+				  enum sta_notify_cmd cmd,
+				  struct ieee80211_sta *sta)
+{
+	trace_drv_sta_notify(local, sdata, cmd, sta);
+	if (local->ops->sta_notify)
+		local->ops->sta_notify(&local->hw, &sdata->vif, cmd, sta);
+	trace_drv_return_void(local);
+}
+
+static inline int drv_sta_add(struct ieee80211_local *local,
+			      struct ieee80211_sub_if_data *sdata,
+			      struct ieee80211_sta *sta)
+{
+	int ret = 0;
+
+	might_sleep();
+
+	trace_drv_sta_add(local, sdata, sta);
+	if (local->ops->sta_add)
+		ret = local->ops->sta_add(&local->hw, &sdata->vif, sta);
+
+	trace_drv_return_int(local, ret);
+
+	return ret;
+}
+
+static inline void drv_sta_remove(struct ieee80211_local *local,
+				  struct ieee80211_sub_if_data *sdata,
+				  struct ieee80211_sta *sta)
+{
+	might_sleep();
+
+	trace_drv_sta_remove(local, sdata, sta);
+	if (local->ops->sta_remove)
+		local->ops->sta_remove(&local->hw, &sdata->vif, sta);
+
+	trace_drv_return_void(local);
+}
+
+static inline int drv_conf_tx(struct ieee80211_local *local,
+			      struct ieee80211_sub_if_data *sdata, u16 ac,
+			      const struct ieee80211_tx_queue_params *params)
+{
+	int ret = -EOPNOTSUPP;
+
+	might_sleep();
+
+	trace_drv_conf_tx(local, sdata, ac, params);
+	if (local->ops->conf_tx)
+		ret = local->ops->conf_tx(&local->hw, &sdata->vif,
+					  ac, params);
+	trace_drv_return_int(local, ret);
+	return ret;
+}
+
+static inline u64 drv_get_tsf(struct ieee80211_local *local,
+			      struct ieee80211_sub_if_data *sdata)
+{
+	u64 ret = -1ULL;
+
+	might_sleep();
+
+	trace_drv_get_tsf(local, sdata);
+	if (local->ops->get_tsf)
+		ret = local->ops->get_tsf(&local->hw, &sdata->vif);
+	trace_drv_return_u64(local, ret);
+	return ret;
+}
+
+static inline void drv_set_tsf(struct ieee80211_local *local,
+			       struct ieee80211_sub_if_data *sdata,
+			       u64 tsf)
+{
+	might_sleep();
+
+	trace_drv_set_tsf(local, sdata, tsf);
+	if (local->ops->set_tsf)
+		local->ops->set_tsf(&local->hw, &sdata->vif, tsf);
+	trace_drv_return_void(local);
+}
+
+static inline void drv_reset_tsf(struct ieee80211_local *local,
+				 struct ieee80211_sub_if_data *sdata)
+{
+	might_sleep();
+
+	trace_drv_reset_tsf(local, sdata);
+	if (local->ops->reset_tsf)
+		local->ops->reset_tsf(&local->hw, &sdata->vif);
+	trace_drv_return_void(local);
+}
+
+static inline int drv_tx_last_beacon(struct ieee80211_local *local)
+{
+	int ret = 0; /* default unsuported op for less congestion */
+
+	might_sleep();
+
+	trace_drv_tx_last_beacon(local);
+	if (local->ops->tx_last_beacon)
+		ret = local->ops->tx_last_beacon(&local->hw);
+	trace_drv_return_int(local, ret);
+	return ret;
+}
+
+static inline int drv_ampdu_action(struct ieee80211_local *local,
+				   struct ieee80211_sub_if_data *sdata,
+				   enum ieee80211_ampdu_mlme_action action,
+				   struct ieee80211_sta *sta, u16 tid,
+				   u16 *ssn, u8 buf_size)
+{
+	int ret = -EOPNOTSUPP;
+
+	might_sleep();
+
+	trace_drv_ampdu_action(local, sdata, action, sta, tid, ssn, buf_size);
+
+	if (local->ops->ampdu_action)
+		ret = local->ops->ampdu_action(&local->hw, &sdata->vif, action,
+					       sta, tid, ssn, buf_size);
+
+	trace_drv_return_int(local, ret);
+
+	return ret;
+}
+
+static inline int drv_get_survey(struct ieee80211_local *local, int idx,
+				struct survey_info *survey)
+{
+	int ret = -EOPNOTSUPP;
+
+	trace_drv_get_survey(local, idx, survey);
+
+	if (local->ops->get_survey)
+		ret = local->ops->get_survey(&local->hw, idx, survey);
+
+	trace_drv_return_int(local, ret);
+
+	return ret;
+}
+
+static inline void drv_rfkill_poll(struct ieee80211_local *local)
+{
+	might_sleep();
+
+	if (local->ops->rfkill_poll)
+		local->ops->rfkill_poll(&local->hw);
+}
+
+static inline void drv_flush(struct ieee80211_local *local,
+			     struct ieee80211_sub_if_data *sdata,
+			     bool drop)
+{
+	might_sleep();
+
+	trace_drv_flush(local, sdata, drop);
+	if (local->ops->flush)
+		local->ops->flush(&local->hw, &sdata->vif, drop);
+	trace_drv_return_void(local);
+}
+
+static inline void drv_channel_switch(struct ieee80211_local *local,
+				     struct ieee80211_channel_switch *ch_switch)
+{
+	might_sleep();
+
+	trace_drv_channel_switch(local, ch_switch);
+	local->ops->channel_switch(&local->hw, ch_switch);
+	trace_drv_return_void(local);
+}
+
+
+static inline int drv_set_antenna(struct ieee80211_local *local,
+				  u32 tx_ant, u32 rx_ant)
+{
+	int ret = -EOPNOTSUPP;
+	might_sleep();
+	if (local->ops->set_antenna)
+		ret = local->ops->set_antenna(&local->hw, tx_ant, rx_ant);
+	trace_drv_set_antenna(local, tx_ant, rx_ant, ret);
+	return ret;
+}
+
+static inline int drv_get_antenna(struct ieee80211_local *local,
+				  u32 *tx_ant, u32 *rx_ant)
+{
+	int ret = -EOPNOTSUPP;
+	might_sleep();
+	if (local->ops->get_antenna)
+		ret = local->ops->get_antenna(&local->hw, tx_ant, rx_ant);
+	trace_drv_get_antenna(local, *tx_ant, *rx_ant, ret);
+	return ret;
+}
+
+static inline int drv_remain_on_channel(struct ieee80211_local *local,
+					struct ieee80211_sub_if_data *sdata,
+					struct ieee80211_channel *chan,
+					enum nl80211_channel_type chantype,
+					unsigned int duration,
+					u64 cookie)
+{
+	int ret;
+
+	might_sleep();
+
+	trace_drv_remain_on_channel(local, chan, chantype, duration);
+	ret = local->ops->remain_on_channel(&local->hw, &sdata->vif, chan,
+						chantype, duration, cookie);
+	trace_drv_return_int(local, ret);
+
+	return ret;
+}
+
+static inline int drv_cancel_remain_on_channel(struct ieee80211_local *local)
+{
+	int ret;
+
+	might_sleep();
+
+	trace_drv_cancel_remain_on_channel(local);
+	ret = local->ops->cancel_remain_on_channel(&local->hw);
+	trace_drv_return_int(local, ret);
+
+	return ret;
+}
+
+static inline int drv_set_ringparam(struct ieee80211_local *local,
+				    u32 tx, u32 rx)
+{
+	int ret = -ENOTSUPP;
+
+	might_sleep();
+
+	trace_drv_set_ringparam(local, tx, rx);
+	if (local->ops->set_ringparam)
+		ret = local->ops->set_ringparam(&local->hw, tx, rx);
+	trace_drv_return_int(local, ret);
+
+	return ret;
+}
+
+static inline void drv_get_ringparam(struct ieee80211_local *local,
+				     u32 *tx, u32 *tx_max, u32 *rx, u32 *rx_max)
+{
+	might_sleep();
+
+	trace_drv_get_ringparam(local, tx, tx_max, rx, rx_max);
+	if (local->ops->get_ringparam)
+		local->ops->get_ringparam(&local->hw, tx, tx_max, rx, rx_max);
+	trace_drv_return_void(local);
+}
+
+static inline bool drv_tx_frames_pending(struct ieee80211_local *local)
+{
+	bool ret = false;
+
+	might_sleep();
+
+	trace_drv_tx_frames_pending(local);
+	if (local->ops->tx_frames_pending)
+		ret = local->ops->tx_frames_pending(&local->hw);
+	trace_drv_return_bool(local, ret);
+
+	return ret;
+}
+
+static inline int drv_set_bitrate_mask(struct ieee80211_local *local,
+				       struct ieee80211_sub_if_data *sdata,
+				       const struct cfg80211_bitrate_mask *mask)
+{
+	int ret = -EOPNOTSUPP;
+
+	might_sleep();
+
+	trace_drv_set_bitrate_mask(local, sdata, mask);
+	if (local->ops->set_bitrate_mask)
+		ret = local->ops->set_bitrate_mask(&local->hw,
+						   &sdata->vif, mask);
+	trace_drv_return_int(local, ret);
+
+	return ret;
+}
+
+static inline void drv_set_rekey_data(struct ieee80211_local *local,
+				      struct ieee80211_sub_if_data *sdata,
+				      struct cfg80211_gtk_rekey_data *data)
+{
+	trace_drv_set_rekey_data(local, sdata, data);
+	if (local->ops->set_rekey_data)
+		local->ops->set_rekey_data(&local->hw, &sdata->vif, data);
+	trace_drv_return_void(local);
+}
+
+static inline void drv_rssi_callback(struct ieee80211_local *local,
+				     const enum ieee80211_rssi_event event)
+{
+	trace_drv_rssi_callback(local, event);
+	if (local->ops->rssi_callback)
+		local->ops->rssi_callback(&local->hw, event);
+	trace_drv_return_void(local);
+}
+
+static inline void
+drv_release_buffered_frames(struct ieee80211_local *local,
+			    struct sta_info *sta, u16 tids, int num_frames,
+			    enum ieee80211_frame_release_type reason,
+			    bool more_data)
+{
+	trace_drv_release_buffered_frames(local, &sta->sta, tids, num_frames,
+					  reason, more_data);
+	if (local->ops->release_buffered_frames)
+		local->ops->release_buffered_frames(&local->hw, &sta->sta, tids,
+						    num_frames, reason,
+						    more_data);
+	trace_drv_return_void(local);
+}
+
+static inline void
+drv_allow_buffered_frames(struct ieee80211_local *local,
+			  struct sta_info *sta, u16 tids, int num_frames,
+			  enum ieee80211_frame_release_type reason,
+			  bool more_data)
+{
+	trace_drv_allow_buffered_frames(local, &sta->sta, tids, num_frames,
+					reason, more_data);
+	if (local->ops->allow_buffered_frames)
+		local->ops->allow_buffered_frames(&local->hw, &sta->sta,
+						  tids, num_frames, reason,
+						  more_data);
+	trace_drv_return_void(local);
+}
+
+static inline void
+drv_set_data_filter(struct ieee80211_local *local,
+		    struct ieee80211_sub_if_data *sdata,
+		    void *data, int len)
+{
+	/*trace_drv_set_data_filter(local, data, len);*/
+	if (local->ops->set_data_filter)
+		local->ops->set_data_filter(&local->hw, &sdata->vif, data, len);
+
+	trace_drv_return_void(local);
+}
+
+static inline int drv_change_mac(struct ieee80211_local *local,
+				struct ieee80211_sub_if_data *sdata, struct sockaddr *sa)
+{
+	int ret = 0;
+	if (local->ops->change_mac)
+		ret = local->ops->change_mac(&local->hw, &sdata->vif, sa);
+
+	return ret;
+}
+#endif /* __MAC80211_DRIVER_OPS */
diff -Naurp a/drivers/net/wireless/xr829/umac/driver-trace.c b/drivers/net/wireless/xr829/umac/driver-trace.c
--- a/drivers/net/wireless/xr829/umac/driver-trace.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/driver-trace.c	2022-08-27 01:22:42.938539802 +0300
@@ -0,0 +1,9 @@
+/* bug in tracepoint.h, it should include this */
+#include <linux/module.h>
+
+/* sparse isn't too happy with all macros... */
+#ifndef __CHECKER__
+#include "driver-ops.h"
+#define CREATE_TRACE_POINTS
+#include "driver-trace.h"
+#endif
diff -Naurp a/drivers/net/wireless/xr829/umac/driver-trace.h b/drivers/net/wireless/xr829/umac/driver-trace.h
--- a/drivers/net/wireless/xr829/umac/driver-trace.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/driver-trace.h	2022-08-27 01:22:42.938539802 +0300
@@ -0,0 +1,1626 @@
+#if !defined(__MAC80211_DRIVER_TRACE) || defined(TRACE_HEADER_MULTI_READ)
+#define __MAC80211_DRIVER_TRACE
+
+#include <linux/tracepoint.h>
+#include <net/mac80211.h>
+#include "ieee80211_i.h"
+
+#if !defined(CONFIG_XRMAC_DRIVER_API_TRACER) || defined(__CHECKER__)
+#undef TRACE_EVENT
+#define TRACE_EVENT(name, proto, ...) \
+static inline void trace_ ## name(proto) {}
+#undef DECLARE_EVENT_CLASS
+#define DECLARE_EVENT_CLASS(...)
+#undef DEFINE_EVENT
+#define DEFINE_EVENT(evt_class, name, proto, ...) \
+static inline void trace_ ## name(proto) {}
+#endif
+
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM mac80211
+
+#define MAXNAME		32
+#define LOCAL_ENTRY	__array(char, wiphy_name, 32)
+#define LOCAL_ASSIGN	strlcpy(__entry->wiphy_name, wiphy_name(local->hw.wiphy), MAXNAME)
+#define LOCAL_PR_FMT	"%s"
+#define LOCAL_PR_ARG	__entry->wiphy_name
+
+#define STA_ENTRY	__array(char, sta_addr, ETH_ALEN)
+#define STA_ASSIGN	(sta ? memcpy(__entry->sta_addr, sta->addr, ETH_ALEN) : memset(__entry->sta_addr, 0, ETH_ALEN))
+#define STA_PR_FMT	" sta:%pM"
+#define STA_PR_ARG	__entry->sta_addr
+/*
+#define VIF_ENTRY	__field(enum nl80211_iftype, vif_type) __field(void *, sdata)	\
+			__field(bool, p2p)						\
+			__string(vif_name, sdata->dev ? sdata->dev->name : "<nodev>")
+*/
+#define VIF_ENTRY									\
+do {												\
+			__field(enum nl80211_iftype, vif_type)	\
+			__field(void *, sdata)					\
+			__field(bool, p2p)						\
+			__string(vif_name, sdata->dev ? sdata->dev->name : "<nodev>")	\
+} while (0)
+
+#define VIF_ASSIGN									\
+do {												\
+			__entry->vif_type = sdata->vif.type;	\
+			__entry->sdata = sdata;					\
+			__entry->p2p = sdata->vif.p2p;			\
+			__assign_str(vif_name, sdata->dev ? sdata->dev->name : "<nodev>");\
+} while (0)
+#define VIF_PR_FMT	" vif:%s(%d%s)"
+#define VIF_PR_ARG	__get_str(vif_name), __entry->vif_type, __entry->p2p ? "/p2p" : ""
+
+/*
+ * Tracing for driver callbacks.
+ */
+
+DECLARE_EVENT_CLASS(local_only_evt,
+	TP_PROTO(struct ieee80211_local *local),
+	TP_ARGS(local),
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+	),
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+	),
+	TP_printk(LOCAL_PR_FMT, LOCAL_PR_ARG)
+);
+
+DECLARE_EVENT_CLASS(local_sdata_addr_evt,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata),
+	TP_ARGS(local, sdata),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		VIF_ENTRY
+		__array(char, addr, 6)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		VIF_ASSIGN;
+		memcpy(__entry->addr, sdata->vif.addr, 6);
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT  VIF_PR_FMT " addr:%pM",
+		LOCAL_PR_ARG, VIF_PR_ARG, __entry->addr
+	)
+);
+
+DECLARE_EVENT_CLASS(local_u32_evt,
+	TP_PROTO(struct ieee80211_local *local, u32 value),
+	TP_ARGS(local, value),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		__field(u32, value)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		__entry->value = value;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT " value:%d",
+		LOCAL_PR_ARG, __entry->value
+	)
+);
+
+DECLARE_EVENT_CLASS(local_sdata_evt,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata),
+	TP_ARGS(local, sdata),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		VIF_ENTRY
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		VIF_ASSIGN;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT VIF_PR_FMT,
+		LOCAL_PR_ARG, VIF_PR_ARG
+	)
+);
+
+DEFINE_EVENT(local_only_evt, drv_return_void,
+	TP_PROTO(struct ieee80211_local *local),
+	TP_ARGS(local)
+);
+
+TRACE_EVENT(drv_return_int,
+	TP_PROTO(struct ieee80211_local *local, int ret),
+	TP_ARGS(local, ret),
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		__field(int, ret)
+	),
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		__entry->ret = ret;
+	),
+	TP_printk(LOCAL_PR_FMT " - %d", LOCAL_PR_ARG, __entry->ret)
+);
+
+TRACE_EVENT(drv_return_bool,
+	TP_PROTO(struct ieee80211_local *local, bool ret),
+	TP_ARGS(local, ret),
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		__field(bool, ret)
+	),
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		__entry->ret = ret;
+	),
+	TP_printk(LOCAL_PR_FMT " - %s", LOCAL_PR_ARG, (__entry->ret) ?
+		  "true" : "false")
+);
+
+TRACE_EVENT(drv_return_u64,
+	TP_PROTO(struct ieee80211_local *local, u64 ret),
+	TP_ARGS(local, ret),
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		__field(u64, ret)
+	),
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		__entry->ret = ret;
+	),
+	TP_printk(LOCAL_PR_FMT " - %llu", LOCAL_PR_ARG, __entry->ret)
+);
+
+DEFINE_EVENT(local_only_evt, drv_start,
+	TP_PROTO(struct ieee80211_local *local),
+	TP_ARGS(local)
+);
+
+DEFINE_EVENT(local_only_evt, drv_suspend,
+	TP_PROTO(struct ieee80211_local *local),
+	TP_ARGS(local)
+);
+
+DEFINE_EVENT(local_only_evt, drv_resume,
+	TP_PROTO(struct ieee80211_local *local),
+	TP_ARGS(local)
+);
+
+DEFINE_EVENT(local_only_evt, drv_stop,
+	TP_PROTO(struct ieee80211_local *local),
+	TP_ARGS(local)
+);
+
+DEFINE_EVENT(local_sdata_addr_evt, drv_add_interface,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata),
+	TP_ARGS(local, sdata)
+);
+
+TRACE_EVENT(drv_change_interface,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata,
+		 enum nl80211_iftype type, bool p2p),
+
+	TP_ARGS(local, sdata, type, p2p),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		VIF_ENTRY
+		__field(u32, new_type)
+		__field(bool, new_p2p)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		VIF_ASSIGN;
+		__entry->new_type = type;
+		__entry->new_p2p = p2p;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT  VIF_PR_FMT " new type:%d%s",
+		LOCAL_PR_ARG, VIF_PR_ARG, __entry->new_type,
+		__entry->new_p2p ? "/p2p" : ""
+	)
+);
+
+DEFINE_EVENT(local_sdata_addr_evt, drv_remove_interface,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata),
+	TP_ARGS(local, sdata)
+);
+
+TRACE_EVENT(drv_config,
+	TP_PROTO(struct ieee80211_local *local,
+		 u32 changed),
+
+	TP_ARGS(local, changed),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		__field(u32, changed)
+		__field(u32, flags)
+		__field(int, power_level)
+		__field(u8, long_frame_max_tx_count)
+		__field(u8, short_frame_max_tx_count)
+		__field(int, center_freq)
+		__field(int, channel_type)
+		__field(int, smps)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		__entry->changed = changed;
+		__entry->flags = local->hw.conf.flags;
+		__entry->power_level = local->hw.conf.power_level;
+		__entry->long_frame_max_tx_count = local->hw.conf.long_frame_max_tx_count;
+		__entry->short_frame_max_tx_count = local->hw.conf.short_frame_max_tx_count;
+		__entry->center_freq = local->chan_state.conf.channel->center_freq;
+		__entry->channel_type = local->chan_state.conf.channel_type;
+		__entry->smps = local->hw.conf.smps_mode;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT " ch:%#x freq:%d",
+		LOCAL_PR_ARG, __entry->changed, __entry->center_freq
+	)
+);
+
+TRACE_EVENT(drv_bss_info_changed,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata,
+		 struct ieee80211_bss_conf *info,
+		 u32 changed),
+
+	TP_ARGS(local, sdata, info, changed),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		VIF_ENTRY
+		__field(bool, assoc)
+		__field(u16, aid)
+		__field(bool, cts)
+		__field(bool, shortpre)
+		__field(bool, shortslot)
+		__field(u8, dtimper)
+		__field(u16, bcnint)
+		__field(u16, assoc_cap)
+		__field(u64, timestamp)
+		__field(u32, basic_rates)
+		__field(u32, changed)
+		__field(bool, enable_beacon)
+		__field(u16, ht_operation_mode)
+		__field(int, dynamic_ps_timeout)
+		__field(int, max_sleep_period)
+		__field(u16, listen_interval)
+		__field(u8, retry_short)
+		__field(u8, retry_long)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		VIF_ASSIGN;
+		__entry->changed = changed;
+		__entry->aid = info->aid;
+		__entry->assoc = info->assoc;
+		__entry->shortpre = info->use_short_preamble;
+		__entry->cts = info->use_cts_prot;
+		__entry->shortslot = info->use_short_slot;
+		__entry->dtimper = info->dtim_period;
+		__entry->bcnint = info->beacon_int;
+		__entry->assoc_cap = info->assoc_capability;
+		__entry->timestamp = info->timestamp;
+		__entry->basic_rates = info->basic_rates;
+		__entry->enable_beacon = info->enable_beacon;
+		__entry->ht_operation_mode = info->ht_operation_mode;
+		__entry->dynamic_ps_timeout = info->dynamic_ps_timeout;
+		__entry->max_sleep_period = info->max_sleep_period;
+		__entry->listen_interval = info->listen_interval;
+		__entry->retry_short = info->retry_short;
+		__entry->retry_long = info->retry_long;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT  VIF_PR_FMT " changed:%#x",
+		LOCAL_PR_ARG, VIF_PR_ARG, __entry->changed
+	)
+);
+
+DECLARE_EVENT_CLASS(tx_sync_evt,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata,
+		 const u8 *bssid,
+		 enum ieee80211_tx_sync_type type),
+	TP_ARGS(local, sdata, bssid, type),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		VIF_ENTRY
+		__array(char, bssid, ETH_ALEN)
+		__field(u32, sync_type)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		VIF_ASSIGN;
+		memcpy(__entry->bssid, bssid, ETH_ALEN);
+		__entry->sync_type = type;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT  VIF_PR_FMT " bssid:%pM type:%d",
+		LOCAL_PR_ARG, VIF_PR_ARG, __entry->bssid, __entry->sync_type
+	)
+);
+
+DEFINE_EVENT(tx_sync_evt, drv_tx_sync,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata,
+		 const u8 *bssid,
+		 enum ieee80211_tx_sync_type type),
+	TP_ARGS(local, sdata, bssid, type)
+);
+
+DEFINE_EVENT(tx_sync_evt, drv_finish_tx_sync,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata,
+		 const u8 *bssid,
+		 enum ieee80211_tx_sync_type type),
+	TP_ARGS(local, sdata, bssid, type)
+);
+
+TRACE_EVENT(drv_prepare_multicast,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata,
+		 int mc_count),
+
+	TP_ARGS(local, sdata, mc_count),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		VIF_ENTRY
+		__field(int, mc_count)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		VIF_ASSIGN;
+		__entry->mc_count = mc_count;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT VIF_PR_FMT " prepare mc (%d)",
+		LOCAL_PR_ARG, VIF_PR_ARG, __entry->mc_count
+	)
+);
+
+TRACE_EVENT(drv_configure_filter,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata,
+		 unsigned int changed_flags,
+		 unsigned int *total_flags,
+		 u64 multicast),
+
+	TP_ARGS(local, sdata, changed_flags, total_flags, multicast),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		VIF_ENTRY
+		__field(unsigned int, changed)
+		__field(unsigned int, total)
+		__field(u64, multicast)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		VIF_ASSIGN;
+		__entry->changed = changed_flags;
+		__entry->total = *total_flags;
+		__entry->multicast = multicast;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT VIF_PR_FMT " changed:%#x total:%#x",
+		LOCAL_PR_ARG, VIF_PR_ARG, __entry->changed, __entry->total
+	)
+);
+
+TRACE_EVENT(drv_set_tim,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sta *sta, bool set),
+
+	TP_ARGS(local, sta, set),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		STA_ENTRY
+		__field(bool, set)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		STA_ASSIGN;
+		__entry->set = set;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT STA_PR_FMT " set:%d",
+		LOCAL_PR_ARG, STA_PR_FMT, __entry->set
+	)
+);
+
+TRACE_EVENT(drv_set_key,
+	TP_PROTO(struct ieee80211_local *local,
+		 enum set_key_cmd cmd, struct ieee80211_sub_if_data *sdata,
+		 struct ieee80211_sta *sta,
+		 struct ieee80211_key_conf *key),
+
+	TP_ARGS(local, cmd, sdata, sta, key),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		VIF_ENTRY
+		STA_ENTRY
+		__field(u32, cipher)
+		__field(u8, hw_key_idx)
+		__field(u8, flags)
+		__field(s8, keyidx)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		VIF_ASSIGN;
+		STA_ASSIGN;
+		__entry->cipher = key->cipher;
+		__entry->flags = key->flags;
+		__entry->keyidx = key->keyidx;
+		__entry->hw_key_idx = key->hw_key_idx;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT  VIF_PR_FMT  STA_PR_FMT,
+		LOCAL_PR_ARG, VIF_PR_ARG, STA_PR_ARG
+	)
+);
+
+TRACE_EVENT(drv_update_tkip_key,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata,
+		 struct ieee80211_key_conf *conf,
+		 struct ieee80211_sta *sta, u32 iv32),
+
+	TP_ARGS(local, sdata, conf, sta, iv32),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		VIF_ENTRY
+		STA_ENTRY
+		__field(u32, iv32)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		VIF_ASSIGN;
+		STA_ASSIGN;
+		__entry->iv32 = iv32;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT VIF_PR_FMT STA_PR_FMT " iv32:%#x",
+		LOCAL_PR_ARG, VIF_PR_ARG, STA_PR_ARG, __entry->iv32
+	)
+);
+
+DEFINE_EVENT(local_sdata_evt, drv_hw_scan,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata),
+	TP_ARGS(local, sdata)
+);
+
+DEFINE_EVENT(local_sdata_evt, drv_cancel_hw_scan,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata),
+	TP_ARGS(local, sdata)
+);
+
+DEFINE_EVENT(local_sdata_evt, drv_sched_scan_start,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata),
+	TP_ARGS(local, sdata)
+);
+
+DEFINE_EVENT(local_sdata_evt, drv_sched_scan_stop,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata),
+	TP_ARGS(local, sdata)
+);
+
+DEFINE_EVENT(local_only_evt, drv_sw_scan_start,
+	TP_PROTO(struct ieee80211_local *local),
+	TP_ARGS(local)
+);
+
+DEFINE_EVENT(local_only_evt, drv_sw_scan_complete,
+	TP_PROTO(struct ieee80211_local *local),
+	TP_ARGS(local)
+);
+
+TRACE_EVENT(drv_get_stats,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_low_level_stats *stats,
+		 int ret),
+
+	TP_ARGS(local, stats, ret),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		__field(int, ret)
+		__field(unsigned int, ackfail)
+		__field(unsigned int, rtsfail)
+		__field(unsigned int, fcserr)
+		__field(unsigned int, rtssucc)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		__entry->ret = ret;
+		__entry->ackfail = stats->dot11ACKFailureCount;
+		__entry->rtsfail = stats->dot11RTSFailureCount;
+		__entry->fcserr = stats->dot11FCSErrorCount;
+		__entry->rtssucc = stats->dot11RTSSuccessCount;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT " ret:%d",
+		LOCAL_PR_ARG, __entry->ret
+	)
+);
+
+TRACE_EVENT(drv_get_tkip_seq,
+	TP_PROTO(struct ieee80211_local *local,
+		 u8 hw_key_idx, u32 *iv32, u16 *iv16),
+
+	TP_ARGS(local, hw_key_idx, iv32, iv16),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		__field(u8, hw_key_idx)
+		__field(u32, iv32)
+		__field(u16, iv16)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		__entry->hw_key_idx = hw_key_idx;
+		__entry->iv32 = *iv32;
+		__entry->iv16 = *iv16;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT, LOCAL_PR_ARG
+	)
+);
+
+DEFINE_EVENT(local_u32_evt, drv_set_frag_threshold,
+	TP_PROTO(struct ieee80211_local *local, u32 value),
+	TP_ARGS(local, value)
+);
+
+TRACE_EVENT(drv_set_rts_threshold,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata, u32 value),
+	TP_ARGS(local, sdata, value),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		VIF_ENTRY
+		__field(u32, value)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		VIF_ASSIGN;
+		__entry->value = value;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT VIF_PR_FMT " RTS:%d",
+		LOCAL_PR_ARG, VIF_PR_ARG, __entry->value
+	)
+);
+
+TRACE_EVENT(drv_set_coverage_class,
+	TP_PROTO(struct ieee80211_local *local, u8 value),
+
+	TP_ARGS(local, value),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		__field(u8, value)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		__entry->value = value;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT " value:%d",
+		LOCAL_PR_ARG, __entry->value
+	)
+);
+
+TRACE_EVENT(drv_sta_notify,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata,
+		 enum sta_notify_cmd cmd,
+		 struct ieee80211_sta *sta),
+
+	TP_ARGS(local, sdata, cmd, sta),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		VIF_ENTRY
+		STA_ENTRY
+		__field(u32, cmd)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		VIF_ASSIGN;
+		STA_ASSIGN;
+		__entry->cmd = cmd;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT  VIF_PR_FMT  STA_PR_FMT " cmd:%d",
+		LOCAL_PR_ARG, VIF_PR_ARG, STA_PR_ARG, __entry->cmd
+	)
+);
+
+TRACE_EVENT(drv_sta_add,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata,
+		 struct ieee80211_sta *sta),
+
+	TP_ARGS(local, sdata, sta),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		VIF_ENTRY
+		STA_ENTRY
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		VIF_ASSIGN;
+		STA_ASSIGN;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT  VIF_PR_FMT  STA_PR_FMT,
+		LOCAL_PR_ARG, VIF_PR_ARG, STA_PR_ARG
+	)
+);
+
+TRACE_EVENT(drv_sta_remove,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata,
+		 struct ieee80211_sta *sta),
+
+	TP_ARGS(local, sdata, sta),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		VIF_ENTRY
+		STA_ENTRY
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		VIF_ASSIGN;
+		STA_ASSIGN;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT  VIF_PR_FMT  STA_PR_FMT,
+		LOCAL_PR_ARG, VIF_PR_ARG, STA_PR_ARG
+	)
+);
+
+TRACE_EVENT(drv_conf_tx,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata,
+		 u16 ac, const struct ieee80211_tx_queue_params *params),
+
+	TP_ARGS(local, sdata, ac, params),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		VIF_ENTRY
+		__field(u16, ac)
+		__field(u16, txop)
+		__field(u16, cw_min)
+		__field(u16, cw_max)
+		__field(u8, aifs)
+		__field(bool, uapsd)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		VIF_ASSIGN;
+		__entry->ac = ac;
+		__entry->txop = params->txop;
+		__entry->cw_max = params->cw_max;
+		__entry->cw_min = params->cw_min;
+		__entry->aifs = params->aifs;
+		__entry->uapsd = params->uapsd;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT  VIF_PR_FMT  " AC:%d",
+		LOCAL_PR_ARG, VIF_PR_ARG, __entry->ac
+	)
+);
+
+DEFINE_EVENT(local_sdata_evt, drv_get_tsf,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata),
+	TP_ARGS(local, sdata)
+);
+
+TRACE_EVENT(drv_set_tsf,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata,
+		 u64 tsf),
+
+	TP_ARGS(local, sdata, tsf),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		VIF_ENTRY
+		__field(u64, tsf)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		VIF_ASSIGN;
+		__entry->tsf = tsf;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT  VIF_PR_FMT  " tsf:%llu",
+		LOCAL_PR_ARG, VIF_PR_ARG, (unsigned long long)__entry->tsf
+	)
+);
+
+DEFINE_EVENT(local_sdata_evt, drv_reset_tsf,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata),
+	TP_ARGS(local, sdata)
+);
+
+DEFINE_EVENT(local_only_evt, drv_tx_last_beacon,
+	TP_PROTO(struct ieee80211_local *local),
+	TP_ARGS(local)
+);
+
+TRACE_EVENT(drv_ampdu_action,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata,
+		 enum ieee80211_ampdu_mlme_action action,
+		 struct ieee80211_sta *sta, u16 tid,
+		 u16 *ssn, u8 buf_size),
+
+	TP_ARGS(local, sdata, action, sta, tid, ssn, buf_size),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		STA_ENTRY
+		__field(u32, action)
+		__field(u16, tid)
+		__field(u16, ssn)
+		__field(u8, buf_size)
+		VIF_ENTRY
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		VIF_ASSIGN;
+		STA_ASSIGN;
+		__entry->action = action;
+		__entry->tid = tid;
+		__entry->ssn = ssn ? *ssn : 0;
+		__entry->buf_size = buf_size;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT VIF_PR_FMT STA_PR_FMT " action:%d tid:%d buf:%d",
+		LOCAL_PR_ARG, VIF_PR_ARG, STA_PR_ARG, __entry->action,
+		__entry->tid, __entry->buf_size
+	)
+);
+
+TRACE_EVENT(drv_get_survey,
+	TP_PROTO(struct ieee80211_local *local, int idx,
+		 struct survey_info *survey),
+
+	TP_ARGS(local, idx, survey),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		__field(int, idx)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		__entry->idx = idx;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT " idx:%d",
+		LOCAL_PR_ARG, __entry->idx
+	)
+);
+
+TRACE_EVENT(drv_flush,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata,
+		 bool drop),
+
+	TP_ARGS(local, sdata, drop),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		VIF_ENTRY
+		__field(bool, drop)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		VIF_ASSIGN;
+		__entry->drop = drop;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT VIF_PR_FMT " drop:%d",
+		LOCAL_PR_ARG, VIF_PR_ARG, __entry->drop
+	)
+);
+
+TRACE_EVENT(drv_channel_switch,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_channel_switch *ch_switch),
+
+	TP_ARGS(local, ch_switch),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		__field(u64, timestamp)
+		__field(bool, block_tx)
+		__field(u16, freq)
+		__field(u8, count)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		__entry->timestamp = ch_switch->timestamp;
+		__entry->block_tx = ch_switch->block_tx;
+		__entry->freq = ch_switch->channel->center_freq;
+		__entry->count = ch_switch->count;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT " new freq:%u count:%d",
+		LOCAL_PR_ARG, __entry->freq, __entry->count
+	)
+);
+
+TRACE_EVENT(drv_set_antenna,
+	TP_PROTO(struct ieee80211_local *local, u32 tx_ant, u32 rx_ant, int ret),
+
+	TP_ARGS(local, tx_ant, rx_ant, ret),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		__field(u32, tx_ant)
+		__field(u32, rx_ant)
+		__field(int, ret)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		__entry->tx_ant = tx_ant;
+		__entry->rx_ant = rx_ant;
+		__entry->ret = ret;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT " tx_ant:%d rx_ant:%d ret:%d",
+		LOCAL_PR_ARG, __entry->tx_ant, __entry->rx_ant, __entry->ret
+	)
+);
+
+TRACE_EVENT(drv_get_antenna,
+	TP_PROTO(struct ieee80211_local *local, u32 tx_ant, u32 rx_ant, int ret),
+
+	TP_ARGS(local, tx_ant, rx_ant, ret),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		__field(u32, tx_ant)
+		__field(u32, rx_ant)
+		__field(int, ret)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		__entry->tx_ant = tx_ant;
+		__entry->rx_ant = rx_ant;
+		__entry->ret = ret;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT " tx_ant:%d rx_ant:%d ret:%d",
+		LOCAL_PR_ARG, __entry->tx_ant, __entry->rx_ant, __entry->ret
+	)
+);
+
+TRACE_EVENT(drv_remain_on_channel,
+	TP_PROTO(struct ieee80211_local *local, struct ieee80211_channel *chan,
+		 enum nl80211_channel_type chantype, unsigned int duration),
+
+	TP_ARGS(local, chan, chantype, duration),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		__field(int, center_freq)
+		__field(int, channel_type)
+		__field(unsigned int, duration)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		__entry->center_freq = chan->center_freq;
+		__entry->channel_type = chantype;
+		__entry->duration = duration;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT " freq:%dMHz duration:%dms",
+		LOCAL_PR_ARG, __entry->center_freq, __entry->duration
+	)
+);
+
+DEFINE_EVENT(local_only_evt, drv_cancel_remain_on_channel,
+	TP_PROTO(struct ieee80211_local *local),
+	TP_ARGS(local)
+);
+
+TRACE_EVENT(drv_offchannel_tx,
+	TP_PROTO(struct ieee80211_local *local, struct sk_buff *skb,
+		 struct ieee80211_channel *chan,
+		 enum nl80211_channel_type channel_type,
+		 unsigned int wait),
+
+	TP_ARGS(local, skb, chan, channel_type, wait),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		__field(int, center_freq)
+		__field(int, channel_type)
+		__field(unsigned int, wait)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		__entry->center_freq = chan->center_freq;
+		__entry->channel_type = channel_type;
+		__entry->wait = wait;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT " freq:%dMHz, wait:%dms",
+		LOCAL_PR_ARG, __entry->center_freq, __entry->wait
+	)
+);
+
+TRACE_EVENT(drv_set_ringparam,
+	TP_PROTO(struct ieee80211_local *local, u32 tx, u32 rx),
+
+	TP_ARGS(local, tx, rx),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		__field(u32, tx)
+		__field(u32, rx)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		__entry->tx = tx;
+		__entry->rx = rx;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT " tx:%d rx %d",
+		LOCAL_PR_ARG, __entry->tx, __entry->rx
+	)
+);
+
+TRACE_EVENT(drv_get_ringparam,
+	TP_PROTO(struct ieee80211_local *local, u32 *tx, u32 *tx_max,
+		 u32 *rx, u32 *rx_max),
+
+	TP_ARGS(local, tx, tx_max, rx, rx_max),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		__field(u32, tx)
+		__field(u32, tx_max)
+		__field(u32, rx)
+		__field(u32, rx_max)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		__entry->tx = *tx;
+		__entry->tx_max = *tx_max;
+		__entry->rx = *rx;
+		__entry->rx_max = *rx_max;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT " tx:%d tx_max %d rx %d rx_max %d",
+		LOCAL_PR_ARG,
+		__entry->tx, __entry->tx_max, __entry->rx, __entry->rx_max
+	)
+);
+
+DEFINE_EVENT(local_only_evt, drv_tx_frames_pending,
+	TP_PROTO(struct ieee80211_local *local),
+	TP_ARGS(local)
+);
+
+DEFINE_EVENT(local_only_evt, drv_offchannel_tx_cancel_wait,
+	TP_PROTO(struct ieee80211_local *local),
+	TP_ARGS(local)
+);
+
+TRACE_EVENT(drv_set_bitrate_mask,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata,
+		 const struct cfg80211_bitrate_mask *mask),
+
+	TP_ARGS(local, sdata, mask),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		VIF_ENTRY
+		__field(u32, legacy_2g)
+		__field(u32, legacy_5g)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		VIF_ASSIGN;
+		__entry->legacy_2g = mask->control[NL80211_BAND_2GHZ].legacy;
+		__entry->legacy_5g = mask->control[NL80211_BAND_5GHZ].legacy;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT  VIF_PR_FMT " 2G Mask:0x%x 5G Mask:0x%x",
+		LOCAL_PR_ARG, VIF_PR_ARG, __entry->legacy_2g, __entry->legacy_5g
+	)
+);
+
+TRACE_EVENT(drv_set_rekey_data,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata,
+		 struct cfg80211_gtk_rekey_data *data),
+
+	TP_ARGS(local, sdata, data),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		VIF_ENTRY
+		__array(u8, kek, NL80211_KEK_LEN)
+		__array(u8, kck, NL80211_KCK_LEN)
+		__array(u8, replay_ctr, NL80211_REPLAY_CTR_LEN)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		VIF_ASSIGN;
+		memcpy(__entry->kek, data->kek, NL80211_KEK_LEN);
+		memcpy(__entry->kck, data->kck, NL80211_KCK_LEN);
+		memcpy(__entry->replay_ctr, data->replay_ctr,
+		       NL80211_REPLAY_CTR_LEN);
+	),
+
+	TP_printk(LOCAL_PR_FMT VIF_PR_FMT,
+		  LOCAL_PR_ARG, VIF_PR_ARG)
+);
+
+TRACE_EVENT(drv_rssi_callback,
+	TP_PROTO(struct ieee80211_local *local,
+		 enum ieee80211_rssi_event rssi_event),
+
+	TP_ARGS(local, rssi_event),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		__field(u32, rssi_event)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		__entry->rssi_event = rssi_event;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT " rssi_event:%d",
+		LOCAL_PR_ARG, __entry->rssi_event
+	)
+);
+
+DECLARE_EVENT_CLASS(release_evt,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sta *sta,
+		 u16 tids, int num_frames,
+		 enum ieee80211_frame_release_type reason,
+		 bool more_data),
+
+	TP_ARGS(local, sta, tids, num_frames, reason, more_data),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		STA_ENTRY
+		__field(u16, tids)
+		__field(int, num_frames)
+		__field(int, reason)
+		__field(bool, more_data)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		STA_ASSIGN;
+		__entry->tids = tids;
+		__entry->num_frames = num_frames;
+		__entry->reason = reason;
+		__entry->more_data = more_data;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT STA_PR_FMT
+		" TIDs:0x%.4x frames:%d reason:%d more:%d",
+		LOCAL_PR_ARG, STA_PR_ARG, __entry->tids, __entry->num_frames,
+		__entry->reason, __entry->more_data
+	)
+);
+
+DEFINE_EVENT(release_evt, drv_release_buffered_frames,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sta *sta,
+		 u16 tids, int num_frames,
+		 enum ieee80211_frame_release_type reason,
+		 bool more_data),
+
+	TP_ARGS(local, sta, tids, num_frames, reason, more_data)
+);
+
+DEFINE_EVENT(release_evt, drv_allow_buffered_frames,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sta *sta,
+		 u16 tids, int num_frames,
+		 enum ieee80211_frame_release_type reason,
+		 bool more_data),
+
+	TP_ARGS(local, sta, tids, num_frames, reason, more_data)
+);
+
+/*
+ * Tracing for API calls that drivers call.
+ */
+
+TRACE_EVENT(api_start_tx_ba_session,
+	TP_PROTO(struct ieee80211_sta *sta, u16 tid),
+
+	TP_ARGS(sta, tid),
+
+	TP_STRUCT__entry(
+		STA_ENTRY
+		__field(u16, tid)
+	),
+
+	TP_fast_assign(
+		STA_ASSIGN;
+		__entry->tid = tid;
+	),
+
+	TP_printk(
+		STA_PR_FMT " tid:%d",
+		STA_PR_ARG, __entry->tid
+	)
+);
+
+TRACE_EVENT(api_start_tx_ba_cb,
+	TP_PROTO(struct ieee80211_sub_if_data *sdata, const u8 *ra, u16 tid),
+
+	TP_ARGS(sdata, ra, tid),
+
+	TP_STRUCT__entry(
+		VIF_ENTRY
+		__array(u8, ra, ETH_ALEN)
+		__field(u16, tid)
+	),
+
+	TP_fast_assign(
+		VIF_ASSIGN;
+		memcpy(__entry->ra, ra, ETH_ALEN);
+		__entry->tid = tid;
+	),
+
+	TP_printk(
+		VIF_PR_FMT " ra:%pM tid:%d",
+		VIF_PR_ARG, __entry->ra, __entry->tid
+	)
+);
+
+TRACE_EVENT(api_stop_tx_ba_session,
+	TP_PROTO(struct ieee80211_sta *sta, u16 tid),
+
+	TP_ARGS(sta, tid),
+
+	TP_STRUCT__entry(
+		STA_ENTRY
+		__field(u16, tid)
+	),
+
+	TP_fast_assign(
+		STA_ASSIGN;
+		__entry->tid = tid;
+	),
+
+	TP_printk(
+		STA_PR_FMT " tid:%d",
+		STA_PR_ARG, __entry->tid
+	)
+);
+
+TRACE_EVENT(api_stop_tx_ba_cb,
+	TP_PROTO(struct ieee80211_sub_if_data *sdata, const u8 *ra, u16 tid),
+
+	TP_ARGS(sdata, ra, tid),
+
+	TP_STRUCT__entry(
+		VIF_ENTRY
+		__array(u8, ra, ETH_ALEN)
+		__field(u16, tid)
+	),
+
+	TP_fast_assign(
+		VIF_ASSIGN;
+		memcpy(__entry->ra, ra, ETH_ALEN);
+		__entry->tid = tid;
+	),
+
+	TP_printk(
+		VIF_PR_FMT " ra:%pM tid:%d",
+		VIF_PR_ARG, __entry->ra, __entry->tid
+	)
+);
+
+DEFINE_EVENT(local_only_evt, api_restart_hw,
+	TP_PROTO(struct ieee80211_local *local),
+	TP_ARGS(local)
+);
+
+TRACE_EVENT(api_beacon_loss,
+	TP_PROTO(struct ieee80211_sub_if_data *sdata),
+
+	TP_ARGS(sdata),
+
+	TP_STRUCT__entry(
+		VIF_ENTRY
+	),
+
+	TP_fast_assign(
+		VIF_ASSIGN;
+	),
+
+	TP_printk(
+		VIF_PR_FMT,
+		VIF_PR_ARG
+	)
+);
+
+TRACE_EVENT(api_connection_loss,
+	TP_PROTO(struct ieee80211_sub_if_data *sdata),
+
+	TP_ARGS(sdata),
+
+	TP_STRUCT__entry(
+		VIF_ENTRY
+	),
+
+	TP_fast_assign(
+		VIF_ASSIGN;
+	),
+
+	TP_printk(
+		VIF_PR_FMT,
+		VIF_PR_ARG
+	)
+);
+
+TRACE_EVENT(api_cqm_rssi_notify,
+	TP_PROTO(struct ieee80211_sub_if_data *sdata,
+		 enum nl80211_cqm_rssi_threshold_event rssi_event),
+
+	TP_ARGS(sdata, rssi_event),
+
+	TP_STRUCT__entry(
+		VIF_ENTRY
+		__field(u32, rssi_event)
+	),
+
+	TP_fast_assign(
+		VIF_ASSIGN;
+		__entry->rssi_event = rssi_event;
+	),
+
+	TP_printk(
+		VIF_PR_FMT " event:%d",
+		VIF_PR_ARG, __entry->rssi_event
+	)
+);
+
+TRACE_EVENT(api_scan_completed,
+	TP_PROTO(struct ieee80211_local *local, bool aborted),
+
+	TP_ARGS(local, aborted),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		__field(bool, aborted)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		__entry->aborted = aborted;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT " aborted:%d",
+		LOCAL_PR_ARG, __entry->aborted
+	)
+);
+
+TRACE_EVENT(api_sched_scan_results,
+	TP_PROTO(struct ieee80211_local *local),
+
+	TP_ARGS(local),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT, LOCAL_PR_ARG
+	)
+);
+
+TRACE_EVENT(api_sched_scan_stopped,
+	TP_PROTO(struct ieee80211_local *local),
+
+	TP_ARGS(local),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT, LOCAL_PR_ARG
+	)
+);
+
+TRACE_EVENT(api_sta_block_awake,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sta *sta, bool block),
+
+	TP_ARGS(local, sta, block),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		STA_ENTRY
+		__field(bool, block)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		STA_ASSIGN;
+		__entry->block = block;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT STA_PR_FMT " block:%d",
+		LOCAL_PR_ARG, STA_PR_FMT, __entry->block
+	)
+);
+
+TRACE_EVENT(api_chswitch_done,
+	TP_PROTO(struct ieee80211_sub_if_data *sdata, bool success),
+
+	TP_ARGS(sdata, success),
+
+	TP_STRUCT__entry(
+		VIF_ENTRY
+		__field(bool, success)
+	),
+
+	TP_fast_assign(
+		VIF_ASSIGN;
+		__entry->success = success;
+	),
+
+	TP_printk(
+		VIF_PR_FMT " success=%d",
+		VIF_PR_ARG, __entry->success
+	)
+);
+
+DEFINE_EVENT(local_only_evt, api_ready_on_channel,
+	TP_PROTO(struct ieee80211_local *local),
+	TP_ARGS(local)
+);
+
+DEFINE_EVENT(local_only_evt, api_remain_on_channel_expired,
+	TP_PROTO(struct ieee80211_local *local),
+	TP_ARGS(local)
+);
+
+TRACE_EVENT(api_gtk_rekey_notify,
+	TP_PROTO(struct ieee80211_sub_if_data *sdata,
+		 const u8 *bssid, const u8 *replay_ctr),
+
+	TP_ARGS(sdata, bssid, replay_ctr),
+
+	TP_STRUCT__entry(
+		VIF_ENTRY
+		__array(u8, bssid, ETH_ALEN)
+		__array(u8, replay_ctr, NL80211_REPLAY_CTR_LEN)
+	),
+
+	TP_fast_assign(
+		VIF_ASSIGN;
+		memcpy(__entry->bssid, bssid, ETH_ALEN);
+		memcpy(__entry->replay_ctr, replay_ctr, NL80211_REPLAY_CTR_LEN);
+	),
+
+	TP_printk(VIF_PR_FMT, VIF_PR_ARG)
+);
+
+TRACE_EVENT(api_enable_rssi_reports,
+	TP_PROTO(struct ieee80211_sub_if_data *sdata,
+		 int rssi_min_thold, int rssi_max_thold),
+
+	TP_ARGS(sdata, rssi_min_thold, rssi_max_thold),
+
+	TP_STRUCT__entry(
+		VIF_ENTRY
+		__field(int, rssi_min_thold)
+		__field(int, rssi_max_thold)
+	),
+
+	TP_fast_assign(
+		VIF_ASSIGN;
+		__entry->rssi_min_thold = rssi_min_thold;
+		__entry->rssi_max_thold = rssi_max_thold;
+	),
+
+	TP_printk(
+		VIF_PR_FMT " rssi_min_thold =%d, rssi_max_thold = %d",
+		VIF_PR_ARG, __entry->rssi_min_thold, __entry->rssi_max_thold
+	)
+);
+
+TRACE_EVENT(api_eosp,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sta *sta),
+
+	TP_ARGS(local, sta),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		STA_ENTRY
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		STA_ASSIGN;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT STA_PR_FMT,
+		LOCAL_PR_ARG, STA_PR_FMT
+	)
+);
+
+/*
+ * Tracing for internal functions
+ * (which may also be called in response to driver calls)
+ */
+
+TRACE_EVENT(wake_queue,
+	TP_PROTO(struct ieee80211_local *local, u16 queue,
+		 enum queue_stop_reason reason),
+
+	TP_ARGS(local, queue, reason),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		__field(u16, queue)
+		__field(u32, reason)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		__entry->queue = queue;
+		__entry->reason = reason;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT " queue:%d, reason:%d",
+		LOCAL_PR_ARG, __entry->queue, __entry->reason
+	)
+);
+
+TRACE_EVENT(stop_queue,
+	TP_PROTO(struct ieee80211_local *local, u16 queue,
+		 enum queue_stop_reason reason),
+
+	TP_ARGS(local, queue, reason),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		__field(u16, queue)
+		__field(u32, reason)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		__entry->queue = queue;
+		__entry->reason = reason;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT " queue:%d, reason:%d",
+		LOCAL_PR_ARG, __entry->queue, __entry->reason
+	)
+);
+#endif /* !__MAC80211_DRIVER_TRACE || TRACE_HEADER_MULTI_READ */
+
+#undef TRACE_INCLUDE_PATH
+#define TRACE_INCLUDE_PATH .
+#undef TRACE_INCLUDE_FILE
+#define TRACE_INCLUDE_FILE driver-trace
+#include <trace/define_trace.h>
diff -Naurp a/drivers/net/wireless/xr829/umac/event.c b/drivers/net/wireless/xr829/umac/event.c
--- a/drivers/net/wireless/xr829/umac/event.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/event.c	2022-08-27 01:22:42.938539802 +0300
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2007	Johannes Berg <johannes@sipsolutions.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * mac80211 - events
+ */
+#include <net/cfg80211.h>
+#include "ieee80211_i.h"
+
+/*
+ * Indicate a failed Michael MIC to userspace. If the caller knows the TSC of
+ * the frame that generated the MIC failure (i.e., if it was provided by the
+ * driver or is still in the frame), it should provide that information.
+ */
+void xrmac_ev_michael_mic_failure(struct ieee80211_sub_if_data *sdata, int keyidx,
+				     struct ieee80211_hdr *hdr, const u8 *tsc,
+				     gfp_t gfp)
+{
+	cfg80211_michael_mic_failure(sdata->dev, hdr->addr2,
+				     (hdr->addr1[0] & 0x01) ?
+				     NL80211_KEYTYPE_GROUP :
+				     NL80211_KEYTYPE_PAIRWISE,
+				     keyidx, tsc, gfp);
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/ht.c b/drivers/net/wireless/xr829/umac/ht.c
--- a/drivers/net/wireless/xr829/umac/ht.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/ht.c	2022-08-27 01:22:42.938539802 +0300
@@ -0,0 +1,321 @@
+/*
+ * HT handling
+ *
+ * Copyright 2003, Jouni Malinen <jkmaline@cc.hut.fi>
+ * Copyright 2002-2005, Instant802 Networks, Inc.
+ * Copyright 2005-2006, Devicescape Software, Inc.
+ * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
+ * Copyright 2007, Michael Wu <flamingice@sourmilk.net>
+ * Copyright 2007-2010, Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/ieee80211.h>
+#include <linux/export.h>
+#include <net/mac80211.h>
+#include "ieee80211_i.h"
+#include "rate.h"
+
+void mac80211_ht_cap_ie_to_sta_ht_cap(struct ieee80211_supported_band *sband,
+				const struct ieee80211_ht_cap *ht_cap_ie,
+				       struct ieee80211_sta_ht_cap *ht_cap)
+{
+	u8 ampdu_info, tx_mcs_set_cap;
+	int i, max_tx_streams;
+
+	BUG_ON(!ht_cap);
+
+	memset(ht_cap, 0, sizeof(*ht_cap));
+
+	if (!ht_cap_ie || !sband->ht_cap.ht_supported)
+		return;
+
+	ht_cap->ht_supported = true;
+
+	/*
+	 * The bits listed in this expression should be
+	 * the same for the peer and us, if the station
+	 * advertises more then we can't use those thus
+	 * we mask them out.
+	 */
+
+	ht_cap->cap = le16_to_cpu(ht_cap_ie->cap_info) &
+		(sband->ht_cap.cap |
+		 ~(IEEE80211_HT_CAP_LDPC_CODING |
+		   IEEE80211_HT_CAP_SUP_WIDTH_20_40 |
+		   IEEE80211_HT_CAP_GRN_FLD |
+		   IEEE80211_HT_CAP_SGI_20 |
+		   IEEE80211_HT_CAP_SGI_40 |
+		   IEEE80211_HT_CAP_DSSSCCK40));
+	/*
+	 * The STBC bits are asymmetric -- if we don't have
+	 * TX then mask out the peer's RX and vice versa.
+	 */
+	if (!(sband->ht_cap.cap & IEEE80211_HT_CAP_TX_STBC))
+		ht_cap->cap &= ~IEEE80211_HT_CAP_RX_STBC;
+	if (!(sband->ht_cap.cap & IEEE80211_HT_CAP_RX_STBC))
+		ht_cap->cap &= ~IEEE80211_HT_CAP_TX_STBC;
+
+	ampdu_info = ht_cap_ie->ampdu_params_info;
+	ht_cap->ampdu_factor =
+		ampdu_info & IEEE80211_HT_AMPDU_PARM_FACTOR;
+	ht_cap->ampdu_density =
+		(ampdu_info & IEEE80211_HT_AMPDU_PARM_DENSITY) >> 2;
+
+	/* own MCS TX capabilities */
+	tx_mcs_set_cap = sband->ht_cap.mcs.tx_params;
+
+	/* Copy peer MCS TX capabilities, the driver might need them. */
+	ht_cap->mcs.tx_params = ht_cap_ie->mcs.tx_params;
+
+	/* can we TX with MCS rates? */
+	if (!(tx_mcs_set_cap & IEEE80211_HT_MCS_TX_DEFINED))
+		return;
+
+	/* Counting from 0, therefore +1 */
+	if (tx_mcs_set_cap & IEEE80211_HT_MCS_TX_RX_DIFF)
+		max_tx_streams =
+			((tx_mcs_set_cap & IEEE80211_HT_MCS_TX_MAX_STREAMS_MASK)
+				>> IEEE80211_HT_MCS_TX_MAX_STREAMS_SHIFT) + 1;
+	else
+		max_tx_streams = IEEE80211_HT_MCS_TX_MAX_STREAMS;
+
+	/*
+	 * 802.11n-2009 20.3.5 / 20.6 says:
+	 * - indices 0 to 7 and 32 are single spatial stream
+	 * - 8 to 31 are multiple spatial streams using equal modulation
+	 *   [8..15 for two streams, 16..23 for three and 24..31 for four]
+	 * - remainder are multiple spatial streams using unequal modulation
+	 */
+	for (i = 0; i < max_tx_streams; i++)
+		ht_cap->mcs.rx_mask[i] =
+			sband->ht_cap.mcs.rx_mask[i] & ht_cap_ie->mcs.rx_mask[i];
+
+	if (tx_mcs_set_cap & IEEE80211_HT_MCS_TX_UNEQUAL_MODULATION)
+		for (i = IEEE80211_HT_MCS_UNEQUAL_MODULATION_START_BYTE;
+		     i < IEEE80211_HT_MCS_MASK_LEN; i++)
+			ht_cap->mcs.rx_mask[i] =
+				sband->ht_cap.mcs.rx_mask[i] &
+					ht_cap_ie->mcs.rx_mask[i];
+
+	/* handle MCS rate 32 too */
+	if (sband->ht_cap.mcs.rx_mask[32/8] & ht_cap_ie->mcs.rx_mask[32/8] & 1)
+		ht_cap->mcs.rx_mask[32/8] |= 1;
+}
+
+void mac80211_sta_tear_down_BA_sessions(struct sta_info *sta, bool tx)
+{
+	int i;
+
+	cancel_work_sync(&sta->ampdu_mlme.work);
+
+	for (i = 0; i <  STA_TID_NUM; i++) {
+		__mac80211_stop_tx_ba_session(sta, i, WLAN_BACK_INITIATOR, tx);
+		__mac80211_stop_rx_ba_session(sta, i, WLAN_BACK_RECIPIENT,
+					       WLAN_REASON_QSTA_LEAVE_QBSS, tx);
+	}
+}
+
+void mac80211_ba_session_work(struct work_struct *work)
+{
+	struct sta_info *sta =
+		container_of(work, struct sta_info, ampdu_mlme.work);
+	struct tid_ampdu_tx *tid_tx;
+	int tid;
+
+	/*
+	 * When this flag is set, new sessions should be
+	 * blocked, and existing sessions will be torn
+	 * down by the code that set the flag, so this
+	 * need not run.
+	 */
+	if (test_sta_flag(sta, WLAN_STA_BLOCK_BA))
+		return;
+
+	mutex_lock(&sta->ampdu_mlme.mtx);
+	for (tid = 0; tid < STA_TID_NUM; tid++) {
+		if (test_and_clear_bit(tid, sta->ampdu_mlme.tid_rx_timer_expired))
+			___mac80211_stop_rx_ba_session(
+				sta, tid, WLAN_BACK_RECIPIENT,
+				WLAN_REASON_QSTA_TIMEOUT, true);
+
+		if (test_and_clear_bit(tid,
+				       sta->ampdu_mlme.tid_rx_stop_requested))
+			___mac80211_stop_rx_ba_session(
+				sta, tid, WLAN_BACK_RECIPIENT,
+				WLAN_REASON_UNSPECIFIED, true);
+
+		tid_tx = sta->ampdu_mlme.tid_start_tx[tid];
+		if (tid_tx) {
+			/*
+			 * Assign it over to the normal tid_tx array
+			 * where it "goes live".
+			 */
+			spin_lock_bh(&sta->lock);
+
+			sta->ampdu_mlme.tid_start_tx[tid] = NULL;
+			/* could there be a race? */
+			if (sta->ampdu_mlme.tid_tx[tid])
+				kfree(tid_tx);
+			else
+				mac80211_assign_tid_tx(sta, tid, tid_tx);
+			spin_unlock_bh(&sta->lock);
+
+			mac80211_tx_ba_session_handle_start(sta, tid);
+			continue;
+		}
+
+		tid_tx = rcu_dereference_protected_tid_tx(sta, tid);
+		if (tid_tx && test_and_clear_bit(HT_AGG_STATE_WANT_STOP,
+						 &tid_tx->state))
+			___mac80211_stop_tx_ba_session(sta, tid,
+							WLAN_BACK_INITIATOR,
+							true);
+	}
+	mutex_unlock(&sta->ampdu_mlme.mtx);
+}
+
+void mac80211_send_delba(struct ieee80211_sub_if_data *sdata,
+			  const u8 *da, u16 tid,
+			  u16 initiator, u16 reason_code)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct sk_buff *skb;
+	struct ieee80211_mgmt *mgmt;
+	u16 params;
+
+	skb = dev_alloc_skb(sizeof(*mgmt) + local->hw.extra_tx_headroom);
+	if (!skb)
+		return;
+
+	skb_reserve(skb, local->hw.extra_tx_headroom);
+	mgmt = (struct ieee80211_mgmt *) skb_put(skb, 24);
+	memset(mgmt, 0, 24);
+	memcpy(mgmt->da, da, ETH_ALEN);
+	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
+	if (sdata->vif.type == NL80211_IFTYPE_AP ||
+	    sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
+		memcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);
+	else if (sdata->vif.type == NL80211_IFTYPE_STATION)
+		memcpy(mgmt->bssid, sdata->u.mgd.bssid, ETH_ALEN);
+
+	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+					  IEEE80211_STYPE_ACTION);
+
+	skb_put(skb, 1 + sizeof(mgmt->u.action.u.delba));
+
+	mgmt->u.action.category = WLAN_CATEGORY_BACK;
+	mgmt->u.action.u.delba.action_code = WLAN_ACTION_DELBA;
+	params = (u16)(initiator << 11); 	/* bit 11 initiator */
+	params |= (u16)(tid << 12); 		/* bit 15:12 TID number */
+
+	mgmt->u.action.u.delba.params = cpu_to_le16(params);
+	mgmt->u.action.u.delba.reason_code = cpu_to_le16(reason_code);
+
+	ieee80211_tx_skb(sdata, skb);
+}
+
+void mac80211_process_delba(struct ieee80211_sub_if_data *sdata,
+			     struct sta_info *sta,
+			     struct ieee80211_mgmt *mgmt, size_t len)
+{
+	u16 tid, params;
+	u16 initiator;
+
+	params = le16_to_cpu(mgmt->u.action.u.delba.params);
+	tid = (params & IEEE80211_DELBA_PARAM_TID_MASK) >> 12;
+	initiator = (params & IEEE80211_DELBA_PARAM_INITIATOR_MASK) >> 11;
+
+#ifdef CONFIG_XRMAC_HT_DEBUG
+	if (net_ratelimit())
+		printk(KERN_DEBUG "delba from %pM (%s) tid %d reason code %d\n",
+			mgmt->sa, initiator ? "initiator" : "recipient", tid,
+			le16_to_cpu(mgmt->u.action.u.delba.reason_code));
+#endif /* CONFIG_XRMAC_HT_DEBUG */
+
+	if (initiator == WLAN_BACK_INITIATOR)
+		__mac80211_stop_rx_ba_session(sta, tid, WLAN_BACK_INITIATOR, 0,
+					       true);
+	else
+		__mac80211_stop_tx_ba_session(sta, tid, WLAN_BACK_RECIPIENT,
+					       true);
+}
+
+int mac80211_send_smps_action(struct ieee80211_sub_if_data *sdata,
+			       enum ieee80211_smps_mode smps, const u8 *da,
+			       const u8 *bssid)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct sk_buff *skb;
+	struct ieee80211_mgmt *action_frame;
+
+	/* 27 = header + category + action + smps mode */
+	skb = dev_alloc_skb(27 + local->hw.extra_tx_headroom);
+	if (!skb)
+		return -ENOMEM;
+
+	skb_reserve(skb, local->hw.extra_tx_headroom);
+	action_frame = (void *)skb_put(skb, 27);
+	memcpy(action_frame->da, da, ETH_ALEN);
+	memcpy(action_frame->sa, sdata->dev->dev_addr, ETH_ALEN);
+	memcpy(action_frame->bssid, bssid, ETH_ALEN);
+	action_frame->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+						  IEEE80211_STYPE_ACTION);
+	action_frame->u.action.category = WLAN_CATEGORY_HT;
+	action_frame->u.action.u.ht_smps.action = WLAN_HT_ACTION_SMPS;
+	switch (smps) {
+	case IEEE80211_SMPS_AUTOMATIC:
+	case IEEE80211_SMPS_NUM_MODES:
+		WARN_ON(1);
+	case IEEE80211_SMPS_OFF:
+		action_frame->u.action.u.ht_smps.smps_control =
+				WLAN_HT_SMPS_CONTROL_DISABLED;
+		break;
+	case IEEE80211_SMPS_STATIC:
+		action_frame->u.action.u.ht_smps.smps_control =
+				WLAN_HT_SMPS_CONTROL_STATIC;
+		break;
+	case IEEE80211_SMPS_DYNAMIC:
+		action_frame->u.action.u.ht_smps.smps_control =
+				WLAN_HT_SMPS_CONTROL_DYNAMIC;
+		break;
+	}
+
+	/* we'll do more on status of this frame */
+	IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;
+	ieee80211_tx_skb(sdata, skb);
+
+	return 0;
+}
+
+void mac80211_request_smps_work(struct work_struct *work)
+{
+	struct ieee80211_sub_if_data *sdata =
+		container_of(work, struct ieee80211_sub_if_data,
+			     u.mgd.request_smps_work);
+
+	mutex_lock(&sdata->u.mgd.mtx);
+	__mac80211_request_smps(sdata, sdata->u.mgd.driver_smps_mode);
+	mutex_unlock(&sdata->u.mgd.mtx);
+}
+
+void mac80211_request_smps(struct ieee80211_vif *vif,
+			    enum ieee80211_smps_mode smps_mode)
+{
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+
+	if (WARN_ON(vif->type != NL80211_IFTYPE_STATION))
+		return;
+
+	if (WARN_ON(smps_mode == IEEE80211_SMPS_OFF))
+		smps_mode = IEEE80211_SMPS_AUTOMATIC;
+
+	sdata->u.mgd.driver_smps_mode = smps_mode;
+
+	mac80211_queue_work(&sdata->local->hw,
+			     &sdata->u.mgd.request_smps_work);
+}
+/* this might change ... don't want non-open drivers using it */
diff -Naurp a/drivers/net/wireless/xr829/umac/ibss.c b/drivers/net/wireless/xr829/umac/ibss.c
--- a/drivers/net/wireless/xr829/umac/ibss.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/ibss.c	2022-08-27 01:22:42.942539817 +0300
@@ -0,0 +1,1012 @@
+/*
+ * IBSS mode implementation
+ * Copyright 2003-2008, Jouni Malinen <j@w1.fi>
+ * Copyright 2004, Instant802 Networks, Inc.
+ * Copyright 2005, Devicescape Software, Inc.
+ * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
+ * Copyright 2007, Michael Wu <flamingice@sourmilk.net>
+ * Copyright 2009, Johannes Berg <johannes@sipsolutions.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/if_ether.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/etherdevice.h>
+#include <linux/rtnetlink.h>
+#include <net/mac80211.h>
+#include <asm/unaligned.h>
+
+#include "ieee80211_i.h"
+#include "driver-ops.h"
+#include "rate.h"
+
+#define IEEE80211_SCAN_INTERVAL (2 * HZ)
+#define IEEE80211_SCAN_INTERVAL_SLOW (15 * HZ)
+#define IEEE80211_IBSS_JOIN_TIMEOUT (7 * HZ)
+
+#define IEEE80211_IBSS_MERGE_INTERVAL (30 * HZ)
+#define IEEE80211_IBSS_INACTIVITY_LIMIT (60 * HZ)
+
+#define IEEE80211_IBSS_MAX_STA_ENTRIES 128
+
+
+static void ieee80211_rx_mgmt_auth_ibss(struct ieee80211_sub_if_data *sdata,
+					struct ieee80211_mgmt *mgmt,
+					size_t len)
+{
+	u16 auth_alg, auth_transaction;
+
+	lockdep_assert_held(&sdata->u.ibss.mtx);
+
+	if (len < 24 + 6)
+		return;
+
+	auth_alg = le16_to_cpu(mgmt->u.auth.auth_alg);
+	auth_transaction = le16_to_cpu(mgmt->u.auth.auth_transaction);
+
+	/*
+	 * IEEE 802.11 standard does not require authentication in IBSS
+	 * networks and most implementations do not seem to use it.
+	 * However, try to reply to authentication attempts if someone
+	 * has actually implemented this.
+	 */
+	if (auth_alg == WLAN_AUTH_OPEN && auth_transaction == 1)
+		mac80211_send_auth(sdata, 2, WLAN_AUTH_OPEN, NULL, 0,
+				    sdata->u.ibss.bssid, NULL, 0, 0);
+}
+
+static void __ieee80211_sta_join_ibss(struct ieee80211_sub_if_data *sdata,
+				      const u8 *bssid, const int beacon_int,
+				      struct ieee80211_channel *chan,
+				      const u32 basic_rates,
+				      const u16 capability, u64 tsf)
+{
+	struct ieee80211_if_ibss *ifibss = &sdata->u.ibss;
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sdata);
+	int rates, i;
+	struct sk_buff *skb;
+	struct ieee80211_mgmt *mgmt;
+	u8 *pos;
+	struct ieee80211_supported_band *sband;
+	struct cfg80211_bss *bss;
+	u32 bss_change;
+	u8 supp_rates[IEEE80211_MAX_SUPP_RATES];
+
+	lockdep_assert_held(&ifibss->mtx);
+
+	/* Reset own TSF to allow time synchronization work. */
+	drv_reset_tsf(local, sdata);
+
+	skb = ifibss->skb;
+	RCU_INIT_POINTER(ifibss->presp, NULL);
+	synchronize_rcu();
+	skb->data = skb->head;
+	skb->len = 0;
+	skb_reset_tail_pointer(skb);
+	skb_reserve(skb, sdata->local->hw.extra_tx_headroom);
+
+	if (memcmp(ifibss->bssid, bssid, ETH_ALEN))
+		xrmac_sta_info_flush(sdata->local, sdata);
+
+	/* if merging, indicate to driver that we leave the old IBSS */
+	if (sdata->vif.bss_conf.ibss_joined) {
+		sdata->vif.bss_conf.ibss_joined = false;
+		mac80211_bss_info_change_notify(sdata, BSS_CHANGED_IBSS);
+	}
+
+	memcpy(ifibss->bssid, bssid, ETH_ALEN);
+
+	sdata->drop_unencrypted = capability & WLAN_CAPABILITY_PRIVACY ? 1 : 0;
+
+	chan_state->oper_channel = chan;
+	WARN_ON(!mac80211_set_channel_type(local, sdata, NL80211_CHAN_NO_HT));
+	mac80211_hw_config(local, IEEE80211_CONF_CHANGE_CHANNEL);
+
+	sband = local->hw.wiphy->bands[chan->band];
+
+	/* build supported rates array */
+	pos = supp_rates;
+	for (i = 0; i < sband->n_bitrates; i++) {
+		int rate = sband->bitrates[i].bitrate;
+		u8 basic = 0;
+		if (basic_rates & BIT(i))
+			basic = 0x80;
+		*pos++ = basic | (u8) (rate / 5);
+	}
+
+	/* Build IBSS probe response */
+	mgmt = (void *) skb_put(skb, 24 + sizeof(mgmt->u.beacon));
+	memset(mgmt, 0, 24 + sizeof(mgmt->u.beacon));
+	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+					  IEEE80211_STYPE_PROBE_RESP);
+	memset(mgmt->da, 0xff, ETH_ALEN);
+	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
+	memcpy(mgmt->bssid, ifibss->bssid, ETH_ALEN);
+	mgmt->u.beacon.beacon_int = cpu_to_le16(beacon_int);
+	mgmt->u.beacon.timestamp = cpu_to_le64(tsf);
+	mgmt->u.beacon.capab_info = cpu_to_le16(capability);
+
+	pos = skb_put(skb, 2 + ifibss->ssid_len);
+	*pos++ = WLAN_EID_SSID;
+	*pos++ = ifibss->ssid_len;
+	memcpy(pos, ifibss->ssid, ifibss->ssid_len);
+
+	rates = sband->n_bitrates;
+	if (rates > 8)
+		rates = 8;
+	pos = skb_put(skb, 2 + rates);
+	*pos++ = WLAN_EID_SUPP_RATES;
+	*pos++ = rates;
+	memcpy(pos, supp_rates, rates);
+
+	if (sband->band == NL80211_BAND_2GHZ) {
+		pos = skb_put(skb, 2 + 1);
+		*pos++ = WLAN_EID_DS_PARAMS;
+		*pos++ = 1;
+		*pos++ = ieee80211_frequency_to_channel(chan->center_freq);
+	}
+
+	pos = skb_put(skb, 2 + 2);
+	*pos++ = WLAN_EID_IBSS_PARAMS;
+	*pos++ = 2;
+	/* FIX: set ATIM window based on scan results */
+	*pos++ = 0;
+	*pos++ = 0;
+
+	if (sband->n_bitrates > 8) {
+		rates = sband->n_bitrates - 8;
+		pos = skb_put(skb, 2 + rates);
+		*pos++ = WLAN_EID_EXT_SUPP_RATES;
+		*pos++ = rates;
+		memcpy(pos, &supp_rates[8], rates);
+	}
+
+	if (ifibss->ie_len)
+		memcpy(skb_put(skb, ifibss->ie_len),
+		       ifibss->ie, ifibss->ie_len);
+
+	if (local->hw.queues >= IEEE80211_NUM_ACS) {
+		pos = skb_put(skb, 9);
+		*pos++ = WLAN_EID_VENDOR_SPECIFIC;
+		*pos++ = 7; /* len */
+		*pos++ = 0x00; /* Microsoft OUI 00:50:F2 */
+		*pos++ = 0x50;
+		*pos++ = 0xf2;
+		*pos++ = 2; /* WME */
+		*pos++ = 0; /* WME info */
+		*pos++ = 1; /* WME ver */
+		*pos++ = 0; /* U-APSD no in use */
+	}
+
+	rcu_assign_pointer(ifibss->presp, skb);
+
+	sdata->vif.bss_conf.beacon_int = beacon_int;
+	sdata->vif.bss_conf.basic_rates = basic_rates;
+	bss_change = BSS_CHANGED_BEACON_INT;
+	bss_change |= mac80211_reset_erp_info(sdata);
+	bss_change |= BSS_CHANGED_BSSID;
+	bss_change |= BSS_CHANGED_BEACON;
+	bss_change |= BSS_CHANGED_BEACON_ENABLED;
+	bss_change |= BSS_CHANGED_BASIC_RATES;
+	bss_change |= BSS_CHANGED_IBSS;
+	sdata->vif.bss_conf.ibss_joined = true;
+	mac80211_bss_info_change_notify(sdata, bss_change);
+
+	mac80211_sta_def_wmm_params(sdata, sband->n_bitrates, supp_rates);
+
+	ifibss->state = IEEE80211_IBSS_MLME_JOINED;
+	mod_timer(&ifibss->timer,
+		  round_jiffies(jiffies + IEEE80211_IBSS_MERGE_INTERVAL));
+
+	bss = cfg80211_inform_bss_frame(local->hw.wiphy, chan_state->conf.channel,
+					mgmt, skb->len, 0, GFP_KERNEL);
+	cfg80211_put_bss(local->hw.wiphy, bss);
+	cfg80211_ibss_joined(sdata->dev, ifibss->bssid, chan, GFP_KERNEL);
+}
+
+static void ieee80211_sta_join_ibss(struct ieee80211_sub_if_data *sdata,
+				    struct ieee80211_bss *bss)
+{
+	struct cfg80211_bss *cbss =
+		container_of((void *)bss, struct cfg80211_bss, priv);
+	struct ieee80211_supported_band *sband;
+	u32 basic_rates;
+	int i, j;
+	u16 beacon_int = cbss->beacon_interval;
+
+	lockdep_assert_held(&sdata->u.ibss.mtx);
+
+	if (beacon_int < 10)
+		beacon_int = 10;
+
+	sband = sdata->local->hw.wiphy->bands[cbss->channel->band];
+
+	basic_rates = 0;
+
+	for (i = 0; i < bss->supp_rates_len; i++) {
+		int rate = (bss->supp_rates[i] & 0x7f) * 5;
+		bool is_basic = !!(bss->supp_rates[i] & 0x80);
+
+		for (j = 0; j < sband->n_bitrates; j++) {
+			if (sband->bitrates[j].bitrate == rate) {
+				if (is_basic)
+					basic_rates |= BIT(j);
+				break;
+			}
+		}
+	}
+
+	__ieee80211_sta_join_ibss(sdata, cbss->bssid,
+				  beacon_int,
+				  cbss->channel,
+				  basic_rates,
+				  cbss->capability,
+				  0);
+}
+
+static void ieee80211_rx_bss_info(struct ieee80211_sub_if_data *sdata,
+				  struct ieee80211_mgmt *mgmt,
+				  size_t len,
+				  struct ieee80211_rx_status *rx_status,
+				  struct ieee802_11_elems *elems,
+				  bool beacon)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sdata);
+	int freq;
+	struct cfg80211_bss *cbss;
+	struct ieee80211_bss *bss;
+	struct sta_info *sta;
+	struct ieee80211_channel *channel;
+	u64 beacon_timestamp, rx_timestamp;
+	u32 supp_rates = 0;
+	enum nl80211_band band = rx_status->band;
+
+	if (elems->ds_params && elems->ds_params_len == 1)
+		freq = ieee80211_channel_to_frequency(elems->ds_params[0],
+						      band);
+	else
+		freq = rx_status->freq;
+
+	channel = ieee80211_get_channel(local->hw.wiphy, freq);
+
+	if (!channel || channel->flags & IEEE80211_CHAN_DISABLED)
+		return;
+
+	if (sdata->vif.type == NL80211_IFTYPE_ADHOC &&
+	    memcmp(mgmt->bssid, sdata->u.ibss.bssid, ETH_ALEN) == 0) {
+
+		rcu_read_lock();
+		sta = xrmac_sta_info_get(sdata, mgmt->sa);
+
+		if (elems->supp_rates) {
+			supp_rates = mac80211_sta_get_rates(local, elems,
+							     band);
+			if (sta) {
+				u32 prev_rates;
+
+				prev_rates = sta->sta.supp_rates[band];
+				/* make sure mandatory rates are always added */
+				sta->sta.supp_rates[band] = supp_rates |
+					mac80211_mandatory_rates(local, band);
+
+				if (sta->sta.supp_rates[band] != prev_rates) {
+#ifdef CONFIG_XRMAC_IBSS_DEBUG
+					printk(KERN_DEBUG
+						"%s: updated supp_rates set "
+						"for %pM based on beacon"
+						"/probe_resp (0x%x -> 0x%x)\n",
+						sdata->name, sta->sta.addr,
+						prev_rates,
+						sta->sta.supp_rates[band]);
+#endif
+					rate_control_rate_init(sta);
+				}
+			} else
+				sta = ieee80211_ibss_add_sta(sdata, mgmt->bssid,
+						mgmt->sa, supp_rates,
+						GFP_ATOMIC);
+		}
+
+		if (sta && elems->wmm_info)
+			set_sta_flag(sta, WLAN_STA_WME);
+
+		rcu_read_unlock();
+	}
+
+	bss = mac80211_bss_info_update(local, rx_status, mgmt, len, elems,
+					channel, beacon);
+	if (!bss)
+		return;
+
+	cbss = container_of((void *)bss, struct cfg80211_bss, priv);
+
+	/* was just updated in ieee80211_bss_info_update */
+	/*beacon_timestamp = cbss->tsf;*/
+	beacon_timestamp = 0;
+	/* check if we need to merge IBSS */
+
+	/* we use a fixed BSSID */
+	if (sdata->u.ibss.fixed_bssid)
+		goto put_bss;
+
+	/* not an IBSS */
+	if (!(cbss->capability & WLAN_CAPABILITY_IBSS))
+		goto put_bss;
+
+	/* different channel */
+	if (cbss->channel != chan_state->oper_channel)
+		goto put_bss;
+
+	/* different SSID */
+	if (elems->ssid_len != sdata->u.ibss.ssid_len ||
+	    memcmp(elems->ssid, sdata->u.ibss.ssid,
+				sdata->u.ibss.ssid_len))
+		goto put_bss;
+
+	/* same BSSID */
+	if (memcmp(cbss->bssid, sdata->u.ibss.bssid, ETH_ALEN) == 0)
+		goto put_bss;
+
+	if (rx_status->flag & RX_FLAG_MACTIME_MPDU) {
+		/*
+		 * For correct IBSS merging we need mactime; since mactime is
+		 * defined as the time the first data symbol of the frame hits
+		 * the PHY, and the timestamp of the beacon is defined as "the
+		 * time that the data symbol containing the first bit of the
+		 * timestamp is transmitted to the PHY plus the transmitting
+		 * STA's delays through its local PHY from the MAC-PHY
+		 * interface to its interface with the WM" (802.11 11.1.2)
+		 * - equals the time this bit arrives at the receiver - we have
+		 * to take into account the offset between the two.
+		 *
+		 * E.g. at 1 MBit that means mactime is 192 usec earlier
+		 * (=24 bytes * 8 usecs/byte) than the beacon timestamp.
+		 */
+		int rate;
+
+		if (rx_status->flag & RX_FLAG_HT)
+			rate = 65; /* TODO: HT rates */
+		else
+			rate = local->hw.wiphy->bands[band]->
+				bitrates[rx_status->rate_idx].bitrate;
+
+		rx_timestamp = rx_status->mactime + (24 * 8 * 10 / rate);
+	} else {
+		/*
+		 * second best option: get current TSF
+		 * (will return -1 if not supported)
+		 */
+		rx_timestamp = drv_get_tsf(local, sdata);
+	}
+
+#ifdef CONFIG_XRMAC_IBSS_DEBUG
+	printk(KERN_DEBUG "RX beacon SA=%pM BSSID="
+	       "%pM TSF=0x%llx BCN=0x%llx diff=%lld @%lu\n",
+	       mgmt->sa, mgmt->bssid,
+	       (unsigned long long)rx_timestamp,
+	       (unsigned long long)beacon_timestamp,
+	       (unsigned long long)(rx_timestamp - beacon_timestamp),
+	       jiffies);
+#endif
+
+	if (beacon_timestamp > rx_timestamp) {
+#ifdef CONFIG_XRMAC_IBSS_DEBUG
+		printk(KERN_DEBUG "%s: beacon TSF higher than "
+		       "local TSF - IBSS merge with BSSID %pM\n",
+		       sdata->name, mgmt->bssid);
+#endif
+		ieee80211_sta_join_ibss(sdata, bss);
+		supp_rates = mac80211_sta_get_rates(local, elems, band);
+		ieee80211_ibss_add_sta(sdata, mgmt->bssid, mgmt->sa,
+				       supp_rates, GFP_KERNEL);
+	}
+
+ put_bss:
+	mac80211_rx_bss_put(local, bss);
+}
+
+/*
+ * Add a new IBSS station, will also be called by the RX code when,
+ * in IBSS mode, receiving a frame from a yet-unknown station, hence
+ * must be callable in atomic context.
+ */
+struct sta_info *ieee80211_ibss_add_sta(struct ieee80211_sub_if_data *sdata,
+					u8 *bssid, u8 *addr, u32 supp_rates,
+					gfp_t gfp)
+{
+	struct ieee80211_if_ibss *ifibss = &sdata->u.ibss;
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sdata);
+	struct sta_info *sta;
+	int band = chan_state->conf.channel->band;
+
+	/*
+	 * XXX: Consider removing the least recently used entry and
+	 * 	allow new one to be added.
+	 */
+	if (local->num_sta >= IEEE80211_IBSS_MAX_STA_ENTRIES) {
+		if (net_ratelimit())
+			printk(KERN_DEBUG "%s: No room for a new IBSS STA entry %pM\n",
+			       sdata->name, addr);
+		return NULL;
+	}
+
+	if (ifibss->state == IEEE80211_IBSS_MLME_SEARCH)
+		return NULL;
+
+	if (compare_ether_addr(bssid, sdata->u.ibss.bssid))
+		return NULL;
+
+#ifdef CONFIG_XRMAC_VERBOSE_DEBUG
+	wiphy_debug(local->hw.wiphy, "Adding new IBSS station %pM (dev=%s)\n",
+		    addr, sdata->name);
+#endif
+
+	sta = xrmac_sta_info_alloc(sdata, addr, gfp);
+	if (!sta)
+		return NULL;
+
+	sta->last_rx = jiffies;
+	set_sta_flag(sta, WLAN_STA_AUTHORIZED);
+
+	/* make sure mandatory rates are always added */
+	sta->sta.supp_rates[band] = supp_rates |
+			mac80211_mandatory_rates(local, band);
+
+	rate_control_rate_init(sta);
+
+	/* If it fails, maybe we raced another insertion? */
+	if (xrmac_sta_info_insert(sta))
+		return xrmac_sta_info_get(sdata, addr);
+	return sta;
+}
+
+static int ieee80211_sta_active_ibss(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_local *local = sdata->local;
+	int active = 0;
+	struct sta_info *sta;
+
+	lockdep_assert_held(&sdata->u.ibss.mtx);
+
+	rcu_read_lock();
+
+	list_for_each_entry_rcu(sta, &local->sta_list, list) {
+		if (sta->sdata == sdata &&
+		    time_after(sta->last_rx + IEEE80211_IBSS_MERGE_INTERVAL,
+			       jiffies)) {
+			active++;
+			break;
+		}
+	}
+
+	rcu_read_unlock();
+
+	return active;
+}
+
+/*
+ * This function is called with state == IEEE80211_IBSS_MLME_JOINED
+ */
+
+static void ieee80211_sta_merge_ibss(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_ibss *ifibss = &sdata->u.ibss;
+
+	lockdep_assert_held(&ifibss->mtx);
+
+	mod_timer(&ifibss->timer,
+		  round_jiffies(jiffies + IEEE80211_IBSS_MERGE_INTERVAL));
+
+	mac80211_sta_expire(sdata, IEEE80211_IBSS_INACTIVITY_LIMIT);
+
+	if (time_before(jiffies, ifibss->last_scan_completed +
+		       IEEE80211_IBSS_MERGE_INTERVAL))
+		return;
+
+	if (ieee80211_sta_active_ibss(sdata))
+		return;
+
+	if (ifibss->fixed_channel)
+		return;
+
+	printk(KERN_DEBUG "%s: No active IBSS STAs - trying to scan for other "
+	       "IBSS networks with same SSID (merge)\n", sdata->name);
+
+	ieee80211_request_internal_scan(sdata,
+			ifibss->ssid, ifibss->ssid_len,
+			ifibss->fixed_channel ? ifibss->channel : NULL);
+}
+
+static void ieee80211_sta_create_ibss(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_ibss *ifibss = &sdata->u.ibss;
+	u8 bssid[ETH_ALEN];
+	u16 capability;
+	int i;
+
+	lockdep_assert_held(&ifibss->mtx);
+
+	if (ifibss->fixed_bssid) {
+		memcpy(bssid, ifibss->bssid, ETH_ALEN);
+	} else {
+		/* Generate random, not broadcast, locally administered BSSID. Mix in
+		 * own MAC address to make sure that devices that do not have proper
+		 * random number generator get different BSSID. */
+		get_random_bytes(bssid, ETH_ALEN);
+		for (i = 0; i < ETH_ALEN; i++)
+			bssid[i] ^= sdata->vif.addr[i];
+		bssid[0] &= ~0x01;
+		bssid[0] |= 0x02;
+	}
+
+	printk(KERN_DEBUG "%s: Creating new IBSS network, BSSID %pM\n",
+	       sdata->name, bssid);
+
+	capability = WLAN_CAPABILITY_IBSS;
+
+	if (ifibss->privacy)
+		capability |= WLAN_CAPABILITY_PRIVACY;
+	else
+		sdata->drop_unencrypted = 0;
+
+	__ieee80211_sta_join_ibss(sdata, bssid, sdata->vif.bss_conf.beacon_int,
+				  ifibss->channel, ifibss->basic_rates,
+				  capability, 0);
+}
+
+/*
+ * This function is called with state == IEEE80211_IBSS_MLME_SEARCH
+ */
+
+static void ieee80211_sta_find_ibss(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_ibss *ifibss = &sdata->u.ibss;
+	struct ieee80211_local *local = sdata->local;
+	//struct ieee80211_channel_state *chan_state = &local->chan_state;
+	struct cfg80211_bss *cbss;
+	struct ieee80211_channel *chan = NULL;
+	const u8 *bssid = NULL;
+	int active_ibss;
+
+	lockdep_assert_held(&ifibss->mtx);
+
+	active_ibss = ieee80211_sta_active_ibss(sdata);
+#ifdef CONFIG_XRMAC_IBSS_DEBUG
+	printk(KERN_DEBUG "%s: sta_find_ibss (active_ibss=%d)\n",
+	       sdata->name, active_ibss);
+#endif /* CONFIG_XRMAC_IBSS_DEBUG */
+
+	if (active_ibss)
+		return;
+
+	if (ifibss->fixed_bssid)
+		bssid = ifibss->bssid;
+	if (ifibss->fixed_channel)
+		chan = ifibss->channel;
+	if (!is_zero_ether_addr(ifibss->bssid))
+		bssid = ifibss->bssid;
+	cbss = cfg80211_get_bss(local->hw.wiphy, chan, bssid,
+				ifibss->ssid, ifibss->ssid_len,
+				IEEE80211_BSS_TYPE_IBSS, IEEE80211_PRIVACY(ifibss->privacy));
+	if (cbss) {
+		struct ieee80211_bss *bss;
+
+		bss = (void *)cbss->priv;
+#ifdef CONFIG_XRMAC_IBSS_DEBUG
+		printk(KERN_DEBUG "   sta_find_ibss: selected %pM current "
+		       "%pM\n", cbss->bssid, ifibss->bssid);
+#endif /* CONFIG_XRMAC_IBSS_DEBUG */
+
+		printk(KERN_DEBUG "%s: Selected IBSS BSSID %pM"
+		       " based on configured SSID\n",
+		       sdata->name, cbss->bssid);
+
+		ieee80211_sta_join_ibss(sdata, bss);
+		mac80211_rx_bss_put(local, bss);
+		return;
+	}
+
+	/* if a fixed bssid and a fixed freq have been provided create the IBSS
+	 * directly and do not waste time scanning
+	 */
+	if (ifibss->fixed_bssid && ifibss->fixed_channel) {
+#ifdef CONFIG_XRMAC_IBSS_DEBUG
+		printk(KERN_DEBUG "Created IBSS using preconfigured BSSID %pM\n",
+			bssid);
+#endif /* CONFIG_XRMAC_IBSS_DEBUG */
+		ieee80211_sta_create_ibss(sdata);
+		return;
+	}
+
+#ifdef CONFIG_XRMAC_IBSS_DEBUG
+	printk(KERN_DEBUG "   did not try to join ibss\n");
+#endif /* CONFIG_XRMAC_IBSS_DEBUG */
+
+	/* Selected IBSS not found in current scan results - try to scan */
+	if (time_after(jiffies, ifibss->last_scan_completed +
+					IEEE80211_SCAN_INTERVAL)) {
+		printk(KERN_DEBUG "%s: Trigger new scan to find an IBSS to "
+		       "join\n", sdata->name);
+
+		ieee80211_request_internal_scan(sdata,
+				ifibss->ssid, ifibss->ssid_len,
+				ifibss->fixed_channel ? ifibss->channel : NULL);
+	} else {
+		int interval = IEEE80211_SCAN_INTERVAL;
+
+		if (time_after(jiffies, ifibss->ibss_join_req +
+					IEEE80211_IBSS_JOIN_TIMEOUT))
+				ieee80211_sta_create_ibss(sdata);
+
+		mod_timer(&ifibss->timer,
+			  round_jiffies(jiffies + interval));
+	}
+}
+
+static void ieee80211_rx_mgmt_probe_req(struct ieee80211_sub_if_data *sdata,
+					struct sk_buff *req)
+{
+	struct ieee80211_mgmt *mgmt = (void *)req->data;
+	struct ieee80211_if_ibss *ifibss = &sdata->u.ibss;
+	struct ieee80211_local *local = sdata->local;
+	int tx_last_beacon, len = req->len;
+	struct sk_buff *skb;
+	struct ieee80211_mgmt *resp;
+	struct sk_buff *presp;
+	u8 *pos, *end;
+
+	lockdep_assert_held(&ifibss->mtx);
+
+	presp = rcu_dereference_protected(ifibss->presp,
+					  lockdep_is_held(&ifibss->mtx));
+
+	if (ifibss->state != IEEE80211_IBSS_MLME_JOINED ||
+	    len < 24 + 2 || !presp)
+		return;
+
+	tx_last_beacon = drv_tx_last_beacon(local);
+
+#ifdef CONFIG_XRMAC_IBSS_DEBUG
+	printk(KERN_DEBUG "%s: RX ProbeReq SA=%pM DA=%pM BSSID=%pM"
+	       " (tx_last_beacon=%d)\n",
+	       sdata->name, mgmt->sa, mgmt->da,
+	       mgmt->bssid, tx_last_beacon);
+#endif /* CONFIG_XRMAC_IBSS_DEBUG */
+
+	if (!tx_last_beacon && is_multicast_ether_addr(mgmt->da))
+		return;
+
+	if (memcmp(mgmt->bssid, ifibss->bssid, ETH_ALEN) != 0 &&
+	    memcmp(mgmt->bssid, "\xff\xff\xff\xff\xff\xff", ETH_ALEN) != 0)
+		return;
+
+	end = ((u8 *) mgmt) + len;
+	pos = mgmt->u.probe_req.variable;
+	if (pos[0] != WLAN_EID_SSID ||
+	    pos + 2 + pos[1] > end) {
+#ifdef CONFIG_XRMAC_IBSS_DEBUG
+		printk(KERN_DEBUG "%s: Invalid SSID IE in ProbeReq "
+		       "from %pM\n",
+		       sdata->name, mgmt->sa);
+#endif
+		return;
+	}
+	if (pos[1] != 0 &&
+	    (pos[1] != ifibss->ssid_len ||
+	     memcmp(pos + 2, ifibss->ssid, ifibss->ssid_len))) {
+		/* Ignore ProbeReq for foreign SSID */
+		return;
+	}
+
+	/* Reply with ProbeResp */
+	skb = skb_copy(presp, GFP_KERNEL);
+	if (!skb)
+		return;
+
+	resp = (struct ieee80211_mgmt *) skb->data;
+	memcpy(resp->da, mgmt->sa, ETH_ALEN);
+#ifdef CONFIG_XRMAC_IBSS_DEBUG
+	printk(KERN_DEBUG "%s: Sending ProbeResp to %pM\n",
+	       sdata->name, resp->da);
+#endif /* CONFIG_XRMAC_IBSS_DEBUG */
+	IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
+	ieee80211_tx_skb(sdata, skb);
+}
+
+static void ieee80211_rx_mgmt_probe_resp(struct ieee80211_sub_if_data *sdata,
+					 struct ieee80211_mgmt *mgmt,
+					 size_t len,
+					 struct ieee80211_rx_status *rx_status)
+{
+	size_t baselen;
+	struct ieee802_11_elems elems;
+
+	if (memcmp(mgmt->da, sdata->vif.addr, ETH_ALEN))
+		return; /* ignore ProbeResp to foreign address */
+
+	baselen = (u8 *) mgmt->u.probe_resp.variable - (u8 *) mgmt;
+	if (baselen > len)
+		return;
+
+	mac802_11_parse_elems(mgmt->u.probe_resp.variable, len - baselen,
+				&elems);
+
+	ieee80211_rx_bss_info(sdata, mgmt, len, rx_status, &elems, false);
+}
+
+static void ieee80211_rx_mgmt_beacon(struct ieee80211_sub_if_data *sdata,
+				     struct ieee80211_mgmt *mgmt,
+				     size_t len,
+				     struct ieee80211_rx_status *rx_status)
+{
+	size_t baselen;
+	struct ieee802_11_elems elems;
+
+	/* Process beacon from the current BSS */
+	baselen = (u8 *) mgmt->u.beacon.variable - (u8 *) mgmt;
+	if (baselen > len)
+		return;
+
+	mac802_11_parse_elems(mgmt->u.beacon.variable, len - baselen, &elems);
+
+	ieee80211_rx_bss_info(sdata, mgmt, len, rx_status, &elems, true);
+}
+
+void mac80211_ibss_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,
+				   struct sk_buff *skb)
+{
+	struct ieee80211_rx_status *rx_status;
+	struct ieee80211_mgmt *mgmt;
+	u16 fc;
+
+	rx_status = IEEE80211_SKB_RXCB(skb);
+	mgmt = (struct ieee80211_mgmt *) skb->data;
+	fc = le16_to_cpu(mgmt->frame_control);
+
+	mutex_lock(&sdata->u.ibss.mtx);
+
+	if (!sdata->u.ibss.ssid_len)
+		goto mgmt_out; /* not ready to merge yet */
+
+	switch (fc & IEEE80211_FCTL_STYPE) {
+	case IEEE80211_STYPE_PROBE_REQ:
+		ieee80211_rx_mgmt_probe_req(sdata, skb);
+		break;
+	case IEEE80211_STYPE_PROBE_RESP:
+		ieee80211_rx_mgmt_probe_resp(sdata, mgmt, skb->len,
+					     rx_status);
+		break;
+	case IEEE80211_STYPE_BEACON:
+		ieee80211_rx_mgmt_beacon(sdata, mgmt, skb->len,
+					 rx_status);
+		break;
+	case IEEE80211_STYPE_AUTH:
+		ieee80211_rx_mgmt_auth_ibss(sdata, mgmt, skb->len);
+		break;
+	}
+
+ mgmt_out:
+	mutex_unlock(&sdata->u.ibss.mtx);
+}
+
+void mac80211_ibss_work(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_ibss *ifibss = &sdata->u.ibss;
+
+	mutex_lock(&ifibss->mtx);
+
+	/*
+	 * Work could be scheduled after scan or similar
+	 * when we aren't even joined (or trying) with a
+	 * network.
+	 */
+	if (!ifibss->ssid_len)
+		goto out;
+
+	switch (ifibss->state) {
+	case IEEE80211_IBSS_MLME_SEARCH:
+		ieee80211_sta_find_ibss(sdata);
+		break;
+	case IEEE80211_IBSS_MLME_JOINED:
+		ieee80211_sta_merge_ibss(sdata);
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+ out:
+	mutex_unlock(&ifibss->mtx);
+}
+
+static void ieee80211_ibss_timer(struct timer_list *t)
+{
+	struct ieee80211_sub_if_data *sdata =
+			from_timer(sdata, t, u.ibss.timer);
+	struct ieee80211_if_ibss *ifibss = &sdata->u.ibss;
+	struct ieee80211_local *local = sdata->local;
+
+	if (local->quiescing) {
+		ifibss->timer_running = true;
+		return;
+	}
+
+	mac80211_queue_work(&local->hw, &sdata->work);
+}
+
+#ifdef CONFIG_PM
+void mac80211_ibss_quiesce(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_ibss *ifibss = &sdata->u.ibss;
+
+	if (del_timer_sync(&ifibss->timer))
+		ifibss->timer_running = true;
+}
+
+void mac80211_ibss_restart(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_ibss *ifibss = &sdata->u.ibss;
+
+	if (ifibss->timer_running) {
+		add_timer(&ifibss->timer);
+		ifibss->timer_running = false;
+	}
+}
+#endif
+
+void mac80211_ibss_setup_sdata(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_ibss *ifibss = &sdata->u.ibss;
+
+	timer_setup(&ifibss->timer, ieee80211_ibss_timer, 0);
+	mutex_init(&ifibss->mtx);
+}
+
+/* scan finished notification */
+void mac80211_ibss_notify_scan_completed(struct ieee80211_local *local)
+{
+	struct ieee80211_sub_if_data *sdata;
+
+	mutex_lock(&local->iflist_mtx);
+	list_for_each_entry(sdata, &local->interfaces, list) {
+		if (!ieee80211_sdata_running(sdata))
+			continue;
+		if (sdata->vif.type != NL80211_IFTYPE_ADHOC)
+			continue;
+		sdata->u.ibss.last_scan_completed = jiffies;
+		mac80211_queue_work(&local->hw, &sdata->work);
+	}
+	mutex_unlock(&local->iflist_mtx);
+}
+
+int mac80211_ibss_join(struct ieee80211_sub_if_data *sdata,
+			struct cfg80211_ibss_params *params)
+{
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(sdata->local, sdata);
+	struct sk_buff *skb;
+
+	skb = dev_alloc_skb(sdata->local->hw.extra_tx_headroom +
+			    36 /* bitrates */ +
+			    34 /* SSID */ +
+			    3  /* DS params */ +
+			    4  /* IBSS params */ +
+			    params->ie_len);
+	if (!skb)
+		return -ENOMEM;
+
+	mutex_lock(&sdata->u.ibss.mtx);
+
+	if (params->bssid) {
+		memcpy(sdata->u.ibss.bssid, params->bssid, ETH_ALEN);
+		sdata->u.ibss.fixed_bssid = true;
+	} else
+		sdata->u.ibss.fixed_bssid = false;
+
+	sdata->u.ibss.privacy = params->privacy;
+	sdata->u.ibss.basic_rates = params->basic_rates;
+	memcpy(sdata->vif.bss_conf.mcast_rate, params->mcast_rate,
+	       sizeof(params->mcast_rate));
+
+	sdata->vif.bss_conf.beacon_int = params->beacon_interval;
+
+	sdata->u.ibss.channel = params->chandef.chan;
+	sdata->u.ibss.fixed_channel = params->channel_fixed;
+
+	/* fix ourselves to that channel now already */
+	if (params->channel_fixed) {
+		chan_state->oper_channel = params->chandef.chan;
+		WARN_ON(!mac80211_set_channel_type(sdata->local, sdata,
+						    NL80211_CHAN_NO_HT));
+	}
+
+	if (params->ie) {
+		sdata->u.ibss.ie = kmemdup(params->ie, params->ie_len,
+					   GFP_KERNEL);
+		if (sdata->u.ibss.ie)
+			sdata->u.ibss.ie_len = params->ie_len;
+	}
+
+	sdata->u.ibss.skb = skb;
+	sdata->u.ibss.state = IEEE80211_IBSS_MLME_SEARCH;
+	sdata->u.ibss.ibss_join_req = jiffies;
+
+	memcpy(sdata->u.ibss.ssid, params->ssid, IEEE80211_MAX_SSID_LEN);
+	sdata->u.ibss.ssid_len = params->ssid_len;
+
+	mutex_unlock(&sdata->u.ibss.mtx);
+
+	mutex_lock(&sdata->local->mtx);
+	mac80211_recalc_idle(sdata->local);
+	mutex_unlock(&sdata->local->mtx);
+
+	mac80211_queue_work(&sdata->local->hw, &sdata->work);
+
+	return 0;
+}
+
+int mac80211_ibss_leave(struct ieee80211_sub_if_data *sdata)
+{
+	struct sk_buff *skb;
+	struct ieee80211_if_ibss *ifibss = &sdata->u.ibss;
+	struct ieee80211_local *local = sdata->local;
+	struct cfg80211_bss *cbss;
+	enum ieee80211_privacy privacy;
+	int active_ibss;
+
+	mutex_lock(&sdata->u.ibss.mtx);
+
+	sdata->u.ibss.state = IEEE80211_IBSS_MLME_SEARCH;
+	memset(sdata->u.ibss.bssid, 0, ETH_ALEN);
+	sdata->u.ibss.ssid_len = 0;
+
+	active_ibss = ieee80211_sta_active_ibss(sdata);
+
+	if (!active_ibss && !is_zero_ether_addr(ifibss->bssid)) {
+		privacy = IEEE80211_PRIVACY_OFF;
+
+		if (ifibss->privacy)
+			privacy = IEEE80211_PRIVACY_ON;
+
+		cbss = cfg80211_get_bss(local->hw.wiphy, ifibss->channel,
+					ifibss->bssid, ifibss->ssid,
+					ifibss->ssid_len, IEEE80211_BSS_TYPE_IBSS, privacy);
+		if (cbss) {
+			cfg80211_unlink_bss(local->hw.wiphy, cbss);
+			cfg80211_put_bss(local->hw.wiphy, cbss);
+		}
+	}
+
+	xrmac_sta_info_flush(sdata->local, sdata);
+
+	/* remove beacon */
+	kfree(sdata->u.ibss.ie);
+	skb = rcu_dereference_protected(sdata->u.ibss.presp,
+					lockdep_is_held(&sdata->u.ibss.mtx));
+	RCU_INIT_POINTER(sdata->u.ibss.presp, NULL);
+	sdata->vif.bss_conf.ibss_joined = false;
+	mac80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON_ENABLED |
+						BSS_CHANGED_IBSS);
+	synchronize_rcu();
+	kfree_skb(skb);
+
+	skb_queue_purge(&sdata->skb_queue);
+
+	del_timer_sync(&sdata->u.ibss.timer);
+
+	mutex_unlock(&sdata->u.ibss.mtx);
+
+	mutex_lock(&local->mtx);
+	mac80211_recalc_idle(sdata->local);
+	mutex_unlock(&local->mtx);
+
+	return 0;
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/ieee80211_i.h b/drivers/net/wireless/xr829/umac/ieee80211_i.h
--- a/drivers/net/wireless/xr829/umac/ieee80211_i.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/ieee80211_i.h	2022-08-27 01:22:42.942539817 +0300
@@ -0,0 +1,1682 @@
+/*
+ * Copyright 2002-2005, Instant802 Networks, Inc.
+ * Copyright 2005, Devicescape Software, Inc.
+ * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
+ * Copyright 2007-2010	Johannes Berg <johannes@sipsolutions.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef IEEE80211_I_H
+#define IEEE80211_I_H
+#include <generated/uapi/linux/version.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/if_ether.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/workqueue.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/etherdevice.h>
+#include <linux/leds.h>
+#include <linux/idr.h>
+#include <linux/rhashtable.h>
+#include <net/ieee80211_radiotap.h>
+#include <net/cfg80211.h>
+#include <net/mac80211.h>
+#include <net/fq.h>
+
+#include "key.h"
+#include "sta_info.h"
+
+struct ieee80211_local;
+
+/* Maximum number of broadcast/multicast frames to buffer when some of the
+ * associated stations are using power saving. */
+#define AP_MAX_BC_BUFFER 128
+
+/* Maximum number of frames buffered to all STAs, including multicast frames.
+ * Note: increasing this limit increases the potential memory requirement. Each
+ * frame can be up to about 2 kB long. */
+#define TOTAL_MAX_TX_BUFFER 512
+
+/* Required encryption head and tailroom */
+#define IEEE80211_ENCRYPT_HEADROOM 20
+#define IEEE80211_ENCRYPT_TAILROOM 18
+
+/* IEEE 802.11 (Ch. 9.5 Defragmentation) requires support for concurrent
+ * reception of at least three fragmented frames. This limit can be increased
+ * by changing this define, at the cost of slower frame reassembly and
+ * increased memory use (about 2 kB of RAM per entry). */
+#define IEEE80211_FRAGMENT_MAX 4
+
+
+#define IEEE80211_DEFAULT_UAPSD_QUEUES \
+	(IEEE80211_WMM_IE_STA_QOSINFO_AC_BK |	\
+	 IEEE80211_WMM_IE_STA_QOSINFO_AC_BE |	\
+	 IEEE80211_WMM_IE_STA_QOSINFO_AC_VI |	\
+	 IEEE80211_WMM_IE_STA_QOSINFO_AC_VO)
+
+#define IEEE80211_DEFAULT_MAX_SP_LEN		\
+	IEEE80211_WMM_IE_STA_QOSINFO_SP_ALL
+
+struct ieee80211_fragment_entry {
+	unsigned long first_frag_time;
+	unsigned int seq;
+	unsigned int rx_queue;
+	unsigned int last_frag;
+	unsigned int extra_len;
+	struct sk_buff_head skb_list;
+	int ccmp; /* Whether fragments were encrypted with CCMP */
+	u8 last_pn[6]; /* PN of the last fragment if CCMP was used */
+};
+
+
+struct ieee80211_bss {
+	/* don't want to look up all the time */
+	size_t ssid_len;
+	u8 ssid[IEEE80211_MAX_SSID_LEN];
+
+	u8 dtim_period;
+
+	bool wmm_used;
+	bool uapsd_supported;
+
+	unsigned long last_probe_resp;
+
+#ifdef CONFIG_XRMAC_MESH
+	u8 *mesh_id;
+	size_t mesh_id_len;
+	u8 *mesh_cfg;
+#endif
+
+#define IEEE80211_MAX_SUPP_RATES 32
+	u8 supp_rates[IEEE80211_MAX_SUPP_RATES];
+	size_t supp_rates_len;
+
+	/*
+	 * During association, we save an ERP value from a probe response so
+	 * that we can feed ERP info to the driver when handling the
+	 * association completes. these fields probably won't be up-to-date
+	 * otherwise, you probably don't want to use them.
+	 */
+	bool has_erp_value;
+	u8 erp_value;
+};
+
+static inline u8 *bss_mesh_cfg(struct ieee80211_bss *bss)
+{
+#ifdef CONFIG_XRMAC_MESH
+	return bss->mesh_cfg;
+#endif
+	return NULL;
+}
+
+static inline u8 *bss_mesh_id(struct ieee80211_bss *bss)
+{
+#ifdef CONFIG_XRMAC_MESH
+	return bss->mesh_id;
+#endif
+	return NULL;
+}
+
+static inline u8 bss_mesh_id_len(struct ieee80211_bss *bss)
+{
+#ifdef CONFIG_XRMAC_MESH
+	return bss->mesh_id_len;
+#endif
+	return 0;
+}
+
+
+typedef unsigned __bitwise ieee80211_tx_result;
+#define TX_CONTINUE	((__force ieee80211_tx_result) 0u)
+#define TX_DROP		((__force ieee80211_tx_result) 1u)
+#define TX_QUEUED	((__force ieee80211_tx_result) 2u)
+
+#define IEEE80211_TX_UNICAST		BIT(1)
+#define IEEE80211_TX_PS_BUFFERED	BIT(2)
+
+struct ieee80211_tx_data {
+	struct sk_buff *skb;
+	struct ieee80211_local *local;
+	struct ieee80211_sub_if_data *sdata;
+	struct sta_info *sta;
+	struct ieee80211_key *key;
+
+	struct ieee80211_channel *channel;
+
+	u16 ethertype;
+	unsigned int flags;
+};
+
+
+typedef unsigned __bitwise ieee80211_rx_result;
+#define RX_CONTINUE		((__force ieee80211_rx_result) 0u)
+#define RX_DROP_UNUSABLE	((__force ieee80211_rx_result) 1u)
+#define RX_DROP_MONITOR		((__force ieee80211_rx_result) 2u)
+#define RX_QUEUED		((__force ieee80211_rx_result) 3u)
+
+/**
+ * enum ieee80211_packet_rx_flags - packet RX flags
+ * @IEEE80211_RX_RA_MATCH: frame is destined to interface currently processed
+ *	(incl. multicast frames)
+ * @IEEE80211_RX_IN_SCAN: received while scanning
+ * @IEEE80211_RX_FRAGMENTED: fragmented frame
+ * @IEEE80211_RX_AMSDU: a-MSDU packet
+ * @IEEE80211_RX_MALFORMED_ACTION_FRM: action frame is malformed
+ * @IEEE80211_RX_DEFERRED_RELEASE: frame was subjected to receive reordering
+ *
+ * These are per-frame flags that are attached to a frame in the
+ * @rx_flags field of &struct ieee80211_rx_status.
+ */
+enum ieee80211_packet_rx_flags {
+	IEEE80211_RX_IN_SCAN			= BIT(0),
+	IEEE80211_RX_RA_MATCH			= BIT(1),
+	IEEE80211_RX_FRAGMENTED			= BIT(2),
+	IEEE80211_RX_AMSDU			= BIT(3),
+	IEEE80211_RX_MALFORMED_ACTION_FRM	= BIT(4),
+	IEEE80211_RX_DEFERRED_RELEASE		= BIT(5),
+	IEEE80211_RX_ERP_BEACON			= BIT(6),
+};
+
+/**
+ * enum ieee80211_rx_flags - RX data flags
+ *
+ * @IEEE80211_RX_CMNTR: received on cooked monitor already
+ *
+ * These flags are used across handling multiple interfaces
+ * for a single frame.
+ */
+enum ieee80211_rx_flags {
+	IEEE80211_RX_CMNTR		= BIT(0),
+};
+
+struct ieee80211_rx_data {
+	struct sk_buff *skb;
+	struct ieee80211_local *local;
+	struct ieee80211_sub_if_data *sdata;
+	struct sta_info *sta;
+	struct ieee80211_key *key;
+
+	unsigned int flags;
+
+	/*
+	 * Index into sequence numbers array, 0..16
+	 * since the last (16) is used for non-QoS,
+	 * will be 16 on non-QoS frames.
+	 */
+	int seqno_idx;
+
+	/*
+	 * Index into the security IV/PN arrays, 0..16
+	 * since the last (16) is used for CCMP-encrypted
+	 * management frames, will be set to 16 on mgmt
+	 * frames and 0 on non-QoS frames.
+	 */
+	int security_idx;
+
+	u32 tkip_iv32;
+	u16 tkip_iv16;
+};
+
+struct beacon_data {
+	u8 *head, *tail;
+	int head_len, tail_len;
+	int dtim_period;
+	struct rcu_head rcu_head;
+};
+
+#ifdef PROBE_RESP_EXTRA_IE
+struct proberesp_data {
+	u8 *head, *tail;
+	int head_len, tail_len;
+	u8 *proberesp_data_ies;
+	int proberesp_data_ies_len;
+};
+#endif
+
+struct ieee80211_if_ap {
+	struct beacon_data __rcu *beacon;
+#ifdef PROBE_RESP_EXTRA_IE
+	struct proberesp_data __rcu *proberesp;
+#endif
+
+	struct list_head vlans;
+
+	/* yes, this looks ugly, but guarantees that we can later use
+	 * bitmap_empty :)
+	 * NB: don't touch this bitmap, use sta_info_{set, clear}_tim_bit */
+	u8 tim[sizeof(unsigned long) * BITS_TO_LONGS(IEEE80211_MAX_AID + 1)];
+	struct sk_buff_head ps_bc_buf;
+	atomic_t num_sta_ps; /* number of stations in PS mode */
+	int dtim_count;
+	bool dtim_bc_mc;
+};
+
+struct ieee80211_if_wds {
+	struct sta_info *sta;
+	u8 remote_addr[ETH_ALEN];
+};
+
+struct ieee80211_if_vlan {
+	struct list_head list;
+
+	/* used for all tx if the VLAN is configured to 4-addr mode */
+	struct sta_info __rcu *sta;
+};
+
+struct mesh_stats {
+	__u32 fwded_mcast;		/* Mesh forwarded multicast frames */
+	__u32 fwded_unicast;		/* Mesh forwarded unicast frames */
+	__u32 fwded_frames;		/* Mesh total forwarded frames */
+	__u32 dropped_frames_ttl;	/* Not transmitted since mesh_ttl == 0*/
+	__u32 dropped_frames_no_route;	/* Not transmitted, no route found */
+	__u32 dropped_frames_congestion;/* Not forwarded due to congestion */
+	atomic_t estab_plinks;
+};
+
+#define PREQ_Q_F_START		0x1
+#define PREQ_Q_F_REFRESH	0x2
+struct mesh_preq_queue {
+	struct list_head list;
+	u8 dst[ETH_ALEN];
+	u8 flags;
+};
+
+#if HZ/100 == 0
+#define IEEE80211_ROC_MIN_LEFT	1
+#else
+#define IEEE80211_ROC_MIN_LEFT	(HZ/100)
+#endif
+
+struct ieee80211_roc_work {
+	struct list_head list;
+	struct list_head dependents;
+
+	struct delayed_work work;
+
+	struct ieee80211_sub_if_data *sdata;
+
+	struct ieee80211_channel *chan;
+
+	bool started, abort, hw_begun, notified;
+
+	unsigned long hw_start_time;
+
+	u32 duration, req_duration;
+	struct sk_buff *frame;
+	u64 cookie, mgmt_tx_cookie;
+	struct ieee80211_local *local;
+	struct net_device *hw_roc_dev;
+	enum nl80211_channel_type chan_type;
+};
+enum ieee80211_work_type {
+	IEEE80211_WORK_ABORT,
+	IEEE80211_WORK_DIRECT_PROBE,
+	IEEE80211_WORK_AUTH,
+	IEEE80211_WORK_ASSOC_BEACON_WAIT,
+	IEEE80211_WORK_ASSOC,
+	IEEE80211_WORK_REMAIN_ON_CHANNEL,
+	IEEE80211_WORK_OFFCHANNEL_TX,
+};
+
+/**
+ * enum work_done_result - indicates what to do after work was done
+ *
+ * @WORK_DONE_DESTROY: This work item is no longer needed, destroy.
+ * @WORK_DONE_REQUEUE: This work item was reset to be reused, and
+ *	should be requeued.
+ */
+enum work_done_result {
+	WORK_DONE_DESTROY,
+	WORK_DONE_REQUEUE,
+};
+
+struct ieee80211_work {
+	struct list_head list;
+
+	struct rcu_head rcu_head;
+
+	struct ieee80211_sub_if_data *sdata;
+
+	enum work_done_result (*done)(struct ieee80211_work *wk,
+				      struct sk_buff *skb);
+
+	struct ieee80211_channel *chan;
+	enum nl80211_channel_type chan_type;
+
+	unsigned long timeout;
+	enum ieee80211_work_type type;
+
+	u8 filter_ta[ETH_ALEN];
+
+	bool started;
+
+	union {
+		struct {
+			int tries;
+			u16 algorithm, transaction;
+			u8 ssid[IEEE80211_MAX_SSID_LEN];
+			u8 ssid_len;
+			u8 key[WLAN_KEY_LEN_WEP104];
+			u8 key_len, key_idx;
+			bool privacy;
+			bool synced;
+			struct cfg80211_bss *bss;
+		} probe_auth;
+		struct {
+			struct cfg80211_bss *bss;
+			const u8 *supp_rates;
+			const u8 *ht_information_ie;
+			enum ieee80211_smps_mode smps;
+			int tries;
+			u16 capability;
+			u8 prev_bssid[ETH_ALEN];
+			u8 ssid[IEEE80211_MAX_SSID_LEN];
+			u8 ssid_len;
+			u8 supp_rates_len;
+			bool wmm_used, use_11n, uapsd_used;
+			bool synced;
+		} assoc;
+		struct {
+			u32 duration;
+		} remain;
+		struct {
+			struct sk_buff *frame;
+			u32 wait;
+			bool status;
+		} offchan_tx;
+	};
+
+	int ie_len;
+	/* must be last */
+	u8 ie[0];
+};
+
+/* flags used in struct ieee80211_if_managed.flags */
+enum ieee80211_sta_flags {
+	IEEE80211_STA_BEACON_POLL	= BIT(0),
+	IEEE80211_STA_CONNECTION_POLL	= BIT(1),
+	IEEE80211_STA_CONTROL_PORT	= BIT(2),
+	IEEE80211_STA_DISABLE_11N	= BIT(4),
+	IEEE80211_STA_CSA_RECEIVED	= BIT(5),
+	IEEE80211_STA_MFP_ENABLED	= BIT(6),
+	IEEE80211_STA_UAPSD_ENABLED	= BIT(7),
+	IEEE80211_STA_NULLFUNC_ACKED	= BIT(8),
+	IEEE80211_STA_RESET_SIGNAL_AVE	= BIT(9),
+};
+
+struct ieee80211_if_managed {
+	struct timer_list timer;
+	struct timer_list conn_mon_timer;
+	struct timer_list bcn_mon_timer;
+	struct timer_list chswitch_timer;
+	struct work_struct monitor_work;
+	struct work_struct chswitch_work;
+	struct work_struct beacon_connection_loss_work;
+
+	unsigned long beacon_timeout;
+	unsigned long probe_timeout;
+	int probe_send_count;
+	bool nullfunc_failed;
+
+	struct mutex mtx;
+	struct cfg80211_bss *associated;
+
+	u8 bssid[ETH_ALEN];
+
+	u16 aid;
+
+	unsigned long timers_running; /* used for quiesce/restart */
+	bool powersave; /* powersave requested for this iface */
+	bool broken_ap; /* AP is broken -- turn off powersave */
+	enum ieee80211_smps_mode req_smps, /* requested smps mode */
+				 ap_smps, /* smps mode AP thinks we're in */
+				 driver_smps_mode; /* smps mode request */
+
+	struct work_struct request_smps_work;
+
+	unsigned int flags;
+
+	bool beacon_crc_valid;
+	u32 beacon_crc;
+
+	enum {
+		IEEE80211_MFP_DISABLED,
+		IEEE80211_MFP_OPTIONAL,
+		IEEE80211_MFP_REQUIRED
+	} mfp; /* management frame protection */
+
+	int wmm_last_param_set;
+
+	char	p2p_last_ie[255];
+	u8	p2p_last_ie_len;
+
+	u8 use_4addr;
+
+	/* Signal strength from the last Beacon frame in the current BSS. */
+	int last_beacon_signal;
+
+	/*
+	 * Weighted average of the signal strength from Beacon frames in the
+	 * current BSS. This is in units of 1/16 of the signal unit to maintain
+	 * accuracy and to speed up calculations, i.e., the value need to be
+	 * divided by 16 to get the actual value.
+	 */
+	int ave_beacon_signal;
+
+	/*
+	 * Number of Beacon frames used in ave_beacon_signal. This can be used
+	 * to avoid generating less reliable cqm events that would be based
+	 * only on couple of received frames.
+	 */
+	unsigned int count_beacon_signal;
+
+	/*
+	 * Last Beacon frame signal strength average (ave_beacon_signal / 16)
+	 * that triggered a cqm event. 0 indicates that no event has been
+	 * generated for the current association.
+	 */
+	int last_cqm_event_signal;
+
+	/*
+	 * State variables for keeping track of RSSI of the AP currently
+	 * connected to and informing driver when RSSI has gone
+	 * below/above a certain threshold.
+	 */
+	int rssi_min_thold, rssi_max_thold;
+	int last_ave_beacon_signal;
+#ifdef CONFIG_XRMAC_XR_ROAMING_CHANGES
+	/*
+	 * Set during reassociation to enable faster key removal.
+	 */
+	int roaming;
+#endif
+	u8 *assoc_req_ies;
+	size_t assoc_req_ies_len;
+};
+
+struct ieee80211_if_ibss {
+	struct timer_list timer;
+
+	struct mutex mtx;
+
+	unsigned long last_scan_completed;
+
+	u32 basic_rates;
+
+	bool timer_running;
+
+	bool fixed_bssid;
+	bool fixed_channel;
+	bool privacy;
+
+	u8 bssid[ETH_ALEN];
+	u8 ssid[IEEE80211_MAX_SSID_LEN];
+	u8 ssid_len, ie_len;
+	u8 *ie;
+	struct ieee80211_channel *channel;
+
+	unsigned long ibss_join_req;
+	/* probe response/beacon for IBSS */
+	struct sk_buff __rcu *presp;
+	struct sk_buff *skb;
+
+	enum {
+		IEEE80211_IBSS_MLME_SEARCH,
+		IEEE80211_IBSS_MLME_JOINED,
+	} state;
+};
+
+struct ieee80211_if_mesh {
+	struct timer_list housekeeping_timer;
+	struct timer_list xrmac_mesh_path_timer;
+	struct timer_list mesh_path_root_timer;
+
+	unsigned long timers_running;
+
+	unsigned long wrkq_flags;
+
+	u8 mesh_id[IEEE80211_MAX_MESH_ID_LEN];
+	size_t mesh_id_len;
+	/* Active Path Selection Protocol Identifier */
+	u8 mesh_pp_id;
+	/* Active Path Selection Metric Identifier */
+	u8 mesh_pm_id;
+	/* Congestion Control Mode Identifier */
+	u8 mesh_cc_id;
+	/* Synchronization Protocol Identifier */
+	u8 mesh_sp_id;
+	/* Authentication Protocol Identifier */
+	u8 mesh_auth_id;
+	/* Local mesh Sequence Number */
+	u32 sn;
+	/* Last used PREQ ID */
+	u32 preq_id;
+	atomic_t mpaths;
+	/* Timestamp of last SN update */
+	unsigned long last_sn_update;
+	/* Timestamp of last SN sent */
+	unsigned long last_preq;
+	struct mesh_rmc *rmc;
+	spinlock_t mesh_preq_queue_lock;
+	struct mesh_preq_queue preq_queue;
+	int preq_queue_len;
+	struct mesh_stats mshstats;
+	struct mesh_config mshcfg;
+	u32 mesh_seqnum;
+	bool accepting_plinks;
+	int num_gates;
+	const u8 *ie;
+	u8 ie_len;
+	enum {
+		IEEE80211_MESH_SEC_NONE = 0x0,
+		IEEE80211_MESH_SEC_AUTHED = 0x1,
+		IEEE80211_MESH_SEC_SECURED = 0x2,
+	} security;
+};
+
+#ifdef CONFIG_XRMAC_MESH
+#define IEEE80211_IFSTA_MESH_CTR_INC(msh, name)	\
+	do { (msh)->mshstats.name++; } while (0)
+#else
+#define IEEE80211_IFSTA_MESH_CTR_INC(msh, name) \
+	do { } while (0)
+#endif
+
+struct ieee80211_channel_state {
+	struct ieee80211_channel_conf conf;
+
+	/* Operational channel */
+	enum nl80211_channel_type _oper_channel_type;
+	struct ieee80211_channel *oper_channel;
+
+	/* CSA channel .e.g for STA when AP switches channels */
+	struct ieee80211_channel *csa_channel;
+
+	/* Temporary remain-on-channel for off-channel operations */
+	struct ieee80211_channel *tmp_channel;
+	enum nl80211_channel_type tmp_channel_type;
+};
+
+/**
+ * enum ieee80211_sub_if_data_flags - virtual interface flags
+ *
+ * @IEEE80211_SDATA_ALLMULTI: interface wants all multicast packets
+ * @IEEE80211_SDATA_PROMISC: interface is promisc
+ * @IEEE80211_SDATA_OPERATING_GMODE: operating in G-only mode
+ * @IEEE80211_SDATA_DONT_BRIDGE_PACKETS: bridge packets between
+ *	associated stations and deliver multicast frames both
+ *	back to wireless media and to the local net stack.
+ * @IEEE80211_SDATA_DISCONNECT_RESUME: Disconnect after resume.
+ */
+enum ieee80211_sub_if_data_flags {
+	IEEE80211_SDATA_ALLMULTI		= BIT(0),
+	IEEE80211_SDATA_PROMISC			= BIT(1),
+	IEEE80211_SDATA_OPERATING_GMODE		= BIT(2),
+	IEEE80211_SDATA_DONT_BRIDGE_PACKETS	= BIT(3),
+	IEEE80211_SDATA_DISCONNECT_RESUME	= BIT(4),
+};
+
+/**
+ * enum ieee80211_sdata_state_bits - virtual interface state bits
+ * @SDATA_STATE_RUNNING: virtual interface is up & running; this
+ *	mirrors netif_running() but is separate for interface type
+ *	change handling while the interface is up
+ * @SDATA_STATE_OFFCHANNEL: This interface is currently in offchannel
+ *	mode, so queues are stopped
+ */
+enum ieee80211_sdata_state_bits {
+	SDATA_STATE_RUNNING,
+	SDATA_STATE_OFFCHANNEL,
+};
+
+/**
+ * enum ieee80211_4way_state - the state of 4-way handshake
+ * @SDATA_4WAY_STATE_NONE:the sta don't send any 4-way handshake EAPOL-KEY
+ * @SDATA_4WAY_STATE_FINISH2:the sta has send second frame(acked) , it means begin
+ * 4-way handshake.
+ * @SDATA_4WAY_STATE_FINISH4:the sta has send fourth frame(acked), it means
+ * 4-way handshake finish.
+ *
+ */
+enum ieee80211_4way_state{
+	SDATA_4WAY_STATE_NONE,
+	SDATA_4WAY_STATE_FINISH2,
+	SDATA_4WAY_STATE_FINISH4,
+};
+
+/* IEEE 802.11, 8.5.2 EAPOL-Key frames */
+#define IEEE80211_KEY_INFO_TYPE_MASK ((u16) (BIT(0) | BIT(1) | BIT(2)))
+#define IEEE80211_KEY_INFO_TYPE_AKM_DEFINED 0
+#define IEEE80211_KEY_INFO_TYPE_HMAC_MD5_RC4 BIT(0)
+#define IEEE80211_KEY_INFO_TYPE_HMAC_SHA1_AES BIT(1)
+#define IEEE80211_KEY_INFO_TYPE_AES_128_CMAC 3
+#define IEEE80211_KEY_INFO_KEY_TYPE BIT(3) /* 1 = Pairwise, 0 = Group key */
+/* bit4..5 is used in WPA, but is reserved in IEEE 802.11i/RSN */
+#define IEEE80211_KEY_INFO_KEY_INDEX_MASK (BIT(4) | BIT(5))
+#define IEEE80211_KEY_INFO_KEY_INDEX_SHIFT 4
+#define IEEE80211_KEY_INFO_INSTALL BIT(6) /* pairwise */
+#define IEEE80211_KEY_INFO_TXRX BIT(6) /* group */
+#define IEEE80211_KEY_INFO_ACK BIT(7)
+#define IEEE80211_KEY_INFO_MIC BIT(8)
+#define IEEE80211_KEY_INFO_SECURE BIT(9)
+#define IEEE80211_KEY_INFO_ERROR BIT(10)
+#define IEEE80211_KEY_INFO_REQUEST BIT(11)
+#define IEEE80211_KEY_INFO_ENCR_KEY_DATA BIT(12) /* IEEE 802.11i/RSN only */
+#define IEEE80211_KEY_INFO_SMK_MESSAGE BIT(13)
+
+
+#define IEEE80211_801X_REPLAY_COUNTER_LEN 8
+#define IEEE80211_801X_NONCE_LEN 32
+#define IEEE80211_801X_KEY_RSC_LEN 8
+
+struct ieee80211_eapol_key {
+	u8 type;
+	/* Note: key_info, key_length, and key_data_length are unaligned */
+	u8 key_info[2]; /* big endian */
+	u8 key_length[2]; /* big endian */
+	u8 replay_counter[IEEE80211_801X_REPLAY_COUNTER_LEN];
+	u8 key_nonce[IEEE80211_801X_NONCE_LEN];
+	u8 key_iv[16];
+	u8 key_rsc[IEEE80211_801X_KEY_RSC_LEN];
+	u8 key_id[8]; /* Reserved in IEEE 802.11i/RSN */
+	u8 key_mic[16];
+	u8 key_data_length[2]; /* big endian */
+	/* followed by key_data_length bytes of key_data */
+} __attribute__ ((packed));
+
+struct ieee802_1x_hdr {
+	u8 version;
+	u8 type;
+	u16 length;
+	/* followed by length octets of data */
+} __attribute__ ((packed));
+
+
+struct ieee80211_sub_if_data {
+	struct list_head list;
+
+	struct wireless_dev wdev;
+
+	/* keys */
+	struct list_head key_list;
+
+	/* count for keys needing tailroom space allocation */
+	int crypto_tx_tailroom_needed_cnt;
+
+	struct net_device *dev;
+	struct ieee80211_local *local;
+
+	unsigned int flags;
+
+	unsigned long state;
+
+	int drop_unencrypted;
+#ifdef CONFIG_XRMAC_XR_ROAMING_CHANGES
+	int queues_locked;
+#endif
+
+	char name[IFNAMSIZ];
+
+	/*
+	 * keep track of whether the HT opmode (stored in
+	 * vif.bss_info.ht_operation_mode) is valid.
+	 */
+	bool ht_opmode_valid;
+
+	/* to detect idle changes */
+	bool old_idle;
+
+	bool pspolling;
+	bool offchannel_ps_enabled;
+	bool ps_allowed;
+	struct work_struct dynamic_ps_enable_work;
+	struct work_struct dynamic_ps_disable_work;
+	struct timer_list dynamic_ps_timer;
+
+	/*
+	 * The dynamic ps timeout configured from user space via WEXT -
+	 * this will override whatever chosen by mac80211 internally.
+	 */
+	int dynamic_ps_forced_timeout;
+	int dynamic_ps_user_timeout;
+	bool disable_dynamic_ps;
+
+	/* Fragment table for host-based reassembly */
+	struct ieee80211_fragment_entry	fragments[IEEE80211_FRAGMENT_MAX];
+	unsigned int fragment_next;
+
+	struct ieee80211_key __rcu *keys[NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS];
+	struct ieee80211_key __rcu *default_unicast_key;
+	struct ieee80211_key __rcu *default_multicast_key;
+	struct ieee80211_key __rcu *default_mgmt_key;
+
+	u16 sequence_number;
+	__be16 control_port_protocol;
+	bool control_port_no_encrypt;
+	int encrypt_headroom;
+	wait_queue_head_t setkey_wq;
+	enum ieee80211_4way_state fourway_state;
+
+	struct ieee80211_tx_queue_params tx_conf[IEEE80211_NUM_ACS];
+
+	struct work_struct work;
+	struct sk_buff_head skb_queue;
+
+	bool arp_filter_state;
+
+#ifdef IPV6_FILTERING
+	bool ndp_filter_state;
+#endif /*IPV6_FILTERING*/
+
+	/*
+	 * AP this belongs to: self in AP mode and
+	 * corresponding AP in VLAN mode, NULL for
+	 * all others (might be needed later in IBSS)
+	 */
+	struct ieee80211_if_ap *bss;
+
+	/* Channel state */
+	struct ieee80211_channel_state chan_state;
+
+	/* bitmap of allowed (non-MCS) rate indexes for rate control */
+	u32 rc_rateidx_mask[NUM_NL80211_BANDS];
+
+	union {
+		struct ieee80211_if_ap ap;
+		struct ieee80211_if_wds wds;
+		struct ieee80211_if_vlan vlan;
+		struct ieee80211_if_managed mgd;
+		struct ieee80211_if_ibss ibss;
+		struct ieee80211_if_mesh mesh;
+		u32 mntr_flags;
+	} u;
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	struct {
+		struct dentry *dir;
+		struct dentry *subdir_stations;
+		struct dentry *default_unicast_key;
+		struct dentry *default_multicast_key;
+		struct dentry *default_mgmt_key;
+	} debugfs;
+#endif
+
+	/* used for uploading changed mc list */
+	struct work_struct reconfig_filter;
+
+	unsigned int filter_flags, req_filt_flags; /* FIF_* */
+
+	/* aggregated multicast list */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
+	struct netdev_hw_addr_list mc_list;
+#else
+	struct dev_addr_list *mc_list;
+	int mc_count;
+#endif
+
+	/* must be last, dynamically sized area in this! */
+	struct ieee80211_vif vif;
+};
+
+static inline
+struct ieee80211_sub_if_data *vif_to_sdata(struct ieee80211_vif *p)
+{
+	return container_of(p, struct ieee80211_sub_if_data, vif);
+}
+
+enum sdata_queue_type {
+	IEEE80211_SDATA_QUEUE_TYPE_FRAME	= 0,
+	IEEE80211_SDATA_QUEUE_AGG_START		= 1,
+	IEEE80211_SDATA_QUEUE_AGG_STOP		= 2,
+};
+
+enum {
+	IEEE80211_RX_MSG	= 1,
+	IEEE80211_TX_STATUS_MSG	= 2,
+	IEEE80211_EOSP_MSG	= 3,
+};
+
+struct skb_eosp_msg_data {
+	u8 sta[ETH_ALEN], iface[ETH_ALEN];
+};
+
+enum queue_stop_reason {
+	IEEE80211_QUEUE_STOP_REASON_DRIVER,
+	IEEE80211_QUEUE_STOP_REASON_PS,
+	IEEE80211_QUEUE_STOP_REASON_CSA,
+	IEEE80211_QUEUE_STOP_REASON_AGGREGATION,
+	IEEE80211_QUEUE_STOP_REASON_SUSPEND,
+	IEEE80211_QUEUE_STOP_REASON_SKB_ADD,
+	IEEE80211_QUEUE_STOP_REASON_CHTYPE_CHANGE,
+};
+
+#ifdef CONFIG_XRMAC_LEDS
+struct tpt_led_trigger {
+	struct led_trigger trig;
+	char name[32];
+	const struct ieee80211_tpt_blink *blink_table;
+	unsigned int blink_table_len;
+	struct timer_list timer;
+	unsigned long prev_traffic;
+	unsigned long tx_bytes, rx_bytes;
+	unsigned int active, want;
+	bool running;
+};
+#endif
+
+/**
+ * mac80211 scan flags - currently active scan mode
+ *
+ * @SCAN_SW_SCANNING: We're currently in the process of scanning but may as
+ *	well be on the operating channel
+ * @SCAN_HW_SCANNING: The hardware is scanning for us, we have no way to
+ *	determine if we are on the operating channel or not
+ * @SCAN_OFF_CHANNEL: We're off our operating channel for scanning,
+ *	gets only set in conjunction with SCAN_SW_SCANNING
+ * @SCAN_COMPLETED: Set for our scan work function when the driver reported
+ *	that the scan completed.
+ * @SCAN_ABORTED: Set for our scan work function when the driver reported
+ *	a scan complete for an aborted scan.
+ */
+enum {
+	SCAN_SW_SCANNING,
+	SCAN_HW_SCANNING,
+	SCAN_OFF_CHANNEL,
+	SCAN_COMPLETED,
+	SCAN_ABORTED,
+};
+
+/**
+ * enum mac80211_scan_state - scan state machine states
+ *
+ * @SCAN_DECISION: Main entry point to the scan state machine, this state
+ *	determines if we should keep on scanning or switch back to the
+ *	operating channel
+ * @SCAN_SET_CHANNEL: Set the next channel to be scanned
+ * @SCAN_SEND_PROBE: Send probe requests and wait for probe responses
+ * @SCAN_LEAVE_OPER_CHANNEL: Leave the operating channel, notify the AP
+ *	about us leaving the channel and stop all associated STA interfaces
+ * @SCAN_ENTER_OPER_CHANNEL: Enter the operating channel again, notify the
+ *	AP about us being back and restart all associated STA interfaces
+ */
+enum mac80211_scan_state {
+	SCAN_DECISION,
+	SCAN_SET_CHANNEL,
+	SCAN_SEND_PROBE,
+	SCAN_LEAVE_OPER_CHANNEL,
+	SCAN_ENTER_OPER_CHANNEL,
+};
+
+struct ieee80211_local {
+	/* embed the driver visible part.
+	 * don't cast (use the static inlines below), but we keep
+	 * it first anyway so they become a no-op */
+	struct ieee80211_hw hw;
+
+	const struct ieee80211_ops *ops;
+
+	/*
+	 * work stuff, potentially off-channel (in the future)
+	 */
+	struct list_head work_list;
+	struct timer_list work_timer;
+	struct work_struct work_work;
+	struct sk_buff_head work_skb_queue;
+
+	/*
+	 * private workqueue to mac80211. mac80211 makes this accessible
+	 * via mac80211_queue_work()
+	 */
+	struct workqueue_struct *workqueue;
+
+	unsigned long queue_stop_reasons[IEEE80211_MAX_QUEUES];
+	/* also used to protect ampdu_ac_queue and amdpu_ac_stop_refcnt */
+	spinlock_t queue_stop_reason_lock;
+
+	int open_count;
+	int monitors, cooked_mntrs;
+
+	bool wiphy_ciphers_allocated;
+
+	/* protects the aggregated multicast list and filter calls */
+	spinlock_t filter_lock;
+
+	/* used to reconfigure hardware SM PS */
+	struct work_struct recalc_smps;
+
+	bool tim_in_locked_section; /* see ieee80211_beacon_get() */
+
+	/*
+	 * suspended is true if we finished all the suspend _and_ we have
+	 * not yet come up from resume. This is to be used by mac80211
+	 * to ensure driver sanity during suspend and mac80211's own
+	 * sanity. It can eventually be used for WoW as well.
+	 */
+	bool suspended;
+
+	/*
+	 * Resuming is true while suspended, but when we're reprogramming the
+	 * hardware -- at that time it's allowed to use mac80211_queue_work()
+	 * again even though some other parts of the stack are still suspended
+	 * and we still drop received frames to avoid waking the stack.
+	 */
+	bool resuming;
+
+	/*
+	 * quiescing is true during the suspend process _only_ to
+	 * ease timer cancelling etc.
+	 */
+	bool quiescing;
+
+	/* device is started */
+	bool started;
+
+
+	/* device is during a HW reconfig */
+	bool in_reconfig;
+
+	/* wowlan is enabled -- don't reconfig on resume */
+	bool wowlan;
+
+	int tx_headroom; /* required headroom for hardware/radiotap */
+
+	/* Tasklet and skb queue to process calls from IRQ mode. All frames
+	 * added to skb_queue will be processed, but frames in
+	 * skb_queue_unreliable may be dropped if the total length of these
+	 * queues increases over the limit. */
+#define IEEE80211_IRQSAFE_QUEUE_LIMIT 128
+	struct tasklet_struct tasklet;
+	struct sk_buff_head skb_queue;
+	struct sk_buff_head skb_queue_unreliable;
+
+	/*
+	 * Internal FIFO queue which is shared between multiple rx path
+	 * stages. Its main task is to provide a serialization mechanism,
+	 * so all rx handlers can enjoy having exclusive access to their
+	 * private data structures.
+	 */
+	struct sk_buff_head rx_skb_queue;
+	bool running_rx_handler;	/* protected by rx_skb_queue.lock */
+
+	/* Station data */
+	/*
+	 * The mutex only protects the list and counter,
+	 * reads are done in RCU.
+	 * Additionally, the lock protects the hash table,
+	 * the pending list and each BSS's TIM bitmap.
+	 */
+	struct mutex sta_mtx;
+	spinlock_t sta_lock;
+	unsigned long num_sta;
+	struct list_head sta_list, sta_pending_list;
+	struct sta_info __rcu *sta_hash[STA_HASH_SIZE];
+	struct timer_list sta_cleanup;
+	struct work_struct sta_finish_work;
+	int sta_generation;
+
+	struct sk_buff_head pending[IEEE80211_MAX_QUEUES];
+	struct tasklet_struct tx_pending_tasklet;
+
+	atomic_t agg_queue_stop[IEEE80211_MAX_QUEUES];
+
+	struct rate_control_ref *rate_ctrl;
+
+	struct arc4_ctx wep_tx_ctx;
+	struct arc4_ctx wep_rx_ctx;
+
+	u32 wep_iv;
+
+	/* see iface.c */
+	struct list_head interfaces;
+	struct mutex iflist_mtx;
+
+	/*
+	 * Key mutex, protects sdata's key_list and sta_info's
+	 * key pointers (write access, they're RCU.)
+	 */
+	struct mutex key_mtx;
+
+	/* mutex for scan and work locking */
+	struct mutex mtx;
+
+	/* Scanning and BSS list */
+	unsigned long scanning;
+	struct cfg80211_ssid scan_ssid;
+	struct cfg80211_scan_request *int_scan_req;
+	struct cfg80211_scan_request *scan_req, *hw_scan_req;
+	struct ieee80211_channel *scan_channel;
+	enum nl80211_band hw_scan_band;
+	int scan_channel_idx;
+	int scan_ies_len;
+	struct cfg80211_scan_info scan_info;
+
+	bool sched_scanning;
+	struct ieee80211_sched_scan_ies sched_scan_ies;
+	struct work_struct sched_scan_stopped_work;
+
+	unsigned long leave_oper_channel_time;
+	enum mac80211_scan_state next_scan_state;
+	struct delayed_work scan_work;
+	struct ieee80211_sub_if_data *scan_sdata;
+
+	/* Channel state */
+	struct ieee80211_channel_state chan_state;
+
+	/* SNMP counters */
+	/* dot11CountersTable */
+	u32 dot11TransmittedFragmentCount;
+	u32 dot11MulticastTransmittedFrameCount;
+	u32 dot11FailedCount;
+	u32 dot11RetryCount;
+	u32 dot11MultipleRetryCount;
+	u32 dot11FrameDuplicateCount;
+	u32 dot11ReceivedFragmentCount;
+	u32 dot11MulticastReceivedFrameCount;
+	u32 dot11TransmittedFrameCount;
+
+#ifdef CONFIG_XRMAC_LEDS
+	int tx_led_counter, rx_led_counter;
+	struct led_trigger *tx_led, *rx_led, *assoc_led, *radio_led;
+	struct tpt_led_trigger *tpt_led_trigger;
+	char tx_led_name[32], rx_led_name[32],
+	     assoc_led_name[32], radio_led_name[32];
+#endif
+
+#ifdef CONFIG_XRMAC_DEBUG_COUNTERS
+	/* TX/RX handler statistics */
+	unsigned int tx_handlers_drop;
+	unsigned int tx_handlers_queued;
+	unsigned int tx_handlers_drop_unencrypted;
+	unsigned int tx_handlers_drop_fragment;
+	unsigned int tx_handlers_drop_wep;
+	unsigned int tx_handlers_drop_not_assoc;
+	unsigned int tx_handlers_drop_unauth_port;
+	unsigned int rx_handlers_drop;
+	unsigned int rx_handlers_queued;
+	unsigned int rx_handlers_drop_nullfunc;
+	unsigned int rx_handlers_drop_defrag;
+	unsigned int rx_handlers_drop_short;
+	unsigned int rx_handlers_drop_passive_scan;
+	unsigned int tx_expand_skb_head;
+	unsigned int tx_expand_skb_head_cloned;
+	unsigned int rx_expand_skb_head;
+	unsigned int rx_expand_skb_head2;
+	unsigned int rx_handlers_fragments;
+	unsigned int tx_status_drop;
+#define I802_DEBUG_INC(c) ((c)++)
+#else /* CONFIG_XRMAC_DEBUG_COUNTERS */
+#define I802_DEBUG_INC(c) do { } while (0)
+#endif /* CONFIG_XRMAC_DEBUG_COUNTERS */
+
+
+	int total_ps_buffered; /* total number of all buffered unicast and
+				* multicast packets for power saving stations
+				*/
+	int wifi_wme_noack_test;
+	unsigned int wmm_acm; /* bit field of ACM bits (BIT(802.1D tag)) */
+#ifdef USE_RSSI_SMOOTH
+	int dis_rssi_smooth;
+#endif
+#ifdef CONFIG_XRADIO_TESTMODE
+	unsigned int wmm_admitted_ups; /* bit field of admitted priorities */
+#endif /*CONFIG_XRADIO_TESTMODE*/
+	/*
+	 * Bitmask of enabled u-apsd queues,
+	 * IEEE80211_WMM_IE_STA_QOSINFO_AC_BE & co. Needs a new association
+	 * to take effect.
+	 */
+	unsigned int uapsd_queues;
+
+	/*
+	 * Maximum number of buffered frames AP can deliver during a
+	 * service period, IEEE80211_WMM_IE_STA_QOSINFO_SP_ALL or similar.
+	 * Needs a new association to take effect.
+	 */
+	unsigned int uapsd_max_sp_len;
+
+	struct notifier_block network_latency_notifier;
+	struct notifier_block ifa_notifier;
+
+#ifdef IPV6_FILTERING
+	struct notifier_block ifa6_notifier;
+#endif /*IPV6_FILTERING*/
+
+	int user_power_level; /* in dBm */
+	int power_constr_level; /* in dBm */
+
+	enum ieee80211_smps_mode smps_mode;
+
+	struct work_struct restart_work;
+
+#ifdef IPV6_FILTERING
+#ifdef CONFIG_INET
+	struct work_struct ifa6_changed_work;
+	struct ieee80211_sub_if_data *ifa6_sdata;
+#endif
+#endif /*IPV6_FILTERING*/
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	struct local_debugfsdentries {
+		struct dentry *rcdir;
+		struct dentry *keys;
+	} debugfs;
+#endif
+
+	/*
+	 * Remain-on-channel support
+	 */
+	struct list_head roc_list;
+	struct work_struct hw_roc_start, hw_roc_done;
+	unsigned long hw_roc_start_time;
+	u64 roc_cookie_counter;
+	/* Temporary remain-on-channel for off-channel operations */
+	struct ieee80211_channel *tmp_channel;
+	struct ieee80211_channel *hw_roc_channel;
+
+	u64 roc_cookie;
+
+	struct ieee80211_sub_if_data __rcu *p2p_sdata;
+};
+
+static inline struct ieee80211_sub_if_data *
+IEEE80211_DEV_TO_SUB_IF(struct net_device *dev)
+{
+	return netdev_priv(dev);
+}
+
+/* this struct represents 802.11n's RA/TID combination */
+struct ieee80211_ra_tid {
+	u8 ra[ETH_ALEN];
+	u16 tid;
+};
+
+static inline struct ieee80211_sub_if_data *
+IEEE80211_WDEV_TO_SUB_IF(struct wireless_dev *wdev)
+{
+	return container_of(wdev, struct ieee80211_sub_if_data, wdev);
+}
+
+/* Parsed Information Elements */
+struct ieee802_11_elems {
+	u8 *ie_start;
+	size_t total_len;
+
+	/* pointers to IEs */
+	u8 *ssid;
+	u8 *supp_rates;
+	u8 *fh_params;
+	u8 *ds_params;
+	u8 *cf_params;
+	struct ieee80211_tim_ie *tim;
+	u8 *ibss_params;
+	u8 *challenge;
+	u8 *wpa;
+	u8 *rsn;
+	u8 *erp_info;
+	u8 *ext_supp_rates;
+	u8 *wmm_info;
+	u8 *wmm_param;
+	u8 *p2p_ie;
+	struct ieee80211_ht_cap *ht_cap_elem;
+	struct ieee80211_ht_operation *ht_info_elem;
+	struct ieee80211_meshconf_ie *mesh_config;
+	u8 *mesh_id;
+	u8 *peering;
+	u8 *preq;
+	u8 *prep;
+	u8 *perr;
+	struct ieee80211_rann_ie *rann;
+	u8 *ch_switch_elem;
+	u8 *country_elem;
+	u8 *pwr_constr_elem;
+	u8 *quiet_elem;	/* first quite element */
+	u8 *timeout_int;
+
+	/* length of them, respectively */
+	u8 ssid_len;
+	u8 supp_rates_len;
+	u8 fh_params_len;
+	u8 ds_params_len;
+	u8 cf_params_len;
+	u8 tim_len;
+	u8 ibss_params_len;
+	u8 challenge_len;
+	u8 wpa_len;
+	u8 rsn_len;
+	u8 erp_info_len;
+	u8 ext_supp_rates_len;
+	u8 wmm_info_len;
+	u8 wmm_param_len;
+	u8 p2p_ie_len;
+	u8 mesh_id_len;
+	u8 peering_len;
+	u8 preq_len;
+	u8 prep_len;
+	u8 perr_len;
+	u8 ch_switch_elem_len;
+	u8 country_elem_len;
+	u8 pwr_constr_elem_len;
+	u8 quiet_elem_len;
+	u8 num_of_quiet_elem;	/* can be more the one */
+	u8 timeout_int_len;
+
+	/* whether a parse error occurred while retrieving these elements */
+	bool parse_error;
+};
+
+static inline struct ieee80211_local *hw_to_local(
+	struct ieee80211_hw *hw)
+{
+	return container_of(hw, struct ieee80211_local, hw);
+}
+
+static inline struct ieee80211_hw *local_to_hw(
+	struct ieee80211_local *local)
+{
+	return &local->hw;
+}
+
+
+static inline int ieee80211_bssid_match(const u8 *raddr, const u8 *addr)
+{
+	return compare_ether_addr(raddr, addr) == 0 ||
+	       is_broadcast_ether_addr(raddr);
+}
+
+/**
+ * ieee80211_is_8021x - check if frame payload is a 8021x frame
+ * @frame: frame
+ */
+unsigned int __attribute_const__ ieee80211_hdrlen(__le16 fc);
+
+#define ETH_P_PAE 0x888E
+
+static inline int ieee80211_is_8021x(struct ieee80211_hdr *frame)
+{
+	const int LLC_TYPE_OFF = 6;
+	if (ieee80211_is_data(frame->frame_control)) {
+		const unsigned int machdrlen = ieee80211_hdrlen(frame->frame_control);
+		u8 *llc_data = (u8 *)frame + machdrlen;
+		return (bool)(*(u16 *)(llc_data+LLC_TYPE_OFF) == cpu_to_be16(ETH_P_PAE));
+	}
+	return false;
+}
+
+/**
+ * ieee80211_is_8021x - check if frame payload is a 8021x eapol key frame
+ * @frame: frame
+ */
+static inline int ieee80211_is_eapol_key(struct ieee80211_hdr *frame)
+{
+	const int LLC_TYPE_OFF = 6;
+	if (ieee80211_is_8021x(frame)) {
+		const unsigned int machdrlen = ieee80211_hdrlen(frame->frame_control);
+		u8 *eapol_frame = (u8 *)frame + machdrlen + LLC_TYPE_OFF;
+		return eapol_frame[3] == 3;
+	}
+	return false;
+}
+
+void ieee80211_notify_channel_change(struct ieee80211_local *local,
+				     struct ieee80211_sub_if_data *sdata);
+int mac80211_hw_config(struct ieee80211_local *local, u32 changed);
+void mac80211_tx_set_protected(struct ieee80211_tx_data *tx);
+void mac80211_bss_info_change_notify(struct ieee80211_sub_if_data *sdata,
+				      u32 changed);
+void mac80211_configure_filter(struct ieee80211_sub_if_data *sdata);
+u32 mac80211_reset_erp_info(struct ieee80211_sub_if_data *sdata);
+
+/* STA code */
+void mac80211_sta_setup_sdata(struct ieee80211_sub_if_data *sdata);
+int mac80211_mgd_auth(struct ieee80211_sub_if_data *sdata,
+		       struct cfg80211_auth_request *req);
+int mac80211_mgd_assoc(struct ieee80211_sub_if_data *sdata,
+			struct cfg80211_assoc_request *req);
+int mac80211_mgd_deauth(struct ieee80211_sub_if_data *sdata,
+			 struct cfg80211_deauth_request *req);
+int mac80211_mgd_disassoc(struct ieee80211_sub_if_data *sdata,
+			   struct cfg80211_disassoc_request *req);
+void mac80211_send_pspoll(struct ieee80211_local *local,
+			   struct ieee80211_sub_if_data *sdata);
+void mac80211_recalc_ps(struct ieee80211_local *local, s32 latency);
+int mac80211_max_network_latency(struct notifier_block *nb,
+				  unsigned long data, void *dummy);
+int ieee80211_set_arp_filter(struct ieee80211_sub_if_data *sdata);
+void mac80211_sta_process_chanswitch(struct ieee80211_sub_if_data *sdata,
+				      struct ieee80211_channel_sw_ie *sw_elem,
+				      struct ieee80211_bss *bss,
+				      u64 timestamp);
+void mac80211_sta_quiesce(struct ieee80211_sub_if_data *sdata);
+void mac80211_sta_restart(struct ieee80211_sub_if_data *sdata);
+void mac80211_sta_work(struct ieee80211_sub_if_data *sdata);
+void mac80211_sta_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,
+				  struct sk_buff *skb);
+int ieee80211_get_local_erp(struct ieee80211_mgmt *mgmt, size_t len);
+#define ERP_INFO_BYTE_OFFSET 2
+void mac80211_sta_reset_beacon_monitor(struct ieee80211_sub_if_data *sdata);
+void mac80211_sta_reset_conn_monitor(struct ieee80211_sub_if_data *sdata);
+
+/* IBSS code */
+void mac80211_ibss_notify_scan_completed(struct ieee80211_local *local);
+void mac80211_ibss_setup_sdata(struct ieee80211_sub_if_data *sdata);
+struct sta_info *ieee80211_ibss_add_sta(struct ieee80211_sub_if_data *sdata,
+					u8 *bssid, u8 *addr, u32 supp_rates,
+					gfp_t gfp);
+int mac80211_ibss_join(struct ieee80211_sub_if_data *sdata,
+			struct cfg80211_ibss_params *params);
+int mac80211_ibss_leave(struct ieee80211_sub_if_data *sdata);
+void mac80211_ibss_quiesce(struct ieee80211_sub_if_data *sdata);
+void mac80211_ibss_restart(struct ieee80211_sub_if_data *sdata);
+void mac80211_ibss_work(struct ieee80211_sub_if_data *sdata);
+void mac80211_ibss_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,
+				   struct sk_buff *skb);
+
+/* mesh code */
+void mac80211_mesh_work(struct ieee80211_sub_if_data *sdata);
+void mac80211_mesh_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,
+				   struct sk_buff *skb);
+
+/* scan/BSS handling */
+void mac80211_scan_work(struct work_struct *work);
+int ieee80211_request_internal_scan(struct ieee80211_sub_if_data *sdata,
+				    const u8 *ssid, u8 ssid_len,
+				    struct ieee80211_channel *chan);
+int mac80211_request_scan(struct ieee80211_sub_if_data *sdata,
+			   struct cfg80211_scan_request *req);
+void mac80211_scan_cancel(struct ieee80211_local *local);
+ieee80211_rx_result
+mac80211_scan_rx(struct ieee80211_sub_if_data *sdata, struct sk_buff *skb);
+
+void mac80211_mlme_notify_scan_completed(struct ieee80211_local *local);
+struct ieee80211_bss *
+mac80211_bss_info_update(struct ieee80211_local *local,
+			  struct ieee80211_rx_status *rx_status,
+			  struct ieee80211_mgmt *mgmt,
+			  size_t len,
+			  struct ieee802_11_elems *elems,
+			  struct ieee80211_channel *channel,
+			  bool beacon);
+struct ieee80211_bss *
+mac80211_rx_bss_get(struct ieee80211_local *local, u8 *bssid, int freq,
+		     u8 *ssid, u8 ssid_len);
+void mac80211_rx_bss_put(struct ieee80211_local *local,
+			  struct ieee80211_bss *bss);
+
+/* scheduled scan handling */
+int mac80211_request_sched_scan_start(struct ieee80211_sub_if_data *sdata,
+				       struct cfg80211_sched_scan_request *req);
+int mac80211_request_sched_scan_stop(struct ieee80211_sub_if_data *sdata);
+void mac80211_sched_scan_stopped_work(struct work_struct *work);
+
+/* off-channel helpers */
+void ieee80211_offchannel_stop_beaconing(struct ieee80211_local *local);
+void ieee80211_offchannel_stop_station(struct ieee80211_local *local);
+void mac80211_offchannel_return(struct ieee80211_local *local,
+				 bool enable_beaconing);
+void mac80211_hw_roc_setup(struct ieee80211_local *local);
+void mac80211_start_next_roc(struct ieee80211_local *local);
+void mac80211_roc_purge(struct ieee80211_sub_if_data *sdata);
+void mac80211_roc_notify_destroy(struct ieee80211_roc_work *roc);
+void mac80211_sw_roc_work(struct work_struct *work);
+void mac80211_handle_roc_started(struct ieee80211_roc_work *roc);
+
+/* interface handling */
+int mac80211_iface_init(void);
+void mac80211_iface_exit(void);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+int mac80211_if_add(struct ieee80211_local *local, const char *name,
+		     unsigned char name_assign_type,
+		     struct wireless_dev **new_wdev, enum nl80211_iftype type,
+		     struct vif_params *params);
+#else
+int mac80211_if_add(struct ieee80211_local *local, const char *name,
+		     struct net_device **new_dev, enum nl80211_iftype type,
+		     struct vif_params *params);
+#endif
+
+int mac80211_if_change_type(struct ieee80211_sub_if_data *sdata,
+			     enum nl80211_iftype type);
+void mac80211_if_remove(struct ieee80211_sub_if_data *sdata);
+void mac80211_remove_interfaces(struct ieee80211_local *local);
+u32 __mac80211_recalc_idle(struct ieee80211_local *local);
+void mac80211_recalc_idle(struct ieee80211_local *local);
+void mac80211_adjust_monitor_flags(struct ieee80211_sub_if_data *sdata,
+				    const int offset);
+int ieee80211_do_open(struct wireless_dev *wdev, bool coming_up);
+void ieee80211_sdata_stop(struct ieee80211_sub_if_data *sdata);
+
+static inline bool ieee80211_sdata_running(struct ieee80211_sub_if_data *sdata)
+{
+	return test_bit(SDATA_STATE_RUNNING, &sdata->state);
+}
+
+static inline struct ieee80211_channel_state *ieee80211_get_channel_state(
+			struct ieee80211_local *local,
+			struct ieee80211_sub_if_data *sdata) {
+	if (local->hw.flags & IEEE80211_HW_SUPPORTS_MULTI_CHANNEL) {
+		BUG_ON(!sdata);
+		return &sdata->chan_state;
+	} else {
+		return &local->chan_state;
+	}
+}
+
+/* tx handling */
+void mac80211_clear_tx_pending(struct ieee80211_local *local);
+void mac80211_tx_pending(unsigned long data);
+netdev_tx_t mac80211_monitor_start_xmit(struct sk_buff *skb,
+					 struct net_device *dev);
+netdev_tx_t mac80211_subif_start_xmit(struct sk_buff *skb,
+				       struct net_device *dev);
+
+/* HT */
+void mac80211_ht_cap_ie_to_sta_ht_cap(struct ieee80211_supported_band *sband,
+				const struct ieee80211_ht_cap *ht_cap_ie,
+				       struct ieee80211_sta_ht_cap *ht_cap);
+void mac80211_send_delba(struct ieee80211_sub_if_data *sdata,
+			  const u8 *da, u16 tid,
+			  u16 initiator, u16 reason_code);
+int mac80211_send_smps_action(struct ieee80211_sub_if_data *sdata,
+			       enum ieee80211_smps_mode smps, const u8 *da,
+			       const u8 *bssid);
+void mac80211_request_smps_work(struct work_struct *work);
+
+void ___mac80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,
+				     u16 initiator, u16 reason, bool stop);
+void __mac80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,
+				    u16 initiator, u16 reason, bool stop);
+void mac80211_sta_tear_down_BA_sessions(struct sta_info *sta, bool tx);
+void mac80211_process_delba(struct ieee80211_sub_if_data *sdata,
+			     struct sta_info *sta,
+			     struct ieee80211_mgmt *mgmt, size_t len);
+void mac80211_process_addba_resp(struct ieee80211_local *local,
+				  struct sta_info *sta,
+				  struct ieee80211_mgmt *mgmt,
+				  size_t len);
+void mac80211_process_addba_request(struct ieee80211_local *local,
+				     struct sta_info *sta,
+				     struct ieee80211_mgmt *mgmt,
+				     size_t len);
+
+int __mac80211_stop_tx_ba_session(struct sta_info *sta, u16 tid,
+				   enum ieee80211_back_parties initiator,
+				   bool tx);
+int ___mac80211_stop_tx_ba_session(struct sta_info *sta, u16 tid,
+				    enum ieee80211_back_parties initiator,
+				    bool tx);
+void mac80211_start_tx_ba_cb(struct ieee80211_vif *vif, u8 *ra, u16 tid);
+void mac80211_stop_tx_ba_cb(struct ieee80211_vif *vif, u8 *ra, u8 tid);
+void mac80211_ba_session_work(struct work_struct *work);
+void mac80211_tx_ba_session_handle_start(struct sta_info *sta, int tid);
+void mac80211_release_reorder_timeout(struct sta_info *sta, int tid);
+
+/* Spectrum management */
+void mac80211_process_measurement_req(struct ieee80211_sub_if_data *sdata,
+				       struct ieee80211_mgmt *mgmt,
+				       size_t len);
+
+/* Suspend/resume and hw reconfiguration */
+int mac80211_reconfig(struct ieee80211_local *local);
+void mac80211_stop_device(struct ieee80211_local *local);
+
+#ifdef CONFIG_PM
+int __mac80211_suspend(struct ieee80211_hw *hw,
+			struct cfg80211_wowlan *wowlan);
+
+static inline int __ieee80211_resume(struct ieee80211_hw *hw)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+
+	WARN(test_bit(SCAN_HW_SCANNING, &local->scanning),
+		"%s: resume with hardware scan still in progress\n",
+		wiphy_name(hw->wiphy));
+
+	return mac80211_reconfig(hw_to_local(hw));
+}
+#else
+static inline int __mac80211_suspend(struct ieee80211_hw *hw,
+				      struct cfg80211_wowlan *wowlan)
+{
+	return 0;
+}
+
+static inline int __ieee80211_resume(struct ieee80211_hw *hw)
+{
+	return 0;
+}
+#endif
+
+/* utility functions/constants */
+extern void *xrmac_wiphy_privid; /* for wiphy privid */
+u8 *mac80211_get_bssid(struct ieee80211_hdr *hdr, size_t len,
+			enum nl80211_iftype type);
+int mac80211_frame_duration(enum nl80211_band band, size_t len,
+			     int rate, int erp, int short_preamble);
+void xrmac_ev_michael_mic_failure(struct ieee80211_sub_if_data *sdata, int keyidx,
+				     struct ieee80211_hdr *hdr, const u8 *tsc,
+				     gfp_t gfp);
+void mac80211_set_wmm_default(struct ieee80211_sub_if_data *sdata);
+void mac80211_xmit(struct ieee80211_sub_if_data *sdata, struct sk_buff *skb);
+void ieee80211_tx_skb(struct ieee80211_sub_if_data *sdata, struct sk_buff *skb);
+void mac802_11_parse_elems(u8 *start, size_t len,
+			    struct ieee802_11_elems *elems);
+u32 mac802_11_parse_elems_crc(u8 *start, size_t len,
+			       struct ieee802_11_elems *elems,
+			       u64 filter, u32 crc);
+u32 mac80211_mandatory_rates(struct ieee80211_local *local,
+			      enum nl80211_band band);
+
+void mac80211_dynamic_ps_enable_work(struct work_struct *work);
+void mac80211_dynamic_ps_disable_work(struct work_struct *work);
+void mac80211_dynamic_ps_timer(struct timer_list *t);
+void mac80211_send_nullfunc(struct ieee80211_local *local,
+			     struct ieee80211_sub_if_data *sdata,
+			     int powersave);
+void mac80211_sta_rx_notify(struct ieee80211_sub_if_data *sdata,
+			     struct ieee80211_hdr *hdr);
+void mac80211_sta_tx_notify(struct ieee80211_sub_if_data *sdata,
+			     struct ieee80211_hdr *hdr, bool ack);
+void mac80211_beacon_connection_loss_work(struct work_struct *work);
+
+void mac80211_wake_queues_by_reason(struct ieee80211_hw *hw,
+				     enum queue_stop_reason reason);
+void mac80211_stop_queues_by_reason(struct ieee80211_hw *hw,
+				     enum queue_stop_reason reason);
+void mac80211_wake_queue_by_reason(struct ieee80211_hw *hw, int queue,
+				    enum queue_stop_reason reason);
+void mac80211_stop_queue_by_reason(struct ieee80211_hw *hw, int queue,
+				    enum queue_stop_reason reason);
+void mac80211_propagate_queue_wake(struct ieee80211_local *local, int queue);
+void mac80211_add_pending_skb(struct ieee80211_local *local,
+			       struct sk_buff *skb);
+void mac80211_add_pending_skbs(struct ieee80211_local *local,
+				struct sk_buff_head *skbs);
+void mac80211_add_pending_skbs_fn(struct ieee80211_local *local,
+				   struct sk_buff_head *skbs,
+				   void (*fn)(void *data), void *data);
+
+void mac80211_send_auth(struct ieee80211_sub_if_data *sdata,
+			 u16 transaction, u16 auth_alg,
+			 u8 *extra, size_t extra_len, const u8 *bssid,
+			 const u8 *key, u8 key_len, u8 key_idx);
+int mac80211_build_preq_ies(struct ieee80211_local *local, u8 *buffer,
+			     const u8 *ie, size_t ie_len,
+			     enum nl80211_band band, u32 rate_mask,
+			     u8 channel);
+struct sk_buff *mac80211_build_probe_req(struct ieee80211_sub_if_data *sdata,
+					  u8 *dst, u32 ratemask,
+					  const u8 *ssid, size_t ssid_len,
+					  const u8 *ie, size_t ie_len,
+					  bool directed);
+void mac80211_send_probe_req(struct ieee80211_sub_if_data *sdata, u8 *dst,
+			      const u8 *ssid, size_t ssid_len,
+			      const u8 *ie, size_t ie_len,
+			      u32 ratemask, bool directed, bool no_cck);
+
+void mac80211_sta_def_wmm_params(struct ieee80211_sub_if_data *sdata,
+				  const size_t supp_rates_len,
+				  const u8 *supp_rates);
+u32 mac80211_sta_get_rates(struct ieee80211_local *local,
+			    struct ieee802_11_elems *elems,
+			    enum nl80211_band band);
+int __mac80211_request_smps(struct ieee80211_sub_if_data *sdata,
+			     enum ieee80211_smps_mode smps_mode);
+void mac80211_recalc_smps(struct ieee80211_local *local);
+
+size_t mac80211_ie_split(const u8 *ies, size_t ielen,
+			  const u8 *ids, int n_ids, size_t offset);
+size_t mac80211_ie_split_vendor(const u8 *ies, size_t ielen, size_t offset);
+
+/* internal work items */
+void mac80211_work_init(struct ieee80211_local *local);
+void mac80211_add_work(struct ieee80211_work *wk);
+void xrmac_free_work(struct ieee80211_work *wk);
+void mac80211_work_purge(struct ieee80211_sub_if_data *sdata);
+ieee80211_rx_result ieee80211_work_rx_mgmt(struct ieee80211_sub_if_data *sdata,
+					   struct sk_buff *skb);
+int mac80211_wk_remain_on_channel(struct ieee80211_sub_if_data *sdata,
+				   struct ieee80211_channel *chan,
+				   enum nl80211_channel_type channel_type,
+				   unsigned int duration, u64 *cookie);
+int mac80211_wk_cancel_remain_on_channel(
+	struct ieee80211_sub_if_data *sdata, u64 cookie);
+
+/* channel management */
+enum ieee80211_chan_mode {
+	CHAN_MODE_UNDEFINED,
+	CHAN_MODE_HOPPING,
+	CHAN_MODE_FIXED,
+};
+
+enum ieee80211_chan_mode
+mac80211_get_channel_mode(struct ieee80211_local *local,
+			   struct ieee80211_sub_if_data *ignore);
+bool mac80211_set_channel_type(struct ieee80211_local *local,
+				struct ieee80211_sub_if_data *sdata,
+				enum nl80211_channel_type chantype);
+
+bool ieee80211_cs_valid(const struct ieee80211_cipher_scheme *cs);
+bool ieee80211_cs_list_valid(const struct ieee80211_cipher_scheme *cs, int n);
+const struct ieee80211_cipher_scheme *
+ieee80211_cs_get(struct ieee80211_local *local, u32 cipher,
+		 enum nl80211_iftype iftype);
+int ieee80211_cs_headroom(struct ieee80211_local *local,
+			  struct cfg80211_crypto_settings *crypto,
+			  enum nl80211_iftype iftype);
+
+#ifdef CONFIG_XRMAC_NOINLINE
+#define debug_noinline noinline
+#else
+#define debug_noinline
+#endif
+
+#endif /* IEEE80211_I_H */
diff -Naurp a/drivers/net/wireless/xr829/umac/iface.c b/drivers/net/wireless/xr829/umac/iface.c
--- a/drivers/net/wireless/xr829/umac/iface.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/iface.c	2022-08-27 01:22:42.942539817 +0300
@@ -0,0 +1,1700 @@
+/*
+ * Interface handling (except master interface)
+ *
+ * Copyright 2002-2005, Instant802 Networks, Inc.
+ * Copyright 2005-2006, Devicescape Software, Inc.
+ * Copyright (c) 2006 Jiri Benc <jbenc@suse.cz>
+ * Copyright 2008, Johannes Berg <johannes@sipsolutions.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <generated/uapi/linux/version.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/if_arp.h>
+#include <linux/netdevice.h>
+#include <linux/rtnetlink.h>
+#include <net/mac80211.h>
+#include <net/ieee80211_radiotap.h>
+#include "ieee80211_i.h"
+#include "sta_info.h"
+#include "debugfs_netdev.h"
+#include "mesh.h"
+#include "led.h"
+#include "driver-ops.h"
+#include "wme.h"
+#include "rate.h"
+
+/**
+ * DOC: Interface list locking
+ *
+ * The interface list in each struct ieee80211_local is protected
+ * three-fold:
+ *
+ * (1) modifications may only be done under the RTNL
+ * (2) modifications and readers are protected against each other by
+ *     the iflist_mtx.
+ * (3) modifications are done in an RCU manner so atomic readers
+ *     can traverse the list in RCU-safe blocks.
+ *
+ * As a consequence, reads (traversals) of the list can be protected
+ * by either the RTNL, the iflist_mtx or RCU.
+ */
+
+
+static int ieee80211_change_mtu(struct net_device *dev, int new_mtu)
+{
+	int meshhdrlen;
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	meshhdrlen = (sdata->vif.type == NL80211_IFTYPE_MESH_POINT) ? 5 : 0;
+
+	/* FIX: what would be proper limits for MTU?
+	 * This interface uses 802.3 frames. */
+	if (new_mtu < 256 ||
+	    new_mtu > IEEE80211_MAX_DATA_LEN - 24 - 6 - meshhdrlen) {
+		return -EINVAL;
+	}
+
+#ifdef CONFIG_XRMAC_VERBOSE_DEBUG
+	printk(KERN_DEBUG "%s: setting MTU %d\n", dev->name, new_mtu);
+#endif /* CONFIG_XRMAC_VERBOSE_DEBUG */
+	dev->mtu = new_mtu;
+	return 0;
+}
+
+static int ieee80211_change_mac(struct net_device *dev, void *addr)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_local *local = sdata->local;
+	struct sockaddr *sa = addr;
+	int ret;
+
+	if (ieee80211_sdata_running(sdata))
+		return -EBUSY;
+
+	ret = drv_change_mac(local, sdata, sa);
+
+	if (ret == 0)
+		ret = eth_mac_addr(dev, sa);
+
+	if (ret == 0)
+		memcpy(sdata->vif.addr, sa->sa_data, ETH_ALEN);
+
+	return ret;
+}
+
+static inline int identical_mac_addr_allowed(int type1, int type2)
+{
+	return type1 == NL80211_IFTYPE_MONITOR ||
+		type2 == NL80211_IFTYPE_MONITOR ||
+		type1 == NL80211_IFTYPE_P2P_DEVICE ||
+		type2 == NL80211_IFTYPE_P2P_DEVICE ||
+		(type1 == NL80211_IFTYPE_AP && type2 == NL80211_IFTYPE_WDS) ||
+		(type1 == NL80211_IFTYPE_WDS &&
+			(type2 == NL80211_IFTYPE_WDS ||
+			 type2 == NL80211_IFTYPE_AP)) ||
+		(type1 == NL80211_IFTYPE_AP && type2 == NL80211_IFTYPE_AP_VLAN) ||
+		(type1 == NL80211_IFTYPE_AP_VLAN &&
+			(type2 == NL80211_IFTYPE_AP ||
+			 type2 == NL80211_IFTYPE_AP_VLAN));
+}
+
+static int ieee80211_check_concurrent_iface(struct ieee80211_sub_if_data *sdata,
+					    enum nl80211_iftype iftype)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_sub_if_data *nsdata;
+
+	ASSERT_RTNL();
+
+	/* we hold the RTNL here so can safely walk the list */
+	list_for_each_entry(nsdata, &local->interfaces, list) {
+
+		if (nsdata != sdata && ieee80211_sdata_running(nsdata)) {
+			/*
+			 * Allow only a single IBSS interface to be up at any
+			 * time. This is restricted because beacon distribution
+			 * cannot work properly if both are in the same IBSS.
+			 *
+			 * To remove this restriction we'd have to disallow them
+			 * from setting the same SSID on different IBSS interfaces
+			 * belonging to the same hardware. Then, however, we're
+			 * faced with having to adopt two different TSF timers...
+			 */
+			if (iftype == NL80211_IFTYPE_ADHOC &&
+			    nsdata->vif.type == NL80211_IFTYPE_ADHOC)
+				return -EBUSY;
+
+			/*
+			 * The remaining checks are only performed for interfaces
+			 * with the same MAC address.
+			 */
+			if (compare_ether_addr(sdata->vif.addr, nsdata->vif.addr))
+				continue;
+
+			/*
+			 * check whether it may have the same address
+			 */
+			if (!identical_mac_addr_allowed(iftype,
+							nsdata->vif.type))
+				return -ENOTUNIQ;
+
+			/*
+			 * can only add VLANs to enabled APs
+			 */
+			if (iftype == NL80211_IFTYPE_AP_VLAN &&
+			    nsdata->vif.type == NL80211_IFTYPE_AP)
+				sdata->bss = &nsdata->u.ap;
+		}
+	}
+
+	return 0;
+}
+
+static int ieee80211_check_queues(struct ieee80211_sub_if_data *sdata)
+{
+	int n_queues = sdata->local->hw.queues;
+	int i;
+
+	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
+		if (WARN_ON_ONCE(sdata->vif.hw_queue[i] ==
+				 IEEE80211_INVAL_HW_QUEUE))
+			return -EINVAL;
+		if (WARN_ON_ONCE(sdata->vif.hw_queue[i] >=
+				 n_queues))
+			return -EINVAL;
+	}
+
+	if ((sdata->vif.type != NL80211_IFTYPE_AP) ||
+	    !(sdata->local->hw.flags & IEEE80211_HW_QUEUE_CONTROL)) {
+		sdata->vif.cab_queue = IEEE80211_INVAL_HW_QUEUE;
+		return 0;
+	}
+
+	if (WARN_ON_ONCE(sdata->vif.cab_queue == IEEE80211_INVAL_HW_QUEUE))
+		return -EINVAL;
+
+	if (WARN_ON_ONCE(sdata->vif.cab_queue >= n_queues))
+		return -EINVAL;
+
+	return 0;
+}
+
+void mac80211_adjust_monitor_flags(struct ieee80211_sub_if_data *sdata,
+				    const int offset)
+{
+	u32 flags = sdata->u.mntr_flags, req_flags = 0;
+
+#define ADJUST(_f, _s) do {\
+	if (flags & MONITOR_FLAG_##_f)\
+		req_flags |= _s;\
+	} while (0)
+
+	ADJUST(PLCPFAIL, FIF_PLCPFAIL);
+	ADJUST(CONTROL, FIF_PSPOLL);
+	ADJUST(CONTROL, FIF_CONTROL);
+	ADJUST(FCSFAIL, FIF_FCSFAIL);
+	ADJUST(OTHER_BSS, FIF_OTHER_BSS);
+	if (offset > 0)
+		sdata->req_filt_flags |= req_flags;
+	else
+		sdata->req_filt_flags &= ~req_flags;
+
+#undef ADJUST
+}
+
+static void ieee80211_set_default_queues(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_local *local = sdata->local;
+	int i;
+
+	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
+		if (local->hw.flags & IEEE80211_HW_QUEUE_CONTROL)
+			sdata->vif.hw_queue[i] = IEEE80211_INVAL_HW_QUEUE;
+		else
+			sdata->vif.hw_queue[i] = i;
+	}
+	sdata->vif.cab_queue = IEEE80211_INVAL_HW_QUEUE;
+}
+
+/*
+ * NOTE: Be very careful when changing this function, it must NOT return
+ * an error on interface type changes that have been pre-checked, so most
+ * checks should be in ieee80211_check_concurrent_iface.
+ */
+int ieee80211_do_open(struct wireless_dev *wdev, bool coming_up)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);
+	struct net_device *dev = wdev->netdev;
+	struct ieee80211_local *local = sdata->local;
+	struct sta_info *sta;
+	u32 changed = 0;
+	int res;
+	u32 hw_reconf_flags = 0;
+
+	sdata->vif.bss_conf.chan_conf = &sdata->chan_state.conf;
+
+	switch (sdata->vif.type) {
+	case NL80211_IFTYPE_WDS:
+		if (!is_valid_ether_addr(sdata->u.wds.remote_addr))
+			return -ENOLINK;
+		break;
+	case NL80211_IFTYPE_AP_VLAN:
+		if (!sdata->bss)
+			return -ENOLINK;
+		list_add(&sdata->u.vlan.list, &sdata->bss->vlans);
+		break;
+	case NL80211_IFTYPE_AP:
+		sdata->bss = &sdata->u.ap;
+		break;
+	case NL80211_IFTYPE_MESH_POINT:
+	case NL80211_IFTYPE_STATION:
+	case NL80211_IFTYPE_MONITOR:
+	case NL80211_IFTYPE_ADHOC:
+	case NL80211_IFTYPE_P2P_DEVICE:
+	case NL80211_IFTYPE_OCB:
+	case NL80211_IFTYPE_NAN:
+		/* no special treatment */
+		break;
+	case NL80211_IFTYPE_UNSPECIFIED:
+	case NUM_NL80211_IFTYPES:
+	case NL80211_IFTYPE_P2P_CLIENT:
+	case NL80211_IFTYPE_P2P_GO:
+		/* cannot happen */
+		WARN_ON(1);
+		break;
+	}
+
+	if (local->open_count == 0) {
+		res = drv_start(local);
+		if (res)
+			goto err_del_bss;
+		/* we're brought up, everything changes */
+		hw_reconf_flags = ~0;
+		ieee80211_led_radio(local, true);
+		ieee80211_mod_tpt_led_trig(local,
+					   IEEE80211_TPT_LEDTRIG_FL_RADIO, 0);
+	}
+
+	/*
+	 * Copy the hopefully now-present MAC address to
+	 * this interface, if it has the special null one.
+	 */
+	if (dev && is_zero_ether_addr(dev->dev_addr)) {
+		memcpy(dev->dev_addr,
+		       local->hw.wiphy->perm_addr,
+		       ETH_ALEN);
+		memcpy(dev->perm_addr, dev->dev_addr, ETH_ALEN);
+
+		if (!is_valid_ether_addr(dev->dev_addr)) {
+			if (!local->open_count)
+				drv_stop(local);
+			return -EADDRNOTAVAIL;
+		}
+	}
+
+	switch (sdata->vif.type) {
+	case NL80211_IFTYPE_AP_VLAN:
+		/* no need to tell driver */
+		break;
+	case NL80211_IFTYPE_MONITOR:
+		if (sdata->u.mntr_flags & MONITOR_FLAG_COOK_FRAMES) {
+			local->cooked_mntrs++;
+			break;
+		}
+
+		/* must be before the call to mac80211_configure_filter */
+		local->monitors++;
+		if (local->monitors == 1) {
+			local->hw.conf.flags |= IEEE80211_CONF_MONITOR;
+			hw_reconf_flags |= IEEE80211_CONF_CHANGE_MONITOR;
+		}
+
+		if (coming_up) {
+			res = drv_add_interface(local, &sdata->vif);
+			if (res)
+				goto err_stop;
+		}
+
+		mac80211_adjust_monitor_flags(sdata, 1);
+		mac80211_configure_filter(sdata);
+
+		netif_carrier_on(dev);
+		break;
+	default:
+		if (coming_up) {
+		printk(KERN_ERR "%s: vif_type=%d, p2p=%d, ch=%d, addr=%02x:%02x:%02x:%02x:%02x:%02x\n",
+		   __func__, sdata->vif.type, sdata->vif.p2p,
+		   sdata->vif.bss_conf.chan_conf->channel->hw_value, sdata->vif.addr[0],
+		   sdata->vif.addr[1], sdata->vif.addr[2], sdata->vif.addr[3], sdata->vif.addr[4], sdata->vif.addr[5]);
+			res = drv_add_interface(local, &sdata->vif);
+			if (res)
+				goto err_stop;
+			res = ieee80211_check_queues(sdata);
+			if (res)
+				goto err_del_interface;
+		}
+
+		if (sdata->vif.type == NL80211_IFTYPE_AP) {
+			mac80211_configure_filter(sdata);
+		}
+
+		if (sdata->vif.type != NL80211_IFTYPE_P2P_DEVICE)
+			changed |= mac80211_reset_erp_info(sdata);
+		mac80211_bss_info_change_notify(sdata, changed);
+
+		switch (sdata->vif.type) {
+		case NL80211_IFTYPE_STATION:
+		case NL80211_IFTYPE_ADHOC:
+		case NL80211_IFTYPE_AP:
+		case NL80211_IFTYPE_MESH_POINT:
+		case NL80211_IFTYPE_OCB:
+			netif_carrier_off(dev);
+			break;
+		case NL80211_IFTYPE_WDS:
+		case NL80211_IFTYPE_P2P_DEVICE:
+		case NL80211_IFTYPE_NAN:
+			break;
+		default:
+			netif_carrier_on(dev);
+		}
+	}
+
+	set_bit(SDATA_STATE_RUNNING, &sdata->state);
+
+	if (sdata->vif.type == NL80211_IFTYPE_WDS) {
+		/* Create STA entry for the WDS peer */
+		sta = xrmac_sta_info_alloc(sdata, sdata->u.wds.remote_addr,
+				     GFP_KERNEL);
+		if (!sta) {
+			res = -ENOMEM;
+			goto err_del_interface;
+		}
+
+		/* no atomic bitop required since STA is not live yet */
+		set_sta_flag(sta, WLAN_STA_AUTHORIZED);
+
+		res = xrmac_sta_info_insert(sta);
+		if (res) {
+			/* STA has been freed */
+			goto err_del_interface;
+		}
+
+		rate_control_rate_init(sta);
+	} else if (sdata->vif.type == NL80211_IFTYPE_P2P_DEVICE) {
+		rcu_assign_pointer(local->p2p_sdata, sdata);
+	}
+
+	mutex_lock(&local->mtx);
+	hw_reconf_flags |= __mac80211_recalc_idle(local);
+	mutex_unlock(&local->mtx);
+
+	if (coming_up)
+		local->open_count++;
+
+	if (hw_reconf_flags) {
+		mac80211_hw_config(local, hw_reconf_flags);
+		/*
+		 * set default queue parameters so drivers don't
+		 * need to initialise the hardware if the hardware
+		 * doesn't start up with sane defaults
+		 */
+		mac80211_set_wmm_default(sdata);
+	}
+
+	mac80211_recalc_ps(local, -1);
+
+	if (dev)
+		netif_tx_start_all_queues(dev);
+
+	return 0;
+ err_del_interface:
+	drv_remove_interface(local, &sdata->vif);
+ err_stop:
+	if (!local->open_count)
+		drv_stop(local);
+ err_del_bss:
+	sdata->bss = NULL;
+	if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
+		list_del(&sdata->u.vlan.list);
+	clear_bit(SDATA_STATE_RUNNING, &sdata->state);
+	return res;
+}
+
+static int ieee80211_open(struct net_device *dev)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	int err;
+
+	/* fail early if user set an invalid address */
+	if (!is_valid_ether_addr(dev->dev_addr))
+		return -EADDRNOTAVAIL;
+
+	err = ieee80211_check_concurrent_iface(sdata, sdata->vif.type);
+	if (err)
+		return err;
+
+	return ieee80211_do_open(&sdata->wdev, true);
+}
+
+static void ieee80211_do_stop(struct ieee80211_sub_if_data *sdata,
+			      bool going_down)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sdata);
+	unsigned long flags;
+	struct sk_buff *skb, *tmp;
+	u32 hw_reconf_flags = 0;
+	int i;
+	enum nl80211_channel_type orig_ct;
+
+	clear_bit(SDATA_STATE_RUNNING, &sdata->state);
+
+	if (local->scan_sdata == sdata)
+		mac80211_scan_cancel(local);
+
+	/*
+	 * Stop TX on this interface first.
+	 */
+	if (sdata->dev)
+		netif_tx_stop_all_queues(sdata->dev);
+
+	mac80211_roc_purge(sdata);
+	/*
+	 * Purge work for this interface.
+	 */
+	mac80211_work_purge(sdata);
+
+	/*
+	 * Remove all stations associated with this interface.
+	 *
+	 * This must be done before calling ops->remove_interface()
+	 * because otherwise we can later invoke ops->sta_notify()
+	 * whenever the STAs are removed, and that invalidates driver
+	 * assumptions about always getting a vif pointer that is valid
+	 * (because if we remove a STA after ops->remove_interface()
+	 * the driver will have removed the vif info already!)
+	 *
+	 * This is relevant only in AP, WDS and mesh modes, since in
+	 * all other modes we've already removed all stations when
+	 * disconnecting etc.
+	 */
+	xrmac_sta_info_flush(local, sdata);
+
+	if (sdata->dev) {
+		netif_addr_lock_bh(sdata->dev);
+		spin_lock_bh(&local->filter_lock);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
+		__hw_addr_unsync(&sdata->mc_list, &sdata->dev->mc,
+				 sdata->dev->addr_len);
+#else
+		__dev_addr_unsync(&sdata->mc_list, &sdata->mc_count,
+				  &sdata->dev->mc_list, &sdata->dev->mc_count);
+#endif
+		spin_unlock_bh(&local->filter_lock);
+		netif_addr_unlock_bh(sdata->dev);
+
+		mac80211_configure_filter(sdata);
+	}
+
+	del_timer_sync(&sdata->dynamic_ps_timer);
+	cancel_work_sync(&sdata->dynamic_ps_enable_work);
+
+	/* APs need special treatment */
+	if (sdata->vif.type == NL80211_IFTYPE_AP) {
+		struct ieee80211_sub_if_data *vlan, *tmpsdata;
+		struct beacon_data *old_beacon =
+			rtnl_dereference(sdata->u.ap.beacon);
+
+		/* sdata_running will return false, so this will disable */
+		mac80211_bss_info_change_notify(sdata,
+						 BSS_CHANGED_BEACON_ENABLED);
+
+		/* remove beacon */
+		RCU_INIT_POINTER(sdata->u.ap.beacon, NULL);
+		synchronize_rcu();
+		kfree(old_beacon);
+
+		/* down all dependent devices, that is VLANs */
+		list_for_each_entry_safe(vlan, tmpsdata, &sdata->u.ap.vlans,
+					 u.vlan.list)
+			dev_close(vlan->dev);
+		WARN_ON(!list_empty(&sdata->u.ap.vlans));
+
+		/* free all potentially still buffered bcast frames */
+		local->total_ps_buffered -= skb_queue_len(&sdata->u.ap.ps_bc_buf);
+		skb_queue_purge(&sdata->u.ap.ps_bc_buf);
+	}
+
+	if (going_down)
+		local->open_count--;
+
+	switch (sdata->vif.type) {
+	case NL80211_IFTYPE_AP_VLAN:
+		list_del(&sdata->u.vlan.list);
+		/* no need to tell driver */
+		break;
+	case NL80211_IFTYPE_MONITOR:
+		if (sdata->u.mntr_flags & MONITOR_FLAG_COOK_FRAMES) {
+			local->cooked_mntrs--;
+			break;
+		}
+
+		local->monitors--;
+		if (local->monitors == 0) {
+			local->hw.conf.flags &= ~IEEE80211_CONF_MONITOR;
+			hw_reconf_flags |= IEEE80211_CONF_CHANGE_MONITOR;
+		}
+
+		mac80211_adjust_monitor_flags(sdata, -1);
+		mac80211_configure_filter(sdata);
+
+		if (going_down)
+			drv_remove_interface(local, &sdata->vif);
+
+		break;
+	case NL80211_IFTYPE_P2P_DEVICE:
+		/* relies on synchronize_rcu() below */
+		rcu_assign_pointer(local->p2p_sdata, NULL);
+		/* fall through */
+	default:
+		flush_work(&sdata->work);
+		/*
+		 * When we get here, the interface is marked down.
+		 * Call synchronize_rcu() to wait for the RX path
+		 * should it be using the interface and enqueuing
+		 * frames at this very time on another CPU.
+		 */
+		synchronize_rcu();
+		skb_queue_purge(&sdata->skb_queue);
+
+		/*
+		 * Disable beaconing here for mesh only, AP and IBSS
+		 * are already taken care of.
+		 */
+		if (sdata->vif.type == NL80211_IFTYPE_MESH_POINT)
+			mac80211_bss_info_change_notify(sdata,
+				BSS_CHANGED_BEACON_ENABLED);
+
+		/*
+		 * Free all remaining keys, there shouldn't be any,
+		 * except maybe group keys in AP more or WDS?
+		 */
+		mac80211_free_keys(sdata);
+
+		if (going_down)
+			drv_remove_interface(local, &sdata->vif);
+	}
+
+	sdata->bss = NULL;
+
+	mutex_lock(&local->mtx);
+	hw_reconf_flags |= __mac80211_recalc_idle(local);
+	mutex_unlock(&local->mtx);
+
+	mac80211_recalc_ps(local, -1);
+
+	if (local->open_count == 0) {
+		mac80211_clear_tx_pending(local);
+		mac80211_stop_device(local);
+
+		/* no reconfiguring after stop! */
+		hw_reconf_flags = 0;
+	}
+
+	/* Re-calculate channel-type, in case there are multiple vifs
+	 * on different channel types.
+	 */
+	orig_ct = chan_state->_oper_channel_type;
+	if (local->hw.flags & IEEE80211_HW_SUPPORTS_MULTI_CHANNEL)
+		mac80211_set_channel_type(local, sdata, NL80211_CHAN_NO_HT);
+	else
+		mac80211_set_channel_type(local, NULL, NL80211_CHAN_NO_HT);
+
+	/* do after stop to avoid reconfiguring when we stop anyway */
+	if (hw_reconf_flags || (orig_ct != chan_state->_oper_channel_type))
+		mac80211_hw_config(local, hw_reconf_flags);
+
+	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
+	for (i = 0; i < IEEE80211_MAX_QUEUES; i++) {
+		skb_queue_walk_safe(&local->pending[i], skb, tmp) {
+			struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+			if (info->control.vif == &sdata->vif) {
+				__skb_unlink(skb, &local->pending[i]);
+				dev_kfree_skb_irq(skb);
+			}
+		}
+	}
+	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
+}
+
+static int ieee80211_stop(struct net_device *dev)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	ieee80211_do_stop(sdata, true);
+
+	return 0;
+}
+
+static void ieee80211_set_multicast_list(struct net_device *dev)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_local *local = sdata->local;
+	int allmulti, promisc, sdata_allmulti, sdata_promisc;
+
+#if 0
+	if (!(SDATA_STATE_RUNNING & sdata->state))
+		return;
+#endif
+
+	allmulti = !!(dev->flags & IFF_ALLMULTI);
+	promisc = !!(dev->flags & IFF_PROMISC);
+	sdata_allmulti = !!(sdata->flags & IEEE80211_SDATA_ALLMULTI);
+	sdata_promisc = !!(sdata->flags & IEEE80211_SDATA_PROMISC);
+
+	if (allmulti != sdata_allmulti)
+		sdata->flags ^= IEEE80211_SDATA_ALLMULTI;
+
+	if (promisc != sdata_promisc)
+		sdata->flags ^= IEEE80211_SDATA_PROMISC;
+
+	spin_lock_bh(&local->filter_lock);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
+	__hw_addr_sync(&sdata->mc_list, &dev->mc, dev->addr_len);
+#else
+	__dev_addr_sync(&sdata->mc_list, &sdata->mc_count,
+			&dev->mc_list, &dev->mc_count);
+#endif
+	spin_unlock_bh(&local->filter_lock);
+	mac80211_queue_work(&local->hw, &sdata->reconfig_filter);
+}
+
+/*
+ * Called when the netdev is removed or, by the code below, before
+ * the interface type changes.
+ */
+static void ieee80211_teardown_sdata(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_local *local = sdata->local;
+	int flushed;
+	int i;
+
+	/* free extra data */
+	mac80211_free_keys(sdata);
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	mac80211_debugfs_remove_netdev(sdata);
+#endif
+
+	for (i = 0; i < IEEE80211_FRAGMENT_MAX; i++)
+		__skb_queue_purge(&sdata->fragments[i].skb_list);
+	sdata->fragment_next = 0;
+
+	if (ieee80211_vif_is_mesh(&sdata->vif))
+		xrmac_mesh_rmc_free(sdata);
+
+	flushed = xrmac_sta_info_flush(local, sdata);
+	WARN_ON(flushed);
+}
+
+static void ieee80211_uninit(struct net_device *dev)
+{
+	ieee80211_teardown_sdata(IEEE80211_DEV_TO_SUB_IF(dev));
+}
+
+static u16 ieee80211_netdev_select_queue(struct net_device *dev,
+					 struct sk_buff *skb,
+					 struct net_device *sb_dev)
+{
+	return mac80211_select_queue(IEEE80211_DEV_TO_SUB_IF(dev), skb);
+}
+
+static const struct net_device_ops ieee80211_dataif_ops = {
+	.ndo_open		= ieee80211_open,
+	.ndo_stop		= ieee80211_stop,
+	.ndo_uninit		= ieee80211_uninit,
+	.ndo_start_xmit		= mac80211_subif_start_xmit,
+	.ndo_set_rx_mode	= ieee80211_set_multicast_list,
+	.ndo_change_mtu 	= ieee80211_change_mtu,
+	.ndo_set_mac_address 	= ieee80211_change_mac,
+	.ndo_select_queue	= ieee80211_netdev_select_queue,
+};
+
+static u16 ieee80211_monitor_select_queue(struct net_device *dev,
+					  struct sk_buff *skb,
+					  struct net_device *sb_dev)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_hdr *hdr;
+	struct ieee80211_radiotap_header *rtap = (void *)skb->data;
+	u8 *p;
+
+	if (local->hw.queues < IEEE80211_NUM_ACS)
+		return 0;
+
+	if (skb->len < 4 ||
+	    skb->len < le16_to_cpu(rtap->it_len) + 2 /* frame control */)
+		return 0; /* doesn't matter, frame will be dropped */
+
+	hdr = (void *)((u8 *)skb->data + le16_to_cpu(rtap->it_len));
+
+	if (!ieee80211_is_data(hdr->frame_control)) {
+		skb->priority = 7;
+		return mac802_1d_to_ac[skb->priority];
+	}
+	if (!ieee80211_is_data_qos(hdr->frame_control)) {
+		skb->priority = 0;
+		return mac802_1d_to_ac[skb->priority];
+	}
+
+	p = ieee80211_get_qos_ctl(hdr);
+	skb->priority = *p & IEEE80211_QOS_CTL_TAG1D_MASK;
+
+	return mac80211_downgrade_queue(local, skb);
+}
+
+static const struct net_device_ops ieee80211_monitorif_ops = {
+	.ndo_open		= ieee80211_open,
+	.ndo_stop		= ieee80211_stop,
+	.ndo_uninit		= ieee80211_uninit,
+	.ndo_start_xmit		= mac80211_monitor_start_xmit,
+	.ndo_set_rx_mode	= ieee80211_set_multicast_list,
+	.ndo_change_mtu 	= ieee80211_change_mtu,
+	.ndo_set_mac_address 	= eth_mac_addr,
+	.ndo_select_queue	= ieee80211_monitor_select_queue,
+};
+
+static void ieee80211_if_setup(struct net_device *dev)
+{
+	ether_setup(dev);
+	dev->priv_flags &= ~IFF_TX_SKB_SHARING;
+	dev->netdev_ops = &ieee80211_dataif_ops;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29))
+	/* Do we need this ? */
+	/* we will validate the address ourselves in ->open */
+	dev->validate_addr = NULL;
+#endif
+	dev->priv_destructor = free_netdev;
+}
+static void ieee80211_iface_work(struct work_struct *work)
+{
+	struct ieee80211_sub_if_data *sdata =
+		container_of(work, struct ieee80211_sub_if_data, work);
+	struct ieee80211_local *local = sdata->local;
+	struct sk_buff *skb;
+	struct sta_info *sta;
+	struct ieee80211_ra_tid *ra_tid;
+	struct cfg80211_bss *bss;
+
+	if (!ieee80211_sdata_running(sdata))
+		return;
+
+	if (local->scanning)
+		return;
+
+	/*
+	 * mac80211_queue_work() should have picked up most cases,
+	 * here we'll pick the rest.
+	 */
+	if (WARN(local->suspended,
+		 "interface work scheduled while going to suspend\n"))
+		return;
+
+	/* first process frames */
+	while ((skb = skb_dequeue(&sdata->skb_queue))) {
+		struct ieee80211_mgmt *mgmt = (void *)skb->data;
+
+		if (skb->pkt_type == IEEE80211_SDATA_QUEUE_AGG_START) {
+			ra_tid = (void *)&skb->cb;
+			mac80211_start_tx_ba_cb(&sdata->vif, ra_tid->ra,
+						 ra_tid->tid);
+		} else if (skb->pkt_type == IEEE80211_SDATA_QUEUE_AGG_STOP) {
+			ra_tid = (void *)&skb->cb;
+			mac80211_stop_tx_ba_cb(&sdata->vif, ra_tid->ra,
+						ra_tid->tid);
+		} else if (ieee80211_is_action(mgmt->frame_control) &&
+			   mgmt->u.action.category == WLAN_CATEGORY_BACK) {
+			int len = skb->len;
+
+			mutex_lock(&local->sta_mtx);
+			sta = xrmac_sta_info_get_bss(sdata, mgmt->sa);
+			if (sta) {
+				switch (mgmt->u.action.u.addba_req.action_code) {
+				case WLAN_ACTION_ADDBA_REQ:
+					mac80211_process_addba_request(
+							local, sta, mgmt, len);
+					break;
+				case WLAN_ACTION_ADDBA_RESP:
+					mac80211_process_addba_resp(local, sta,
+								     mgmt, len);
+					break;
+				case WLAN_ACTION_DELBA:
+					mac80211_process_delba(sdata, sta,
+								mgmt, len);
+					break;
+				default:
+					WARN_ON(1);
+					break;
+				}
+			}
+			mutex_unlock(&local->sta_mtx);
+		} else if (ieee80211_is_data_qos(mgmt->frame_control)) {
+			struct ieee80211_hdr *hdr = (void *)mgmt;
+			/*
+			 * So the frame isn't mgmt, but frame_control
+			 * is at the right place anyway, of course, so
+			 * the if statement is correct.
+			 *
+			 * Warn if we have other data frame types here,
+			 * they must not get here.
+			 */
+			WARN_ON(hdr->frame_control &
+					cpu_to_le16(IEEE80211_STYPE_NULLFUNC));
+			WARN_ON(!(hdr->seq_ctrl &
+					cpu_to_le16(IEEE80211_SCTL_FRAG)));
+			/*
+			 * This was a fragment of a frame, received while
+			 * a block-ack session was active. That cannot be
+			 * right, so terminate the session.
+			 */
+			mutex_lock(&local->sta_mtx);
+			sta = xrmac_sta_info_get_bss(sdata, mgmt->sa);
+			if (sta) {
+				u16 tid = *ieee80211_get_qos_ctl(hdr) &
+						IEEE80211_QOS_CTL_TID_MASK;
+
+				__mac80211_stop_rx_ba_session(
+					sta, tid, WLAN_BACK_RECIPIENT,
+					WLAN_REASON_QSTA_REQUIRE_SETUP,
+					true);
+			}
+			mutex_unlock(&local->sta_mtx);
+		} else {
+			switch (sdata->vif.type) {
+			case NL80211_IFTYPE_AP:
+			case NL80211_IFTYPE_P2P_GO:
+				if (ieee80211_is_beacon(mgmt->frame_control)) {
+					struct ieee80211_bss_conf *bss_conf =
+						&sdata->vif.bss_conf;
+					u32 bss_info_changed = 0, erp = 0;
+					struct ieee80211_channel *channel =
+						ieee80211_get_channel(local->hw.wiphy,
+								IEEE80211_SKB_RXCB(skb)->freq);
+					bss = cfg80211_inform_bss_frame(local->hw.wiphy, channel,
+							mgmt, skb->len,
+							IEEE80211_SKB_RXCB(skb)->signal, GFP_ATOMIC);
+
+					/*
+					erp = cfg80211_get_local_erp(local->hw.wiphy,
+							IEEE80211_SKB_RXCB(skb)->freq);
+					 */
+					erp = ieee80211_get_local_erp(mgmt, skb->len);
+					bss_conf->ap_rx_beacon_erp_info |= erp;
+					if (!!bss_conf->use_cts_prot !=
+							!!(bss_conf->ap_rx_beacon_erp_info & WLAN_ERP_USE_PROTECTION)) {
+						bss_conf->use_cts_prot =
+							!!(bss_conf->ap_rx_beacon_erp_info & WLAN_ERP_USE_PROTECTION);
+						bss_info_changed |= BSS_CHANGED_ERP_CTS_PROT;
+					}
+					mac80211_bss_info_change_notify(sdata,
+							bss_info_changed);
+				};
+				break;
+			case NL80211_IFTYPE_STATION:
+				mac80211_sta_rx_queued_mgmt(sdata, skb);
+				break;
+			case NL80211_IFTYPE_ADHOC:
+				mac80211_ibss_rx_queued_mgmt(sdata, skb);
+				break;
+			case NL80211_IFTYPE_MESH_POINT:
+				if (!ieee80211_vif_is_mesh(&sdata->vif))
+					break;
+				mac80211_mesh_rx_queued_mgmt(sdata, skb);
+				break;
+			default:
+				WARN(1, "frame for unexpected interface type");
+				break;
+			}
+		}
+		kfree_skb(skb);
+	}
+
+	/* then other type-dependent work */
+	switch (sdata->vif.type) {
+	case NL80211_IFTYPE_STATION:
+		mac80211_sta_work(sdata);
+		break;
+	case NL80211_IFTYPE_ADHOC:
+		mac80211_ibss_work(sdata);
+		break;
+	case NL80211_IFTYPE_MESH_POINT:
+		if (!ieee80211_vif_is_mesh(&sdata->vif))
+			break;
+		mac80211_mesh_work(sdata);
+		break;
+	default:
+		break;
+	}
+}
+
+static void mac80211_reconfig_filter(struct work_struct *work)
+{
+	struct ieee80211_sub_if_data *sdata =
+		container_of(work, struct ieee80211_sub_if_data,
+			     reconfig_filter);
+
+	mac80211_configure_filter(sdata);
+}
+
+/*
+ * Helper function to initialise an interface to a specific type.
+ */
+static void ieee80211_setup_sdata(struct ieee80211_sub_if_data *sdata,
+				  enum nl80211_iftype type)
+{
+	/* clear type-dependent union */
+	memset(&sdata->u, 0, sizeof(sdata->u));
+
+#ifdef CONFIG_XRMAC_XR_ROAMING_CHANGES
+	sdata->queues_locked = 0;
+#endif
+	/* and set some type-dependent values */
+	sdata->vif.type = type;
+	sdata->vif.p2p = false;
+	sdata->wdev.iftype = type;
+
+	sdata->control_port_protocol = cpu_to_be16(ETH_P_PAE);
+	sdata->control_port_no_encrypt = false;
+
+	/* only monitor/p2p-device differ */
+	if (sdata->dev) {
+		sdata->dev->netdev_ops = &ieee80211_dataif_ops;
+		sdata->dev->type = ARPHRD_ETHER;
+	}
+
+	skb_queue_head_init(&sdata->skb_queue);
+	INIT_WORK(&sdata->work, ieee80211_iface_work);
+	INIT_WORK(&sdata->reconfig_filter, mac80211_reconfig_filter);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
+
+	__hw_addr_init(&sdata->mc_list);
+
+#endif
+
+
+	/*
+	 * Initialize wiphy parameters to IEEE 802.11 MIB default values.
+	 * RTS threshold is disabled by default with the special -1 value.
+	 */
+	sdata->vif.bss_conf.retry_short = sdata->wdev.wiphy->retry_short = 7;
+	sdata->vif.bss_conf.retry_long = sdata->wdev.wiphy->retry_long = 4;
+	sdata->wdev.wiphy->rts_threshold = (u32) -1;
+
+	switch (type) {
+	case NL80211_IFTYPE_P2P_GO:
+		type = NL80211_IFTYPE_AP;
+		sdata->vif.type = type;
+		sdata->vif.p2p = true;
+		/* fall through */
+	case NL80211_IFTYPE_AP:
+		skb_queue_head_init(&sdata->u.ap.ps_bc_buf);
+		INIT_LIST_HEAD(&sdata->u.ap.vlans);
+		sdata->local->uapsd_queues = IEEE80211_DEFAULT_UAPSD_QUEUES;
+		break;
+	case NL80211_IFTYPE_P2P_CLIENT:
+		type = NL80211_IFTYPE_STATION;
+		sdata->vif.type = type;
+		sdata->vif.p2p = true;
+		/* fall through */
+	case NL80211_IFTYPE_STATION:
+		mac80211_sta_setup_sdata(sdata);
+		break;
+	case NL80211_IFTYPE_OCB:
+		printk(KERN_WARNING "not support yet!\n");
+		break;
+	case NL80211_IFTYPE_ADHOC:
+		sdata->vif.bss_conf.bssid = sdata->u.ibss.bssid;
+		mac80211_ibss_setup_sdata(sdata);
+		break;
+	case NL80211_IFTYPE_MESH_POINT:
+		if (ieee80211_vif_is_mesh(&sdata->vif))
+			mac80211_mesh_init_sdata(sdata);
+		break;
+	case NL80211_IFTYPE_MONITOR:
+		sdata->dev->type = ARPHRD_IEEE80211_RADIOTAP;
+		sdata->dev->netdev_ops = &ieee80211_monitorif_ops;
+		sdata->u.mntr_flags = MONITOR_FLAG_CONTROL |
+				      MONITOR_FLAG_OTHER_BSS;
+		break;
+	case NL80211_IFTYPE_WDS:
+	case NL80211_IFTYPE_NAN:
+	case NL80211_IFTYPE_AP_VLAN:
+	case NL80211_IFTYPE_P2P_DEVICE:
+		break;
+	case NL80211_IFTYPE_UNSPECIFIED:
+	case NUM_NL80211_IFTYPES:
+		BUG();
+		break;
+	}
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	mac80211_debugfs_add_netdev(sdata);
+#endif /* CONFIG_XRMAC_DEBUGFS */
+	drv_bss_info_changed(sdata->local, sdata, &sdata->vif.bss_conf,
+			     BSS_CHANGED_RETRY_LIMITS);
+}
+
+static int ieee80211_runtime_change_iftype(struct ieee80211_sub_if_data *sdata,
+					   enum nl80211_iftype type)
+{
+	struct ieee80211_local *local = sdata->local;
+	int ret, err;
+	enum nl80211_iftype internal_type = type;
+	bool p2p = false;
+
+	ASSERT_RTNL();
+
+	if (!local->ops->change_interface)
+		return -EBUSY;
+
+	switch (sdata->vif.type) {
+	case NL80211_IFTYPE_AP:
+	case NL80211_IFTYPE_STATION:
+	case NL80211_IFTYPE_ADHOC:
+		/*
+		 * Could maybe also all others here?
+		 * Just not sure how that interacts
+		 * with the RX/config path e.g. for
+		 * mesh.
+		 */
+		break;
+	default:
+		return -EBUSY;
+	}
+
+	switch (type) {
+	case NL80211_IFTYPE_AP:
+	case NL80211_IFTYPE_STATION:
+	case NL80211_IFTYPE_ADHOC:
+		/*
+		 * Could probably support everything
+		 * but WDS here (WDS do_open can fail
+		 * under memory pressure, which this
+		 * code isn't prepared to handle).
+		 */
+		break;
+	case NL80211_IFTYPE_P2P_CLIENT:
+		p2p = true;
+		internal_type = NL80211_IFTYPE_STATION;
+		break;
+	case NL80211_IFTYPE_P2P_GO:
+		p2p = true;
+		internal_type = NL80211_IFTYPE_AP;
+		break;
+	default:
+		return -EBUSY;
+	}
+
+	ret = ieee80211_check_concurrent_iface(sdata, internal_type);
+	if (ret)
+		return ret;
+
+	ieee80211_do_stop(sdata, false);
+
+	ieee80211_teardown_sdata(sdata);
+
+	ret = drv_change_interface(local, sdata, internal_type, p2p);
+	if (ret)
+		type = sdata->vif.type;
+
+	/*
+	 * Ignore return value here, there's not much we can do since
+	 * the driver changed the interface type internally already.
+	 * The warnings will hopefully make driver authors fix it :-)
+	 */
+	ieee80211_check_queues(sdata);
+
+	ieee80211_setup_sdata(sdata, type);
+
+	err = ieee80211_do_open(&sdata->wdev, false);
+	WARN(err, "type change: do_open returned %d", err);
+
+	return ret;
+}
+
+int mac80211_if_change_type(struct ieee80211_sub_if_data *sdata,
+			     enum nl80211_iftype type)
+{
+	struct ieee80211_channel_state *chan_state =
+			ieee80211_get_channel_state(sdata->local, sdata);
+	int ret;
+
+	ASSERT_RTNL();
+
+	if (type == ieee80211_vif_type_p2p(&sdata->vif))
+		return 0;
+
+	if (ieee80211_sdata_running(sdata)) {
+		ret = ieee80211_runtime_change_iftype(sdata, type);
+		if (ret)
+			return ret;
+	} else {
+		/* Purge and reset type-dependent state. */
+		ieee80211_teardown_sdata(sdata);
+		ieee80211_setup_sdata(sdata, type);
+	}
+
+	/* reset some values that shouldn't be kept across type changes */
+	sdata->vif.bss_conf.basic_rates =
+		mac80211_mandatory_rates(sdata->local,
+			chan_state->conf.channel->band);
+	sdata->drop_unencrypted = 0;
+	if (type == NL80211_IFTYPE_STATION)
+		sdata->u.mgd.use_4addr = false;
+
+	return 0;
+}
+
+static void ieee80211_assign_perm_addr(struct ieee80211_local *local,
+				       u8 *perm_addr, enum nl80211_iftype type)
+{
+	struct ieee80211_sub_if_data *sdata;
+	u64 mask, start, addr, val, inc;
+	u8 *m;
+	u8 tmp_addr[ETH_ALEN];
+	int i;
+
+	/* default ... something at least */
+	memcpy(perm_addr, local->hw.wiphy->perm_addr, ETH_ALEN);
+
+	if (is_zero_ether_addr(local->hw.wiphy->addr_mask) &&
+	    local->hw.wiphy->n_addresses <= 1)
+		return;
+
+
+	mutex_lock(&local->iflist_mtx);
+
+	switch (type) {
+	case NL80211_IFTYPE_MONITOR:
+		/* doesn't matter */
+		break;
+	case NL80211_IFTYPE_WDS:
+	case NL80211_IFTYPE_AP_VLAN:
+		/* match up with an AP interface */
+		list_for_each_entry(sdata, &local->interfaces, list) {
+			if (sdata->vif.type != NL80211_IFTYPE_AP)
+				continue;
+			memcpy(perm_addr, sdata->vif.addr, ETH_ALEN);
+			break;
+		}
+		/* keep default if no AP interface present */
+		break;
+	default:
+		/* assign a new address if possible -- try n_addresses first */
+		for (i = 0; i < local->hw.wiphy->n_addresses; i++) {
+			bool used = false;
+
+			list_for_each_entry(sdata, &local->interfaces, list) {
+				if (memcmp(local->hw.wiphy->addresses[i].addr,
+					   sdata->vif.addr, ETH_ALEN) == 0) {
+					used = true;
+					break;
+				}
+			}
+
+			if (!used) {
+				memcpy(perm_addr,
+				       local->hw.wiphy->addresses[i].addr,
+				       ETH_ALEN);
+				break;
+			}
+		}
+
+		/* try mask if available */
+		if (is_zero_ether_addr(local->hw.wiphy->addr_mask))
+			break;
+
+		m = local->hw.wiphy->addr_mask;
+		mask =	((u64)m[0] << 5*8) | ((u64)m[1] << 4*8) |
+			((u64)m[2] << 3*8) | ((u64)m[3] << 2*8) |
+			((u64)m[4] << 1*8) | ((u64)m[5] << 0*8);
+
+		if (__ffs64(mask) + hweight64(mask) != fls64(mask)) {
+			/* not a contiguous mask ... not handled now! */
+			printk(KERN_DEBUG "not contiguous\n");
+			break;
+		}
+
+		m = local->hw.wiphy->perm_addr;
+		start = ((u64)m[0] << 5*8) | ((u64)m[1] << 4*8) |
+			((u64)m[2] << 3*8) | ((u64)m[3] << 2*8) |
+			((u64)m[4] << 1*8) | ((u64)m[5] << 0*8);
+
+		inc = 1ULL<<__ffs64(mask);
+		val = (start & mask);
+		addr = (start & ~mask) | (val & mask);
+		do {
+			bool used = false;
+
+			tmp_addr[5] = addr >> 0*8;
+			tmp_addr[4] = addr >> 1*8;
+			tmp_addr[3] = addr >> 2*8;
+			tmp_addr[2] = addr >> 3*8;
+			tmp_addr[1] = addr >> 4*8;
+			tmp_addr[0] = addr >> 5*8;
+
+			val += inc;
+
+			list_for_each_entry(sdata, &local->interfaces, list) {
+				if (memcmp(tmp_addr, sdata->vif.addr,
+							ETH_ALEN) == 0) {
+					used = true;
+					break;
+				}
+			}
+
+			if (!used) {
+				memcpy(perm_addr, tmp_addr, ETH_ALEN);
+				break;
+			}
+			addr = (start & ~mask) | (val & mask);
+		} while (addr != start);
+
+		break;
+	}
+
+	mutex_unlock(&local->iflist_mtx);
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+int mac80211_if_add(struct ieee80211_local *local, const char *name,
+		     unsigned char name_assign_type,
+		     struct wireless_dev **new_wdev, enum nl80211_iftype type,
+		     struct vif_params *params)
+#else
+int mac80211_if_add(struct ieee80211_local *local, const char *name,
+		     struct net_device **new_dev, enum nl80211_iftype type,
+		     struct vif_params *params)
+#endif
+{
+	struct net_device *ndev = NULL;
+	struct ieee80211_sub_if_data *sdata = NULL;
+	int ret, i;
+	int txqs = 1;
+
+	ASSERT_RTNL();
+
+	if (type == NL80211_IFTYPE_P2P_DEVICE) {
+		struct wireless_dev *wdev;
+
+		sdata = kzalloc(sizeof(*sdata) + local->hw.vif_data_size,
+				GFP_KERNEL);
+		if (!sdata)
+			return -ENOMEM;
+		wdev = &sdata->wdev;
+
+		sdata->dev = NULL;
+		strlcpy(sdata->name, name, IFNAMSIZ);
+		ieee80211_assign_perm_addr(local, wdev->address, type);
+		memcpy(sdata->vif.addr, wdev->address, ETH_ALEN);
+	} else {
+		if (local->hw.queues >= IEEE80211_NUM_ACS)
+			txqs = IEEE80211_NUM_ACS;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+		ndev = alloc_netdev_mqs(sizeof(*sdata) + local->hw.vif_data_size,
+					name, name_assign_type, ieee80211_if_setup, txqs, 1);
+#else
+		ndev = alloc_netdev_mqs(sizeof(*sdata) + local->hw.vif_data_size,
+					name, ieee80211_if_setup, txqs, 1);
+#endif
+		if (!ndev)
+			return -ENOMEM;
+		dev_net_set(ndev, wiphy_net(local->hw.wiphy));
+
+/* This is an optimization, just ignore for older kernels */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26))
+		ndev->needed_headroom = local->tx_headroom +
+					4*6 /* four MAC addresses */
+					+ 2 + 2 + 2 + 2 /* ctl, dur, seq, qos */
+					+ 6 /* mesh */
+					+ 8 /* rfc1042/bridge tunnel */
+					- ETH_HLEN /* ethernet hard_header_len */
+					+ IEEE80211_ENCRYPT_HEADROOM;
+		ndev->needed_tailroom = IEEE80211_ENCRYPT_TAILROOM;
+#endif
+
+		ret = dev_alloc_name(ndev, ndev->name);
+		if (ret < 0) {
+			free_netdev(ndev);
+			return ret;
+		}
+
+		ieee80211_assign_perm_addr(local, ndev->perm_addr, type);
+		memcpy(ndev->dev_addr, ndev->perm_addr, ETH_ALEN);
+		SET_NETDEV_DEV(ndev, wiphy_dev(local->hw.wiphy));
+
+		/* don't use IEEE80211_DEV_TO_SUB_IF -- it checks too much */
+		sdata = netdev_priv(ndev);
+		ndev->ieee80211_ptr = &sdata->wdev;
+		memcpy(sdata->vif.addr, ndev->dev_addr, ETH_ALEN);
+		memcpy(sdata->name, ndev->name, IFNAMSIZ);
+
+		sdata->dev = ndev;
+	}
+
+	/* initialise type-independent data */
+	sdata->wdev.wiphy = local->hw.wiphy;
+	sdata->local = local;
+#ifdef CONFIG_INET
+	sdata->arp_filter_state = true;
+#ifdef IPV6_FILTERING
+	sdata->ndp_filter_state = true;
+#endif /*IPV6_FILTERING*/
+#endif
+
+	for (i = 0; i < IEEE80211_FRAGMENT_MAX; i++)
+		skb_queue_head_init(&sdata->fragments[i].skb_list);
+
+	INIT_LIST_HEAD(&sdata->key_list);
+	init_waitqueue_head(&sdata->setkey_wq);
+	sdata->fourway_state = SDATA_4WAY_STATE_NONE;
+
+	for (i = 0; i < NUM_NL80211_BANDS; i++) {
+		struct ieee80211_supported_band *sband;
+		sband = local->hw.wiphy->bands[i];
+		sdata->rc_rateidx_mask[i] =
+			sband ? (1 << sband->n_bitrates) - 1 : 0;
+
+		if (!sdata->chan_state.oper_channel) {
+			/* init channel we're on */
+			/* soumik: set default channel to non social channel */
+			sdata->chan_state.conf.channel =
+			/* sdata->chan_state.oper_channel = &sband->channels[0]; */
+			sdata->chan_state.oper_channel = &sband->channels[2];
+			sdata->chan_state.conf.channel_type = NL80211_CHAN_NO_HT;
+		}
+	}
+
+	sdata->dynamic_ps_forced_timeout = -1;
+
+	INIT_WORK(&sdata->dynamic_ps_enable_work,
+		  mac80211_dynamic_ps_enable_work);
+	INIT_WORK(&sdata->dynamic_ps_disable_work,
+		  mac80211_dynamic_ps_disable_work);
+	timer_setup(&sdata->dynamic_ps_timer, mac80211_dynamic_ps_timer, 0);
+
+	sdata->vif.bss_conf.listen_interval = local->hw.max_listen_interval;
+
+	ieee80211_set_default_queues(sdata);
+
+	/* setup type-dependent data */
+	ieee80211_setup_sdata(sdata, type);
+
+	if (ndev) {
+		if (params) {
+			ndev->ieee80211_ptr->use_4addr = params->use_4addr;
+			if (type == NL80211_IFTYPE_STATION)
+				sdata->u.mgd.use_4addr = params->use_4addr;
+		}
+
+
+		ret = register_netdevice(ndev);
+		if (ret) {
+			free_netdev(ndev);
+			return ret;
+		}
+	}
+
+	mutex_lock(&local->iflist_mtx);
+	list_add_tail_rcu(&sdata->list, &local->interfaces);
+	mutex_unlock(&local->iflist_mtx);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	if (new_wdev)
+		*new_wdev = &sdata->wdev;
+#else
+	if (new_dev)
+		*new_dev = ndev;
+#endif
+
+	return 0;
+
+}
+
+void mac80211_if_remove(struct ieee80211_sub_if_data *sdata)
+{
+	ASSERT_RTNL();
+
+	cancel_work_sync(&sdata->reconfig_filter);
+
+	mutex_lock(&sdata->local->iflist_mtx);
+	list_del_rcu(&sdata->list);
+	mutex_unlock(&sdata->local->iflist_mtx);
+
+	if (ieee80211_vif_is_mesh(&sdata->vif))
+		xrmac_mesh_path_flush_by_iface(sdata);
+
+	synchronize_rcu();
+
+	if (sdata->dev) {
+		unregister_netdevice(sdata->dev);
+	} else {
+		cfg80211_unregister_wdev(&sdata->wdev);
+		ieee80211_teardown_sdata(sdata);
+		kfree(sdata);
+	}
+}
+
+void ieee80211_sdata_stop(struct ieee80211_sub_if_data *sdata)
+{
+	if (WARN_ON_ONCE(!test_bit(SDATA_STATE_RUNNING, &sdata->state)))
+		return;
+	ieee80211_do_stop(sdata, true);
+}
+
+/*
+ * Remove all interfaces, may only be called at hardware unregistration
+ * time because it doesn't do RCU-safe list removals.
+ */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33))
+void mac80211_remove_interfaces(struct ieee80211_local *local)
+{
+	struct ieee80211_sub_if_data *sdata, *tmp;
+	LIST_HEAD(unreg_list);
+	LIST_HEAD(wdev_list);
+
+	ASSERT_RTNL();
+
+	mutex_lock(&local->iflist_mtx);
+	list_for_each_entry_safe(sdata, tmp, &local->interfaces, list) {
+		list_del(&sdata->list);
+
+		if (ieee80211_vif_is_mesh(&sdata->vif))
+			xrmac_mesh_path_flush_by_iface(sdata);
+
+		if (sdata->dev)
+			unregister_netdevice_queue(sdata->dev, &unreg_list);
+		else
+			list_add(&sdata->list, &wdev_list);
+	}
+	mutex_unlock(&local->iflist_mtx);
+	unregister_netdevice_many(&unreg_list);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
+	/*list_del(&unreg_list);*/
+#else
+	list_del(&unreg_list);
+#endif
+
+	list_for_each_entry_safe(sdata, tmp, &wdev_list, list) {
+		list_del(&sdata->list);
+		cfg80211_unregister_wdev(&sdata->wdev);
+		kfree(sdata);
+	}
+}
+#else
+void mac80211_remove_interfaces(struct ieee80211_local *local)
+{
+	struct ieee80211_sub_if_data *sdata, *tmp;
+
+	ASSERT_RTNL();
+
+	list_for_each_entry_safe(sdata, tmp, &local->interfaces, list) {
+		mutex_lock(&local->iflist_mtx);
+		list_del(&sdata->list);
+		mutex_unlock(&local->iflist_mtx);
+
+		unregister_netdevice(sdata->dev);
+	}
+}
+#endif
+
+static u32 ieee80211_idle_off(struct ieee80211_local *local,
+			      const char *reason)
+{
+	if (!(local->hw.conf.flags & IEEE80211_CONF_IDLE))
+		return 0;
+
+#ifdef CONFIG_XRMAC_VERBOSE_DEBUG
+	wiphy_debug(local->hw.wiphy, "device no longer idle - %s\n", reason);
+#endif
+
+	local->hw.conf.flags &= ~IEEE80211_CONF_IDLE;
+	return IEEE80211_CONF_CHANGE_IDLE;
+}
+
+static u32 ieee80211_idle_on(struct ieee80211_local *local)
+{
+	struct ieee80211_sub_if_data *sdata;
+	if (local->hw.conf.flags & IEEE80211_CONF_IDLE)
+		return 0;
+
+#ifdef CONFIG_XRMAC_VERBOSE_DEBUG
+	wiphy_debug(local->hw.wiphy, "device now idle\n");
+#endif
+	list_for_each_entry(sdata, &local->interfaces, list)
+		drv_flush(local, sdata, false);
+
+	local->hw.conf.flags |= IEEE80211_CONF_IDLE;
+	return IEEE80211_CONF_CHANGE_IDLE;
+}
+
+u32 __mac80211_recalc_idle(struct ieee80211_local *local)
+{
+	struct ieee80211_sub_if_data *sdata;
+	int count = 0;
+	bool working = false, scanning = false, hw_roc = false;
+	struct ieee80211_work *wk;
+	unsigned int led_trig_start = 0, led_trig_stop = 0;
+	struct ieee80211_roc_work *roc;
+
+#ifdef CONFIG_PROVE_LOCKING
+	WARN_ON(debug_locks && !lockdep_rtnl_is_held() &&
+		!lockdep_is_held(&local->iflist_mtx));
+#endif
+	lockdep_assert_held(&local->mtx);
+
+	list_for_each_entry(sdata, &local->interfaces, list) {
+		if (!ieee80211_sdata_running(sdata)) {
+			sdata->vif.bss_conf.idle = true;
+			continue;
+		}
+
+		sdata->old_idle = sdata->vif.bss_conf.idle;
+
+		/* do not count disabled managed interfaces */
+		if (sdata->vif.type == NL80211_IFTYPE_STATION &&
+		    !sdata->u.mgd.associated) {
+			sdata->vif.bss_conf.idle = true;
+			continue;
+		}
+		/* do not count unused IBSS interfaces */
+		if (sdata->vif.type == NL80211_IFTYPE_ADHOC &&
+		    !sdata->u.ibss.ssid_len) {
+			sdata->vif.bss_conf.idle = true;
+			continue;
+		}
+
+		if (sdata->vif.type == NL80211_IFTYPE_P2P_DEVICE)
+			continue;
+
+		/* count everything else */
+		count++;
+	}
+
+	if (!local->ops->remain_on_channel) {
+		list_for_each_entry(roc, &local->roc_list, list) {
+			working = true;
+			roc->sdata->vif.bss_conf.idle = false;
+		}
+	}
+
+
+	list_for_each_entry(wk, &local->work_list, list) {
+		working = true;
+		wk->sdata->vif.bss_conf.idle = false;
+	}
+
+	if (local->scan_sdata) {
+		scanning = true;
+		local->scan_sdata->vif.bss_conf.idle = false;
+	}
+
+	if (local->hw_roc_channel)
+		hw_roc = true;
+
+	list_for_each_entry(sdata, &local->interfaces, list) {
+		if (sdata->vif.type == NL80211_IFTYPE_MONITOR ||
+		    sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||
+		    sdata->vif.type == NL80211_IFTYPE_P2P_DEVICE)
+			continue;
+		if (sdata->old_idle == sdata->vif.bss_conf.idle)
+			continue;
+		if (!ieee80211_sdata_running(sdata))
+			continue;
+		mac80211_bss_info_change_notify(sdata, BSS_CHANGED_IDLE);
+	}
+
+	if (working || scanning || hw_roc)
+		led_trig_start |= IEEE80211_TPT_LEDTRIG_FL_WORK;
+	else
+		led_trig_stop |= IEEE80211_TPT_LEDTRIG_FL_WORK;
+
+	if (count)
+		led_trig_start |= IEEE80211_TPT_LEDTRIG_FL_CONNECTED;
+	else
+		led_trig_stop |= IEEE80211_TPT_LEDTRIG_FL_CONNECTED;
+
+	ieee80211_mod_tpt_led_trig(local, led_trig_start, led_trig_stop);
+
+	if (hw_roc)
+		return ieee80211_idle_off(local, "hw remain-on-channel");
+	if (working)
+		return ieee80211_idle_off(local, "working");
+	if (scanning)
+		return ieee80211_idle_off(local, "scanning");
+	if (!count)
+		return ieee80211_idle_on(local);
+	else
+		return ieee80211_idle_off(local, "in use");
+
+	return 0;
+}
+
+void mac80211_recalc_idle(struct ieee80211_local *local)
+{
+	u32 chg;
+
+	mutex_lock(&local->iflist_mtx);
+	chg = __mac80211_recalc_idle(local);
+	mutex_unlock(&local->iflist_mtx);
+	if (chg)
+		mac80211_hw_config(local, chg);
+}
+
+static int netdev_notify(struct notifier_block *nb,
+			 unsigned long state,
+			 void *ndev)
+{
+	struct net_device *dev = ndev;
+	struct ieee80211_sub_if_data *sdata;
+
+	if (state != NETDEV_CHANGENAME)
+		return 0;
+
+	if (!dev->ieee80211_ptr || !dev->ieee80211_ptr->wiphy)
+		return 0;
+
+	if (dev->ieee80211_ptr->wiphy->privid != xrmac_wiphy_privid)
+		return 0;
+
+	sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	memcpy(sdata->name, dev->name, IFNAMSIZ);
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	mac80211_debugfs_rename_netdev(sdata);
+#endif /* CONFIG_XRMAC_DEBUGFS */
+
+	return 0;
+}
+
+static struct notifier_block mac80211_netdev_notifier = {
+	.notifier_call = netdev_notify,
+};
+
+int mac80211_iface_init(void)
+{
+	return register_netdevice_notifier(&mac80211_netdev_notifier);
+}
+
+void mac80211_iface_exit(void)
+{
+	unregister_netdevice_notifier(&mac80211_netdev_notifier);
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/key.c b/drivers/net/wireless/xr829/umac/key.c
--- a/drivers/net/wireless/xr829/umac/key.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/key.c	2022-08-27 01:22:42.942539817 +0300
@@ -0,0 +1,778 @@
+/*
+ * Copyright 2002-2005, Instant802 Networks, Inc.
+ * Copyright 2005-2006, Devicescape Software, Inc.
+ * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
+ * Copyright 2007-2008	Johannes Berg <johannes@sipsolutions.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/if_ether.h>
+#include <linux/etherdevice.h>
+#include <linux/list.h>
+#include <linux/rcupdate.h>
+#include <linux/rtnetlink.h>
+#include <linux/slab.h>
+#include <linux/export.h>
+#include <crypto/arc4.h>
+#include <net/mac80211.h>
+#include "ieee80211_i.h"
+#include "driver-ops.h"
+#include "debugfs_key.h"
+#include "aes_ccm.h"
+#include "aes_cmac.h"
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29))
+#include <asm/unaligned.h>
+#endif
+
+/**
+ * DOC: Key handling basics
+ *
+ * Key handling in mac80211 is done based on per-interface (sub_if_data)
+ * keys and per-station keys. Since each station belongs to an interface,
+ * each station key also belongs to that interface.
+ *
+ * Hardware acceleration is done on a best-effort basis for algorithms
+ * that are implemented in software,  for each key the hardware is asked
+ * to enable that key for offloading but if it cannot do that the key is
+ * simply kept for software encryption (unless it is for an algorithm
+ * that isn't implemented in software).
+ * There is currently no way of knowing whether a key is handled in SW
+ * or HW except by looking into debugfs.
+ *
+ * All key management is internally protected by a mutex. Within all
+ * other parts of mac80211, key references are, just as STA structure
+ * references, protected by RCU. Note, however, that some things are
+ * unprotected, namely the key->sta dereferences within the hardware
+ * acceleration functions. This means that sta_info_destroy() must
+ * remove the key which waits for an RCU grace period.
+ */
+
+static const u8 bcast_addr[ETH_ALEN] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
+
+static void assert_key_lock(struct ieee80211_local *local)
+{
+	lockdep_assert_held(&local->key_mtx);
+}
+
+static struct ieee80211_sta *get_sta_for_key(struct ieee80211_key *key)
+{
+	if (key->sta)
+		return &key->sta->sta;
+
+	return NULL;
+}
+
+static void increment_tailroom_need_count(struct ieee80211_sub_if_data *sdata)
+{
+	/*
+	 * When this count is zero, SKB resizing for allocating tailroom
+	 * for IV or MMIC is skipped. But, this check has created two race
+	 * cases in xmit path while transiting from zero count to one:
+	 *
+	 * 1. SKB resize was skipped because no key was added but just before
+	 * the xmit key is added and SW encryption kicks off.
+	 *
+	 * 2. SKB resize was skipped because all the keys were hw planted but
+	 * just before xmit one of the key is deleted and SW encryption kicks
+	 * off.
+	 *
+	 * In both the above case SW encryption will find not enough space for
+	 * tailroom and exits with WARN_ON. (See WARN_ONs at wpa.c)
+	 *
+	 * Solution has been explained at
+	 * http://mid.gmane.org/1308590980.4322.19.camel@jlt3.sipsolutions.net
+	 */
+
+	if (!sdata->crypto_tx_tailroom_needed_cnt++) {
+		/*
+		 * Flush all XMIT packets currently using HW encryption or no
+		 * encryption at all if the count transition is from 0 -> 1.
+		 */
+		synchronize_net();
+	}
+}
+
+static int ieee80211_key_enable_hw_accel(struct ieee80211_key *key)
+{
+	struct ieee80211_sub_if_data *sdata;
+	struct ieee80211_sta *sta;
+	int ret;
+
+	might_sleep();
+
+	if (!key->local->ops->set_key)
+		goto out_unsupported;
+
+	assert_key_lock(key->local);
+
+	sta = get_sta_for_key(key);
+
+	/*
+	 * If this is a per-STA GTK, check if it
+	 * is supported; if not, return.
+	 */
+	if (sta && !(key->conf.flags & IEEE80211_KEY_FLAG_PAIRWISE) &&
+	    !(key->local->hw.flags & IEEE80211_HW_SUPPORTS_PER_STA_GTK))
+		goto out_unsupported;
+
+	sdata = key->sdata;
+	if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {
+		/*
+		 * The driver doesn't know anything about VLAN interfaces.
+		 * Hence, don't send GTKs for VLAN interfaces to the driver.
+		 */
+		if (!(key->conf.flags & IEEE80211_KEY_FLAG_PAIRWISE))
+			goto out_unsupported;
+		sdata = container_of(sdata->bss,
+				     struct ieee80211_sub_if_data,
+				     u.ap);
+	}
+
+	ret = drv_set_key(key->local, SET_KEY, sdata, sta, &key->conf);
+
+	if (!ret) {
+		key->flags |= KEY_FLAG_UPLOADED_TO_HARDWARE;
+
+		if (!((key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_MMIC) ||
+		      (key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_IV) ||
+		      (key->conf.flags & IEEE80211_KEY_FLAG_ALLOC_IV)))
+			sdata->crypto_tx_tailroom_needed_cnt--;
+
+		return 0;
+	}
+
+	if (ret != -ENOSPC && ret != -EOPNOTSUPP)
+		wiphy_err(key->local->hw.wiphy,
+			  "failed to set key (%d, %pM) to hardware (%d)\n",
+			  key->conf.keyidx, sta ? sta->addr : bcast_addr, ret);
+
+ out_unsupported:
+	switch (key->conf.cipher) {
+	case WLAN_CIPHER_SUITE_WEP40:
+	case WLAN_CIPHER_SUITE_WEP104:
+	case WLAN_CIPHER_SUITE_TKIP:
+	case WLAN_CIPHER_SUITE_CCMP:
+	case WLAN_CIPHER_SUITE_AES_CMAC:
+		/* all of these we can do in software */
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static void ieee80211_key_disable_hw_accel(struct ieee80211_key *key)
+{
+	struct ieee80211_sub_if_data *sdata;
+	struct ieee80211_sta *sta;
+	int ret;
+
+	might_sleep();
+
+	if (!key || !key->local->ops->set_key)
+		return;
+
+	assert_key_lock(key->local);
+
+	if (!(key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE))
+		return;
+
+	sta = get_sta_for_key(key);
+	sdata = key->sdata;
+
+	if (!((key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_MMIC) ||
+	      (key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_IV) ||
+	      (key->conf.flags & IEEE80211_KEY_FLAG_ALLOC_IV)))
+		increment_tailroom_need_count(sdata);
+
+	if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
+		sdata = container_of(sdata->bss,
+				     struct ieee80211_sub_if_data,
+				     u.ap);
+
+	ret = drv_set_key(key->local, DISABLE_KEY, sdata,
+			  sta, &key->conf);
+
+	if (ret)
+		wiphy_err(key->local->hw.wiphy,
+			  "failed to remove key (%d, %pM) from hardware (%d)\n",
+			  key->conf.keyidx, sta ? sta->addr : bcast_addr, ret);
+
+#ifdef CONFIG_XRMAC_XR_ROAMING_CHANGES
+	/*
+	 * In STA mode during roaming do not clear this flag.
+	 * We don't want to switch to SW encryption in case
+	 * of any ongoing TX traffic. However that should never
+	 * happen.
+	 */
+	if (key->sdata->vif.type != NL80211_IFTYPE_STATION ||
+		!key->sdata->u.mgd.roaming)
+#endif
+	key->flags &= ~KEY_FLAG_UPLOADED_TO_HARDWARE;
+}
+
+void mac80211_key_removed(struct ieee80211_key_conf *key_conf)
+{
+	struct ieee80211_key *key;
+
+	key = container_of(key_conf, struct ieee80211_key, conf);
+
+	might_sleep();
+	assert_key_lock(key->local);
+
+	key->flags &= ~KEY_FLAG_UPLOADED_TO_HARDWARE;
+
+	/*
+	 * Flush TX path to avoid attempts to use this key
+	 * after this function returns. Until then, drivers
+	 * must be prepared to handle the key.
+	 */
+	synchronize_rcu();
+}
+
+static void __mac80211_set_default_key(struct ieee80211_sub_if_data *sdata,
+					int idx, bool uni, bool multi)
+{
+	struct ieee80211_key *key = NULL;
+
+	assert_key_lock(sdata->local);
+
+	if (idx >= 0 && idx < NUM_DEFAULT_KEYS)
+		key = key_mtx_dereference(sdata->local, sdata->keys[idx]);
+
+	if (uni)
+		rcu_assign_pointer(sdata->default_unicast_key, key);
+	if (multi)
+		rcu_assign_pointer(sdata->default_multicast_key, key);
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	mac80211_debugfs_key_update_default(sdata);
+#endif
+}
+
+void mac80211_set_default_key(struct ieee80211_sub_if_data *sdata, int idx,
+			       bool uni, bool multi)
+{
+	mutex_lock(&sdata->local->key_mtx);
+	__mac80211_set_default_key(sdata, idx, uni, multi);
+	mutex_unlock(&sdata->local->key_mtx);
+}
+
+static void
+__mac80211_set_default_mgmt_key(struct ieee80211_sub_if_data *sdata, int idx)
+{
+	struct ieee80211_key *key = NULL;
+
+	assert_key_lock(sdata->local);
+
+	if (idx >= NUM_DEFAULT_KEYS &&
+	    idx < NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS)
+		key = key_mtx_dereference(sdata->local, sdata->keys[idx]);
+
+	rcu_assign_pointer(sdata->default_mgmt_key, key);
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	mac80211_debugfs_key_update_default(sdata);
+#endif
+}
+
+void mac80211_set_default_mgmt_key(struct ieee80211_sub_if_data *sdata,
+				    int idx)
+{
+	mutex_lock(&sdata->local->key_mtx);
+	__mac80211_set_default_mgmt_key(sdata, idx);
+	mutex_unlock(&sdata->local->key_mtx);
+}
+
+
+static void __ieee80211_key_replace(struct ieee80211_sub_if_data *sdata,
+				    struct sta_info *sta,
+				    bool pairwise,
+				    struct ieee80211_key *old,
+				    struct ieee80211_key *new)
+{
+	int idx;
+	bool defunikey, defmultikey, defmgmtkey;
+
+	if (new)
+		list_add_tail(&new->list, &sdata->key_list);
+
+	if (sta && pairwise) {
+		if (old && new &&
+			(new->conf.cipher == WLAN_CIPHER_SUITE_CCMP)) {
+			int i;
+			for (i = 0; i < NUM_RX_DATA_QUEUES + 1; i++) {
+				memcpy(new->u.ccmp.prev_rx_pn[i],
+				old->u.ccmp.prev_rx_pn[i], CCMP_PN_LEN);
+			}
+		}
+
+		rcu_assign_pointer(sta->ptk, new);
+	} else if (sta) {
+		if (old)
+			idx = old->conf.keyidx;
+		else
+			idx = new->conf.keyidx;
+		rcu_assign_pointer(sta->gtk[idx], new);
+	} else {
+		WARN_ON(new && old && new->conf.keyidx != old->conf.keyidx);
+
+		if (old)
+			idx = old->conf.keyidx;
+		else
+			idx = new->conf.keyidx;
+
+		defunikey = old &&
+			old == key_mtx_dereference(sdata->local,
+						sdata->default_unicast_key);
+		defmultikey = old &&
+			old == key_mtx_dereference(sdata->local,
+						sdata->default_multicast_key);
+		defmgmtkey = old &&
+			old == key_mtx_dereference(sdata->local,
+						sdata->default_mgmt_key);
+
+		if (defunikey && !new)
+			__mac80211_set_default_key(sdata, -1, true, false);
+		if (defmultikey && !new)
+			__mac80211_set_default_key(sdata, -1, false, true);
+		if (defmgmtkey && !new)
+			__mac80211_set_default_mgmt_key(sdata, -1);
+
+		rcu_assign_pointer(sdata->keys[idx], new);
+		if (defunikey && new)
+			__mac80211_set_default_key(sdata, new->conf.keyidx,
+						    true, false);
+		if (defmultikey && new)
+			__mac80211_set_default_key(sdata, new->conf.keyidx,
+						    false, true);
+		if (defmgmtkey && new)
+			__mac80211_set_default_mgmt_key(sdata,
+							 new->conf.keyidx);
+	}
+
+	if (old)
+		list_del(&old->list);
+}
+
+struct ieee80211_key *mac80211_key_alloc(u32 cipher, int idx, size_t key_len,
+					  const u8 *key_data,
+					  size_t seq_len, const u8 *seq)
+{
+	struct ieee80211_key *key;
+	int i, j, err;
+
+	BUG_ON(idx < 0 || idx >= NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS);
+
+	key = kzalloc(sizeof(struct ieee80211_key) + key_len, GFP_KERNEL);
+	if (!key)
+		return ERR_PTR(-ENOMEM);
+
+	/*
+	 * Default to software encryption; we'll later upload the
+	 * key to the hardware if possible.
+	 */
+	key->conf.flags = 0;
+	key->flags = 0;
+
+	key->conf.cipher = cipher;
+	key->conf.keyidx = idx;
+	key->conf.keylen = key_len;
+	switch (cipher) {
+	case WLAN_CIPHER_SUITE_WEP40:
+	case WLAN_CIPHER_SUITE_WEP104:
+		key->conf.iv_len = WEP_IV_LEN;
+		key->conf.icv_len = WEP_ICV_LEN;
+		break;
+	case WLAN_CIPHER_SUITE_TKIP:
+		key->conf.iv_len = TKIP_IV_LEN;
+		key->conf.icv_len = TKIP_ICV_LEN;
+		if (seq) {
+			for (i = 0; i < NUM_RX_DATA_QUEUES; i++) {
+				key->u.tkip.rx[i].iv32 =
+					get_unaligned_le32(&seq[2]);
+				key->u.tkip.rx[i].iv16 =
+					get_unaligned_le16(seq);
+			}
+		}
+		spin_lock_init(&key->u.tkip.txlock);
+		break;
+	case WLAN_CIPHER_SUITE_CCMP:
+		key->conf.iv_len = CCMP_HDR_LEN;
+		key->conf.icv_len = CCMP_MIC_LEN;
+		if (seq) {
+			for (i = 0; i < NUM_RX_DATA_QUEUES + 1; i++)
+				for (j = 0; j < CCMP_PN_LEN; j++)
+					key->u.ccmp.rx_pn[i][j] =
+						seq[CCMP_PN_LEN - j - 1];
+		}
+		/*
+		 * Initialize AES key state here as an optimization so that
+		 * it does not need to be initialized for every packet.
+		 */
+		key->u.ccmp.tfm = mac80211_aes_key_setup_encrypt(key_data);
+		if (IS_ERR(key->u.ccmp.tfm)) {
+			err = PTR_ERR(key->u.ccmp.tfm);
+			kfree(key);
+			return ERR_PTR(err);
+		}
+		break;
+	case WLAN_CIPHER_SUITE_AES_CMAC:
+		key->conf.iv_len = 0;
+		key->conf.icv_len = sizeof(struct ieee80211_mmie);
+		if (seq)
+			for (j = 0; j < 6; j++)
+				key->u.aes_cmac.rx_pn[j] = seq[6 - j - 1];
+		/*
+		 * Initialize AES key state here as an optimization so that
+		 * it does not need to be initialized for every packet.
+		 */
+		key->u.aes_cmac.tfm =
+			mac80211_aes_cmac_key_setup(key_data);
+		if (IS_ERR(key->u.aes_cmac.tfm)) {
+			err = PTR_ERR(key->u.aes_cmac.tfm);
+			kfree(key);
+			return ERR_PTR(err);
+		}
+		break;
+	case WLAN_CIPHER_SUITE_SMS4:
+		key->conf.iv_len = WAPI_IV_LEN;
+		key->conf.icv_len = WAPI_ICV_LEN;
+		break;
+	}
+	memcpy(key->conf.key, key_data, key_len);
+	INIT_LIST_HEAD(&key->list);
+
+	return key;
+}
+
+#ifdef CONFIG_XRMAC_XR_ROAMING_CHANGES
+/**
+ * mac80211_key_free_rcu - key free rcu callback
+ */
+static void mac80211_key_free_rcu(struct rcu_head *rcu_h)
+{
+	struct ieee80211_key *key =
+		container_of(rcu_h, struct ieee80211_key, rcu);
+	kfree(key);
+}
+#endif
+static void __ieee80211_key_destroy(struct ieee80211_key *key)
+{
+	if (!key)
+		return;
+#ifdef CONFIG_XRMAC_XR_ROAMING_CHANGES
+	/*
+	 * In STA mode during roaming all TX queues should be
+	 * stopped. Therefore we don't need to wait on synchronize_rcu()
+	 * before removing the key from the device.
+	 * We use non blocking rcu to decrease roaming time.
+	 */
+	if (key->sdata->vif.type == NL80211_IFTYPE_STATION &&
+	    key->sdata->u.mgd.roaming) {
+
+		if (key->local)
+			ieee80211_key_disable_hw_accel(key);
+
+		if (key->conf.cipher == WLAN_CIPHER_SUITE_CCMP)
+			mac80211_aes_key_free(key->u.ccmp.tfm);
+		if (key->conf.cipher == WLAN_CIPHER_SUITE_AES_CMAC)
+			mac80211_aes_cmac_key_free(key->u.aes_cmac.tfm);
+		if (key->local) {
+#ifdef CONFIG_XRMAC_DEBUGFS
+			mac80211_debugfs_key_remove(key);
+#endif
+			key->sdata->crypto_tx_tailroom_needed_cnt--;
+	}
+
+		call_rcu(&key->rcu, mac80211_key_free_rcu);
+
+		return;
+	}
+#endif
+
+	/*
+	 * Synchronize so the TX path can no longer be using
+	 * this key before we free/remove it.
+	 */
+	synchronize_rcu();
+
+	if (key->local)
+		ieee80211_key_disable_hw_accel(key);
+
+	if (key->conf.cipher == WLAN_CIPHER_SUITE_CCMP)
+		mac80211_aes_key_free(key->u.ccmp.tfm);
+	if (key->conf.cipher == WLAN_CIPHER_SUITE_AES_CMAC)
+		mac80211_aes_cmac_key_free(key->u.aes_cmac.tfm);
+	if (key->local) {
+#ifdef CONFIG_XRMAC_DEBUGFS
+		mac80211_debugfs_key_remove(key);
+#endif
+		key->sdata->crypto_tx_tailroom_needed_cnt--;
+	}
+
+	kfree(key);
+}
+
+int mac80211_key_link(struct ieee80211_key *key,
+		       struct ieee80211_sub_if_data *sdata,
+		       struct sta_info *sta)
+{
+	struct ieee80211_key *old_key;
+	int idx, ret;
+	bool pairwise;
+
+	BUG_ON(!sdata);
+	BUG_ON(!key);
+
+	pairwise = key->conf.flags & IEEE80211_KEY_FLAG_PAIRWISE;
+	idx = key->conf.keyidx;
+	key->local = sdata->local;
+	key->sdata = sdata;
+	key->sta = sta;
+
+	if (sta) {
+		/*
+		 * some hardware cannot handle TKIP with QoS, so
+		 * we indicate whether QoS could be in use.
+		 */
+		if (test_sta_flag(sta, WLAN_STA_WME))
+			key->conf.flags |= IEEE80211_KEY_FLAG_WMM_STA;
+	} else {
+		if (sdata->vif.type == NL80211_IFTYPE_STATION) {
+			struct sta_info *ap;
+
+			/*
+			 * We're getting a sta pointer in, so must be under
+			 * appropriate locking for xrmac_sta_info_get().
+			 */
+
+			/* same here, the AP could be using QoS */
+			ap = xrmac_sta_info_get(key->sdata, key->sdata->u.mgd.bssid);
+			if (ap) {
+				if (test_sta_flag(ap, WLAN_STA_WME))
+					key->conf.flags |=
+						IEEE80211_KEY_FLAG_WMM_STA;
+			}
+		}
+	}
+
+	mutex_lock(&sdata->local->key_mtx);
+
+	if (sta && pairwise)
+		old_key = key_mtx_dereference(sdata->local, sta->ptk);
+	else if (sta)
+		old_key = key_mtx_dereference(sdata->local, sta->gtk[idx]);
+	else
+		old_key = key_mtx_dereference(sdata->local, sdata->keys[idx]);
+
+	increment_tailroom_need_count(sdata);
+
+	__ieee80211_key_replace(sdata, sta, pairwise, old_key, key);
+	__ieee80211_key_destroy(old_key);
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	xrmac80211_debugfs_key_add(key);
+#endif
+
+	ret = ieee80211_key_enable_hw_accel(key);
+
+	mutex_unlock(&sdata->local->key_mtx);
+
+	return ret;
+}
+
+void __mac80211_key_free(struct ieee80211_key *key)
+{
+	if (!key)
+		return;
+
+	/*
+	 * Replace key with nothingness if it was ever used.
+	 */
+	if (key->sdata)
+		__ieee80211_key_replace(key->sdata, key->sta,
+				key->conf.flags & IEEE80211_KEY_FLAG_PAIRWISE,
+				key, NULL);
+	__ieee80211_key_destroy(key);
+}
+
+void mac80211_key_free(struct ieee80211_local *local,
+			struct ieee80211_key *key)
+{
+	mutex_lock(&local->key_mtx);
+	__mac80211_key_free(key);
+	mutex_unlock(&local->key_mtx);
+}
+
+void mac80211_enable_keys(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_key *key;
+
+	ASSERT_RTNL();
+
+	if (WARN_ON(!ieee80211_sdata_running(sdata)))
+		return;
+
+	mutex_lock(&sdata->local->key_mtx);
+
+	sdata->crypto_tx_tailroom_needed_cnt = 0;
+
+	list_for_each_entry(key, &sdata->key_list, list) {
+		increment_tailroom_need_count(sdata);
+		ieee80211_key_enable_hw_accel(key);
+	}
+
+	mutex_unlock(&sdata->local->key_mtx);
+}
+
+void mac80211_iter_keys(struct ieee80211_hw *hw,
+			 struct ieee80211_vif *vif,
+			 void (*iter)(struct ieee80211_hw *hw,
+				      struct ieee80211_vif *vif,
+				      struct ieee80211_sta *sta,
+				      struct ieee80211_key_conf *key,
+				      void *data),
+			 void *iter_data)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct ieee80211_key *key;
+	struct ieee80211_sub_if_data *sdata;
+
+	ASSERT_RTNL();
+
+	mutex_lock(&local->key_mtx);
+	if (vif) {
+		sdata = vif_to_sdata(vif);
+		list_for_each_entry(key, &sdata->key_list, list)
+			iter(hw, &sdata->vif,
+			     key->sta ? &key->sta->sta : NULL,
+			     &key->conf, iter_data);
+	} else {
+		list_for_each_entry(sdata, &local->interfaces, list)
+			list_for_each_entry(key, &sdata->key_list, list)
+				iter(hw, &sdata->vif,
+				     key->sta ? &key->sta->sta : NULL,
+				     &key->conf, iter_data);
+	}
+	mutex_unlock(&local->key_mtx);
+}
+
+void mac80211_disable_keys(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_key *key;
+
+	ASSERT_RTNL();
+
+	mutex_lock(&sdata->local->key_mtx);
+
+	list_for_each_entry(key, &sdata->key_list, list)
+		ieee80211_key_disable_hw_accel(key);
+
+	mutex_unlock(&sdata->local->key_mtx);
+}
+
+void mac80211_free_keys(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_key *key, *tmp;
+
+	mutex_lock(&sdata->local->key_mtx);
+#ifdef CONFIG_XRMAC_DEBUGFS
+	mac80211_debugfs_key_remove_mgmt_default(sdata);
+#endif
+
+	list_for_each_entry_safe(key, tmp, &sdata->key_list, list)
+		__mac80211_key_free(key);
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	mac80211_debugfs_key_update_default(sdata);
+#endif
+
+	mutex_unlock(&sdata->local->key_mtx);
+}
+
+
+void mac80211_gtk_rekey_notify(struct ieee80211_vif *vif, const u8 *bssid,
+				const u8 *replay_ctr, gfp_t gfp)
+{
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+
+	trace_api_gtk_rekey_notify(sdata, bssid, replay_ctr);
+
+	cfg80211_gtk_rekey_notify(sdata->dev, bssid, replay_ctr, gfp);
+}
+
+void mac80211_get_key_tx_seq(struct ieee80211_key_conf *keyconf,
+			      struct ieee80211_key_seq *seq)
+{
+	struct ieee80211_key *key;
+	u64 pn64;
+
+	if (WARN_ON(!(keyconf->flags & IEEE80211_KEY_FLAG_GENERATE_IV)))
+		return;
+
+	key = container_of(keyconf, struct ieee80211_key, conf);
+
+	switch (key->conf.cipher) {
+	case WLAN_CIPHER_SUITE_TKIP:
+		seq->tkip.iv32 = key->u.tkip.tx.iv32;
+		seq->tkip.iv16 = key->u.tkip.tx.iv16;
+		break;
+	case WLAN_CIPHER_SUITE_CCMP:
+		pn64 = atomic64_read(&key->u.ccmp.tx_pn);
+		seq->ccmp.pn[5] = pn64;
+		seq->ccmp.pn[4] = pn64 >> 8;
+		seq->ccmp.pn[3] = pn64 >> 16;
+		seq->ccmp.pn[2] = pn64 >> 24;
+		seq->ccmp.pn[1] = pn64 >> 32;
+		seq->ccmp.pn[0] = pn64 >> 40;
+		break;
+	case WLAN_CIPHER_SUITE_AES_CMAC:
+		pn64 = atomic64_read(&key->u.aes_cmac.tx_pn);
+		seq->ccmp.pn[5] = pn64;
+		seq->ccmp.pn[4] = pn64 >> 8;
+		seq->ccmp.pn[3] = pn64 >> 16;
+		seq->ccmp.pn[2] = pn64 >> 24;
+		seq->ccmp.pn[1] = pn64 >> 32;
+		seq->ccmp.pn[0] = pn64 >> 40;
+		break;
+	default:
+		WARN_ON(1);
+	}
+}
+
+void mac80211_get_key_rx_seq(struct ieee80211_key_conf *keyconf,
+			      int tid, struct ieee80211_key_seq *seq)
+{
+	struct ieee80211_key *key;
+	const u8 *pn;
+
+	key = container_of(keyconf, struct ieee80211_key, conf);
+
+	switch (key->conf.cipher) {
+	case WLAN_CIPHER_SUITE_TKIP:
+		if (WARN_ON(tid < 0 || tid >= NUM_RX_DATA_QUEUES))
+			return;
+		seq->tkip.iv32 = key->u.tkip.rx[tid].iv32;
+		seq->tkip.iv16 = key->u.tkip.rx[tid].iv16;
+		break;
+	case WLAN_CIPHER_SUITE_CCMP:
+		if (WARN_ON(tid < -1 || tid >= NUM_RX_DATA_QUEUES))
+			return;
+		if (tid < 0)
+			pn = key->u.ccmp.rx_pn[NUM_RX_DATA_QUEUES];
+		else
+			pn = key->u.ccmp.rx_pn[tid];
+		memcpy(seq->ccmp.pn, pn, CCMP_PN_LEN);
+		break;
+	case WLAN_CIPHER_SUITE_AES_CMAC:
+		if (WARN_ON(tid != 0))
+			return;
+		pn = key->u.aes_cmac.rx_pn;
+		memcpy(seq->aes_cmac.pn, pn, CMAC_PN_LEN);
+		break;
+	}
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/key.h b/drivers/net/wireless/xr829/umac/key.h
--- a/drivers/net/wireless/xr829/umac/key.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/key.h	2022-08-27 01:22:42.942539817 +0300
@@ -0,0 +1,158 @@
+/*
+ * Copyright 2002-2004, Instant802 Networks, Inc.
+ * Copyright 2005, Devicescape Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef IEEE80211_KEY_H
+#define IEEE80211_KEY_H
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/crypto.h>
+#include <linux/rcupdate.h>
+#include <crypto/arc4.h>
+#include <net/mac80211.h>
+
+#define NUM_DEFAULT_KEYS 4
+#define NUM_DEFAULT_MGMT_KEYS 2
+
+#define WEP_IV_LEN		4
+#define WEP_ICV_LEN		4
+#define ALG_CCMP_KEY_LEN	16
+#define CCMP_HDR_LEN		8
+#define CCMP_MIC_LEN		8
+#define CCMP_TK_LEN		16
+#define CCMP_PN_LEN		6
+#define TKIP_IV_LEN		8
+#define TKIP_ICV_LEN		4
+#define CMAC_PN_LEN		6
+#define WAPI_IV_LEN		18
+#define WAPI_ICV_LEN		16
+
+#define NUM_RX_DATA_QUEUES	16
+
+struct ieee80211_local;
+struct ieee80211_sub_if_data;
+struct sta_info;
+
+/**
+ * enum ieee80211_internal_key_flags - internal key flags
+ *
+ * @KEY_FLAG_UPLOADED_TO_HARDWARE: Indicates that this key is present
+ *	in the hardware for TX crypto hardware acceleration.
+ * @KEY_FLAG_TAINTED: Key is tainted and packets should be dropped.
+ */
+enum ieee80211_internal_key_flags {
+	KEY_FLAG_UPLOADED_TO_HARDWARE	= BIT(0),
+	KEY_FLAG_TAINTED		= BIT(1),
+};
+
+enum ieee80211_internal_tkip_state {
+	TKIP_STATE_NOT_INIT,
+	TKIP_STATE_PHASE1_DONE,
+	TKIP_STATE_PHASE1_HW_UPLOADED,
+};
+
+struct tkip_ctx {
+	u32 iv32;	/* current iv32 */
+	u16 iv16;	/* current iv16 */
+	u16 p1k[5];	/* p1k cache */
+	u32 p1k_iv32;	/* iv32 for which p1k computed */
+	enum ieee80211_internal_tkip_state state;
+};
+
+struct ieee80211_key {
+	struct ieee80211_local *local;
+	struct ieee80211_sub_if_data *sdata;
+	struct sta_info *sta;
+
+	/* for sdata list */
+	struct list_head list;
+
+	/* protected by key mutex */
+	unsigned int flags;
+
+	union {
+		struct {
+			/* protects tx context */
+			spinlock_t txlock;
+
+			/* last used TSC */
+			struct tkip_ctx tx;
+
+			/* last received RSC */
+			struct tkip_ctx rx[NUM_RX_DATA_QUEUES];
+		} tkip;
+		struct {
+			atomic64_t tx_pn;
+			/*
+			 * Last received packet number. The first
+			 * NUM_RX_DATA_QUEUES counters are used with Data
+			 * frames and the last counter is used with Robust
+			 * Management frames.
+			 */
+			u8 rx_pn[NUM_RX_DATA_QUEUES + 1][CCMP_PN_LEN];
+			u8 prev_rx_pn[NUM_RX_DATA_QUEUES + 1][6];
+			struct crypto_cipher *tfm;
+			u32 replays; /* dot11RSNAStatsCCMPReplays */
+		} ccmp;
+		struct {
+			atomic64_t tx_pn;
+			u8 rx_pn[CMAC_PN_LEN];
+			struct crypto_cipher *tfm;
+			u32 replays; /* dot11RSNAStatsCMACReplays */
+			u32 icverrors; /* dot11RSNAStatsCMACICVErrors */
+		} aes_cmac;
+	} u;
+
+	/* number of times this key has been used */
+	int tx_rx_count;
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	struct {
+		struct dentry *stalink;
+		struct dentry *dir;
+		int cnt;
+	} debugfs;
+#endif
+
+#ifdef CONFIG_XRMAC_XR_ROAMING_CHANGES
+	/* rcu: used for non blocking key freeing */
+	struct rcu_head rcu;
+#endif
+	/*
+	 * key config, must be last because it contains key
+	 * material as variable length member
+	 */
+	struct ieee80211_key_conf conf;
+};
+
+struct ieee80211_key *mac80211_key_alloc(u32 cipher, int idx, size_t key_len,
+					  const u8 *key_data,
+					  size_t seq_len, const u8 *seq);
+/*
+ * Insert a key into data structures (sdata, sta if necessary)
+ * to make it used, free old key.
+ */
+int __must_check mac80211_key_link(struct ieee80211_key *key,
+				    struct ieee80211_sub_if_data *sdata,
+				    struct sta_info *sta);
+void __mac80211_key_free(struct ieee80211_key *key);
+void mac80211_key_free(struct ieee80211_local *local,
+			struct ieee80211_key *key);
+void mac80211_set_default_key(struct ieee80211_sub_if_data *sdata, int idx,
+			       bool uni, bool multi);
+void mac80211_set_default_mgmt_key(struct ieee80211_sub_if_data *sdata,
+				    int idx);
+void mac80211_free_keys(struct ieee80211_sub_if_data *sdata);
+void mac80211_enable_keys(struct ieee80211_sub_if_data *sdata);
+void mac80211_disable_keys(struct ieee80211_sub_if_data *sdata);
+
+#define key_mtx_dereference(local, ref) \
+	rcu_dereference_protected(ref, lockdep_is_held(&((local)->key_mtx)))
+
+#endif /* IEEE80211_KEY_H */
diff -Naurp a/drivers/net/wireless/xr829/umac/led.c b/drivers/net/wireless/xr829/umac/led.c
--- a/drivers/net/wireless/xr829/umac/led.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/led.c	2022-08-27 01:22:42.942539817 +0300
@@ -0,0 +1,304 @@
+/*
+ * Copyright 2006, Johannes Berg <johannes@sipsolutions.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* just for IFNAMSIZ */
+#include <linux/if.h>
+#include <linux/slab.h>
+#include <linux/export.h>
+#include "led.h"
+
+void ieee80211_led_rx(struct ieee80211_local *local)
+{
+	if (unlikely(!local->rx_led))
+		return;
+	if (local->rx_led_counter++ % 2 == 0)
+		led_trigger_event(local->rx_led, LED_OFF);
+	else
+		led_trigger_event(local->rx_led, LED_FULL);
+}
+
+/* q is 1 if a packet was enqueued, 0 if it has been transmitted */
+void ieee80211_led_tx(struct ieee80211_local *local, int q)
+{
+	if (unlikely(!local->tx_led))
+		return;
+	/* not sure how this is supposed to work ... */
+	local->tx_led_counter += 2*q-1;
+	if (local->tx_led_counter % 2 == 0)
+		led_trigger_event(local->tx_led, LED_OFF);
+	else
+		led_trigger_event(local->tx_led, LED_FULL);
+}
+
+void ieee80211_led_assoc(struct ieee80211_local *local, bool associated)
+{
+	if (unlikely(!local->assoc_led))
+		return;
+	if (associated)
+		led_trigger_event(local->assoc_led, LED_FULL);
+	else
+		led_trigger_event(local->assoc_led, LED_OFF);
+}
+
+void ieee80211_led_radio(struct ieee80211_local *local, bool enabled)
+{
+	if (unlikely(!local->radio_led))
+		return;
+	if (enabled)
+		led_trigger_event(local->radio_led, LED_FULL);
+	else
+		led_trigger_event(local->radio_led, LED_OFF);
+}
+
+void ieee80211_led_names(struct ieee80211_local *local)
+{
+	snprintf(local->rx_led_name, sizeof(local->rx_led_name),
+		 "%srx", wiphy_name(local->hw.wiphy));
+	snprintf(local->tx_led_name, sizeof(local->tx_led_name),
+		 "%stx", wiphy_name(local->hw.wiphy));
+	snprintf(local->assoc_led_name, sizeof(local->assoc_led_name),
+		 "%sassoc", wiphy_name(local->hw.wiphy));
+	snprintf(local->radio_led_name, sizeof(local->radio_led_name),
+		 "%sradio", wiphy_name(local->hw.wiphy));
+}
+
+void ieee80211_led_init(struct ieee80211_local *local)
+{
+	local->rx_led = kzalloc(sizeof(struct led_trigger), GFP_KERNEL);
+	if (local->rx_led) {
+		local->rx_led->name = local->rx_led_name;
+		if (led_trigger_register(local->rx_led)) {
+			kfree(local->rx_led);
+			local->rx_led = NULL;
+		}
+	}
+
+	local->tx_led = kzalloc(sizeof(struct led_trigger), GFP_KERNEL);
+	if (local->tx_led) {
+		local->tx_led->name = local->tx_led_name;
+		if (led_trigger_register(local->tx_led)) {
+			kfree(local->tx_led);
+			local->tx_led = NULL;
+		}
+	}
+
+	local->assoc_led = kzalloc(sizeof(struct led_trigger), GFP_KERNEL);
+	if (local->assoc_led) {
+		local->assoc_led->name = local->assoc_led_name;
+		if (led_trigger_register(local->assoc_led)) {
+			kfree(local->assoc_led);
+			local->assoc_led = NULL;
+		}
+	}
+
+	local->radio_led = kzalloc(sizeof(struct led_trigger), GFP_KERNEL);
+	if (local->radio_led) {
+		local->radio_led->name = local->radio_led_name;
+		if (led_trigger_register(local->radio_led)) {
+			kfree(local->radio_led);
+			local->radio_led = NULL;
+		}
+	}
+
+	if (local->tpt_led_trigger) {
+		if (led_trigger_register(&local->tpt_led_trigger->trig)) {
+			kfree(local->tpt_led_trigger);
+			local->tpt_led_trigger = NULL;
+		}
+	}
+}
+
+void ieee80211_led_exit(struct ieee80211_local *local)
+{
+	if (local->radio_led) {
+		led_trigger_unregister(local->radio_led);
+		kfree(local->radio_led);
+	}
+	if (local->assoc_led) {
+		led_trigger_unregister(local->assoc_led);
+		kfree(local->assoc_led);
+	}
+	if (local->tx_led) {
+		led_trigger_unregister(local->tx_led);
+		kfree(local->tx_led);
+	}
+	if (local->rx_led) {
+		led_trigger_unregister(local->rx_led);
+		kfree(local->rx_led);
+	}
+
+	if (local->tpt_led_trigger) {
+		led_trigger_unregister(&local->tpt_led_trigger->trig);
+		kfree(local->tpt_led_trigger);
+	}
+}
+
+char *__ieee80211_get_radio_led_name(struct ieee80211_hw *hw)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+
+	return local->radio_led_name;
+}
+
+char *__ieee80211_get_assoc_led_name(struct ieee80211_hw *hw)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+
+	return local->assoc_led_name;
+}
+
+char *__ieee80211_get_tx_led_name(struct ieee80211_hw *hw)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+
+	return local->tx_led_name;
+}
+
+char *__ieee80211_get_rx_led_name(struct ieee80211_hw *hw)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+
+	return local->rx_led_name;
+}
+
+static unsigned long tpt_trig_traffic(struct ieee80211_local *local,
+				      struct tpt_led_trigger *tpt_trig)
+{
+	unsigned long traffic, delta;
+
+	traffic = tpt_trig->tx_bytes + tpt_trig->rx_bytes;
+
+	delta = traffic - tpt_trig->prev_traffic;
+	tpt_trig->prev_traffic = traffic;
+	return DIV_ROUND_UP(delta, 1024 / 8);
+}
+
+static void tpt_trig_timer(unsigned long data)
+{
+	struct ieee80211_local *local = (void *)data;
+	struct tpt_led_trigger *tpt_trig = local->tpt_led_trigger;
+	struct led_classdev *led_cdev;
+	unsigned long on, off, tpt;
+	int i;
+
+	if (!tpt_trig->running)
+		return;
+
+	mod_timer(&tpt_trig->timer, round_jiffies(jiffies + HZ));
+
+	tpt = tpt_trig_traffic(local, tpt_trig);
+
+	/* default to just solid on */
+	on = 1;
+	off = 0;
+
+	for (i = tpt_trig->blink_table_len - 1; i >= 0; i--) {
+		if (tpt_trig->blink_table[i].throughput < 0 ||
+		    tpt > tpt_trig->blink_table[i].throughput) {
+			off = tpt_trig->blink_table[i].blink_time / 2;
+			on = tpt_trig->blink_table[i].blink_time - off;
+			break;
+		}
+	}
+
+	read_lock(&tpt_trig->trig.leddev_list_lock);
+	list_for_each_entry(led_cdev, &tpt_trig->trig.led_cdevs, trig_list)
+		led_blink_set(led_cdev, &on, &off);
+	read_unlock(&tpt_trig->trig.leddev_list_lock);
+}
+
+char *__ieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw,
+				unsigned int flags,
+				const struct ieee80211_tpt_blink *blink_table,
+				unsigned int blink_table_len)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct tpt_led_trigger *tpt_trig;
+
+	if (WARN_ON(local->tpt_led_trigger))
+		return NULL;
+
+	tpt_trig = kzalloc(sizeof(struct tpt_led_trigger), GFP_KERNEL);
+	if (!tpt_trig)
+		return NULL;
+
+	snprintf(tpt_trig->name, sizeof(tpt_trig->name),
+		 "%stpt", wiphy_name(local->hw.wiphy));
+
+	tpt_trig->trig.name = tpt_trig->name;
+
+	tpt_trig->blink_table = blink_table;
+	tpt_trig->blink_table_len = blink_table_len;
+	tpt_trig->want = flags;
+
+	setup_timer(&tpt_trig->timer, tpt_trig_timer, (unsigned long)local);
+
+	local->tpt_led_trigger = tpt_trig;
+
+	return tpt_trig->name;
+}
+
+static void ieee80211_start_tpt_led_trig(struct ieee80211_local *local)
+{
+	struct tpt_led_trigger *tpt_trig = local->tpt_led_trigger;
+
+	if (tpt_trig->running)
+		return;
+
+	/* reset traffic */
+	tpt_trig_traffic(local, tpt_trig);
+	tpt_trig->running = true;
+
+	tpt_trig_timer((unsigned long)local);
+	mod_timer(&tpt_trig->timer, round_jiffies(jiffies + HZ));
+}
+
+static void ieee80211_stop_tpt_led_trig(struct ieee80211_local *local)
+{
+	struct tpt_led_trigger *tpt_trig = local->tpt_led_trigger;
+	struct led_classdev *led_cdev;
+
+	if (!tpt_trig->running)
+		return;
+
+	tpt_trig->running = false;
+	del_timer_sync(&tpt_trig->timer);
+
+	read_lock(&tpt_trig->trig.leddev_list_lock);
+	list_for_each_entry(led_cdev, &tpt_trig->trig.led_cdevs, trig_list)
+		led_brightness_set(led_cdev, LED_OFF);
+	read_unlock(&tpt_trig->trig.leddev_list_lock);
+}
+
+void ieee80211_mod_tpt_led_trig(struct ieee80211_local *local,
+				unsigned int types_on, unsigned int types_off)
+{
+	struct tpt_led_trigger *tpt_trig = local->tpt_led_trigger;
+	bool allowed;
+
+	WARN_ON(types_on & types_off);
+
+	if (!tpt_trig)
+		return;
+
+	tpt_trig->active &= ~types_off;
+	tpt_trig->active |= types_on;
+
+	/*
+	 * Regardless of wanted state, we shouldn't blink when
+	 * the radio is disabled -- this can happen due to some
+	 * code ordering issues with __mac80211_recalc_idle()
+	 * being called before the radio is started.
+	 */
+	allowed = tpt_trig->active & IEEE80211_TPT_LEDTRIG_FL_RADIO;
+
+	if (!allowed || !(tpt_trig->active & tpt_trig->want))
+		ieee80211_stop_tpt_led_trig(local);
+	else
+		ieee80211_start_tpt_led_trig(local);
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/led.h b/drivers/net/wireless/xr829/umac/led.h
--- a/drivers/net/wireless/xr829/umac/led.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/led.h	2022-08-27 01:22:42.942539817 +0300
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2006, Johannes Berg <johannes@sipsolutions.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/leds.h>
+#include "ieee80211_i.h"
+
+#ifdef CONFIG_XRMAC_LEDS
+void ieee80211_led_rx(struct ieee80211_local *local);
+void ieee80211_led_tx(struct ieee80211_local *local, int q);
+void ieee80211_led_assoc(struct ieee80211_local *local,
+			 bool associated);
+void ieee80211_led_radio(struct ieee80211_local *local,
+			 bool enabled);
+void ieee80211_led_names(struct ieee80211_local *local);
+void ieee80211_led_init(struct ieee80211_local *local);
+void ieee80211_led_exit(struct ieee80211_local *local);
+void ieee80211_mod_tpt_led_trig(struct ieee80211_local *local,
+				unsigned int types_on, unsigned int types_off);
+#else
+static inline void ieee80211_led_rx(struct ieee80211_local *local)
+{
+}
+static inline void ieee80211_led_tx(struct ieee80211_local *local, int q)
+{
+}
+static inline void ieee80211_led_assoc(struct ieee80211_local *local,
+				       bool associated)
+{
+}
+static inline void ieee80211_led_radio(struct ieee80211_local *local,
+				       bool enabled)
+{
+}
+static inline void ieee80211_led_names(struct ieee80211_local *local)
+{
+}
+static inline void ieee80211_led_init(struct ieee80211_local *local)
+{
+}
+static inline void ieee80211_led_exit(struct ieee80211_local *local)
+{
+}
+static inline void ieee80211_mod_tpt_led_trig(struct ieee80211_local *local,
+					      unsigned int types_on,
+					      unsigned int types_off)
+{
+}
+#endif
+
+static inline void
+ieee80211_tpt_led_trig_tx(struct ieee80211_local *local, __le16 fc, int bytes)
+{
+#ifdef CONFIG_XRMAC_LEDS
+	if (local->tpt_led_trigger && ieee80211_is_data(fc))
+		local->tpt_led_trigger->tx_bytes += bytes;
+#endif
+}
+
+static inline void
+ieee80211_tpt_led_trig_rx(struct ieee80211_local *local, __le16 fc, int bytes)
+{
+#ifdef CONFIG_XRMAC_LEDS
+	if (local->tpt_led_trigger && ieee80211_is_data(fc))
+		local->tpt_led_trigger->rx_bytes += bytes;
+#endif
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/main.c b/drivers/net/wireless/xr829/umac/main.c
--- a/drivers/net/wireless/xr829/umac/main.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/main.c	2022-08-27 01:22:42.946539832 +0300
@@ -0,0 +1,1381 @@
+/*
+ * Copyright 2002-2005, Instant802 Networks, Inc.
+ * Copyright 2005-2006, Devicescape Software, Inc.
+ * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <generated/uapi/linux/version.h>
+#include <net/mac80211.h>
+#include <linux/module.h>
+#include <linux/fips.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/skbuff.h>
+#include <linux/etherdevice.h>
+#include <linux/if_arp.h>
+#include <linux/rtnetlink.h>
+#include <linux/bitmap.h>
+#include <linux/pm_qos.h>
+#include <linux/inetdevice.h>
+#include <net/net_namespace.h>
+#include <net/cfg80211.h>
+#include <uapi/linux/netdevice.h>
+
+#ifdef IPV6_FILTERING
+#include <net/if_inet6.h>
+#include <net/addrconf.h>
+#endif /*IPV6_FILTERING*/
+
+#include "ieee80211_i.h"
+#include "driver-ops.h"
+#include "rate.h"
+#include "mesh.h"
+#include "wep.h"
+#include "led.h"
+#include "cfg.h"
+#include "debugfs.h"
+
+static struct lock_class_key ieee80211_rx_skb_queue_class;
+
+void mac80211_configure_filter(struct ieee80211_sub_if_data *sdata)
+{
+	u64 mc;
+	unsigned int changed_flags;
+	unsigned int new_flags = 0;
+	struct ieee80211_local *local = sdata->local;
+
+#if 0
+	if (!(SDATA_STATE_RUNNING & sdata->state))
+		return;
+#endif
+
+	if (sdata->flags & IEEE80211_SDATA_ALLMULTI)
+		new_flags |= FIF_ALLMULTI;
+
+	if (sdata->flags & IEEE80211_SDATA_PROMISC)
+		new_flags |= FIF_PROMISC_IN_BSS;
+
+	if (sdata->vif.type == NL80211_IFTYPE_MONITOR ||
+			local->scan_sdata == sdata)
+		new_flags |= FIF_BCN_PRBRESP_PROMISC;
+
+	if (sdata->vif.type == NL80211_IFTYPE_AP ||
+			sdata->vif.type == NL80211_IFTYPE_ADHOC)
+		new_flags |= FIF_PROBE_REQ;
+
+	if (sdata->vif.type == NL80211_IFTYPE_AP)
+		new_flags |= FIF_PSPOLL;
+
+	new_flags |= sdata->req_filt_flags;
+
+	spin_lock_bh(&local->filter_lock);
+	changed_flags = sdata->filter_flags ^ new_flags;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
+	mc = drv_prepare_multicast(local, sdata, &sdata->mc_list);
+#else
+	mc = drv_prepare_multicast(local, sdata, sdata->mc_count,
+				   sdata->mc_list);
+#endif
+	spin_unlock_bh(&local->filter_lock);
+
+	/* be a bit nasty */
+	new_flags |= ((unsigned int)1 << 31);
+
+	drv_configure_filter(local, sdata, changed_flags, &new_flags, mc);
+
+	WARN_ON(new_flags & ((unsigned int)1 << 31));
+
+	sdata->filter_flags = new_flags & ~((unsigned int)1 << 31);
+}
+
+void ieee80211_notify_channel_change(struct ieee80211_local *local,
+			struct ieee80211_sub_if_data *sdata)
+{
+	if (local->hw.flags & IEEE80211_HW_SUPPORTS_MULTI_CHANNEL) {
+		BUG_ON(!sdata);
+		mac80211_bss_info_change_notify(sdata, BSS_CHANGED_CHANNEL);
+	} else {
+		mac80211_hw_config(local, IEEE80211_CONF_CHANGE_CHANNEL);
+	}
+}
+
+static struct ieee80211_channel *ieee80211_recalc_channel(
+			struct ieee80211_local *local,
+			struct ieee80211_sub_if_data *sdata,
+			u32 *changed)
+{
+	struct ieee80211_channel_state *chan_state;
+	struct ieee80211_channel *chan, *scan_chan;
+	enum nl80211_channel_type channel_type;
+	u32 offchannel_flag;
+	bool multi_channel;
+
+	BUG_ON(local && sdata);
+	BUG_ON(!local && !sdata);
+
+	multi_channel = sdata ? true : false;
+	if (local == NULL && sdata != NULL)
+		local = sdata->local;
+	scan_chan = local->scan_channel;
+
+	if (sdata) {
+		if (local->scan_sdata != sdata)
+			scan_chan = NULL;
+		chan_state = &sdata->chan_state;
+	} else if (scan_chan) {
+		BUG_ON(!local->scan_sdata);
+		chan_state = &local->scan_sdata->chan_state;
+	} else {
+		chan_state = &local->chan_state;
+	}
+
+	offchannel_flag = chan_state->conf.offchannel;
+	if (scan_chan) {
+		chan = scan_chan;
+		/* If scanning on oper channel, use whatever channel-type
+		 * is currently in use.
+		 */
+		if (chan == chan_state->oper_channel)
+			channel_type = chan_state->_oper_channel_type;
+		else
+			channel_type = NL80211_CHAN_NO_HT;
+		chan_state->conf.offchannel = true;
+	} else if (chan_state->tmp_channel &&
+		   chan_state->oper_channel != chan_state->tmp_channel) {
+		chan = scan_chan = chan_state->tmp_channel;
+		channel_type = chan_state->tmp_channel_type;
+		chan_state->conf.offchannel = true;
+	} else {
+		chan = chan_state->oper_channel;
+		channel_type = chan_state->_oper_channel_type;
+		chan_state->conf.offchannel = false;
+	}
+
+	offchannel_flag ^= chan_state->conf.offchannel;
+
+	if (offchannel_flag || chan != chan_state->conf.channel ||
+	    channel_type != chan_state->conf.channel_type) {
+		chan_state->conf.channel = chan;
+		chan_state->conf.channel_type = channel_type;
+
+		if (multi_channel) {
+			*changed |= BSS_CHANGED_CHANNEL;
+		} else {
+			*changed |= IEEE80211_CONF_CHANGE_CHANNEL;
+		}
+	}
+
+	return chan;
+}
+
+int mac80211_hw_config(struct ieee80211_local *local, u32 changed)
+{
+	struct ieee80211_channel *chan = NULL; /* Only used when multi channel is off */
+	struct ieee80211_sub_if_data *sdata;
+	int ret = 0;
+	int power;
+	bool is_ht;
+
+	might_sleep();
+
+	if (local->hw.flags & IEEE80211_HW_SUPPORTS_MULTI_CHANNEL) {
+		/* XXX: broken code ahead*/
+		/*      we can't call bss_info_changed while in rcu section!*/
+		rcu_read_lock();
+		list_for_each_entry_rcu(sdata, &local->interfaces, list)
+			ieee80211_recalc_channel(NULL, sdata, &changed);
+		rcu_read_unlock();
+		/* XXX: broken code end*/
+	} else {
+		chan = ieee80211_recalc_channel(local, NULL, &changed);
+	}
+
+	if (local->hw.flags & IEEE80211_HW_SUPPORTS_MULTI_CHANNEL) {
+		is_ht = true;
+		rcu_read_lock();
+		list_for_each_entry_rcu(sdata, &local->interfaces, list) {
+			if (!conf_is_ht(&sdata->chan_state.conf)) {
+				is_ht = false;
+				break;
+			}
+		}
+		rcu_read_unlock();
+	} else {
+		is_ht = conf_is_ht(local->hw.conf.chan_conf);
+	}
+
+	if (!is_ht) {
+		/*
+		 * mac80211.h documents that this is only valid
+		 * when the channel is set to an HT type, and
+		 * that otherwise STATIC is used.
+		 */
+		local->hw.conf.smps_mode = IEEE80211_SMPS_STATIC;
+	} else if (local->hw.conf.smps_mode != local->smps_mode) {
+		local->hw.conf.smps_mode = local->smps_mode;
+		changed |= IEEE80211_CONF_CHANGE_SMPS;
+	}
+
+	if (local->hw.flags & IEEE80211_HW_SUPPORTS_MULTI_CHANNEL) {
+		power = 0;
+		rcu_read_lock();
+		list_for_each_entry_rcu(sdata, &local->interfaces, list)
+			power = max(power, sdata->chan_state.conf.channel->max_power);
+		list_for_each_entry_rcu(sdata, &local->interfaces, list)
+			power = min(power, (sdata->chan_state.conf.channel->max_power -
+						local->power_constr_level));
+		rcu_read_unlock();
+	} else {
+		if ((local->scanning & SCAN_SW_SCANNING) ||
+		    (local->scanning & SCAN_HW_SCANNING)) {
+			power = chan->max_power;
+		} else {
+			power = local->power_constr_level ?
+				(chan->max_power - local->power_constr_level) :
+				chan->max_power;
+		}
+	}
+
+	if (local->user_power_level >= 0)
+		power = min(power, local->user_power_level);
+
+	if (local->hw.conf.power_level != power) {
+		changed |= IEEE80211_CONF_CHANGE_POWER;
+		local->hw.conf.power_level = power;
+	}
+
+	if (changed && local->open_count) {
+		ret = drv_config(local, changed);
+		/*
+		 * Goal:
+		 * HW reconfiguration should never fail, the driver has told
+		 * us what it can support so it should live up to that promise.
+		 *
+		 * Current status:
+		 * rfkill is not integrated with mac80211 and a
+		 * configuration command can thus fail if hardware rfkill
+		 * is enabled
+		 *
+		 * FIXME: integrate rfkill with mac80211 and then add this
+		 * WARN_ON() back
+		 *
+		 */
+		/* WARN_ON(ret); */
+	}
+
+	return ret;
+}
+
+void mac80211_bss_info_change_notify(struct ieee80211_sub_if_data *sdata,
+				      u32 changed)
+{
+	struct ieee80211_local *local = sdata->local;
+	static const u8 zero[ETH_ALEN] = { 0 };
+
+	if (!changed)
+		return;
+
+	if (local->hw.flags & IEEE80211_HW_SUPPORTS_MULTI_CHANNEL)
+		ieee80211_recalc_channel(NULL, sdata, &changed);
+
+	if (sdata->vif.type == NL80211_IFTYPE_STATION) {
+		/*
+		 * While not associated, claim a BSSID of all-zeroes
+		 * so that drivers don't do any weird things with the
+		 * BSSID at that time.
+		 */
+		if (sdata->vif.bss_conf.assoc)
+			sdata->vif.bss_conf.bssid = sdata->u.mgd.bssid;
+		else
+			sdata->vif.bss_conf.bssid = zero;
+	} else if (sdata->vif.type == NL80211_IFTYPE_ADHOC)
+		sdata->vif.bss_conf.bssid = sdata->u.ibss.bssid;
+	else if (sdata->vif.type == NL80211_IFTYPE_AP)
+		sdata->vif.bss_conf.bssid = sdata->vif.addr;
+	else if (sdata->vif.type == NL80211_IFTYPE_WDS)
+		sdata->vif.bss_conf.bssid = NULL;
+	else if (ieee80211_vif_is_mesh(&sdata->vif)) {
+		sdata->vif.bss_conf.bssid = zero;
+	} else if (sdata->vif.type == NL80211_IFTYPE_P2P_DEVICE) {
+		sdata->vif.bss_conf.bssid = sdata->vif.addr;
+		WARN_ONCE(changed & ~(BSS_CHANGED_IDLE),
+			  "P2P Device BSS changed %#x", changed);
+	} else {
+		WARN_ON(1);
+		return;
+	}
+
+	switch (sdata->vif.type) {
+	case NL80211_IFTYPE_AP:
+	case NL80211_IFTYPE_ADHOC:
+	case NL80211_IFTYPE_WDS:
+	case NL80211_IFTYPE_MESH_POINT:
+		break;
+	default:
+		/* do not warn to simplify caller in scan.c */
+		changed &= ~BSS_CHANGED_BEACON_ENABLED;
+		if (WARN_ON(changed & BSS_CHANGED_BEACON))
+			return;
+		break;
+	}
+
+	if (changed & BSS_CHANGED_BEACON_ENABLED) {
+		if (local->quiescing || !ieee80211_sdata_running(sdata) ||
+		    test_bit(SCAN_SW_SCANNING, &local->scanning)) {
+			sdata->vif.bss_conf.enable_beacon = false;
+		} else {
+			/*
+			 * Beacon should be enabled, but AP mode must
+			 * check whether there is a beacon configured.
+			 */
+			switch (sdata->vif.type) {
+			case NL80211_IFTYPE_AP:
+				sdata->vif.bss_conf.enable_beacon =
+					!!sdata->u.ap.beacon;
+				break;
+			case NL80211_IFTYPE_ADHOC:
+				sdata->vif.bss_conf.enable_beacon =
+					!!sdata->u.ibss.presp;
+				break;
+#ifdef CONFIG_XRMAC_MESH
+			case NL80211_IFTYPE_MESH_POINT:
+				sdata->vif.bss_conf.enable_beacon =
+					!!sdata->u.mesh.mesh_id_len;
+				break;
+#endif
+			default:
+				/* not reached */
+				WARN_ON(1);
+				break;
+			}
+		}
+	}
+
+	drv_bss_info_changed(local, sdata, &sdata->vif.bss_conf, changed);
+}
+
+u32 mac80211_reset_erp_info(struct ieee80211_sub_if_data *sdata)
+{
+	sdata->vif.bss_conf.use_cts_prot = false;
+	sdata->vif.bss_conf.use_short_preamble = false;
+	sdata->vif.bss_conf.use_short_slot = false;
+	return BSS_CHANGED_ERP_CTS_PROT |
+	       BSS_CHANGED_ERP_PREAMBLE |
+	       BSS_CHANGED_ERP_SLOT;
+}
+
+static void ieee80211_tasklet_handler(unsigned long data)
+{
+	struct ieee80211_local *local = (struct ieee80211_local *) data;
+	struct sta_info *sta, *tmp;
+	struct skb_eosp_msg_data *eosp_data;
+	struct sk_buff *skb;
+
+	while ((skb = skb_dequeue(&local->skb_queue)) ||
+	       (skb = skb_dequeue(&local->skb_queue_unreliable))) {
+		switch (skb->pkt_type) {
+		case IEEE80211_RX_MSG:
+			/* Clear skb->pkt_type in order to not confuse kernel
+			 * netstack. */
+			skb->pkt_type = 0;
+			mac80211_rx(local_to_hw(local), skb);
+			break;
+		case IEEE80211_TX_STATUS_MSG:
+			skb->pkt_type = 0;
+			mac80211_tx_status(local_to_hw(local), skb);
+			break;
+		case IEEE80211_EOSP_MSG:
+			eosp_data = (void *)skb->cb;
+			for_each_sta_info(local, eosp_data->sta, sta, tmp) {
+				/* skip wrong virtual interface */
+				if (memcmp(eosp_data->iface,
+					   sta->sdata->vif.addr, ETH_ALEN))
+					continue;
+				clear_sta_flag(sta, WLAN_STA_SP);
+				break;
+			}
+			dev_kfree_skb(skb);
+			break;
+		default:
+			WARN(1, "mac80211: Packet is of unknown type %d\n",
+			     skb->pkt_type);
+			dev_kfree_skb(skb);
+			break;
+		}
+	}
+}
+
+static void ieee80211_restart_work(struct work_struct *work)
+{
+	struct ieee80211_local *local =
+		container_of(work, struct ieee80211_local, restart_work);
+
+	/* wait for scan work complete */
+	flush_workqueue(local->workqueue);
+
+	mutex_lock(&local->mtx);
+	WARN(test_bit(SCAN_HW_SCANNING, &local->scanning) ||
+	     local->sched_scanning,
+		"%s called with hardware scan in progress\n", __func__);
+	mutex_unlock(&local->mtx);
+
+	rtnl_lock();
+	mac80211_scan_cancel(local);
+	mac80211_reconfig(local);
+	rtnl_unlock();
+}
+
+void mac80211_restart_hw(struct ieee80211_hw *hw)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+
+	trace_api_restart_hw(local);
+
+	wiphy_info(hw->wiphy,
+		   "Hardware restart was requested\n");
+
+	/* use this reason, mac80211_reconfig will unblock it */
+	mac80211_stop_queues_by_reason(hw,
+		IEEE80211_QUEUE_STOP_REASON_SUSPEND);
+
+	/*
+	 * Stop all Rx during the reconfig. We don't want state changes
+	 * or driver callbacks while this is in progress.
+	 */
+	local->in_reconfig = true;
+	barrier();
+
+	queue_work(system_freezable_wq, &local->restart_work);
+}
+
+int mac80211_ifdev_move(struct ieee80211_hw *hw,
+			struct device *new_parent, int dpm_order)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct ieee80211_sub_if_data *sdata;
+	int ret;
+
+	list_for_each_entry(sdata, &local->interfaces, list) {
+		if (sdata->vif.type == NL80211_IFTYPE_P2P_DEVICE)
+			continue;
+		ret = device_move(&sdata->dev->dev, new_parent, dpm_order);
+		if (ret < 0)
+			return ret;
+	}
+	return 0;
+}
+
+static void mac80211_recalc_smps_work(struct work_struct *work)
+{
+	struct ieee80211_local *local =
+		container_of(work, struct ieee80211_local, recalc_smps);
+
+	mutex_lock(&local->iflist_mtx);
+	mac80211_recalc_smps(local);
+	mutex_unlock(&local->iflist_mtx);
+}
+
+#ifdef CONFIG_INET
+static int ieee80211_ifa_changed(struct notifier_block *nb,
+				 unsigned long data, void *arg)
+{
+	struct in_ifaddr *ifa = arg;
+	struct ieee80211_local *local =
+		container_of(nb, struct ieee80211_local,
+			     ifa_notifier);
+	struct net_device *ndev = ifa->ifa_dev->dev;
+	struct wireless_dev *wdev = ndev->ieee80211_ptr;
+	struct in_device *idev;
+	struct ieee80211_sub_if_data *sdata;
+	struct ieee80211_bss_conf *bss_conf;
+	struct ieee80211_if_managed *ifmgd = NULL;
+	int c = 0;
+
+	/* Make sure it's our interface that got changed */
+	if (!wdev)
+		return NOTIFY_DONE;
+
+	if (wdev->wiphy != local->hw.wiphy)
+		return NOTIFY_DONE;
+
+	sdata = IEEE80211_DEV_TO_SUB_IF(ndev);
+	bss_conf = &sdata->vif.bss_conf;
+
+	if (!ieee80211_sdata_running(sdata))
+		return NOTIFY_DONE;
+
+	/* ARP filtering is only supported in managed mode */
+	switch (sdata->vif.type) {
+	case NL80211_IFTYPE_STATION:
+	case NL80211_IFTYPE_AP:
+	case NL80211_IFTYPE_P2P_GO:
+		break;
+	default:
+		return NOTIFY_DONE;
+	}
+
+	idev = __in_dev_get_rtnl(sdata->dev);
+	if (!idev)
+		return NOTIFY_DONE;
+
+	if (sdata->vif.type == NL80211_IFTYPE_STATION) {
+		ifmgd = &sdata->u.mgd;
+		mutex_lock(&ifmgd->mtx);
+	}
+
+	/* Copy the addresses to the bss_conf list */
+	ifa = idev->ifa_list;
+	while (c < IEEE80211_BSS_ARP_ADDR_LIST_LEN && ifa) {
+		bss_conf->arp_addr_list[c] = ifa->ifa_address;
+		ifa = ifa->ifa_next;
+		c++;
+	}
+
+	/* If not all addresses fit the list, disable filtering */
+	if (ifa) {
+		sdata->arp_filter_state = false;
+		c = 0;
+	} else {
+		sdata->arp_filter_state = true;
+	}
+	bss_conf->arp_addr_cnt = c;
+
+	if (sdata->vif.type == NL80211_IFTYPE_STATION) {
+		/* Configure driver only if associated */
+		if (ifmgd->associated) {
+			bss_conf->arp_filter_enabled = sdata->arp_filter_state;
+			mac80211_bss_info_change_notify(sdata,
+				BSS_CHANGED_ARP_FILTER);
+		}
+		mutex_unlock(&ifmgd->mtx);
+	} else {
+		bss_conf->arp_filter_enabled = sdata->arp_filter_state;
+		mac80211_bss_info_change_notify(sdata,
+						 BSS_CHANGED_ARP_FILTER);
+	}
+
+	return NOTIFY_DONE;
+}
+
+#ifdef IPV6_FILTERING
+static void ieee80211_ifa6_changed_work(struct work_struct *work)
+{
+	struct ieee80211_local *local =
+			container_of(work, struct ieee80211_local, ifa6_changed_work);
+	struct ieee80211_sub_if_data *sdata = local->ifa6_sdata;
+	struct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+
+	mutex_lock(&ifmgd->mtx);
+	if (ifmgd->associated) {
+		bss_conf->ndp_filter_enabled = sdata->ndp_filter_state;
+		mac80211_bss_info_change_notify(sdata,
+							BSS_CHANGED_NDP_FILTER);
+	}
+	mutex_unlock(&ifmgd->mtx);
+}
+
+static int ieee80211_ifa6_changed(struct notifier_block *nb,
+							    unsigned long data, void *arg)
+{
+	struct inet6_ifaddr *ifa = (struct inet6_ifaddr *)arg;
+	struct ieee80211_local *local =
+		   container_of(nb, struct ieee80211_local, ifa6_notifier);
+	struct net_device *ndev = (struct net_device *)ifa->idev->dev;
+	struct wireless_dev *wdev = ndev->ieee80211_ptr;
+	struct inet6_dev *idev;
+	struct ieee80211_sub_if_data *sdata;
+	struct ieee80211_bss_conf *bss_conf;
+	/*struct ieee80211_if_managed *ifmgd;*/
+	int c = 0;
+
+	/* Make sure it's our interface that got changed */
+	if (!wdev)
+		return NOTIFY_DONE;
+
+	if (wdev->wiphy != local->hw.wiphy)
+		return NOTIFY_DONE;
+
+	sdata = IEEE80211_DEV_TO_SUB_IF(ndev);
+	bss_conf = &sdata->vif.bss_conf;
+
+	if (!ieee80211_sdata_running(sdata))
+		return NOTIFY_DONE;
+
+	/* NDP filtering is only supported in managed mode */
+	switch (sdata->vif.type) {
+	case NL80211_IFTYPE_STATION:
+	case NL80211_IFTYPE_AP:
+	case NL80211_IFTYPE_P2P_GO:
+		break;
+	default:
+		return NOTIFY_DONE;
+	}
+
+	idev = __in6_dev_get(sdata->dev);
+	if (!idev)
+		return NOTIFY_DONE;
+
+#if 0
+	if (sdata->vif.type == NL80211_IFTYPE_STATION) {
+			ifmgd = &sdata->u.mgd;
+			mutex_lock(&ifmgd->mtx);
+	}
+#endif
+
+	list_for_each_entry(ifa, &idev->addr_list, if_list) {
+		c++;
+		if (c > IEEE80211_BSS_NDP_ADDR_LIST_LEN)
+			break;
+		memcpy(&bss_conf->ndp_addr_list[c-1],
+				&ifa->addr, sizeof(struct in6_addr));
+	}
+
+	if (c > IEEE80211_BSS_NDP_ADDR_LIST_LEN) {
+		sdata->ndp_filter_state = false;
+		c = 0;
+	} else {
+		sdata->ndp_filter_state = true;
+	}
+	bss_conf->ndp_addr_cnt = c;
+
+	if (sdata->vif.type == NL80211_IFTYPE_STATION) {
+		local->ifa6_sdata = sdata;
+		schedule_work(&local->ifa6_changed_work);
+#if 0
+		/* Configure driver only if associated */
+		if (ifmgd->associated) {
+			bss_conf->ndp_filter_enabled = sdata->ndp_filter_state;
+			mac80211_bss_info_change_notify(sdata,
+						BSS_CHANGED_NDP_FILTER);
+		}
+		mutex_unlock(&ifmgd->mtx);
+#endif
+	} else {
+		bss_conf->ndp_filter_enabled = sdata->ndp_filter_state;
+	}
+
+	return NOTIFY_DONE;
+}
+#endif /*IPV6_FILTERING*/
+#endif /*CONFIG_INET*/
+
+/* There isn't a lot of sense in it, but you can transmit anything you like */
+static const struct ieee80211_txrx_stypes
+ieee80211_default_mgmt_stypes[NUM_NL80211_IFTYPES] = {
+	[NL80211_IFTYPE_ADHOC] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ACTION >> 4),
+	},
+	[NL80211_IFTYPE_STATION] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
+			BIT(IEEE80211_STYPE_PROBE_REQ >> 4),
+	},
+	[NL80211_IFTYPE_AP] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
+			BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
+			BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
+			BIT(IEEE80211_STYPE_DISASSOC >> 4) |
+			BIT(IEEE80211_STYPE_AUTH >> 4) |
+			BIT(IEEE80211_STYPE_DEAUTH >> 4) |
+			BIT(IEEE80211_STYPE_ACTION >> 4),
+	},
+	[NL80211_IFTYPE_AP_VLAN] = {
+		/* copy AP */
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
+			BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
+			BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
+			BIT(IEEE80211_STYPE_DISASSOC >> 4) |
+			BIT(IEEE80211_STYPE_AUTH >> 4) |
+			BIT(IEEE80211_STYPE_DEAUTH >> 4) |
+			BIT(IEEE80211_STYPE_ACTION >> 4),
+	},
+	[NL80211_IFTYPE_P2P_CLIENT] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
+			BIT(IEEE80211_STYPE_PROBE_REQ >> 4),
+	},
+	[NL80211_IFTYPE_P2P_GO] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
+			BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
+			BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
+			BIT(IEEE80211_STYPE_DISASSOC >> 4) |
+			BIT(IEEE80211_STYPE_AUTH >> 4) |
+			BIT(IEEE80211_STYPE_DEAUTH >> 4) |
+			BIT(IEEE80211_STYPE_ACTION >> 4),
+	},
+	[NL80211_IFTYPE_MESH_POINT] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
+			BIT(IEEE80211_STYPE_AUTH >> 4) |
+			BIT(IEEE80211_STYPE_DEAUTH >> 4),
+	},
+	[NL80211_IFTYPE_P2P_DEVICE] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
+			BIT(IEEE80211_STYPE_PROBE_REQ >> 4),
+	},
+
+};
+
+struct ieee80211_hw *mac80211_alloc_hw(size_t priv_data_len,
+					const struct ieee80211_ops *ops)
+{
+	struct ieee80211_local *local;
+	int priv_size, i;
+	struct wiphy *wiphy;
+
+	/* Ensure 32-byte alignment of our private data and hw private data.
+	 * We use the wiphy priv data for both our ieee80211_local and for
+	 * the driver's private data
+	 *
+	 * In memory it'll be like this:
+	 *
+	 * +-------------------------+
+	 * | struct wiphy	    |
+	 * +-------------------------+
+	 * | struct ieee80211_local  |
+	 * +-------------------------+
+	 * | driver's private data   |
+	 * +-------------------------+
+	 *
+	 */
+	priv_size = ALIGN(sizeof(*local), NETDEV_ALIGN) + priv_data_len;
+
+	wiphy = wiphy_new(&xrmac_config_ops, priv_size);
+
+	if (!wiphy)
+		return NULL;
+
+	wiphy->mgmt_stypes = ieee80211_default_mgmt_stypes;
+
+	wiphy->privid = xrmac_wiphy_privid;
+	wiphy->features |= NL80211_FEATURE_SAE;
+
+	wiphy->flags |= WIPHY_FLAG_NETNS_OK |
+			WIPHY_FLAG_4ADDR_AP |
+			WIPHY_FLAG_4ADDR_STATION |
+			WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
+
+	if (!ops->set_key)
+		wiphy->flags |= WIPHY_FLAG_IBSS_RSN;
+
+	wiphy->bss_priv_size = sizeof(struct ieee80211_bss);
+
+	local = wiphy_priv(wiphy);
+
+	local->hw.wiphy = wiphy;
+
+	local->hw.priv = (char *)local + ALIGN(sizeof(*local), NETDEV_ALIGN);
+
+	BUG_ON(!ops->tx);
+	BUG_ON(!ops->start);
+	BUG_ON(!ops->stop);
+	BUG_ON(!ops->config);
+	BUG_ON(!ops->add_interface);
+	BUG_ON(!ops->remove_interface);
+	BUG_ON(!ops->configure_filter);
+	local->ops = ops;
+
+	local->hw.conf.chan_conf = &local->chan_state.conf;
+
+	/* set up some defaults */
+	local->hw.queues = 1;
+	local->hw.max_rates = 1;
+	local->hw.max_report_rates = 0;
+	local->hw.max_rx_aggregation_subframes = IEEE80211_MAX_AMPDU_BUF;
+	local->hw.max_tx_aggregation_subframes = IEEE80211_MAX_AMPDU_BUF;
+	local->hw.offchannel_tx_hw_queue = IEEE80211_INVAL_HW_QUEUE;
+	local->user_power_level = -1;
+	local->uapsd_queues = IEEE80211_DEFAULT_UAPSD_QUEUES;
+	local->uapsd_max_sp_len = IEEE80211_DEFAULT_MAX_SP_LEN;
+
+	INIT_LIST_HEAD(&local->interfaces);
+	mutex_init(&local->iflist_mtx);
+	mutex_init(&local->mtx);
+
+	mutex_init(&local->key_mtx);
+	spin_lock_init(&local->filter_lock);
+	spin_lock_init(&local->queue_stop_reason_lock);
+
+	/*
+	 * The rx_skb_queue is only accessed from tasklets,
+	 * but other SKB queues are used from within IRQ
+	 * context. Therefore, this one needs a different
+	 * locking class so our direct, non-irq-safe use of
+	 * the queue's lock doesn't throw lockdep warnings.
+	 */
+	skb_queue_head_init_class(&local->rx_skb_queue,
+				  &ieee80211_rx_skb_queue_class);
+
+	INIT_DELAYED_WORK(&local->scan_work, mac80211_scan_work);
+
+	mac80211_work_init(local);
+
+	INIT_WORK(&local->restart_work, ieee80211_restart_work);
+
+#ifdef CONFIG_INET
+#ifdef IPV6_FILTERING
+		INIT_WORK(&local->ifa6_changed_work, ieee80211_ifa6_changed_work);
+#endif /*IPV6_FILTERING*/
+#endif
+
+	INIT_WORK(&local->recalc_smps, mac80211_recalc_smps_work);
+	local->smps_mode = IEEE80211_SMPS_OFF;
+
+	INIT_WORK(&local->sched_scan_stopped_work,
+		  mac80211_sched_scan_stopped_work);
+
+	xrmac_sta_info_init(local);
+
+	for (i = 0; i < IEEE80211_MAX_QUEUES; i++) {
+		skb_queue_head_init(&local->pending[i]);
+		atomic_set(&local->agg_queue_stop[i], 0);
+	}
+	tasklet_init(&local->tx_pending_tasklet, mac80211_tx_pending,
+		     (unsigned long)local);
+
+	tasklet_init(&local->tasklet,
+		     ieee80211_tasklet_handler,
+		     (unsigned long) local);
+
+	skb_queue_head_init(&local->skb_queue);
+	skb_queue_head_init(&local->skb_queue_unreliable);
+
+	ieee80211_led_names(local);
+
+	mac80211_hw_roc_setup(local);
+
+	return local_to_hw(local);
+}
+
+static int ieee80211_init_cipher_suites(struct ieee80211_local *local)
+{
+	bool have_wep = !fips_enabled; /* FIPS does not permit the use of RC4 */
+	bool have_mfp = local->hw.flags & IEEE80211_HW_MFP_CAPABLE;
+	const struct ieee80211_cipher_scheme *cs = local->hw.cipher_schemes;
+	int n_suites = 0, r = 0, w = 0;
+	u32 *suites;
+	static const u32 cipher_suites[] = {
+		/* keep WEP first, it may be removed below */
+		WLAN_CIPHER_SUITE_WEP40,
+		WLAN_CIPHER_SUITE_WEP104,
+		WLAN_CIPHER_SUITE_TKIP,
+		WLAN_CIPHER_SUITE_CCMP,
+
+		/* keep last -- depends on hw flags! */
+		WLAN_CIPHER_SUITE_AES_CMAC
+	};
+
+	/* Driver specifies the ciphers, we have nothing to do... */
+	if (local->hw.wiphy->cipher_suites && have_wep)
+		return 0;
+
+	/* Set up cipher suites if driver relies on mac80211 cipher defs */
+	if (!local->hw.wiphy->cipher_suites && !cs) {
+		local->hw.wiphy->cipher_suites = cipher_suites;
+		local->hw.wiphy->n_cipher_suites = ARRAY_SIZE(cipher_suites);
+
+		if (!have_mfp)
+			local->hw.wiphy->n_cipher_suites--;
+
+		if (!have_wep) {
+			local->hw.wiphy->cipher_suites += 2;
+			local->hw.wiphy->n_cipher_suites -= 2;
+		}
+
+		return 0;
+	}
+
+	if (!local->hw.wiphy->cipher_suites) {
+		/*
+		 * Driver specifies cipher schemes only
+		 * We start counting ciphers defined by schemes, TKIP and CCMP
+		 */
+		n_suites = local->hw.n_cipher_schemes + 2;
+
+		/* check if we have WEP40 and WEP104 */
+		if (have_wep)
+			n_suites += 2;
+
+		/* check if we have AES_CMAC */
+		if (have_mfp)
+			n_suites++;
+
+		suites = kmalloc(sizeof(u32) * n_suites, GFP_KERNEL);
+		if (!suites)
+			return -ENOMEM;
+
+		suites[w++] = WLAN_CIPHER_SUITE_CCMP;
+		suites[w++] = WLAN_CIPHER_SUITE_TKIP;
+
+		if (have_wep) {
+			suites[w++] = WLAN_CIPHER_SUITE_WEP40;
+			suites[w++] = WLAN_CIPHER_SUITE_WEP104;
+		}
+
+		if (have_mfp)
+			suites[w++] = WLAN_CIPHER_SUITE_AES_CMAC;
+
+		for (r = 0; r < local->hw.n_cipher_schemes; r++)
+			suites[w++] = cs[r].cipher;
+	} else {
+		/* Driver provides cipher suites, but we need to exclude WEP */
+		suites = kmemdup(local->hw.wiphy->cipher_suites,
+				 sizeof(u32) * local->hw.wiphy->n_cipher_suites,
+				 GFP_KERNEL);
+		if (!suites)
+			return -ENOMEM;
+
+		for (r = 0; r < local->hw.wiphy->n_cipher_suites; r++) {
+			u32 suite = local->hw.wiphy->cipher_suites[r];
+
+			if (suite == WLAN_CIPHER_SUITE_WEP40 ||
+			    suite == WLAN_CIPHER_SUITE_WEP104)
+				continue;
+			suites[w++] = suite;
+		}
+	}
+
+	local->hw.wiphy->cipher_suites = suites;
+	local->hw.wiphy->n_cipher_suites = w;
+	local->wiphy_ciphers_allocated = true;
+
+	return 0;
+}
+
+int mac80211_register_hw(struct ieee80211_hw *hw)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct ieee80211_channel_state *chan_state = &local->chan_state;
+	int result, i;
+	enum nl80211_band band;
+	int channels, max_bitrates;
+	bool supp_ht;
+
+	if (hw->flags & IEEE80211_HW_QUEUE_CONTROL &&
+	    (local->hw.offchannel_tx_hw_queue == IEEE80211_INVAL_HW_QUEUE ||
+	     local->hw.offchannel_tx_hw_queue >= local->hw.queues))
+		return -EINVAL;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
+		if ((hw->wiphy->wowlan->flags || hw->wiphy->wowlan->n_patterns)
+#else
+		if ((hw->wiphy->wowlan.flags || hw->wiphy->wowlan.n_patterns)
+#endif
+
+#ifdef CONFIG_PM
+	    && (!local->ops->suspend || !local->ops->resume)
+#endif
+	    )
+		return -EINVAL;
+
+	if (hw->max_report_rates == 0)
+		hw->max_report_rates = hw->max_rates;
+
+	/*
+	 * generic code guarantees at least one band,
+	 * set this very early because much code assumes
+	 * that chan_state->conf.channel is assigned
+	 */
+	channels = 0;
+	max_bitrates = 0;
+	supp_ht = false;
+	for (band = 0; band < NUM_NL80211_BANDS; band++) {
+		struct ieee80211_supported_band *sband;
+
+		sband = local->hw.wiphy->bands[band];
+		if (!sband)
+			continue;
+		if (!chan_state->oper_channel) {
+			/* init channel we're on */
+			/* soumik: Set default channel to a non-social channel */
+			chan_state->conf.channel =
+			/* chan_state->oper_channel = &sband->channels[0]; */
+			chan_state->oper_channel = &sband->channels[2];
+			chan_state->conf.channel_type = NL80211_CHAN_NO_HT;
+		}
+		channels += sband->n_channels;
+
+		if (max_bitrates < sband->n_bitrates)
+			max_bitrates = sband->n_bitrates;
+		supp_ht = supp_ht || sband->ht_cap.ht_supported;
+	}
+
+	local->int_scan_req = kzalloc(sizeof(*local->int_scan_req) +
+				      sizeof(void *) * channels, GFP_KERNEL);
+	if (!local->int_scan_req)
+		return -ENOMEM;
+
+	for (band = 0; band < NUM_NL80211_BANDS; band++) {
+		if (!local->hw.wiphy->bands[band])
+			continue;
+		local->int_scan_req->rates[band] = (u32) -1;
+	}
+
+	/* if low-level driver supports AP, we also support VLAN */
+	if (local->hw.wiphy->interface_modes & BIT(NL80211_IFTYPE_AP)) {
+		hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_AP_VLAN);
+		hw->wiphy->software_iftypes |= BIT(NL80211_IFTYPE_AP_VLAN);
+	}
+
+	/* mac80211 always supports monitor */
+	hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_MONITOR);
+	hw->wiphy->software_iftypes |= BIT(NL80211_IFTYPE_MONITOR);
+
+	/*
+	 * mac80211 doesn't support more than 1 channel, and also not more
+	 * than one IBSS interface
+	 */
+	for (i = 0; i < hw->wiphy->n_iface_combinations; i++) {
+		const struct ieee80211_iface_combination *c;
+		int j;
+
+		c = &hw->wiphy->iface_combinations[i];
+
+		if (c->num_different_channels > 1)
+			return -EINVAL;
+
+		for (j = 0; j < c->n_limits; j++)
+			if ((c->limits[j].types & BIT(NL80211_IFTYPE_ADHOC)) &&
+			    c->limits[j].max > 1)
+				return -EINVAL;
+	}
+
+#ifndef CONFIG_XRMAC_MESH
+	/* mesh depends on Kconfig, but drivers should set it if they want */
+	local->hw.wiphy->interface_modes &= ~BIT(NL80211_IFTYPE_MESH_POINT);
+#endif
+
+	/* if the underlying driver supports mesh, mac80211 will (at least)
+	 * provide routing of mesh authentication frames to userspace */
+	if (local->hw.wiphy->interface_modes & BIT(NL80211_IFTYPE_MESH_POINT))
+		local->hw.wiphy->flags |= WIPHY_FLAG_MESH_AUTH;
+
+	/* mac80211 supports control port protocol changing */
+	local->hw.wiphy->flags |= WIPHY_FLAG_CONTROL_PORT_PROTOCOL;
+
+	if (local->hw.flags & IEEE80211_HW_SIGNAL_DBM)
+		local->hw.wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
+	else if (local->hw.flags & IEEE80211_HW_SIGNAL_UNSPEC)
+		local->hw.wiphy->signal_type = CFG80211_SIGNAL_TYPE_UNSPEC;
+
+	WARN((local->hw.flags & IEEE80211_HW_SUPPORTS_UAPSD)
+	     && (local->hw.flags & IEEE80211_HW_PS_NULLFUNC_STACK),
+	     "U-APSD not supported with HW_PS_NULLFUNC_STACK\n");
+
+	/*
+	 * Calculate scan IE length -- we need this to alloc
+	 * memory and to subtract from the driver limit. It
+	 * includes the DS Params, (extended) supported rates, and HT
+	 * information -- SSID is the driver's responsibility.
+	 */
+	local->scan_ies_len = 4 + max_bitrates /* (ext) supp rates */ +
+		3 /* DS Params */;
+	if (supp_ht)
+		local->scan_ies_len += 2 + sizeof(struct ieee80211_ht_cap);
+
+	if (!local->ops->hw_scan) {
+		/* For hw_scan, driver needs to set these up. */
+		local->hw.wiphy->max_scan_ssids = 4;
+		local->hw.wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;
+	}
+
+	/*
+	 * If the driver supports any scan IEs, then assume the
+	 * limit includes the IEs mac80211 will add, otherwise
+	 * leave it at zero and let the driver sort it out; we
+	 * still pass our IEs to the driver but userspace will
+	 * not be allowed to in that case.
+	 */
+	if (local->hw.wiphy->max_scan_ie_len)
+		local->hw.wiphy->max_scan_ie_len -= local->scan_ies_len;
+
+	/* Set up cipher suites unless driver already did */
+	WARN_ON(!ieee80211_cs_list_valid(local->hw.cipher_schemes,
+					 local->hw.n_cipher_schemes));
+
+	result = ieee80211_init_cipher_suites(local);
+	if (result < 0)
+		goto fail_wiphy_register;
+
+	if (!local->ops->remain_on_channel)
+		local->hw.wiphy->max_remain_on_channel_duration = 5000;
+
+	/* mac80211 based drivers don't support internal TDLS setup */
+	if (local->hw.wiphy->flags & WIPHY_FLAG_SUPPORTS_TDLS)
+		local->hw.wiphy->flags |= WIPHY_FLAG_TDLS_EXTERNAL_SETUP;
+
+	result = wiphy_register(local->hw.wiphy);
+	if (result < 0)
+		goto fail_wiphy_register;
+
+	/*
+	 * We use the number of queues for feature tests (QoS, HT) internally
+	 * so restrict them appropriately.
+	 */
+	if (hw->queues > IEEE80211_MAX_QUEUES)
+		hw->queues = IEEE80211_MAX_QUEUES;
+
+	local->workqueue =
+		alloc_ordered_workqueue(wiphy_name(local->hw.wiphy), 0);
+	if (!local->workqueue) {
+		result = -ENOMEM;
+		goto fail_workqueue;
+	}
+
+	/*
+	 * The hardware needs headroom for sending the frame,
+	 * and we need some headroom for passing the frame to monitor
+	 * interfaces, but never both at the same time.
+	 */
+	local->tx_headroom = max_t(unsigned int, local->hw.extra_tx_headroom,
+				   IEEE80211_TX_STATUS_HEADROOM);
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	xrmac_debugfs_hw_add(local);
+#endif /* CONFIG_XRMAC_DEBUGFS */
+	/*
+	 * if the driver doesn't specify a max listen interval we
+	 * use 5 which should be a safe default
+	 */
+	if (local->hw.max_listen_interval == 0)
+		local->hw.max_listen_interval = 5;
+
+	result = mac80211_wep_init(local);
+	if (result < 0)
+		wiphy_debug(local->hw.wiphy, "Failed to initialize wep: %d\n",
+			    result);
+
+	rtnl_lock();
+
+	result = mac80211_init_rate_ctrl_alg(local,
+					      hw->rate_control_algorithm);
+	if (result < 0) {
+		wiphy_debug(local->hw.wiphy,
+			    "Failed to initialize rate control algorithm\n");
+		goto fail_rate;
+	}
+
+	/* add one default STA interface if supported */
+	if (local->hw.wiphy->interface_modes & BIT(NL80211_IFTYPE_STATION)) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+		result = mac80211_if_add(local, "wlan%d", NET_NAME_ENUM, NULL,
+					  NL80211_IFTYPE_STATION, NULL);
+#else
+		result = mac80211_if_add(local, "wlan%d", NULL,
+					  NL80211_IFTYPE_STATION, NULL);
+#endif
+		if (result)
+			wiphy_warn(local->hw.wiphy,
+				   "Failed to add default virtual iface\n");
+#ifdef OLD_P2P_MODE
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+		result = mac80211_if_add(local, "p2p%d", NET_NAME_ENUM, NULL,
+							  NL80211_IFTYPE_STATION, NULL);
+#else
+		result = mac80211_if_add(local, "p2p%d", NULL,
+					  NL80211_IFTYPE_STATION, NULL);
+#endif
+		if (result)
+			wiphy_warn(local->hw.wiphy,
+				   "Failed to add default virtual p2p iface\n");
+#endif
+
+	}
+
+	rtnl_unlock();
+
+	ieee80211_led_init(local);
+
+	local->network_latency_notifier.notifier_call =
+		mac80211_max_network_latency;
+	result = xr_pm_qos_add_notifier(PM_QOS_NETWORK_LATENCY,
+				     &local->network_latency_notifier);
+	if (result) {
+		rtnl_lock();
+		goto fail_pm_qos;
+	}
+
+#ifdef CONFIG_INET
+	local->ifa_notifier.notifier_call = ieee80211_ifa_changed;
+	result = register_inetaddr_notifier(&local->ifa_notifier);
+	if (result)
+		goto fail_ifa;
+
+#ifdef IPV6_FILTERING
+	local->ifa6_notifier.notifier_call = ieee80211_ifa6_changed;
+	result = register_inet6addr_notifier(&local->ifa6_notifier);
+	if (result)
+		goto fail_ifa;
+#endif /*IPV6_FILTERING*/
+#endif
+
+	return 0;
+
+#ifdef CONFIG_INET
+ fail_ifa:
+	xr_pm_qos_remove_notifier(PM_QOS_NETWORK_LATENCY,
+			       &local->network_latency_notifier);
+	rtnl_lock();
+#endif
+ fail_pm_qos:
+	ieee80211_led_exit(local);
+	mac80211_remove_interfaces(local);
+ fail_rate:
+	rtnl_unlock();
+	xrmac_sta_info_stop(local);
+	destroy_workqueue(local->workqueue);
+ fail_workqueue:
+	wiphy_unregister(local->hw.wiphy);
+ fail_wiphy_register:
+	if (local->wiphy_ciphers_allocated)
+		kfree(local->hw.wiphy->cipher_suites);
+	kfree(local->int_scan_req);
+	return result;
+}
+
+void mac80211_unregister_hw(struct ieee80211_hw *hw)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+
+	tasklet_kill(&local->tx_pending_tasklet);
+	tasklet_kill(&local->tasklet);
+
+	xr_pm_qos_remove_notifier(PM_QOS_NETWORK_LATENCY,
+			       &local->network_latency_notifier);
+#ifdef CONFIG_INET
+	unregister_inetaddr_notifier(&local->ifa_notifier);
+#ifdef IPV6_FILTERING
+	unregister_inet6addr_notifier(&local->ifa6_notifier);
+#endif /*IPV6_FILTERING*/
+#endif
+
+	rtnl_lock();
+
+	/*
+	 * At this point, interface list manipulations are fine
+	 * because the driver cannot be handing us frames any
+	 * more and the tasklet is killed.
+	 */
+	mac80211_remove_interfaces(local);
+
+	rtnl_unlock();
+
+	/*
+	 * Now all work items will be gone, but the
+	 * timer might still be armed, so delete it
+	 */
+	del_timer_sync(&local->work_timer);
+
+	cancel_work_sync(&local->restart_work);
+
+#ifdef IPV6_FILTERING
+#ifdef CONFIG_INET
+	cancel_work_sync(&local->ifa6_changed_work);
+#endif
+#endif /*IPV6_FILTERING*/
+
+	mac80211_clear_tx_pending(local);
+	xrmac_rate_control_deinitialize(local);
+
+	if (skb_queue_len(&local->skb_queue) ||
+	    skb_queue_len(&local->skb_queue_unreliable))
+		wiphy_warn(local->hw.wiphy, "skb_queue not empty\n");
+	skb_queue_purge(&local->skb_queue);
+	skb_queue_purge(&local->skb_queue_unreliable);
+	skb_queue_purge(&local->rx_skb_queue);
+
+#ifdef CONFIG_XRMAC_XR_ROAMING_CHANGES
+	/*
+	 * Work can also be sheduled in call_rcu callback.
+	 * Wait for all rcu callbacks to finish.
+	 */
+	rcu_barrier();
+#endif
+	destroy_workqueue(local->workqueue);
+	wiphy_unregister(local->hw.wiphy);
+	xrmac_sta_info_stop(local);
+	ieee80211_led_exit(local);
+	kfree(local->int_scan_req);
+}
+
+void mac80211_free_hw(struct ieee80211_hw *hw)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+
+	mutex_destroy(&local->iflist_mtx);
+	mutex_destroy(&local->mtx);
+
+	if (local->wiphy_ciphers_allocated)
+		kfree(local->hw.wiphy->cipher_suites);
+
+	wiphy_free(local->hw.wiphy);
+}
+
+int __init ieee80211_init(void)
+{
+	struct sk_buff *skb;
+	int ret;
+
+	BUILD_BUG_ON(sizeof(struct ieee80211_tx_info) > sizeof(skb->cb));
+	BUILD_BUG_ON(offsetof(struct ieee80211_tx_info, driver_data) +
+		     IEEE80211_TX_INFO_DRIVER_DATA_SIZE > sizeof(skb->cb));
+
+	ret = xrmac_rc80211_minstrel_init();
+	if (ret)
+		return ret;
+
+	ret = xrmac_rc80211_minstrel_ht_init();
+	if (ret)
+		goto err_minstrel;
+
+	ret = xrmac_rc80211_pid_init();
+	if (ret)
+		goto err_pid;
+
+	ret = mac80211_iface_init();
+	if (ret)
+		goto err_netdev;
+
+	return 0;
+ err_netdev:
+	xrmac_rc80211_pid_exit();
+ err_pid:
+	xrmac_rc80211_minstrel_ht_exit();
+ err_minstrel:
+	xrmac_rc80211_minstrel_exit();
+
+	return ret;
+}
+
+void ieee80211_exit(void)
+{
+	xrmac_rc80211_pid_exit();
+	xrmac_rc80211_minstrel_ht_exit();
+	xrmac_rc80211_minstrel_exit();
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
+	flush_scheduled_work();
+#endif
+
+	if (xrmac_mesh_allocated)
+		mac80211s_stop();
+
+	mac80211_iface_exit();
+
+	rcu_barrier();
+}
+
+MODULE_DESCRIPTION("IEEE 802.11 subsystem");
+MODULE_LICENSE("GPL");
diff -Naurp a/drivers/net/wireless/xr829/umac/mesh.c b/drivers/net/wireless/xr829/umac/mesh.c
--- a/drivers/net/wireless/xr829/umac/mesh.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/mesh.c	2022-08-27 01:22:42.946539832 +0300
@@ -0,0 +1,712 @@
+/*
+ * Copyright (c) 2008, 2009 open80211s Ltd.
+ * Authors:    Luis Carlos Cobo <luisca@cozybit.com>
+ * 	       Javier Cardona <javier@cozybit.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/slab.h>
+#include <asm/unaligned.h>
+#include "ieee80211_i.h"
+#include "mesh.h"
+
+#define MESHCONF_CAPAB_ACCEPT_PLINKS 0x01
+#define MESHCONF_CAPAB_FORWARDING    0x08
+
+#define TMR_RUNNING_HK	0
+#define TMR_RUNNING_MP	1
+#define TMR_RUNNING_MPR	2
+
+int xrmac_mesh_allocated;
+static struct kmem_cache *rm_cache;
+
+#ifdef CONFIG_XRMAC_MESH
+bool xrmac_mesh_action_is_path_sel(struct ieee80211_mgmt *mgmt)
+{
+	return (mgmt->u.action.u.mesh_action.action_code ==
+			WLAN_MESH_ACTION_HWMP_PATH_SELECTION);
+}
+#else
+bool xrmac_mesh_action_is_path_sel(struct ieee80211_mgmt *mgmt)
+{ return false; }
+#endif
+
+void mac80211s_init(void)
+{
+	xrmac_mesh_pathtbl_init();
+	xrmac_mesh_allocated = 1;
+	rm_cache = kmem_cache_create("mesh_rmc", sizeof(struct rmc_entry),
+				     0, 0, NULL);
+}
+
+void mac80211s_stop(void)
+{
+	xrmac_mesh_pathtbl_unregister();
+	kmem_cache_destroy(rm_cache);
+}
+
+static void ieee80211_mesh_housekeeping_timer(unsigned long data)
+{
+	struct ieee80211_sub_if_data *sdata = (void *) data;
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+
+	set_bit(MESH_WORK_HOUSEKEEPING, &ifmsh->wrkq_flags);
+
+	if (local->quiescing) {
+		set_bit(TMR_RUNNING_HK, &ifmsh->timers_running);
+		return;
+	}
+
+	mac80211_queue_work(&local->hw, &sdata->work);
+}
+
+/**
+ * xrmac_mesh_matches_local - check if the config of a mesh point matches ours
+ *
+ * @ie: information elements of a management frame from the mesh peer
+ * @sdata: local mesh subif
+ *
+ * This function checks if the mesh configuration of a mesh point matches the
+ * local mesh configuration, i.e. if both nodes belong to the same mesh network.
+ */
+bool xrmac_mesh_matches_local(struct ieee802_11_elems *ie, struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+
+	/*
+	 * As support for each feature is added, check for matching
+	 * - On mesh config capabilities
+	 *   - Power Save Support En
+	 *   - Sync support enabled
+	 *   - Sync support active
+	 *   - Sync support required from peer
+	 *   - MDA enabled
+	 * - Power management control on fc
+	 */
+	if (ifmsh->mesh_id_len == ie->mesh_id_len &&
+		memcmp(ifmsh->mesh_id, ie->mesh_id, ie->mesh_id_len) == 0 &&
+		(ifmsh->mesh_pp_id == ie->mesh_config->meshconf_psel) &&
+		(ifmsh->mesh_pm_id == ie->mesh_config->meshconf_pmetric) &&
+		(ifmsh->mesh_cc_id == ie->mesh_config->meshconf_congest) &&
+		(ifmsh->mesh_sp_id == ie->mesh_config->meshconf_synch) &&
+		(ifmsh->mesh_auth_id == ie->mesh_config->meshconf_auth))
+		return true;
+
+	return false;
+}
+
+/**
+ * xrmac_mesh_peer_accepts_plinks - check if an mp is willing to establish peer links
+ *
+ * @ie: information elements of a management frame from the mesh peer
+ */
+bool xrmac_mesh_peer_accepts_plinks(struct ieee802_11_elems *ie)
+{
+	return (ie->mesh_config->meshconf_cap &
+	    MESHCONF_CAPAB_ACCEPT_PLINKS) != 0;
+}
+
+/**
+ * xrmac_mesh_accept_plinks_update: update accepting_plink in local mesh beacons
+ *
+ * @sdata: mesh interface in which mesh beacons are going to be updated
+ */
+void xrmac_mesh_accept_plinks_update(struct ieee80211_sub_if_data *sdata)
+{
+	bool free_plinks;
+
+	/* In case mesh_plink_free_count > 0 and mesh_plinktbl_capacity == 0,
+	 * the mesh interface might be able to establish plinks with peers that
+	 * are already on the table but are not on PLINK_ESTAB state. However,
+	 * in general the mesh interface is not accepting peer link requests
+	 * from new peers, and that must be reflected in the beacon
+	 */
+	free_plinks = mesh_plink_availables(sdata);
+
+	if (free_plinks != sdata->u.mesh.accepting_plinks)
+		ieee80211_mesh_housekeeping_timer((unsigned long) sdata);
+}
+
+int xrmac_mesh_rmc_init(struct ieee80211_sub_if_data *sdata)
+{
+	int i;
+
+	sdata->u.mesh.rmc = kmalloc(sizeof(struct mesh_rmc), GFP_KERNEL);
+	if (!sdata->u.mesh.rmc)
+		return -ENOMEM;
+	sdata->u.mesh.rmc->idx_mask = RMC_BUCKETS - 1;
+	for (i = 0; i < RMC_BUCKETS; i++)
+		INIT_LIST_HEAD(&sdata->u.mesh.rmc->bucket[i].list);
+	return 0;
+}
+
+void xrmac_mesh_rmc_free(struct ieee80211_sub_if_data *sdata)
+{
+	struct mesh_rmc *rmc = sdata->u.mesh.rmc;
+	struct rmc_entry *p, *n;
+	int i;
+
+	if (!sdata->u.mesh.rmc)
+		return;
+
+	for (i = 0; i < RMC_BUCKETS; i++)
+		list_for_each_entry_safe(p, n, &rmc->bucket[i].list, list) {
+			list_del(&p->list);
+			kmem_cache_free(rm_cache, p);
+		}
+
+	kfree(rmc);
+	sdata->u.mesh.rmc = NULL;
+}
+
+/**
+ * xrmac_mesh_rmc_check - Check frame in recent multicast cache and add if absent.
+ *
+ * @sa:		source address
+ * @mesh_hdr:	mesh_header
+ *
+ * Returns: 0 if the frame is not in the cache, nonzero otherwise.
+ *
+ * Checks using the source address and the mesh sequence number if we have
+ * received this frame lately. If the frame is not in the cache, it is added to
+ * it.
+ */
+int xrmac_mesh_rmc_check(u8 *sa, struct ieee80211s_hdr *mesh_hdr,
+		   struct ieee80211_sub_if_data *sdata)
+{
+	struct mesh_rmc *rmc = sdata->u.mesh.rmc;
+	u32 seqnum = 0;
+	int entries = 0;
+	u8 idx;
+	struct rmc_entry *p, *n;
+
+	/* Don't care about endianness since only match matters */
+	memcpy(&seqnum, &mesh_hdr->seqnum, sizeof(mesh_hdr->seqnum));
+	idx = le32_to_cpu(mesh_hdr->seqnum) & rmc->idx_mask;
+	list_for_each_entry_safe(p, n, &rmc->bucket[idx].list, list) {
+		++entries;
+		if (time_after(jiffies, p->exp_time) ||
+				(entries == RMC_QUEUE_MAX_LEN)) {
+			list_del(&p->list);
+			kmem_cache_free(rm_cache, p);
+			--entries;
+		} else if ((seqnum == p->seqnum) &&
+			   (memcmp(sa, p->sa, ETH_ALEN) == 0))
+			return -1;
+	}
+
+	p = kmem_cache_alloc(rm_cache, GFP_ATOMIC);
+	if (!p)
+		return 0;
+
+	p->seqnum = seqnum;
+	p->exp_time = jiffies + RMC_TIMEOUT;
+	memcpy(p->sa, sa, ETH_ALEN);
+	list_add(&p->list, &rmc->bucket[idx].list);
+	return 0;
+}
+
+int
+xrmac_mesh_add_meshconf_ie(struct sk_buff *skb, struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+	u8 *pos, neighbors;
+	u8 meshconf_len = sizeof(struct ieee80211_meshconf_ie);
+
+	if (skb_tailroom(skb) < 2 + meshconf_len)
+		return -ENOMEM;
+
+	pos = skb_put(skb, 2 + meshconf_len);
+	*pos++ = WLAN_EID_MESH_CONFIG;
+	*pos++ = meshconf_len;
+
+	/* Active path selection protocol ID */
+	*pos++ = ifmsh->mesh_pp_id;
+	/* Active path selection metric ID   */
+	*pos++ = ifmsh->mesh_pm_id;
+	/* Congestion control mode identifier */
+	*pos++ = ifmsh->mesh_cc_id;
+	/* Synchronization protocol identifier */
+	*pos++ = ifmsh->mesh_sp_id;
+	/* Authentication Protocol identifier */
+	*pos++ = ifmsh->mesh_auth_id;
+	/* Mesh Formation Info - number of neighbors */
+	neighbors = atomic_read(&ifmsh->mshstats.estab_plinks);
+	/* Number of neighbor mesh STAs or 15 whichever is smaller */
+	neighbors = (neighbors > 15) ? 15 : neighbors;
+	*pos++ = neighbors << 1;
+	/* Mesh capability */
+	ifmsh->accepting_plinks = mesh_plink_availables(sdata);
+	*pos = MESHCONF_CAPAB_FORWARDING;
+	*pos++ |= ifmsh->accepting_plinks ?
+	    MESHCONF_CAPAB_ACCEPT_PLINKS : 0x00;
+	*pos++ = 0x00;
+
+	return 0;
+}
+
+int
+xrmac_mesh_add_meshid_ie(struct sk_buff *skb, struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+	u8 *pos;
+
+	if (skb_tailroom(skb) < 2 + ifmsh->mesh_id_len)
+		return -ENOMEM;
+
+	pos = skb_put(skb, 2 + ifmsh->mesh_id_len);
+	*pos++ = WLAN_EID_MESH_ID;
+	*pos++ = ifmsh->mesh_id_len;
+	if (ifmsh->mesh_id_len)
+		memcpy(pos, ifmsh->mesh_id, ifmsh->mesh_id_len);
+
+	return 0;
+}
+
+int
+xrmac_mesh_add_vendor_ies(struct sk_buff *skb, struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+	u8 offset, len;
+	const u8 *data;
+
+	if (!ifmsh->ie || !ifmsh->ie_len)
+		return 0;
+
+	/* fast-forward to vendor IEs */
+	offset = mac80211_ie_split_vendor(ifmsh->ie, ifmsh->ie_len, 0);
+
+	if (offset) {
+		len = ifmsh->ie_len - offset;
+		data = ifmsh->ie + offset;
+		if (skb_tailroom(skb) < len)
+			return -ENOMEM;
+		memcpy(skb_put(skb, len), data, len);
+	}
+
+	return 0;
+}
+
+int
+xrmac_mesh_add_rsn_ie(struct sk_buff *skb, struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+	u8 len = 0;
+	const u8 *data;
+
+	if (!ifmsh->ie || !ifmsh->ie_len)
+		return 0;
+
+	/* find RSN IE */
+	data = ifmsh->ie;
+	while (data < ifmsh->ie + ifmsh->ie_len) {
+		if (*data == WLAN_EID_RSN) {
+			len = data[1] + 2;
+			break;
+		}
+		data++;
+	}
+
+	if (len) {
+		if (skb_tailroom(skb) < len)
+			return -ENOMEM;
+		memcpy(skb_put(skb, len), data, len);
+	}
+
+	return 0;
+}
+
+int xrmac_mesh_add_ds_params_ie(struct sk_buff *skb,
+			  struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sdata);
+	struct ieee80211_supported_band *sband;
+	u8 *pos;
+
+	if (skb_tailroom(skb) < 3)
+		return -ENOMEM;
+
+	sband = local->hw.wiphy->bands[chan_state->conf.channel->band];
+	if (sband->band == NL80211_BAND_2GHZ) {
+		pos = skb_put(skb, 2 + 1);
+		*pos++ = WLAN_EID_DS_PARAMS;
+		*pos++ = 1;
+		*pos++ = ieee80211_frequency_to_channel(chan_state->conf.channel->center_freq);
+	}
+
+	return 0;
+}
+
+static void ieee80211_xrmac_mesh_path_timer(unsigned long data)
+{
+	struct ieee80211_sub_if_data *sdata =
+		(struct ieee80211_sub_if_data *) data;
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+	struct ieee80211_local *local = sdata->local;
+
+	if (local->quiescing) {
+		set_bit(TMR_RUNNING_MP, &ifmsh->timers_running);
+		return;
+	}
+
+	mac80211_queue_work(&local->hw, &sdata->work);
+}
+
+static void ieee80211_mesh_path_root_timer(unsigned long data)
+{
+	struct ieee80211_sub_if_data *sdata =
+		(struct ieee80211_sub_if_data *) data;
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+	struct ieee80211_local *local = sdata->local;
+
+	set_bit(MESH_WORK_ROOT, &ifmsh->wrkq_flags);
+
+	if (local->quiescing) {
+		set_bit(TMR_RUNNING_MPR, &ifmsh->timers_running);
+		return;
+	}
+
+	mac80211_queue_work(&local->hw, &sdata->work);
+}
+
+void mac80211_mesh_root_setup(struct ieee80211_if_mesh *ifmsh)
+{
+	if (ifmsh->mshcfg.dot11MeshHWMPRootMode)
+		set_bit(MESH_WORK_ROOT, &ifmsh->wrkq_flags);
+	else {
+		clear_bit(MESH_WORK_ROOT, &ifmsh->wrkq_flags);
+		/* stop running timer */
+		del_timer_sync(&ifmsh->mesh_path_root_timer);
+	}
+}
+
+/**
+ * mac80211_fill_mesh_addresses - fill addresses of a locally originated mesh frame
+ * @hdr:    	802.11 frame header
+ * @fc:		frame control field
+ * @meshda:	destination address in the mesh
+ * @meshsa:	source address address in the mesh.  Same as TA, as frame is
+ *              locally originated.
+ *
+ * Return the length of the 802.11 (does not include a mesh control header)
+ */
+int mac80211_fill_mesh_addresses(struct ieee80211_hdr *hdr, __le16 *fc,
+				  const u8 *meshda, const u8 *meshsa)
+{
+	if (is_multicast_ether_addr(meshda)) {
+		*fc |= cpu_to_le16(IEEE80211_FCTL_FROMDS);
+		/* DA TA SA */
+		memcpy(hdr->addr1, meshda, ETH_ALEN);
+		memcpy(hdr->addr2, meshsa, ETH_ALEN);
+		memcpy(hdr->addr3, meshsa, ETH_ALEN);
+		return 24;
+	} else {
+		*fc |= cpu_to_le16(IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS);
+		/* RA TA DA SA */
+		memset(hdr->addr1, 0, ETH_ALEN);   /* RA is resolved later */
+		memcpy(hdr->addr2, meshsa, ETH_ALEN);
+		memcpy(hdr->addr3, meshda, ETH_ALEN);
+		memcpy(hdr->addr4, meshsa, ETH_ALEN);
+		return 30;
+	}
+}
+
+/**
+ * mac80211_new_mesh_header - create a new mesh header
+ * @meshhdr:    uninitialized mesh header
+ * @sdata:	mesh interface to be used
+ * @addr4or5:   1st address in the ae header, which may correspond to address 4
+ *              (if addr6 is NULL) or address 5 (if addr6 is present). It may
+ *              be NULL.
+ * @addr6:	2nd address in the ae header, which corresponds to addr6 of the
+ *              mesh frame
+ *
+ * Return the header length.
+ */
+int mac80211_new_mesh_header(struct ieee80211s_hdr *meshhdr,
+		struct ieee80211_sub_if_data *sdata, char *addr4or5,
+		char *addr6)
+{
+	int aelen = 0;
+	BUG_ON(!addr4or5 && addr6);
+	memset(meshhdr, 0, sizeof(*meshhdr));
+	meshhdr->ttl = sdata->u.mesh.mshcfg.dot11MeshTTL;
+	put_unaligned(cpu_to_le32(sdata->u.mesh.mesh_seqnum), &meshhdr->seqnum);
+	sdata->u.mesh.mesh_seqnum++;
+	if (addr4or5 && !addr6) {
+		meshhdr->flags |= MESH_FLAGS_AE_A4;
+		aelen += ETH_ALEN;
+		memcpy(meshhdr->eaddr1, addr4or5, ETH_ALEN);
+	} else if (addr4or5 && addr6) {
+		meshhdr->flags |= MESH_FLAGS_AE_A5_A6;
+		aelen += 2 * ETH_ALEN;
+		memcpy(meshhdr->eaddr1, addr4or5, ETH_ALEN);
+		memcpy(meshhdr->eaddr2, addr6, ETH_ALEN);
+	}
+	return 6 + aelen;
+}
+
+static void ieee80211_mesh_housekeeping(struct ieee80211_sub_if_data *sdata,
+			   struct ieee80211_if_mesh *ifmsh)
+{
+	bool free_plinks;
+
+#ifdef CONFIG_XRMAC_VERBOSE_DEBUG
+	printk(KERN_DEBUG "%s: running mesh housekeeping\n",
+	       sdata->name);
+#endif
+
+	mac80211_sta_expire(sdata, IEEE80211_MESH_PEER_INACTIVITY_LIMIT);
+	xrmac_mesh_path_expire(sdata);
+
+	free_plinks = mesh_plink_availables(sdata);
+	if (free_plinks != sdata->u.mesh.accepting_plinks)
+		mac80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON);
+
+	mod_timer(&ifmsh->housekeeping_timer,
+		  round_jiffies(jiffies + IEEE80211_MESH_HOUSEKEEPING_INTERVAL));
+}
+
+static void ieee80211_mesh_rootpath(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+
+	xrmac_mesh_path_tx_root_frame(sdata);
+	mod_timer(&ifmsh->mesh_path_root_timer,
+		  round_jiffies(TU_TO_EXP_TIME(
+				  ifmsh->mshcfg.dot11MeshHWMPRannInterval)));
+}
+
+#ifdef CONFIG_PM
+void mac80211_mesh_quiesce(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+
+	/* use atomic bitops in case all timers fire at the same time */
+
+	if (del_timer_sync(&ifmsh->housekeeping_timer))
+		set_bit(TMR_RUNNING_HK, &ifmsh->timers_running);
+	if (del_timer_sync(&ifmsh->xrmac_mesh_path_timer))
+		set_bit(TMR_RUNNING_MP, &ifmsh->timers_running);
+	if (del_timer_sync(&ifmsh->mesh_path_root_timer))
+		set_bit(TMR_RUNNING_MPR, &ifmsh->timers_running);
+}
+
+void mac80211_mesh_restart(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+
+	if (test_and_clear_bit(TMR_RUNNING_HK, &ifmsh->timers_running))
+		add_timer(&ifmsh->housekeeping_timer);
+	if (test_and_clear_bit(TMR_RUNNING_MP, &ifmsh->timers_running))
+		add_timer(&ifmsh->xrmac_mesh_path_timer);
+	if (test_and_clear_bit(TMR_RUNNING_MPR, &ifmsh->timers_running))
+		add_timer(&ifmsh->mesh_path_root_timer);
+	mac80211_mesh_root_setup(ifmsh);
+}
+#endif
+
+void mac80211_start_mesh(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+	struct ieee80211_local *local = sdata->local;
+
+	sdata->req_filt_flags |= FIF_OTHER_BSS;
+	/* mesh ifaces must set allmulti to forward mcast traffic */
+	sdata->flags |= IEEE80211_SDATA_ALLMULTI;
+	mac80211_configure_filter(sdata);
+
+	ifmsh->mesh_cc_id = 0;	/* Disabled */
+	ifmsh->mesh_sp_id = 0;	/* Neighbor Offset */
+	ifmsh->mesh_auth_id = 0;	/* Disabled */
+	set_bit(MESH_WORK_HOUSEKEEPING, &ifmsh->wrkq_flags);
+	mac80211_mesh_root_setup(ifmsh);
+	mac80211_queue_work(&local->hw, &sdata->work);
+	sdata->vif.bss_conf.beacon_int = MESH_DEFAULT_BEACON_INTERVAL;
+	mac80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON |
+						BSS_CHANGED_BEACON_ENABLED |
+						BSS_CHANGED_BEACON_INT);
+}
+
+void mac80211_stop_mesh(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+
+	ifmsh->mesh_id_len = 0;
+	mac80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON_ENABLED);
+	xrmac_sta_info_flush(local, NULL);
+
+	del_timer_sync(&sdata->u.mesh.housekeeping_timer);
+	del_timer_sync(&sdata->u.mesh.mesh_path_root_timer);
+	/*
+	 * If the timer fired while we waited for it, it will have
+	 * requeued the work. Now the work will be running again
+	 * but will not rearm the timer again because it checks
+	 * whether the interface is running, which, at this point,
+	 * it no longer is.
+	 */
+	cancel_work_sync(&sdata->work);
+
+	sdata->req_filt_flags &= ~(FIF_OTHER_BSS);
+	sdata->flags &= ~IEEE80211_SDATA_ALLMULTI;
+	mac80211_configure_filter(sdata);
+}
+
+static void ieee80211_mesh_rx_bcn_presp(struct ieee80211_sub_if_data *sdata,
+					u16 stype,
+					struct ieee80211_mgmt *mgmt,
+					size_t len,
+					struct ieee80211_rx_status *rx_status)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee802_11_elems elems;
+	struct ieee80211_channel *channel;
+	u32 supp_rates = 0;
+	size_t baselen;
+	int freq;
+	enum nl80211_band band = rx_status->band;
+
+	/* ignore ProbeResp to foreign address */
+	if (stype == IEEE80211_STYPE_PROBE_RESP &&
+	    compare_ether_addr(mgmt->da, sdata->vif.addr))
+		return;
+
+	baselen = (u8 *) mgmt->u.probe_resp.variable - (u8 *) mgmt;
+	if (baselen > len)
+		return;
+
+	mac802_11_parse_elems(mgmt->u.probe_resp.variable, len - baselen,
+			       &elems);
+
+	/* ignore beacons from secure mesh peers if our security is off */
+	if (elems.rsn_len && sdata->u.mesh.security == IEEE80211_MESH_SEC_NONE)
+		return;
+
+	if (elems.ds_params && elems.ds_params_len == 1)
+		freq = ieee80211_channel_to_frequency(elems.ds_params[0], band);
+	else
+		freq = rx_status->freq;
+
+	channel = ieee80211_get_channel(local->hw.wiphy, freq);
+
+	if (!channel || channel->flags & IEEE80211_CHAN_DISABLED)
+		return;
+
+	if (elems.mesh_id && elems.mesh_config &&
+	    xrmac_mesh_matches_local(&elems, sdata)) {
+		supp_rates = mac80211_sta_get_rates(local, &elems, band);
+		xrmac_mesh_neighbour_update(mgmt->sa, supp_rates, sdata, &elems);
+	}
+}
+
+static void ieee80211_mesh_rx_mgmt_action(struct ieee80211_sub_if_data *sdata,
+					  struct ieee80211_mgmt *mgmt,
+					  size_t len,
+					  struct ieee80211_rx_status *rx_status)
+{
+	switch (mgmt->u.action.category) {
+	case WLAN_CATEGORY_SELF_PROTECTED:
+		switch (mgmt->u.action.u.self_prot.action_code) {
+		case WLAN_SP_MESH_PEERING_OPEN:
+		case WLAN_SP_MESH_PEERING_CLOSE:
+		case WLAN_SP_MESH_PEERING_CONFIRM:
+			xrmac_mesh_rx_plink_frame(sdata, mgmt, len, rx_status);
+			break;
+		}
+		break;
+	case WLAN_CATEGORY_MESH_ACTION:
+		if (xrmac_mesh_action_is_path_sel(mgmt))
+			xrmac_mesh_rx_path_sel_frame(sdata, mgmt, len);
+		break;
+	}
+}
+
+void mac80211_mesh_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,
+				   struct sk_buff *skb)
+{
+	struct ieee80211_rx_status *rx_status;
+	struct ieee80211_mgmt *mgmt;
+	u16 stype;
+
+	rx_status = IEEE80211_SKB_RXCB(skb);
+	mgmt = (struct ieee80211_mgmt *) skb->data;
+	stype = le16_to_cpu(mgmt->frame_control) & IEEE80211_FCTL_STYPE;
+
+	switch (stype) {
+	case IEEE80211_STYPE_PROBE_RESP:
+	case IEEE80211_STYPE_BEACON:
+		ieee80211_mesh_rx_bcn_presp(sdata, stype, mgmt, skb->len,
+					    rx_status);
+		break;
+	case IEEE80211_STYPE_ACTION:
+		ieee80211_mesh_rx_mgmt_action(sdata, mgmt, skb->len, rx_status);
+		break;
+	}
+}
+
+void mac80211_mesh_work(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+
+	if (ifmsh->preq_queue_len &&
+	    time_after(jiffies,
+		       ifmsh->last_preq + msecs_to_jiffies(ifmsh->mshcfg.dot11MeshHWMPpreqMinInterval)))
+		xrmac_mesh_path_start_discovery(sdata);
+
+	if (test_and_clear_bit(MESH_WORK_GROW_MPATH_TABLE, &ifmsh->wrkq_flags))
+		xrmac_mesh_mpath_table_grow();
+
+	if (test_and_clear_bit(MESH_WORK_GROW_MPP_TABLE, &ifmsh->wrkq_flags))
+		xrmac_mesh_mpp_table_grow();
+
+	if (test_and_clear_bit(MESH_WORK_HOUSEKEEPING, &ifmsh->wrkq_flags))
+		ieee80211_mesh_housekeeping(sdata, ifmsh);
+
+	if (test_and_clear_bit(MESH_WORK_ROOT, &ifmsh->wrkq_flags))
+		ieee80211_mesh_rootpath(sdata);
+}
+
+void mac80211_mesh_notify_scan_completed(struct ieee80211_local *local)
+{
+	struct ieee80211_sub_if_data *sdata;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(sdata, &local->interfaces, list)
+		if (ieee80211_vif_is_mesh(&sdata->vif))
+			mac80211_queue_work(&local->hw, &sdata->work);
+	rcu_read_unlock();
+}
+
+void mac80211_mesh_init_sdata(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+
+	setup_timer(&ifmsh->housekeeping_timer,
+		    ieee80211_mesh_housekeeping_timer,
+		    (unsigned long) sdata);
+
+	ifmsh->accepting_plinks = true;
+	ifmsh->preq_id = 0;
+	ifmsh->sn = 0;
+	ifmsh->num_gates = 0;
+	atomic_set(&ifmsh->mpaths, 0);
+	xrmac_mesh_rmc_init(sdata);
+	ifmsh->last_preq = jiffies;
+	/* Allocate all mesh structures when creating the first mesh interface. */
+	if (!xrmac_mesh_allocated)
+		mac80211s_init();
+	setup_timer(&ifmsh->xrmac_mesh_path_timer,
+		    ieee80211_xrmac_mesh_path_timer,
+		    (unsigned long) sdata);
+	setup_timer(&ifmsh->mesh_path_root_timer,
+		    ieee80211_mesh_path_root_timer,
+		    (unsigned long) sdata);
+	INIT_LIST_HEAD(&ifmsh->preq_queue.list);
+	spin_lock_init(&ifmsh->mesh_preq_queue_lock);
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/mesh.h b/drivers/net/wireless/xr829/umac/mesh.h
--- a/drivers/net/wireless/xr829/umac/mesh.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/mesh.h	2022-08-27 01:22:42.946539832 +0300
@@ -0,0 +1,330 @@
+/*
+ * Copyright (c) 2008, 2009 open80211s Ltd.
+ * Authors:    Luis Carlos Cobo <luisca@cozybit.com>
+ *             Javier Cardona <javier@cozybit.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef IEEE80211S_H
+#define IEEE80211S_H
+
+#include <linux/types.h>
+#include <linux/jhash.h>
+#include <asm/unaligned.h>
+#include "ieee80211_i.h"
+
+
+/* Data structures */
+
+/**
+ * enum mesh_path_flags - mac80211 mesh path flags
+ *
+ *
+ *
+ * @MESH_PATH_ACTIVE: the mesh path can be used for forwarding
+ * @MESH_PATH_RESOLVING: the discovery process is running for this mesh path
+ * @MESH_PATH_SN_VALID: the mesh path contains a valid destination sequence
+ * 	number
+ * @MESH_PATH_FIXED: the mesh path has been manually set and should not be
+ * 	modified
+ * @MESH_PATH_RESOLVED: the mesh path can has been resolved
+ *
+ * MESH_PATH_RESOLVED is used by the mesh path timer to
+ * decide when to stop or cancel the mesh path discovery.
+ */
+enum mesh_path_flags {
+	MESH_PATH_ACTIVE =	BIT(0),
+	MESH_PATH_RESOLVING =	BIT(1),
+	MESH_PATH_SN_VALID =	BIT(2),
+	MESH_PATH_FIXED	=	BIT(3),
+	MESH_PATH_RESOLVED =	BIT(4),
+};
+
+/**
+ * enum mesh_deferred_task_flags - mac80211 mesh deferred tasks
+ *
+ *
+ *
+ * @MESH_WORK_HOUSEKEEPING: run the periodic mesh housekeeping tasks
+ * @MESH_WORK_GROW_MPATH_TABLE: the mesh path table is full and needs
+ * to grow.
+ * @MESH_WORK_GROW_MPP_TABLE: the mesh portals table is full and needs to
+ * grow
+ * @MESH_WORK_ROOT: the mesh root station needs to send a frame
+ */
+enum mesh_deferred_task_flags {
+	MESH_WORK_HOUSEKEEPING,
+	MESH_WORK_GROW_MPATH_TABLE,
+	MESH_WORK_GROW_MPP_TABLE,
+	MESH_WORK_ROOT,
+};
+
+/**
+ * struct mesh_path - mac80211 mesh path structure
+ *
+ * @dst: mesh path destination mac address
+ * @sdata: mesh subif
+ * @next_hop: mesh neighbor to which frames for this destination will be
+ * 	forwarded
+ * @timer: mesh path discovery timer
+ * @frame_queue: pending queue for frames sent to this destination while the
+ * 	path is unresolved
+ * @sn: target sequence number
+ * @metric: current metric to this destination
+ * @hop_count: hops to destination
+ * @exp_time: in jiffies, when the path will expire or when it expired
+ * @discovery_timeout: timeout (lapse in jiffies) used for the last discovery
+ * 	retry
+ * @discovery_retries: number of discovery retries
+ * @flags: mesh path flags, as specified on &enum mesh_path_flags
+ * @state_lock: mesh path state lock used to protect changes to the
+ * mpath itself.  No need to take this lock when adding or removing
+ * an mpath to a hash bucket on a path table.
+ * @is_gate: the destination station of this path is a mesh gate
+ *
+ *
+ * The combination of dst and sdata is unique in the mesh path table. Since the
+ * next_hop STA is only protected by RCU as well, deleting the STA must also
+ * remove/substitute the mesh_path structure and wait until that is no longer
+ * reachable before destroying the STA completely.
+ */
+struct mesh_path {
+	u8 dst[ETH_ALEN];
+	u8 mpp[ETH_ALEN];	/* used for MPP or MAP */
+	struct ieee80211_sub_if_data *sdata;
+	struct sta_info __rcu *next_hop;
+	struct timer_list timer;
+	struct sk_buff_head frame_queue;
+	struct rcu_head rcu;
+	u32 sn;
+	u32 metric;
+	u8 hop_count;
+	unsigned long exp_time;
+	u32 discovery_timeout;
+	u8 discovery_retries;
+	enum mesh_path_flags flags;
+	spinlock_t state_lock;
+	bool is_gate;
+};
+
+/**
+ * struct mesh_table
+ *
+ * @hash_buckets: array of hash buckets of the table
+ * @hashwlock: array of locks to protect write operations, one per bucket
+ * @hash_mask: 2^size_order - 1, used to compute hash idx
+ * @hash_rnd: random value used for hash computations
+ * @entries: number of entries in the table
+ * @free_node: function to free nodes of the table
+ * @copy_node: function to copy nodes of the table
+ * @size_order: determines size of the table, there will be 2^size_order hash
+ *	buckets
+ * @mean_chain_len: maximum average length for the hash buckets' list, if it is
+ *	reached, the table will grow
+ * @known_gates: list of known mesh gates and their mpaths by the station. The
+ * gate's mpath may or may not be resolved and active.
+ *
+ * rcu_head: RCU head to free the table
+ */
+struct mesh_table {
+	/* Number of buckets will be 2^N */
+	struct hlist_head *hash_buckets;
+	spinlock_t *hashwlock;		/* One per bucket, for add/del */
+	unsigned int hash_mask;		/* (2^size_order) - 1 */
+	__u32 hash_rnd;			/* Used for hash generation */
+	atomic_t entries;		/* Up to MAX_MESH_NEIGHBOURS */
+	void (*free_node) (struct hlist_node *p, bool free_leafs);
+	int (*copy_node) (struct hlist_node *p, struct mesh_table *newtbl);
+	int size_order;
+	int mean_chain_len;
+	struct hlist_head *known_gates;
+	spinlock_t gates_lock;
+
+	struct rcu_head rcu_head;
+};
+
+/* Recent multicast cache */
+/* RMC_BUCKETS must be a power of 2, maximum 256 */
+#define RMC_BUCKETS		256
+#define RMC_QUEUE_MAX_LEN	4
+#define RMC_TIMEOUT		(3 * HZ)
+
+/**
+ * struct rmc_entry - entry in the Recent Multicast Cache
+ *
+ * @seqnum: mesh sequence number of the frame
+ * @exp_time: expiration time of the entry, in jiffies
+ * @sa: source address of the frame
+ *
+ * The Recent Multicast Cache keeps track of the latest multicast frames that
+ * have been received by a mesh interface and discards received multicast frames
+ * that are found in the cache.
+ */
+struct rmc_entry {
+	struct list_head list;
+	u32 seqnum;
+	unsigned long exp_time;
+	u8 sa[ETH_ALEN];
+};
+
+struct mesh_rmc {
+	struct rmc_entry bucket[RMC_BUCKETS];
+	u32 idx_mask;
+};
+
+#define IEEE80211_MESH_PEER_INACTIVITY_LIMIT (1800 * HZ)
+#define IEEE80211_MESH_HOUSEKEEPING_INTERVAL (60 * HZ)
+
+#define MESH_DEFAULT_BEACON_INTERVAL		1000 	/* in 1024 us units */
+
+#define MESH_PATH_EXPIRE (600 * HZ)
+
+/* Default maximum number of plinks per interface */
+#define MESH_MAX_PLINKS		256
+
+/* Maximum number of paths per interface */
+#define MESH_MAX_MPATHS		1024
+
+/* Public interfaces */
+/* Various */
+int mac80211_fill_mesh_addresses(struct ieee80211_hdr *hdr, __le16 *fc,
+				  const u8 *da, const u8 *sa);
+int mac80211_new_mesh_header(struct ieee80211s_hdr *meshhdr,
+		struct ieee80211_sub_if_data *sdata, char *addr4or5,
+		char *addr6);
+int xrmac_mesh_rmc_check(u8 *addr, struct ieee80211s_hdr *mesh_hdr,
+		struct ieee80211_sub_if_data *sdata);
+bool xrmac_mesh_matches_local(struct ieee802_11_elems *ie,
+		struct ieee80211_sub_if_data *sdata);
+void mesh_ids_set_default(struct ieee80211_if_mesh *mesh);
+void mesh_mgmt_ies_add(struct sk_buff *skb,
+		struct ieee80211_sub_if_data *sdata);
+int xrmac_mesh_add_meshconf_ie(struct sk_buff *skb,
+			 struct ieee80211_sub_if_data *sdata);
+int xrmac_mesh_add_meshid_ie(struct sk_buff *skb,
+		       struct ieee80211_sub_if_data *sdata);
+int xrmac_mesh_add_rsn_ie(struct sk_buff *skb,
+		    struct ieee80211_sub_if_data *sdata);
+int xrmac_mesh_add_vendor_ies(struct sk_buff *skb,
+			struct ieee80211_sub_if_data *sdata);
+int xrmac_mesh_add_ds_params_ie(struct sk_buff *skb,
+			  struct ieee80211_sub_if_data *sdata);
+void xrmac_mesh_rmc_free(struct ieee80211_sub_if_data *sdata);
+int xrmac_mesh_rmc_init(struct ieee80211_sub_if_data *sdata);
+void mac80211s_init(void);
+void mac80211s_update_metric(struct ieee80211_local *local,
+		struct sta_info *stainfo, struct sk_buff *skb);
+void mac80211s_stop(void);
+void mac80211_mesh_init_sdata(struct ieee80211_sub_if_data *sdata);
+void mac80211_start_mesh(struct ieee80211_sub_if_data *sdata);
+void mac80211_stop_mesh(struct ieee80211_sub_if_data *sdata);
+void mac80211_mesh_root_setup(struct ieee80211_if_mesh *ifmsh);
+
+/* Mesh paths */
+int xrmac_mesh_nexthop_lookup(struct sk_buff *skb,
+		struct ieee80211_sub_if_data *sdata);
+void xrmac_mesh_path_start_discovery(struct ieee80211_sub_if_data *sdata);
+struct mesh_path *xrmac_mesh_path_lookup(u8 *dst,
+		struct ieee80211_sub_if_data *sdata);
+struct mesh_path *xrmac_mpp_path_lookup(u8 *dst,
+				  struct ieee80211_sub_if_data *sdata);
+int xrmac_mpp_path_add(u8 *dst, u8 *mpp, struct ieee80211_sub_if_data *sdata);
+struct mesh_path *xrmac_mesh_path_lookup_by_idx(int idx,
+		struct ieee80211_sub_if_data *sdata);
+void xrmac_mesh_path_fix_nexthop(struct mesh_path *mpath, struct sta_info *next_hop);
+void xrmac_mesh_path_expire(struct ieee80211_sub_if_data *sdata);
+void xrmac_mesh_rx_path_sel_frame(struct ieee80211_sub_if_data *sdata,
+		struct ieee80211_mgmt *mgmt, size_t len);
+int xrmac_mesh_path_add(u8 *dst, struct ieee80211_sub_if_data *sdata);
+
+int xrmac_mesh_path_add_gate(struct mesh_path *mpath);
+int xrmac_mesh_path_send_to_gates(struct mesh_path *mpath);
+int xrmac_mesh_gate_num(struct ieee80211_sub_if_data *sdata);
+/* Mesh plinks */
+void xrmac_mesh_neighbour_update(u8 *hw_addr, u32 rates,
+		struct ieee80211_sub_if_data *sdata,
+		struct ieee802_11_elems *ie);
+bool xrmac_mesh_peer_accepts_plinks(struct ieee802_11_elems *ie);
+void xrmac_mesh_accept_plinks_update(struct ieee80211_sub_if_data *sdata);
+void xrmac_mesh_plink_broken(struct sta_info *sta);
+void xrmac_mesh_plink_deactivate(struct sta_info *sta);
+int xrmac_mesh_plink_open(struct sta_info *sta);
+void xrmac_mesh_plink_block(struct sta_info *sta);
+void xrmac_mesh_rx_plink_frame(struct ieee80211_sub_if_data *sdata,
+			 struct ieee80211_mgmt *mgmt, size_t len,
+			 struct ieee80211_rx_status *rx_status);
+
+/* Private interfaces */
+/* Mesh tables */
+void xrmac_mesh_mpath_table_grow(void);
+void xrmac_mesh_mpp_table_grow(void);
+/* Mesh paths */
+int xrmac_mesh_path_error_tx(u8 ttl, u8 *target, __le32 target_sn, __le16 target_rcode,
+		       const u8 *ra, struct ieee80211_sub_if_data *sdata);
+void xrmac_mesh_path_assign_nexthop(struct mesh_path *mpath, struct sta_info *sta);
+void xrmac_mesh_path_flush_pending(struct mesh_path *mpath);
+void xrmac_mesh_path_tx_pending(struct mesh_path *mpath);
+int xrmac_mesh_pathtbl_init(void);
+void xrmac_mesh_pathtbl_unregister(void);
+int xrmac_mesh_path_del(u8 *addr, struct ieee80211_sub_if_data *sdata);
+void xrmac_mesh_path_timer(unsigned long data);
+void xrmac_mesh_path_flush_by_nexthop(struct sta_info *sta);
+void xrmac_mesh_path_flush_by_iface(struct ieee80211_sub_if_data *sdata);
+void xrmac_mesh_path_discard_frame(struct sk_buff *skb,
+		struct ieee80211_sub_if_data *sdata);
+void mesh_path_quiesce(struct ieee80211_sub_if_data *sdata);
+void mesh_path_restart(struct ieee80211_sub_if_data *sdata);
+void xrmac_mesh_path_tx_root_frame(struct ieee80211_sub_if_data *sdata);
+
+bool xrmac_mesh_action_is_path_sel(struct ieee80211_mgmt *mgmt);
+extern int xrmac_mesh_paths_generation;
+
+#ifdef CONFIG_XRMAC_MESH
+extern int xrmac_mesh_allocated;
+
+static inline int mesh_plink_free_count(struct ieee80211_sub_if_data *sdata)
+{
+	return sdata->u.mesh.mshcfg.dot11MeshMaxPeerLinks -
+	       atomic_read(&sdata->u.mesh.mshstats.estab_plinks);
+}
+
+static inline bool mesh_plink_availables(struct ieee80211_sub_if_data *sdata)
+{
+	return (min_t(long, mesh_plink_free_count(sdata),
+		   MESH_MAX_PLINKS - sdata->local->num_sta)) > 0;
+}
+
+static inline void mesh_path_activate(struct mesh_path *mpath)
+{
+	mpath->flags |= MESH_PATH_ACTIVE | MESH_PATH_RESOLVED;
+}
+
+static inline bool mesh_path_sel_is_hwmp(struct ieee80211_sub_if_data *sdata)
+{
+	return sdata->u.mesh.mesh_pp_id == IEEE80211_PATH_PROTOCOL_HWMP;
+}
+
+void mac80211_mesh_notify_scan_completed(struct ieee80211_local *local);
+
+void mac80211_mesh_quiesce(struct ieee80211_sub_if_data *sdata);
+void mac80211_mesh_restart(struct ieee80211_sub_if_data *sdata);
+void xrmac_mesh_plink_quiesce(struct sta_info *sta);
+void xrmac_mesh_plink_restart(struct sta_info *sta);
+#else
+#define xrmac_mesh_allocated	0
+static inline void
+mac80211_mesh_notify_scan_completed(struct ieee80211_local *local) {}
+static inline void mac80211_mesh_quiesce(struct ieee80211_sub_if_data *sdata)
+{}
+static inline void mac80211_mesh_restart(struct ieee80211_sub_if_data *sdata)
+{}
+static inline void xrmac_mesh_plink_quiesce(struct sta_info *sta) {}
+static inline void xrmac_mesh_plink_restart(struct sta_info *sta) {}
+static inline bool mesh_path_sel_is_hwmp(struct ieee80211_sub_if_data *sdata)
+{ return false; }
+#endif
+
+#endif /* IEEE80211S_H */
diff -Naurp a/drivers/net/wireless/xr829/umac/mesh_hwmp.c b/drivers/net/wireless/xr829/umac/mesh_hwmp.c
--- a/drivers/net/wireless/xr829/umac/mesh_hwmp.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/mesh_hwmp.c	2022-08-27 01:22:42.946539832 +0300
@@ -0,0 +1,1094 @@
+/*
+ * Copyright (c) 2008, 2009 open80211s Ltd.
+ * Author:     Luis Carlos Cobo <luisca@cozybit.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/slab.h>
+#include "wme.h"
+#include "mesh.h"
+
+#ifdef CONFIG_XRMAC_VERBOSE_MHWMP_DEBUG
+#define mhwmp_dbg(fmt, args...) \
+	printk(KERN_DEBUG "Mesh HWMP (%s): " fmt "\n", sdata->name, ##args)
+#else
+#define mhwmp_dbg(fmt, args...)   do { (void)(0); } while (0)
+#endif
+
+#define TEST_FRAME_LEN	8192
+#define MAX_METRIC	0xffffffff
+#define ARITH_SHIFT	8
+
+/* Number of frames buffered per destination for unresolved destinations */
+#define MESH_FRAME_QUEUE_LEN	10
+#define MAX_PREQ_QUEUE_LEN	64
+
+/* Destination only */
+#define MP_F_DO	0x1
+/* Reply and forward */
+#define MP_F_RF	0x2
+/* Unknown Sequence Number */
+#define MP_F_USN    0x01
+/* Reason code Present */
+#define MP_F_RCODE  0x02
+
+static void mesh_queue_preq(struct mesh_path *, u8);
+
+static inline u32 u32_field_get(u8 *preq_elem, int offset, bool ae)
+{
+	if (ae)
+		offset += 6;
+	return get_unaligned_le32(preq_elem + offset);
+}
+
+static inline u32 u16_field_get(u8 *preq_elem, int offset, bool ae)
+{
+	if (ae)
+		offset += 6;
+	return get_unaligned_le16(preq_elem + offset);
+}
+
+/* HWMP IE processing macros */
+#define AE_F			(1<<6)
+#define AE_F_SET(x)		(*x & AE_F)
+#define PREQ_IE_FLAGS(x)	(*(x))
+#define PREQ_IE_HOPCOUNT(x)	(*(x + 1))
+#define PREQ_IE_TTL(x)		(*(x + 2))
+#define PREQ_IE_PREQ_ID(x)	u32_field_get(x, 3, 0)
+#define PREQ_IE_ORIG_ADDR(x)	(x + 7)
+#define PREQ_IE_ORIG_SN(x)	u32_field_get(x, 13, 0)
+#define PREQ_IE_LIFETIME(x)	u32_field_get(x, 17, AE_F_SET(x))
+#define PREQ_IE_METRIC(x) 	u32_field_get(x, 21, AE_F_SET(x))
+#define PREQ_IE_TARGET_F(x)	(*(AE_F_SET(x) ? x + 32 : x + 26))
+#define PREQ_IE_TARGET_ADDR(x) 	(AE_F_SET(x) ? x + 33 : x + 27)
+#define PREQ_IE_TARGET_SN(x) 	u32_field_get(x, 33, AE_F_SET(x))
+
+
+#define PREP_IE_FLAGS(x)	PREQ_IE_FLAGS(x)
+#define PREP_IE_HOPCOUNT(x)	PREQ_IE_HOPCOUNT(x)
+#define PREP_IE_TTL(x)		PREQ_IE_TTL(x)
+#define PREP_IE_ORIG_ADDR(x)	(AE_F_SET(x) ? x + 27 : x + 21)
+#define PREP_IE_ORIG_SN(x)	u32_field_get(x, 27, AE_F_SET(x))
+#define PREP_IE_LIFETIME(x)	u32_field_get(x, 13, AE_F_SET(x))
+#define PREP_IE_METRIC(x)	u32_field_get(x, 17, AE_F_SET(x))
+#define PREP_IE_TARGET_ADDR(x)	(x + 3)
+#define PREP_IE_TARGET_SN(x)	u32_field_get(x, 9, 0)
+
+#define PERR_IE_TTL(x)		(*(x))
+#define PERR_IE_TARGET_FLAGS(x)	(*(x + 2))
+#define PERR_IE_TARGET_ADDR(x)	(x + 3)
+#define PERR_IE_TARGET_SN(x)	u32_field_get(x, 9, 0)
+#define PERR_IE_TARGET_RCODE(x)	u16_field_get(x, 13, 0)
+
+#define MSEC_TO_TU(x) (x*1000/1024)
+#define SN_GT(x, y) ((long) (y) - (long) (x) < 0)
+#define SN_LT(x, y) ((long) (x) - (long) (y) < 0)
+
+#define net_traversal_jiffies(s) \
+	msecs_to_jiffies(s->u.mesh.mshcfg.dot11MeshHWMPnetDiameterTraversalTime)
+#define default_lifetime(s) \
+	MSEC_TO_TU(s->u.mesh.mshcfg.dot11MeshHWMPactivePathTimeout)
+#define min_preq_int_jiff(s) \
+	(msecs_to_jiffies(s->u.mesh.mshcfg.dot11MeshHWMPpreqMinInterval))
+#define max_preq_retries(s) (s->u.mesh.mshcfg.dot11MeshHWMPmaxPREQretries)
+#define disc_timeout_jiff(s) \
+	msecs_to_jiffies(sdata->u.mesh.mshcfg.min_discovery_timeout)
+
+enum mpath_frame_type {
+	MPATH_PREQ = 0,
+	MPATH_PREP,
+	MPATH_PERR,
+	MPATH_RANN
+};
+
+static const u8 broadcast_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
+static int mesh_path_sel_frame_tx(enum mpath_frame_type action, u8 flags,
+		u8 *orig_addr, __le32 orig_sn, u8 target_flags, u8 *target,
+		__le32 target_sn, const u8 *da, u8 hop_count, u8 ttl,
+		__le32 lifetime, __le32 metric, __le32 preq_id,
+		struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct sk_buff *skb = dev_alloc_skb(local->hw.extra_tx_headroom + 400);
+	struct ieee80211_mgmt *mgmt;
+	u8 *pos;
+	int ie_len;
+
+	if (!skb)
+		return -1;
+	skb_reserve(skb, local->hw.extra_tx_headroom);
+	/* 25 is the size of the common mgmt part (24) plus the size of the
+	 * common action part (1)
+	 */
+	mgmt = (struct ieee80211_mgmt *)
+		skb_put(skb, 25 + sizeof(mgmt->u.action.u.mesh_action));
+	memset(mgmt, 0, 25 + sizeof(mgmt->u.action.u.mesh_action));
+	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+					  IEEE80211_STYPE_ACTION);
+
+	memcpy(mgmt->da, da, ETH_ALEN);
+	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
+	/* BSSID == SA */
+	memcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);
+	mgmt->u.action.category = WLAN_CATEGORY_MESH_ACTION;
+	mgmt->u.action.u.mesh_action.action_code =
+					WLAN_MESH_ACTION_HWMP_PATH_SELECTION;
+
+	switch (action) {
+	case MPATH_PREQ:
+		mhwmp_dbg("sending PREQ to %pM", target);
+		ie_len = 37;
+		pos = skb_put(skb, 2 + ie_len);
+		*pos++ = WLAN_EID_PREQ;
+		break;
+	case MPATH_PREP:
+		mhwmp_dbg("sending PREP to %pM", target);
+		ie_len = 31;
+		pos = skb_put(skb, 2 + ie_len);
+		*pos++ = WLAN_EID_PREP;
+		break;
+	case MPATH_RANN:
+		mhwmp_dbg("sending RANN from %pM", orig_addr);
+		ie_len = sizeof(struct ieee80211_rann_ie);
+		pos = skb_put(skb, 2 + ie_len);
+		*pos++ = WLAN_EID_RANN;
+		break;
+	default:
+		kfree_skb(skb);
+		return -ENOTSUPP;
+		break;
+	}
+	*pos++ = ie_len;
+	*pos++ = flags;
+	*pos++ = hop_count;
+	*pos++ = ttl;
+	if (action == MPATH_PREP) {
+		memcpy(pos, target, ETH_ALEN);
+		pos += ETH_ALEN;
+		memcpy(pos, &target_sn, 4);
+		pos += 4;
+	} else {
+		if (action == MPATH_PREQ) {
+			memcpy(pos, &preq_id, 4);
+			pos += 4;
+		}
+		memcpy(pos, orig_addr, ETH_ALEN);
+		pos += ETH_ALEN;
+		memcpy(pos, &orig_sn, 4);
+		pos += 4;
+	}
+	memcpy(pos, &lifetime, 4);	/* interval for RANN */
+	pos += 4;
+	memcpy(pos, &metric, 4);
+	pos += 4;
+	if (action == MPATH_PREQ) {
+		*pos++ = 1; /* destination count */
+		*pos++ = target_flags;
+		memcpy(pos, target, ETH_ALEN);
+		pos += ETH_ALEN;
+		memcpy(pos, &target_sn, 4);
+		pos += 4;
+	} else if (action == MPATH_PREP) {
+		memcpy(pos, orig_addr, ETH_ALEN);
+		pos += ETH_ALEN;
+		memcpy(pos, &orig_sn, 4);
+		pos += 4;
+	}
+
+	ieee80211_tx_skb(sdata, skb);
+	return 0;
+}
+
+
+/*  Headroom is not adjusted.  Caller should ensure that skb has sufficient
+ *  headroom in case the frame is encrypted. */
+static void prepare_frame_for_deferred_tx(struct ieee80211_sub_if_data *sdata,
+		struct sk_buff *skb)
+{
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+
+	skb_set_mac_header(skb, 0);
+	skb_set_network_header(skb, 0);
+	skb_set_transport_header(skb, 0);
+
+	/* Send all internal mgmt frames on VO. Accordingly set TID to 7. */
+	skb_set_queue_mapping(skb, IEEE80211_AC_VO);
+	skb->priority = 7;
+
+	info->control.vif = &sdata->vif;
+	mac80211_set_qos_hdr(sdata, skb);
+}
+
+/**
+ * mesh_send_path error - Sends a PERR mesh management frame
+ *
+ * @target: broken destination
+ * @target_sn: SN of the broken destination
+ * @target_rcode: reason code for this PERR
+ * @ra: node this frame is addressed to
+ *
+ * Note: This function may be called with driver locks taken that the driver
+ * also acquires in the TX path.  To avoid a deadlock we don't transmit the
+ * frame directly but add it to the pending queue instead.
+ */
+int xrmac_mesh_path_error_tx(u8 ttl, u8 *target, __le32 target_sn,
+		       __le16 target_rcode, const u8 *ra,
+		       struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct sk_buff *skb = dev_alloc_skb(local->hw.extra_tx_headroom + 400);
+	struct ieee80211_mgmt *mgmt;
+	u8 *pos;
+	int ie_len;
+
+	if (!skb)
+		return -1;
+	skb_reserve(skb, local->tx_headroom + local->hw.extra_tx_headroom);
+	/* 25 is the size of the common mgmt part (24) plus the size of the
+	 * common action part (1)
+	 */
+	mgmt = (struct ieee80211_mgmt *)
+		skb_put(skb, 25 + sizeof(mgmt->u.action.u.mesh_action));
+	memset(mgmt, 0, 25 + sizeof(mgmt->u.action.u.mesh_action));
+	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+					  IEEE80211_STYPE_ACTION);
+
+	memcpy(mgmt->da, ra, ETH_ALEN);
+	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
+	/* BSSID == SA */
+	memcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);
+	mgmt->u.action.category = WLAN_CATEGORY_MESH_ACTION;
+	mgmt->u.action.u.mesh_action.action_code =
+					WLAN_MESH_ACTION_HWMP_PATH_SELECTION;
+	ie_len = 15;
+	pos = skb_put(skb, 2 + ie_len);
+	*pos++ = WLAN_EID_PERR;
+	*pos++ = ie_len;
+	/* ttl */
+	*pos++ = ttl;
+	/* number of destinations */
+	*pos++ = 1;
+	/*
+	 * flags bit, bit 1 is unset if we know the sequence number and
+	 * bit 2 is set if we have a reason code
+	 */
+	*pos = 0;
+	if (!target_sn)
+		*pos |= MP_F_USN;
+	if (target_rcode)
+		*pos |= MP_F_RCODE;
+	pos++;
+	memcpy(pos, target, ETH_ALEN);
+	pos += ETH_ALEN;
+	memcpy(pos, &target_sn, 4);
+	pos += 4;
+	memcpy(pos, &target_rcode, 2);
+
+	/* see note in function header */
+	prepare_frame_for_deferred_tx(sdata, skb);
+	mac80211_add_pending_skb(local, skb);
+	return 0;
+}
+
+void mac80211s_update_metric(struct ieee80211_local *local,
+		struct sta_info *stainfo, struct sk_buff *skb)
+{
+	struct ieee80211_tx_info *txinfo = IEEE80211_SKB_CB(skb);
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	int failed;
+
+	if (!ieee80211_is_data(hdr->frame_control))
+		return;
+
+	failed = !(txinfo->flags & IEEE80211_TX_STAT_ACK);
+
+	/* moving average, scaled to 100 */
+	stainfo->fail_avg = ((80 * stainfo->fail_avg + 5) / 100 + 20 * failed);
+	if (stainfo->fail_avg > 95)
+		xrmac_mesh_plink_broken(stainfo);
+}
+
+static u32 airtime_link_metric_get(struct ieee80211_local *local,
+				   struct sta_info *sta)
+{
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sta->sdata);
+	struct ieee80211_supported_band *sband;
+	/* This should be adjusted for each device */
+	int device_constant = 1 << ARITH_SHIFT;
+	int test_frame_len = TEST_FRAME_LEN << ARITH_SHIFT;
+	int s_unit = 1 << ARITH_SHIFT;
+	int rate, err;
+	u32 tx_time, estimated_retx;
+	u64 result;
+
+	sband = local->hw.wiphy->bands[chan_state->conf.channel->band];
+
+	if (sta->fail_avg >= 100)
+		return MAX_METRIC;
+
+	if (sta->last_tx_rate.flags & IEEE80211_TX_RC_MCS)
+		return MAX_METRIC;
+
+	err = (sta->fail_avg << ARITH_SHIFT) / 100;
+
+	/* bitrate is in units of 100 Kbps, while we need rate in units of
+	 * 1Mbps. This will be corrected on tx_time computation.
+	 */
+	rate = sband->bitrates[sta->last_tx_rate.idx].bitrate;
+	tx_time = (device_constant + 10 * test_frame_len / rate);
+	estimated_retx = ((1 << (2 * ARITH_SHIFT)) / (s_unit - err));
+	result = (tx_time * estimated_retx) >> (2 * ARITH_SHIFT) ;
+	return (u32)result;
+}
+
+/**
+ * hwmp_route_info_get - Update routing info to originator and transmitter
+ *
+ * @sdata: local mesh subif
+ * @mgmt: mesh management frame
+ * @hwmp_ie: hwmp information element (PREP or PREQ)
+ *
+ * This function updates the path routing information to the originator and the
+ * transmitter of a HWMP PREQ or PREP frame.
+ *
+ * Returns: metric to frame originator or 0 if the frame should not be further
+ * processed
+ *
+ * Notes: this function is the only place (besides user-provided info) where
+ * path routing information is updated.
+ */
+static u32 hwmp_route_info_get(struct ieee80211_sub_if_data *sdata,
+			    struct ieee80211_mgmt *mgmt,
+			    u8 *hwmp_ie, enum mpath_frame_type action)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct mesh_path *mpath;
+	struct sta_info *sta;
+	bool fresh_info;
+	u8 *orig_addr, *ta;
+	u32 orig_sn, orig_metric;
+	unsigned long orig_lifetime, exp_time;
+	u32 last_hop_metric, new_metric;
+	bool process = true;
+
+	rcu_read_lock();
+	sta = xrmac_sta_info_get(sdata, mgmt->sa);
+	if (!sta) {
+		rcu_read_unlock();
+		return 0;
+	}
+
+	last_hop_metric = airtime_link_metric_get(local, sta);
+	/* Update and check originator routing info */
+	fresh_info = true;
+
+	switch (action) {
+	case MPATH_PREQ:
+		orig_addr = PREQ_IE_ORIG_ADDR(hwmp_ie);
+		orig_sn = PREQ_IE_ORIG_SN(hwmp_ie);
+		orig_lifetime = PREQ_IE_LIFETIME(hwmp_ie);
+		orig_metric = PREQ_IE_METRIC(hwmp_ie);
+		break;
+	case MPATH_PREP:
+		/* Originator here refers to the MP that was the destination in
+		 * the Path Request. The draft refers to that MP as the
+		 * destination address, even though usually it is the origin of
+		 * the PREP frame. We divert from the nomenclature in the draft
+		 * so that we can easily use a single function to gather path
+		 * information from both PREQ and PREP frames.
+		 */
+		orig_addr = PREP_IE_ORIG_ADDR(hwmp_ie);
+		orig_sn = PREP_IE_ORIG_SN(hwmp_ie);
+		orig_lifetime = PREP_IE_LIFETIME(hwmp_ie);
+		orig_metric = PREP_IE_METRIC(hwmp_ie);
+		break;
+	default:
+		rcu_read_unlock();
+		return 0;
+	}
+	new_metric = orig_metric + last_hop_metric;
+	if (new_metric < orig_metric)
+		new_metric = MAX_METRIC;
+	exp_time = TU_TO_EXP_TIME(orig_lifetime);
+
+	if (memcmp(orig_addr, sdata->vif.addr, ETH_ALEN) == 0) {
+		/* This MP is the originator, we are not interested in this
+		 * frame, except for updating transmitter's path info.
+		 */
+		process = false;
+		fresh_info = false;
+	} else {
+		mpath = xrmac_mesh_path_lookup(orig_addr, sdata);
+		if (mpath) {
+			spin_lock_bh(&mpath->state_lock);
+			if (mpath->flags & MESH_PATH_FIXED)
+				fresh_info = false;
+			else if ((mpath->flags & MESH_PATH_ACTIVE) &&
+			    (mpath->flags & MESH_PATH_SN_VALID)) {
+				if (SN_GT(mpath->sn, orig_sn) ||
+				    (mpath->sn == orig_sn &&
+				     new_metric >= mpath->metric)) {
+					process = false;
+					fresh_info = false;
+				}
+			}
+		} else {
+			xrmac_mesh_path_add(orig_addr, sdata);
+			mpath = xrmac_mesh_path_lookup(orig_addr, sdata);
+			if (!mpath) {
+				rcu_read_unlock();
+				return 0;
+			}
+			spin_lock_bh(&mpath->state_lock);
+		}
+
+		if (fresh_info) {
+			xrmac_mesh_path_assign_nexthop(mpath, sta);
+			mpath->flags |= MESH_PATH_SN_VALID;
+			mpath->metric = new_metric;
+			mpath->sn = orig_sn;
+			mpath->exp_time = time_after(mpath->exp_time, exp_time)
+					  ?  mpath->exp_time : exp_time;
+			mesh_path_activate(mpath);
+			spin_unlock_bh(&mpath->state_lock);
+			xrmac_mesh_path_tx_pending(mpath);
+			/* draft says preq_id should be saved to, but there does
+			 * not seem to be any use for it, skipping by now
+			 */
+		} else
+			spin_unlock_bh(&mpath->state_lock);
+	}
+
+	/* Update and check transmitter routing info */
+	ta = mgmt->sa;
+	if (memcmp(orig_addr, ta, ETH_ALEN) == 0)
+		fresh_info = false;
+	else {
+		fresh_info = true;
+
+		mpath = xrmac_mesh_path_lookup(ta, sdata);
+		if (mpath) {
+			spin_lock_bh(&mpath->state_lock);
+			if ((mpath->flags & MESH_PATH_FIXED) ||
+				((mpath->flags & MESH_PATH_ACTIVE) &&
+					(last_hop_metric > mpath->metric)))
+				fresh_info = false;
+		} else {
+			xrmac_mesh_path_add(ta, sdata);
+			mpath = xrmac_mesh_path_lookup(ta, sdata);
+			if (!mpath) {
+				rcu_read_unlock();
+				return 0;
+			}
+			spin_lock_bh(&mpath->state_lock);
+		}
+
+		if (fresh_info) {
+			xrmac_mesh_path_assign_nexthop(mpath, sta);
+			mpath->metric = last_hop_metric;
+			mpath->exp_time = time_after(mpath->exp_time, exp_time)
+					  ?  mpath->exp_time : exp_time;
+			mesh_path_activate(mpath);
+			spin_unlock_bh(&mpath->state_lock);
+			xrmac_mesh_path_tx_pending(mpath);
+		} else
+			spin_unlock_bh(&mpath->state_lock);
+	}
+
+	rcu_read_unlock();
+
+	return process ? new_metric : 0;
+}
+
+static void hwmp_preq_frame_process(struct ieee80211_sub_if_data *sdata,
+				    struct ieee80211_mgmt *mgmt,
+				    u8 *preq_elem, u32 metric)
+{
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+	struct mesh_path *mpath;
+	u8 *target_addr, *orig_addr;
+	u8 target_flags, ttl;
+	u32 orig_sn, target_sn, lifetime;
+	bool reply = false;
+	bool forward = true;
+
+	/* Update target SN, if present */
+	target_addr = PREQ_IE_TARGET_ADDR(preq_elem);
+	orig_addr = PREQ_IE_ORIG_ADDR(preq_elem);
+	target_sn = PREQ_IE_TARGET_SN(preq_elem);
+	orig_sn = PREQ_IE_ORIG_SN(preq_elem);
+	target_flags = PREQ_IE_TARGET_F(preq_elem);
+
+	mhwmp_dbg("received PREQ from %pM", orig_addr);
+
+	if (memcmp(target_addr, sdata->vif.addr, ETH_ALEN) == 0) {
+		mhwmp_dbg("PREQ is for us");
+		forward = false;
+		reply = true;
+		metric = 0;
+		if (time_after(jiffies, ifmsh->last_sn_update +
+					net_traversal_jiffies(sdata)) ||
+		    time_before(jiffies, ifmsh->last_sn_update)) {
+			target_sn = ++ifmsh->sn;
+			ifmsh->last_sn_update = jiffies;
+		}
+	} else {
+		rcu_read_lock();
+		mpath = xrmac_mesh_path_lookup(target_addr, sdata);
+		if (mpath) {
+			if ((!(mpath->flags & MESH_PATH_SN_VALID)) ||
+					SN_LT(mpath->sn, target_sn)) {
+				mpath->sn = target_sn;
+				mpath->flags |= MESH_PATH_SN_VALID;
+			} else if ((!(target_flags & MP_F_DO)) &&
+					(mpath->flags & MESH_PATH_ACTIVE)) {
+				reply = true;
+				metric = mpath->metric;
+				target_sn = mpath->sn;
+				if (target_flags & MP_F_RF)
+					target_flags |= MP_F_DO;
+				else
+					forward = false;
+			}
+		}
+		rcu_read_unlock();
+	}
+
+	if (reply) {
+		lifetime = PREQ_IE_LIFETIME(preq_elem);
+		ttl = ifmsh->mshcfg.element_ttl;
+		if (ttl != 0) {
+			mhwmp_dbg("replying to the PREQ");
+			mesh_path_sel_frame_tx(MPATH_PREP, 0, target_addr,
+				cpu_to_le32(target_sn), 0, orig_addr,
+				cpu_to_le32(orig_sn), mgmt->sa, 0, ttl,
+				cpu_to_le32(lifetime), cpu_to_le32(metric),
+				0, sdata);
+		} else
+			ifmsh->mshstats.dropped_frames_ttl++;
+	}
+
+	if (forward) {
+		u32 preq_id;
+		u8 hopcount, flags;
+
+		ttl = PREQ_IE_TTL(preq_elem);
+		lifetime = PREQ_IE_LIFETIME(preq_elem);
+		if (ttl <= 1) {
+			ifmsh->mshstats.dropped_frames_ttl++;
+			return;
+		}
+		mhwmp_dbg("forwarding the PREQ from %pM", orig_addr);
+		--ttl;
+		flags = PREQ_IE_FLAGS(preq_elem);
+		preq_id = PREQ_IE_PREQ_ID(preq_elem);
+		hopcount = PREQ_IE_HOPCOUNT(preq_elem) + 1;
+		mesh_path_sel_frame_tx(MPATH_PREQ, flags, orig_addr,
+				cpu_to_le32(orig_sn), target_flags, target_addr,
+				cpu_to_le32(target_sn), broadcast_addr,
+				hopcount, ttl, cpu_to_le32(lifetime),
+				cpu_to_le32(metric), cpu_to_le32(preq_id),
+				sdata);
+		ifmsh->mshstats.fwded_mcast++;
+		ifmsh->mshstats.fwded_frames++;
+	}
+}
+
+
+static inline struct sta_info *
+next_hop_deref_protected(struct mesh_path *mpath)
+{
+	return rcu_dereference_protected(mpath->next_hop,
+					 lockdep_is_held(&mpath->state_lock));
+}
+
+
+static void hwmp_prep_frame_process(struct ieee80211_sub_if_data *sdata,
+				    struct ieee80211_mgmt *mgmt,
+				    u8 *prep_elem, u32 metric)
+{
+	struct mesh_path *mpath;
+	u8 *target_addr, *orig_addr;
+	u8 ttl, hopcount, flags;
+	u8 next_hop[ETH_ALEN];
+	u32 target_sn, orig_sn, lifetime;
+
+	mhwmp_dbg("received PREP from %pM", PREP_IE_ORIG_ADDR(prep_elem));
+
+	/* Note that we divert from the draft nomenclature and denominate
+	 * destination to what the draft refers to as origininator. So in this
+	 * function destnation refers to the final destination of the PREP,
+	 * which corresponds with the originator of the PREQ which this PREP
+	 * replies
+	 */
+	target_addr = PREP_IE_TARGET_ADDR(prep_elem);
+	if (memcmp(target_addr, sdata->vif.addr, ETH_ALEN) == 0)
+		/* destination, no forwarding required */
+		return;
+
+	ttl = PREP_IE_TTL(prep_elem);
+	if (ttl <= 1) {
+		sdata->u.mesh.mshstats.dropped_frames_ttl++;
+		return;
+	}
+
+	rcu_read_lock();
+	mpath = xrmac_mesh_path_lookup(target_addr, sdata);
+	if (mpath)
+		spin_lock_bh(&mpath->state_lock);
+	else
+		goto fail;
+	if (!(mpath->flags & MESH_PATH_ACTIVE)) {
+		spin_unlock_bh(&mpath->state_lock);
+		goto fail;
+	}
+	memcpy(next_hop, next_hop_deref_protected(mpath)->sta.addr, ETH_ALEN);
+	spin_unlock_bh(&mpath->state_lock);
+	--ttl;
+	flags = PREP_IE_FLAGS(prep_elem);
+	lifetime = PREP_IE_LIFETIME(prep_elem);
+	hopcount = PREP_IE_HOPCOUNT(prep_elem) + 1;
+	orig_addr = PREP_IE_ORIG_ADDR(prep_elem);
+	target_sn = PREP_IE_TARGET_SN(prep_elem);
+	orig_sn = PREP_IE_ORIG_SN(prep_elem);
+
+	mesh_path_sel_frame_tx(MPATH_PREP, flags, orig_addr,
+		cpu_to_le32(orig_sn), 0, target_addr,
+		cpu_to_le32(target_sn), next_hop, hopcount,
+		ttl, cpu_to_le32(lifetime), cpu_to_le32(metric),
+		0, sdata);
+	rcu_read_unlock();
+
+	sdata->u.mesh.mshstats.fwded_unicast++;
+	sdata->u.mesh.mshstats.fwded_frames++;
+	return;
+
+fail:
+	rcu_read_unlock();
+	sdata->u.mesh.mshstats.dropped_frames_no_route++;
+}
+
+static void hwmp_perr_frame_process(struct ieee80211_sub_if_data *sdata,
+			     struct ieee80211_mgmt *mgmt, u8 *perr_elem)
+{
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+	struct mesh_path *mpath;
+	u8 ttl;
+	u8 *ta, *target_addr;
+	u32 target_sn;
+	u16 target_rcode;
+
+	ta = mgmt->sa;
+	ttl = PERR_IE_TTL(perr_elem);
+	if (ttl <= 1) {
+		ifmsh->mshstats.dropped_frames_ttl++;
+		return;
+	}
+	ttl--;
+	target_addr = PERR_IE_TARGET_ADDR(perr_elem);
+	target_sn = PERR_IE_TARGET_SN(perr_elem);
+	target_rcode = PERR_IE_TARGET_RCODE(perr_elem);
+
+	rcu_read_lock();
+	mpath = xrmac_mesh_path_lookup(target_addr, sdata);
+	if (mpath) {
+		spin_lock_bh(&mpath->state_lock);
+		if (mpath->flags & MESH_PATH_ACTIVE &&
+		    memcmp(ta, next_hop_deref_protected(mpath)->sta.addr,
+							ETH_ALEN) == 0 &&
+		    (!(mpath->flags & MESH_PATH_SN_VALID) ||
+		    SN_GT(target_sn, mpath->sn))) {
+			mpath->flags &= ~MESH_PATH_ACTIVE;
+			mpath->sn = target_sn;
+			spin_unlock_bh(&mpath->state_lock);
+			xrmac_mesh_path_error_tx(ttl, target_addr, cpu_to_le32(target_sn),
+					   cpu_to_le16(target_rcode),
+					   broadcast_addr, sdata);
+		} else
+			spin_unlock_bh(&mpath->state_lock);
+	}
+	rcu_read_unlock();
+}
+
+static void hwmp_rann_frame_process(struct ieee80211_sub_if_data *sdata,
+				struct ieee80211_mgmt *mgmt,
+				struct ieee80211_rann_ie *rann)
+{
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+	struct mesh_path *mpath;
+	u8 ttl, flags, hopcount;
+	u8 *orig_addr;
+	u32 orig_sn, metric;
+	u32 interval = ifmsh->mshcfg.dot11MeshHWMPRannInterval;
+	bool root_is_gate;
+
+	ttl = rann->rann_ttl;
+	if (ttl <= 1) {
+		ifmsh->mshstats.dropped_frames_ttl++;
+		return;
+	}
+	ttl--;
+	flags = rann->rann_flags;
+	root_is_gate = !!(flags & RANN_FLAG_IS_GATE);
+	orig_addr = rann->rann_addr;
+	orig_sn = rann->rann_seq;
+	hopcount = rann->rann_hopcount;
+	hopcount++;
+	metric = rann->rann_metric;
+
+	/*  Ignore our own RANNs */
+	if (memcmp(orig_addr, sdata->vif.addr, ETH_ALEN) == 0)
+		return;
+
+	mhwmp_dbg("received RANN from %pM (is_gate=%d)", orig_addr,
+			root_is_gate);
+
+	rcu_read_lock();
+	mpath = xrmac_mesh_path_lookup(orig_addr, sdata);
+	if (!mpath) {
+		xrmac_mesh_path_add(orig_addr, sdata);
+		mpath = xrmac_mesh_path_lookup(orig_addr, sdata);
+		if (!mpath) {
+			rcu_read_unlock();
+			sdata->u.mesh.mshstats.dropped_frames_no_route++;
+			return;
+		}
+	}
+
+	if ((!(mpath->flags & (MESH_PATH_ACTIVE | MESH_PATH_RESOLVING)) ||
+	     time_after(jiffies, mpath->exp_time - 1*HZ)) &&
+	     !(mpath->flags & MESH_PATH_FIXED)) {
+		mhwmp_dbg("%s time to refresh root mpath %pM", sdata->name,
+							       orig_addr);
+		mesh_queue_preq(mpath, PREQ_Q_F_START | PREQ_Q_F_REFRESH);
+	}
+
+	if (mpath->sn < orig_sn) {
+		mesh_path_sel_frame_tx(MPATH_RANN, flags, orig_addr,
+				       cpu_to_le32(orig_sn),
+				       0, NULL, 0, broadcast_addr,
+				       hopcount, ttl, cpu_to_le32(interval),
+				       cpu_to_le32(metric + mpath->metric),
+				       0, sdata);
+		mpath->sn = orig_sn;
+	}
+	if (root_is_gate)
+		xrmac_mesh_path_add_gate(mpath);
+
+	rcu_read_unlock();
+}
+
+
+void xrmac_mesh_rx_path_sel_frame(struct ieee80211_sub_if_data *sdata,
+			    struct ieee80211_mgmt *mgmt,
+			    size_t len)
+{
+	struct ieee802_11_elems elems;
+	size_t baselen;
+	u32 last_hop_metric;
+	struct sta_info *sta;
+
+	/* need action_code */
+	if (len < IEEE80211_MIN_ACTION_SIZE + 1)
+		return;
+
+	rcu_read_lock();
+	sta = xrmac_sta_info_get(sdata, mgmt->sa);
+	if (!sta || sta->plink_state != NL80211_PLINK_ESTAB) {
+		rcu_read_unlock();
+		return;
+	}
+	rcu_read_unlock();
+
+	baselen = (u8 *) mgmt->u.action.u.mesh_action.variable - (u8 *) mgmt;
+	mac802_11_parse_elems(mgmt->u.action.u.mesh_action.variable,
+			len - baselen, &elems);
+
+	if (elems.preq) {
+		if (elems.preq_len != 37)
+			/* Right now we support just 1 destination and no AE */
+			return;
+		last_hop_metric = hwmp_route_info_get(sdata, mgmt, elems.preq,
+						      MPATH_PREQ);
+		if (last_hop_metric)
+			hwmp_preq_frame_process(sdata, mgmt, elems.preq,
+						last_hop_metric);
+	}
+	if (elems.prep) {
+		if (elems.prep_len != 31)
+			/* Right now we support no AE */
+			return;
+		last_hop_metric = hwmp_route_info_get(sdata, mgmt, elems.prep,
+						      MPATH_PREP);
+		if (last_hop_metric)
+			hwmp_prep_frame_process(sdata, mgmt, elems.prep,
+						last_hop_metric);
+	}
+	if (elems.perr) {
+		if (elems.perr_len != 15)
+			/* Right now we support only one destination per PERR */
+			return;
+		hwmp_perr_frame_process(sdata, mgmt, elems.perr);
+	}
+	if (elems.rann)
+		hwmp_rann_frame_process(sdata, mgmt, elems.rann);
+}
+
+/**
+ * mesh_queue_preq - queue a PREQ to a given destination
+ *
+ * @mpath: mesh path to discover
+ * @flags: special attributes of the PREQ to be sent
+ *
+ * Locking: the function must be called from within a rcu read lock block.
+ *
+ */
+static void mesh_queue_preq(struct mesh_path *mpath, u8 flags)
+{
+	struct ieee80211_sub_if_data *sdata = mpath->sdata;
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+	struct mesh_preq_queue *preq_node;
+
+	preq_node = kmalloc(sizeof(struct mesh_preq_queue), GFP_ATOMIC);
+	if (!preq_node) {
+		mhwmp_dbg("could not allocate PREQ node");
+		return;
+	}
+
+	spin_lock_bh(&ifmsh->mesh_preq_queue_lock);
+	if (ifmsh->preq_queue_len == MAX_PREQ_QUEUE_LEN) {
+		spin_unlock_bh(&ifmsh->mesh_preq_queue_lock);
+		kfree(preq_node);
+		if (printk_ratelimit())
+			mhwmp_dbg("PREQ node queue full");
+		return;
+	}
+
+	memcpy(preq_node->dst, mpath->dst, ETH_ALEN);
+	preq_node->flags = flags;
+
+	list_add_tail(&preq_node->list, &ifmsh->preq_queue.list);
+	++ifmsh->preq_queue_len;
+	spin_unlock_bh(&ifmsh->mesh_preq_queue_lock);
+
+	if (time_after(jiffies, ifmsh->last_preq + min_preq_int_jiff(sdata)))
+		mac80211_queue_work(&sdata->local->hw, &sdata->work);
+
+	else if (time_before(jiffies, ifmsh->last_preq)) {
+		/* avoid long wait if did not send preqs for a long time
+		 * and jiffies wrapped around
+		 */
+		ifmsh->last_preq = jiffies - min_preq_int_jiff(sdata) - 1;
+		mac80211_queue_work(&sdata->local->hw, &sdata->work);
+	} else
+		mod_timer(&ifmsh->xrmac_mesh_path_timer, ifmsh->last_preq +
+						min_preq_int_jiff(sdata));
+}
+
+/**
+ * xrmac_mesh_path_start_discovery - launch a path discovery from the PREQ queue
+ *
+ * @sdata: local mesh subif
+ */
+void xrmac_mesh_path_start_discovery(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+	struct mesh_preq_queue *preq_node;
+	struct mesh_path *mpath;
+	u8 ttl, target_flags;
+	u32 lifetime;
+
+	spin_lock_bh(&ifmsh->mesh_preq_queue_lock);
+	if (!ifmsh->preq_queue_len ||
+		time_before(jiffies, ifmsh->last_preq +
+				min_preq_int_jiff(sdata))) {
+		spin_unlock_bh(&ifmsh->mesh_preq_queue_lock);
+		return;
+	}
+
+	preq_node = list_first_entry(&ifmsh->preq_queue.list,
+			struct mesh_preq_queue, list);
+	list_del(&preq_node->list);
+	--ifmsh->preq_queue_len;
+	spin_unlock_bh(&ifmsh->mesh_preq_queue_lock);
+
+	rcu_read_lock();
+	mpath = xrmac_mesh_path_lookup(preq_node->dst, sdata);
+	if (!mpath)
+		goto enddiscovery;
+
+	spin_lock_bh(&mpath->state_lock);
+	if (preq_node->flags & PREQ_Q_F_START) {
+		if (mpath->flags & MESH_PATH_RESOLVING) {
+			spin_unlock_bh(&mpath->state_lock);
+			goto enddiscovery;
+		} else {
+			mpath->flags &= ~MESH_PATH_RESOLVED;
+			mpath->flags |= MESH_PATH_RESOLVING;
+			mpath->discovery_retries = 0;
+			mpath->discovery_timeout = disc_timeout_jiff(sdata);
+		}
+	} else if (!(mpath->flags & MESH_PATH_RESOLVING) ||
+			mpath->flags & MESH_PATH_RESOLVED) {
+		mpath->flags &= ~MESH_PATH_RESOLVING;
+		spin_unlock_bh(&mpath->state_lock);
+		goto enddiscovery;
+	}
+
+	ifmsh->last_preq = jiffies;
+
+	if (time_after(jiffies, ifmsh->last_sn_update +
+				net_traversal_jiffies(sdata)) ||
+	    time_before(jiffies, ifmsh->last_sn_update)) {
+		++ifmsh->sn;
+		sdata->u.mesh.last_sn_update = jiffies;
+	}
+	lifetime = default_lifetime(sdata);
+	ttl = sdata->u.mesh.mshcfg.element_ttl;
+	if (ttl == 0) {
+		sdata->u.mesh.mshstats.dropped_frames_ttl++;
+		spin_unlock_bh(&mpath->state_lock);
+		goto enddiscovery;
+	}
+
+	if (preq_node->flags & PREQ_Q_F_REFRESH)
+		target_flags = MP_F_DO;
+	else
+		target_flags = MP_F_RF;
+
+	spin_unlock_bh(&mpath->state_lock);
+	mesh_path_sel_frame_tx(MPATH_PREQ, 0, sdata->vif.addr,
+			cpu_to_le32(ifmsh->sn), target_flags, mpath->dst,
+			cpu_to_le32(mpath->sn), broadcast_addr, 0,
+			ttl, cpu_to_le32(lifetime), 0,
+			cpu_to_le32(ifmsh->preq_id++), sdata);
+	mod_timer(&mpath->timer, jiffies + mpath->discovery_timeout);
+
+enddiscovery:
+	rcu_read_unlock();
+	kfree(preq_node);
+}
+
+/**
+ * xrmac_mesh_nexthop_lookup - put the appropriate next hop on a mesh frame
+ *
+ * @skb: 802.11 frame to be sent
+ * @sdata: network subif the frame will be sent through
+ *
+ * Returns: 0 if the next hop was found. Nonzero otherwise. If no next hop is
+ * found, the function will start a path discovery and queue the frame so it is
+ * sent when the path is resolved. This means the caller must not free the skb
+ * in this case.
+ */
+int xrmac_mesh_nexthop_lookup(struct sk_buff *skb,
+			struct ieee80211_sub_if_data *sdata)
+{
+	struct sk_buff *skb_to_free = NULL;
+	struct mesh_path *mpath;
+	struct sta_info *next_hop;
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	u8 *target_addr = hdr->addr3;
+	int err = 0;
+
+	rcu_read_lock();
+	mpath = xrmac_mesh_path_lookup(target_addr, sdata);
+
+	if (!mpath) {
+		xrmac_mesh_path_add(target_addr, sdata);
+		mpath = xrmac_mesh_path_lookup(target_addr, sdata);
+		if (!mpath) {
+			sdata->u.mesh.mshstats.dropped_frames_no_route++;
+			err = -ENOSPC;
+			goto endlookup;
+		}
+	}
+
+	if (mpath->flags & MESH_PATH_ACTIVE) {
+		if (time_after(jiffies,
+			       mpath->exp_time -
+			       msecs_to_jiffies(sdata->u.mesh.mshcfg.path_refresh_time)) &&
+		    !memcmp(sdata->vif.addr, hdr->addr4, ETH_ALEN) &&
+		    !(mpath->flags & MESH_PATH_RESOLVING) &&
+		    !(mpath->flags & MESH_PATH_FIXED)) {
+			mesh_queue_preq(mpath,
+					PREQ_Q_F_START | PREQ_Q_F_REFRESH);
+		}
+		next_hop = rcu_dereference(mpath->next_hop);
+		if (next_hop)
+			memcpy(hdr->addr1, next_hop->sta.addr, ETH_ALEN);
+		else
+			err = -ENOENT;
+	} else {
+		struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+		if (!(mpath->flags & MESH_PATH_RESOLVING)) {
+			/* Start discovery only if it is not running yet */
+			mesh_queue_preq(mpath, PREQ_Q_F_START);
+		}
+
+		if (skb_queue_len(&mpath->frame_queue) >=
+				MESH_FRAME_QUEUE_LEN)
+			skb_to_free = skb_dequeue(&mpath->frame_queue);
+
+		info->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING;
+		skb_queue_tail(&mpath->frame_queue, skb);
+		if (skb_to_free)
+			xrmac_mesh_path_discard_frame(skb_to_free, sdata);
+		err = -ENOENT;
+	}
+
+endlookup:
+	rcu_read_unlock();
+	return err;
+}
+
+void xrmac_mesh_path_timer(unsigned long data)
+{
+	struct mesh_path *mpath = (void *) data;
+	struct ieee80211_sub_if_data *sdata = mpath->sdata;
+	int ret;
+
+	if (sdata->local->quiescing)
+		return;
+
+	spin_lock_bh(&mpath->state_lock);
+	if (mpath->flags & MESH_PATH_RESOLVED ||
+			(!(mpath->flags & MESH_PATH_RESOLVING))) {
+		mpath->flags &= ~(MESH_PATH_RESOLVING | MESH_PATH_RESOLVED);
+		spin_unlock_bh(&mpath->state_lock);
+	} else if (mpath->discovery_retries < max_preq_retries(sdata)) {
+		++mpath->discovery_retries;
+		mpath->discovery_timeout *= 2;
+		spin_unlock_bh(&mpath->state_lock);
+		mesh_queue_preq(mpath, 0);
+	} else {
+		mpath->flags = 0;
+		mpath->exp_time = jiffies;
+		spin_unlock_bh(&mpath->state_lock);
+		if (!mpath->is_gate && xrmac_mesh_gate_num(sdata) > 0) {
+			ret = xrmac_mesh_path_send_to_gates(mpath);
+			if (ret)
+				mhwmp_dbg("no gate was reachable");
+		} else
+			xrmac_mesh_path_flush_pending(mpath);
+	}
+}
+
+void
+xrmac_mesh_path_tx_root_frame(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+	u32 interval = ifmsh->mshcfg.dot11MeshHWMPRannInterval;
+	u8 flags;
+
+	flags = (ifmsh->mshcfg.dot11MeshGateAnnouncementProtocol)
+			? RANN_FLAG_IS_GATE : 0;
+	mesh_path_sel_frame_tx(MPATH_RANN, flags, sdata->vif.addr,
+			       cpu_to_le32(++ifmsh->sn),
+			       0, NULL, 0, broadcast_addr,
+			       0, sdata->u.mesh.mshcfg.element_ttl,
+			       cpu_to_le32(interval), 0, 0, sdata);
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/mesh_pathtbl.c b/drivers/net/wireless/xr829/umac/mesh_pathtbl.c
--- a/drivers/net/wireless/xr829/umac/mesh_pathtbl.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/mesh_pathtbl.c	2022-08-27 01:22:42.946539832 +0300
@@ -0,0 +1,1173 @@
+/*
+ * Copyright (c) 2008, 2009 open80211s Ltd.
+ * Author:     Luis Carlos Cobo <luisca@cozybit.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/etherdevice.h>
+#include <linux/list.h>
+#include <linux/random.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <net/mac80211.h>
+#include "wme.h"
+#include "ieee80211_i.h"
+#include "mesh.h"
+
+#ifdef CONFIG_XRMAC_VERBOSE_MPATH_DEBUG
+#define mpath_dbg(fmt, args...)	printk(KERN_DEBUG fmt, ##args)
+#else
+#define mpath_dbg(fmt, args...)	do { (void)(0); } while (0)
+#endif
+
+/* There will be initially 2^INIT_PATHS_SIZE_ORDER buckets */
+#define INIT_PATHS_SIZE_ORDER	2
+
+/* Keep the mean chain length below this constant */
+#define MEAN_CHAIN_LEN		2
+
+#define MPATH_EXPIRED(mpath) ((mpath->flags & MESH_PATH_ACTIVE) && \
+				time_after(jiffies, mpath->exp_time) && \
+				!(mpath->flags & MESH_PATH_FIXED))
+
+struct mpath_node {
+	struct hlist_node list;
+	struct rcu_head rcu;
+	/* This indirection allows two different tables to point to the same
+	 * mesh_path structure, useful when resizing
+	 */
+	struct mesh_path *mpath;
+};
+
+static struct mesh_table __rcu *mesh_paths;
+static struct mesh_table __rcu *mpp_paths; /* Store paths for MPP&MAP */
+
+int xrmac_mesh_paths_generation;
+
+/* This lock will have the grow table function as writer and add / delete nodes
+ * as readers. RCU provides sufficient protection only when reading the table
+ * (i.e. doing lookups).  Adding or adding or removing nodes requires we take
+ * the read lock or we risk operating on an old table.  The write lock is only
+ * needed when modifying the number of buckets a table.
+ */
+static DEFINE_RWLOCK(pathtbl_resize_lock);
+
+
+static inline struct mesh_table *resize_dereference_mesh_paths(void)
+{
+	return rcu_dereference_protected(mesh_paths,
+		lockdep_is_held(&pathtbl_resize_lock));
+}
+
+static inline struct mesh_table *resize_dereference_mpp_paths(void)
+{
+	return rcu_dereference_protected(mpp_paths,
+		lockdep_is_held(&pathtbl_resize_lock));
+}
+
+static int mesh_gate_add(struct mesh_table *tbl, struct mesh_path *mpath);
+
+/*
+ * CAREFUL -- "tbl" must not be an expression,
+ * in particular not an rcu_dereference(), since
+ * it's used twice. So it is illegal to do
+ *	for_each_mesh_entry(rcu_dereference(...), ...)
+ */
+#define for_each_mesh_entry(tbl, p, node, i) \
+	for (i = 0; i <= tbl->hash_mask; i++) \
+		hlist_for_each_entry_rcu(node, p, &tbl->hash_buckets[i], list)
+
+
+static struct mesh_table *mesh_table_alloc(int size_order)
+{
+	int i;
+	struct mesh_table *newtbl;
+
+	newtbl = kmalloc(sizeof(struct mesh_table), GFP_ATOMIC);
+	if (!newtbl)
+		return NULL;
+
+	newtbl->hash_buckets = kzalloc(sizeof(struct hlist_head) *
+			(1 << size_order), GFP_ATOMIC);
+
+	if (!newtbl->hash_buckets) {
+		kfree(newtbl);
+		return NULL;
+	}
+
+	newtbl->hashwlock = kmalloc(sizeof(spinlock_t) *
+			(1 << size_order), GFP_ATOMIC);
+	if (!newtbl->hashwlock) {
+		kfree(newtbl->hash_buckets);
+		kfree(newtbl);
+		return NULL;
+	}
+
+	newtbl->size_order = size_order;
+	newtbl->hash_mask = (1 << size_order) - 1;
+	atomic_set(&newtbl->entries,  0);
+	get_random_bytes(&newtbl->hash_rnd,
+			sizeof(newtbl->hash_rnd));
+	for (i = 0; i <= newtbl->hash_mask; i++)
+		spin_lock_init(&newtbl->hashwlock[i]);
+	spin_lock_init(&newtbl->gates_lock);
+
+	return newtbl;
+}
+
+static void __mesh_table_free(struct mesh_table *tbl)
+{
+	kfree(tbl->hash_buckets);
+	kfree(tbl->hashwlock);
+	kfree(tbl);
+}
+
+static void mesh_table_free(struct mesh_table *tbl, bool free_leafs)
+{
+	struct hlist_head *mesh_hash;
+	struct hlist_node *p, *q;
+	struct mpath_node *gate;
+	int i;
+
+	mesh_hash = tbl->hash_buckets;
+	for (i = 0; i <= tbl->hash_mask; i++) {
+		spin_lock_bh(&tbl->hashwlock[i]);
+		hlist_for_each_safe(p, q, &mesh_hash[i]) {
+			tbl->free_node(p, free_leafs);
+			atomic_dec(&tbl->entries);
+		}
+		spin_unlock_bh(&tbl->hashwlock[i]);
+	}
+	if (free_leafs) {
+		spin_lock_bh(&tbl->gates_lock);
+		hlist_for_each_entry_safe(gate, p, q,
+					 tbl->known_gates, list) {
+			hlist_del(&gate->list);
+			kfree(gate);
+		}
+		kfree(tbl->known_gates);
+		spin_unlock_bh(&tbl->gates_lock);
+	}
+
+	__mesh_table_free(tbl);
+}
+
+static int mesh_table_grow(struct mesh_table *oldtbl,
+			   struct mesh_table *newtbl)
+{
+	struct hlist_head *oldhash;
+	struct hlist_node *p, *q;
+	int i;
+
+	if (atomic_read(&oldtbl->entries)
+			< oldtbl->mean_chain_len * (oldtbl->hash_mask + 1))
+		return -EAGAIN;
+
+	newtbl->free_node = oldtbl->free_node;
+	newtbl->mean_chain_len = oldtbl->mean_chain_len;
+	newtbl->copy_node = oldtbl->copy_node;
+	newtbl->known_gates = oldtbl->known_gates;
+	atomic_set(&newtbl->entries, atomic_read(&oldtbl->entries));
+
+	oldhash = oldtbl->hash_buckets;
+	for (i = 0; i <= oldtbl->hash_mask; i++)
+		hlist_for_each(p, &oldhash[i])
+			if (oldtbl->copy_node(p, newtbl) < 0)
+				goto errcopy;
+
+	return 0;
+
+errcopy:
+	for (i = 0; i <= newtbl->hash_mask; i++) {
+		hlist_for_each_safe(p, q, &newtbl->hash_buckets[i])
+			oldtbl->free_node(p, 0);
+	}
+	return -ENOMEM;
+}
+
+static u32 mesh_table_hash(u8 *addr, struct ieee80211_sub_if_data *sdata,
+			   struct mesh_table *tbl)
+{
+	/* Use last four bytes of hw addr and interface index as hash index */
+	return jhash_2words(*(u32 *)(addr+2), sdata->dev->ifindex, tbl->hash_rnd)
+		& tbl->hash_mask;
+}
+
+
+/**
+ *
+ * xrmac_mesh_path_assign_nexthop - update mesh path next hop
+ *
+ * @mpath: mesh path to update
+ * @sta: next hop to assign
+ *
+ * Locking: mpath->state_lock must be held when calling this function
+ */
+void xrmac_mesh_path_assign_nexthop(struct mesh_path *mpath, struct sta_info *sta)
+{
+	struct sk_buff *skb;
+	struct ieee80211_hdr *hdr;
+	struct sk_buff_head tmpq;
+	unsigned long flags;
+	struct ieee80211_sub_if_data *sdata = mpath->sdata;
+
+	rcu_assign_pointer(mpath->next_hop, sta);
+
+	__skb_queue_head_init(&tmpq);
+
+	spin_lock_irqsave(&mpath->frame_queue.lock, flags);
+
+	while ((skb = __skb_dequeue(&mpath->frame_queue)) != NULL) {
+		hdr = (struct ieee80211_hdr *) skb->data;
+		memcpy(hdr->addr1, sta->sta.addr, ETH_ALEN);
+		skb_set_queue_mapping(skb, mac80211_select_queue(sdata, skb));
+		mac80211_set_qos_hdr(sdata, skb);
+		__skb_queue_tail(&tmpq, skb);
+	}
+
+	skb_queue_splice(&tmpq, &mpath->frame_queue);
+	spin_unlock_irqrestore(&mpath->frame_queue.lock, flags);
+}
+
+static void prepare_for_gate(struct sk_buff *skb, char *dst_addr,
+			     struct mesh_path *gate_mpath)
+{
+	struct ieee80211_hdr *hdr;
+	struct ieee80211s_hdr *mshdr;
+	int mesh_hdrlen, hdrlen;
+	char *next_hop;
+
+	hdr = (struct ieee80211_hdr *) skb->data;
+	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	mshdr = (struct ieee80211s_hdr *) (skb->data + hdrlen);
+
+	if (!(mshdr->flags & MESH_FLAGS_AE)) {
+		/* size of the fixed part of the mesh header */
+		mesh_hdrlen = 6;
+
+		/* make room for the two extended addresses */
+		skb_push(skb, 2 * ETH_ALEN);
+		memmove(skb->data, hdr, hdrlen + mesh_hdrlen);
+
+		hdr = (struct ieee80211_hdr *) skb->data;
+
+		/* we preserve the previous mesh header and only add
+		 * the new addreses */
+		mshdr = (struct ieee80211s_hdr *) (skb->data + hdrlen);
+		mshdr->flags = MESH_FLAGS_AE_A5_A6;
+		memcpy(mshdr->eaddr1, hdr->addr3, ETH_ALEN);
+		memcpy(mshdr->eaddr2, hdr->addr4, ETH_ALEN);
+	}
+
+	/* update next hop */
+	hdr = (struct ieee80211_hdr *) skb->data;
+	rcu_read_lock();
+	next_hop = rcu_dereference(gate_mpath->next_hop)->sta.addr;
+	memcpy(hdr->addr1, next_hop, ETH_ALEN);
+	rcu_read_unlock();
+	memcpy(hdr->addr3, dst_addr, ETH_ALEN);
+}
+
+/**
+ *
+ * mesh_path_move_to_queue - Move or copy frames from one mpath queue to another
+ *
+ * This function is used to transfer or copy frames from an unresolved mpath to
+ * a gate mpath.  The function also adds the Address Extension field and
+ * updates the next hop.
+ *
+ * If a frame already has an Address Extension field, only the next hop and
+ * destination addresses are updated.
+ *
+ * The gate mpath must be an active mpath with a valid mpath->next_hop.
+ *
+ * @mpath: An active mpath the frames will be sent to (i.e. the gate)
+ * @from_mpath: The failed mpath
+ * @copy: When true, copy all the frames to the new mpath queue.  When false,
+ * move them.
+ */
+static void mesh_path_move_to_queue(struct mesh_path *gate_mpath,
+				    struct mesh_path *from_mpath,
+				    bool copy)
+{
+	struct sk_buff *skb, *cp_skb = NULL;
+	struct sk_buff_head gateq, failq;
+	unsigned long flags;
+	int num_skbs;
+
+	BUG_ON(gate_mpath == from_mpath);
+	BUG_ON(!gate_mpath->next_hop);
+
+	__skb_queue_head_init(&gateq);
+	__skb_queue_head_init(&failq);
+
+	spin_lock_irqsave(&from_mpath->frame_queue.lock, flags);
+	skb_queue_splice_init(&from_mpath->frame_queue, &failq);
+	spin_unlock_irqrestore(&from_mpath->frame_queue.lock, flags);
+
+	num_skbs = skb_queue_len(&failq);
+
+	while (num_skbs--) {
+		skb = __skb_dequeue(&failq);
+		if (copy) {
+			cp_skb = skb_copy(skb, GFP_ATOMIC);
+			if (cp_skb)
+				__skb_queue_tail(&failq, cp_skb);
+		}
+
+		prepare_for_gate(skb, gate_mpath->dst, gate_mpath);
+		__skb_queue_tail(&gateq, skb);
+	}
+
+	spin_lock_irqsave(&gate_mpath->frame_queue.lock, flags);
+	skb_queue_splice(&gateq, &gate_mpath->frame_queue);
+	mpath_dbg("Mpath queue for gate %pM has %d frames\n",
+			gate_mpath->dst,
+			skb_queue_len(&gate_mpath->frame_queue));
+	spin_unlock_irqrestore(&gate_mpath->frame_queue.lock, flags);
+
+	if (!copy)
+		return;
+
+	spin_lock_irqsave(&from_mpath->frame_queue.lock, flags);
+	skb_queue_splice(&failq, &from_mpath->frame_queue);
+	spin_unlock_irqrestore(&from_mpath->frame_queue.lock, flags);
+}
+
+
+static struct mesh_path *path_lookup(struct mesh_table *tbl, u8 *dst,
+					  struct ieee80211_sub_if_data *sdata)
+{
+	struct mesh_path *mpath;
+	struct hlist_node *n;
+	struct hlist_head *bucket;
+	struct mpath_node *node;
+
+	bucket = &tbl->hash_buckets[mesh_table_hash(dst, sdata, tbl)];
+	hlist_for_each_entry_rcu(node, n, bucket, list) {
+		mpath = node->mpath;
+		if (mpath->sdata == sdata &&
+				memcmp(dst, mpath->dst, ETH_ALEN) == 0) {
+			if (MPATH_EXPIRED(mpath)) {
+				spin_lock_bh(&mpath->state_lock);
+				mpath->flags &= ~MESH_PATH_ACTIVE;
+				spin_unlock_bh(&mpath->state_lock);
+			}
+			return mpath;
+		}
+	}
+	return NULL;
+}
+
+/**
+ * xrmac_mesh_path_lookup - look up a path in the mesh path table
+ * @dst: hardware address (ETH_ALEN length) of destination
+ * @sdata: local subif
+ *
+ * Returns: pointer to the mesh path structure, or NULL if not found
+ *
+ * Locking: must be called within a read rcu section.
+ */
+struct mesh_path *xrmac_mesh_path_lookup(u8 *dst, struct ieee80211_sub_if_data *sdata)
+{
+	return path_lookup(rcu_dereference(mesh_paths), dst, sdata);
+}
+
+struct mesh_path *xrmac_mpp_path_lookup(u8 *dst, struct ieee80211_sub_if_data *sdata)
+{
+	return path_lookup(rcu_dereference(mpp_paths), dst, sdata);
+}
+
+
+/**
+ * xrmac_mesh_path_lookup_by_idx - look up a path in the mesh path table by its index
+ * @idx: index
+ * @sdata: local subif, or NULL for all entries
+ *
+ * Returns: pointer to the mesh path structure, or NULL if not found.
+ *
+ * Locking: must be called within a read rcu section.
+ */
+struct mesh_path *xrmac_mesh_path_lookup_by_idx(int idx, struct ieee80211_sub_if_data *sdata)
+{
+	struct mesh_table *tbl = rcu_dereference(mesh_paths);
+	struct mpath_node *node;
+	struct hlist_node *p;
+	int i;
+	int j = 0;
+
+	for_each_mesh_entry(tbl, p, node, i) {
+		if (sdata && node->mpath->sdata != sdata)
+			continue;
+		if (j++ == idx) {
+			if (MPATH_EXPIRED(node->mpath)) {
+				spin_lock_bh(&node->mpath->state_lock);
+				node->mpath->flags &= ~MESH_PATH_ACTIVE;
+				spin_unlock_bh(&node->mpath->state_lock);
+			}
+			return node->mpath;
+		}
+	}
+
+	return NULL;
+}
+
+static void mesh_gate_node_reclaim(struct rcu_head *rp)
+{
+	struct mpath_node *node = container_of(rp, struct mpath_node, rcu);
+	kfree(node);
+}
+
+/**
+ * mesh_gate_add - mark mpath as path to a mesh gate and add to known_gates
+ * @mesh_tbl: table which contains known_gates list
+ * @mpath: mpath to known mesh gate
+ *
+ * Returns: 0 on success
+ *
+ */
+static int mesh_gate_add(struct mesh_table *tbl, struct mesh_path *mpath)
+{
+	struct mpath_node *gate, *new_gate;
+	struct hlist_node *n;
+	int err;
+
+	rcu_read_lock();
+	tbl = rcu_dereference(tbl);
+
+	hlist_for_each_entry_rcu(gate, n, tbl->known_gates, list)
+		if (gate->mpath == mpath) {
+			err = -EEXIST;
+			goto err_rcu;
+		}
+
+	new_gate = kzalloc(sizeof(struct mpath_node), GFP_ATOMIC);
+	if (!new_gate) {
+		err = -ENOMEM;
+		goto err_rcu;
+	}
+
+	mpath->is_gate = true;
+	mpath->sdata->u.mesh.num_gates++;
+	new_gate->mpath = mpath;
+	spin_lock_bh(&tbl->gates_lock);
+	hlist_add_head_rcu(&new_gate->list, tbl->known_gates);
+	spin_unlock_bh(&tbl->gates_lock);
+	rcu_read_unlock();
+	mpath_dbg("Mesh path (%s): Recorded new gate: %pM. %d known gates\n",
+		  mpath->sdata->name, mpath->dst,
+		  mpath->sdata->u.mesh.num_gates);
+	return 0;
+err_rcu:
+	rcu_read_unlock();
+	return err;
+}
+
+/**
+ * mesh_gate_del - remove a mesh gate from the list of known gates
+ * @tbl: table which holds our list of known gates
+ * @mpath: gate mpath
+ *
+ * Returns: 0 on success
+ *
+ * Locking: must be called inside rcu_read_lock() section
+ */
+static int mesh_gate_del(struct mesh_table *tbl, struct mesh_path *mpath)
+{
+	struct mpath_node *gate;
+	struct hlist_node *p, *q;
+
+	tbl = rcu_dereference(tbl);
+
+	hlist_for_each_entry_safe(gate, p, q, tbl->known_gates, list)
+		if (gate->mpath == mpath) {
+			spin_lock_bh(&tbl->gates_lock);
+			hlist_del_rcu(&gate->list);
+			call_rcu(&gate->rcu, mesh_gate_node_reclaim);
+			spin_unlock_bh(&tbl->gates_lock);
+			mpath->sdata->u.mesh.num_gates--;
+			mpath->is_gate = false;
+			mpath_dbg("Mesh path (%s): Deleted gate: %pM. "
+				  "%d known gates\n", mpath->sdata->name,
+				  mpath->dst, mpath->sdata->u.mesh.num_gates);
+			break;
+		}
+
+	return 0;
+}
+
+/**
+ *
+ * xrmac_mesh_path_add_gate - add the given mpath to a mesh gate to our path table
+ * @mpath: gate path to add to table
+ */
+int xrmac_mesh_path_add_gate(struct mesh_path *mpath)
+{
+	return mesh_gate_add(mesh_paths, mpath);
+}
+
+/**
+ * xrmac_mesh_gate_num - number of gates known to this interface
+ * @sdata: subif data
+ */
+int xrmac_mesh_gate_num(struct ieee80211_sub_if_data *sdata)
+{
+	return sdata->u.mesh.num_gates;
+}
+
+/**
+ * xrmac_mesh_path_add - allocate and add a new path to the mesh path table
+ * @addr: destination address of the path (ETH_ALEN length)
+ * @sdata: local subif
+ *
+ * Returns: 0 on success
+ *
+ * State: the initial state of the new path is set to 0
+ */
+int xrmac_mesh_path_add(u8 *dst, struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+	struct ieee80211_local *local = sdata->local;
+	struct mesh_table *tbl;
+	struct mesh_path *mpath, *new_mpath;
+	struct mpath_node *node, *new_node;
+	struct hlist_head *bucket;
+	struct hlist_node *n;
+	int grow = 0;
+	int err = 0;
+	u32 hash_idx;
+
+	if (memcmp(dst, sdata->vif.addr, ETH_ALEN) == 0)
+		/* never add ourselves as neighbours */
+		return -ENOTSUPP;
+
+	if (is_multicast_ether_addr(dst))
+		return -ENOTSUPP;
+
+	if (atomic_add_unless(&sdata->u.mesh.mpaths, 1, MESH_MAX_MPATHS) == 0)
+		return -ENOSPC;
+
+	err = -ENOMEM;
+	new_mpath = kzalloc(sizeof(struct mesh_path), GFP_ATOMIC);
+	if (!new_mpath)
+		goto err_path_alloc;
+
+	new_node = kmalloc(sizeof(struct mpath_node), GFP_ATOMIC);
+	if (!new_node)
+		goto err_node_alloc;
+
+	read_lock_bh(&pathtbl_resize_lock);
+	memcpy(new_mpath->dst, dst, ETH_ALEN);
+	new_mpath->sdata = sdata;
+	new_mpath->flags = 0;
+	skb_queue_head_init(&new_mpath->frame_queue);
+	new_node->mpath = new_mpath;
+	new_mpath->timer.data = (unsigned long) new_mpath;
+	new_mpath->timer.function = xrmac_mesh_path_timer;
+	new_mpath->exp_time = jiffies;
+	spin_lock_init(&new_mpath->state_lock);
+	init_timer(&new_mpath->timer);
+
+	tbl = resize_dereference_mesh_paths();
+
+	hash_idx = mesh_table_hash(dst, sdata, tbl);
+	bucket = &tbl->hash_buckets[hash_idx];
+
+	spin_lock_bh(&tbl->hashwlock[hash_idx]);
+
+	err = -EEXIST;
+	hlist_for_each_entry(node, n, bucket, list) {
+		mpath = node->mpath;
+		if (mpath->sdata == sdata && memcmp(dst, mpath->dst, ETH_ALEN) == 0)
+			goto err_exists;
+	}
+
+	hlist_add_head_rcu(&new_node->list, bucket);
+	if (atomic_inc_return(&tbl->entries) >=
+	    tbl->mean_chain_len * (tbl->hash_mask + 1))
+		grow = 1;
+
+	xrmac_mesh_paths_generation++;
+
+	spin_unlock_bh(&tbl->hashwlock[hash_idx]);
+	read_unlock_bh(&pathtbl_resize_lock);
+	if (grow) {
+		set_bit(MESH_WORK_GROW_MPATH_TABLE,  &ifmsh->wrkq_flags);
+		mac80211_queue_work(&local->hw, &sdata->work);
+	}
+	return 0;
+
+err_exists:
+	spin_unlock_bh(&tbl->hashwlock[hash_idx]);
+	read_unlock_bh(&pathtbl_resize_lock);
+	kfree(new_node);
+err_node_alloc:
+	kfree(new_mpath);
+err_path_alloc:
+	atomic_dec(&sdata->u.mesh.mpaths);
+	return err;
+}
+
+static void mesh_table_free_rcu(struct rcu_head *rcu)
+{
+	struct mesh_table *tbl = container_of(rcu, struct mesh_table, rcu_head);
+
+	mesh_table_free(tbl, false);
+}
+
+void xrmac_mesh_mpath_table_grow(void)
+{
+	struct mesh_table *oldtbl, *newtbl;
+
+	write_lock_bh(&pathtbl_resize_lock);
+	oldtbl = resize_dereference_mesh_paths();
+	newtbl = mesh_table_alloc(oldtbl->size_order + 1);
+	if (!newtbl)
+		goto out;
+	if (mesh_table_grow(oldtbl, newtbl) < 0) {
+		__mesh_table_free(newtbl);
+		goto out;
+	}
+	rcu_assign_pointer(mesh_paths, newtbl);
+
+	call_rcu(&oldtbl->rcu_head, mesh_table_free_rcu);
+
+ out:
+	write_unlock_bh(&pathtbl_resize_lock);
+}
+
+void xrmac_mesh_mpp_table_grow(void)
+{
+	struct mesh_table *oldtbl, *newtbl;
+
+	write_lock_bh(&pathtbl_resize_lock);
+	oldtbl = resize_dereference_mpp_paths();
+	newtbl = mesh_table_alloc(oldtbl->size_order + 1);
+	if (!newtbl)
+		goto out;
+	if (mesh_table_grow(oldtbl, newtbl) < 0) {
+		__mesh_table_free(newtbl);
+		goto out;
+	}
+	rcu_assign_pointer(mpp_paths, newtbl);
+	call_rcu(&oldtbl->rcu_head, mesh_table_free_rcu);
+
+ out:
+	write_unlock_bh(&pathtbl_resize_lock);
+}
+
+int xrmac_mpp_path_add(u8 *dst, u8 *mpp, struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+	struct ieee80211_local *local = sdata->local;
+	struct mesh_table *tbl;
+	struct mesh_path *mpath, *new_mpath;
+	struct mpath_node *node, *new_node;
+	struct hlist_head *bucket;
+	struct hlist_node *n;
+	int grow = 0;
+	int err = 0;
+	u32 hash_idx;
+
+	if (memcmp(dst, sdata->vif.addr, ETH_ALEN) == 0)
+		/* never add ourselves as neighbours */
+		return -ENOTSUPP;
+
+	if (is_multicast_ether_addr(dst))
+		return -ENOTSUPP;
+
+	err = -ENOMEM;
+	new_mpath = kzalloc(sizeof(struct mesh_path), GFP_ATOMIC);
+	if (!new_mpath)
+		goto err_path_alloc;
+
+	new_node = kmalloc(sizeof(struct mpath_node), GFP_ATOMIC);
+	if (!new_node)
+		goto err_node_alloc;
+
+	read_lock_bh(&pathtbl_resize_lock);
+	memcpy(new_mpath->dst, dst, ETH_ALEN);
+	memcpy(new_mpath->mpp, mpp, ETH_ALEN);
+	new_mpath->sdata = sdata;
+	new_mpath->flags = 0;
+	skb_queue_head_init(&new_mpath->frame_queue);
+	new_node->mpath = new_mpath;
+	init_timer(&new_mpath->timer);
+	new_mpath->exp_time = jiffies;
+	spin_lock_init(&new_mpath->state_lock);
+
+	tbl = resize_dereference_mpp_paths();
+
+	hash_idx = mesh_table_hash(dst, sdata, tbl);
+	bucket = &tbl->hash_buckets[hash_idx];
+
+	spin_lock_bh(&tbl->hashwlock[hash_idx]);
+
+	err = -EEXIST;
+	hlist_for_each_entry(node, n, bucket, list) {
+		mpath = node->mpath;
+		if (mpath->sdata == sdata && memcmp(dst, mpath->dst, ETH_ALEN) == 0)
+			goto err_exists;
+	}
+
+	hlist_add_head_rcu(&new_node->list, bucket);
+	if (atomic_inc_return(&tbl->entries) >=
+	    tbl->mean_chain_len * (tbl->hash_mask + 1))
+		grow = 1;
+
+	spin_unlock_bh(&tbl->hashwlock[hash_idx]);
+	read_unlock_bh(&pathtbl_resize_lock);
+	if (grow) {
+		set_bit(MESH_WORK_GROW_MPP_TABLE,  &ifmsh->wrkq_flags);
+		mac80211_queue_work(&local->hw, &sdata->work);
+	}
+	return 0;
+
+err_exists:
+	spin_unlock_bh(&tbl->hashwlock[hash_idx]);
+	read_unlock_bh(&pathtbl_resize_lock);
+	kfree(new_node);
+err_node_alloc:
+	kfree(new_mpath);
+err_path_alloc:
+	return err;
+}
+
+
+/**
+ * xrmac_mesh_plink_broken - deactivates paths and sends perr when a link breaks
+ *
+ * @sta: broken peer link
+ *
+ * This function must be called from the rate control algorithm if enough
+ * delivery errors suggest that a peer link is no longer usable.
+ */
+void xrmac_mesh_plink_broken(struct sta_info *sta)
+{
+	struct mesh_table *tbl;
+	static const u8 bcast[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+	struct mesh_path *mpath;
+	struct mpath_node *node;
+	struct hlist_node *p;
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
+	int i;
+	__le16 reason = cpu_to_le16(WLAN_REASON_MESH_PATH_DEST_UNREACHABLE);
+
+	rcu_read_lock();
+	tbl = rcu_dereference(mesh_paths);
+	for_each_mesh_entry(tbl, p, node, i) {
+		mpath = node->mpath;
+		if (rcu_dereference(mpath->next_hop) == sta &&
+		    mpath->flags & MESH_PATH_ACTIVE &&
+		    !(mpath->flags & MESH_PATH_FIXED)) {
+			spin_lock_bh(&mpath->state_lock);
+			mpath->flags &= ~MESH_PATH_ACTIVE;
+			++mpath->sn;
+			spin_unlock_bh(&mpath->state_lock);
+			xrmac_mesh_path_error_tx(sdata->u.mesh.mshcfg.element_ttl,
+					mpath->dst, cpu_to_le32(mpath->sn),
+					reason, bcast, sdata);
+		}
+	}
+	rcu_read_unlock();
+}
+
+static void mesh_path_node_reclaim(struct rcu_head *rp)
+{
+	struct mpath_node *node = container_of(rp, struct mpath_node, rcu);
+	struct ieee80211_sub_if_data *sdata = node->mpath->sdata;
+
+	del_timer_sync(&node->mpath->timer);
+	atomic_dec(&sdata->u.mesh.mpaths);
+	kfree(node->mpath);
+	kfree(node);
+}
+
+/* needs to be called with the corresponding hashwlock taken */
+static void __xrmac_mesh_path_del(struct mesh_table *tbl, struct mpath_node *node)
+{
+	struct mesh_path *mpath;
+	mpath = node->mpath;
+	spin_lock(&mpath->state_lock);
+	mpath->flags |= MESH_PATH_RESOLVING;
+	if (mpath->is_gate)
+		mesh_gate_del(tbl, mpath);
+	hlist_del_rcu(&node->list);
+	call_rcu(&node->rcu, mesh_path_node_reclaim);
+	spin_unlock(&mpath->state_lock);
+	atomic_dec(&tbl->entries);
+}
+
+/**
+ * xrmac_mesh_path_flush_by_nexthop - Deletes mesh paths if their next hop matches
+ *
+ * @sta - mesh peer to match
+ *
+ * RCU notes: this function is called when a mesh plink transitions from
+ * PLINK_ESTAB to any other state, since PLINK_ESTAB state is the only one that
+ * allows path creation. This will happen before the sta can be freed (because
+ * sta_info_destroy() calls this) so any reader in a rcu read block will be
+ * protected against the plink disappearing.
+ */
+void xrmac_mesh_path_flush_by_nexthop(struct sta_info *sta)
+{
+	struct mesh_table *tbl;
+	struct mesh_path *mpath;
+	struct mpath_node *node;
+	struct hlist_node *p;
+	int i;
+
+	rcu_read_lock();
+	read_lock_bh(&pathtbl_resize_lock);
+	tbl = resize_dereference_mesh_paths();
+	for_each_mesh_entry(tbl, p, node, i) {
+		mpath = node->mpath;
+		if (rcu_dereference(mpath->next_hop) == sta) {
+			spin_lock_bh(&tbl->hashwlock[i]);
+			__xrmac_mesh_path_del(tbl, node);
+			spin_unlock_bh(&tbl->hashwlock[i]);
+		}
+	}
+	read_unlock_bh(&pathtbl_resize_lock);
+	rcu_read_unlock();
+}
+
+static void table_flush_by_iface(struct mesh_table *tbl,
+				 struct ieee80211_sub_if_data *sdata)
+{
+	struct mesh_path *mpath;
+	struct mpath_node *node;
+	struct hlist_node *p;
+	int i;
+
+	WARN_ON(!rcu_read_lock_held());
+	for_each_mesh_entry(tbl, p, node, i) {
+		mpath = node->mpath;
+		if (mpath->sdata != sdata)
+			continue;
+		spin_lock_bh(&tbl->hashwlock[i]);
+		__xrmac_mesh_path_del(tbl, node);
+		spin_unlock_bh(&tbl->hashwlock[i]);
+	}
+}
+
+/**
+ * xrmac_mesh_path_flush_by_iface - Deletes all mesh paths associated with a given iface
+ *
+ * This function deletes both mesh paths as well as mesh portal paths.
+ *
+ * @sdata - interface data to match
+ *
+ */
+void xrmac_mesh_path_flush_by_iface(struct ieee80211_sub_if_data *sdata)
+{
+	struct mesh_table *tbl;
+
+	rcu_read_lock();
+	read_lock_bh(&pathtbl_resize_lock);
+	tbl = resize_dereference_mesh_paths();
+	table_flush_by_iface(tbl, sdata);
+	tbl = resize_dereference_mpp_paths();
+	table_flush_by_iface(tbl, sdata);
+	read_unlock_bh(&pathtbl_resize_lock);
+	rcu_read_unlock();
+}
+
+/**
+ * xrmac_mesh_path_del - delete a mesh path from the table
+ *
+ * @addr: dst address (ETH_ALEN length)
+ * @sdata: local subif
+ *
+ * Returns: 0 if successful
+ */
+int xrmac_mesh_path_del(u8 *addr, struct ieee80211_sub_if_data *sdata)
+{
+	struct mesh_table *tbl;
+	struct mesh_path *mpath;
+	struct mpath_node *node;
+	struct hlist_head *bucket;
+	struct hlist_node *n;
+	int hash_idx;
+	int err = 0;
+
+	read_lock_bh(&pathtbl_resize_lock);
+	tbl = resize_dereference_mesh_paths();
+	hash_idx = mesh_table_hash(addr, sdata, tbl);
+	bucket = &tbl->hash_buckets[hash_idx];
+
+	spin_lock_bh(&tbl->hashwlock[hash_idx]);
+	hlist_for_each_entry(node, n, bucket, list) {
+		mpath = node->mpath;
+		if (mpath->sdata == sdata &&
+		    memcmp(addr, mpath->dst, ETH_ALEN) == 0) {
+			__xrmac_mesh_path_del(tbl, node);
+			goto enddel;
+		}
+	}
+
+	err = -ENXIO;
+enddel:
+	xrmac_mesh_paths_generation++;
+	spin_unlock_bh(&tbl->hashwlock[hash_idx]);
+	read_unlock_bh(&pathtbl_resize_lock);
+	return err;
+}
+
+/**
+ * xrmac_mesh_path_tx_pending - sends pending frames in a mesh path queue
+ *
+ * @mpath: mesh path to activate
+ *
+ * Locking: the state_lock of the mpath structure must NOT be held when calling
+ * this function.
+ */
+void xrmac_mesh_path_tx_pending(struct mesh_path *mpath)
+{
+	if (mpath->flags & MESH_PATH_ACTIVE)
+		mac80211_add_pending_skbs(mpath->sdata->local,
+				&mpath->frame_queue);
+}
+
+/**
+ * xrmac_mesh_path_send_to_gates - sends pending frames to all known mesh gates
+ *
+ * @mpath: mesh path whose queue will be emptied
+ *
+ * If there is only one gate, the frames are transferred from the failed mpath
+ * queue to that gate's queue.  If there are more than one gates, the frames
+ * are copied from each gate to the next.  After frames are copied, the
+ * mpath queues are emptied onto the transmission queue.
+ */
+int xrmac_mesh_path_send_to_gates(struct mesh_path *mpath)
+{
+	struct ieee80211_sub_if_data *sdata = mpath->sdata;
+	struct hlist_node *n;
+	struct mesh_table *tbl;
+	struct mesh_path *from_mpath = mpath;
+	struct mpath_node *gate = NULL;
+	bool copy = false;
+	struct hlist_head *known_gates;
+
+	rcu_read_lock();
+	tbl = rcu_dereference(mesh_paths);
+	known_gates = tbl->known_gates;
+	rcu_read_unlock();
+
+	if (!known_gates)
+		return -EHOSTUNREACH;
+
+	hlist_for_each_entry_rcu(gate, n, known_gates, list) {
+		if (gate->mpath->sdata != sdata)
+			continue;
+
+		if (gate->mpath->flags & MESH_PATH_ACTIVE) {
+			mpath_dbg("Forwarding to %pM\n", gate->mpath->dst);
+			mesh_path_move_to_queue(gate->mpath, from_mpath, copy);
+			from_mpath = gate->mpath;
+			copy = true;
+		} else {
+			mpath_dbg("Not forwarding %p\n", gate->mpath);
+			mpath_dbg("flags %x\n", gate->mpath->flags);
+		}
+	}
+
+	hlist_for_each_entry_rcu(gate, n, known_gates, list)
+		if (gate->mpath->sdata == sdata) {
+			mpath_dbg("Sending to %pM\n", gate->mpath->dst);
+			xrmac_mesh_path_tx_pending(gate->mpath);
+		}
+
+	return (from_mpath == mpath) ? -EHOSTUNREACH : 0;
+}
+
+/**
+ * xrmac_mesh_path_discard_frame - discard a frame whose path could not be resolved
+ *
+ * @skb: frame to discard
+ * @sdata: network subif the frame was to be sent through
+ *
+ * If the frame was being forwarded from another MP, a PERR frame will be sent
+ * to the precursor.  The precursor's address (i.e. the previous hop) was saved
+ * in addr1 of the frame-to-be-forwarded, and would only be overwritten once
+ * the destination is successfully resolved.
+ *
+ * Locking: the function must me called within a rcu_read_lock region
+ */
+void xrmac_mesh_path_discard_frame(struct sk_buff *skb,
+			     struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	struct mesh_path *mpath;
+	u32 sn = 0;
+	__le16 reason = cpu_to_le16(WLAN_REASON_MESH_PATH_NOFORWARD);
+
+	if (memcmp(hdr->addr4, sdata->vif.addr, ETH_ALEN) != 0) {
+		u8 *ra, *da;
+
+		da = hdr->addr3;
+		ra = hdr->addr1;
+		rcu_read_lock();
+		mpath = xrmac_mesh_path_lookup(da, sdata);
+		if (mpath) {
+			spin_lock_bh(&mpath->state_lock);
+			sn = ++mpath->sn;
+			spin_unlock_bh(&mpath->state_lock);
+		}
+		rcu_read_unlock();
+		xrmac_mesh_path_error_tx(sdata->u.mesh.mshcfg.element_ttl, skb->data,
+				   cpu_to_le32(sn), reason, ra, sdata);
+	}
+
+	kfree_skb(skb);
+	sdata->u.mesh.mshstats.dropped_frames_no_route++;
+}
+
+/**
+ * xrmac_mesh_path_flush_pending - free the pending queue of a mesh path
+ *
+ * @mpath: mesh path whose queue has to be freed
+ *
+ * Locking: the function must me called within a rcu_read_lock region
+ */
+void xrmac_mesh_path_flush_pending(struct mesh_path *mpath)
+{
+	struct sk_buff *skb;
+
+	while ((skb = skb_dequeue(&mpath->frame_queue)) != NULL)
+		xrmac_mesh_path_discard_frame(skb, mpath->sdata);
+}
+
+/**
+ * xrmac_mesh_path_fix_nexthop - force a specific next hop for a mesh path
+ *
+ * @mpath: the mesh path to modify
+ * @next_hop: the next hop to force
+ *
+ * Locking: this function must be called holding mpath->state_lock
+ */
+void xrmac_mesh_path_fix_nexthop(struct mesh_path *mpath, struct sta_info *next_hop)
+{
+	spin_lock_bh(&mpath->state_lock);
+	xrmac_mesh_path_assign_nexthop(mpath, next_hop);
+	mpath->sn = 0xffff;
+	mpath->metric = 0;
+	mpath->hop_count = 0;
+	mpath->exp_time = 0;
+	mpath->flags |= MESH_PATH_FIXED;
+	mesh_path_activate(mpath);
+	spin_unlock_bh(&mpath->state_lock);
+	xrmac_mesh_path_tx_pending(mpath);
+}
+
+static void mesh_path_node_free(struct hlist_node *p, bool free_leafs)
+{
+	struct mesh_path *mpath;
+	struct mpath_node *node = hlist_entry(p, struct mpath_node, list);
+	mpath = node->mpath;
+	hlist_del_rcu(p);
+	if (free_leafs) {
+		del_timer_sync(&mpath->timer);
+		kfree(mpath);
+	}
+	kfree(node);
+}
+
+static int mesh_path_node_copy(struct hlist_node *p, struct mesh_table *newtbl)
+{
+	struct mesh_path *mpath;
+	struct mpath_node *node, *new_node;
+	u32 hash_idx;
+
+	new_node = kmalloc(sizeof(struct mpath_node), GFP_ATOMIC);
+	if (new_node == NULL)
+		return -ENOMEM;
+
+	node = hlist_entry(p, struct mpath_node, list);
+	mpath = node->mpath;
+	new_node->mpath = mpath;
+	hash_idx = mesh_table_hash(mpath->dst, mpath->sdata, newtbl);
+	hlist_add_head(&new_node->list,
+			&newtbl->hash_buckets[hash_idx]);
+	return 0;
+}
+
+int xrmac_mesh_pathtbl_init(void)
+{
+	struct mesh_table *tbl_path, *tbl_mpp;
+	int ret;
+
+	tbl_path = mesh_table_alloc(INIT_PATHS_SIZE_ORDER);
+	if (!tbl_path)
+		return -ENOMEM;
+	tbl_path->free_node = &mesh_path_node_free;
+	tbl_path->copy_node = &mesh_path_node_copy;
+	tbl_path->mean_chain_len = MEAN_CHAIN_LEN;
+	tbl_path->known_gates = kzalloc(sizeof(struct hlist_head), GFP_ATOMIC);
+	if (!tbl_path->known_gates) {
+		ret = -ENOMEM;
+		goto free_path;
+	}
+	INIT_HLIST_HEAD(tbl_path->known_gates);
+
+
+	tbl_mpp = mesh_table_alloc(INIT_PATHS_SIZE_ORDER);
+	if (!tbl_mpp) {
+		ret = -ENOMEM;
+		goto free_path;
+	}
+	tbl_mpp->free_node = &mesh_path_node_free;
+	tbl_mpp->copy_node = &mesh_path_node_copy;
+	tbl_mpp->mean_chain_len = MEAN_CHAIN_LEN;
+	tbl_mpp->known_gates = kzalloc(sizeof(struct hlist_head), GFP_ATOMIC);
+	if (!tbl_mpp->known_gates) {
+		ret = -ENOMEM;
+		goto free_mpp;
+	}
+	INIT_HLIST_HEAD(tbl_mpp->known_gates);
+
+	/* Need no locking since this is during init */
+	RCU_INIT_POINTER(mesh_paths, tbl_path);
+	RCU_INIT_POINTER(mpp_paths, tbl_mpp);
+
+	return 0;
+
+free_mpp:
+	mesh_table_free(tbl_mpp, true);
+free_path:
+	mesh_table_free(tbl_path, true);
+	return ret;
+}
+
+void xrmac_mesh_path_expire(struct ieee80211_sub_if_data *sdata)
+{
+	struct mesh_table *tbl;
+	struct mesh_path *mpath;
+	struct mpath_node *node;
+	struct hlist_node *p;
+	int i;
+
+	rcu_read_lock();
+	tbl = rcu_dereference(mesh_paths);
+	for_each_mesh_entry(tbl, p, node, i) {
+		if (node->mpath->sdata != sdata)
+			continue;
+		mpath = node->mpath;
+		if ((!(mpath->flags & MESH_PATH_RESOLVING)) &&
+		    (!(mpath->flags & MESH_PATH_FIXED)) &&
+		     time_after(jiffies, mpath->exp_time + MESH_PATH_EXPIRE))
+			xrmac_mesh_path_del(mpath->dst, mpath->sdata);
+	}
+	rcu_read_unlock();
+}
+
+void xrmac_mesh_pathtbl_unregister(void)
+{
+	/* no need for locking during exit path */
+	mesh_table_free(rcu_dereference_protected(mesh_paths, 1), true);
+	mesh_table_free(rcu_dereference_protected(mpp_paths, 1), true);
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/mesh_plink.c b/drivers/net/wireless/xr829/umac/mesh_plink.c
--- a/drivers/net/wireless/xr829/umac/mesh_plink.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/mesh_plink.c	2022-08-27 01:22:42.946539832 +0300
@@ -0,0 +1,829 @@
+/*
+ * Copyright (c) 2008, 2009 open80211s Ltd.
+ * Author:     Luis Carlos Cobo <luisca@cozybit.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/gfp.h>
+#include <linux/kernel.h>
+#include <linux/random.h>
+#include "ieee80211_i.h"
+#include "rate.h"
+#include "mesh.h"
+
+#ifdef CONFIG_XRMAC_VERBOSE_MPL_DEBUG
+#define mpl_dbg(fmt, args...)	printk(KERN_DEBUG fmt, ##args)
+#else
+#define mpl_dbg(fmt, args...)	do { (void)(0); } while (0)
+#endif
+
+#define PLINK_GET_LLID(p) (p + 2)
+#define PLINK_GET_PLID(p) (p + 4)
+
+#define mod_plink_timer(s, t) (mod_timer(&s->plink_timer, \
+				jiffies + HZ * t / 1000))
+
+#define dot11MeshMaxRetries(s) (s->u.mesh.mshcfg.dot11MeshMaxRetries)
+#define dot11MeshRetryTimeout(s) (s->u.mesh.mshcfg.dot11MeshRetryTimeout)
+#define dot11MeshConfirmTimeout(s) (s->u.mesh.mshcfg.dot11MeshConfirmTimeout)
+#define dot11MeshHoldingTimeout(s) (s->u.mesh.mshcfg.dot11MeshHoldingTimeout)
+#define dot11MeshMaxPeerLinks(s) (s->u.mesh.mshcfg.dot11MeshMaxPeerLinks)
+
+enum plink_event {
+	PLINK_UNDEFINED,
+	OPN_ACPT,
+	OPN_RJCT,
+	OPN_IGNR,
+	CNF_ACPT,
+	CNF_RJCT,
+	CNF_IGNR,
+	CLS_ACPT,
+	CLS_IGNR
+};
+
+static int mesh_plink_frame_tx(struct ieee80211_sub_if_data *sdata,
+		enum ieee80211_self_protected_actioncode action,
+		u8 *da, __le16 llid, __le16 plid, __le16 reason);
+
+static inline
+void mesh_plink_inc_estab_count(struct ieee80211_sub_if_data *sdata)
+{
+	atomic_inc(&sdata->u.mesh.mshstats.estab_plinks);
+	xrmac_mesh_accept_plinks_update(sdata);
+}
+
+static inline
+void mesh_plink_dec_estab_count(struct ieee80211_sub_if_data *sdata)
+{
+	atomic_dec(&sdata->u.mesh.mshstats.estab_plinks);
+	xrmac_mesh_accept_plinks_update(sdata);
+}
+
+/**
+ * mesh_plink_fsm_restart - restart a mesh peer link finite state machine
+ *
+ * @sta: mesh peer link to restart
+ *
+ * Locking: this function must be called holding sta->lock
+ */
+static inline void mesh_plink_fsm_restart(struct sta_info *sta)
+{
+	sta->plink_state = NL80211_PLINK_LISTEN;
+	sta->llid = sta->plid = sta->reason = 0;
+	sta->plink_retries = 0;
+}
+
+/*
+ * NOTE: This is just an alias for xrmac_sta_info_alloc(), see notes
+ *       on it in the lifecycle management section!
+ */
+static struct sta_info *mesh_plink_alloc(struct ieee80211_sub_if_data *sdata,
+					 u8 *hw_addr, u32 rates)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sdata);
+	struct sta_info *sta;
+
+	if (local->num_sta >= MESH_MAX_PLINKS)
+		return NULL;
+
+	sta = xrmac_sta_info_alloc(sdata, hw_addr, GFP_KERNEL);
+	if (!sta)
+		return NULL;
+
+	set_sta_flag(sta, WLAN_STA_AUTH);
+	set_sta_flag(sta, WLAN_STA_AUTHORIZED);
+	set_sta_flag(sta, WLAN_STA_WME);
+	sta->sta.supp_rates[chan_state->conf.channel->band] = rates;
+	rate_control_rate_init(sta);
+
+	return sta;
+}
+
+/**
+ * __xrmac_mesh_plink_deactivate - deactivate mesh peer link
+ *
+ * @sta: mesh peer link to deactivate
+ *
+ * All mesh paths with this peer as next hop will be flushed
+ *
+ * Locking: the caller must hold sta->lock
+ */
+static bool __xrmac_mesh_plink_deactivate(struct sta_info *sta)
+{
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
+	bool deactivated = false;
+
+	if (sta->plink_state == NL80211_PLINK_ESTAB) {
+		mesh_plink_dec_estab_count(sdata);
+		deactivated = true;
+	}
+	sta->plink_state = NL80211_PLINK_BLOCKED;
+	xrmac_mesh_path_flush_by_nexthop(sta);
+
+	return deactivated;
+}
+
+/**
+ * xrmac_mesh_plink_deactivate - deactivate mesh peer link
+ *
+ * @sta: mesh peer link to deactivate
+ *
+ * All mesh paths with this peer as next hop will be flushed
+ */
+void xrmac_mesh_plink_deactivate(struct sta_info *sta)
+{
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
+	bool deactivated;
+
+	spin_lock_bh(&sta->lock);
+	deactivated = __xrmac_mesh_plink_deactivate(sta);
+	sta->reason = cpu_to_le16(WLAN_REASON_MESH_PEER_CANCELED);
+	mesh_plink_frame_tx(sdata, WLAN_SP_MESH_PEERING_CLOSE,
+			    sta->sta.addr, sta->llid, sta->plid,
+			    sta->reason);
+	spin_unlock_bh(&sta->lock);
+
+	if (deactivated)
+		mac80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON);
+}
+
+static int mesh_plink_frame_tx(struct ieee80211_sub_if_data *sdata,
+		enum ieee80211_self_protected_actioncode action,
+		u8 *da, __le16 llid, __le16 plid, __le16 reason)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct sk_buff *skb = dev_alloc_skb(local->hw.extra_tx_headroom + 400 +
+			sdata->u.mesh.ie_len);
+	struct ieee80211_mgmt *mgmt;
+	bool include_plid = false;
+	int ie_len = 4;
+	u16 peering_proto = 0;
+	u8 *pos;
+
+	if (!skb)
+		return -1;
+	skb_reserve(skb, local->hw.extra_tx_headroom);
+	/* 25 is the size of the common mgmt part (24) plus the size of the
+	 * common action part (1)
+	 */
+	mgmt = (struct ieee80211_mgmt *)
+		skb_put(skb, 25 + sizeof(mgmt->u.action.u.self_prot));
+	memset(mgmt, 0, 25 + sizeof(mgmt->u.action.u.self_prot));
+	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+					  IEEE80211_STYPE_ACTION);
+	memcpy(mgmt->da, da, ETH_ALEN);
+	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
+	memcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);
+	mgmt->u.action.category = WLAN_CATEGORY_SELF_PROTECTED;
+	mgmt->u.action.u.self_prot.action_code = action;
+
+	if (action != WLAN_SP_MESH_PEERING_CLOSE) {
+		/* capability info */
+		pos = skb_put(skb, 2);
+		memset(pos, 0, 2);
+		if (action == WLAN_SP_MESH_PEERING_CONFIRM) {
+			/* AID */
+			pos = skb_put(skb, 2);
+			memcpy(pos + 2, &plid, 2);
+		}
+		if (mac80211_add_srates_ie(&sdata->vif, skb) ||
+		    mac80211_add_ext_srates_ie(&sdata->vif, skb) ||
+		    xrmac_mesh_add_rsn_ie(skb, sdata) ||
+		    xrmac_mesh_add_meshid_ie(skb, sdata) ||
+		    xrmac_mesh_add_meshconf_ie(skb, sdata))
+			return -1;
+	} else {	/* WLAN_SP_MESH_PEERING_CLOSE */
+		if (xrmac_mesh_add_meshid_ie(skb, sdata))
+			return -1;
+	}
+
+	/* Add Mesh Peering Management element */
+	switch (action) {
+	case WLAN_SP_MESH_PEERING_OPEN:
+		break;
+	case WLAN_SP_MESH_PEERING_CONFIRM:
+		ie_len += 2;
+		include_plid = true;
+		break;
+	case WLAN_SP_MESH_PEERING_CLOSE:
+		if (plid) {
+			ie_len += 2;
+			include_plid = true;
+		}
+		ie_len += 2;	/* reason code */
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (WARN_ON(skb_tailroom(skb) < 2 + ie_len))
+		return -ENOMEM;
+
+	pos = skb_put(skb, 2 + ie_len);
+	*pos++ = WLAN_EID_PEER_MGMT;
+	*pos++ = ie_len;
+	memcpy(pos, &peering_proto, 2);
+	pos += 2;
+	memcpy(pos, &llid, 2);
+	pos += 2;
+	if (include_plid) {
+		memcpy(pos, &plid, 2);
+		pos += 2;
+	}
+	if (action == WLAN_SP_MESH_PEERING_CLOSE) {
+		memcpy(pos, &reason, 2);
+		pos += 2;
+	}
+	if (xrmac_mesh_add_vendor_ies(skb, sdata))
+		return -1;
+
+	ieee80211_tx_skb(sdata, skb);
+	return 0;
+}
+
+void xrmac_mesh_neighbour_update(u8 *hw_addr, u32 rates,
+		struct ieee80211_sub_if_data *sdata,
+		struct ieee802_11_elems *elems)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sdata);
+	struct sta_info *sta;
+
+	rcu_read_lock();
+
+	sta = xrmac_sta_info_get(sdata, hw_addr);
+	if (!sta) {
+		rcu_read_unlock();
+		/* Userspace handles peer allocation when security is enabled
+		 * */
+		if (sdata->u.mesh.security & IEEE80211_MESH_SEC_AUTHED)
+			cfg80211_notify_new_peer_candidate(sdata->dev, hw_addr,
+					elems->ie_start, elems->total_len,
+					GFP_KERNEL);
+		else
+			sta = mesh_plink_alloc(sdata, hw_addr, rates);
+		if (!sta)
+			return;
+		if (xrmac_sta_info_insert_rcu(sta)) {
+			rcu_read_unlock();
+			return;
+		}
+	}
+
+	sta->last_rx = jiffies;
+	sta->sta.supp_rates[chan_state->conf.channel->band] = rates;
+	if (xrmac_mesh_peer_accepts_plinks(elems) &&
+			sta->plink_state == NL80211_PLINK_LISTEN &&
+			sdata->u.mesh.accepting_plinks &&
+			sdata->u.mesh.mshcfg.auto_open_plinks)
+		xrmac_mesh_plink_open(sta);
+
+	rcu_read_unlock();
+}
+
+static void mesh_plink_timer(unsigned long data)
+{
+	struct sta_info *sta;
+	__le16 llid, plid, reason;
+	struct ieee80211_sub_if_data *sdata;
+
+	/*
+	 * This STA is valid because sta_info_destroy() will
+	 * del_timer_sync() this timer after having made sure
+	 * it cannot be readded (by deleting the plink.)
+	 */
+	sta = (struct sta_info *) data;
+
+	if (sta->sdata->local->quiescing) {
+		sta->plink_timer_was_running = true;
+		return;
+	}
+
+	spin_lock_bh(&sta->lock);
+	if (sta->ignore_plink_timer) {
+		sta->ignore_plink_timer = false;
+		spin_unlock_bh(&sta->lock);
+		return;
+	}
+	mpl_dbg("Mesh plink timer for %pM fired on state %d\n",
+		sta->sta.addr, sta->plink_state);
+	reason = 0;
+	llid = sta->llid;
+	plid = sta->plid;
+	sdata = sta->sdata;
+
+	switch (sta->plink_state) {
+	case NL80211_PLINK_OPN_RCVD:
+	case NL80211_PLINK_OPN_SNT:
+		/* retry timer */
+		if (sta->plink_retries < dot11MeshMaxRetries(sdata)) {
+			u32 rand;
+			mpl_dbg("Mesh plink for %pM (retry, timeout): %d %d\n",
+				sta->sta.addr, sta->plink_retries,
+				sta->plink_timeout);
+			get_random_bytes(&rand, sizeof(u32));
+			sta->plink_timeout = sta->plink_timeout +
+					     rand % sta->plink_timeout;
+			++sta->plink_retries;
+			mod_plink_timer(sta, sta->plink_timeout);
+			spin_unlock_bh(&sta->lock);
+			mesh_plink_frame_tx(sdata, WLAN_SP_MESH_PEERING_OPEN,
+					    sta->sta.addr, llid, 0, 0);
+			break;
+		}
+		reason = cpu_to_le16(WLAN_REASON_MESH_MAX_RETRIES);
+		/* fall through on else */
+	case NL80211_PLINK_CNF_RCVD:
+		/* confirm timer */
+		if (!reason)
+			reason = cpu_to_le16(WLAN_REASON_MESH_CONFIRM_TIMEOUT);
+		sta->plink_state = NL80211_PLINK_HOLDING;
+		mod_plink_timer(sta, dot11MeshHoldingTimeout(sdata));
+		spin_unlock_bh(&sta->lock);
+		mesh_plink_frame_tx(sdata, WLAN_SP_MESH_PEERING_CLOSE,
+				    sta->sta.addr, llid, plid, reason);
+		break;
+	case NL80211_PLINK_HOLDING:
+		/* holding timer */
+		del_timer(&sta->plink_timer);
+		mesh_plink_fsm_restart(sta);
+		spin_unlock_bh(&sta->lock);
+		break;
+	default:
+		spin_unlock_bh(&sta->lock);
+		break;
+	}
+}
+
+#ifdef CONFIG_PM
+void xrmac_mesh_plink_quiesce(struct sta_info *sta)
+{
+	if (del_timer_sync(&sta->plink_timer))
+		sta->plink_timer_was_running = true;
+}
+
+void xrmac_mesh_plink_restart(struct sta_info *sta)
+{
+	if (sta->plink_timer_was_running) {
+		add_timer(&sta->plink_timer);
+		sta->plink_timer_was_running = false;
+	}
+}
+#endif
+
+static inline void mesh_plink_timer_set(struct sta_info *sta, int timeout)
+{
+	sta->plink_timer.expires = jiffies + (HZ * timeout / 1000);
+	sta->plink_timer.data = (unsigned long) sta;
+	sta->plink_timer.function = mesh_plink_timer;
+	sta->plink_timeout = timeout;
+	add_timer(&sta->plink_timer);
+}
+
+int xrmac_mesh_plink_open(struct sta_info *sta)
+{
+	__le16 llid;
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
+
+	if (!test_sta_flag(sta, WLAN_STA_AUTH))
+		return -EPERM;
+
+	spin_lock_bh(&sta->lock);
+	get_random_bytes(&llid, 2);
+	sta->llid = llid;
+	if (sta->plink_state != NL80211_PLINK_LISTEN) {
+		spin_unlock_bh(&sta->lock);
+		return -EBUSY;
+	}
+	sta->plink_state = NL80211_PLINK_OPN_SNT;
+	mesh_plink_timer_set(sta, dot11MeshRetryTimeout(sdata));
+	spin_unlock_bh(&sta->lock);
+	mpl_dbg("Mesh plink: starting establishment with %pM\n",
+		sta->sta.addr);
+
+	return mesh_plink_frame_tx(sdata, WLAN_SP_MESH_PEERING_OPEN,
+				   sta->sta.addr, llid, 0, 0);
+}
+
+void xrmac_mesh_plink_block(struct sta_info *sta)
+{
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
+	bool deactivated;
+
+	spin_lock_bh(&sta->lock);
+	deactivated = __xrmac_mesh_plink_deactivate(sta);
+	sta->plink_state = NL80211_PLINK_BLOCKED;
+	spin_unlock_bh(&sta->lock);
+
+	if (deactivated)
+		mac80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON);
+}
+
+
+void xrmac_mesh_rx_plink_frame(struct ieee80211_sub_if_data *sdata, struct ieee80211_mgmt *mgmt,
+			 size_t len, struct ieee80211_rx_status *rx_status)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee802_11_elems elems;
+	struct sta_info *sta;
+	enum plink_event event;
+	enum ieee80211_self_protected_actioncode ftype;
+	size_t baselen;
+	bool deactivated, matches_local = true;
+	u8 ie_len;
+	u8 *baseaddr;
+	__le16 plid, llid, reason;
+#ifdef CONFIG_XRMAC_VERBOSE_MPL_DEBUG
+	static const char *mplstates[] = {
+		[NL80211_PLINK_LISTEN] = "LISTEN",
+		[NL80211_PLINK_OPN_SNT] = "OPN-SNT",
+		[NL80211_PLINK_OPN_RCVD] = "OPN-RCVD",
+		[NL80211_PLINK_CNF_RCVD] = "CNF_RCVD",
+		[NL80211_PLINK_ESTAB] = "ESTAB",
+		[NL80211_PLINK_HOLDING] = "HOLDING",
+		[NL80211_PLINK_BLOCKED] = "BLOCKED"
+	};
+#endif
+
+	/* need action_code, aux */
+	if (len < IEEE80211_MIN_ACTION_SIZE + 3)
+		return;
+
+	if (is_multicast_ether_addr(mgmt->da)) {
+		mpl_dbg("Mesh plink: ignore frame from multicast address");
+		return;
+	}
+
+	baseaddr = mgmt->u.action.u.self_prot.variable;
+	baselen = (u8 *) mgmt->u.action.u.self_prot.variable - (u8 *) mgmt;
+	if (mgmt->u.action.u.self_prot.action_code ==
+						WLAN_SP_MESH_PEERING_CONFIRM) {
+		baseaddr += 4;
+		baselen += 4;
+	}
+	mac802_11_parse_elems(baseaddr, len - baselen, &elems);
+	if (!elems.peering) {
+		mpl_dbg("Mesh plink: missing necessary peer link ie\n");
+		return;
+	}
+	if (elems.rsn_len &&
+			sdata->u.mesh.security == IEEE80211_MESH_SEC_NONE) {
+		mpl_dbg("Mesh plink: can't establish link with secure peer\n");
+		return;
+	}
+
+	ftype = mgmt->u.action.u.self_prot.action_code;
+	ie_len = elems.peering_len;
+	if ((ftype == WLAN_SP_MESH_PEERING_OPEN && ie_len != 4) ||
+	    (ftype == WLAN_SP_MESH_PEERING_CONFIRM && ie_len != 6) ||
+	    (ftype == WLAN_SP_MESH_PEERING_CLOSE && ie_len != 6
+							&& ie_len != 8)) {
+		mpl_dbg("Mesh plink: incorrect plink ie length %d %d\n",
+		    ftype, ie_len);
+		return;
+	}
+
+	if (ftype != WLAN_SP_MESH_PEERING_CLOSE &&
+				(!elems.mesh_id || !elems.mesh_config)) {
+		mpl_dbg("Mesh plink: missing necessary ie\n");
+		return;
+	}
+	/* Note the lines below are correct, the llid in the frame is the plid
+	 * from the point of view of this host.
+	 */
+	memcpy(&plid, PLINK_GET_LLID(elems.peering), 2);
+	if (ftype == WLAN_SP_MESH_PEERING_CONFIRM ||
+	    (ftype == WLAN_SP_MESH_PEERING_CLOSE && ie_len == 8))
+		memcpy(&llid, PLINK_GET_PLID(elems.peering), 2);
+
+	rcu_read_lock();
+
+	sta = xrmac_sta_info_get(sdata, mgmt->sa);
+	if (!sta && ftype != WLAN_SP_MESH_PEERING_OPEN) {
+		mpl_dbg("Mesh plink: cls or cnf from unknown peer\n");
+		rcu_read_unlock();
+		return;
+	}
+
+	if (sta && !test_sta_flag(sta, WLAN_STA_AUTH)) {
+		mpl_dbg("Mesh plink: Action frame from non-authed peer\n");
+		rcu_read_unlock();
+		return;
+	}
+
+	if (sta && sta->plink_state == NL80211_PLINK_BLOCKED) {
+		rcu_read_unlock();
+		return;
+	}
+
+	/* Now we will figure out the appropriate event... */
+	event = PLINK_UNDEFINED;
+	if (ftype != WLAN_SP_MESH_PEERING_CLOSE &&
+	    (!xrmac_mesh_matches_local(&elems, sdata))) {
+		matches_local = false;
+		switch (ftype) {
+		case WLAN_SP_MESH_PEERING_OPEN:
+			event = OPN_RJCT;
+			break;
+		case WLAN_SP_MESH_PEERING_CONFIRM:
+			event = CNF_RJCT;
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (!sta && !matches_local) {
+		rcu_read_unlock();
+		reason = cpu_to_le16(WLAN_REASON_MESH_CONFIG);
+		llid = 0;
+		mesh_plink_frame_tx(sdata, WLAN_SP_MESH_PEERING_CLOSE,
+				    mgmt->sa, llid, plid, reason);
+		return;
+	} else if (!sta) {
+		/* ftype == WLAN_SP_MESH_PEERING_OPEN */
+		u32 rates;
+
+		rcu_read_unlock();
+
+		if (!mesh_plink_free_count(sdata)) {
+			mpl_dbg("Mesh plink error: no more free plinks\n");
+			return;
+		}
+
+		rates = mac80211_sta_get_rates(local, &elems, rx_status->band);
+		sta = mesh_plink_alloc(sdata, mgmt->sa, rates);
+		if (!sta) {
+			mpl_dbg("Mesh plink error: plink table full\n");
+			return;
+		}
+		if (xrmac_sta_info_insert_rcu(sta)) {
+			rcu_read_unlock();
+			return;
+		}
+		event = OPN_ACPT;
+		spin_lock_bh(&sta->lock);
+	} else if (matches_local) {
+		spin_lock_bh(&sta->lock);
+		switch (ftype) {
+		case WLAN_SP_MESH_PEERING_OPEN:
+			if (!mesh_plink_free_count(sdata) ||
+			    (sta->plid && sta->plid != plid))
+				event = OPN_IGNR;
+			else
+				event = OPN_ACPT;
+			break;
+		case WLAN_SP_MESH_PEERING_CONFIRM:
+			if (!mesh_plink_free_count(sdata) ||
+			    (sta->llid != llid || sta->plid != plid))
+				event = CNF_IGNR;
+			else
+				event = CNF_ACPT;
+			break;
+		case WLAN_SP_MESH_PEERING_CLOSE:
+			if (sta->plink_state == NL80211_PLINK_ESTAB)
+				/* Do not check for llid or plid. This does not
+				 * follow the standard but since multiple plinks
+				 * per sta are not supported, it is necessary in
+				 * order to avoid a livelock when MP A sees an
+				 * establish peer link to MP B but MP B does not
+				 * see it. This can be caused by a timeout in
+				 * B's peer link establishment or B beign
+				 * restarted.
+				 */
+				event = CLS_ACPT;
+			else if (sta->plid != plid)
+				event = CLS_IGNR;
+			else if (ie_len == 7 && sta->llid != llid)
+				event = CLS_IGNR;
+			else
+				event = CLS_ACPT;
+			break;
+		default:
+			mpl_dbg("Mesh plink: unknown frame subtype\n");
+			spin_unlock_bh(&sta->lock);
+			rcu_read_unlock();
+			return;
+		}
+	} else {
+		spin_lock_bh(&sta->lock);
+	}
+
+	mpl_dbg("Mesh plink (peer, state, llid, plid, event): %pM %s %d %d %d\n",
+		mgmt->sa, mplstates[sta->plink_state],
+		le16_to_cpu(sta->llid), le16_to_cpu(sta->plid),
+		event);
+	reason = 0;
+	switch (sta->plink_state) {
+		/* spin_unlock as soon as state is updated at each case */
+	case NL80211_PLINK_LISTEN:
+		switch (event) {
+		case CLS_ACPT:
+			mesh_plink_fsm_restart(sta);
+			spin_unlock_bh(&sta->lock);
+			break;
+		case OPN_ACPT:
+			sta->plink_state = NL80211_PLINK_OPN_RCVD;
+			sta->plid = plid;
+			get_random_bytes(&llid, 2);
+			sta->llid = llid;
+			mesh_plink_timer_set(sta, dot11MeshRetryTimeout(sdata));
+			spin_unlock_bh(&sta->lock);
+			mesh_plink_frame_tx(sdata,
+					    WLAN_SP_MESH_PEERING_OPEN,
+					    sta->sta.addr, llid, 0, 0);
+			mesh_plink_frame_tx(sdata,
+					    WLAN_SP_MESH_PEERING_CONFIRM,
+					    sta->sta.addr, llid, plid, 0);
+			break;
+		default:
+			spin_unlock_bh(&sta->lock);
+			break;
+		}
+		break;
+
+	case NL80211_PLINK_OPN_SNT:
+		switch (event) {
+		case OPN_RJCT:
+		case CNF_RJCT:
+			reason = cpu_to_le16(WLAN_REASON_MESH_CONFIG);
+		case CLS_ACPT:
+			if (!reason)
+				reason = cpu_to_le16(WLAN_REASON_MESH_CLOSE);
+			sta->reason = reason;
+			sta->plink_state = NL80211_PLINK_HOLDING;
+			if (!mod_plink_timer(sta,
+					     dot11MeshHoldingTimeout(sdata)))
+				sta->ignore_plink_timer = true;
+
+			llid = sta->llid;
+			spin_unlock_bh(&sta->lock);
+			mesh_plink_frame_tx(sdata,
+					    WLAN_SP_MESH_PEERING_CLOSE,
+					    sta->sta.addr, llid, plid, reason);
+			break;
+		case OPN_ACPT:
+			/* retry timer is left untouched */
+			sta->plink_state = NL80211_PLINK_OPN_RCVD;
+			sta->plid = plid;
+			llid = sta->llid;
+			spin_unlock_bh(&sta->lock);
+			mesh_plink_frame_tx(sdata,
+					    WLAN_SP_MESH_PEERING_CONFIRM,
+					    sta->sta.addr, llid, plid, 0);
+			break;
+		case CNF_ACPT:
+			sta->plink_state = NL80211_PLINK_CNF_RCVD;
+			if (!mod_plink_timer(sta,
+					     dot11MeshConfirmTimeout(sdata)))
+				sta->ignore_plink_timer = true;
+
+			spin_unlock_bh(&sta->lock);
+			break;
+		default:
+			spin_unlock_bh(&sta->lock);
+			break;
+		}
+		break;
+
+	case NL80211_PLINK_OPN_RCVD:
+		switch (event) {
+		case OPN_RJCT:
+		case CNF_RJCT:
+			reason = cpu_to_le16(WLAN_REASON_MESH_CONFIG);
+		case CLS_ACPT:
+			if (!reason)
+				reason = cpu_to_le16(WLAN_REASON_MESH_CLOSE);
+			sta->reason = reason;
+			sta->plink_state = NL80211_PLINK_HOLDING;
+			if (!mod_plink_timer(sta,
+					     dot11MeshHoldingTimeout(sdata)))
+				sta->ignore_plink_timer = true;
+
+			llid = sta->llid;
+			spin_unlock_bh(&sta->lock);
+			mesh_plink_frame_tx(sdata, WLAN_SP_MESH_PEERING_CLOSE,
+					    sta->sta.addr, llid, plid, reason);
+			break;
+		case OPN_ACPT:
+			llid = sta->llid;
+			spin_unlock_bh(&sta->lock);
+			mesh_plink_frame_tx(sdata,
+					    WLAN_SP_MESH_PEERING_CONFIRM,
+					    sta->sta.addr, llid, plid, 0);
+			break;
+		case CNF_ACPT:
+			del_timer(&sta->plink_timer);
+			sta->plink_state = NL80211_PLINK_ESTAB;
+			spin_unlock_bh(&sta->lock);
+			mesh_plink_inc_estab_count(sdata);
+			mac80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON);
+			mpl_dbg("Mesh plink with %pM ESTABLISHED\n",
+				sta->sta.addr);
+			break;
+		default:
+			spin_unlock_bh(&sta->lock);
+			break;
+		}
+		break;
+
+	case NL80211_PLINK_CNF_RCVD:
+		switch (event) {
+		case OPN_RJCT:
+		case CNF_RJCT:
+			reason = cpu_to_le16(WLAN_REASON_MESH_CONFIG);
+		case CLS_ACPT:
+			if (!reason)
+				reason = cpu_to_le16(WLAN_REASON_MESH_CLOSE);
+			sta->reason = reason;
+			sta->plink_state = NL80211_PLINK_HOLDING;
+			if (!mod_plink_timer(sta,
+					     dot11MeshHoldingTimeout(sdata)))
+				sta->ignore_plink_timer = true;
+
+			llid = sta->llid;
+			spin_unlock_bh(&sta->lock);
+			mesh_plink_frame_tx(sdata,
+					    WLAN_SP_MESH_PEERING_CLOSE,
+					    sta->sta.addr, llid, plid, reason);
+			break;
+		case OPN_ACPT:
+			del_timer(&sta->plink_timer);
+			sta->plink_state = NL80211_PLINK_ESTAB;
+			spin_unlock_bh(&sta->lock);
+			mesh_plink_inc_estab_count(sdata);
+			mac80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON);
+			mpl_dbg("Mesh plink with %pM ESTABLISHED\n",
+				sta->sta.addr);
+			mesh_plink_frame_tx(sdata,
+					    WLAN_SP_MESH_PEERING_CONFIRM,
+					    sta->sta.addr, llid, plid, 0);
+			break;
+		default:
+			spin_unlock_bh(&sta->lock);
+			break;
+		}
+		break;
+
+	case NL80211_PLINK_ESTAB:
+		switch (event) {
+		case CLS_ACPT:
+			reason = cpu_to_le16(WLAN_REASON_MESH_CLOSE);
+			sta->reason = reason;
+			deactivated = __xrmac_mesh_plink_deactivate(sta);
+			sta->plink_state = NL80211_PLINK_HOLDING;
+			llid = sta->llid;
+			mod_plink_timer(sta, dot11MeshHoldingTimeout(sdata));
+			spin_unlock_bh(&sta->lock);
+			if (deactivated)
+				mac80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON);
+			mesh_plink_frame_tx(sdata, WLAN_SP_MESH_PEERING_CLOSE,
+					    sta->sta.addr, llid, plid, reason);
+			break;
+		case OPN_ACPT:
+			llid = sta->llid;
+			spin_unlock_bh(&sta->lock);
+			mesh_plink_frame_tx(sdata,
+					    WLAN_SP_MESH_PEERING_CONFIRM,
+					    sta->sta.addr, llid, plid, 0);
+			break;
+		default:
+			spin_unlock_bh(&sta->lock);
+			break;
+		}
+		break;
+	case NL80211_PLINK_HOLDING:
+		switch (event) {
+		case CLS_ACPT:
+			if (del_timer(&sta->plink_timer))
+				sta->ignore_plink_timer = 1;
+			mesh_plink_fsm_restart(sta);
+			spin_unlock_bh(&sta->lock);
+			break;
+		case OPN_ACPT:
+		case CNF_ACPT:
+		case OPN_RJCT:
+		case CNF_RJCT:
+			llid = sta->llid;
+			reason = sta->reason;
+			spin_unlock_bh(&sta->lock);
+			mesh_plink_frame_tx(sdata, WLAN_SP_MESH_PEERING_CLOSE,
+					    sta->sta.addr, llid, plid, reason);
+			break;
+		default:
+			spin_unlock_bh(&sta->lock);
+		}
+		break;
+	default:
+		/* should not get here, PLINK_BLOCKED is dealt with at the
+		 * beginning of the function
+		 */
+		spin_unlock_bh(&sta->lock);
+		break;
+	}
+
+	rcu_read_unlock();
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/michael.c b/drivers/net/wireless/xr829/umac/michael.c
--- a/drivers/net/wireless/xr829/umac/michael.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/michael.c	2022-08-27 01:22:42.946539832 +0300
@@ -0,0 +1,86 @@
+/*
+ * Michael MIC implementation - optimized for TKIP MIC operations
+ * Copyright 2002-2003, Instant802 Networks, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/types.h>
+#include <linux/bitops.h>
+#include <linux/ieee80211.h>
+#include <asm/unaligned.h>
+
+#include "michael.h"
+
+static void michael_block(struct xrmac_michael_mic_ctx *mctx, u32 val)
+{
+	mctx->l ^= val;
+	mctx->r ^= rol32(mctx->l, 17);
+	mctx->l += mctx->r;
+	mctx->r ^= ((mctx->l & 0xff00ff00) >> 8) |
+		   ((mctx->l & 0x00ff00ff) << 8);
+	mctx->l += mctx->r;
+	mctx->r ^= rol32(mctx->l, 3);
+	mctx->l += mctx->r;
+	mctx->r ^= ror32(mctx->l, 2);
+	mctx->l += mctx->r;
+}
+
+static void xrmac_michael_mic_hdr(struct xrmac_michael_mic_ctx *mctx, const u8 *key,
+			    struct ieee80211_hdr *hdr)
+{
+	u8 *da, *sa, tid;
+
+	da = ieee80211_get_DA(hdr);
+	sa = ieee80211_get_SA(hdr);
+	if (ieee80211_is_data_qos(hdr->frame_control))
+		tid = *ieee80211_get_qos_ctl(hdr) & IEEE80211_QOS_CTL_TID_MASK;
+	else
+		tid = 0;
+
+	mctx->l = get_unaligned_le32(key);
+	mctx->r = get_unaligned_le32(key + 4);
+
+	/*
+	 * A pseudo header (DA, SA, Priority, 0, 0, 0) is used in Michael MIC
+	 * calculation, but it is _not_ transmitted
+	 */
+	michael_block(mctx, get_unaligned_le32(da));
+	michael_block(mctx, get_unaligned_le16(&da[4]) |
+			    (get_unaligned_le16(sa) << 16));
+	michael_block(mctx, get_unaligned_le32(&sa[2]));
+	michael_block(mctx, tid);
+}
+
+void xrmac_michael_mic(const u8 *key, struct ieee80211_hdr *hdr,
+		 const u8 *data, size_t data_len, u8 *mic)
+{
+	u32 val;
+	size_t block, blocks, left;
+	struct xrmac_michael_mic_ctx mctx;
+
+	xrmac_michael_mic_hdr(&mctx, key, hdr);
+
+	/* Real data */
+	blocks = data_len / 4;
+	left = data_len % 4;
+
+	for (block = 0; block < blocks; block++)
+		michael_block(&mctx, get_unaligned_le32(&data[block * 4]));
+
+	/* Partial block of 0..3 bytes and padding: 0x5a + 4..7 zeros to make
+	 * total length a multiple of 4. */
+	val = 0x5a;
+	while (left > 0) {
+		val <<= 8;
+		left--;
+		val |= data[blocks * 4 + left];
+	}
+
+	michael_block(&mctx, val);
+	michael_block(&mctx, 0);
+
+	put_unaligned_le32(mctx.l, mic);
+	put_unaligned_le32(mctx.r, mic + 4);
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/michael.h b/drivers/net/wireless/xr829/umac/michael.h
--- a/drivers/net/wireless/xr829/umac/michael.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/michael.h	2022-08-27 01:22:42.946539832 +0300
@@ -0,0 +1,24 @@
+/*
+ * Michael MIC implementation - optimized for TKIP MIC operations
+ * Copyright 2002-2003, Instant802 Networks, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef MICHAEL_H
+#define MICHAEL_H
+
+#include <linux/types.h>
+
+#define MICHAEL_MIC_LEN 8
+
+struct xrmac_michael_mic_ctx {
+	u32 l, r;
+};
+
+void xrmac_michael_mic(const u8 *key, struct ieee80211_hdr *hdr,
+		 const u8 *data, size_t data_len, u8 *mic);
+
+#endif /* MICHAEL_H */
diff -Naurp a/drivers/net/wireless/xr829/umac/mlme.c b/drivers/net/wireless/xr829/umac/mlme.c
--- a/drivers/net/wireless/xr829/umac/mlme.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/mlme.c	2022-08-27 01:22:42.950539847 +0300
@@ -0,0 +1,3162 @@
+/*
+ * BSS client mode implementation
+ * Copyright 2003-2008, Jouni Malinen <j@w1.fi>
+ * Copyright 2004, Instant802 Networks, Inc.
+ * Copyright 2005, Devicescape Software, Inc.
+ * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
+ * Copyright 2007, Michael Wu <flamingice@sourmilk.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <generated/uapi/linux/version.h>
+#include <linux/delay.h>
+#include <linux/fips.h>
+#include <linux/if_ether.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/etherdevice.h>
+#include <linux/moduleparam.h>
+#include <linux/rtnetlink.h>
+#include <linux/pm_qos.h>
+#include <linux/crc32.h>
+#include <linux/slab.h>
+#include <linux/export.h>
+#include <net/mac80211.h>
+#include <asm/unaligned.h>
+
+#include "ieee80211_i.h"
+#include "driver-ops.h"
+#include "rate.h"
+#include "led.h"
+
+static int max_nullfunc_tries = 2;
+module_param(max_nullfunc_tries, int, 0644);
+MODULE_PARM_DESC(max_nullfunc_tries,
+		 "Maximum nullfunc tx tries before disconnecting (reason 4).");
+
+static int max_probe_tries = 5;
+module_param(max_probe_tries, int, 0644);
+MODULE_PARM_DESC(max_probe_tries,
+		 "Maximum probe tries before disconnecting (reason 4).");
+
+/*
+ * Beacon loss timeout is calculated as N frames times the
+ * advertised beacon interval.  This may need to be somewhat
+ * higher than what hardware might detect to account for
+ * delays in the host processing frames. But since we also
+ * probe on beacon miss before declaring the connection lost
+ * default to what we want.
+ */
+#define IEEE80211_BEACON_LOSS_COUNT	7
+
+/*
+ * Time the connection can be idle before we probe
+ * it to see if we can still talk to the AP.
+ */
+#define IEEE80211_CONNECTION_IDLE_TIME	(30 * HZ)
+/*
+ * Time we wait for a probe response after sending
+ * a probe request because of beacon loss or for
+ * checking the connection still works.
+ */
+static int probe_wait_ms = 500;
+module_param(probe_wait_ms, int, 0644);
+MODULE_PARM_DESC(probe_wait_ms,
+		 "Maximum time(ms) to wait for probe response"
+		 " before disconnecting (reason 4).");
+
+/*
+ * Weight given to the latest Beacon frame when calculating average signal
+ * strength for Beacon frames received in the current BSS. This must be
+ * between 1 and 15.
+ */
+#define IEEE80211_SIGNAL_AVE_WEIGHT	3
+
+/*
+ * How many Beacon frames need to have been used in average signal strength
+ * before starting to indicate signal change events.
+ */
+#define IEEE80211_SIGNAL_AVE_MIN_COUNT	4
+
+#define TMR_RUNNING_TIMER	0
+#define TMR_RUNNING_CHANSW	1
+
+/*
+ * All cfg80211 functions have to be called outside a locked
+ * section so that they can acquire a lock themselves... This
+ * is much simpler than queuing up things in cfg80211, but we
+ * do need some indirection for that here.
+ */
+enum rx_mgmt_action {
+	/* no action required */
+	RX_MGMT_NONE,
+
+	/* caller must call cfg80211_send_deauth() */
+	RX_MGMT_CFG80211_DEAUTH,
+
+	/* caller must call cfg80211_send_disassoc() */
+	RX_MGMT_CFG80211_DISASSOC,
+};
+
+/* utils */
+static inline void ASSERT_MGD_MTX(struct ieee80211_if_managed *ifmgd)
+{
+	lockdep_assert_held(&ifmgd->mtx);
+}
+
+/*
+ * We can have multiple work items (and connection probing)
+ * scheduling this timer, but we need to take care to only
+ * reschedule it when it should fire _earlier_ than it was
+ * asked for before, or if it's not pending right now. This
+ * function ensures that. Note that it then is required to
+ * run this function for all timeouts after the first one
+ * has happened -- the work that runs from this timer will
+ * do that.
+ */
+static void run_again(struct ieee80211_if_managed *ifmgd,
+			     unsigned long timeout)
+{
+	ASSERT_MGD_MTX(ifmgd);
+
+	if (!timer_pending(&ifmgd->timer) ||
+	    time_before(timeout, ifmgd->timer.expires))
+		mod_timer(&ifmgd->timer, timeout);
+}
+
+void mac80211_sta_reset_beacon_monitor(struct ieee80211_sub_if_data *sdata)
+{
+	if (sdata->local->hw.flags & IEEE80211_HW_BEACON_FILTER)
+		return;
+
+	mod_timer(&sdata->u.mgd.bcn_mon_timer,
+		  round_jiffies_up(jiffies + sdata->u.mgd.beacon_timeout));
+}
+
+void mac80211_sta_reset_conn_monitor(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+
+	if (unlikely(!sdata->u.mgd.associated))
+		return;
+
+	if (sdata->local->hw.flags & IEEE80211_HW_CONNECTION_MONITOR)
+		return;
+
+	mod_timer(&sdata->u.mgd.conn_mon_timer,
+		  round_jiffies_up(jiffies + IEEE80211_CONNECTION_IDLE_TIME));
+
+	ifmgd->probe_send_count = 0;
+}
+
+static int ecw2cw(int ecw)
+{
+	return (1 << ecw) - 1;
+}
+
+/*
+ * ieee80211_enable_ht should be called only after the operating band
+ * has been determined as ht configuration depends on the hw's
+ * HT abilities for a specific band.
+ */
+static u32 ieee80211_enable_ht(struct ieee80211_sub_if_data *sdata,
+				struct ieee80211_ht_operation *hti,
+				const u8 *bssid, u16 ap_ht_cap_flags,
+				bool beacon_htcap_ie)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sdata);
+	struct ieee80211_supported_band *sband;
+	struct sta_info *sta;
+	u32 changed = 0;
+	int hti_cfreq;
+	u16 ht_opmode;
+	bool enable_ht = true;
+	enum nl80211_channel_type prev_chantype;
+	enum nl80211_channel_type channel_type = NL80211_CHAN_NO_HT;
+
+	sband = local->hw.wiphy->bands[chan_state->conf.channel->band];
+
+	prev_chantype = sdata->vif.bss_conf.channel_type;
+
+	/* HT is not supported */
+	if (!sband->ht_cap.ht_supported)
+		enable_ht = false;
+
+	if (enable_ht) {
+		hti_cfreq = ieee80211_channel_to_frequency(hti->primary_chan,
+							   sband->band);
+		/* check that channel matches the right operating channel */
+		if (chan_state->conf.channel->center_freq != hti_cfreq) {
+			/* Some APs mess this up, evidently.
+			 * Netgear WNDR3700 sometimes reports 4 higher than
+			 * the actual channel, for instance.
+			 */
+			printk(KERN_DEBUG
+			       "%s: Wrong control channel in association"
+			       " response: configured center-freq: %d"
+			       " hti-cfreq: %d  hti->primary_chan: %d"
+			       " band: %d.  Disabling HT.\n",
+			       sdata->name,
+			       chan_state->conf.channel->center_freq,
+			       hti_cfreq, hti->primary_chan,
+			       sband->band);
+			enable_ht = false;
+		}
+	}
+
+	if (enable_ht) {
+		channel_type = NL80211_CHAN_HT20;
+
+		if (!(ap_ht_cap_flags & IEEE80211_HT_CAP_40MHZ_INTOLERANT) &&
+		    (sband->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40) &&
+		    (hti->ht_param & IEEE80211_HT_PARAM_CHAN_WIDTH_ANY)) {
+			switch (hti->ht_param & IEEE80211_HT_PARAM_CHA_SEC_OFFSET) {
+			case IEEE80211_HT_PARAM_CHA_SEC_ABOVE:
+				if (!(chan_state->conf.channel->flags &
+				    IEEE80211_CHAN_NO_HT40PLUS))
+					channel_type = NL80211_CHAN_HT40PLUS;
+				break;
+			case IEEE80211_HT_PARAM_CHA_SEC_BELOW:
+				if (!(chan_state->conf.channel->flags &
+				    IEEE80211_CHAN_NO_HT40MINUS))
+					channel_type = NL80211_CHAN_HT40MINUS;
+				break;
+			}
+		}
+	}
+
+	if (chan_state->tmp_channel)
+		chan_state->tmp_channel_type = channel_type;
+
+	if (!mac80211_set_channel_type(local, sdata, channel_type)) {
+		/* can only fail due to HT40+/- mismatch */
+		channel_type = NL80211_CHAN_HT20;
+		WARN_ON(!mac80211_set_channel_type(local, sdata, channel_type));
+	}
+
+	if (beacon_htcap_ie && (prev_chantype != channel_type)) {
+		/*
+		 * Whenever the AP announces the HT mode change that can be
+		 * 40MHz intolerant or etc., it would be safer to stop tx
+		 * queues before doing hw config to avoid buffer overflow.
+		 */
+		mac80211_stop_queues_by_reason(&sdata->local->hw,
+				IEEE80211_QUEUE_STOP_REASON_CHTYPE_CHANGE);
+
+		/* flush out all packets */
+		synchronize_net();
+
+		drv_flush(local, sdata, false);
+	}
+
+	/* channel_type change automatically detected */
+	mac80211_hw_config(local, 0);
+
+	if (prev_chantype != channel_type) {
+		rcu_read_lock();
+		sta = xrmac_sta_info_get(sdata, bssid);
+		if (sta)
+			rate_control_rate_update(local, sband, sta,
+						 IEEE80211_RC_HT_CHANGED,
+						 channel_type);
+		rcu_read_unlock();
+
+		if (beacon_htcap_ie)
+			mac80211_wake_queues_by_reason(&sdata->local->hw,
+				IEEE80211_QUEUE_STOP_REASON_CHTYPE_CHANGE);
+	}
+
+	ht_opmode = le16_to_cpu(hti->operation_mode);
+
+	/* if bss configuration changed store the new one */
+	if (sdata->ht_opmode_valid != enable_ht ||
+	    sdata->vif.bss_conf.ht_operation_mode != ht_opmode ||
+	    prev_chantype != channel_type) {
+		changed |= BSS_CHANGED_HT;
+		sdata->vif.bss_conf.ht_operation_mode = ht_opmode;
+		sdata->ht_opmode_valid = enable_ht;
+	}
+
+	return changed;
+}
+
+/* frame sending functions */
+
+static void ieee80211_send_deauth_disassoc(struct ieee80211_sub_if_data *sdata,
+					   const u8 *bssid, u16 stype, u16 reason,
+					   void *cookie, bool send_frame)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+	struct sk_buff *skb;
+	struct ieee80211_mgmt *mgmt;
+
+	skb = dev_alloc_skb(local->hw.extra_tx_headroom + sizeof(*mgmt));
+	if (!skb)
+		return;
+
+	skb_reserve(skb, local->hw.extra_tx_headroom);
+
+	mgmt = (struct ieee80211_mgmt *) skb_put(skb, 24);
+	memset(mgmt, 0, 24);
+	memcpy(mgmt->da, bssid, ETH_ALEN);
+	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
+	memcpy(mgmt->bssid, bssid, ETH_ALEN);
+	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT | stype);
+	skb_put(skb, 2);
+	/* u.deauth.reason_code == u.disassoc.reason_code */
+	mgmt->u.deauth.reason_code = cpu_to_le16(reason);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+		cfg80211_tx_mlme_mgmt(sdata->dev, (u8 *)mgmt, skb->len);
+#else
+	if (stype == IEEE80211_STYPE_DEAUTH)
+		if (cookie)
+			__cfg80211_send_deauth(sdata->dev, (u8 *)mgmt, skb->len);
+		else
+			cfg80211_send_deauth(sdata->dev, (u8 *)mgmt, skb->len);
+	else
+		if (cookie)
+			__cfg80211_send_disassoc(sdata->dev, (u8 *)mgmt, skb->len);
+		else
+			cfg80211_send_disassoc(sdata->dev, (u8 *)mgmt, skb->len);
+#endif
+
+	if (!(ifmgd->flags & IEEE80211_STA_MFP_ENABLED))
+		IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
+
+	if (send_frame)
+		ieee80211_tx_skb(sdata, skb);
+	else
+		kfree_skb(skb);
+}
+
+void mac80211_send_pspoll(struct ieee80211_local *local,
+			   struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_pspoll *pspoll;
+	struct sk_buff *skb;
+
+	skb = mac80211_pspoll_get(&local->hw, &sdata->vif);
+	if (!skb)
+		return;
+
+	pspoll = (struct ieee80211_pspoll *) skb->data;
+	pspoll->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);
+
+	IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
+	ieee80211_tx_skb(sdata, skb);
+}
+
+void mac80211_send_nullfunc(struct ieee80211_local *local,
+			     struct ieee80211_sub_if_data *sdata,
+			     int powersave)
+{
+	struct sk_buff *skb;
+	struct ieee80211_hdr_3addr *nullfunc;
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+
+	skb = mac80211_nullfunc_get(&local->hw, &sdata->vif);
+	if (!skb)
+		return;
+
+	nullfunc = (struct ieee80211_hdr_3addr *) skb->data;
+	if (powersave)
+		nullfunc->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);
+
+	IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
+	if (ifmgd->flags & (IEEE80211_STA_BEACON_POLL |
+			    IEEE80211_STA_CONNECTION_POLL))
+		IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_CTL_USE_MINRATE;
+
+	ieee80211_tx_skb(sdata, skb);
+}
+
+static void ieee80211_send_4addr_nullfunc(struct ieee80211_local *local,
+					  struct ieee80211_sub_if_data *sdata)
+{
+	struct sk_buff *skb;
+	struct ieee80211_hdr *nullfunc;
+	__le16 fc;
+
+	if (WARN_ON(sdata->vif.type != NL80211_IFTYPE_STATION))
+		return;
+
+	skb = dev_alloc_skb(local->hw.extra_tx_headroom + 30);
+	if (!skb)
+		return;
+
+	skb_reserve(skb, local->hw.extra_tx_headroom);
+
+	nullfunc = (struct ieee80211_hdr *) skb_put(skb, 30);
+	memset(nullfunc, 0, 30);
+	fc = cpu_to_le16(IEEE80211_FTYPE_DATA | IEEE80211_STYPE_NULLFUNC |
+			 IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS);
+	nullfunc->frame_control = fc;
+	memcpy(nullfunc->addr1, sdata->u.mgd.bssid, ETH_ALEN);
+	memcpy(nullfunc->addr2, sdata->vif.addr, ETH_ALEN);
+	memcpy(nullfunc->addr3, sdata->u.mgd.bssid, ETH_ALEN);
+	memcpy(nullfunc->addr4, sdata->vif.addr, ETH_ALEN);
+
+	IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
+	ieee80211_tx_skb(sdata, skb);
+}
+
+/* spectrum management related things */
+static void ieee80211_chswitch_work(struct work_struct *work)
+{
+	struct ieee80211_sub_if_data *sdata =
+		container_of(work, struct ieee80211_sub_if_data, u.mgd.chswitch_work);
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(sdata->local, sdata);
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+
+	if (!ieee80211_sdata_running(sdata))
+		return;
+
+	mutex_lock(&ifmgd->mtx);
+	if (!ifmgd->associated)
+		goto out;
+
+	chan_state->oper_channel = chan_state->csa_channel;
+	if (!sdata->local->ops->channel_switch) {
+		/* call "hw_config" only if doing sw channel switch */
+		mac80211_hw_config(sdata->local,
+			IEEE80211_CONF_CHANGE_CHANNEL);
+	} else {
+		/* update the device channel directly */
+		chan_state->conf.channel = chan_state->oper_channel;
+	}
+
+	/* XXX: shouldn't really modify cfg80211-owned data! */
+	ifmgd->associated->channel = chan_state->oper_channel;
+
+	mac80211_wake_queues_by_reason(&sdata->local->hw,
+					IEEE80211_QUEUE_STOP_REASON_CSA);
+ out:
+	ifmgd->flags &= ~IEEE80211_STA_CSA_RECEIVED;
+	mutex_unlock(&ifmgd->mtx);
+}
+
+void mac80211_chswitch_done(struct ieee80211_vif *vif, bool success)
+{
+	struct ieee80211_channel_state *chan_state;
+	struct ieee80211_sub_if_data *sdata;
+	struct ieee80211_if_managed *ifmgd;
+
+	sdata = vif_to_sdata(vif);
+	chan_state = ieee80211_get_channel_state(sdata->local, sdata);
+	ifmgd = &sdata->u.mgd;
+
+	trace_api_chswitch_done(sdata, success);
+	if (!success) {
+		/*
+		 * If the channel switch was not successful, stay
+		 * around on the old channel. We currently lack
+		 * good handling of this situation, possibly we
+		 * should just drop the association.
+		 */
+		chan_state->csa_channel = chan_state->oper_channel;
+	}
+
+	mac80211_queue_work(&sdata->local->hw, &ifmgd->chswitch_work);
+}
+
+static void ieee80211_chswitch_timer(struct timer_list *t)
+{
+	struct ieee80211_sub_if_data *sdata =
+		from_timer(sdata, t, u.mgd.chswitch_timer);
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+
+	if (sdata->local->quiescing) {
+		set_bit(TMR_RUNNING_CHANSW, &ifmgd->timers_running);
+		return;
+	}
+
+	mac80211_queue_work(&sdata->local->hw, &ifmgd->chswitch_work);
+}
+
+void mac80211_sta_process_chanswitch(struct ieee80211_sub_if_data *sdata,
+				      struct ieee80211_channel_sw_ie *sw_elem,
+				      struct ieee80211_bss *bss,
+				      u64 timestamp)
+{
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(sdata->local, sdata);
+	struct cfg80211_bss *cbss =
+		container_of((void *)bss, struct cfg80211_bss, priv);
+	struct ieee80211_channel *new_ch;
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+	int new_freq = ieee80211_channel_to_frequency(sw_elem->new_ch_num,
+						      cbss->channel->band);
+
+	ASSERT_MGD_MTX(ifmgd);
+
+	if (!ifmgd->associated)
+		return;
+
+	if (sdata->local->scanning)
+		return;
+
+	/* Disregard subsequent beacons if we are already running a timer
+	   processing a CSA */
+
+	if (ifmgd->flags & IEEE80211_STA_CSA_RECEIVED)
+		return;
+
+	new_ch = ieee80211_get_channel(sdata->local->hw.wiphy, new_freq);
+	if (!new_ch || new_ch->flags & IEEE80211_CHAN_DISABLED)
+		return;
+
+	chan_state->csa_channel = new_ch;
+
+	if (sdata->local->ops->channel_switch) {
+		/* use driver's channel switch callback */
+		struct ieee80211_channel_switch ch_switch;
+		memset(&ch_switch, 0, sizeof(ch_switch));
+		ch_switch.timestamp = timestamp;
+		if (sw_elem->mode) {
+			ch_switch.block_tx = true;
+			mac80211_stop_queues_by_reason(&sdata->local->hw,
+					IEEE80211_QUEUE_STOP_REASON_CSA);
+		}
+		ch_switch.channel = new_ch;
+		ch_switch.count = sw_elem->count;
+		ifmgd->flags |= IEEE80211_STA_CSA_RECEIVED;
+		drv_channel_switch(sdata->local, &ch_switch);
+		return;
+	}
+
+	/* channel switch handled in software */
+	if (sw_elem->count <= 1) {
+		mac80211_queue_work(&sdata->local->hw, &ifmgd->chswitch_work);
+	} else {
+		if (sw_elem->mode)
+			mac80211_stop_queues_by_reason(&sdata->local->hw,
+					IEEE80211_QUEUE_STOP_REASON_CSA);
+		ifmgd->flags |= IEEE80211_STA_CSA_RECEIVED;
+		mod_timer(&ifmgd->chswitch_timer,
+			  jiffies +
+			  msecs_to_jiffies(sw_elem->count *
+					   cbss->beacon_interval));
+	}
+}
+
+static void ieee80211_handle_pwr_constr(struct ieee80211_sub_if_data *sdata,
+					u16 capab_info, u8 *pwr_constr_elem,
+					u8 pwr_constr_elem_len)
+{
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(sdata->local, sdata);
+
+	if (!(capab_info & WLAN_CAPABILITY_SPECTRUM_MGMT))
+		return;
+
+	/* Power constraint IE length should be 1 octet */
+	if (pwr_constr_elem_len != 1)
+		return;
+
+	if ((*pwr_constr_elem <= chan_state->conf.channel->max_power) &&
+	    (*pwr_constr_elem != sdata->local->power_constr_level)) {
+		sdata->local->power_constr_level = *pwr_constr_elem;
+		mac80211_hw_config(sdata->local, 0);
+	}
+}
+
+void mac80211_enable_dyn_ps(struct ieee80211_vif *vif)
+{
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_bss_conf *conf = &sdata->vif.bss_conf;
+
+	WARN_ON(sdata->vif.type != NL80211_IFTYPE_STATION ||
+		!(local->hw.flags & IEEE80211_HW_SUPPORTS_PS) ||
+		(local->hw.flags & IEEE80211_HW_SUPPORTS_DYNAMIC_PS));
+
+	sdata->disable_dynamic_ps = false;
+	conf->dynamic_ps_timeout = sdata->dynamic_ps_user_timeout;
+}
+
+void mac80211_disable_dyn_ps(struct ieee80211_vif *vif)
+{
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_bss_conf *conf = &sdata->vif.bss_conf;
+
+	WARN_ON(sdata->vif.type != NL80211_IFTYPE_STATION ||
+		!(local->hw.flags & IEEE80211_HW_SUPPORTS_PS) ||
+		(local->hw.flags & IEEE80211_HW_SUPPORTS_DYNAMIC_PS));
+
+	sdata->disable_dynamic_ps = true;
+	conf->dynamic_ps_timeout = 0;
+	del_timer_sync(&sdata->dynamic_ps_timer);
+	mac80211_queue_work(&local->hw,
+			     &sdata->dynamic_ps_enable_work);
+}
+
+/* powersave */
+static void ieee80211_enable_ps(struct ieee80211_local *local,
+				struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_bss_conf *conf = &sdata->vif.bss_conf;
+
+	/*
+	 * If we are scanning right now then the parameters will
+	 * take effect when scan finishes.
+	 */
+	if (local->scanning) /* XXX: investigate this codepath */
+		return;
+
+	if (conf->dynamic_ps_timeout > 0 &&
+	    !(local->hw.flags & IEEE80211_HW_SUPPORTS_DYNAMIC_PS)) {
+		mod_timer(&sdata->dynamic_ps_timer, jiffies +
+			  msecs_to_jiffies(conf->dynamic_ps_timeout));
+	} else {
+		if (local->hw.flags & IEEE80211_HW_PS_NULLFUNC_STACK)
+			mac80211_send_nullfunc(local, sdata, 1);
+
+		if ((local->hw.flags & IEEE80211_HW_PS_NULLFUNC_STACK) &&
+		    (local->hw.flags & IEEE80211_HW_REPORTS_TX_ACK_STATUS))
+			return;
+
+		conf->ps_enabled = true;
+		mac80211_bss_info_change_notify(sdata, BSS_CHANGED_PS);
+	}
+}
+
+static void ieee80211_change_ps(struct ieee80211_local *local)
+{
+	struct ieee80211_sub_if_data *sdata;
+
+	/* XXX: This needs to be verified */
+	list_for_each_entry(sdata, &local->interfaces, list) {
+		if (sdata->ps_allowed) {
+			ieee80211_enable_ps(local, sdata);
+		} else if (sdata->vif.bss_conf.ps_enabled) {
+			sdata->vif.bss_conf.ps_enabled = false;
+			mac80211_bss_info_change_notify(sdata, BSS_CHANGED_PS);
+			del_timer_sync(&sdata->dynamic_ps_timer);
+			cancel_work_sync(&sdata->dynamic_ps_enable_work);
+		}
+	}
+}
+
+static bool ieee80211_powersave_allowed(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_managed *mgd = &sdata->u.mgd;
+	struct sta_info *sta = NULL;
+	bool authorized = false;
+
+	if (!mgd->powersave)
+		return false;
+
+	if (mgd->broken_ap)
+		return false;
+
+	if (!mgd->associated)
+		return false;
+
+	if (!mgd->associated->beacon_ies)
+		return false;
+
+	if (mgd->flags & (IEEE80211_STA_BEACON_POLL |
+			  IEEE80211_STA_CONNECTION_POLL))
+		return false;
+
+	rcu_read_lock();
+	sta = xrmac_sta_info_get(sdata, mgd->bssid);
+	if (sta)
+		authorized = test_sta_flag(sta, WLAN_STA_AUTHORIZED);
+	rcu_read_unlock();
+
+	return authorized;
+}
+
+/* need to hold RTNL or interface lock */
+void mac80211_recalc_ps(struct ieee80211_local *local, s32 latency)
+{
+	struct ieee80211_sub_if_data *sdata;
+	struct ieee80211_bss_conf *conf;
+	struct ieee80211_work *wk;
+	int timeout;
+	s32 beaconint_us;
+
+	if (!(local->hw.flags & IEEE80211_HW_SUPPORTS_PS)) {
+		list_for_each_entry(sdata, &local->interfaces, list)
+			sdata->ps_allowed = false;
+		return;
+	}
+
+	if (!list_empty(&local->work_list)) {
+		list_for_each_entry(wk, &local->work_list, list)
+			wk->sdata->ps_allowed = false;
+		goto change;
+	}
+
+	list_for_each_entry(sdata, &local->interfaces, list) {
+		if (!ieee80211_sdata_running(sdata))
+			continue;
+		if (sdata->vif.type == NL80211_IFTYPE_AP) {
+			/* If an AP vif is found, then disable PS
+			 * by setting the count to zero thereby setting
+			 * ps_sdata to NULL.
+			 */
+			/*count = 0;*/
+			/*break;*/
+			/* XXX: I don't think I understand the above. Any ideas? */
+		}
+		if (sdata->vif.type != NL80211_IFTYPE_STATION)
+			continue;
+		if (!ieee80211_powersave_allowed(sdata)) {
+			sdata->ps_allowed = false;
+			continue;
+		}
+
+		conf = &sdata->vif.bss_conf;
+
+		if (latency < 0)
+			latency = xr_pm_qos_request(PM_QOS_NETWORK_LATENCY);
+
+		beaconint_us = ieee80211_tu_to_usec(
+					sdata->vif.bss_conf.beacon_int);
+
+		timeout = sdata->dynamic_ps_forced_timeout;
+		if (timeout < 0) {
+			/*
+			 * Go to full PSM if the user configures a very low
+			 * latency requirement.
+			 * The 2000 second value is there for compatibility
+			 * until the PM_QOS_NETWORK_LATENCY is configured
+			 * with real values.
+			 */
+			if (latency > (1900 * USEC_PER_MSEC) &&
+			    latency != (2000 * USEC_PER_SEC))
+				timeout = 0;
+			else
+				timeout = 100;
+		}
+		sdata->dynamic_ps_user_timeout = timeout;
+		if (!sdata->disable_dynamic_ps)
+			conf->dynamic_ps_timeout =
+				sdata->dynamic_ps_user_timeout;
+
+		if (beaconint_us > latency) {
+			sdata->ps_allowed = false;
+		} else {
+			struct ieee80211_bss *bss;
+			int maxslp = 1;
+			u8 dtimper;
+
+			bss = (void *)sdata->u.mgd.associated->priv;
+			dtimper = bss->dtim_period;
+
+			/* If the TIM IE is invalid, pretend the value is 1 */
+			if (!dtimper)
+				dtimper = 1;
+			else if (dtimper > 1)
+				maxslp = min_t(int, dtimper,
+						    latency / beaconint_us);
+
+			sdata->vif.bss_conf.max_sleep_period = maxslp;
+			sdata->vif.bss_conf.ps_dtim_period = dtimper;
+			sdata->ps_allowed = true;
+		}
+	}
+
+ change:
+	ieee80211_change_ps(local);
+}
+
+void mac80211_dynamic_ps_disable_work(struct work_struct *work)
+{
+	struct ieee80211_sub_if_data *sdata =
+		container_of(work, struct ieee80211_sub_if_data,
+			     dynamic_ps_disable_work);
+
+	if (sdata->vif.bss_conf.ps_enabled) {
+		sdata->vif.bss_conf.ps_enabled = false;
+		mac80211_bss_info_change_notify(sdata, BSS_CHANGED_PS);
+	}
+
+	/* XXX: with queue patches this should be updated:*/
+	mac80211_wake_queues_by_reason(&sdata->local->hw,
+					IEEE80211_QUEUE_STOP_REASON_PS);
+}
+
+void mac80211_dynamic_ps_enable_work(struct work_struct *work)
+{
+	struct ieee80211_sub_if_data *sdata =
+		container_of(work, struct ieee80211_sub_if_data,
+			     dynamic_ps_enable_work);
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_if_managed *ifmgd;
+	unsigned long flags;
+	int q;
+
+	/* can only happen when PS was just disabled anyway */
+	if (!sdata->ps_allowed)
+		return;
+
+	ifmgd = &sdata->u.mgd;
+
+	if (sdata->vif.bss_conf.ps_enabled)
+		return;
+
+	if (!sdata->disable_dynamic_ps &&
+	    sdata->vif.bss_conf.dynamic_ps_timeout > 0) {
+		/* don't enter PS if TX frames are pending */
+		if (drv_tx_frames_pending(local)) {
+			mod_timer(&sdata->dynamic_ps_timer, jiffies +
+				  msecs_to_jiffies(
+				  sdata->vif.bss_conf.dynamic_ps_timeout));
+			return;
+		}
+
+		/*
+		 * transmission can be stopped by others which leads to
+		 * dynamic_ps_timer expiry. Postpone the ps timer if it
+		 * is not the actual idle state.
+		 */
+		spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
+		for (q = 0; q < local->hw.queues; q++) {
+			if (local->queue_stop_reasons[q]) {
+				spin_unlock_irqrestore(&local->queue_stop_reason_lock,
+						       flags);
+				mod_timer(&sdata->dynamic_ps_timer, jiffies +
+					  msecs_to_jiffies(
+					  sdata->vif.bss_conf.dynamic_ps_timeout));
+				return;
+			}
+		}
+		spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
+	}
+
+	if ((local->hw.flags & IEEE80211_HW_PS_NULLFUNC_STACK) &&
+	    (!(ifmgd->flags & IEEE80211_STA_NULLFUNC_ACKED))) {
+		netif_tx_stop_all_queues(sdata->dev);
+
+		if (drv_tx_frames_pending(local))
+			mod_timer(&sdata->dynamic_ps_timer, jiffies +
+				  msecs_to_jiffies(
+				  sdata->vif.bss_conf.dynamic_ps_timeout));
+		else {
+			mac80211_send_nullfunc(local, sdata, 1);
+			/* Flush to get the tx status of nullfunc frame */
+			drv_flush(local, sdata, false);
+		}
+	}
+
+	if (!((local->hw.flags & IEEE80211_HW_REPORTS_TX_ACK_STATUS) &&
+	      (local->hw.flags & IEEE80211_HW_PS_NULLFUNC_STACK)) ||
+	    (ifmgd->flags & IEEE80211_STA_NULLFUNC_ACKED)) {
+		ifmgd->flags &= ~IEEE80211_STA_NULLFUNC_ACKED;
+		sdata->vif.bss_conf.ps_enabled = true;
+		mac80211_bss_info_change_notify(sdata, BSS_CHANGED_PS);
+	}
+
+	if (local->hw.flags & IEEE80211_HW_PS_NULLFUNC_STACK)
+		netif_tx_wake_all_queues(sdata->dev);
+}
+
+void mac80211_dynamic_ps_timer(struct timer_list *t)
+{
+	struct ieee80211_sub_if_data *sdata =
+			from_timer(sdata, t, dynamic_ps_timer);
+	struct ieee80211_local *local = sdata->local;
+
+	if (local->quiescing || local->suspended)
+		return;
+
+	mac80211_queue_work(&local->hw, &sdata->dynamic_ps_enable_work);
+}
+
+#define MAX_P2P_NOA_DESC 4
+/* TODO: check if not defined already */
+struct noa_desc {
+	u8	count;
+	__le32	duration;
+	__le32	interval;
+	__le32	start;
+} __packed;
+
+struct noa_attr {
+	u8	index;
+	u8	oppPsCTWindow;
+	struct noa_desc dsc[MAX_P2P_NOA_DESC];
+} __packed;
+
+struct p2p_attr {
+	u8	type;
+	__le16	len;
+	u8	data[0];
+} __packed;
+
+static void ieee80211_sta_p2p_noa_check(struct ieee80211_local *local,
+					struct ieee80211_sub_if_data *sdata,
+					u8 *p2p_ie, size_t p2p_ie_len)
+{
+	struct ieee80211_bss_conf *conf = &sdata->vif.bss_conf;
+	struct cfg80211_p2p_ps p2p_ps = {0};
+	struct p2p_attr *attr;
+	struct noa_attr *noa_attr = NULL;
+	u8 *ptr;
+	u16 len = 0, noa_len = 0;
+	int i;
+	size_t left;
+	size_t elen;
+
+	if (!p2p_ie)
+		goto out;
+
+	ptr = p2p_ie;
+	left = p2p_ie_len;
+
+	while (left >= 2) {
+
+		elen = *++ptr;
+		ptr++;
+		left -= 2;
+		if (elen > left)
+			break;
+		ptr += 4;
+
+		/* Find Noa attr */
+		for (i = 0; i < elen-4;) {
+			attr = (struct p2p_attr *) &ptr[i];
+			len = __le32_to_cpu(attr->len);
+
+			switch (attr->type) {
+			case 0x0C:
+				noa_attr = (struct noa_attr *) &attr->data[0];
+				noa_len = len;
+				break;
+			default:
+				break;
+			}
+			if (noa_attr)
+				break;
+			i = i + len + 3;
+		}
+
+		left -= elen;
+		ptr += elen - 4;
+
+		if (!noa_attr)
+			/* parse next P2P IE if any left */
+			continue;
+
+		/* Get NOA settings */
+		p2p_ps.opp_ps = !!(noa_attr->oppPsCTWindow & BIT(7));
+		p2p_ps.ctwindow = (noa_attr->oppPsCTWindow & (~BIT(7)));
+
+		if (noa_len >= (sizeof(struct noa_desc) + 2)) {
+			/* currently FW API supports only one descriptor */
+			p2p_ps.count = noa_attr->dsc[0].count;
+			p2p_ps.start =
+				__le32_to_cpu(noa_attr->dsc[0].start);
+			p2p_ps.duration =
+				__le32_to_cpu(noa_attr->dsc[0].duration);
+			p2p_ps.interval =
+				__le32_to_cpu(noa_attr->dsc[0].interval);
+		}
+		/* do not continue if one descriptor found */
+		break;
+	}
+
+out:
+	/* Notify driver if change is required */
+	if (memcmp(&conf->p2p_ps, &p2p_ps, sizeof(p2p_ps))) {
+		/* do not change legacy ps settings */
+		p2p_ps.legacy_ps = conf->p2p_ps.legacy_ps;
+		conf->p2p_ps = p2p_ps;
+		if (local->hw.flags & IEEE80211_HW_SUPPORTS_P2P_PS)
+			mac80211_bss_info_change_notify(sdata,
+							 BSS_CHANGED_P2P_PS);
+	}
+}
+
+
+/* P2P */
+static void ieee80211_sta_p2p_params(struct ieee80211_local *local,
+				     struct ieee80211_sub_if_data *sdata,
+				     u8 *p2p_ie, size_t p2p_ie_len)
+{
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+
+	if (!p2p_ie) {
+		if (ifmgd->p2p_last_ie_len) {
+			memset(ifmgd->p2p_last_ie, 0x00,
+			       sizeof(ifmgd->p2p_last_ie));
+			ifmgd->p2p_last_ie_len = 0;
+			ieee80211_sta_p2p_noa_check(local, sdata, p2p_ie,
+						    p2p_ie_len);
+			return;
+		}
+	}
+
+	if (p2p_ie_len != ifmgd->p2p_last_ie_len ||
+	    memcmp(p2p_ie, ifmgd->p2p_last_ie, p2p_ie_len)) {
+		/* BSS_CHANGED_P2P_PS */
+		ieee80211_sta_p2p_noa_check(local, sdata, p2p_ie,
+					    p2p_ie_len);
+	}
+
+	memcpy(ifmgd->p2p_last_ie, p2p_ie, p2p_ie_len);
+	ifmgd->p2p_last_ie_len = p2p_ie_len;
+}
+
+/* MLME */
+static void ieee80211_sta_wmm_params(struct ieee80211_local *local,
+				     struct ieee80211_sub_if_data *sdata,
+				     u8 *wmm_param, size_t wmm_param_len)
+{
+	struct ieee80211_tx_queue_params params;
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+	size_t left;
+	int count;
+	u8 *pos, uapsd_queues = 0;
+
+	if (!local->ops->conf_tx)
+		return;
+
+	if (local->hw.queues < IEEE80211_NUM_ACS)
+		return;
+
+	if (!wmm_param)
+		return;
+
+	if (wmm_param_len < 8 || wmm_param[5] /* version */ != 1)
+		return;
+
+	if (ifmgd->flags & IEEE80211_STA_UAPSD_ENABLED)
+		uapsd_queues = local->uapsd_queues;
+
+	count = wmm_param[6] & 0x0f;
+	if (count == ifmgd->wmm_last_param_set)
+		return;
+	ifmgd->wmm_last_param_set = count;
+
+	pos = wmm_param + 8;
+	left = wmm_param_len - 8;
+
+	memset(&params, 0, sizeof(params));
+
+	local->wmm_acm = 0;
+#ifdef CONFIG_XRADIO_TESTMODE
+	local->wmm_admitted_ups = 0;
+#endif /*CONFIG_XRADIO_TESTMODE*/
+	for (; left >= 4; left -= 4, pos += 4) {
+		int aci = (pos[0] >> 5) & 0x03;
+		int acm = (pos[0] >> 4) & 0x01;
+		bool uapsd = false;
+		int queue;
+
+		switch (aci) {
+		case 1: /* AC_BK */
+			queue = 3;
+			if (acm)
+				local->wmm_acm |= BIT(1) | BIT(2); /* BK/- */
+			if (uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_BK)
+				uapsd = true;
+			break;
+		case 2: /* AC_VI */
+			queue = 1;
+			if (acm)
+				local->wmm_acm |= BIT(4) | BIT(5); /* CL/VI */
+			if (uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VI)
+				uapsd = true;
+			break;
+		case 3: /* AC_VO */
+			queue = 0;
+			if (acm)
+				local->wmm_acm |= BIT(6) | BIT(7); /* VO/NC */
+			if (uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VO)
+				uapsd = true;
+			break;
+		case 0: /* AC_BE */
+		default:
+			queue = 2;
+			if (acm)
+				local->wmm_acm |= BIT(0) | BIT(3); /* BE/EE */
+			if (uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_BE)
+				uapsd = true;
+			break;
+		}
+
+		params.aifs = pos[0] & 0x0f;
+		params.cw_max = ecw2cw((pos[1] & 0xf0) >> 4);
+		params.cw_min = ecw2cw(pos[1] & 0x0f);
+		params.txop = get_unaligned_le16(pos + 2);
+		params.uapsd = uapsd;
+
+#ifdef CONFIG_XRMAC_VERBOSE_DEBUG
+		wiphy_debug(local->hw.wiphy,
+			    "WMM queue=%d aci=%d acm=%d aifs=%d "
+			    "cWmin=%d cWmax=%d txop=%d uapsd=%d\n",
+			    queue, aci, acm,
+			    params.aifs, params.cw_min, params.cw_max,
+			    params.txop, params.uapsd);
+#endif
+		sdata->tx_conf[queue] = params;
+		if (drv_conf_tx(local, sdata, queue, &params))
+			wiphy_debug(local->hw.wiphy,
+				    "failed to set TX queue parameters for queue %d\n",
+				    queue);
+	}
+
+	/* enable WMM or activate new settings */
+	sdata->vif.bss_conf.qos = true;
+	mac80211_bss_info_change_notify(sdata, BSS_CHANGED_QOS);
+}
+
+static u32 ieee80211_handle_bss_capability(struct ieee80211_sub_if_data *sdata,
+					   u16 capab, bool erp_valid, u8 erp)
+{
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(sdata->local, sdata);
+	struct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;
+	u32 changed = 0;
+	bool use_protection;
+	bool use_short_preamble;
+	bool use_short_slot;
+
+	if (erp_valid) {
+		use_protection = (erp & WLAN_ERP_USE_PROTECTION) != 0;
+		use_short_preamble = (erp & WLAN_ERP_BARKER_PREAMBLE) == 0;
+	} else {
+		use_protection = false;
+		use_short_preamble = !!(capab & WLAN_CAPABILITY_SHORT_PREAMBLE);
+	}
+
+	use_short_slot = !!(capab & WLAN_CAPABILITY_SHORT_SLOT_TIME);
+	if (chan_state->conf.channel->band == NL80211_BAND_5GHZ)
+		use_short_slot = true;
+
+	if (use_protection != bss_conf->use_cts_prot) {
+		bss_conf->use_cts_prot = use_protection;
+		changed |= BSS_CHANGED_ERP_CTS_PROT;
+	}
+
+	if (use_short_preamble != bss_conf->use_short_preamble) {
+		bss_conf->use_short_preamble = use_short_preamble;
+		changed |= BSS_CHANGED_ERP_PREAMBLE;
+	}
+
+	if (use_short_slot != bss_conf->use_short_slot) {
+		bss_conf->use_short_slot = use_short_slot;
+		changed |= BSS_CHANGED_ERP_SLOT;
+	}
+
+	return changed;
+}
+
+static void ieee80211_set_associated(struct ieee80211_sub_if_data *sdata,
+				     struct cfg80211_bss *cbss,
+				     u32 bss_info_changed)
+{
+	struct ieee80211_bss *bss = (void *)cbss->priv;
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;
+
+	bss_info_changed |= BSS_CHANGED_ASSOC;
+	/* set timing information */
+	bss_conf->beacon_int = cbss->beacon_interval;
+	/*bss_conf->timestamp = cbss->tsf;*/
+	bss_conf->timestamp = 0;
+	bss_info_changed |= BSS_CHANGED_BEACON_INT;
+	bss_info_changed |= ieee80211_handle_bss_capability(sdata,
+		cbss->capability, bss->has_erp_value, bss->erp_value);
+
+	sdata->u.mgd.beacon_timeout = usecs_to_jiffies(ieee80211_tu_to_usec(
+		IEEE80211_BEACON_LOSS_COUNT * bss_conf->beacon_int));
+	sdata->u.mgd.associated = cbss;
+	memcpy(sdata->u.mgd.bssid, cbss->bssid, ETH_ALEN);
+
+	sdata->u.mgd.flags |= IEEE80211_STA_RESET_SIGNAL_AVE;
+
+	/* just to be sure */
+	sdata->u.mgd.flags &= ~(IEEE80211_STA_CONNECTION_POLL |
+				IEEE80211_STA_BEACON_POLL);
+
+	ieee80211_led_assoc(local, 1);
+
+	if (local->hw.flags & IEEE80211_HW_NEED_DTIM_PERIOD)
+		bss_conf->dtim_period = bss->dtim_period;
+	else
+		bss_conf->dtim_period = 0;
+
+	bss_conf->assoc = 1;
+	/*
+	 * For now just always ask the driver to update the basic rateset
+	 * when we have associated, we aren't checking whether it actually
+	 * changed or not.
+	 */
+	bss_info_changed |= BSS_CHANGED_BASIC_RATES;
+
+	/* And the BSSID changed - we're associated now */
+	bss_info_changed |= BSS_CHANGED_BSSID;
+
+	/* Tell the driver to monitor connection quality (if supported) */
+	if ((local->hw.flags & IEEE80211_HW_SUPPORTS_CQM_RSSI) &&
+	    bss_conf->cqm_rssi_thold)
+		bss_info_changed |= BSS_CHANGED_CQM;
+
+	/* Enable ARP filtering */
+	if (bss_conf->arp_filter_enabled != sdata->arp_filter_state) {
+		bss_conf->arp_filter_enabled = sdata->arp_filter_state;
+		bss_info_changed |= BSS_CHANGED_ARP_FILTER;
+	}
+
+#ifdef IPV6_FILTERING
+	/* Enable NDP filtering */
+	if (bss_conf->ndp_filter_enabled != sdata->ndp_filter_state) {
+		bss_conf->ndp_filter_enabled = sdata->ndp_filter_state;
+		bss_info_changed |= BSS_CHANGED_NDP_FILTER;
+	}
+#endif /*IPV6_FILTERING*/
+
+	mac80211_bss_info_change_notify(sdata, bss_info_changed);
+
+	mutex_lock(&local->iflist_mtx);
+	mac80211_recalc_ps(local, -1);
+	mac80211_recalc_smps(local);
+	mutex_unlock(&local->iflist_mtx);
+
+	netif_tx_start_all_queues(sdata->dev);
+	netif_carrier_on(sdata->dev);
+}
+
+static void ieee80211_set_disassoc(struct ieee80211_sub_if_data *sdata,
+				   bool remove_sta, bool tx)
+{
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+	struct ieee80211_local *local = sdata->local;
+	struct sta_info *sta;
+	u32 changed = 0, config_changed = 0;
+	u8 bssid[ETH_ALEN];
+
+	ASSERT_MGD_MTX(ifmgd);
+
+	if (WARN_ON(!ifmgd->associated))
+		return;
+
+	memcpy(bssid, ifmgd->associated->bssid, ETH_ALEN);
+
+	ifmgd->associated = NULL;
+	sdata->fourway_state = SDATA_4WAY_STATE_NONE;
+	memset(ifmgd->bssid, 0, ETH_ALEN);
+
+	/*
+	 * we need to commit the associated = NULL change because the
+	 * scan code uses that to determine whether this iface should
+	 * go to/wake up from powersave or not -- and could otherwise
+	 * wake the queues erroneously.
+	 */
+	smp_mb();
+
+	/*
+	 * Thus, we can only afterwards stop the queues -- to account
+	 * for the case where another CPU is finishing a scan at this
+	 * time -- we don't want the scan code to enable queues.
+	 */
+
+	netif_tx_stop_all_queues(sdata->dev);
+	netif_carrier_off(sdata->dev);
+
+	mutex_lock(&local->sta_mtx);
+	sta = xrmac_sta_info_get(sdata, bssid);
+	if (sta) {
+		set_sta_flag(sta, WLAN_STA_BLOCK_BA);
+		mac80211_sta_tear_down_BA_sessions(sta, tx);
+	}
+	mutex_unlock(&local->sta_mtx);
+
+	changed |= mac80211_reset_erp_info(sdata);
+
+	ieee80211_led_assoc(local, 0);
+	changed |= BSS_CHANGED_ASSOC;
+	sdata->vif.bss_conf.assoc = false;
+
+	mac80211_set_wmm_default(sdata);
+
+	/* channel(_type) changes are handled by mac80211_hw_config */
+	WARN_ON(!mac80211_set_channel_type(local, sdata, NL80211_CHAN_NO_HT));
+
+	/* on the next assoc, re-program HT parameters */
+	sdata->ht_opmode_valid = false;
+
+	local->power_constr_level = 0;
+
+	del_timer_sync(&sdata->dynamic_ps_timer);
+	cancel_work_sync(&sdata->dynamic_ps_enable_work);
+
+	if (sdata->vif.bss_conf.ps_enabled) {
+		sdata->vif.bss_conf.ps_enabled = false;
+		mac80211_bss_info_change_notify(sdata, BSS_CHANGED_PS);
+	}
+	sdata->ps_allowed = false;
+
+	mac80211_hw_config(local, config_changed);
+
+	/* Disable ARP filtering */
+	if (sdata->vif.bss_conf.arp_filter_enabled) {
+		sdata->vif.bss_conf.arp_filter_enabled = false;
+		changed |= BSS_CHANGED_ARP_FILTER;
+	}
+
+#ifdef IPV6_FILTERING
+	/* Disable NDP filtering */
+	if (sdata->vif.bss_conf.ndp_filter_enabled) {
+		sdata->vif.bss_conf.ndp_filter_enabled = false;
+		changed |= BSS_CHANGED_NDP_FILTER;
+	}
+#endif /*IPV6_FILTERING*/
+
+	/* The BSSID (not really interesting) and HT changed */
+	changed |= BSS_CHANGED_BSSID | BSS_CHANGED_HT;
+	mac80211_bss_info_change_notify(sdata, changed);
+
+	/* remove AP and TDLS peers */
+	if (remove_sta)
+		xrmac_sta_info_flush(local, sdata);
+
+	del_timer_sync(&sdata->u.mgd.conn_mon_timer);
+	del_timer_sync(&sdata->u.mgd.bcn_mon_timer);
+	del_timer_sync(&sdata->u.mgd.timer);
+	del_timer_sync(&sdata->u.mgd.chswitch_timer);
+}
+
+void mac80211_sta_rx_notify(struct ieee80211_sub_if_data *sdata,
+			     struct ieee80211_hdr *hdr)
+{
+	/*
+	 * We can postpone the mgd.timer whenever receiving unicast frames
+	 * from AP because we know that the connection is working both ways
+	 * at that time. But multicast frames (and hence also beacons) must
+	 * be ignored here, because we need to trigger the timer during
+	 * data idle periods for sending the periodic probe request to the
+	 * AP we're connected to.
+	 */
+	if (is_multicast_ether_addr(hdr->addr1))
+		return;
+
+	mac80211_sta_reset_conn_monitor(sdata);
+}
+
+static void ieee80211_reset_ap_probe(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+
+	if (!(ifmgd->flags & (IEEE80211_STA_BEACON_POLL |
+			      IEEE80211_STA_CONNECTION_POLL)))
+	    return;
+
+	ifmgd->flags &= ~(IEEE80211_STA_CONNECTION_POLL |
+			  IEEE80211_STA_BEACON_POLL);
+	mutex_lock(&sdata->local->iflist_mtx);
+	mac80211_recalc_ps(sdata->local, -1);
+	mutex_unlock(&sdata->local->iflist_mtx);
+
+	if (sdata->local->hw.flags & IEEE80211_HW_CONNECTION_MONITOR)
+		return;
+
+	/*
+	 * We've received a probe response, but are not sure whether
+	 * we have or will be receiving any beacons or data, so let's
+	 * schedule the timers again, just in case.
+	 */
+	mac80211_sta_reset_beacon_monitor(sdata);
+
+	mod_timer(&ifmgd->conn_mon_timer,
+		  round_jiffies_up(jiffies +
+				   IEEE80211_CONNECTION_IDLE_TIME));
+}
+
+void mac80211_sta_tx_notify(struct ieee80211_sub_if_data *sdata,
+			     struct ieee80211_hdr *hdr, bool ack)
+{
+	if (!ieee80211_is_data(hdr->frame_control))
+	    return;
+
+	if (ack)
+		mac80211_sta_reset_conn_monitor(sdata);
+
+	if (ieee80211_is_nullfunc(hdr->frame_control) &&
+	    sdata->u.mgd.probe_send_count > 0) {
+		if (ack)
+			sdata->u.mgd.probe_send_count = 0;
+		else
+			sdata->u.mgd.nullfunc_failed = true;
+		mac80211_queue_work(&sdata->local->hw, &sdata->work);
+	}
+}
+
+static void ieee80211_mgd_probe_ap_send(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+	const u8 *ssid;
+	u8 *dst = ifmgd->associated->bssid;
+	u8 unicast_limit = max(1, max_probe_tries - 3);
+
+	/*
+	 * Try sending broadcast probe requests for the last three
+	 * probe requests after the first ones failed since some
+	 * buggy APs only support broadcast probe requests.
+	 */
+	if (ifmgd->probe_send_count >= unicast_limit)
+		dst = NULL;
+
+	/*
+	 * When the hardware reports an accurate Tx ACK status, it's
+	 * better to send a nullfunc frame instead of a probe request,
+	 * as it will kick us off the AP quickly if we aren't associated
+	 * anymore. The timeout will be reset if the frame is ACKed by
+	 * the AP.
+	 */
+	ifmgd->probe_send_count++;
+	if (sdata->local->hw.flags & IEEE80211_HW_REPORTS_TX_ACK_STATUS) {
+		ifmgd->nullfunc_failed = false;
+		mac80211_send_nullfunc(sdata->local, sdata, 0);
+	} else {
+		ssid = ieee80211_bss_get_ie(ifmgd->associated, WLAN_EID_SSID);
+		mac80211_send_probe_req(sdata, dst, ssid + 2, ssid[1], NULL, 0,
+					 (u32) -1, true, false);
+	}
+
+	ifmgd->probe_timeout = jiffies + msecs_to_jiffies(probe_wait_ms);
+	run_again(ifmgd, ifmgd->probe_timeout);
+}
+
+static void ieee80211_mgd_probe_ap(struct ieee80211_sub_if_data *sdata,
+				   bool beacon)
+{
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(sdata->local, sdata);
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+	bool already = false;
+
+	if (!ieee80211_sdata_running(sdata))
+		return;
+
+	if (sdata->local->scanning)
+		return;
+
+	if (chan_state->tmp_channel)
+		return;
+
+	mutex_lock(&ifmgd->mtx);
+
+	if (!ifmgd->associated)
+		goto out;
+
+#ifdef CONFIG_XRMAC_VERBOSE_DEBUG
+	if (beacon && net_ratelimit())
+		printk(KERN_DEBUG "%s: detected beacon loss from AP "
+		       "- sending probe request\n", sdata->name);
+#endif
+
+	/*
+	 * The driver/our work has already reported this event or the
+	 * connection monitoring has kicked in and we have already sent
+	 * a probe request. Or maybe the AP died and the driver keeps
+	 * reporting until we disassociate...
+	 *
+	 * In either case we have to ignore the current call to this
+	 * function (except for setting the correct probe reason bit)
+	 * because otherwise we would reset the timer every time and
+	 * never check whether we received a probe response!
+	 */
+	if (ifmgd->flags & (IEEE80211_STA_BEACON_POLL |
+			    IEEE80211_STA_CONNECTION_POLL))
+		already = true;
+
+	if (beacon)
+		ifmgd->flags |= IEEE80211_STA_BEACON_POLL;
+	else
+		ifmgd->flags |= IEEE80211_STA_CONNECTION_POLL;
+
+	if (already)
+		goto out;
+
+	mutex_lock(&sdata->local->iflist_mtx);
+	mac80211_recalc_ps(sdata->local, -1);
+	mutex_unlock(&sdata->local->iflist_mtx);
+
+	ifmgd->probe_send_count = 0;
+	ieee80211_mgd_probe_ap_send(sdata);
+ out:
+	mutex_unlock(&ifmgd->mtx);
+}
+
+struct sk_buff *mac80211_ap_probereq_get(struct ieee80211_hw *hw,
+					  struct ieee80211_vif *vif)
+{
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+	struct sk_buff *skb;
+	const u8 *ssid;
+
+	if (WARN_ON(sdata->vif.type != NL80211_IFTYPE_STATION))
+		return NULL;
+
+	ASSERT_MGD_MTX(ifmgd);
+
+	if (!ifmgd->associated)
+		return NULL;
+
+	ssid = ieee80211_bss_get_ie(ifmgd->associated, WLAN_EID_SSID);
+	skb = mac80211_build_probe_req(sdata, ifmgd->associated->bssid,
+					(u32) -1, ssid + 2, ssid[1],
+					NULL, 0, true);
+
+	return skb;
+}
+
+static void __mac80211_connection_loss(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+	struct ieee80211_local *local = sdata->local;
+	u8 bssid[ETH_ALEN];
+
+	mutex_lock(&ifmgd->mtx);
+	if (!ifmgd->associated) {
+		mutex_unlock(&ifmgd->mtx);
+		return;
+	}
+
+	memcpy(bssid, ifmgd->associated->bssid, ETH_ALEN);
+
+	printk(KERN_DEBUG "%s: Connection to AP %pM lost.\n",
+	       sdata->name, bssid);
+
+	ieee80211_set_disassoc(sdata, true, true);
+	mutex_unlock(&ifmgd->mtx);
+
+	mutex_lock(&local->mtx);
+	mac80211_recalc_idle(local);
+	mutex_unlock(&local->mtx);
+	/*
+	 * must be outside lock due to cfg80211,
+	 * but that's not a problem.
+	 */
+	ieee80211_send_deauth_disassoc(sdata, bssid,
+				       IEEE80211_STYPE_DEAUTH,
+				       WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY,
+				       NULL, true);
+}
+
+void mac80211_beacon_connection_loss_work(struct work_struct *work)
+{
+	struct ieee80211_sub_if_data *sdata =
+		container_of(work, struct ieee80211_sub_if_data,
+			     u.mgd.beacon_connection_loss_work);
+
+	if (sdata->local->hw.flags & IEEE80211_HW_CONNECTION_MONITOR)
+		__mac80211_connection_loss(sdata);
+	else
+		ieee80211_mgd_probe_ap(sdata, true);
+}
+
+void mac80211_beacon_loss(struct ieee80211_vif *vif)
+{
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+	struct ieee80211_hw *hw = &sdata->local->hw;
+
+	trace_api_beacon_loss(sdata);
+
+	WARN_ON(hw->flags & IEEE80211_HW_CONNECTION_MONITOR);
+	mac80211_queue_work(hw, &sdata->u.mgd.beacon_connection_loss_work);
+}
+
+void mac80211_connection_loss(struct ieee80211_vif *vif)
+{
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+	struct ieee80211_hw *hw = &sdata->local->hw;
+
+	trace_api_connection_loss(sdata);
+
+	WARN_ON(!(hw->flags & IEEE80211_HW_CONNECTION_MONITOR));
+	mac80211_queue_work(hw, &sdata->u.mgd.beacon_connection_loss_work);
+}
+
+static enum rx_mgmt_action __must_check
+ieee80211_rx_mgmt_deauth(struct ieee80211_sub_if_data *sdata,
+			 struct ieee80211_mgmt *mgmt, size_t len)
+{
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+	const u8 *bssid = NULL;
+	u16 reason_code;
+
+	if (len < 24 + 2)
+		return RX_MGMT_NONE;
+
+	ASSERT_MGD_MTX(ifmgd);
+
+	bssid = ifmgd->associated->bssid;
+
+	reason_code = le16_to_cpu(mgmt->u.deauth.reason_code);
+
+	printk(KERN_DEBUG "%s: deauthenticated from %pM (Reason: %u)\n",
+			sdata->name, bssid, reason_code);
+
+#ifdef CONFIG_XRMAC_XR_ROAMING_CHANGES
+	sdata->queues_locked = 0;
+#endif
+	ieee80211_set_disassoc(sdata, true, false);
+	mutex_lock(&sdata->local->mtx);
+	mac80211_recalc_idle(sdata->local);
+	mutex_unlock(&sdata->local->mtx);
+
+	return RX_MGMT_CFG80211_DEAUTH;
+}
+
+
+static enum rx_mgmt_action __must_check
+ieee80211_rx_mgmt_disassoc(struct ieee80211_sub_if_data *sdata,
+			   struct ieee80211_mgmt *mgmt, size_t len)
+{
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+	u16 reason_code;
+
+	if (len < 24 + 2)
+		return RX_MGMT_NONE;
+
+	ASSERT_MGD_MTX(ifmgd);
+
+	if (WARN_ON(!ifmgd->associated))
+		return RX_MGMT_NONE;
+
+	if (WARN_ON(memcmp(ifmgd->associated->bssid, mgmt->sa, ETH_ALEN)))
+		return RX_MGMT_NONE;
+
+	reason_code = le16_to_cpu(mgmt->u.disassoc.reason_code);
+
+	printk(KERN_DEBUG "%s: disassociated from %pM (Reason: %u)\n",
+			sdata->name, mgmt->sa, reason_code);
+
+	ieee80211_set_disassoc(sdata, true, false);
+	mutex_lock(&sdata->local->mtx);
+	mac80211_recalc_idle(sdata->local);
+	mutex_unlock(&sdata->local->mtx);
+	return RX_MGMT_CFG80211_DISASSOC;
+}
+
+
+static bool ieee80211_assoc_success(struct ieee80211_work *wk,
+				    struct ieee80211_mgmt *mgmt, size_t len)
+{
+	struct ieee80211_sub_if_data *sdata = wk->sdata;
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sdata);
+	struct ieee80211_supported_band *sband;
+	struct sta_info *sta;
+	struct cfg80211_bss *cbss = wk->assoc.bss;
+	u8 *pos;
+	u32 rates, basic_rates;
+	u16 capab_info, aid;
+	struct ieee802_11_elems elems;
+	struct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;
+	u32 changed = 0;
+	int i, j, err;
+	bool have_higher_than_11mbit = false;
+	u16 ap_ht_cap_flags;
+	int min_rate = INT_MAX, min_rate_index = -1;
+
+	/* AssocResp and ReassocResp have identical structure */
+
+	aid = le16_to_cpu(mgmt->u.assoc_resp.aid);
+	capab_info = le16_to_cpu(mgmt->u.assoc_resp.capab_info);
+
+	if ((aid & (BIT(15) | BIT(14))) != (BIT(15) | BIT(14)))
+		printk(KERN_DEBUG
+		       "%s: invalid AID value 0x%x; bits 15:14 not set\n",
+		       sdata->name, aid);
+	aid &= ~(BIT(15) | BIT(14));
+
+	ifmgd->broken_ap = false;
+
+	if (aid == 0 || aid > IEEE80211_MAX_AID) {
+		printk(KERN_DEBUG
+		       "%s: invalid AID value %d (out of range), turn off PS\n",
+		       sdata->name, aid);
+		aid = 0;
+		ifmgd->broken_ap = true;
+	}
+
+	pos = mgmt->u.assoc_resp.variable;
+	mac802_11_parse_elems(pos, len - (pos - (u8 *) mgmt), &elems);
+
+	if (!elems.supp_rates) {
+		printk(KERN_DEBUG "%s: no SuppRates element in AssocResp\n",
+		       sdata->name);
+		return false;
+	}
+
+	ifmgd->aid = aid;
+
+	mutex_lock(&sdata->local->sta_mtx);
+	/*
+	 * station info was already allocated and inserted before
+	 * the association and should be available to us
+	 */
+	sta = xrmac_sta_info_get_rx(sdata, cbss->bssid);
+	if (WARN_ON(!sta)) {
+		mutex_unlock(&sdata->local->sta_mtx);
+		return false;
+	}
+
+	set_sta_flag(sta, WLAN_STA_AUTH);
+	set_sta_flag(sta, WLAN_STA_ASSOC);
+	set_sta_flag(sta, WLAN_STA_ASSOC_AP);
+	if (!(ifmgd->flags & IEEE80211_STA_CONTROL_PORT))
+		set_sta_flag(sta, WLAN_STA_AUTHORIZED);
+
+	rates = 0;
+	basic_rates = 0;
+	sband = local->hw.wiphy->bands[wk->chan->band];
+
+	for (i = 0; i < elems.supp_rates_len; i++) {
+		int rate = (elems.supp_rates[i] & 0x7f) * 5;
+		bool is_basic = !!(elems.supp_rates[i] & 0x80);
+
+		if (rate > 110)
+			have_higher_than_11mbit = true;
+
+		for (j = 0; j < sband->n_bitrates; j++) {
+			if (sband->bitrates[j].bitrate == rate) {
+				rates |= BIT(j);
+				if (is_basic)
+					basic_rates |= BIT(j);
+				if (rate < min_rate) {
+					min_rate = rate;
+					min_rate_index = j;
+				}
+				break;
+			}
+		}
+	}
+
+	for (i = 0; i < elems.ext_supp_rates_len; i++) {
+		int rate = (elems.ext_supp_rates[i] & 0x7f) * 5;
+		bool is_basic = !!(elems.ext_supp_rates[i] & 0x80);
+
+		if (rate > 110)
+			have_higher_than_11mbit = true;
+
+		for (j = 0; j < sband->n_bitrates; j++) {
+			if (sband->bitrates[j].bitrate == rate) {
+				rates |= BIT(j);
+				if (is_basic)
+					basic_rates |= BIT(j);
+				if (rate < min_rate) {
+					min_rate = rate;
+					min_rate_index = j;
+				}
+				break;
+			}
+		}
+	}
+
+	/*
+	 * some buggy APs don't advertise basic_rates. use the lowest
+	 * supported rate instead.
+	 */
+	if (unlikely(!basic_rates) && min_rate_index >= 0) {
+		printk(KERN_DEBUG "%s: No basic rates in AssocResp. "
+		       "Using min supported rate instead.\n", sdata->name);
+		basic_rates = BIT(min_rate_index);
+	}
+
+	sta->sta.supp_rates[wk->chan->band] = rates;
+	sdata->vif.bss_conf.basic_rates = basic_rates;
+
+	/* cf. IEEE 802.11 9.2.12 */
+	if (wk->chan->band == NL80211_BAND_2GHZ &&
+	    have_higher_than_11mbit)
+		sdata->flags |= IEEE80211_SDATA_OPERATING_GMODE;
+	else
+		sdata->flags &= ~IEEE80211_SDATA_OPERATING_GMODE;
+
+	if (elems.ht_cap_elem && !(ifmgd->flags & IEEE80211_STA_DISABLE_11N))
+		mac80211_ht_cap_ie_to_sta_ht_cap(sband,
+				(const struct ieee80211_ht_cap *)elems.ht_cap_elem,
+							&sta->sta.ht_cap);
+
+	ap_ht_cap_flags = sta->sta.ht_cap.cap;
+
+	rate_control_rate_init(sta);
+
+	if (ifmgd->flags & IEEE80211_STA_MFP_ENABLED)
+		set_sta_flag(sta, WLAN_STA_MFP);
+
+	if (elems.wmm_param)
+		set_sta_flag(sta, WLAN_STA_WME);
+
+	/* sta_info_reinsert will also unlock the mutex lock */
+	err = sta_info_reinsert(sta);
+	sta = NULL;
+	if (err) {
+		printk(KERN_DEBUG "%s: failed to insert STA entry for"
+		       " the AP (error %d)\n", sdata->name, err);
+		return false;
+	}
+
+	/*
+	 * Always handle WMM once after association regardless
+	 * of the first value the AP uses. Setting -1 here has
+	 * that effect because the AP values is an unsigned
+	 * 4-bit value.
+	 */
+	ifmgd->wmm_last_param_set = -1;
+
+	if (elems.wmm_param)
+		ieee80211_sta_wmm_params(local, sdata, elems.wmm_param,
+					 elems.wmm_param_len);
+	else
+		mac80211_set_wmm_default(sdata);
+
+	chan_state->oper_channel = wk->chan;
+
+	if (elems.ht_info_elem && elems.wmm_param &&
+	    (sdata->local->hw.queues >= 4) &&
+	    !(ifmgd->flags & IEEE80211_STA_DISABLE_11N))
+		changed |= ieee80211_enable_ht(sdata, elems.ht_info_elem,
+					       cbss->bssid, ap_ht_cap_flags,
+					       false);
+
+	/* set AID and assoc capability,
+	 * ieee80211_set_associated() will tell the driver */
+	bss_conf->aid = aid;
+	bss_conf->assoc_capability = capab_info;
+	ieee80211_set_associated(sdata, cbss, changed);
+
+	/*
+	 * If we're using 4-addr mode, let the AP know that we're
+	 * doing so, so that it can create the STA VLAN on its side
+	 */
+	if (ifmgd->use_4addr)
+		ieee80211_send_4addr_nullfunc(local, sdata);
+
+	/*
+	 * Start timer to probe the connection to the AP now.
+	 * Also start the timer that will detect beacon loss.
+	 */
+	mac80211_sta_rx_notify(sdata, (struct ieee80211_hdr *)mgmt);
+	mac80211_sta_reset_beacon_monitor(sdata);
+
+	return true;
+}
+
+
+static void ieee80211_rx_bss_info(struct ieee80211_sub_if_data *sdata,
+				  struct ieee80211_mgmt *mgmt,
+				  size_t len,
+				  struct ieee80211_rx_status *rx_status,
+				  struct ieee802_11_elems *elems,
+				  bool beacon)
+{
+	struct ieee80211_local *local = sdata->local;
+	int freq;
+	struct ieee80211_bss *bss;
+	struct ieee80211_channel *channel;
+	bool need_ps = false;
+
+	if (sdata->u.mgd.associated) {
+		bss = (void *)sdata->u.mgd.associated->priv;
+		/* not previously set so we may need to recalc */
+		need_ps = !bss->dtim_period;
+	}
+
+	if (elems->ds_params && elems->ds_params_len == 1)
+		freq = ieee80211_channel_to_frequency(elems->ds_params[0],
+						      rx_status->band);
+	else
+		freq = rx_status->freq;
+
+	channel = ieee80211_get_channel(local->hw.wiphy, freq);
+
+	if (!channel || channel->flags & IEEE80211_CHAN_DISABLED)
+		return;
+
+	bss = mac80211_bss_info_update(local, rx_status, mgmt, len, elems,
+					channel, beacon);
+	if (bss)
+		mac80211_rx_bss_put(local, bss);
+
+	if (!sdata->u.mgd.associated)
+		return;
+
+	if (need_ps) {
+		mutex_lock(&local->iflist_mtx);
+		mac80211_recalc_ps(local, -1);
+		mutex_unlock(&local->iflist_mtx);
+	}
+
+	if (elems->ch_switch_elem && (elems->ch_switch_elem_len == 3) &&
+	    (memcmp(mgmt->bssid, sdata->u.mgd.associated->bssid,
+							ETH_ALEN) == 0)) {
+		struct ieee80211_channel_sw_ie *sw_elem =
+			(struct ieee80211_channel_sw_ie *)elems->ch_switch_elem;
+		mac80211_sta_process_chanswitch(sdata, sw_elem,
+						 bss, rx_status->mactime);
+	}
+}
+
+
+static void ieee80211_rx_mgmt_probe_resp(struct ieee80211_sub_if_data *sdata,
+					 struct sk_buff *skb)
+{
+	struct ieee80211_mgmt *mgmt = (void *)skb->data;
+	struct ieee80211_if_managed *ifmgd;
+	struct ieee80211_rx_status *rx_status = (void *) skb->cb;
+	size_t baselen, len = skb->len;
+	struct ieee802_11_elems elems;
+
+	ifmgd = &sdata->u.mgd;
+
+	ASSERT_MGD_MTX(ifmgd);
+
+	if (memcmp(mgmt->da, sdata->vif.addr, ETH_ALEN))
+		return; /* ignore ProbeResp to foreign address */
+
+	baselen = (u8 *) mgmt->u.probe_resp.variable - (u8 *) mgmt;
+	if (baselen > len)
+		return;
+
+	mac802_11_parse_elems(mgmt->u.probe_resp.variable, len - baselen,
+				&elems);
+
+	ieee80211_rx_bss_info(sdata, mgmt, len, rx_status, &elems, false);
+
+	if (ifmgd->associated &&
+	    memcmp(mgmt->bssid, ifmgd->associated->bssid, ETH_ALEN) == 0)
+		ieee80211_reset_ap_probe(sdata);
+}
+
+/*
+ * This is the canonical list of information elements we care about,
+ * the filter code also gives us all changes to the Microsoft OUI
+ * (00:50:F2) vendor IE which is used for WMM which we need to track.
+ *
+ * We implement beacon filtering in software since that means we can
+ * avoid processing the frame here and in cfg80211, and userspace
+ * will not be able to tell whether the hardware supports it or not.
+ *
+ * XXX: This list needs to be dynamic -- userspace needs to be able to
+ *	add items it requires. It also needs to be able to tell us to
+ *	look out for other vendor IEs.
+ */
+static const u64 care_about_ies =
+	(1ULL << WLAN_EID_COUNTRY) |
+	(1ULL << WLAN_EID_ERP_INFO) |
+	(1ULL << WLAN_EID_CHANNEL_SWITCH) |
+	(1ULL << WLAN_EID_PWR_CONSTRAINT) |
+	(1ULL << WLAN_EID_HT_CAPABILITY) |
+	(1ULL << WLAN_EID_HT_INFORMATION);
+
+static void ieee80211_rx_mgmt_beacon(struct ieee80211_sub_if_data *sdata,
+				     struct ieee80211_mgmt *mgmt,
+				     size_t len,
+				     struct ieee80211_rx_status *rx_status)
+{
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+	struct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;
+	size_t baselen;
+	struct ieee802_11_elems elems;
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sdata);
+	u32 changed = 0;
+	bool erp_valid, directed_tim = false;
+	u8 erp_value = 0;
+	u32 ncrc;
+	u8 *bssid;
+
+	ASSERT_MGD_MTX(ifmgd);
+
+	/* Process beacon from the current BSS */
+	baselen = (u8 *) mgmt->u.beacon.variable - (u8 *) mgmt;
+	if (baselen > len)
+		return;
+
+	if (rx_status->freq != chan_state->conf.channel->center_freq)
+		return;
+
+	/*
+	 * We might have received a number of frames, among them a
+	 * disassoc frame and a beacon...
+	 */
+	if (!ifmgd->associated)
+		return;
+
+	bssid = ifmgd->associated->bssid;
+
+	/*
+	 * And in theory even frames from a different AP we were just
+	 * associated to a split-second ago!
+	 */
+	if (memcmp(bssid, mgmt->bssid, ETH_ALEN) != 0)
+		return;
+
+	/* Track average RSSI from the Beacon frames of the current AP */
+	ifmgd->last_beacon_signal = rx_status->signal;
+	if (ifmgd->flags & IEEE80211_STA_RESET_SIGNAL_AVE) {
+		ifmgd->flags &= ~IEEE80211_STA_RESET_SIGNAL_AVE;
+		ifmgd->ave_beacon_signal = rx_status->signal * 16;
+		ifmgd->last_cqm_event_signal = 0;
+		ifmgd->count_beacon_signal = 1;
+		ifmgd->last_ave_beacon_signal = 0;
+	} else {
+		ifmgd->ave_beacon_signal =
+			(IEEE80211_SIGNAL_AVE_WEIGHT * rx_status->signal * 16 +
+			 (16 - IEEE80211_SIGNAL_AVE_WEIGHT) *
+			 ifmgd->ave_beacon_signal) / 16;
+		ifmgd->count_beacon_signal++;
+	}
+
+	if (ifmgd->rssi_min_thold != ifmgd->rssi_max_thold &&
+	    ifmgd->count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT) {
+		int sig = ifmgd->ave_beacon_signal;
+		int last_sig = ifmgd->last_ave_beacon_signal;
+
+		/*
+		 * if signal crosses either of the boundaries, invoke callback
+		 * with appropriate parameters
+		 */
+		if (sig > ifmgd->rssi_max_thold &&
+		    (last_sig <= ifmgd->rssi_min_thold || last_sig == 0)) {
+			ifmgd->last_ave_beacon_signal = sig;
+			drv_rssi_callback(local, RSSI_EVENT_HIGH);
+		} else if (sig < ifmgd->rssi_min_thold &&
+			   (last_sig >= ifmgd->rssi_max_thold ||
+			   last_sig == 0)) {
+			ifmgd->last_ave_beacon_signal = sig;
+			drv_rssi_callback(local, RSSI_EVENT_LOW);
+		}
+	}
+
+	if (bss_conf->cqm_rssi_thold &&
+	    ifmgd->count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT &&
+	    !(local->hw.flags & IEEE80211_HW_SUPPORTS_CQM_RSSI)) {
+		int sig = ifmgd->ave_beacon_signal / 16;
+		int last_event = ifmgd->last_cqm_event_signal;
+		int thold = bss_conf->cqm_rssi_thold;
+		int hyst = bss_conf->cqm_rssi_hyst;
+		if (sig < thold &&
+		    (last_event == 0 || sig < last_event - hyst)) {
+			ifmgd->last_cqm_event_signal = sig;
+			mac80211_cqm_rssi_notify(
+				&sdata->vif,
+				NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
+				sig,
+				GFP_KERNEL);
+		} else if (sig > thold &&
+			   (last_event == 0 || sig > last_event + hyst)) {
+			ifmgd->last_cqm_event_signal = sig;
+			mac80211_cqm_rssi_notify(
+				&sdata->vif,
+				NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,
+				sig,
+				GFP_KERNEL);
+		}
+	}
+
+	if (ifmgd->flags & IEEE80211_STA_BEACON_POLL) {
+#ifdef CONFIG_XRMAC_VERBOSE_DEBUG
+		if (net_ratelimit()) {
+			printk(KERN_DEBUG "%s: cancelling probereq poll due "
+			       "to a received beacon\n", sdata->name);
+		}
+#endif
+		ifmgd->flags &= ~IEEE80211_STA_BEACON_POLL;
+		mutex_lock(&local->iflist_mtx);
+		mac80211_recalc_ps(local, -1);
+		mutex_unlock(&local->iflist_mtx);
+	}
+
+	/*
+	 * Push the beacon loss detection into the future since
+	 * we are processing a beacon from the AP just now.
+	 */
+	mac80211_sta_reset_beacon_monitor(sdata);
+
+	ncrc = crc32_be(0, (void *)&mgmt->u.beacon.beacon_int, 4);
+	ncrc = mac802_11_parse_elems_crc(mgmt->u.beacon.variable,
+					  len - baselen, &elems,
+					  care_about_ies, ncrc);
+
+	if (local->hw.flags & IEEE80211_HW_PS_NULLFUNC_STACK)
+		directed_tim = ieee80211_check_tim(elems.tim, elems.tim_len,
+						   ifmgd->aid);
+
+	if (ncrc != ifmgd->beacon_crc || !ifmgd->beacon_crc_valid) {
+		ieee80211_rx_bss_info(sdata, mgmt, len, rx_status, &elems,
+				      true);
+
+		ieee80211_sta_wmm_params(local, sdata, elems.wmm_param,
+					 elems.wmm_param_len);
+
+		ieee80211_sta_p2p_params(local, sdata, elems.p2p_ie,
+					 elems.p2p_ie_len);
+	}
+
+	if (local->hw.flags & IEEE80211_HW_PS_NULLFUNC_STACK) {
+		if (directed_tim) {
+			if (sdata->vif.bss_conf.dynamic_ps_timeout > 0) {
+				sdata->vif.bss_conf.ps_enabled = false;
+				mac80211_bss_info_change_notify(sdata, BSS_CHANGED_PS);
+				mac80211_send_nullfunc(local, sdata, 0);
+			} else {
+				sdata->pspolling = true;
+
+				/*
+				 * Here is assumed that the driver will be
+				 * able to send ps-poll frame and receive a
+				 * response even though power save mode is
+				 * enabled, but some drivers might require
+				 * to disable power save here. This needs
+				 * to be investigated.
+				 */
+				mac80211_send_pspoll(local, sdata);
+			}
+		}
+	}
+
+	if (ncrc == ifmgd->beacon_crc && ifmgd->beacon_crc_valid)
+		return;
+	ifmgd->beacon_crc = ncrc;
+	ifmgd->beacon_crc_valid = true;
+
+	if (elems.erp_info && elems.erp_info_len >= 1) {
+		erp_valid = true;
+		erp_value = elems.erp_info[0];
+	} else {
+		erp_valid = false;
+	}
+	changed |= ieee80211_handle_bss_capability(sdata,
+			le16_to_cpu(mgmt->u.beacon.capab_info),
+			erp_valid, erp_value);
+
+
+	if (elems.ht_cap_elem && elems.ht_info_elem && elems.wmm_param &&
+	    !(ifmgd->flags & IEEE80211_STA_DISABLE_11N)) {
+		struct sta_info *sta;
+		struct ieee80211_supported_band *sband;
+		u16 ap_ht_cap_flags;
+
+		rcu_read_lock();
+
+		sta = xrmac_sta_info_get(sdata, bssid);
+		if (WARN_ON(!sta)) {
+			rcu_read_unlock();
+			return;
+		}
+
+		sband = local->hw.wiphy->bands[chan_state->conf.channel->band];
+
+		mac80211_ht_cap_ie_to_sta_ht_cap(sband,
+				(const struct ieee80211_ht_cap *)elems.ht_cap_elem,
+							&sta->sta.ht_cap);
+
+		ap_ht_cap_flags = sta->sta.ht_cap.cap;
+
+		rcu_read_unlock();
+
+		changed |= ieee80211_enable_ht(sdata, elems.ht_info_elem,
+					       bssid, ap_ht_cap_flags, true);
+	}
+
+	/* Note: country IE parsing is done for us by cfg80211 */
+	if (elems.country_elem) {
+		/* TODO: IBSS also needs this */
+		if (elems.pwr_constr_elem)
+			ieee80211_handle_pwr_constr(sdata,
+				le16_to_cpu(mgmt->u.probe_resp.capab_info),
+				elems.pwr_constr_elem,
+				elems.pwr_constr_elem_len);
+	}
+
+	mac80211_bss_info_change_notify(sdata, changed);
+}
+
+int ieee80211_get_local_erp(struct ieee80211_mgmt *mgmt, size_t len)
+{
+
+	int tmp = 0, erp = 0;
+	const u8 *p;
+	size_t ielen = len - offsetof(struct ieee80211_mgmt,
+					u.beacon.variable);
+
+	p = cfg80211_find_ie(WLAN_EID_SUPP_RATES,
+				mgmt->u.beacon.variable, ielen);
+	if (p) {
+		/* Check for pure 11b access poin */
+		if (p[1] == 4)
+			erp |= WLAN_ERP_USE_PROTECTION;
+	}
+
+	p = cfg80211_find_ie(WLAN_EID_ERP_INFO,
+				mgmt->u.beacon.variable, ielen);
+	if (p)
+		tmp = p[ERP_INFO_BYTE_OFFSET];
+	erp |= tmp;
+	return erp;
+}
+
+void mac80211_sta_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,
+				  struct sk_buff *skb)
+{
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+	struct ieee80211_rx_status *rx_status;
+	struct ieee80211_mgmt *mgmt;
+	enum rx_mgmt_action rma = RX_MGMT_NONE;
+	u16 fc;
+
+	rx_status = (struct ieee80211_rx_status *) skb->cb;
+	mgmt = (struct ieee80211_mgmt *) skb->data;
+	fc = le16_to_cpu(mgmt->frame_control);
+
+	mutex_lock(&ifmgd->mtx);
+
+	if (ifmgd->associated &&
+	    memcmp(ifmgd->associated->bssid, mgmt->bssid, ETH_ALEN) == 0) {
+		switch (fc & IEEE80211_FCTL_STYPE) {
+		case IEEE80211_STYPE_BEACON:
+			ieee80211_rx_mgmt_beacon(sdata, mgmt, skb->len,
+						 rx_status);
+			break;
+		case IEEE80211_STYPE_PROBE_RESP:
+			ieee80211_rx_mgmt_probe_resp(sdata, skb);
+			break;
+		case IEEE80211_STYPE_DEAUTH:
+			rma = ieee80211_rx_mgmt_deauth(sdata, mgmt, skb->len);
+			break;
+		case IEEE80211_STYPE_DISASSOC:
+			rma = ieee80211_rx_mgmt_disassoc(sdata, mgmt, skb->len);
+			break;
+		case IEEE80211_STYPE_ACTION:
+			switch (mgmt->u.action.category) {
+			case WLAN_CATEGORY_SPECTRUM_MGMT:
+				mac80211_sta_process_chanswitch(sdata,
+						&mgmt->u.action.u.chan_switch.sw_elem,
+						(void *)ifmgd->associated->priv,
+						rx_status->mactime);
+				break;
+			}
+		}
+		mutex_unlock(&ifmgd->mtx);
+
+		switch (rma) {
+		case RX_MGMT_NONE:
+			/* no action */
+			break;
+		case RX_MGMT_CFG80211_DEAUTH:
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+			cfg80211_tx_mlme_mgmt(sdata->dev, (u8 *)mgmt, skb->len);
+#else
+			cfg80211_send_deauth(sdata->dev, (u8 *)mgmt, skb->len);
+#endif
+			break;
+		case RX_MGMT_CFG80211_DISASSOC:
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+			cfg80211_tx_mlme_mgmt(sdata->dev, (u8 *)mgmt, skb->len);
+#else
+			cfg80211_send_disassoc(sdata->dev, (u8 *)mgmt, skb->len);
+#endif
+			break;
+		default:
+			WARN(1, "unexpected: %d", rma);
+		}
+		return;
+	}
+
+	mutex_unlock(&ifmgd->mtx);
+
+	if (skb->len >= 24 + 2 /* mgmt + deauth reason */ &&
+	    (fc & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_DEAUTH) {
+		struct ieee80211_local *local = sdata->local;
+		struct ieee80211_work *wk;
+
+		mutex_lock(&local->mtx);
+		list_for_each_entry(wk, &local->work_list, list) {
+			if (wk->sdata != sdata)
+				continue;
+
+			if (wk->type != IEEE80211_WORK_ASSOC &&
+			    wk->type != IEEE80211_WORK_ASSOC_BEACON_WAIT)
+				continue;
+
+			if (memcmp(mgmt->bssid, wk->filter_ta, ETH_ALEN))
+				continue;
+			if (memcmp(mgmt->sa, wk->filter_ta, ETH_ALEN))
+				continue;
+
+			/*
+			 * Printing the message only here means we can't
+			 * spuriously print it, but it also means that it
+			 * won't be printed when the frame comes in before
+			 * we even tried to associate or in similar cases.
+			 *
+			 * Ultimately, I suspect cfg80211 should print the
+			 * messages instead.
+			 */
+			printk(KERN_DEBUG
+			       "%s: deauthenticated from %pM (Reason: %u)\n",
+			       sdata->name, mgmt->bssid,
+			       le16_to_cpu(mgmt->u.deauth.reason_code));
+
+			xrmac_sta_info_destroy_addr(sdata, mgmt->bssid);
+			list_del_rcu(&wk->list);
+			xrmac_free_work(wk);
+			break;
+		}
+		mutex_unlock(&local->mtx);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+		cfg80211_tx_mlme_mgmt(sdata->dev, (u8 *)mgmt, skb->len);
+#else
+		cfg80211_send_deauth(sdata->dev, (u8 *)mgmt, skb->len);
+#endif
+	}
+}
+
+static void ieee80211_sta_timer(struct timer_list *t)
+{
+	struct ieee80211_sub_if_data *sdata =
+		from_timer(sdata, t, u.mgd.timer);
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+	struct ieee80211_local *local = sdata->local;
+
+	if (local->quiescing) {
+		set_bit(TMR_RUNNING_TIMER, &ifmgd->timers_running);
+		return;
+	}
+
+	mac80211_queue_work(&local->hw, &sdata->work);
+}
+
+static void ieee80211_sta_connection_lost(struct ieee80211_sub_if_data *sdata,
+					  u8 *bssid, u8 reason)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+
+	ifmgd->flags &= ~(IEEE80211_STA_CONNECTION_POLL |
+			  IEEE80211_STA_BEACON_POLL);
+
+	ieee80211_set_disassoc(sdata, true, true);
+	mutex_unlock(&ifmgd->mtx);
+	mutex_lock(&local->mtx);
+	mac80211_recalc_idle(local);
+	mutex_unlock(&local->mtx);
+	/*
+	 * must be outside lock due to cfg80211,
+	 * but that's not a problem.
+	 */
+	ieee80211_send_deauth_disassoc(sdata, bssid,
+			IEEE80211_STYPE_DEAUTH, reason,
+			NULL, true);
+	mutex_lock(&ifmgd->mtx);
+}
+
+void mac80211_sta_work(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+	struct ieee80211_vif *vif = &sdata->vif;
+	struct ieee80211_bss_conf *bss_conf = &vif->bss_conf;
+
+	/* then process the rest of the work */
+	mutex_lock(&ifmgd->mtx);
+
+	if (ifmgd->flags & (IEEE80211_STA_BEACON_POLL |
+			    IEEE80211_STA_CONNECTION_POLL) &&
+	    ifmgd->associated) {
+		u8 bssid[ETH_ALEN];
+		int max_tries;
+
+		memcpy(bssid, ifmgd->associated->bssid, ETH_ALEN);
+
+		if (local->hw.flags & IEEE80211_HW_REPORTS_TX_ACK_STATUS)
+			max_tries = max_nullfunc_tries;
+		else
+			max_tries = max_probe_tries;
+
+		/* ACK received for nullfunc probing frame */
+		if (!ifmgd->probe_send_count)
+			ieee80211_reset_ap_probe(sdata);
+		else if (ifmgd->nullfunc_failed) {
+			if (ifmgd->probe_send_count < max_tries) {
+#ifdef CONFIG_XRMAC_VERBOSE_DEBUG
+				wiphy_debug(local->hw.wiphy,
+					    "%s: No ack for nullfunc frame to"
+					    " AP %pM, try %d/%i\n",
+					    sdata->name, bssid,
+					    ifmgd->probe_send_count, max_tries);
+#endif
+				ieee80211_mgd_probe_ap_send(sdata);
+			} else {
+#ifdef CONFIG_XRMAC_VERBOSE_DEBUG
+				wiphy_debug(local->hw.wiphy,
+					    "%s: No ack for nullfunc frame to"
+					    " AP %pM, disconnecting.\n",
+					    sdata->name, bssid);
+#endif
+				ieee80211_sta_connection_lost(sdata, bssid,
+					WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY);
+			}
+		} else if (time_is_after_jiffies(ifmgd->probe_timeout))
+			run_again(ifmgd, ifmgd->probe_timeout);
+		else if (local->hw.flags & IEEE80211_HW_REPORTS_TX_ACK_STATUS) {
+#ifdef CONFIG_XRMAC_VERBOSE_DEBUG
+			wiphy_debug(local->hw.wiphy,
+				    "%s: Failed to send nullfunc to AP %pM"
+				    " after %dms, disconnecting.\n",
+				    sdata->name,
+				    bssid, probe_wait_ms);
+#endif
+			ieee80211_sta_connection_lost(sdata, bssid,
+				WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY);
+		} else if (ifmgd->probe_send_count < max_tries) {
+#ifdef CONFIG_XRMAC_VERBOSE_DEBUG
+			wiphy_debug(local->hw.wiphy,
+				    "%s: No probe response from AP %pM"
+				    " after %dms, try %d/%i\n",
+				    sdata->name,
+				    bssid, probe_wait_ms,
+				    ifmgd->probe_send_count, max_tries);
+#endif
+			ieee80211_mgd_probe_ap_send(sdata);
+		/* Changed to follow XR beacon_miss/beacon_loss design */
+		} else if (!(bss_conf->cqm_beacon_miss_thold) &&
+			   !(bss_conf->cqm_tx_fail_thold)) {
+			/*
+			 * We actually lost the connection ... or did we?
+			 * Let's make sure!
+			 */
+			wiphy_debug(local->hw.wiphy,
+				    "%s: No probe response from AP %pM"
+				    " after %dms, disconnecting.\n",
+				    sdata->name,
+				    bssid, probe_wait_ms);
+
+			ieee80211_sta_connection_lost(sdata, bssid,
+				WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY);
+		}
+	}
+
+	mutex_unlock(&ifmgd->mtx);
+}
+
+static void ieee80211_sta_bcn_mon_timer(struct timer_list *t)
+{
+	struct ieee80211_sub_if_data *sdata =
+		from_timer(sdata, t, u.mgd.bcn_mon_timer);
+	struct ieee80211_local *local = sdata->local;
+
+	if (local->quiescing)
+		return;
+
+	mac80211_queue_work(&sdata->local->hw,
+			     &sdata->u.mgd.beacon_connection_loss_work);
+}
+
+static void ieee80211_sta_conn_mon_timer(struct timer_list *t)
+{
+	struct ieee80211_sub_if_data *sdata =
+		from_timer(sdata, t, u.mgd.conn_mon_timer);
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+	struct ieee80211_local *local = sdata->local;
+
+	if (local->quiescing)
+		return;
+
+	mac80211_queue_work(&local->hw, &ifmgd->monitor_work);
+}
+
+static void ieee80211_sta_monitor_work(struct work_struct *work)
+{
+	struct ieee80211_sub_if_data *sdata =
+		container_of(work, struct ieee80211_sub_if_data,
+			     u.mgd.monitor_work);
+
+	ieee80211_mgd_probe_ap(sdata, false);
+}
+
+static void ieee80211_restart_sta_timer(struct ieee80211_sub_if_data *sdata, bool monitor)
+{
+	if (sdata->vif.type == NL80211_IFTYPE_STATION) {
+		if (monitor) {
+			sdata->u.mgd.flags &= ~(IEEE80211_STA_BEACON_POLL |
+					IEEE80211_STA_CONNECTION_POLL);
+
+			/* let's probe the connection once */
+			mac80211_queue_work(&sdata->local->hw,
+				   &sdata->u.mgd.monitor_work);
+		}
+		/* and do all the other regular work too */
+		mac80211_queue_work(&sdata->local->hw, &sdata->work);
+	}
+}
+
+#ifdef CONFIG_PM
+void mac80211_sta_quiesce(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+
+	/*
+	 * we need to use atomic bitops for the running bits
+	 * only because both timers might fire at the same
+	 * time -- the code here is properly synchronised.
+	 */
+
+	cancel_work_sync(&ifmgd->request_smps_work);
+
+	cancel_work_sync(&ifmgd->monitor_work);
+	cancel_work_sync(&ifmgd->beacon_connection_loss_work);
+	if (del_timer_sync(&ifmgd->timer))
+		set_bit(TMR_RUNNING_TIMER, &ifmgd->timers_running);
+
+	cancel_work_sync(&ifmgd->chswitch_work);
+	if (del_timer_sync(&ifmgd->chswitch_timer))
+		set_bit(TMR_RUNNING_CHANSW, &ifmgd->timers_running);
+
+	/* these will just be re-established on connection */
+	del_timer_sync(&ifmgd->conn_mon_timer);
+	del_timer_sync(&ifmgd->bcn_mon_timer);
+}
+
+void mac80211_sta_restart(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+
+	if (!ifmgd->associated)
+		return;
+
+	if (sdata->flags & IEEE80211_SDATA_DISCONNECT_RESUME) {
+		sdata->flags &= ~IEEE80211_SDATA_DISCONNECT_RESUME;
+		mutex_lock(&ifmgd->mtx);
+		if (ifmgd->associated) {
+#ifdef CONFIG_XRMAC_VERBOSE_DEBUG
+			wiphy_debug(sdata->local->hw.wiphy,
+				    "%s: driver requested disconnect after resume.\n",
+				    sdata->name);
+#endif
+			ieee80211_sta_connection_lost(sdata,
+				ifmgd->associated->bssid,
+				WLAN_REASON_UNSPECIFIED);
+			mutex_unlock(&ifmgd->mtx);
+			return;
+		}
+		mutex_unlock(&ifmgd->mtx);
+	}
+
+	if (test_and_clear_bit(TMR_RUNNING_TIMER, &ifmgd->timers_running))
+		add_timer(&ifmgd->timer);
+	if (test_and_clear_bit(TMR_RUNNING_CHANSW, &ifmgd->timers_running))
+		add_timer(&ifmgd->chswitch_timer);
+	mac80211_sta_reset_beacon_monitor(sdata);
+	ieee80211_restart_sta_timer(sdata, true);
+	mac80211_queue_work(&sdata->local->hw, &sdata->u.mgd.monitor_work);
+}
+#endif
+
+/* interface setup */
+void mac80211_sta_setup_sdata(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_managed *ifmgd;
+
+	ifmgd = &sdata->u.mgd;
+	INIT_WORK(&ifmgd->monitor_work, ieee80211_sta_monitor_work);
+	INIT_WORK(&ifmgd->chswitch_work, ieee80211_chswitch_work);
+	INIT_WORK(&ifmgd->beacon_connection_loss_work,
+		  mac80211_beacon_connection_loss_work);
+	INIT_WORK(&ifmgd->request_smps_work, mac80211_request_smps_work);
+	timer_setup(&ifmgd->timer, ieee80211_sta_timer, 0);
+	timer_setup(&ifmgd->bcn_mon_timer, ieee80211_sta_bcn_mon_timer, 0);
+	timer_setup(&ifmgd->conn_mon_timer, ieee80211_sta_conn_mon_timer, 0);
+	timer_setup(&ifmgd->chswitch_timer, ieee80211_chswitch_timer, 0);
+
+	ifmgd->flags = 0;
+
+	mutex_init(&ifmgd->mtx);
+
+	/* Disable UAPSD for sta by default */
+	sdata->local->uapsd_queues = 0;
+
+	if (sdata->local->hw.flags & IEEE80211_HW_SUPPORTS_DYNAMIC_SMPS)
+		ifmgd->req_smps = IEEE80211_SMPS_AUTOMATIC;
+	else
+		ifmgd->req_smps = IEEE80211_SMPS_OFF;
+#ifdef CONFIG_XRMAC_XR_ROAMING_CHANGES
+	ifmgd->roaming = 0;
+#endif
+}
+
+/* scan finished notification */
+void mac80211_mlme_notify_scan_completed(struct ieee80211_local *local)
+{
+	struct ieee80211_sub_if_data *sdata = local->scan_sdata;
+
+	/* Restart STA timers */
+	rcu_read_lock();
+	list_for_each_entry_rcu(sdata, &local->interfaces, list)
+		ieee80211_restart_sta_timer(sdata, false);
+	rcu_read_unlock();
+}
+
+int mac80211_max_network_latency(struct notifier_block *nb,
+				  unsigned long data, void *dummy)
+{
+	s32 latency_usec = (s32) data;
+	struct ieee80211_local *local =
+		container_of(nb, struct ieee80211_local,
+			     network_latency_notifier);
+
+	mutex_lock(&local->iflist_mtx);
+	mac80211_recalc_ps(local, latency_usec);
+	mutex_unlock(&local->iflist_mtx);
+
+	return 0;
+}
+
+/* config hooks */
+static enum work_done_result
+ieee80211_probe_auth_done(struct ieee80211_work *wk,
+			  struct sk_buff *skb)
+{
+	struct ieee80211_local *local = wk->sdata->local;
+
+	if (!skb) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+		cfg80211_auth_timeout(wk->sdata->dev, wk->filter_ta);
+#else
+		cfg80211_send_auth_timeout(wk->sdata->dev, wk->filter_ta);
+#endif
+		goto destroy;
+	}
+
+	if (wk->type == IEEE80211_WORK_AUTH) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+		cfg80211_rx_mlme_mgmt(wk->sdata->dev, skb->data, skb->len);
+#else
+		cfg80211_send_rx_auth(wk->sdata->dev, skb->data, skb->len);
+#endif
+		goto destroy;
+	}
+
+	mutex_lock(&wk->sdata->u.mgd.mtx);
+	ieee80211_rx_mgmt_probe_resp(wk->sdata, skb);
+	mutex_unlock(&wk->sdata->u.mgd.mtx);
+
+	wk->type = IEEE80211_WORK_AUTH;
+	wk->probe_auth.tries = 0;
+	return WORK_DONE_REQUEUE;
+ destroy:
+	if (wk->probe_auth.synced)
+		drv_finish_tx_sync(local, wk->sdata, wk->filter_ta,
+				   IEEE80211_TX_SYNC_AUTH);
+
+	return WORK_DONE_DESTROY;
+}
+
+int mac80211_mgd_auth(struct ieee80211_sub_if_data *sdata,
+		       struct cfg80211_auth_request *req)
+{
+	const u8 *ssid;
+	struct ieee80211_work *wk;
+	u16 auth_alg;
+
+	/*
+	if (req->local_state_change)
+		return 0; *//* nl80211_authenticate handled the case */
+
+	switch (req->auth_type) {
+	case NL80211_AUTHTYPE_OPEN_SYSTEM:
+		auth_alg = WLAN_AUTH_OPEN;
+		break;
+	case NL80211_AUTHTYPE_SHARED_KEY:
+		if (fips_enabled)
+			return -EOPNOTSUPP;
+		auth_alg = WLAN_AUTH_SHARED_KEY;
+		break;
+	case NL80211_AUTHTYPE_FT:
+		auth_alg = WLAN_AUTH_FT;
+		break;
+	case NL80211_AUTHTYPE_NETWORK_EAP:
+		auth_alg = WLAN_AUTH_LEAP;
+		break;
+	case NL80211_AUTHTYPE_SAE:
+		auth_alg = WLAN_AUTH_SAE;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	wk = kzalloc(sizeof(*wk) + req->auth_data_len - 4 + req->ie_len, GFP_KERNEL);
+	if (!wk)
+		return -ENOMEM;
+
+	memcpy(wk->filter_ta, req->bss->bssid, ETH_ALEN);
+
+	if (req->ie && req->ie_len) {
+		memcpy(wk->ie, req->ie, req->ie_len);
+		wk->ie_len = req->ie_len;
+	}else if (req->auth_data && req->auth_data_len) {
+		__le16 *pos = (__le16 *) req->auth_data;
+		wk->probe_auth.transaction = le16_to_cpu(pos[0]);
+
+		memcpy(wk->ie, req->auth_data + 4, req->auth_data_len - 4);
+		wk->ie_len = req->auth_data_len - 4;
+	}
+
+	if (req->key && req->key_len) {
+		wk->probe_auth.key_len = req->key_len;
+		wk->probe_auth.key_idx = req->key_idx;
+		memcpy(wk->probe_auth.key, req->key, req->key_len);
+	}
+
+	ssid = ieee80211_bss_get_ie(req->bss, WLAN_EID_SSID);
+	memcpy(wk->probe_auth.ssid, ssid + 2, ssid[1]);
+	wk->probe_auth.ssid_len = ssid[1];
+
+	wk->probe_auth.algorithm = auth_alg;
+	wk->probe_auth.privacy = req->bss->capability & WLAN_CAPABILITY_PRIVACY;
+	wk->probe_auth.bss = req->bss;
+
+	/* if we already have a probe, don't probe again */
+	if (req->bss->proberesp_ies || req->bss->beacon_ies)
+		wk->type = IEEE80211_WORK_AUTH;
+	else
+		wk->type = IEEE80211_WORK_DIRECT_PROBE;
+	wk->chan = req->bss->channel;
+	wk->chan_type = NL80211_CHAN_NO_HT;
+	wk->sdata = sdata;
+	wk->done = ieee80211_probe_auth_done;
+
+	mac80211_add_work(wk);
+	return 0;
+}
+
+/* create and insert a dummy station entry */
+static int ieee80211_pre_assoc(struct ieee80211_sub_if_data *sdata,
+				u8 *bssid)
+{
+	struct sta_info *sta;
+	int err;
+
+	sta = xrmac_sta_info_alloc(sdata, bssid, GFP_KERNEL);
+	if (!sta)
+		return -ENOMEM;
+
+	sta->dummy = true;
+
+	err = xrmac_sta_info_insert(sta);
+	sta = NULL;
+	if (err) {
+		printk(KERN_DEBUG "%s: failed to insert Dummy STA entry for"
+		       " the AP (error %d)\n", sdata->name, err);
+		/* return err; */
+		return 0;
+	}
+
+	return 0;
+}
+
+static enum work_done_result ieee80211_assoc_done(struct ieee80211_work *wk,
+						  struct sk_buff *skb)
+{
+	struct ieee80211_local *local = wk->sdata->local;
+	struct ieee80211_mgmt *mgmt;
+	struct ieee80211_rx_status *rx_status;
+	struct ieee802_11_elems elems;
+	struct cfg80211_bss *cbss = wk->assoc.bss;
+	struct ieee80211_if_managed *ifmgd = &wk->sdata->u.mgd;
+	u16 status;
+
+	if (!skb) {
+		xrmac_sta_info_destroy_addr(wk->sdata, cbss->bssid);
+		cfg80211_assoc_timeout(wk->sdata->dev, cbss);
+		goto destroy;
+	}
+
+	if (wk->type == IEEE80211_WORK_ASSOC_BEACON_WAIT) {
+		mutex_lock(&wk->sdata->u.mgd.mtx);
+		rx_status = (void *) skb->cb;
+		mac802_11_parse_elems(skb->data + 24 + 12, skb->len - 24 - 12, &elems);
+		ieee80211_rx_bss_info(wk->sdata, (void *)skb->data, skb->len, rx_status,
+				      &elems, true);
+		mutex_unlock(&wk->sdata->u.mgd.mtx);
+
+		wk->type = IEEE80211_WORK_ASSOC;
+		/* not really done yet */
+		return WORK_DONE_REQUEUE;
+	}
+
+	mgmt = (void *)skb->data;
+	status = le16_to_cpu(mgmt->u.assoc_resp.status_code);
+
+	if (status == WLAN_STATUS_SUCCESS) {
+		if (wk->assoc.synced)
+			drv_finish_tx_sync(local, wk->sdata, wk->filter_ta,
+					   IEEE80211_TX_SYNC_ASSOC);
+
+		mutex_lock(&wk->sdata->u.mgd.mtx);
+		if (!ieee80211_assoc_success(wk, mgmt, skb->len)) {
+			mutex_unlock(&wk->sdata->u.mgd.mtx);
+			/* oops -- internal error -- send timeout for now */
+			xrmac_sta_info_destroy_addr(wk->sdata, cbss->bssid);
+			cfg80211_assoc_timeout(wk->sdata->dev, cbss);
+			printk(KERN_ERR "%s return WORK_DONE_DESTROY\n", __func__);
+			return WORK_DONE_DESTROY;
+		}
+
+		mutex_unlock(&wk->sdata->u.mgd.mtx);
+	} else {
+		/* assoc failed - destroy the dummy station entry */
+		xrmac_sta_info_destroy_addr(wk->sdata, cbss->bssid);
+	}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	cfg80211_rx_assoc_resp(wk->sdata->dev, cbss, skb->data, skb->len, -1,
+		ifmgd->assoc_req_ies, ifmgd->assoc_req_ies_len);
+#else
+	cfg80211_send_rx_assoc(wk->sdata->dev, cbss, skb->data, skb->len);
+#endif
+ destroy:
+	if (wk->assoc.synced)
+		drv_finish_tx_sync(local, wk->sdata, wk->filter_ta,
+				   IEEE80211_TX_SYNC_ASSOC);
+
+	return WORK_DONE_DESTROY;
+}
+
+int mac80211_mgd_assoc(struct ieee80211_sub_if_data *sdata,
+			struct cfg80211_assoc_request *req)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+	struct ieee80211_bss *bss = (void *)req->bss->priv;
+	struct ieee80211_work *wk;
+	const u8 *ssid;
+	int i, err;
+
+	mutex_lock(&ifmgd->mtx);
+	if (ifmgd->associated) {
+		if (!req->prev_bssid ||
+		    memcmp(req->prev_bssid, ifmgd->associated->bssid,
+			   ETH_ALEN)) {
+			/*
+			 * We are already associated and the request was not a
+			 * reassociation request from the current BSS, so
+			 * reject it.
+			 */
+			mutex_unlock(&ifmgd->mtx);
+			return -EALREADY;
+		}
+
+#ifdef CONFIG_XRMAC_XR_ROAMING_CHANGES
+		ifmgd->roaming = 1;
+#endif
+		/* Trying to reassociate - clear previous association state */
+		ieee80211_set_disassoc(sdata, true, false);
+#ifdef CONFIG_XRMAC_XR_ROAMING_CHANGES
+		ifmgd->roaming = 0;
+#endif
+	}
+	mutex_unlock(&ifmgd->mtx);
+
+	wk = kzalloc(sizeof(*wk) + req->ie_len, GFP_KERNEL);
+	if (!wk)
+		return -ENOMEM;
+
+	/*
+	 * create a dummy station info entry in order
+	 * to start accepting incoming EAPOL packets from the station
+	 */
+	err = ieee80211_pre_assoc(sdata, req->bss->bssid);
+	if (err) {
+		kfree(wk);
+		return err;
+	}
+
+	/*
+	if (req->flags & ASSOC_REQ_DISABLE_HT)
+		ifmgd->flags |= IEEE80211_STA_DISABLE_11N;
+	*/
+	ifmgd->flags &= ~IEEE80211_STA_DISABLE_11N;/*default sta 11n enable*/
+	ifmgd->flags &= ~IEEE80211_STA_NULLFUNC_ACKED;
+
+	ifmgd->beacon_crc_valid = false;
+
+	for (i = 0; i < req->crypto.n_ciphers_pairwise; i++)
+		if (req->crypto.ciphers_pairwise[i] == WLAN_CIPHER_SUITE_WEP40 ||
+		    req->crypto.ciphers_pairwise[i] == WLAN_CIPHER_SUITE_TKIP ||
+		    req->crypto.ciphers_pairwise[i] == WLAN_CIPHER_SUITE_WEP104)
+			ifmgd->flags |= IEEE80211_STA_DISABLE_11N;
+
+
+	if (req->ie && req->ie_len) {
+		memcpy(wk->ie, req->ie, req->ie_len);
+		wk->ie_len = req->ie_len;
+	} else
+		wk->ie_len = 0;
+
+	wk->assoc.bss = req->bss;
+
+	memcpy(wk->filter_ta, req->bss->bssid, ETH_ALEN);
+
+	/* new association always uses requested smps mode */
+	if (ifmgd->req_smps == IEEE80211_SMPS_AUTOMATIC) {
+		if (ifmgd->powersave)
+			ifmgd->ap_smps = IEEE80211_SMPS_DYNAMIC;
+		else
+			ifmgd->ap_smps = IEEE80211_SMPS_OFF;
+	} else
+		ifmgd->ap_smps = ifmgd->req_smps;
+
+	wk->assoc.smps = ifmgd->ap_smps;
+	/*
+	 * IEEE802.11n does not allow TKIP/WEP as pairwise ciphers in HT mode.
+	 * We still associate in non-HT mode (11a/b/g) if any one of these
+	 * ciphers is configured as pairwise.
+	 * We can set this to true for non-11n hardware, that'll be checked
+	 * separately along with the peer capabilities.
+	 */
+	wk->assoc.use_11n = !(ifmgd->flags & IEEE80211_STA_DISABLE_11N);
+	wk->assoc.capability = req->bss->capability;
+	wk->assoc.wmm_used = bss->wmm_used &&
+			     (local->hw.queues >= IEEE80211_NUM_ACS);
+	wk->assoc.supp_rates = bss->supp_rates;
+	wk->assoc.supp_rates_len = bss->supp_rates_len;
+	wk->assoc.ht_information_ie =
+		ieee80211_bss_get_ie(req->bss, WLAN_EID_HT_INFORMATION);
+	if (bss->wmm_used && bss->uapsd_supported &&
+	    (sdata->local->hw.flags & IEEE80211_HW_SUPPORTS_UAPSD)) {
+		/*
+		if (req->uapsd != -1)
+			sdata->local->uapsd_queues = req->uapsd;
+		*/
+		wk->assoc.uapsd_used = true;
+		ifmgd->flags |= IEEE80211_STA_UAPSD_ENABLED;
+	} else {
+		wk->assoc.uapsd_used = false;
+		ifmgd->flags &= ~IEEE80211_STA_UAPSD_ENABLED;
+	}
+
+	ssid = ieee80211_bss_get_ie(req->bss, WLAN_EID_SSID);
+	memcpy(wk->assoc.ssid, ssid + 2, ssid[1]);
+	wk->assoc.ssid_len = ssid[1];
+
+	if (req->prev_bssid)
+		memcpy(wk->assoc.prev_bssid, req->prev_bssid, ETH_ALEN);
+
+	wk->chan = req->bss->channel;
+	wk->chan_type = NL80211_CHAN_NO_HT;
+	wk->sdata = sdata;
+	wk->done = ieee80211_assoc_done;
+	if (!bss->dtim_period &&
+	    sdata->local->hw.flags & IEEE80211_HW_NEED_DTIM_PERIOD)
+		wk->type = IEEE80211_WORK_ASSOC_BEACON_WAIT;
+	else
+		wk->type = IEEE80211_WORK_ASSOC;
+
+	if (req->use_mfp) {
+		ifmgd->mfp = IEEE80211_MFP_REQUIRED;
+		ifmgd->flags |= IEEE80211_STA_MFP_ENABLED;
+	} else {
+		ifmgd->mfp = IEEE80211_MFP_DISABLED;
+		ifmgd->flags &= ~IEEE80211_STA_MFP_ENABLED;
+	}
+
+	if (req->crypto.control_port)
+		ifmgd->flags |= IEEE80211_STA_CONTROL_PORT;
+	else
+		ifmgd->flags &= ~IEEE80211_STA_CONTROL_PORT;
+
+	sdata->control_port_protocol = req->crypto.control_port_ethertype;
+	sdata->control_port_no_encrypt = req->crypto.control_port_no_encrypt;
+	sdata->encrypt_headroom = ieee80211_cs_headroom(local, &req->crypto,
+								sdata->vif.type);
+
+	mac80211_add_work(wk);
+	return 0;
+}
+
+int mac80211_mgd_deauth(struct ieee80211_sub_if_data *sdata,
+			 struct cfg80211_deauth_request *req)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+	u8 bssid[ETH_ALEN];
+	bool assoc_bss = false;
+
+	mutex_lock(&ifmgd->mtx);
+
+	memcpy(bssid, req->bssid, ETH_ALEN);
+	if (ifmgd->associated &&
+	    compare_ether_addr(ifmgd->associated->bssid, req->bssid) == 0) {
+		ieee80211_set_disassoc(sdata, false, true);
+		mutex_unlock(&ifmgd->mtx);
+		assoc_bss = true;
+	} else {
+		bool not_auth_yet = false;
+		struct ieee80211_work *tmp, *wk = NULL;
+
+		mutex_unlock(&ifmgd->mtx);
+
+		mutex_lock(&local->mtx);
+		list_for_each_entry(tmp, &local->work_list, list) {
+			if (tmp->sdata != sdata)
+				continue;
+
+			if (tmp->type != IEEE80211_WORK_DIRECT_PROBE &&
+			    tmp->type != IEEE80211_WORK_AUTH &&
+			    tmp->type != IEEE80211_WORK_ASSOC &&
+			    tmp->type != IEEE80211_WORK_ASSOC_BEACON_WAIT)
+				continue;
+
+			if (memcmp(req->bssid, tmp->filter_ta, ETH_ALEN))
+				continue;
+
+			not_auth_yet = tmp->type == IEEE80211_WORK_DIRECT_PROBE;
+			list_del_rcu(&tmp->list);
+			synchronize_rcu();
+			wk = tmp;
+			break;
+		}
+		mutex_unlock(&local->mtx);
+
+		if (wk && wk->type == IEEE80211_WORK_ASSOC) {
+			/* clean up dummy sta & TX sync */
+			xrmac_sta_info_destroy_addr(wk->sdata, wk->filter_ta);
+			if (wk->assoc.synced)
+				drv_finish_tx_sync(local, wk->sdata,
+						   wk->filter_ta,
+						   IEEE80211_TX_SYNC_ASSOC);
+		} else if (wk && wk->type == IEEE80211_WORK_AUTH) {
+			if (wk->probe_auth.synced)
+				drv_finish_tx_sync(local, wk->sdata,
+						   wk->filter_ta,
+						   IEEE80211_TX_SYNC_AUTH);
+		}
+		kfree(wk);
+
+		/*
+		 * If somebody requests authentication and we haven't
+		 * sent out an auth frame yet there's no need to send
+		 * out a deauth frame either. If the state was PROBE,
+		 * then this is the case. If it's AUTH we have sent a
+		 * frame, and if it's IDLE we have completed the auth
+		 * process already.
+		 */
+		if (not_auth_yet) {
+			/*__cfg80211_auth_canceled(sdata->dev, bssid); */
+			return 0;
+		}
+	}
+
+	printk(KERN_DEBUG "%s: deauthenticating from %pM by local choice (reason=%d)\n",
+	       sdata->name, bssid, req->reason_code);
+
+	ieee80211_send_deauth_disassoc(sdata, bssid, IEEE80211_STYPE_DEAUTH,
+				       req->reason_code, sdata->dev->ieee80211_ptr,
+				       true);
+	if (assoc_bss)
+		xrmac_sta_info_flush(sdata->local, sdata);
+
+	mutex_lock(&sdata->local->mtx);
+	mac80211_recalc_idle(sdata->local);
+	mutex_unlock(&sdata->local->mtx);
+
+	return 0;
+}
+
+int mac80211_mgd_disassoc(struct ieee80211_sub_if_data *sdata,
+			   struct cfg80211_disassoc_request *req)
+{
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+	u8 bssid[ETH_ALEN];
+
+	mutex_lock(&ifmgd->mtx);
+
+	/*
+	 * cfg80211 should catch this ... but it's racy since
+	 * we can receive a disassoc frame, process it, hand it
+	 * to cfg80211 while that's in a locked section already
+	 * trying to tell us that the user wants to disconnect.
+	 */
+	if (ifmgd->associated != req->bss) {
+		mutex_unlock(&ifmgd->mtx);
+		return -ENOLINK;
+	}
+
+	printk(KERN_DEBUG "%s: disassociating from %pM by local choice (reason=%d)\n",
+	       sdata->name, req->bss->bssid, req->reason_code);
+
+	memcpy(bssid, req->bss->bssid, ETH_ALEN);
+	ieee80211_set_disassoc(sdata, false, true);
+
+	mutex_unlock(&ifmgd->mtx);
+
+	ieee80211_send_deauth_disassoc(sdata, req->bss->bssid,
+			IEEE80211_STYPE_DISASSOC, req->reason_code,
+			 sdata->dev->ieee80211_ptr, !req->local_state_change);
+	xrmac_sta_info_flush(sdata->local, sdata);
+
+	mutex_lock(&sdata->local->mtx);
+	mac80211_recalc_idle(sdata->local);
+	mutex_unlock(&sdata->local->mtx);
+
+	return 0;
+}
+
+void mac80211_cqm_rssi_notify(struct ieee80211_vif *vif,
+			       enum nl80211_cqm_rssi_threshold_event rssi_event,
+			       s32 rssi_level, gfp_t gfp)
+{
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+
+	trace_api_cqm_rssi_notify(sdata, rssi_event);
+
+	cfg80211_cqm_rssi_notify(sdata->dev, rssi_event, rssi_level, gfp);
+}
+#if 0
+void ieee80211_cqm_beacon_miss_notify(struct ieee80211_vif *vif,
+				      gfp_t gfp)
+{
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+
+	cfg80211_cqm_beacon_miss_notify(sdata->dev, gfp);
+}
+
+void ieee80211_cqm_tx_fail_notify(struct ieee80211_vif *vif,
+				      gfp_t gfp)
+{
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+
+	cfg80211_cqm_tx_fail_notify(sdata->dev, gfp);
+}
+
+void ieee80211_p2p_noa_notify(struct ieee80211_vif *vif,
+			      struct cfg80211_p2p_ps *p2p_ps,
+			      gfp_t gfp)
+{
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+
+	cfg80211_p2p_noa_notify(sdata->dev, p2p_ps, gfp);
+}
+
+void ieee80211_driver_hang_notify(struct ieee80211_vif *vif,
+					gfp_t gfp)
+{
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+
+	cfg80211_driver_hang_notify(sdata->dev, gfp);
+}
+#endif
+
+unsigned char mac80211_get_operstate(struct ieee80211_vif *vif)
+{
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+	return sdata->dev->operstate;
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/offchannel.c b/drivers/net/wireless/xr829/umac/offchannel.c
--- a/drivers/net/wireless/xr829/umac/offchannel.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/offchannel.c	2022-08-27 01:22:42.950539847 +0300
@@ -0,0 +1,531 @@
+/*
+ * Off-channel operation helpers
+ *
+ * Copyright 2003, Jouni Malinen <jkmaline@cc.hut.fi>
+ * Copyright 2004, Instant802 Networks, Inc.
+ * Copyright 2005, Devicescape Software, Inc.
+ * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
+ * Copyright 2007, Michael Wu <flamingice@sourmilk.net>
+ * Copyright 2009	Johannes Berg <johannes@sipsolutions.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/export.h>
+#include <net/mac80211.h>
+#include "ieee80211_i.h"
+#include "driver-trace.h"
+#include "driver-ops.h"
+
+/*
+ * inform AP that we will go to sleep so that it will buffer the frames
+ * while we scan
+ */
+#if 0
+static void ieee80211_offchannel_ps_enable(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+
+	sdata->offchannel_ps_enabled = false;
+
+	/* FIXME: what to do when local->pspolling is true? */
+
+	del_timer_sync(&sdata->dynamic_ps_timer);
+	del_timer_sync(&ifmgd->bcn_mon_timer);
+	del_timer_sync(&ifmgd->conn_mon_timer);
+
+	cancel_work_sync(&sdata->dynamic_ps_enable_work);
+
+	if (sdata->vif.bss_conf.ps_enabled) {
+		sdata->offchannel_ps_enabled = true;
+		sdata->vif.bss_conf.ps_enabled = false;
+		mac80211_bss_info_change_notify(sdata, BSS_CHANGED_PS);
+	}
+
+	if (!(sdata->offchannel_ps_enabled) ||
+	    !(local->hw.flags & IEEE80211_HW_PS_NULLFUNC_STACK))
+		/*
+		 * If power save was enabled, no need to send a nullfunc
+		 * frame because AP knows that we are sleeping. But if the
+		 * hardware is creating the nullfunc frame for power save
+		 * status (ie. IEEE80211_HW_PS_NULLFUNC_STACK is not
+		 * enabled) and power save was enabled, the firmware just
+		 * sent a null frame with power save disabled. So we need
+		 * to send a new nullfunc frame to inform the AP that we
+		 * are again sleeping.
+		 */
+		mac80211_send_nullfunc(local, sdata, 1);
+}
+
+/* inform AP that we are awake again, unless power save is enabled */
+static void ieee80211_offchannel_ps_disable(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_local *local = sdata->local;
+
+	if (!sdata->ps_allowed)
+		mac80211_send_nullfunc(local, sdata, 0);
+	else if (sdata->offchannel_ps_enabled) {
+		/*
+		 * In !IEEE80211_HW_PS_NULLFUNC_STACK case the hardware
+		 * will send a nullfunc frame with the powersave bit set
+		 * even though the AP already knows that we are sleeping.
+		 * This could be avoided by sending a null frame with power
+		 * save bit disabled before enabling the power save, but
+		 * this doesn't gain anything.
+		 *
+		 * When IEEE80211_HW_PS_NULLFUNC_STACK is enabled, no need
+		 * to send a nullfunc frame because AP already knows that
+		 * we are sleeping, let's just enable power save mode in
+		 * hardware.
+		 */
+		sdata->vif.bss_conf.ps_enabled = true;
+		mac80211_bss_info_change_notify(sdata, BSS_CHANGED_PS);
+	} else if (sdata->vif.bss_conf.dynamic_ps_timeout > 0) {
+		/*
+		 * If IEEE80211_CONF_PS was not set and the dynamic_ps_timer
+		 * had been running before leaving the operating channel,
+		 * restart the timer now and send a nullfunc frame to inform
+		 * the AP that we are awake.
+		 */
+		mac80211_send_nullfunc(local, sdata, 0);
+		mod_timer(&sdata->dynamic_ps_timer, jiffies +
+			  msecs_to_jiffies(sdata->vif.bss_conf.dynamic_ps_timeout));
+	}
+
+	mac80211_sta_reset_beacon_monitor(sdata);
+	mac80211_sta_reset_conn_monitor(sdata);
+}
+#endif
+
+void ieee80211_offchannel_stop_beaconing(struct ieee80211_local *local)
+{
+	struct ieee80211_sub_if_data *sdata;
+
+	mutex_lock(&local->iflist_mtx);
+	list_for_each_entry(sdata, &local->interfaces, list) {
+		if (!ieee80211_sdata_running(sdata))
+			continue;
+
+		if (sdata->vif.type == NL80211_IFTYPE_P2P_DEVICE)
+			continue;
+
+		/* disable beaconing */
+		if (sdata->vif.type == NL80211_IFTYPE_AP ||
+		    sdata->vif.type == NL80211_IFTYPE_ADHOC ||
+		    sdata->vif.type == NL80211_IFTYPE_MESH_POINT)
+			mac80211_bss_info_change_notify(
+				sdata, BSS_CHANGED_BEACON_ENABLED);
+
+		/*
+		 * only handle non-STA interfaces here, STA interfaces
+		 * are handled in ieee80211_offchannel_stop_station(),
+		 * e.g., from the background scan state machine.
+		 *
+		 * In addition, do not stop monitor interface to allow it to be
+		 * used from user space controlled off-channel operations.
+		 */
+		if (sdata->vif.type != NL80211_IFTYPE_STATION &&
+		    sdata->vif.type != NL80211_IFTYPE_MONITOR) {
+			set_bit(SDATA_STATE_OFFCHANNEL, &sdata->state);
+			netif_tx_stop_all_queues(sdata->dev);
+		}
+	}
+	mutex_unlock(&local->iflist_mtx);
+}
+
+void ieee80211_offchannel_stop_station(struct ieee80211_local *local)
+{
+	struct ieee80211_sub_if_data *sdata;
+
+	/*
+	 * notify the AP about us leaving the channel and stop all STA interfaces
+	 */
+	mutex_lock(&local->iflist_mtx);
+	list_for_each_entry(sdata, &local->interfaces, list) {
+		if (!ieee80211_sdata_running(sdata))
+			continue;
+
+		if (sdata->vif.type == NL80211_IFTYPE_STATION) {
+			set_bit(SDATA_STATE_OFFCHANNEL, &sdata->state);
+			netif_tx_stop_all_queues(sdata->dev);
+#if 0
+			/* TEMPHACK - FW manages power save mode when
+			   doing ROC */
+			if (sdata->u.mgd.associated)
+				ieee80211_offchannel_ps_enable(sdata);
+#endif
+		}
+	}
+	mutex_unlock(&local->iflist_mtx);
+}
+
+void mac80211_offchannel_return(struct ieee80211_local *local,
+				 bool enable_beaconing)
+{
+	struct ieee80211_sub_if_data *sdata;
+
+	mutex_lock(&local->iflist_mtx);
+	list_for_each_entry(sdata, &local->interfaces, list) {
+		if (sdata->vif.type == NL80211_IFTYPE_P2P_DEVICE)
+			continue;
+
+		if (sdata->vif.type != NL80211_IFTYPE_MONITOR) {
+			clear_bit(SDATA_STATE_OFFCHANNEL, &sdata->state);
+		}
+	/* TODO: Combo mode TEMPHACK */
+#if 0
+		if (!ieee80211_sdata_running(sdata))
+			continue;
+#endif
+		/* Tell AP we're back */
+#if 0
+		/* TEMPHACK - FW handles the power save mode when
+		   doing ROC */
+		if (sdata->vif.type == NL80211_IFTYPE_STATION) {
+			if (sdata->u.mgd.associated)
+				ieee80211_offchannel_ps_disable(sdata);
+		}
+#endif
+
+		if (sdata->vif.type != NL80211_IFTYPE_MONITOR) {
+			/*
+			 * This may wake up queues even though the driver
+			 * currently has them stopped. This is not very
+			 * likely, since the driver won't have gotten any
+			 * (or hardly any) new packets while we weren't
+			 * on the right channel, and even if it happens
+			 * it will at most lead to queueing up one more
+			 * packet per queue in mac80211 rather than on
+			 * the interface qdisc.
+			 */
+#ifdef CONFIG_XRMAC_XR_ROAMING_CHANGES
+			if (!sdata->queues_locked)
+#endif
+				netif_tx_wake_all_queues(sdata->dev);
+		}
+
+		/* re-enable beaconing */
+		if (enable_beaconing &&
+		    (sdata->vif.type == NL80211_IFTYPE_AP ||
+		     sdata->vif.type == NL80211_IFTYPE_ADHOC ||
+		     sdata->vif.type == NL80211_IFTYPE_MESH_POINT))
+			mac80211_bss_info_change_notify(
+				sdata, BSS_CHANGED_BEACON_ENABLED);
+	}
+	mutex_unlock(&local->iflist_mtx);
+}
+
+void mac80211_handle_roc_started(struct ieee80211_roc_work *roc)
+{
+	if (roc->notified)
+		return;
+
+	if (roc->mgmt_tx_cookie) {
+		if (!WARN_ON(!roc->frame)) {
+			ieee80211_tx_skb(roc->sdata, roc->frame);
+			roc->frame = NULL;
+		}
+	} else {
+		/*
+		cfg80211_ready_on_channel(roc->hw_roc_dev, roc->cookie,
+					  roc->chan, roc->chan_type, roc->req_duration,
+					  GFP_KERNEL);
+		*/
+		cfg80211_ready_on_channel(&roc->sdata->wdev, roc->cookie,
+				  roc->chan, roc->req_duration,
+				  GFP_KERNEL);
+	}
+
+	roc->notified = true;
+}
+
+static void ieee80211_hw_roc_start(struct work_struct *work)
+{
+	struct ieee80211_local *local =
+		container_of(work, struct ieee80211_local, hw_roc_start);
+	struct ieee80211_roc_work *roc, *dep, *tmp;
+
+	mutex_lock(&local->mtx);
+
+	if (list_empty(&local->roc_list))
+		goto out_unlock;
+
+	roc = list_first_entry(&local->roc_list, struct ieee80211_roc_work,
+			       list);
+
+	if (!roc->started)
+		goto out_unlock;
+
+	roc->hw_begun = true;
+	roc->hw_start_time = local->hw_roc_start_time;
+	roc->local = local;
+
+	mac80211_handle_roc_started(roc);
+	list_for_each_entry_safe(dep, tmp, &roc->dependents, list) {
+		mac80211_handle_roc_started(dep);
+
+		if (dep->duration > roc->duration) {
+			u32 dur = dep->duration;
+			dep->duration = dur - roc->duration;
+			roc->duration = dur;
+			list_move(&dep->list, &roc->list);
+		}
+	}
+ out_unlock:
+	mutex_unlock(&local->mtx);
+}
+
+void mac80211_ready_on_channel(struct ieee80211_hw *hw)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+
+	local->hw_roc_start_time = jiffies;
+
+	trace_api_ready_on_channel(local);
+
+	mac80211_queue_work(hw, &local->hw_roc_start);
+}
+
+void mac80211_start_next_roc(struct ieee80211_local *local)
+{
+	struct ieee80211_roc_work *roc;
+
+	lockdep_assert_held(&local->mtx);
+
+	if (list_empty(&local->roc_list)) {
+		/*ieee80211_run_deferred_scan(local);*/
+		return;
+	}
+
+	roc = list_first_entry(&local->roc_list, struct ieee80211_roc_work,
+			       list);
+
+	if (WARN_ON_ONCE(roc->started))
+		return;
+
+	if (local->ops->remain_on_channel) {
+		int ret, duration = roc->duration;
+
+		/* XXX: duplicated, see ieee80211_start_roc_work() */
+		if (!duration)
+			duration = 10;
+
+		ret = drv_remain_on_channel(local, roc->sdata, roc->chan, NL80211_CHAN_NO_HT,
+					    duration,
+					    (roc->mgmt_tx_cookie ? roc->mgmt_tx_cookie : roc->cookie));
+
+		roc->started = true;
+
+		if (ret) {
+			wiphy_warn(local->hw.wiphy,
+				   "failed to start next HW ROC (%d)\n", ret);
+			/*
+			 * queue the work struct again to avoid recursion
+			 * when multiple failures occur
+			 */
+			mac80211_remain_on_channel_expired(&local->hw,
+					(roc->mgmt_tx_cookie ? roc->mgmt_tx_cookie : roc->cookie));
+		} else
+			local->hw_roc_channel = roc->chan;
+	} else {
+		/* delay it a bit */
+		mac80211_queue_delayed_work(&local->hw, &roc->work,
+					     round_jiffies_relative(HZ/2));
+	}
+}
+
+void mac80211_roc_notify_destroy(struct ieee80211_roc_work *roc)
+{
+	struct ieee80211_roc_work *dep, *tmp;
+
+	/* was never transmitted */
+	if (roc->frame) {
+		cfg80211_mgmt_tx_status(&roc->sdata->wdev,
+					(unsigned long)roc->frame,
+					roc->frame->data, roc->frame->len,
+					false, GFP_KERNEL);
+		kfree_skb(roc->frame);
+	}
+
+	/*
+	if (!roc->mgmt_tx_cookie)
+	cfg80211_remain_on_channel_expired(roc->hw_roc_dev,
+						   roc->cookie, roc->chan, roc->chan_type,
+						   GFP_KERNEL);
+	*/
+	if (!roc->mgmt_tx_cookie)
+		cfg80211_remain_on_channel_expired(&roc->sdata->wdev,
+						   roc->cookie, roc->chan,
+						   GFP_KERNEL);
+
+
+	list_for_each_entry_safe(dep, tmp, &roc->dependents, list)
+		mac80211_roc_notify_destroy(dep);
+
+	kfree(roc);
+}
+
+void mac80211_sw_roc_work(struct work_struct *work)
+{
+	struct ieee80211_roc_work *roc =
+		container_of(work, struct ieee80211_roc_work, work.work);
+	struct ieee80211_sub_if_data *sdata = roc->sdata;
+	struct ieee80211_local *local = sdata->local;
+	bool started;
+
+	mutex_lock(&local->mtx);
+
+	if (roc->abort)
+		goto finish;
+
+	if (WARN_ON(list_empty(&local->roc_list)))
+		goto out_unlock;
+
+	if (WARN_ON(roc != list_first_entry(&local->roc_list,
+					    struct ieee80211_roc_work,
+					    list)))
+		goto out_unlock;
+
+	if (!roc->started) {
+		struct ieee80211_roc_work *dep;
+
+		/* start this ROC */
+
+		/* switch channel etc */
+		mac80211_recalc_idle(local);
+
+		local->tmp_channel = roc->chan;
+		mac80211_hw_config(local, 0);
+
+		/* tell userspace or send frame */
+		mac80211_handle_roc_started(roc);
+		list_for_each_entry(dep, &roc->dependents, list)
+			mac80211_handle_roc_started(dep);
+
+		/* if it was pure TX, just finish right away */
+		if (!roc->duration)
+			goto finish;
+
+		roc->started = true;
+		mac80211_queue_delayed_work(&local->hw, &roc->work,
+					     msecs_to_jiffies(roc->duration));
+	} else {
+		/* finish this ROC */
+ finish:
+		list_del(&roc->list);
+		started = roc->started;
+		mac80211_roc_notify_destroy(roc);
+
+		if (started) {
+			drv_flush(local, sdata, false);
+
+			local->tmp_channel = NULL;
+			mac80211_hw_config(local, 0);
+
+			mac80211_offchannel_return(local, true);
+		}
+
+		mac80211_recalc_idle(local);
+
+		if (started)
+			mac80211_start_next_roc(local);
+	}
+
+ out_unlock:
+	mutex_unlock(&local->mtx);
+}
+
+static void ieee80211_hw_roc_done(struct work_struct *work)
+{
+	struct ieee80211_local *local =
+		container_of(work, struct ieee80211_local, hw_roc_done);
+	struct ieee80211_roc_work *roc;
+	u64	cookie;
+
+	mutex_lock(&local->mtx);
+
+	if (list_empty(&local->roc_list))
+		goto out_unlock;
+
+	roc = list_first_entry(&local->roc_list, struct ieee80211_roc_work,
+			       list);
+
+	if (!roc->started)
+		goto out_unlock;
+
+	cookie = roc->mgmt_tx_cookie ? roc->mgmt_tx_cookie : roc->cookie;
+
+	if (cookie != local->roc_cookie) {
+		local->roc_cookie = 0;
+		goto out_unlock;
+	}
+	local->roc_cookie = 0;
+	list_del(&roc->list);
+
+	mac80211_roc_notify_destroy(roc);
+
+	local->hw_roc_channel = NULL;
+
+	/* if there's another roc, start it now */
+	mac80211_start_next_roc(local);
+
+ out_unlock:
+	mutex_unlock(&local->mtx);
+}
+
+void mac80211_remain_on_channel_expired(struct ieee80211_hw *hw, u64 cookie)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	/*struct ieee80211_roc_work *roc;*/
+	local->roc_cookie = cookie;
+
+	trace_api_remain_on_channel_expired(local);
+
+	mac80211_queue_work(hw, &local->hw_roc_done);
+}
+
+void mac80211_hw_roc_setup(struct ieee80211_local *local)
+{
+	INIT_WORK(&local->hw_roc_start, ieee80211_hw_roc_start);
+	INIT_WORK(&local->hw_roc_done, ieee80211_hw_roc_done);
+	INIT_LIST_HEAD(&local->roc_list);
+}
+
+void mac80211_roc_purge(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_roc_work *roc, *tmp;
+	LIST_HEAD(tmp_list);
+
+	mutex_lock(&local->mtx);
+	list_for_each_entry_safe(roc, tmp, &local->roc_list, list) {
+		if (roc->sdata != sdata)
+			continue;
+
+		if (roc->started && local->ops->remain_on_channel) {
+			/* can race, so ignore return value */
+			drv_cancel_remain_on_channel(local);
+		}
+
+		list_move_tail(&roc->list, &tmp_list);
+		roc->abort = true;
+	}
+	local->hw_roc_channel = NULL;
+	mutex_unlock(&local->mtx);
+
+	list_for_each_entry_safe(roc, tmp, &tmp_list, list) {
+		if (local->ops->remain_on_channel) {
+			list_del(&roc->list);
+			mac80211_roc_notify_destroy(roc);
+		} else {
+			mac80211_queue_delayed_work(&local->hw, &roc->work, 0);
+
+			/* work will clean up etc */
+			flush_delayed_work(&roc->work);
+		}
+	}
+
+	WARN_ON_ONCE(!list_empty(&tmp_list));
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/pm.c b/drivers/net/wireless/xr829/umac/pm.c
--- a/drivers/net/wireless/xr829/umac/pm.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/pm.c	2022-08-27 01:22:42.950539847 +0300
@@ -0,0 +1,252 @@
+#include <net/mac80211.h>
+#include <net/rtnetlink.h>
+#include <linux/pm_qos.h>
+
+#include "ieee80211_i.h"
+#include "mesh.h"
+#include "driver-ops.h"
+#include "led.h"
+
+/* return value indicates whether the driver should be further notified */
+static bool ieee80211_quiesce(struct ieee80211_sub_if_data *sdata)
+{
+	switch (sdata->vif.type) {
+	case NL80211_IFTYPE_STATION:
+		mac80211_sta_quiesce(sdata);
+		return true;
+	case NL80211_IFTYPE_ADHOC:
+		mac80211_ibss_quiesce(sdata);
+		return true;
+	case NL80211_IFTYPE_MESH_POINT:
+		mac80211_mesh_quiesce(sdata);
+		return true;
+	case NL80211_IFTYPE_AP_VLAN:
+	case NL80211_IFTYPE_MONITOR:
+		/* don't tell driver about this */
+		return false;
+	default:
+		return true;
+	}
+}
+
+int __mac80211_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct ieee80211_sub_if_data *sdata;
+	struct sta_info *sta;
+
+	/* PM code has a watchdog to trigger a BUG when
+	 * suspend callback is not returning in several seconds.
+	 * Some WLAN hardware has longer timeouts for non-interruptible
+	 * configuration-related operations, leading to the watchdog
+	 * timeout while mac80211_scan_cancel is waiting on the mutex.
+	 *
+	 * The code below checks if interface mutex is already held
+	 * and rejects suspend if there is a possibility of locking.
+	 *
+	 * It's a bit racy, but handles most of cases.
+	 */
+	if (mutex_trylock(&local->mtx))
+		mutex_unlock(&local->mtx);
+	else {
+		wiphy_warn(hw->wiphy, "Suspend when operation "
+			"is in progress. Suspend aborted.\n");
+		return -EBUSY;
+	}
+
+/*
+	if (!local->open_count)
+		goto suspend;
+*/
+	mac80211_scan_cancel(local);
+
+	if (hw->flags & IEEE80211_HW_AMPDU_AGGREGATION) {
+		mutex_lock(&local->sta_mtx);
+		list_for_each_entry(sta, &local->sta_list, list) {
+			set_sta_flag(sta, WLAN_STA_BLOCK_BA);
+			mac80211_sta_tear_down_BA_sessions(sta, true);
+		}
+		mutex_unlock(&local->sta_mtx);
+	}
+
+	mac80211_stop_queues_by_reason(hw,
+			IEEE80211_QUEUE_STOP_REASON_SUSPEND);
+
+	/* flush out all packets */
+	synchronize_net();
+	list_for_each_entry(sdata, &local->interfaces, list)
+		drv_flush(local, sdata, false);
+
+	local->quiescing = true;
+	/* make quiescing visible to timers everywhere */
+	mb();
+
+	flush_workqueue(local->workqueue);
+
+	/* Don't try to run timers while suspended. */
+	del_timer_sync(&local->sta_cleanup);
+
+	 /*
+	 * Note that this particular timer doesn't need to be
+	 * restarted at resume.
+	 */
+	list_for_each_entry(sdata, &local->interfaces, list) {
+		cancel_work_sync(&sdata->dynamic_ps_enable_work);
+		del_timer_sync(&sdata->dynamic_ps_timer);
+	}
+
+	/*wowlan is useless to xradio_wow_suspend.*/
+	local->wowlan = true;
+	if (local->wowlan) {
+		int err = drv_suspend(local, wowlan);
+		if (err < 0) {
+			local->quiescing = false;
+			mac80211_wake_queues_by_reason(hw,
+					IEEE80211_QUEUE_STOP_REASON_SUSPEND);
+			return err;
+		} else if (err > 0) {
+			WARN_ON(err != 1);
+			local->wowlan = false;
+		} else {
+			list_for_each_entry(sdata, &local->interfaces, list) {
+				cancel_work_sync(&sdata->work);
+				ieee80211_quiesce(sdata);
+			}
+			goto suspend;
+		}
+		list_for_each_entry(sdata, &local->interfaces, list) {
+			cancel_work_sync(&sdata->work);
+		}
+		goto suspend;
+	}
+
+	/* disable keys */
+	list_for_each_entry(sdata, &local->interfaces, list)
+		mac80211_disable_keys(sdata);
+
+	/* tear down aggregation sessions and remove STAs */
+	mutex_lock(&local->sta_mtx);
+	list_for_each_entry(sta, &local->sta_list, list) {
+		if (sta->uploaded) {
+			sdata = sta->sdata;
+			if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
+				sdata = container_of(sdata->bss,
+					     struct ieee80211_sub_if_data,
+					     u.ap);
+
+			drv_sta_remove(local, sdata, &sta->sta);
+		}
+
+		xrmac_mesh_plink_quiesce(sta);
+	}
+	mutex_unlock(&local->sta_mtx);
+
+	/* remove all interfaces */
+	list_for_each_entry(sdata, &local->interfaces, list) {
+		cancel_work_sync(&sdata->work);
+
+		if (!ieee80211_quiesce(sdata))
+			continue;
+
+		if (!ieee80211_sdata_running(sdata))
+			continue;
+
+		/* disable beaconing */
+		mac80211_bss_info_change_notify(sdata,
+			BSS_CHANGED_BEACON_ENABLED);
+
+		drv_remove_interface(local, &sdata->vif);
+	}
+
+	/* stop hardware - this must stop RX */
+	if (local->open_count)
+		mac80211_stop_device(local);
+
+ suspend:
+	local->suspended = true;
+	/* need suspended to be visible before quiescing is false */
+	barrier();
+	local->quiescing = false;
+
+#ifdef ROAM_OFFLOAD
+	local->sched_scanning = true;
+#endif /*ROAM_OFFLOAD*/
+
+	return 0;
+}
+
+/*
+ * __ieee80211_resume() is a static inline which just calls
+ * mac80211_reconfig(), which is also needed for hardware
+ * hang/firmware failure/etc. recovery.
+ */
+
+static BLOCKING_NOTIFIER_HEAD(network_lat_notifier);
+static struct pm_qos_constraints network_lat_constraints = {
+	.list = PLIST_HEAD_INIT(network_lat_constraints.list),
+	.target_value = PM_QOS_NETWORK_LAT_DEFAULT_VALUE,
+	.default_value = PM_QOS_NETWORK_LAT_DEFAULT_VALUE,
+	.no_constraint_value = PM_QOS_NETWORK_LAT_DEFAULT_VALUE,
+	.type = PM_QOS_MIN,
+	.notifiers = &network_lat_notifier,
+};
+static struct xr_pm_qos_object network_lat_pm_qos = {
+	.constraints = &network_lat_constraints,
+	.name = "network_latency",
+};
+
+static BLOCKING_NOTIFIER_HEAD(network_throughput_notifier);
+static struct pm_qos_constraints network_tput_constraints = {
+	.list = PLIST_HEAD_INIT(network_tput_constraints.list),
+	.target_value = PM_QOS_NETWORK_THROUGHPUT_DEFAULT_VALUE,
+	.default_value = PM_QOS_NETWORK_THROUGHPUT_DEFAULT_VALUE,
+	.no_constraint_value = PM_QOS_NETWORK_THROUGHPUT_DEFAULT_VALUE,
+	.type = PM_QOS_MAX,
+	.notifiers = &network_throughput_notifier,
+};
+struct xr_pm_qos_object network_throughput_pm_qos = {
+	.constraints = &network_tput_constraints,
+	.name = "network_throughput",
+};
+
+static BLOCKING_NOTIFIER_HEAD(memory_bandwidth_notifier);
+
+static struct xr_pm_qos_object null_pm_qos;
+static struct xr_pm_qos_object cpu_dma_pm_qos;
+
+static struct xr_pm_qos_object *xr_pm_qos_array[] = {
+	&null_pm_qos,
+	&cpu_dma_pm_qos,
+	&network_lat_pm_qos,
+	&network_throughput_pm_qos,
+};
+
+int xr_pm_qos_request(int pm_qos_class)
+{
+	return xr_pm_qos_array[pm_qos_class]->constraints->target_value;
+}
+
+int xr_pm_qos_add_notifier(int pm_qos_class,
+			struct notifier_block *notifier)
+{
+	int retval;
+
+	retval = blocking_notifier_chain_register(
+			xr_pm_qos_array[pm_qos_class]->constraints->notifiers,
+			notifier);
+
+	return retval;
+}
+
+int xr_pm_qos_remove_notifier(int pm_qos_class,
+				struct notifier_block *notifier)
+{
+	 int retval;
+
+	retval = blocking_notifier_chain_unregister(
+			xr_pm_qos_array[pm_qos_class]->constraints->notifiers,
+			notifier);
+
+	return retval;
+}
+
diff -Naurp a/drivers/net/wireless/xr829/umac/rate.c b/drivers/net/wireless/xr829/umac/rate.c
--- a/drivers/net/wireless/xr829/umac/rate.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/rate.c	2022-08-27 01:22:42.950539847 +0300
@@ -0,0 +1,442 @@
+/*
+ * Copyright 2002-2005, Instant802 Networks, Inc.
+ * Copyright 2005-2006, Devicescape Software, Inc.
+ * Copyright (c) 2006 Jiri Benc <jbenc@suse.cz>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/rtnetlink.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include "rate.h"
+#include "ieee80211_i.h"
+#include "debugfs.h"
+
+struct rate_control_alg {
+	struct list_head list;
+	struct rate_control_ops *ops;
+};
+
+static LIST_HEAD(rate_ctrl_algs);
+static DEFINE_MUTEX(rate_ctrl_mutex);
+
+static char *ieee80211_default_rc_algo = CONFIG_XRMAC_RC_DEFAULT;
+module_param(ieee80211_default_rc_algo, charp, 0644);
+MODULE_PARM_DESC(ieee80211_default_rc_algo,
+		 "Default rate control algorithm for mac80211 to use");
+
+int mac80211_rate_control_register(struct rate_control_ops *ops)
+{
+	struct rate_control_alg *alg;
+
+	if (!ops->name)
+		return -EINVAL;
+
+	mutex_lock(&rate_ctrl_mutex);
+	list_for_each_entry(alg, &rate_ctrl_algs, list) {
+		if (!strcmp(alg->ops->name, ops->name)) {
+			/* don't register an algorithm twice */
+			WARN_ON(1);
+			mutex_unlock(&rate_ctrl_mutex);
+			return -EALREADY;
+		}
+	}
+
+	alg = kzalloc(sizeof(*alg), GFP_KERNEL);
+	if (alg == NULL) {
+		mutex_unlock(&rate_ctrl_mutex);
+		return -ENOMEM;
+	}
+	alg->ops = ops;
+
+	list_add_tail(&alg->list, &rate_ctrl_algs);
+	mutex_unlock(&rate_ctrl_mutex);
+
+	return 0;
+}
+
+void mac80211_rate_control_unregister(struct rate_control_ops *ops)
+{
+	struct rate_control_alg *alg;
+
+	mutex_lock(&rate_ctrl_mutex);
+	list_for_each_entry(alg, &rate_ctrl_algs, list) {
+		if (alg->ops == ops) {
+			list_del(&alg->list);
+			kfree(alg);
+			break;
+		}
+	}
+	mutex_unlock(&rate_ctrl_mutex);
+}
+
+static struct rate_control_ops *
+ieee80211_try_rate_control_ops_get(const char *name)
+{
+	struct rate_control_alg *alg;
+	struct rate_control_ops *ops = NULL;
+
+	if (!name)
+		return NULL;
+
+	mutex_lock(&rate_ctrl_mutex);
+	list_for_each_entry(alg, &rate_ctrl_algs, list) {
+		if (!strcmp(alg->ops->name, name))
+			if (try_module_get(alg->ops->module)) {
+				ops = alg->ops;
+				break;
+			}
+	}
+	mutex_unlock(&rate_ctrl_mutex);
+	return ops;
+}
+
+/* Get the rate control algorithm. */
+static struct rate_control_ops *
+ieee80211_rate_control_ops_get(const char *name)
+{
+	struct rate_control_ops *ops;
+	const char *alg_name;
+
+	kernel_param_lock(THIS_MODULE);
+	if (!name)
+		alg_name = ieee80211_default_rc_algo;
+	else
+		alg_name = name;
+
+	ops = ieee80211_try_rate_control_ops_get(alg_name);
+	if (!ops) {
+		request_module("rc80211_%s", alg_name);
+		ops = ieee80211_try_rate_control_ops_get(alg_name);
+	}
+	if (!ops && name)
+		/* try default if specific alg requested but not found */
+		ops = ieee80211_try_rate_control_ops_get(ieee80211_default_rc_algo);
+
+	/* try built-in one if specific alg requested but not found */
+	if (!ops && strlen(CONFIG_XRMAC_RC_DEFAULT) != 0)
+		ops = ieee80211_try_rate_control_ops_get(CONFIG_XRMAC_RC_DEFAULT);
+	kernel_param_unlock(THIS_MODULE);
+
+	return ops;
+}
+
+static void ieee80211_rate_control_ops_put(struct rate_control_ops *ops)
+{
+	module_put(ops->module);
+}
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+static ssize_t rcname_read(struct file *file, char __user *userbuf,
+			   size_t count, loff_t *ppos)
+{
+	struct rate_control_ref *ref = file->private_data;
+	int len = strlen(ref->ops->name);
+
+	return simple_read_from_buffer(userbuf, count, ppos,
+				       ref->ops->name, len);
+}
+
+static const struct file_operations rcname_ops = {
+	.read = rcname_read,
+	.open = mac80211_open_file_generic,
+	.llseek = default_llseek,
+};
+#endif
+
+static struct rate_control_ref *rate_control_alloc(const char *name,
+					    struct ieee80211_local *local)
+{
+	struct dentry *debugfsdir = NULL;
+	struct rate_control_ref *ref;
+
+	ref = kmalloc(sizeof(struct rate_control_ref), GFP_KERNEL);
+	if (!ref)
+		goto fail_ref;
+	kref_init(&ref->kref);
+	ref->local = local;
+	ref->ops = ieee80211_rate_control_ops_get(name);
+	if (!ref->ops)
+		goto fail_ops;
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	debugfsdir = debugfs_create_dir("rc", local->hw.wiphy->debugfsdir);
+	local->debugfs.rcdir = debugfsdir;
+	debugfs_create_file("name", 0400, debugfsdir, ref, &rcname_ops);
+#endif
+
+	ref->priv = ref->ops->alloc(&local->hw, debugfsdir);
+	if (!ref->priv)
+		goto fail_priv;
+	return ref;
+
+fail_priv:
+	ieee80211_rate_control_ops_put(ref->ops);
+fail_ops:
+	kfree(ref);
+fail_ref:
+	return NULL;
+}
+
+static void rate_control_release(struct kref *kref)
+{
+	struct rate_control_ref *ctrl_ref;
+
+	ctrl_ref = container_of(kref, struct rate_control_ref, kref);
+	ctrl_ref->ops->free(ctrl_ref->priv);
+
+#ifdef CONFIG_XRMAO_DEBUGFS
+	debugfs_remove_recursive(ctrl_ref->local->debugfs.rcdir);
+	ctrl_ref->local->debugfs.rcdir = NULL;
+#endif
+
+	ieee80211_rate_control_ops_put(ctrl_ref->ops);
+	kfree(ctrl_ref);
+}
+
+static bool rc_no_data_or_no_ack_use_min(struct ieee80211_tx_rate_control *txrc)
+{
+	struct sk_buff *skb = txrc->skb;
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	__le16 fc;
+
+	fc = hdr->frame_control;
+
+	return (info->flags & (IEEE80211_TX_CTL_NO_ACK |
+			       IEEE80211_TX_CTL_USE_MINRATE)) ||
+		!ieee80211_is_data(fc);
+}
+
+static void rc_send_low_broadcast(s8 *idx, u32 basic_rates,
+				  struct ieee80211_supported_band *sband)
+{
+	u8 i;
+
+	if (basic_rates == 0)
+		return; /* assume basic rates unknown and accept rate */
+	if (*idx < 0)
+		return;
+	if (basic_rates & (1 << *idx))
+		return; /* selected rate is a basic rate */
+
+	for (i = *idx + 1; i <= sband->n_bitrates; i++) {
+		if (basic_rates & (1 << i)) {
+			*idx = i;
+			return;
+		}
+	}
+
+	/* could not find a basic rate; use original selection */
+}
+
+static inline s8
+rate_lowest_non_cck_index(struct ieee80211_supported_band *sband,
+			  struct ieee80211_sta *sta)
+{
+	int i;
+
+	for (i = 0; i < sband->n_bitrates; i++) {
+		struct ieee80211_rate *srate = &sband->bitrates[i];
+		if ((srate->bitrate == 10) || (srate->bitrate == 20) ||
+		    (srate->bitrate == 55) || (srate->bitrate == 110))
+			continue;
+
+		if (rate_supported(sta, sband->band, i))
+			return i;
+	}
+
+	/* No matching rate found */
+	return 0;
+}
+
+
+bool xrmac_rate_control_send_low(struct ieee80211_sta *sta,
+			   void *priv_sta,
+			   struct ieee80211_tx_rate_control *txrc)
+{
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(txrc->skb);
+	struct ieee80211_supported_band *sband = txrc->sband;
+	int mcast_rate;
+
+	if (!sta || !priv_sta || rc_no_data_or_no_ack_use_min(txrc)) {
+		if ((sband->band != NL80211_BAND_2GHZ) ||
+		    !(info->flags & IEEE80211_TX_CTL_NO_CCK_RATE))
+			info->control.rates[0].idx =
+				rate_lowest_index(txrc->sband, sta);
+		else
+			info->control.rates[0].idx =
+				rate_lowest_non_cck_index(txrc->sband, sta);
+		info->control.rates[0].count =
+			(info->flags & IEEE80211_TX_CTL_NO_ACK) ?
+			1 : txrc->hw->max_rate_tries;
+		if (!sta && txrc->bss) {
+			mcast_rate = txrc->bss_conf->mcast_rate[sband->band];
+			if (mcast_rate > 0) {
+				info->control.rates[0].idx = mcast_rate - 1;
+				return true;
+			}
+
+			rc_send_low_broadcast(&info->control.rates[0].idx,
+					      txrc->bss_conf->basic_rates,
+					      sband);
+		}
+		return true;
+	}
+	return false;
+}
+
+static void rate_idx_match_mask(struct ieee80211_tx_rate *rate,
+				int n_bitrates, u32 mask)
+{
+	int j;
+
+	/* See whether the selected rate or anything below it is allowed. */
+	for (j = rate->idx; j >= 0; j--) {
+		if (mask & (1 << j)) {
+			/* Okay, found a suitable rate. Use it. */
+			rate->idx = j;
+			return;
+		}
+	}
+
+	/* Try to find a higher rate that would be allowed */
+	for (j = rate->idx + 1; j < n_bitrates; j++) {
+		if (mask & (1 << j)) {
+			/* Okay, found a suitable rate. Use it. */
+			rate->idx = j;
+			return;
+		}
+	}
+
+	/*
+	 * Uh.. No suitable rate exists. This should not really happen with
+	 * sane TX rate mask configurations. However, should someone manage to
+	 * configure supported rates and TX rate mask in incompatible way,
+	 * allow the frame to be transmitted with whatever the rate control
+	 * selected.
+	 */
+}
+
+void xrmac_rate_control_get_rate(struct ieee80211_sub_if_data *sdata,
+			   struct sta_info *sta,
+			   struct ieee80211_tx_rate_control *txrc)
+{
+	struct rate_control_ref *ref = sdata->local->rate_ctrl;
+	void *priv_sta = NULL;
+	struct ieee80211_sta *ista = NULL;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(txrc->skb);
+	int i;
+	u32 mask;
+
+	if (sta) {
+		ista = &sta->sta;
+		priv_sta = sta->rate_ctrl_priv;
+	}
+
+	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {
+		info->control.rates[i].idx = -1;
+		info->control.rates[i].flags = 0;
+		info->control.rates[i].count = 1;
+	}
+
+	if (sdata->local->hw.flags & IEEE80211_HW_HAS_RATE_CONTROL)
+		return;
+
+	ref->ops->get_rate(ref->priv, ista, priv_sta, txrc);
+
+	/*
+	 * Try to enforce the rateidx mask the user wanted. skip this if the
+	 * default mask (allow all rates) is used to save some processing for
+	 * the common case.
+	 */
+	mask = sdata->rc_rateidx_mask[info->band];
+	if (mask != (1 << txrc->sband->n_bitrates) - 1) {
+		if (sta) {
+			/* Filter out rates that the STA does not support */
+			mask &= sta->sta.supp_rates[info->band];
+		}
+		/*
+		 * Make sure the rate index selected for each TX rate is
+		 * included in the configured mask and change the rate indexes
+		 * if needed.
+		 */
+		for (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {
+			/* Skip invalid rates */
+			if (info->control.rates[i].idx < 0)
+				break;
+			/* Rate masking supports only legacy rates for now */
+			if (info->control.rates[i].flags & IEEE80211_TX_RC_MCS)
+				continue;
+			rate_idx_match_mask(&info->control.rates[i],
+					    txrc->sband->n_bitrates, mask);
+		}
+	}
+
+	BUG_ON(info->control.rates[0].idx < 0);
+}
+
+struct rate_control_ref *rate_control_get(struct rate_control_ref *ref)
+{
+	kref_get(&ref->kref);
+	return ref;
+}
+
+void rate_control_put(struct rate_control_ref *ref)
+{
+	kref_put(&ref->kref, rate_control_release);
+}
+
+int mac80211_init_rate_ctrl_alg(struct ieee80211_local *local,
+				 const char *name)
+{
+	struct rate_control_ref *ref, *old;
+
+	ASSERT_RTNL();
+
+	if (local->open_count)
+		return -EBUSY;
+
+	if (local->hw.flags & IEEE80211_HW_HAS_RATE_CONTROL) {
+		if (WARN_ON(!local->ops->set_rts_threshold))
+			return -EINVAL;
+		return 0;
+	}
+
+	ref = rate_control_alloc(name, local);
+	if (!ref) {
+		wiphy_warn(local->hw.wiphy,
+			   "Failed to select rate control algorithm\n");
+		return -ENOENT;
+	}
+
+	old = local->rate_ctrl;
+	local->rate_ctrl = ref;
+	if (old) {
+		rate_control_put(old);
+		xrmac_sta_info_flush(local, NULL);
+	}
+
+	wiphy_debug(local->hw.wiphy, "Selected rate control algorithm '%s'\n",
+		    ref->ops->name);
+
+	return 0;
+}
+
+void xrmac_rate_control_deinitialize(struct ieee80211_local *local)
+{
+	struct rate_control_ref *ref;
+
+	ref = local->rate_ctrl;
+
+	if (!ref)
+		return;
+
+	local->rate_ctrl = NULL;
+	rate_control_put(ref);
+}
+
diff -Naurp a/drivers/net/wireless/xr829/umac/rate.h b/drivers/net/wireless/xr829/umac/rate.h
--- a/drivers/net/wireless/xr829/umac/rate.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/rate.h	2022-08-27 01:22:42.950539847 +0300
@@ -0,0 +1,165 @@
+/*
+ * Copyright 2002-2005, Instant802 Networks, Inc.
+ * Copyright 2005, Devicescape Software, Inc.
+ * Copyright (c) 2006 Jiri Benc <jbenc@suse.cz>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef IEEE80211_RATE_H
+#define IEEE80211_RATE_H
+
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/types.h>
+#include <linux/kref.h>
+#include <net/mac80211.h>
+#include "ieee80211_i.h"
+#include "sta_info.h"
+
+struct rate_control_ref {
+	struct ieee80211_local *local;
+	struct rate_control_ops *ops;
+	void *priv;
+	struct kref kref;
+};
+
+void xrmac_rate_control_get_rate(struct ieee80211_sub_if_data *sdata,
+			   struct sta_info *sta,
+			   struct ieee80211_tx_rate_control *txrc);
+struct rate_control_ref *rate_control_get(struct rate_control_ref *ref);
+void rate_control_put(struct rate_control_ref *ref);
+
+static inline void rate_control_tx_status(struct ieee80211_local *local,
+					  struct ieee80211_supported_band *sband,
+					  struct sta_info *sta,
+					  struct sk_buff *skb)
+{
+	struct rate_control_ref *ref = local->rate_ctrl;
+	struct ieee80211_sta *ista = &sta->sta;
+	void *priv_sta = sta->rate_ctrl_priv;
+
+	if (!ref)
+		return;
+
+	ref->ops->tx_status(ref->priv, sband, ista, priv_sta, skb);
+}
+
+
+static inline void rate_control_rate_init(struct sta_info *sta)
+{
+	struct ieee80211_local *local = sta->sdata->local;
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sta->sdata);
+	struct rate_control_ref *ref = sta->rate_ctrl;
+	struct ieee80211_sta *ista = &sta->sta;
+	void *priv_sta = sta->rate_ctrl_priv;
+	struct ieee80211_supported_band *sband;
+
+	if (!ref)
+		return;
+
+	sband = local->hw.wiphy->bands[chan_state->conf.channel->band];
+
+	ref->ops->rate_init(ref->priv, sband, ista, priv_sta);
+}
+
+static inline void rate_control_rate_update(struct ieee80211_local *local,
+				    struct ieee80211_supported_band *sband,
+				    struct sta_info *sta, u32 changed,
+				    enum nl80211_channel_type oper_chan_type)
+{
+	struct rate_control_ref *ref = local->rate_ctrl;
+	struct ieee80211_sta *ista = &sta->sta;
+	void *priv_sta = sta->rate_ctrl_priv;
+
+	if (ref && ref->ops->rate_update)
+		ref->ops->rate_update(ref->priv, sband, ista,
+				      priv_sta, changed, oper_chan_type);
+}
+
+static inline void *rate_control_alloc_sta(struct rate_control_ref *ref,
+					   struct ieee80211_sta *sta,
+					   gfp_t gfp)
+{
+	return ref->ops->alloc_sta(ref->priv, sta, gfp);
+}
+
+static inline void rate_control_free_sta(struct sta_info *sta)
+{
+	struct rate_control_ref *ref = sta->rate_ctrl;
+	struct ieee80211_sta *ista = &sta->sta;
+	void *priv_sta = sta->rate_ctrl_priv;
+
+	ref->ops->free_sta(ref->priv, ista, priv_sta);
+}
+
+static inline void rate_control_add_sta_debugfs(struct sta_info *sta)
+{
+#ifdef CONFIG_XRMAC_DEBUGFS
+	struct rate_control_ref *ref = sta->rate_ctrl;
+	if (ref && sta->debugfs.dir && ref->ops->add_sta_debugfs)
+		ref->ops->add_sta_debugfs(ref->priv, sta->rate_ctrl_priv,
+					  sta->debugfs.dir);
+#endif
+}
+
+static inline void rate_control_remove_sta_debugfs(struct sta_info *sta)
+{
+#ifdef CONFIG_XRMAC_DEBUGFS
+	struct rate_control_ref *ref = sta->rate_ctrl;
+	if (ref && ref->ops->remove_sta_debugfs)
+		ref->ops->remove_sta_debugfs(ref->priv, sta->rate_ctrl_priv);
+#endif
+}
+
+/* Get a reference to the rate control algorithm. If `name' is NULL, get the
+ * first available algorithm. */
+int mac80211_init_rate_ctrl_alg(struct ieee80211_local *local,
+				 const char *name);
+void xrmac_rate_control_deinitialize(struct ieee80211_local *local);
+
+
+/* Rate control algorithms */
+#ifdef CONFIG_XRMAC_RC_PID
+extern int xrmac_rc80211_pid_init(void);
+extern void xrmac_rc80211_pid_exit(void);
+#else
+static inline int xrmac_rc80211_pid_init(void)
+{
+	return 0;
+}
+static inline void xrmac_rc80211_pid_exit(void)
+{
+}
+#endif
+
+#ifdef CONFIG_XRMAC_RC_MINSTREL
+extern int xrmac_rc80211_minstrel_init(void);
+extern void xrmac_rc80211_minstrel_exit(void);
+#else
+static inline int xrmac_rc80211_minstrel_init(void)
+{
+	return 0;
+}
+static inline void xrmac_rc80211_minstrel_exit(void)
+{
+}
+#endif
+
+#ifdef CONFIG_XRMAC_RC_MINSTREL_HT
+extern int xrmac_rc80211_minstrel_ht_init(void);
+extern void xrmac_rc80211_minstrel_ht_exit(void);
+#else
+static inline int xrmac_rc80211_minstrel_ht_init(void)
+{
+	return 0;
+}
+static inline void xrmac_rc80211_minstrel_ht_exit(void)
+{
+}
+#endif
+
+
+#endif /* IEEE80211_RATE_H */
diff -Naurp a/drivers/net/wireless/xr829/umac/rc80211_minstrel.c b/drivers/net/wireless/xr829/umac/rc80211_minstrel.c
--- a/drivers/net/wireless/xr829/umac/rc80211_minstrel.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/rc80211_minstrel.c	2022-08-27 01:22:42.950539847 +0300
@@ -0,0 +1,579 @@
+/*
+ * Copyright (C) 2008 Felix Fietkau <nbd@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Based on minstrel.c:
+ *   Copyright (C) 2005-2007 Derek Smithies <derek@indranet.co.nz>
+ *   Sponsored by Indranet Technologies Ltd
+ *
+ * Based on sample.c:
+ *   Copyright (c) 2005 John Bicket
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer,
+ *      without modification.
+ *   2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *      similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any
+ *      redistribution must be conditioned upon including a substantially
+ *      similar Disclaimer requirement for further binary redistribution.
+ *   3. Neither the names of the above-listed copyright holders nor the names
+ *      of any contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *   Alternatively, this software may be distributed under the terms of the
+ *   GNU General Public License ("GPL") version 2 as published by the Free
+ *   Software Foundation.
+ *
+ *   NO WARRANTY
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY
+ *   AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+ *   THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,
+ *   OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
+ *   IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ *   THE POSSIBILITY OF SUCH DAMAGES.
+ */
+#include <linux/netdevice.h>
+#include <linux/types.h>
+#include <linux/skbuff.h>
+#include <linux/debugfs.h>
+#include <linux/random.h>
+#include <linux/ieee80211.h>
+#include <linux/slab.h>
+#include <net/mac80211.h>
+#include "rate.h"
+#include "rc80211_minstrel.h"
+
+#define SAMPLE_COLUMNS	10
+#define SAMPLE_TBL(_mi, _idx, _col) \
+		_mi->sample_table[(_idx * SAMPLE_COLUMNS) + _col]
+
+/* convert mac80211 rate index to local array index */
+static inline int
+rix_to_ndx(struct minstrel_sta_info *mi, int rix)
+{
+	int i = rix;
+	for (i = rix; i >= 0; i--)
+		if (mi->r[i].rix == rix)
+			break;
+	return i;
+}
+
+static void
+minstrel_update_stats(struct minstrel_priv *mp, struct minstrel_sta_info *mi)
+{
+	u32 max_tp = 0, index_max_tp = 0, index_max_tp2 = 0;
+	u32 max_prob = 0, index_max_prob = 0;
+	u32 usecs;
+	u32 p;
+	int i;
+
+	mi->stats_update = jiffies;
+	for (i = 0; i < mi->n_rates; i++) {
+		struct minstrel_rate *mr = &mi->r[i];
+
+		usecs = mr->perfect_tx_time;
+		if (!usecs)
+			usecs = 1000000;
+
+		/* To avoid rounding issues, probabilities scale from 0 (0%)
+		 * to 18000 (100%) */
+		if (mr->attempts) {
+			p = (mr->success * 18000) / mr->attempts;
+			mr->succ_hist += mr->success;
+			mr->att_hist += mr->attempts;
+			mr->cur_prob = p;
+			p = ((p * (100 - mp->ewma_level)) + (mr->probability *
+				mp->ewma_level)) / 100;
+			mr->probability = p;
+			mr->cur_tp = p * (1000000 / usecs);
+		}
+
+		mr->last_success = mr->success;
+		mr->last_attempts = mr->attempts;
+		mr->success = 0;
+		mr->attempts = 0;
+
+		/* Sample less often below the 10% chance of success.
+		 * Sample less often above the 95% chance of success. */
+		if ((mr->probability > 17100) || (mr->probability < 1800)) {
+			mr->adjusted_retry_count = mr->retry_count >> 1;
+			if (mr->adjusted_retry_count > 2)
+				mr->adjusted_retry_count = 2;
+			mr->sample_limit = 4;
+		} else {
+			mr->sample_limit = -1;
+			mr->adjusted_retry_count = mr->retry_count;
+		}
+		if (!mr->adjusted_retry_count)
+			mr->adjusted_retry_count = 2;
+	}
+
+	for (i = 0; i < mi->n_rates; i++) {
+		struct minstrel_rate *mr = &mi->r[i];
+		if (max_tp < mr->cur_tp) {
+			index_max_tp = i;
+			max_tp = mr->cur_tp;
+		}
+		if (max_prob < mr->probability) {
+			index_max_prob = i;
+			max_prob = mr->probability;
+		}
+	}
+
+	max_tp = 0;
+	for (i = 0; i < mi->n_rates; i++) {
+		struct minstrel_rate *mr = &mi->r[i];
+
+		if (i == index_max_tp)
+			continue;
+
+		if (max_tp < mr->cur_tp) {
+			index_max_tp2 = i;
+			max_tp = mr->cur_tp;
+		}
+	}
+	mi->max_tp_rate = index_max_tp;
+	mi->max_tp_rate2 = index_max_tp2;
+	mi->max_prob_rate = index_max_prob;
+}
+
+static void
+minstrel_tx_status(void *priv, struct ieee80211_supported_band *sband,
+			struct ieee80211_sta *sta, void *priv_sta,
+			struct sk_buff *skb)
+{
+	struct minstrel_sta_info *mi = priv_sta;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	struct ieee80211_tx_rate *ar = info->status.rates;
+	int i, ndx;
+	int success;
+
+	success = !!(info->flags & IEEE80211_TX_STAT_ACK);
+
+	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {
+		if (ar[i].idx < 0)
+			break;
+
+		ndx = rix_to_ndx(mi, ar[i].idx);
+		if (ndx < 0)
+			continue;
+
+		mi->r[ndx].attempts += ar[i].count;
+
+		if ((i != IEEE80211_TX_MAX_RATES - 1) && (ar[i + 1].idx < 0))
+			mi->r[ndx].success += success;
+	}
+
+	if ((info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE) && (i >= 0))
+		mi->sample_count++;
+
+	if (mi->sample_deferred > 0)
+		mi->sample_deferred--;
+}
+
+
+static inline unsigned int
+minstrel_get_retry_count(struct minstrel_rate *mr,
+						struct ieee80211_tx_info *info)
+{
+	unsigned int retry = mr->adjusted_retry_count;
+
+	if (info->control.rates[0].flags & IEEE80211_TX_RC_USE_RTS_CTS)
+		retry = max(2U, min(mr->retry_count_rtscts, retry));
+	else if (info->control.rates[0].flags & IEEE80211_TX_RC_USE_CTS_PROTECT)
+		retry = max(2U, min(mr->retry_count_cts, retry));
+	return retry;
+}
+
+
+static int
+minstrel_get_next_sample(struct minstrel_sta_info *mi)
+{
+	unsigned int sample_ndx;
+	sample_ndx = SAMPLE_TBL(mi, mi->sample_idx, mi->sample_column);
+	mi->sample_idx++;
+	if ((int) mi->sample_idx > (mi->n_rates - 2)) {
+		mi->sample_idx = 0;
+		mi->sample_column++;
+		if (mi->sample_column >= SAMPLE_COLUMNS)
+			mi->sample_column = 0;
+	}
+	return sample_ndx;
+}
+
+static void
+minstrel_get_rate(void *priv, struct ieee80211_sta *sta,
+		  void *priv_sta, struct ieee80211_tx_rate_control *txrc)
+{
+	struct sk_buff *skb = txrc->skb;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	struct minstrel_sta_info *mi = priv_sta;
+	struct minstrel_priv *mp = priv;
+	struct ieee80211_tx_rate *ar = info->control.rates;
+	unsigned int ndx, sample_ndx = 0;
+	bool mrr;
+	bool sample_slower = false;
+	bool sample = false;
+	int i, delta;
+	int mrr_ndx[3];
+	int sample_rate;
+
+	if (xrmac_rate_control_send_low(sta, priv_sta, txrc))
+		return;
+
+	mrr = mp->has_mrr && !txrc->rts && !txrc->bss_conf->use_cts_prot;
+
+	if (time_after(jiffies, mi->stats_update + (mp->update_interval *
+			HZ) / 1000))
+		minstrel_update_stats(mp, mi);
+
+	ndx = mi->max_tp_rate;
+
+	if (mrr)
+		sample_rate = mp->lookaround_rate_mrr;
+	else
+		sample_rate = mp->lookaround_rate;
+
+	mi->packet_count++;
+	delta = (mi->packet_count * sample_rate / 100) -
+			(mi->sample_count + mi->sample_deferred / 2);
+
+	/* delta > 0: sampling required */
+	if ((delta > 0) && (mrr || !mi->prev_sample)) {
+		struct minstrel_rate *msr;
+		if (mi->packet_count >= 10000) {
+			mi->sample_deferred = 0;
+			mi->sample_count = 0;
+			mi->packet_count = 0;
+		} else if (delta > mi->n_rates * 2) {
+			/* With multi-rate retry, not every planned sample
+			 * attempt actually gets used, due to the way the retry
+			 * chain is set up - [max_tp, sample, prob, lowest] for
+			 * sample_rate < max_tp.
+			 *
+			 * If there's too much sampling backlog and the link
+			 * starts getting worse, minstrel would start bursting
+			 * out lots of sampling frames, which would result
+			 * in a large throughput loss. */
+			mi->sample_count += (delta - mi->n_rates * 2);
+		}
+
+		sample_ndx = minstrel_get_next_sample(mi);
+		msr = &mi->r[sample_ndx];
+		sample = true;
+		sample_slower = mrr && (msr->perfect_tx_time >
+			mi->r[ndx].perfect_tx_time);
+
+		if (!sample_slower) {
+			if (msr->sample_limit != 0) {
+				ndx = sample_ndx;
+				mi->sample_count++;
+				if (msr->sample_limit > 0)
+					msr->sample_limit--;
+			} else {
+				sample = false;
+			}
+		} else {
+			/* Only use IEEE80211_TX_CTL_RATE_CTRL_PROBE to mark
+			 * packets that have the sampling rate deferred to the
+			 * second MRR stage. Increase the sample counter only
+			 * if the deferred sample rate was actually used.
+			 * Use the sample_deferred counter to make sure that
+			 * the sampling is not done in large bursts */
+			info->flags |= IEEE80211_TX_CTL_RATE_CTRL_PROBE;
+			mi->sample_deferred++;
+		}
+	}
+	mi->prev_sample = sample;
+
+	/* If we're not using MRR and the sampling rate already
+	 * has a probability of >95%, we shouldn't be attempting
+	 * to use it, as this only wastes precious airtime */
+	if (!mrr && sample && (mi->r[ndx].probability > 17100))
+		ndx = mi->max_tp_rate;
+
+	ar[0].idx = mi->r[ndx].rix;
+	ar[0].count = minstrel_get_retry_count(&mi->r[ndx], info);
+
+	if (!mrr) {
+		if (!sample)
+			ar[0].count = mp->max_retry;
+		ar[1].idx = mi->lowest_rix;
+		ar[1].count = mp->max_retry;
+		return;
+	}
+
+	/* MRR setup */
+	if (sample) {
+		if (sample_slower)
+			mrr_ndx[0] = sample_ndx;
+		else
+			mrr_ndx[0] = mi->max_tp_rate;
+	} else {
+		mrr_ndx[0] = mi->max_tp_rate2;
+	}
+	mrr_ndx[1] = mi->max_prob_rate;
+	mrr_ndx[2] = 0;
+	for (i = 1; i < 4; i++) {
+		ar[i].idx = mi->r[mrr_ndx[i - 1]].rix;
+		ar[i].count = mi->r[mrr_ndx[i - 1]].adjusted_retry_count;
+	}
+}
+
+
+static void
+calc_rate_durations(enum nl80211_band band,
+		    struct minstrel_rate *d,
+		    struct ieee80211_rate *rate)
+{
+	int erp = !!(rate->flags & IEEE80211_RATE_ERP_G);
+
+	d->perfect_tx_time = mac80211_frame_duration(band, 1200,
+			rate->bitrate, erp, 1);
+	d->ack_time = mac80211_frame_duration(band, 10,
+			rate->bitrate, erp, 1);
+}
+
+static void
+init_sample_table(struct minstrel_sta_info *mi)
+{
+	unsigned int i, col, new_idx;
+	unsigned int n_srates = mi->n_rates - 1;
+	u8 rnd[8];
+
+	mi->sample_column = 0;
+	mi->sample_idx = 0;
+	memset(mi->sample_table, 0, SAMPLE_COLUMNS * mi->n_rates);
+
+	for (col = 0; col < SAMPLE_COLUMNS; col++) {
+		for (i = 0; i < n_srates; i++) {
+			get_random_bytes(rnd, sizeof(rnd));
+			new_idx = (i + rnd[i & 7]) % n_srates;
+
+			while (SAMPLE_TBL(mi, new_idx, col) != 0)
+				new_idx = (new_idx + 1) % n_srates;
+
+			/* Don't sample the slowest rate (i.e. slowest base
+			 * rate). We must presume that the slowest rate works
+			 * fine, or else other management frames will also be
+			 * failing and the link will break */
+			SAMPLE_TBL(mi, new_idx, col) = i + 1;
+		}
+	}
+}
+
+static void
+minstrel_rate_init(void *priv, struct ieee80211_supported_band *sband,
+				struct ieee80211_sta *sta, void *priv_sta)
+{
+	struct minstrel_sta_info *mi = priv_sta;
+	struct minstrel_priv *mp = priv;
+	struct ieee80211_rate *ctl_rate;
+	unsigned int i, n = 0;
+	unsigned int t_slot = 9; /* FIXME: get real slot time */
+
+	mi->lowest_rix = rate_lowest_index(sband, sta);
+	ctl_rate = &sband->bitrates[mi->lowest_rix];
+	mi->sp_ack_dur = mac80211_frame_duration(sband->band, 10,
+				ctl_rate->bitrate,
+				!!(ctl_rate->flags & IEEE80211_RATE_ERP_G), 1);
+
+	for (i = 0; i < sband->n_bitrates; i++) {
+		struct minstrel_rate *mr = &mi->r[n];
+		unsigned int tx_time = 0, tx_time_cts = 0, tx_time_rtscts = 0;
+		unsigned int tx_time_single;
+		unsigned int cw = mp->cw_min;
+
+		if (!rate_supported(sta, sband->band, i))
+			continue;
+		n++;
+		memset(mr, 0, sizeof(*mr));
+
+		mr->rix = i;
+		mr->bitrate = sband->bitrates[i].bitrate / 5;
+		calc_rate_durations(sband->band, mr, &sband->bitrates[i]);
+
+		/* calculate maximum number of retransmissions before
+		 * fallback (based on maximum segment size) */
+		mr->sample_limit = -1;
+		mr->retry_count = 1;
+		mr->retry_count_cts = 1;
+		mr->retry_count_rtscts = 1;
+		tx_time = mr->perfect_tx_time + mi->sp_ack_dur;
+		do {
+			/* add one retransmission */
+			tx_time_single = mr->ack_time + mr->perfect_tx_time;
+
+			/* contention window */
+			tx_time_single += (t_slot * cw) >> 1;
+			cw = min((cw << 1) | 1, mp->cw_max);
+
+			tx_time += tx_time_single;
+			tx_time_cts += tx_time_single + mi->sp_ack_dur;
+			tx_time_rtscts += tx_time_single + 2 * mi->sp_ack_dur;
+			if ((tx_time_cts < mp->segment_size) &&
+				(mr->retry_count_cts < mp->max_retry))
+				mr->retry_count_cts++;
+			if ((tx_time_rtscts < mp->segment_size) &&
+				(mr->retry_count_rtscts < mp->max_retry))
+				mr->retry_count_rtscts++;
+		} while ((tx_time < mp->segment_size) &&
+				(++mr->retry_count < mp->max_retry));
+		mr->adjusted_retry_count = mr->retry_count;
+	}
+
+	for (i = n; i < sband->n_bitrates; i++) {
+		struct minstrel_rate *mr = &mi->r[i];
+		mr->rix = -1;
+	}
+
+	mi->n_rates = n;
+	mi->stats_update = jiffies;
+
+	init_sample_table(mi);
+}
+
+static void *
+minstrel_alloc_sta(void *priv, struct ieee80211_sta *sta, gfp_t gfp)
+{
+	struct ieee80211_supported_band *sband;
+	struct minstrel_sta_info *mi;
+	struct minstrel_priv *mp = priv;
+	struct ieee80211_hw *hw = mp->hw;
+	int max_rates = 0;
+	int i;
+
+	mi = kzalloc(sizeof(struct minstrel_sta_info), gfp);
+	if (!mi)
+		return NULL;
+
+	for (i = 0; i < NUM_NL80211_BANDS; i++) {
+		sband = hw->wiphy->bands[i];
+		if (sband && sband->n_bitrates > max_rates)
+			max_rates = sband->n_bitrates;
+	}
+
+	mi->r = kzalloc(sizeof(struct minstrel_rate) * max_rates, gfp);
+	if (!mi->r)
+		goto error;
+
+	mi->sample_table = kmalloc(SAMPLE_COLUMNS * max_rates, gfp);
+	if (!mi->sample_table)
+		goto error1;
+
+	mi->stats_update = jiffies;
+	return mi;
+
+error1:
+	kfree(mi->r);
+error:
+	kfree(mi);
+	return NULL;
+}
+
+static void
+minstrel_free_sta(void *priv, struct ieee80211_sta *sta, void *priv_sta)
+{
+	struct minstrel_sta_info *mi = priv_sta;
+
+	kfree(mi->sample_table);
+	kfree(mi->r);
+	kfree(mi);
+}
+
+static void *
+minstrel_alloc(struct ieee80211_hw *hw, struct dentry *debugfsdir)
+{
+	struct minstrel_priv *mp;
+
+	mp = kzalloc(sizeof(struct minstrel_priv), GFP_ATOMIC);
+	if (!mp)
+		return NULL;
+
+	/* contention window settings
+	 * Just an approximation. Using the per-queue values would complicate
+	 * the calculations and is probably unnecessary */
+	mp->cw_min = 15;
+	mp->cw_max = 1023;
+
+	/* number of packets (in %) to use for sampling other rates
+	 * sample less often for non-mrr packets, because the overhead
+	 * is much higher than with mrr */
+	mp->lookaround_rate = 5;
+	mp->lookaround_rate_mrr = 10;
+
+	/* moving average weight for EWMA */
+	mp->ewma_level = 75;
+
+	/* maximum time that the hw is allowed to stay in one MRR segment */
+	mp->segment_size = 6000;
+
+	if (hw->max_rate_tries > 0)
+		mp->max_retry = hw->max_rate_tries;
+	else
+		/* safe default, does not necessarily have to match hw properties */
+		mp->max_retry = 7;
+
+	if (hw->max_rates >= 4)
+		mp->has_mrr = true;
+
+	mp->hw = hw;
+	mp->update_interval = 100;
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	mp->fixed_rate_idx = (u32) -1;
+	mp->dbg_fixed_rate = debugfs_create_u32("fixed_rate_idx",
+			S_IRUGO | S_IWUGO, debugfsdir, &mp->fixed_rate_idx);
+#endif
+
+	return mp;
+}
+
+static void
+minstrel_free(void *priv)
+{
+#ifdef CONFIG_XRMAC_DEBUGFS
+	debugfs_remove(((struct minstrel_priv *)priv)->dbg_fixed_rate);
+#endif
+	kfree(priv);
+}
+
+struct rate_control_ops xrmac_minstrel = {
+	.name = "minstrel",
+	.tx_status = minstrel_tx_status,
+	.get_rate = minstrel_get_rate,
+	.rate_init = minstrel_rate_init,
+	.alloc = minstrel_alloc,
+	.free = minstrel_free,
+	.alloc_sta = minstrel_alloc_sta,
+	.free_sta = minstrel_free_sta,
+#ifdef CONFIG_XRMAC_DEBUGFS
+	.add_sta_debugfs = xrmac_minstrel_add_sta_debugfs,
+	.remove_sta_debugfs = xrmac_minstrel_remove_sta_debugfs,
+#endif
+};
+
+int __init
+xrmac_rc80211_minstrel_init(void)
+{
+	return mac80211_rate_control_register(&xrmac_minstrel);
+}
+
+void
+xrmac_rc80211_minstrel_exit(void)
+{
+	mac80211_rate_control_unregister(&xrmac_minstrel);
+}
+
diff -Naurp a/drivers/net/wireless/xr829/umac/rc80211_minstrel.h b/drivers/net/wireless/xr829/umac/rc80211_minstrel.h
--- a/drivers/net/wireless/xr829/umac/rc80211_minstrel.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/rc80211_minstrel.h	2022-08-27 01:22:42.950539847 +0300
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2008 Felix Fietkau <nbd@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __RC_MINSTREL_H
+#define __RC_MINSTREL_H
+
+struct minstrel_rate {
+	int bitrate;
+	int rix;
+
+	unsigned int perfect_tx_time;
+	unsigned int ack_time;
+
+	int sample_limit;
+	unsigned int retry_count;
+	unsigned int retry_count_cts;
+	unsigned int retry_count_rtscts;
+	unsigned int adjusted_retry_count;
+
+	u32 success;
+	u32 attempts;
+	u32 last_attempts;
+	u32 last_success;
+
+	/* parts per thousand */
+	u32 cur_prob;
+	u32 probability;
+
+	/* per-rate throughput */
+	u32 cur_tp;
+
+	u64 succ_hist;
+	u64 att_hist;
+};
+
+struct minstrel_sta_info {
+	unsigned long stats_update;
+	unsigned int sp_ack_dur;
+	unsigned int rate_avg;
+
+	unsigned int lowest_rix;
+
+	unsigned int max_tp_rate;
+	unsigned int max_tp_rate2;
+	unsigned int max_prob_rate;
+	unsigned int packet_count;
+	unsigned int sample_count;
+	int sample_deferred;
+
+	unsigned int sample_idx;
+	unsigned int sample_column;
+
+	int n_rates;
+	struct minstrel_rate *r;
+	bool prev_sample;
+
+	/* sampling table */
+	u8 *sample_table;
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	struct dentry *dbg_stats;
+#endif
+};
+
+struct minstrel_priv {
+	struct ieee80211_hw *hw;
+	bool has_mrr;
+	unsigned int cw_min;
+	unsigned int cw_max;
+	unsigned int max_retry;
+	unsigned int ewma_level;
+	unsigned int segment_size;
+	unsigned int update_interval;
+	unsigned int lookaround_rate;
+	unsigned int lookaround_rate_mrr;
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	/*
+	 * enable fixed rate processing per RC
+	 *   - write static index to debugfs:ieee80211/phyX/rc/fixed_rate_idx
+	 *   - write -1 to enable RC processing again
+	 *   - setting will be applied on next update
+	 */
+	u32 fixed_rate_idx;
+	struct dentry *dbg_fixed_rate;
+#endif
+
+};
+
+struct minstrel_debugfs_info {
+	size_t len;
+	char buf[];
+};
+
+extern struct rate_control_ops xrmac_minstrel;
+void xrmac_minstrel_add_sta_debugfs(void *priv, void *priv_sta, struct dentry *dir);
+void xrmac_minstrel_remove_sta_debugfs(void *priv, void *priv_sta);
+
+/* debugfs */
+int xrmac_minstrel_stats_open(struct inode *inode, struct file *file);
+ssize_t xrmac_minstrel_stats_read(struct file *file, char __user *buf, size_t len, loff_t *ppos);
+int xrmac_minstrel_stats_release(struct inode *inode, struct file *file);
+
+#endif
diff -Naurp a/drivers/net/wireless/xr829/umac/rc80211_minstrel_debugfs.c b/drivers/net/wireless/xr829/umac/rc80211_minstrel_debugfs.c
--- a/drivers/net/wireless/xr829/umac/rc80211_minstrel_debugfs.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/rc80211_minstrel_debugfs.c	2022-08-27 01:22:42.950539847 +0300
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2008 Felix Fietkau <nbd@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Based on minstrel.c:
+ *   Copyright (C) 2005-2007 Derek Smithies <derek@indranet.co.nz>
+ *   Sponsored by Indranet Technologies Ltd
+ *
+ * Based on sample.c:
+ *   Copyright (c) 2005 John Bicket
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer,
+ *      without modification.
+ *   2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *      similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any
+ *      redistribution must be conditioned upon including a substantially
+ *      similar Disclaimer requirement for further binary redistribution.
+ *   3. Neither the names of the above-listed copyright holders nor the names
+ *      of any contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *   Alternatively, this software may be distributed under the terms of the
+ *   GNU General Public License ("GPL") version 2 as published by the Free
+ *   Software Foundation.
+ *
+ *   NO WARRANTY
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY
+ *   AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+ *   THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,
+ *   OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
+ *   IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ *   THE POSSIBILITY OF SUCH DAMAGES.
+ */
+#include <linux/netdevice.h>
+#include <linux/types.h>
+#include <linux/skbuff.h>
+#include <linux/debugfs.h>
+#include <linux/ieee80211.h>
+#include <linux/slab.h>
+#include <linux/export.h>
+#include <net/mac80211.h>
+#include "rc80211_minstrel.h"
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+
+int
+xrmac_minstrel_stats_open(struct inode *inode, struct file *file)
+{
+	struct minstrel_sta_info *mi = inode->i_private;
+	struct minstrel_debugfs_info *ms;
+	unsigned int i, tp, prob, eprob;
+	char *p;
+
+	ms = kmalloc(sizeof(*ms) + 4096, GFP_KERNEL);
+	if (!ms)
+		return -ENOMEM;
+
+	file->private_data = ms;
+	p = ms->buf;
+	p += sprintf(p, "rate     throughput  ewma prob   this prob  "
+			"this succ/attempt   success    attempts\n");
+	for (i = 0; i < mi->n_rates; i++) {
+		struct minstrel_rate *mr = &mi->r[i];
+
+		*(p++) = (i == mi->max_tp_rate) ? 'T' : ' ';
+		*(p++) = (i == mi->max_tp_rate2) ? 't' : ' ';
+		*(p++) = (i == mi->max_prob_rate) ? 'P' : ' ';
+		p += sprintf(p, "%3u%s", (unsigned int)mr->bitrate / 2,
+				(mr->bitrate & 1 ? ".5" : "  "));
+
+		tp = mr->cur_tp / ((18000 << 10) / 96);
+		prob = mr->cur_prob / 18;
+		eprob = mr->probability / 18;
+
+		p += sprintf(p, "  %6u.%1u   %6u.%1u   %6u.%1u        "
+				"%3u(%3u)   %8llu    %8llu\n",
+				tp / 10, tp % 10,
+				eprob / 10, eprob % 10,
+				prob / 10, prob % 10,
+				mr->last_success,
+				mr->last_attempts,
+				(unsigned long long)mr->succ_hist,
+				(unsigned long long)mr->att_hist);
+	}
+	p += sprintf(p, "\nTotal packet count::    ideal %d      "
+			"lookaround %d\n\n",
+			mi->packet_count - mi->sample_count,
+			mi->sample_count);
+	ms->len = p - ms->buf;
+
+	return 0;
+}
+
+ssize_t
+xrmac_minstrel_stats_read(struct file *file, char __user *buf, size_t len, loff_t *ppos)
+{
+	struct minstrel_debugfs_info *ms;
+
+	ms = file->private_data;
+	return simple_read_from_buffer(buf, len, ppos, ms->buf, ms->len);
+}
+
+int
+xrmac_minstrel_stats_release(struct inode *inode, struct file *file)
+{
+	kfree(file->private_data);
+	return 0;
+}
+
+static const struct file_operations minstrel_stat_fops = {
+	.owner = THIS_MODULE,
+	.open = xrmac_minstrel_stats_open,
+	.read = xrmac_minstrel_stats_read,
+	.release = xrmac_minstrel_stats_release,
+	.llseek = default_llseek,
+};
+
+void
+xrmac_minstrel_add_sta_debugfs(void *priv, void *priv_sta, struct dentry *dir)
+{
+	struct minstrel_sta_info *mi = priv_sta;
+
+	mi->dbg_stats = debugfs_create_file("rc_stats", S_IRUGO, dir, mi,
+			&minstrel_stat_fops);
+}
+
+void
+xrmac_minstrel_remove_sta_debugfs(void *priv, void *priv_sta)
+{
+	struct minstrel_sta_info *mi = priv_sta;
+
+	debugfs_remove(mi->dbg_stats);
+}
+#endif /* CONFIG_XRMAC_DEBUGFS */
diff -Naurp a/drivers/net/wireless/xr829/umac/rc80211_minstrel_ht.c b/drivers/net/wireless/xr829/umac/rc80211_minstrel_ht.c
--- a/drivers/net/wireless/xr829/umac/rc80211_minstrel_ht.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/rc80211_minstrel_ht.c	2022-08-27 01:22:42.950539847 +0300
@@ -0,0 +1,906 @@
+/*
+ * Copyright (C) 2010 Felix Fietkau <nbd@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/netdevice.h>
+#include <linux/types.h>
+#include <linux/skbuff.h>
+#include <linux/debugfs.h>
+#include <linux/random.h>
+#include <linux/ieee80211.h>
+#include <net/mac80211.h>
+#include "rate.h"
+#include "rc80211_minstrel.h"
+#include "rc80211_minstrel_ht.h"
+
+#define AVG_PKT_SIZE	1200
+#define SAMPLE_COLUMNS	10
+#define EWMA_LEVEL		75
+
+/* Number of bits for an average sized packet */
+#define MCS_NBITS (AVG_PKT_SIZE << 3)
+
+/* Number of symbols for a packet with (bps) bits per symbol */
+#define MCS_NSYMS(bps) ((MCS_NBITS + (bps) - 1) / (bps))
+
+/* Transmission time for a packet containing (syms) symbols */
+#define MCS_SYMBOL_TIME(sgi, syms)					\
+	(sgi ?								\
+	  ((syms) * 18 + 4) / 5 :	/* syms * 3.6 us */		\
+	  (syms) << 2			/* syms * 4 us */		\
+	)
+
+/* Transmit duration for the raw data part of an average sized packet */
+#define MCS_DURATION(streams, sgi, bps) MCS_SYMBOL_TIME(sgi, MCS_NSYMS((streams) * (bps)))
+
+/* MCS rate information for an MCS group */
+#define MCS_GROUP(_streams, _sgi, _ht40) {				\
+	.streams = _streams,						\
+	.flags =							\
+		(_sgi ? IEEE80211_TX_RC_SHORT_GI : 0) |			\
+		(_ht40 ? IEEE80211_TX_RC_40_MHZ_WIDTH : 0),		\
+	.duration = {							\
+		MCS_DURATION(_streams, _sgi, _ht40 ? 54 : 26),		\
+		MCS_DURATION(_streams, _sgi, _ht40 ? 108 : 52),		\
+		MCS_DURATION(_streams, _sgi, _ht40 ? 162 : 78),		\
+		MCS_DURATION(_streams, _sgi, _ht40 ? 216 : 104),	\
+		MCS_DURATION(_streams, _sgi, _ht40 ? 324 : 156),	\
+		MCS_DURATION(_streams, _sgi, _ht40 ? 432 : 208),	\
+		MCS_DURATION(_streams, _sgi, _ht40 ? 486 : 234),	\
+		MCS_DURATION(_streams, _sgi, _ht40 ? 540 : 260)		\
+	}								\
+}
+
+/*
+ * To enable sufficiently targeted rate sampling, MCS rates are divided into
+ * groups, based on the number of streams and flags (HT40, SGI) that they
+ * use.
+ */
+const struct mcs_group xrmac_minstrel_mcs_groups[] = {
+	MCS_GROUP(1, 0, 0),
+	MCS_GROUP(2, 0, 0),
+#if MINSTREL_MAX_STREAMS >= 3
+	MCS_GROUP(3, 0, 0),
+#endif
+
+	MCS_GROUP(1, 1, 0),
+	MCS_GROUP(2, 1, 0),
+#if MINSTREL_MAX_STREAMS >= 3
+	MCS_GROUP(3, 1, 0),
+#endif
+
+	MCS_GROUP(1, 0, 1),
+	MCS_GROUP(2, 0, 1),
+#if MINSTREL_MAX_STREAMS >= 3
+	MCS_GROUP(3, 0, 1),
+#endif
+
+	MCS_GROUP(1, 1, 1),
+	MCS_GROUP(2, 1, 1),
+#if MINSTREL_MAX_STREAMS >= 3
+	MCS_GROUP(3, 1, 1),
+#endif
+};
+
+static u8 sample_table[SAMPLE_COLUMNS][MCS_GROUP_RATES];
+
+/*
+ * Perform EWMA (Exponentially Weighted Moving Average) calculation
+ */
+static int
+minstrel_ewma(int old, int new, int weight)
+{
+	return (new * (100 - weight) + old * weight) / 100;
+}
+
+/*
+ * Look up an MCS group index based on mac80211 rate information
+ */
+static int
+minstrel_ht_get_group_idx(struct ieee80211_tx_rate *rate)
+{
+	int streams = (rate->idx / MCS_GROUP_RATES) + 1;
+	u32 flags = IEEE80211_TX_RC_SHORT_GI | IEEE80211_TX_RC_40_MHZ_WIDTH;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(xrmac_minstrel_mcs_groups); i++) {
+		if (xrmac_minstrel_mcs_groups[i].streams != streams)
+			continue;
+		if (xrmac_minstrel_mcs_groups[i].flags != (rate->flags & flags))
+			continue;
+
+		return i;
+	}
+
+	WARN_ON(1);
+	return 0;
+}
+
+static inline struct minstrel_rate_stats *
+minstrel_get_ratestats(struct minstrel_ht_sta *mi, int index)
+{
+	return &mi->groups[index / MCS_GROUP_RATES].rates[index % MCS_GROUP_RATES];
+}
+
+
+/*
+ * Recalculate success probabilities and counters for a rate using EWMA
+ */
+static void
+minstrel_calc_rate_ewma(struct minstrel_priv *mp, struct minstrel_rate_stats *mr)
+{
+	if (unlikely(mr->attempts > 0)) {
+		mr->sample_skipped = 0;
+		mr->cur_prob = MINSTREL_FRAC(mr->success, mr->attempts);
+		if (!mr->att_hist)
+			mr->probability = mr->cur_prob;
+		else
+			mr->probability = minstrel_ewma(mr->probability,
+				mr->cur_prob, EWMA_LEVEL);
+		mr->att_hist += mr->attempts;
+		mr->succ_hist += mr->success;
+	} else {
+		mr->sample_skipped++;
+	}
+	mr->last_success = mr->success;
+	mr->last_attempts = mr->attempts;
+	mr->success = 0;
+	mr->attempts = 0;
+}
+
+/*
+ * Calculate throughput based on the average A-MPDU length, taking into account
+ * the expected number of retransmissions and their expected length
+ */
+static void
+minstrel_ht_calc_tp(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+					int group, int rate)
+{
+	struct minstrel_rate_stats *mr;
+	unsigned int usecs;
+
+	mr = &mi->groups[group].rates[rate];
+
+	if (mr->probability < MINSTREL_FRAC(1, 10)) {
+		mr->cur_tp = 0;
+		return;
+	}
+
+	usecs = mi->overhead / MINSTREL_TRUNC(mi->avg_ampdu_len);
+	usecs += xrmac_minstrel_mcs_groups[group].duration[rate];
+	mr->cur_tp = MINSTREL_TRUNC((1000000 / usecs) * mr->probability);
+}
+
+/*
+ * Update rate statistics and select new primary rates
+ *
+ * Rules for rate selection:
+ *  - max_prob_rate must use only one stream, as a tradeoff between delivery
+ *    probability and throughput during strong fluctuations
+ *  - as long as the max prob rate has a probability of more than 3/4, pick
+ *    higher throughput rates, even if the probablity is a bit lower
+ */
+static void
+minstrel_ht_update_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+	struct minstrel_mcs_group_data *mg;
+	struct minstrel_rate_stats *mr;
+	int cur_prob, cur_prob_tp, cur_tp, cur_tp2;
+	int group, i, index;
+
+	if (mi->ampdu_packets > 0) {
+		mi->avg_ampdu_len = minstrel_ewma(mi->avg_ampdu_len,
+			MINSTREL_FRAC(mi->ampdu_len, mi->ampdu_packets), EWMA_LEVEL);
+		mi->ampdu_len = 0;
+		mi->ampdu_packets = 0;
+	}
+
+	mi->sample_slow = 0;
+	mi->sample_count = 0;
+	mi->max_tp_rate = 0;
+	mi->max_tp_rate2 = 0;
+	mi->max_prob_rate = 0;
+
+	for (group = 0; group < ARRAY_SIZE(xrmac_minstrel_mcs_groups); group++) {
+		cur_prob = 0;
+		cur_prob_tp = 0;
+		cur_tp = 0;
+		cur_tp2 = 0;
+
+		mg = &mi->groups[group];
+		if (!mg->supported)
+			continue;
+
+		mg->max_tp_rate = 0;
+		mg->max_tp_rate2 = 0;
+		mg->max_prob_rate = 0;
+		mi->sample_count++;
+
+		for (i = 0; i < MCS_GROUP_RATES; i++) {
+			if (!(mg->supported & BIT(i)))
+				continue;
+
+			mr = &mg->rates[i];
+			mr->retry_updated = false;
+			index = MCS_GROUP_RATES * group + i;
+			minstrel_calc_rate_ewma(mp, mr);
+			minstrel_ht_calc_tp(mp, mi, group, i);
+
+			if (!mr->cur_tp)
+				continue;
+
+			/* ignore the lowest rate of each single-stream group */
+			if (!i && xrmac_minstrel_mcs_groups[group].streams == 1)
+				continue;
+
+			if ((mr->cur_tp > cur_prob_tp && mr->probability >
+			     MINSTREL_FRAC(3, 4)) || mr->probability > cur_prob) {
+				mg->max_prob_rate = index;
+				cur_prob = mr->probability;
+				cur_prob_tp = mr->cur_tp;
+			}
+
+			if (mr->cur_tp > cur_tp) {
+				swap(index, mg->max_tp_rate);
+				cur_tp = mr->cur_tp;
+				mr = minstrel_get_ratestats(mi, index);
+			}
+
+			if (index >= mg->max_tp_rate)
+				continue;
+
+			if (mr->cur_tp > cur_tp2) {
+				mg->max_tp_rate2 = index;
+				cur_tp2 = mr->cur_tp;
+			}
+		}
+	}
+
+	/* try to sample up to half of the available rates during each interval */
+	mi->sample_count *= 4;
+
+	cur_prob = 0;
+	cur_prob_tp = 0;
+	cur_tp = 0;
+	cur_tp2 = 0;
+	for (group = 0; group < ARRAY_SIZE(xrmac_minstrel_mcs_groups); group++) {
+		mg = &mi->groups[group];
+		if (!mg->supported)
+			continue;
+
+		mr = minstrel_get_ratestats(mi, mg->max_prob_rate);
+		if (cur_prob_tp < mr->cur_tp &&
+		    xrmac_minstrel_mcs_groups[group].streams == 1) {
+			mi->max_prob_rate = mg->max_prob_rate;
+			cur_prob = mr->cur_prob;
+			cur_prob_tp = mr->cur_tp;
+		}
+
+		mr = minstrel_get_ratestats(mi, mg->max_tp_rate);
+		if (cur_tp < mr->cur_tp) {
+			mi->max_tp_rate2 = mi->max_tp_rate;
+			cur_tp2 = cur_tp;
+			mi->max_tp_rate = mg->max_tp_rate;
+			cur_tp = mr->cur_tp;
+		}
+
+		mr = minstrel_get_ratestats(mi, mg->max_tp_rate2);
+		if (cur_tp2 < mr->cur_tp) {
+			mi->max_tp_rate2 = mg->max_tp_rate2;
+			cur_tp2 = mr->cur_tp;
+		}
+	}
+
+	mi->stats_update = jiffies;
+}
+
+static bool
+minstrel_ht_txstat_valid(struct ieee80211_tx_rate *rate)
+{
+	if (!rate->count)
+		return false;
+
+	if (rate->idx < 0)
+		return false;
+
+	return !!(rate->flags & IEEE80211_TX_RC_MCS);
+}
+
+static void
+minstrel_next_sample_idx(struct minstrel_ht_sta *mi)
+{
+	struct minstrel_mcs_group_data *mg;
+
+	for (;;) {
+		mi->sample_group++;
+		mi->sample_group %= ARRAY_SIZE(xrmac_minstrel_mcs_groups);
+		mg = &mi->groups[mi->sample_group];
+
+		if (!mg->supported)
+			continue;
+
+		if (++mg->index >= MCS_GROUP_RATES) {
+			mg->index = 0;
+			if (++mg->column >= ARRAY_SIZE(sample_table))
+				mg->column = 0;
+		}
+		break;
+	}
+}
+
+static void
+minstrel_downgrade_rate(struct minstrel_ht_sta *mi, unsigned int *idx,
+			bool primary)
+{
+	int group, orig_group;
+
+	orig_group = group = *idx / MCS_GROUP_RATES;
+	while (group > 0) {
+		group--;
+
+		if (!mi->groups[group].supported)
+			continue;
+
+		if (xrmac_minstrel_mcs_groups[group].streams >
+		    xrmac_minstrel_mcs_groups[orig_group].streams)
+			continue;
+
+		if (primary)
+			*idx = mi->groups[group].max_tp_rate;
+		else
+			*idx = mi->groups[group].max_tp_rate2;
+		break;
+	}
+}
+
+static void
+minstrel_aggr_check(struct minstrel_priv *mp, struct ieee80211_sta *pubsta, struct sk_buff *skb)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
+	u16 tid;
+
+	if (unlikely(!ieee80211_is_data_qos(hdr->frame_control)))
+		return;
+
+	if (unlikely(skb->protocol == cpu_to_be16(ETH_P_PAE)))
+		return;
+
+	tid = *ieee80211_get_qos_ctl(hdr) & IEEE80211_QOS_CTL_TID_MASK;
+	if (likely(sta->ampdu_mlme.tid_tx[tid]))
+		return;
+
+	if (skb_get_queue_mapping(skb) == IEEE80211_AC_VO)
+		return;
+
+	mac80211_start_tx_ba_session(pubsta, tid, 5000);
+}
+
+static void
+minstrel_ht_tx_status(void *priv, struct ieee80211_supported_band *sband,
+					struct ieee80211_sta *sta, void *priv_sta,
+					struct sk_buff *skb)
+{
+	struct minstrel_ht_sta_priv *msp = priv_sta;
+	struct minstrel_ht_sta *mi = &msp->ht;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	struct ieee80211_tx_rate *ar = info->status.rates;
+	struct minstrel_rate_stats *rate, *rate2;
+	struct minstrel_priv *mp = priv;
+	bool last = false;
+	int group;
+	int i = 0;
+
+	if (!msp->is_ht)
+		return xrmac_minstrel.tx_status(priv, sband, sta, &msp->legacy, skb);
+
+	/* This packet was aggregated but doesn't carry status info */
+	if ((info->flags & IEEE80211_TX_CTL_AMPDU) &&
+	    !(info->flags & IEEE80211_TX_STAT_AMPDU))
+		return;
+
+	if (!(info->flags & IEEE80211_TX_STAT_AMPDU)) {
+		info->status.ampdu_ack_len =
+			(info->flags & IEEE80211_TX_STAT_ACK ? 1 : 0);
+		info->status.ampdu_len = 1;
+	}
+
+	mi->ampdu_packets++;
+	mi->ampdu_len += info->status.ampdu_len;
+
+	if (!mi->sample_wait && !mi->sample_tries && mi->sample_count > 0) {
+		mi->sample_wait = 16 + 2 * MINSTREL_TRUNC(mi->avg_ampdu_len);
+		mi->sample_tries = 2;
+		mi->sample_count--;
+	}
+
+	if (info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE)
+		mi->sample_packets += info->status.ampdu_len;
+
+	for (i = 0; !last; i++) {
+		last = (i == IEEE80211_TX_MAX_RATES - 1) ||
+		       !minstrel_ht_txstat_valid(&ar[i + 1]);
+
+		if (!minstrel_ht_txstat_valid(&ar[i]))
+			break;
+
+		group = minstrel_ht_get_group_idx(&ar[i]);
+		rate = &mi->groups[group].rates[ar[i].idx % 8];
+
+		if (last)
+			rate->success += info->status.ampdu_ack_len;
+
+		rate->attempts += ar[i].count * info->status.ampdu_len;
+	}
+
+	/*
+	 * check for sudden death of spatial multiplexing,
+	 * downgrade to a lower number of streams if necessary.
+	 */
+	rate = minstrel_get_ratestats(mi, mi->max_tp_rate);
+	if (rate->attempts > 30 &&
+	    MINSTREL_FRAC(rate->success, rate->attempts) <
+	    MINSTREL_FRAC(20, 100))
+		minstrel_downgrade_rate(mi, &mi->max_tp_rate, true);
+
+	rate2 = minstrel_get_ratestats(mi, mi->max_tp_rate2);
+	if (rate2->attempts > 30 &&
+	    MINSTREL_FRAC(rate2->success, rate2->attempts) <
+	    MINSTREL_FRAC(20, 100))
+		minstrel_downgrade_rate(mi, &mi->max_tp_rate2, false);
+
+	if (time_after(jiffies, mi->stats_update + (mp->update_interval / 2 * HZ) / 1000)) {
+		minstrel_ht_update_stats(mp, mi);
+		if (!(info->flags & IEEE80211_TX_CTL_AMPDU))
+			minstrel_aggr_check(mp, sta, skb);
+	}
+}
+
+static void
+minstrel_calc_retransmit(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+						int index)
+{
+	struct minstrel_rate_stats *mr;
+	const struct mcs_group *group;
+	unsigned int tx_time, tx_time_rtscts, tx_time_data;
+	unsigned int cw = mp->cw_min;
+	unsigned int ctime = 0;
+	unsigned int t_slot = 9; /* FIXME */
+	unsigned int ampdu_len = MINSTREL_TRUNC(mi->avg_ampdu_len);
+
+	mr = minstrel_get_ratestats(mi, index);
+	if (mr->probability < MINSTREL_FRAC(1, 10)) {
+		mr->retry_count = 1;
+		mr->retry_count_rtscts = 1;
+		return;
+	}
+
+	mr->retry_count = 2;
+	mr->retry_count_rtscts = 2;
+	mr->retry_updated = true;
+
+	group = &xrmac_minstrel_mcs_groups[index / MCS_GROUP_RATES];
+	tx_time_data = group->duration[index % MCS_GROUP_RATES] * ampdu_len;
+
+	/* Contention time for first 2 tries */
+	ctime = (t_slot * cw) >> 1;
+	cw = min((cw << 1) | 1, mp->cw_max);
+	ctime += (t_slot * cw) >> 1;
+	cw = min((cw << 1) | 1, mp->cw_max);
+
+	/* Total TX time for data and Contention after first 2 tries */
+	tx_time = ctime + 2 * (mi->overhead + tx_time_data);
+	tx_time_rtscts = ctime + 2 * (mi->overhead_rtscts + tx_time_data);
+
+	/* See how many more tries we can fit inside segment size */
+	do {
+		/* Contention time for this try */
+		ctime = (t_slot * cw) >> 1;
+		cw = min((cw << 1) | 1, mp->cw_max);
+
+		/* Total TX time after this try */
+		tx_time += ctime + mi->overhead + tx_time_data;
+		tx_time_rtscts += ctime + mi->overhead_rtscts + tx_time_data;
+
+		if (tx_time_rtscts < mp->segment_size)
+			mr->retry_count_rtscts++;
+	} while ((tx_time < mp->segment_size) &&
+			(++mr->retry_count < mp->max_retry));
+}
+
+
+static void
+minstrel_ht_set_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+					struct ieee80211_tx_rate *rate, int index,
+					struct ieee80211_tx_rate_control *txrc,
+					bool sample, bool rtscts)
+{
+	const struct mcs_group *group = &xrmac_minstrel_mcs_groups[index / MCS_GROUP_RATES];
+	struct minstrel_rate_stats *mr;
+
+	mr = minstrel_get_ratestats(mi, index);
+	if (!mr->retry_updated)
+		minstrel_calc_retransmit(mp, mi, index);
+
+	if (sample)
+		rate->count = 1;
+	else if (mr->probability < MINSTREL_FRAC(20, 100))
+		rate->count = 2;
+	else if (rtscts)
+		rate->count = mr->retry_count_rtscts;
+	else
+		rate->count = mr->retry_count;
+
+	rate->flags = IEEE80211_TX_RC_MCS | group->flags;
+	if (rtscts)
+		rate->flags |= IEEE80211_TX_RC_USE_RTS_CTS;
+	rate->idx = index % MCS_GROUP_RATES + (group->streams - 1) * MCS_GROUP_RATES;
+}
+
+static inline int
+minstrel_get_duration(int index)
+{
+	const struct mcs_group *group = &xrmac_minstrel_mcs_groups[index / MCS_GROUP_RATES];
+	return group->duration[index % MCS_GROUP_RATES];
+}
+
+static int
+minstrel_get_sample_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+	struct minstrel_rate_stats *mr;
+	struct minstrel_mcs_group_data *mg;
+	struct minstrel_rate_stats *max_tp2_mr;
+	int sample_idx = 0;
+
+	if (mi->sample_wait > 0) {
+		mi->sample_wait--;
+		return -1;
+	}
+
+	if (!mi->sample_tries)
+		return -1;
+
+	mi->sample_tries--;
+	mg = &mi->groups[mi->sample_group];
+	sample_idx = sample_table[mg->column][mg->index];
+	mr = &mg->rates[sample_idx];
+	sample_idx += mi->sample_group * MCS_GROUP_RATES;
+	minstrel_next_sample_idx(mi);
+
+	/*
+	 * When not using MRR, do not sample if the probability is already
+	 * higher than 95% to avoid wasting airtime
+	 */
+	if (!mp->has_mrr && (mr->probability > MINSTREL_FRAC(95, 100)))
+		return -1;
+
+	/*
+	 * Make sure that lower rates get sampled only occasionally,
+	 * if the link is working perfectly.
+	 */
+	if (minstrel_get_duration(sample_idx) >
+	    minstrel_get_duration(mi->max_tp_rate)) {
+		if (mr->sample_skipped < 20)
+			return -1;
+
+		if (mi->sample_slow++ > 2)
+			return -1;
+	}
+
+	max_tp2_mr = minstrel_get_ratestats(mi, mi->max_tp_rate2);
+
+	if (((max_tp2_mr->probability) * minstrel_get_duration(sample_idx)) >
+		(MINSTREL_FRAC(100, 100) * minstrel_get_duration(mi->max_tp_rate2))) {
+			return -1;
+	}
+
+	return sample_idx;
+}
+
+static void
+minstrel_ht_get_rate(void *priv, struct ieee80211_sta *sta, void *priv_sta,
+					struct ieee80211_tx_rate_control *txrc)
+{
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(txrc->skb);
+	struct ieee80211_tx_rate *ar = info->status.rates;
+	struct minstrel_ht_sta_priv *msp = priv_sta;
+	struct minstrel_ht_sta *mi = &msp->ht;
+	struct minstrel_priv *mp = priv;
+	int sample_idx;
+	bool sample = false;
+
+	if (xrmac_rate_control_send_low(sta, priv_sta, txrc))
+		return;
+
+	if (!msp->is_ht)
+		return xrmac_minstrel.get_rate(priv, sta, &msp->legacy, txrc);
+
+	info->flags |= mi->tx_flags;
+
+	/* Don't use EAPOL frames for sampling on non-mrr hw */
+	if (mp->hw->max_rates == 1 &&
+	    txrc->skb->protocol == cpu_to_be16(ETH_P_PAE))
+		sample_idx = -1;
+	else
+		sample_idx = minstrel_get_sample_rate(mp, mi);
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	/* use fixed index if set */
+	if (mp->fixed_rate_idx != -1)
+		sample_idx = mp->fixed_rate_idx;
+#endif
+
+	if (sample_idx >= 0) {
+		sample = true;
+		minstrel_ht_set_rate(mp, mi, &ar[0], sample_idx,
+			txrc, true, false);
+		info->flags |= IEEE80211_TX_CTL_RATE_CTRL_PROBE;
+	} else {
+		minstrel_ht_set_rate(mp, mi, &ar[0], mi->max_tp_rate,
+			txrc, false, false);
+	}
+
+	if (mp->hw->max_rates >= 3) {
+		/*
+		 * At least 3 tx rates supported, use
+		 * sample_rate -> max_tp_rate -> max_prob_rate for sampling and
+		 * max_tp_rate -> max_tp_rate2 -> max_prob_rate by default.
+		 */
+		if (sample_idx >= 0)
+			minstrel_ht_set_rate(mp, mi, &ar[1], mi->max_tp_rate,
+				txrc, false, false);
+		else
+			minstrel_ht_set_rate(mp, mi, &ar[1], mi->max_tp_rate2,
+				txrc, false, true);
+
+		minstrel_ht_set_rate(mp, mi, &ar[2], mi->max_prob_rate,
+				     txrc, false, !sample);
+
+		ar[3].count = 0;
+		ar[3].idx = -1;
+	} else if (mp->hw->max_rates == 2) {
+		/*
+		 * Only 2 tx rates supported, use
+		 * sample_rate -> max_prob_rate for sampling and
+		 * max_tp_rate -> max_prob_rate by default.
+		 */
+		minstrel_ht_set_rate(mp, mi, &ar[1], mi->max_prob_rate,
+				     txrc, false, !sample);
+
+		ar[2].count = 0;
+		ar[2].idx = -1;
+	} else {
+		/* Not using MRR, only use the first rate */
+		ar[1].count = 0;
+		ar[1].idx = -1;
+	}
+
+	mi->total_packets++;
+
+	/* wraparound */
+	if (mi->total_packets == ~0) {
+		mi->total_packets = 0;
+		mi->sample_packets = 0;
+	}
+}
+
+static void
+minstrel_ht_update_caps(void *priv, struct ieee80211_supported_band *sband,
+			struct ieee80211_sta *sta, void *priv_sta,
+			enum nl80211_channel_type oper_chan_type)
+{
+	struct minstrel_priv *mp = priv;
+	struct minstrel_ht_sta_priv *msp = priv_sta;
+	struct minstrel_ht_sta *mi = &msp->ht;
+	struct ieee80211_mcs_info *mcs = &sta->ht_cap.mcs;
+	u16 sta_cap = sta->ht_cap.cap;
+	int n_supported = 0;
+	int ack_dur;
+	int stbc;
+	int i;
+
+	/* fall back to the old minstrel for legacy stations */
+	if (!sta->ht_cap.ht_supported)
+		goto use_legacy;
+
+	BUILD_BUG_ON(ARRAY_SIZE(xrmac_minstrel_mcs_groups) !=
+		MINSTREL_MAX_STREAMS * MINSTREL_STREAM_GROUPS);
+
+	msp->is_ht = true;
+	memset(mi, 0, sizeof(*mi));
+	mi->stats_update = jiffies;
+
+	ack_dur = mac80211_frame_duration(sband->band, 10, 60, 1, 1);
+	mi->overhead = mac80211_frame_duration(sband->band, 0, 60, 1, 1) + ack_dur;
+	mi->overhead_rtscts = mi->overhead + 2 * ack_dur;
+
+	mi->avg_ampdu_len = MINSTREL_FRAC(1, 1);
+
+	/* When using MRR, sample more on the first attempt, without delay */
+	if (mp->has_mrr) {
+		mi->sample_count = 16;
+		mi->sample_wait = 0;
+	} else {
+		mi->sample_count = 8;
+		mi->sample_wait = 8;
+	}
+	mi->sample_tries = 4;
+
+	stbc = (sta_cap & IEEE80211_HT_CAP_RX_STBC) >>
+		IEEE80211_HT_CAP_RX_STBC_SHIFT;
+	mi->tx_flags |= stbc << IEEE80211_TX_CTL_STBC_SHIFT;
+
+	if (sta_cap & IEEE80211_HT_CAP_LDPC_CODING)
+		mi->tx_flags |= IEEE80211_TX_CTL_LDPC;
+
+	if (oper_chan_type != NL80211_CHAN_HT40MINUS &&
+	    oper_chan_type != NL80211_CHAN_HT40PLUS)
+		sta_cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;
+
+	for (i = 0; i < ARRAY_SIZE(mi->groups); i++) {
+		u16 req = 0;
+
+		mi->groups[i].supported = 0;
+		if (xrmac_minstrel_mcs_groups[i].flags & IEEE80211_TX_RC_SHORT_GI) {
+			if (xrmac_minstrel_mcs_groups[i].flags & IEEE80211_TX_RC_40_MHZ_WIDTH)
+				req |= IEEE80211_HT_CAP_SGI_40;
+			else
+				req |= IEEE80211_HT_CAP_SGI_20;
+		}
+
+		if (xrmac_minstrel_mcs_groups[i].flags & IEEE80211_TX_RC_40_MHZ_WIDTH)
+			req |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;
+
+		if ((sta_cap & req) != req)
+			continue;
+
+		mi->groups[i].supported =
+			mcs->rx_mask[xrmac_minstrel_mcs_groups[i].streams - 1];
+
+		if (mi->groups[i].supported)
+			n_supported++;
+	}
+
+	if (!n_supported)
+		goto use_legacy;
+
+	return;
+
+use_legacy:
+	msp->is_ht = false;
+	memset(&msp->legacy, 0, sizeof(msp->legacy));
+	msp->legacy.r = msp->ratelist;
+	msp->legacy.sample_table = msp->sample_table;
+	return xrmac_minstrel.rate_init(priv, sband, sta, &msp->legacy);
+}
+
+static void
+minstrel_ht_rate_init(void *priv, struct ieee80211_supported_band *sband,
+					struct ieee80211_sta *sta, void *priv_sta)
+{
+	struct sta_info *stai = container_of(sta, struct sta_info, sta);
+	struct ieee80211_local *local = stai->local;
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, stai->sdata);
+
+	minstrel_ht_update_caps(priv, sband, sta, priv_sta, chan_state->conf.channel_type);
+}
+
+static void
+minstrel_ht_rate_update(void *priv, struct ieee80211_supported_band *sband,
+						struct ieee80211_sta *sta, void *priv_sta,
+						u32 changed, enum nl80211_channel_type oper_chan_type)
+{
+	minstrel_ht_update_caps(priv, sband, sta, priv_sta, oper_chan_type);
+}
+
+static void *
+minstrel_ht_alloc_sta(void *priv, struct ieee80211_sta *sta, gfp_t gfp)
+{
+	struct ieee80211_supported_band *sband;
+	struct minstrel_ht_sta_priv *msp;
+	struct minstrel_priv *mp = priv;
+	struct ieee80211_hw *hw = mp->hw;
+	int max_rates = 0;
+	int i;
+
+	for (i = 0; i < NUM_NL80211_BANDS; i++) {
+		sband = hw->wiphy->bands[i];
+		if (sband && sband->n_bitrates > max_rates)
+			max_rates = sband->n_bitrates;
+	}
+
+	msp = kzalloc(sizeof(struct minstrel_ht_sta), gfp);
+	if (!msp)
+		return NULL;
+
+	msp->ratelist = kzalloc(sizeof(struct minstrel_rate) * max_rates, gfp);
+	if (!msp->ratelist)
+		goto error;
+
+	msp->sample_table = kmalloc(SAMPLE_COLUMNS * max_rates, gfp);
+	if (!msp->sample_table)
+		goto error1;
+
+	return msp;
+
+error1:
+	kfree(msp->ratelist);
+error:
+	kfree(msp);
+	return NULL;
+}
+
+static void
+minstrel_ht_free_sta(void *priv, struct ieee80211_sta *sta, void *priv_sta)
+{
+	struct minstrel_ht_sta_priv *msp = priv_sta;
+
+	kfree(msp->sample_table);
+	kfree(msp->ratelist);
+	kfree(msp);
+}
+
+static void *
+minstrel_ht_alloc(struct ieee80211_hw *hw, struct dentry *debugfsdir)
+{
+	return xrmac_minstrel.alloc(hw, debugfsdir);
+}
+
+static void
+minstrel_ht_free(void *priv)
+{
+	xrmac_minstrel.free(priv);
+}
+
+static struct rate_control_ops xrmac_minstrel_ht = {
+	.name = "minstrel_ht",
+	.tx_status = minstrel_ht_tx_status,
+	.get_rate = minstrel_ht_get_rate,
+	.rate_init = minstrel_ht_rate_init,
+	.rate_update = minstrel_ht_rate_update,
+	.alloc_sta = minstrel_ht_alloc_sta,
+	.free_sta = minstrel_ht_free_sta,
+	.alloc = minstrel_ht_alloc,
+	.free = minstrel_ht_free,
+#ifdef CONFIG_XRMAC_DEBUGFS
+	.add_sta_debugfs = xrmac_minstrel_ht_add_sta_debugfs,
+	.remove_sta_debugfs = xrmac_minstrel_ht_remove_sta_debugfs,
+#endif
+};
+
+
+static void
+init_sample_table(void)
+{
+	int col, i, new_idx;
+	u8 rnd[MCS_GROUP_RATES];
+
+	memset(sample_table, 0xff, sizeof(sample_table));
+	for (col = 0; col < SAMPLE_COLUMNS; col++) {
+		for (i = 0; i < MCS_GROUP_RATES; i++) {
+			get_random_bytes(rnd, sizeof(rnd));
+			new_idx = (i + rnd[i]) % MCS_GROUP_RATES;
+
+			while (sample_table[col][new_idx] != 0xff)
+				new_idx = (new_idx + 1) % MCS_GROUP_RATES;
+
+			sample_table[col][new_idx] = i;
+		}
+	}
+}
+
+int __init
+xrmac_rc80211_minstrel_ht_init(void)
+{
+	init_sample_table();
+	return mac80211_rate_control_register(&xrmac_minstrel_ht);
+}
+
+void
+xrmac_rc80211_minstrel_ht_exit(void)
+{
+	mac80211_rate_control_unregister(&xrmac_minstrel_ht);
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/rc80211_minstrel_ht.h b/drivers/net/wireless/xr829/umac/rc80211_minstrel_ht.h
--- a/drivers/net/wireless/xr829/umac/rc80211_minstrel_ht.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/rc80211_minstrel_ht.h	2022-08-27 01:22:42.954539862 +0300
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2010 Felix Fietkau <nbd@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __RC_MINSTREL_HT_H
+#define __RC_MINSTREL_HT_H
+
+/*
+ * The number of streams can be changed to 2 to reduce code
+ * size and memory footprint.
+ */
+#define MINSTREL_MAX_STREAMS	3
+#define MINSTREL_STREAM_GROUPS	4
+
+/* scaled fraction values */
+#define MINSTREL_SCALE	16
+#define MINSTREL_FRAC(val, div) (((val) << MINSTREL_SCALE) / div)
+#define MINSTREL_TRUNC(val) ((val) >> MINSTREL_SCALE)
+
+#define MCS_GROUP_RATES	8
+
+struct mcs_group {
+	u32 flags;
+	unsigned int streams;
+	unsigned int duration[MCS_GROUP_RATES];
+};
+
+extern const struct mcs_group xrmac_minstrel_mcs_groups[];
+
+struct minstrel_rate_stats {
+	/* current / last sampling period attempts/success counters */
+	unsigned int attempts, last_attempts;
+	unsigned int success, last_success;
+
+	/* total attempts/success counters */
+	u64 att_hist, succ_hist;
+
+	/* current throughput */
+	unsigned int cur_tp;
+
+	/* packet delivery probabilities */
+	unsigned int cur_prob, probability;
+
+	/* maximum retry counts */
+	unsigned int retry_count;
+	unsigned int retry_count_rtscts;
+
+	bool retry_updated;
+	u8 sample_skipped;
+};
+
+struct minstrel_mcs_group_data {
+	u8 index;
+	u8 column;
+
+	/* bitfield of supported MCS rates of this group */
+	u8 supported;
+
+	/* selected primary rates */
+	unsigned int max_tp_rate;
+	unsigned int max_tp_rate2;
+	unsigned int max_prob_rate;
+
+	/* MCS rate statistics */
+	struct minstrel_rate_stats rates[MCS_GROUP_RATES];
+};
+
+struct minstrel_ht_sta {
+	/* ampdu length (average, per sampling interval) */
+	unsigned int ampdu_len;
+	unsigned int ampdu_packets;
+
+	/* ampdu length (EWMA) */
+	unsigned int avg_ampdu_len;
+
+	/* best throughput rate */
+	unsigned int max_tp_rate;
+
+	/* second best throughput rate */
+	unsigned int max_tp_rate2;
+
+	/* best probability rate */
+	unsigned int max_prob_rate;
+
+	/* time of last status update */
+	unsigned long stats_update;
+
+	/* overhead time in usec for each frame */
+	unsigned int overhead;
+	unsigned int overhead_rtscts;
+
+	unsigned int total_packets;
+	unsigned int sample_packets;
+
+	/* tx flags to add for frames for this sta */
+	u32 tx_flags;
+
+	u8 sample_wait;
+	u8 sample_tries;
+	u8 sample_count;
+	u8 sample_slow;
+
+	/* current MCS group to be sampled */
+	u8 sample_group;
+
+	/* MCS rate group info and statistics */
+	struct minstrel_mcs_group_data groups[MINSTREL_MAX_STREAMS * MINSTREL_STREAM_GROUPS];
+};
+
+struct minstrel_ht_sta_priv {
+	union {
+		struct minstrel_ht_sta ht;
+		struct minstrel_sta_info legacy;
+	};
+#ifdef CONFIG_XRMAC_DEBUGFS
+	struct dentry *dbg_stats;
+#endif
+	void *ratelist;
+	void *sample_table;
+	bool is_ht;
+};
+
+void xrmac_minstrel_ht_add_sta_debugfs(void *priv, void *priv_sta, struct dentry *dir);
+void xrmac_minstrel_ht_remove_sta_debugfs(void *priv, void *priv_sta);
+
+#endif
diff -Naurp a/drivers/net/wireless/xr829/umac/rc80211_minstrel_ht_debugfs.c b/drivers/net/wireless/xr829/umac/rc80211_minstrel_ht_debugfs.c
--- a/drivers/net/wireless/xr829/umac/rc80211_minstrel_ht_debugfs.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/rc80211_minstrel_ht_debugfs.c	2022-08-27 01:22:42.954539862 +0300
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2010 Felix Fietkau <nbd@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/netdevice.h>
+#include <linux/types.h>
+#include <linux/skbuff.h>
+#include <linux/debugfs.h>
+#include <linux/ieee80211.h>
+#include <linux/export.h>
+#include <net/mac80211.h>
+#include "rc80211_minstrel.h"
+#include "rc80211_minstrel_ht.h"
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+
+static int
+minstrel_ht_stats_open(struct inode *inode, struct file *file)
+{
+	struct minstrel_ht_sta_priv *msp = inode->i_private;
+	struct minstrel_ht_sta *mi = &msp->ht;
+	struct minstrel_debugfs_info *ms;
+	unsigned int i, j, tp, prob, eprob;
+	char *p;
+	int ret;
+
+	if (!msp->is_ht) {
+		inode->i_private = &msp->legacy;
+		ret = xrmac_minstrel_stats_open(inode, file);
+		inode->i_private = msp;
+		return ret;
+	}
+
+	ms = kmalloc(sizeof(*ms) + 8192, GFP_KERNEL);
+	if (!ms)
+		return -ENOMEM;
+
+	file->private_data = ms;
+	p = ms->buf;
+	p += sprintf(p, "type      rate     throughput  ewma prob   this prob  "
+			"this succ/attempt   success    attempts\n");
+	for (i = 0; i < MINSTREL_MAX_STREAMS * MINSTREL_STREAM_GROUPS; i++) {
+		char htmode = '2';
+		char gimode = 'L';
+
+		if (!mi->groups[i].supported)
+			continue;
+
+		if (xrmac_minstrel_mcs_groups[i].flags & IEEE80211_TX_RC_40_MHZ_WIDTH)
+			htmode = '4';
+		if (xrmac_minstrel_mcs_groups[i].flags & IEEE80211_TX_RC_SHORT_GI)
+			gimode = 'S';
+
+		for (j = 0; j < MCS_GROUP_RATES; j++) {
+			struct minstrel_rate_stats *mr = &mi->groups[i].rates[j];
+			int idx = i * MCS_GROUP_RATES + j;
+
+			if (!(mi->groups[i].supported & BIT(j)))
+				continue;
+
+			p += sprintf(p, "HT%c0/%cGI ", htmode, gimode);
+
+			*(p++) = (idx == mi->max_tp_rate) ? 'T' : ' ';
+			*(p++) = (idx == mi->max_tp_rate2) ? 't' : ' ';
+			*(p++) = (idx == mi->max_prob_rate) ? 'P' : ' ';
+			p += sprintf(p, "MCS%-2u", (xrmac_minstrel_mcs_groups[i].streams - 1) *
+					MCS_GROUP_RATES + j);
+
+			tp = mr->cur_tp / 10;
+			prob = MINSTREL_TRUNC(mr->cur_prob * 1000);
+			eprob = MINSTREL_TRUNC(mr->probability * 1000);
+
+			p += sprintf(p, "  %6u.%1u   %6u.%1u   %6u.%1u        "
+					"%3u(%3u)   %8llu    %8llu\n",
+					tp / 10, tp % 10,
+					eprob / 10, eprob % 10,
+					prob / 10, prob % 10,
+					mr->last_success,
+					mr->last_attempts,
+					(unsigned long long)mr->succ_hist,
+					(unsigned long long)mr->att_hist);
+		}
+	}
+	p += sprintf(p, "\nTotal packet count::    ideal %d      "
+			"lookaround %d\n",
+			max(0, (int) mi->total_packets - (int) mi->sample_packets),
+			mi->sample_packets);
+	p += sprintf(p, "Average A-MPDU length: %d.%d\n",
+		MINSTREL_TRUNC(mi->avg_ampdu_len),
+		MINSTREL_TRUNC(mi->avg_ampdu_len * 10) % 10);
+	ms->len = p - ms->buf;
+
+	return nonseekable_open(inode, file);
+}
+
+static const struct file_operations minstrel_ht_stat_fops = {
+	.owner = THIS_MODULE,
+	.open = minstrel_ht_stats_open,
+	.read = xrmac_minstrel_stats_read,
+	.release = xrmac_minstrel_stats_release,
+	.llseek = no_llseek,
+};
+
+static int minstrel_ctrl_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+static ssize_t minstrel_get_param(struct file *file,
+	char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct minstrel_priv *mp_ctrl = file->private_data;
+	char buf[200];
+	size_t size = 0;
+	sprintf(buf, "ewma_level=%d, update_interval=%dms\n" \
+			"has_mrr=%d, lookaround=%d, lookaround_mrr=%d\n",
+			mp_ctrl->ewma_level, mp_ctrl->update_interval,
+			mp_ctrl->has_mrr, mp_ctrl->lookaround_rate, mp_ctrl->lookaround_rate_mrr);
+
+	size = strlen(buf);
+
+	return simple_read_from_buffer(user_buf, count, ppos,
+					buf, size);
+}
+
+static ssize_t minstrel_set_param(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct minstrel_priv *mp_ctrl = file->private_data;
+	char buf[50] = {0};
+	char *start  = &buf[0];
+	char *endptr = NULL;
+	unsigned int set_param = 0;
+
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, count > 49 ? 49 : count))
+		return -EFAULT;
+
+
+	set_param = simple_strtoul(start, &endptr, 10);
+	if (set_param <= 100)
+		mp_ctrl->ewma_level = set_param;
+
+	start = endptr+1;
+	if (start < buf+49) {
+		set_param = simple_strtoul(start, &endptr, 10);
+		mp_ctrl->update_interval = set_param;
+	}
+
+	start = endptr+1;
+	if (start < buf+49) {
+		set_param = simple_strtoul(start, &endptr, 10);
+		if (set_param <= 100)
+			mp_ctrl->lookaround_rate = set_param;
+	}
+
+	start = endptr+1;
+	if (start < buf+49) {
+		set_param = simple_strtoul(start, &endptr, 10);
+		if (set_param <= 100)
+			mp_ctrl->lookaround_rate_mrr = set_param;
+	}
+	return count;
+}
+
+static const struct file_operations fops_param_ctrl = {
+	.open   = minstrel_ctrl_open,
+	.write  = minstrel_set_param,
+	.read   = minstrel_get_param,
+	.llseek = default_llseek,
+};
+
+void
+xrmac_minstrel_ht_add_sta_debugfs(void *priv, void *priv_sta, struct dentry *dir)
+{
+	struct minstrel_ht_sta_priv *msp = priv_sta;
+
+	msp->dbg_stats = debugfs_create_file("rc_stats", S_IRUGO, dir, msp,
+			&minstrel_ht_stat_fops);
+
+	if (priv)
+		msp->dbg_stats = debugfs_create_file("param_ctrl", S_IRUSR|S_IWUSR, dir,
+											priv, &fops_param_ctrl);
+}
+
+void
+xrmac_minstrel_ht_remove_sta_debugfs(void *priv, void *priv_sta)
+{
+	struct minstrel_ht_sta_priv *msp = priv_sta;
+
+	debugfs_remove(msp->dbg_stats);
+}
+#endif /* CONFIG_XRMAC_DEBUGFS */
diff -Naurp a/drivers/net/wireless/xr829/umac/rc80211_pid.h b/drivers/net/wireless/xr829/umac/rc80211_pid.h
--- a/drivers/net/wireless/xr829/umac/rc80211_pid.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/rc80211_pid.h	2022-08-27 01:22:42.954539862 +0300
@@ -0,0 +1,278 @@
+/*
+ * Copyright 2007, Mattias Nissler <mattias.nissler@gmx.de>
+ * Copyright 2007, Stefano Brivio <stefano.brivio@polimi.it>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef RC80211_PID_H
+#define RC80211_PID_H
+
+/* Sampling period for measuring percentage of failed frames in ms. */
+#define RC_PID_INTERVAL			125
+
+/* Exponential averaging smoothness (used for I part of PID controller) */
+#define RC_PID_SMOOTHING_SHIFT		3
+#define RC_PID_SMOOTHING		(1 << RC_PID_SMOOTHING_SHIFT)
+
+/* Sharpening factor (used for D part of PID controller) */
+#define RC_PID_SHARPENING_FACTOR	0
+#define RC_PID_SHARPENING_DURATION	0
+
+/* Fixed point arithmetic shifting amount. */
+#define RC_PID_ARITH_SHIFT		8
+
+/* Proportional PID component coefficient. */
+#define RC_PID_COEFF_P			15
+/* Integral PID component coefficient. */
+#define RC_PID_COEFF_I			9
+/* Derivative PID component coefficient. */
+#define RC_PID_COEFF_D			15
+
+/* Target failed frames rate for the PID controller. NB: This effectively gives
+ * maximum failed frames percentage we're willing to accept. If the wireless
+ * link quality is good, the controller will fail to adjust failed frames
+ * percentage to the target. This is intentional.
+ */
+#define RC_PID_TARGET_PF		14
+
+/* Rate behaviour normalization quantity over time. */
+#define RC_PID_NORM_OFFSET		3
+
+/* Push high rates right after loading. */
+#define RC_PID_FAST_START		0
+
+/* Arithmetic right shift for positive and negative values for ISO C. */
+#define RC_PID_DO_ARITH_RIGHT_SHIFT(x, y) \
+	((x) < 0 ? -((-(x)) >> (y)) : (x) >> (y))
+
+enum rc_pid_event_type {
+	RC_PID_EVENT_TYPE_TX_STATUS,
+	RC_PID_EVENT_TYPE_RATE_CHANGE,
+	RC_PID_EVENT_TYPE_TX_RATE,
+	RC_PID_EVENT_TYPE_PF_SAMPLE,
+};
+
+union rc_pid_event_data {
+	/* RC_PID_EVENT_TX_STATUS */
+	struct {
+		u32 flags;
+		struct ieee80211_tx_info tx_status;
+	};
+	/* RC_PID_EVENT_TYPE_RATE_CHANGE */
+	/* RC_PID_EVENT_TYPE_TX_RATE */
+	struct {
+		int index;
+		int rate;
+	};
+	/* RC_PID_EVENT_TYPE_PF_SAMPLE */
+	struct {
+		s32 pf_sample;
+		s32 prop_err;
+		s32 int_err;
+		s32 der_err;
+	};
+};
+
+struct rc_pid_event {
+	/* The time when the event occurred */
+	unsigned long timestamp;
+
+	/* Event ID number */
+	unsigned int id;
+
+	/* Type of event */
+	enum rc_pid_event_type type;
+
+	/* type specific data */
+	union rc_pid_event_data data;
+};
+
+/* Size of the event ring buffer. */
+#define RC_PID_EVENT_RING_SIZE 32
+
+struct rc_pid_event_buffer {
+	/* Counter that generates event IDs */
+	unsigned int ev_count;
+
+	/* Ring buffer of events */
+	struct rc_pid_event ring[RC_PID_EVENT_RING_SIZE];
+
+	/* Index to the entry in events_buf to be reused */
+	unsigned int next_entry;
+
+	/* Lock that guards against concurrent access to this buffer struct */
+	spinlock_t lock;
+
+	/* Wait queue for poll/select and blocking I/O */
+	wait_queue_head_t waitqueue;
+};
+
+struct rc_pid_events_file_info {
+	/* The event buffer we read */
+	struct rc_pid_event_buffer *events;
+
+	/* The entry we have should read next */
+	unsigned int next_entry;
+};
+
+/**
+ * struct rc_pid_debugfs_entries - tunable parameters
+ *
+ * Algorithm parameters, tunable via debugfs.
+ * @target: target percentage for failed frames
+ * @sampling_period: error sampling interval in milliseconds
+ * @coeff_p: absolute value of the proportional coefficient
+ * @coeff_i: absolute value of the integral coefficient
+ * @coeff_d: absolute value of the derivative coefficient
+ * @smoothing_shift: absolute value of the integral smoothing factor (i.e.
+ *	amount of smoothing introduced by the exponential moving average)
+ * @sharpen_factor: absolute value of the derivative sharpening factor (i.e.
+ *	amount of emphasis given to the derivative term after low activity
+ *	events)
+ * @sharpen_duration: duration of the sharpening effect after the detected low
+ *	activity event, relative to sampling_period
+ * @norm_offset: amount of normalization periodically performed on the learnt
+ *	rate behaviour values (lower means we should trust more what we learnt
+ *	about behaviour of rates, higher means we should trust more the natural
+ *	ordering of rates)
+ */
+struct rc_pid_debugfs_entries {
+	struct dentry *target;
+	struct dentry *sampling_period;
+	struct dentry *coeff_p;
+	struct dentry *coeff_i;
+	struct dentry *coeff_d;
+	struct dentry *smoothing_shift;
+	struct dentry *sharpen_factor;
+	struct dentry *sharpen_duration;
+	struct dentry *norm_offset;
+};
+
+void xrmac_rate_control_pid_event_tx_status(struct rc_pid_event_buffer *buf,
+				      struct ieee80211_tx_info *stat);
+
+void xrmac_rate_control_pid_event_rate_change(struct rc_pid_event_buffer *buf,
+					       int index, int rate);
+
+void xrmac_rate_control_pid_event_tx_rate(struct rc_pid_event_buffer *buf,
+					   int index, int rate);
+
+void xrmac_rate_control_pid_event_pf_sample(struct rc_pid_event_buffer *buf,
+					     s32 pf_sample, s32 prop_err,
+					     s32 int_err, s32 der_err);
+
+void xrmac_rate_control_pid_add_sta_debugfs(void *priv, void *priv_sta,
+					     struct dentry *dir);
+
+void xrmac_rate_control_pid_remove_sta_debugfs(void *priv, void *priv_sta);
+
+struct rc_pid_sta_info {
+	unsigned long last_change;
+	unsigned long last_sample;
+
+	u32 tx_num_failed;
+	u32 tx_num_xmit;
+
+	int txrate_idx;
+
+	/* Average failed frames percentage error (i.e. actual vs. target
+	 * percentage), scaled by RC_PID_SMOOTHING. This value is computed
+	 * using using an exponential weighted average technique:
+	 *
+	 *           (RC_PID_SMOOTHING - 1) * err_avg_old + err
+	 * err_avg = ------------------------------------------
+	 *                       RC_PID_SMOOTHING
+	 *
+	 * where err_avg is the new approximation, err_avg_old the previous one
+	 * and err is the error w.r.t. to the current failed frames percentage
+	 * sample. Note that the bigger RC_PID_SMOOTHING the more weight is
+	 * given to the previous estimate, resulting in smoother behavior (i.e.
+	 * corresponding to a longer integration window).
+	 *
+	 * For computation, we actually don't use the above formula, but this
+	 * one:
+	 *
+	 * err_avg_scaled = err_avg_old_scaled - err_avg_old + err
+	 *
+	 * where:
+	 * 	err_avg_scaled = err * RC_PID_SMOOTHING
+	 * 	err_avg_old_scaled = err_avg_old * RC_PID_SMOOTHING
+	 *
+	 * This avoids floating point numbers and the per_failed_old value can
+	 * easily be obtained by shifting per_failed_old_scaled right by
+	 * RC_PID_SMOOTHING_SHIFT.
+	 */
+	s32 err_avg_sc;
+
+	/* Last framed failes percentage sample. */
+	u32 last_pf;
+
+	/* Sharpening needed. */
+	u8 sharp_cnt;
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	/* Event buffer */
+	struct rc_pid_event_buffer events;
+
+	/* Events debugfs file entry */
+	struct dentry *events_entry;
+#endif
+};
+
+/* Algorithm parameters. We keep them on a per-algorithm approach, so they can
+ * be tuned individually for each interface.
+ */
+struct rc_pid_rateinfo {
+
+	/* Map sorted rates to rates in ieee80211_hw_mode. */
+	int index;
+
+	/* Map rates in ieee80211_hw_mode to sorted rates. */
+	int rev_index;
+
+	/* Did we do any measurement on this rate? */
+	bool valid;
+
+	/* Comparison with the lowest rate. */
+	int diff;
+};
+
+struct rc_pid_info {
+
+	/* The failed frames percentage target. */
+	unsigned int target;
+
+	/* Rate at which failed frames percentage is sampled in 0.001s. */
+	unsigned int sampling_period;
+
+	/* P, I and D coefficients. */
+	int coeff_p;
+	int coeff_i;
+	int coeff_d;
+
+	/* Exponential averaging shift. */
+	unsigned int smoothing_shift;
+
+	/* Sharpening factor and duration. */
+	unsigned int sharpen_factor;
+	unsigned int sharpen_duration;
+
+	/* Normalization offset. */
+	unsigned int norm_offset;
+
+	/* Rates information. */
+	struct rc_pid_rateinfo *rinfo;
+
+	/* Index of the last used rate. */
+	int oldrate;
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	/* Debugfs entries created for the parameters above. */
+	struct rc_pid_debugfs_entries dentries;
+#endif
+};
+
+#endif /* RC80211_PID_H */
diff -Naurp a/drivers/net/wireless/xr829/umac/rc80211_pid_algo.c b/drivers/net/wireless/xr829/umac/rc80211_pid_algo.c
--- a/drivers/net/wireless/xr829/umac/rc80211_pid_algo.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/rc80211_pid_algo.c	2022-08-27 01:22:42.954539862 +0300
@@ -0,0 +1,476 @@
+/*
+ * Copyright 2002-2005, Instant802 Networks, Inc.
+ * Copyright 2005, Devicescape Software, Inc.
+ * Copyright 2007, Mattias Nissler <mattias.nissler@gmx.de>
+ * Copyright 2007-2008, Stefano Brivio <stefano.brivio@polimi.it>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/netdevice.h>
+#include <linux/types.h>
+#include <linux/skbuff.h>
+#include <linux/debugfs.h>
+#include <linux/slab.h>
+#include <net/mac80211.h>
+#include "rate.h"
+#include "mesh.h"
+#include "rc80211_pid.h"
+
+
+/* This is an implementation of a TX rate control algorithm that uses a PID
+ * controller. Given a target failed frames rate, the controller decides about
+ * TX rate changes to meet the target failed frames rate.
+ *
+ * The controller basically computes the following:
+ *
+ * adj = CP * err + CI * err_avg + CD * (err - last_err) * (1 + sharpening)
+ *
+ * where
+ *	adj	adjustment value that is used to switch TX rate (see below)
+ *	err	current error: target vs. current failed frames percentage
+ *	last_err	last error
+ *	err_avg	average (i.e. poor man's integral) of recent errors
+ *	sharpening	non-zero when fast response is needed (i.e. right after
+ *			association or no frames sent for a long time), heading
+ *			to zero over time
+ *	CP	Proportional coefficient
+ *	CI	Integral coefficient
+ *	CD	Derivative coefficient
+ *
+ * CP, CI, CD are subject to careful tuning.
+ *
+ * The integral component uses a exponential moving average approach instead of
+ * an actual sliding window. The advantage is that we don't need to keep an
+ * array of the last N error values and computation is easier.
+ *
+ * Once we have the adj value, we map it to a rate by means of a learning
+ * algorithm. This algorithm keeps the state of the percentual failed frames
+ * difference between rates. The behaviour of the lowest available rate is kept
+ * as a reference value, and every time we switch between two rates, we compute
+ * the difference between the failed frames each rate exhibited. By doing so,
+ * we compare behaviours which different rates exhibited in adjacent timeslices,
+ * thus the comparison is minimally affected by external conditions. This
+ * difference gets propagated to the whole set of measurements, so that the
+ * reference is always the same. Periodically, we normalize this set so that
+ * recent events weigh the most. By comparing the adj value with this set, we
+ * avoid pejorative switches to lower rates and allow for switches to higher
+ * rates if they behaved well.
+ *
+ * Note that for the computations we use a fixed-point representation to avoid
+ * floating point arithmetic. Hence, all values are shifted left by
+ * RC_PID_ARITH_SHIFT.
+ */
+
+
+/* Adjust the rate while ensuring that we won't switch to a lower rate if it
+ * exhibited a worse failed frames behaviour and we'll choose the highest rate
+ * whose failed frames behaviour is not worse than the one of the original rate
+ * target. While at it, check that the new rate is valid. */
+static void rate_control_pid_adjust_rate(struct ieee80211_supported_band *sband,
+					 struct ieee80211_sta *sta,
+					 struct rc_pid_sta_info *spinfo, int adj,
+					 struct rc_pid_rateinfo *rinfo)
+{
+	int cur_sorted, new_sorted, probe, tmp, n_bitrates, band;
+	int cur = spinfo->txrate_idx;
+
+	band = sband->band;
+	n_bitrates = sband->n_bitrates;
+
+	/* Map passed arguments to sorted values. */
+	cur_sorted = rinfo[cur].rev_index;
+	new_sorted = cur_sorted + adj;
+
+	/* Check limits. */
+	if (new_sorted < 0)
+		new_sorted = rinfo[0].rev_index;
+	else if (new_sorted >= n_bitrates)
+		new_sorted = rinfo[n_bitrates - 1].rev_index;
+
+	tmp = new_sorted;
+
+	if (adj < 0) {
+		/* Ensure that the rate decrease isn't disadvantageous. */
+		for (probe = cur_sorted; probe >= new_sorted; probe--)
+			if (rinfo[probe].diff <= rinfo[cur_sorted].diff &&
+			    rate_supported(sta, band, rinfo[probe].index))
+				tmp = probe;
+	} else {
+		/* Look for rate increase with zero (or below) cost. */
+		for (probe = new_sorted + 1; probe < n_bitrates; probe++)
+			if (rinfo[probe].diff <= rinfo[new_sorted].diff &&
+			    rate_supported(sta, band, rinfo[probe].index))
+				tmp = probe;
+	}
+
+	/* Fit the rate found to the nearest supported rate. */
+	do {
+		if (rate_supported(sta, band, rinfo[tmp].index)) {
+			spinfo->txrate_idx = rinfo[tmp].index;
+			break;
+		}
+		if (adj < 0)
+			tmp--;
+		else
+			tmp++;
+	} while (tmp < n_bitrates && tmp >= 0);
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	xrmac_rate_control_pid_event_rate_change(&spinfo->events,
+		spinfo->txrate_idx,
+		sband->bitrates[spinfo->txrate_idx].bitrate);
+#endif
+}
+
+/* Normalize the failed frames per-rate differences. */
+static void rate_control_pid_normalize(struct rc_pid_info *pinfo, int l)
+{
+	int i, norm_offset = pinfo->norm_offset;
+	struct rc_pid_rateinfo *r = pinfo->rinfo;
+
+	if (r[0].diff > norm_offset)
+		r[0].diff -= norm_offset;
+	else if (r[0].diff < -norm_offset)
+		r[0].diff += norm_offset;
+	for (i = 0; i < l - 1; i++)
+		if (r[i + 1].diff > r[i].diff + norm_offset)
+			r[i + 1].diff -= norm_offset;
+		else if (r[i + 1].diff <= r[i].diff)
+			r[i + 1].diff += norm_offset;
+}
+
+static void rate_control_pid_sample(struct rc_pid_info *pinfo,
+				    struct ieee80211_supported_band *sband,
+				    struct ieee80211_sta *sta,
+				    struct rc_pid_sta_info *spinfo)
+{
+	struct rc_pid_rateinfo *rinfo = pinfo->rinfo;
+	u32 pf;
+	s32 err_avg;
+	u32 err_prop;
+	u32 err_int;
+	u32 err_der;
+	int adj, i, j, tmp;
+	unsigned long period;
+
+	/* In case nothing happened during the previous control interval, turn
+	 * the sharpening factor on. */
+	period = msecs_to_jiffies(pinfo->sampling_period);
+	if (jiffies - spinfo->last_sample > 2 * period)
+		spinfo->sharp_cnt = pinfo->sharpen_duration;
+
+	spinfo->last_sample = jiffies;
+
+	/* This should never happen, but in case, we assume the old sample is
+	 * still a good measurement and copy it. */
+	if (unlikely(spinfo->tx_num_xmit == 0))
+		pf = spinfo->last_pf;
+	else
+		pf = spinfo->tx_num_failed * 100 / spinfo->tx_num_xmit;
+
+	spinfo->tx_num_xmit = 0;
+	spinfo->tx_num_failed = 0;
+
+	/* If we just switched rate, update the rate behaviour info. */
+	if (pinfo->oldrate != spinfo->txrate_idx) {
+
+		i = rinfo[pinfo->oldrate].rev_index;
+		j = rinfo[spinfo->txrate_idx].rev_index;
+
+		tmp = (pf - spinfo->last_pf);
+		tmp = RC_PID_DO_ARITH_RIGHT_SHIFT(tmp, RC_PID_ARITH_SHIFT);
+
+		rinfo[j].diff = rinfo[i].diff + tmp;
+		pinfo->oldrate = spinfo->txrate_idx;
+	}
+	rate_control_pid_normalize(pinfo, sband->n_bitrates);
+
+	/* Compute the proportional, integral and derivative errors. */
+	err_prop = (pinfo->target - pf) << RC_PID_ARITH_SHIFT;
+
+	err_avg = spinfo->err_avg_sc >> pinfo->smoothing_shift;
+	spinfo->err_avg_sc = spinfo->err_avg_sc - err_avg + err_prop;
+	err_int = spinfo->err_avg_sc >> pinfo->smoothing_shift;
+
+	err_der = (pf - spinfo->last_pf) *
+		  (1 + pinfo->sharpen_factor * spinfo->sharp_cnt);
+	spinfo->last_pf = pf;
+	if (spinfo->sharp_cnt)
+			spinfo->sharp_cnt--;
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	xrmac_rate_control_pid_event_pf_sample(&spinfo->events, pf, err_prop, err_int,
+					 err_der);
+#endif
+
+	/* Compute the controller output. */
+	adj = (err_prop * pinfo->coeff_p + err_int * pinfo->coeff_i
+	      + err_der * pinfo->coeff_d);
+	adj = RC_PID_DO_ARITH_RIGHT_SHIFT(adj, 2 * RC_PID_ARITH_SHIFT);
+
+	/* Change rate. */
+	if (adj)
+		rate_control_pid_adjust_rate(sband, sta, spinfo, adj, rinfo);
+}
+
+static void rate_control_pid_tx_status(void *priv, struct ieee80211_supported_band *sband,
+				       struct ieee80211_sta *sta, void *priv_sta,
+				       struct sk_buff *skb)
+{
+	struct rc_pid_info *pinfo = priv;
+	struct rc_pid_sta_info *spinfo = priv_sta;
+	unsigned long period;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+
+	if (!spinfo)
+		return;
+
+	/* Ignore all frames that were sent with a different rate than the rate
+	 * we currently advise mac80211 to use. */
+	if (info->status.rates[0].idx != spinfo->txrate_idx)
+		return;
+
+	spinfo->tx_num_xmit++;
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	xrmac_rate_control_pid_event_tx_status(&spinfo->events, info);
+#endif
+
+	/* We count frames that totally failed to be transmitted as two bad
+	 * frames, those that made it out but had some retries as one good and
+	 * one bad frame. */
+	if (!(info->flags & IEEE80211_TX_STAT_ACK)) {
+		spinfo->tx_num_failed += 2;
+		spinfo->tx_num_xmit++;
+	} else if (info->status.rates[0].count > 1) {
+		spinfo->tx_num_failed++;
+		spinfo->tx_num_xmit++;
+	}
+
+	/* Update PID controller state. */
+	period = msecs_to_jiffies(pinfo->sampling_period);
+	if (time_after(jiffies, spinfo->last_sample + period))
+		rate_control_pid_sample(pinfo, sband, sta, spinfo);
+}
+
+static void
+rate_control_pid_get_rate(void *priv, struct ieee80211_sta *sta,
+			  void *priv_sta,
+			  struct ieee80211_tx_rate_control *txrc)
+{
+	struct sk_buff *skb = txrc->skb;
+	struct ieee80211_supported_band *sband = txrc->sband;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(info->control.vif);
+	struct rc_pid_sta_info *spinfo = priv_sta;
+	int rateidx;
+
+	if (txrc->rts)
+		info->control.rates[0].count = sdata->wdev.wiphy->retry_long;
+	else
+		info->control.rates[0].count = sdata->wdev.wiphy->retry_short;
+
+	/* Send management frames and NO_ACK data using lowest rate. */
+	if (xrmac_rate_control_send_low(sta, priv_sta, txrc))
+		return;
+
+	rateidx = spinfo->txrate_idx;
+
+	if (rateidx >= sband->n_bitrates)
+		rateidx = sband->n_bitrates - 1;
+
+	info->control.rates[0].idx = rateidx;
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	xrmac_rate_control_pid_event_tx_rate(&spinfo->events,
+		rateidx, sband->bitrates[rateidx].bitrate);
+#endif
+}
+
+static void
+rate_control_pid_rate_init(void *priv, struct ieee80211_supported_band *sband,
+			   struct ieee80211_sta *sta, void *priv_sta)
+{
+	struct rc_pid_sta_info *spinfo = priv_sta;
+	struct rc_pid_info *pinfo = priv;
+	struct rc_pid_rateinfo *rinfo = pinfo->rinfo;
+	int i, j, tmp;
+	bool s;
+
+	/* TODO: This routine should consider using RSSI from previous packets
+	 * as we need to have IEEE 802.1X auth succeed immediately after assoc..
+	 * Until that method is implemented, we will use the lowest supported
+	 * rate as a workaround. */
+
+	/* Sort the rates. This is optimized for the most common case (i.e.
+	 * almost-sorted CCK+OFDM rates). Kind of bubble-sort with reversed
+	 * mapping too. */
+	for (i = 0; i < sband->n_bitrates; i++) {
+		rinfo[i].index = i;
+		rinfo[i].rev_index = i;
+		if (RC_PID_FAST_START)
+			rinfo[i].diff = 0;
+		else
+			rinfo[i].diff = i * pinfo->norm_offset;
+	}
+	for (i = 1; i < sband->n_bitrates; i++) {
+		s = 0;
+		for (j = 0; j < sband->n_bitrates - i; j++)
+			if (unlikely(sband->bitrates[rinfo[j].index].bitrate >
+				     sband->bitrates[rinfo[j + 1].index].bitrate)) {
+				tmp = rinfo[j].index;
+				rinfo[j].index = rinfo[j + 1].index;
+				rinfo[j + 1].index = tmp;
+				rinfo[rinfo[j].index].rev_index = j;
+				rinfo[rinfo[j + 1].index].rev_index = j + 1;
+				s = 1;
+			}
+		if (!s)
+			break;
+	}
+
+	spinfo->txrate_idx = rate_lowest_index(sband, sta);
+}
+
+static void *rate_control_pid_alloc(struct ieee80211_hw *hw,
+				    struct dentry *debugfsdir)
+{
+	struct rc_pid_info *pinfo;
+	struct rc_pid_rateinfo *rinfo;
+	struct ieee80211_supported_band *sband;
+	int i, max_rates = 0;
+#ifdef CONFIG_XRMAC_DEBUGFS
+	struct rc_pid_debugfs_entries *de;
+#endif
+
+	pinfo = kmalloc(sizeof(*pinfo), GFP_ATOMIC);
+	if (!pinfo)
+		return NULL;
+
+	for (i = 0; i < NUM_NL80211_BANDS; i++) {
+		sband = hw->wiphy->bands[i];
+		if (sband && sband->n_bitrates > max_rates)
+			max_rates = sband->n_bitrates;
+	}
+
+	rinfo = kmalloc(sizeof(*rinfo) * max_rates, GFP_ATOMIC);
+	if (!rinfo) {
+		kfree(pinfo);
+		return NULL;
+	}
+
+	pinfo->target = RC_PID_TARGET_PF;
+	pinfo->sampling_period = RC_PID_INTERVAL;
+	pinfo->coeff_p = RC_PID_COEFF_P;
+	pinfo->coeff_i = RC_PID_COEFF_I;
+	pinfo->coeff_d = RC_PID_COEFF_D;
+	pinfo->smoothing_shift = RC_PID_SMOOTHING_SHIFT;
+	pinfo->sharpen_factor = RC_PID_SHARPENING_FACTOR;
+	pinfo->sharpen_duration = RC_PID_SHARPENING_DURATION;
+	pinfo->norm_offset = RC_PID_NORM_OFFSET;
+	pinfo->rinfo = rinfo;
+	pinfo->oldrate = 0;
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	de = &pinfo->dentries;
+	de->target = debugfs_create_u32("target_pf", S_IRUSR | S_IWUSR,
+					debugfsdir, &pinfo->target);
+	de->sampling_period = debugfs_create_u32("sampling_period",
+						 S_IRUSR | S_IWUSR, debugfsdir,
+						 &pinfo->sampling_period);
+	de->coeff_p = debugfs_create_u32("coeff_p", S_IRUSR | S_IWUSR,
+					 debugfsdir, (u32 *)&pinfo->coeff_p);
+	de->coeff_i = debugfs_create_u32("coeff_i", S_IRUSR | S_IWUSR,
+					 debugfsdir, (u32 *)&pinfo->coeff_i);
+	de->coeff_d = debugfs_create_u32("coeff_d", S_IRUSR | S_IWUSR,
+					 debugfsdir, (u32 *)&pinfo->coeff_d);
+	de->smoothing_shift = debugfs_create_u32("smoothing_shift",
+						 S_IRUSR | S_IWUSR, debugfsdir,
+						 &pinfo->smoothing_shift);
+	de->sharpen_factor = debugfs_create_u32("sharpen_factor",
+					       S_IRUSR | S_IWUSR, debugfsdir,
+					       &pinfo->sharpen_factor);
+	de->sharpen_duration = debugfs_create_u32("sharpen_duration",
+						  S_IRUSR | S_IWUSR, debugfsdir,
+						  &pinfo->sharpen_duration);
+	de->norm_offset = debugfs_create_u32("norm_offset",
+					     S_IRUSR | S_IWUSR, debugfsdir,
+					     &pinfo->norm_offset);
+#endif
+
+	return pinfo;
+}
+
+static void rate_control_pid_free(void *priv)
+{
+	struct rc_pid_info *pinfo = priv;
+#ifdef CONFIG_XRMAC_DEBUGFS
+	struct rc_pid_debugfs_entries *de = &pinfo->dentries;
+
+	debugfs_remove(de->norm_offset);
+	debugfs_remove(de->sharpen_duration);
+	debugfs_remove(de->sharpen_factor);
+	debugfs_remove(de->smoothing_shift);
+	debugfs_remove(de->coeff_d);
+	debugfs_remove(de->coeff_i);
+	debugfs_remove(de->coeff_p);
+	debugfs_remove(de->sampling_period);
+	debugfs_remove(de->target);
+#endif
+
+	kfree(pinfo->rinfo);
+	kfree(pinfo);
+}
+
+static void *rate_control_pid_alloc_sta(void *priv, struct ieee80211_sta *sta,
+					gfp_t gfp)
+{
+	struct rc_pid_sta_info *spinfo;
+
+	spinfo = kzalloc(sizeof(*spinfo), gfp);
+	if (spinfo == NULL)
+		return NULL;
+
+	spinfo->last_sample = jiffies;
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	spin_lock_init(&spinfo->events.lock);
+	init_waitqueue_head(&spinfo->events.waitqueue);
+#endif
+
+	return spinfo;
+}
+
+static void rate_control_pid_free_sta(void *priv, struct ieee80211_sta *sta,
+				      void *priv_sta)
+{
+	kfree(priv_sta);
+}
+
+static struct rate_control_ops mac80211_rcpid = {
+	.name = "pid",
+	.tx_status = rate_control_pid_tx_status,
+	.get_rate = rate_control_pid_get_rate,
+	.rate_init = rate_control_pid_rate_init,
+	.alloc = rate_control_pid_alloc,
+	.free = rate_control_pid_free,
+	.alloc_sta = rate_control_pid_alloc_sta,
+	.free_sta = rate_control_pid_free_sta,
+#ifdef CONFIG_XRMAC_DEBUGFS
+	.add_sta_debugfs = xrmac_rate_control_pid_add_sta_debugfs,
+	.remove_sta_debugfs = xrmac_rate_control_pid_remove_sta_debugfs,
+#endif
+};
+
+int __init xrmac_rc80211_pid_init(void)
+{
+	return mac80211_rate_control_register(&mac80211_rcpid);
+}
+
+void xrmac_rc80211_pid_exit(void)
+{
+	mac80211_rate_control_unregister(&mac80211_rcpid);
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/rc80211_pid_debugfs.c b/drivers/net/wireless/xr829/umac/rc80211_pid_debugfs.c
--- a/drivers/net/wireless/xr829/umac/rc80211_pid_debugfs.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/rc80211_pid_debugfs.c	2022-08-27 01:22:42.954539862 +0300
@@ -0,0 +1,230 @@
+/*
+ * Copyright 2007, Mattias Nissler <mattias.nissler@gmx.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/poll.h>
+#include <linux/netdevice.h>
+#include <linux/types.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/export.h>
+
+#include <net/mac80211.h>
+#include "rate.h"
+
+#include "rc80211_pid.h"
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+static void rate_control_pid_event(struct rc_pid_event_buffer *buf,
+				   enum rc_pid_event_type type,
+				   union rc_pid_event_data *data)
+{
+	struct rc_pid_event *ev;
+	unsigned long status;
+
+	spin_lock_irqsave(&buf->lock, status);
+	ev = &(buf->ring[buf->next_entry]);
+	buf->next_entry = (buf->next_entry + 1) % RC_PID_EVENT_RING_SIZE;
+
+	ev->timestamp = jiffies;
+	ev->id = buf->ev_count++;
+	ev->type = type;
+	ev->data = *data;
+
+	spin_unlock_irqrestore(&buf->lock, status);
+
+	wake_up_all(&buf->waitqueue);
+}
+
+void xrmac_rate_control_pid_event_tx_status(struct rc_pid_event_buffer *buf,
+				      struct ieee80211_tx_info *stat)
+{
+	union rc_pid_event_data evd;
+
+	evd.flags = stat->flags;
+	memcpy(&evd.tx_status, stat, sizeof(struct ieee80211_tx_info));
+	rate_control_pid_event(buf, RC_PID_EVENT_TYPE_TX_STATUS, &evd);
+}
+
+void xrmac_rate_control_pid_event_rate_change(struct rc_pid_event_buffer *buf,
+					       int index, int rate)
+{
+	union rc_pid_event_data evd;
+
+	evd.index = index;
+	evd.rate = rate;
+	rate_control_pid_event(buf, RC_PID_EVENT_TYPE_RATE_CHANGE, &evd);
+}
+
+void xrmac_rate_control_pid_event_tx_rate(struct rc_pid_event_buffer *buf,
+					   int index, int rate)
+{
+	union rc_pid_event_data evd;
+
+	evd.index = index;
+	evd.rate = rate;
+	rate_control_pid_event(buf, RC_PID_EVENT_TYPE_TX_RATE, &evd);
+}
+
+void xrmac_rate_control_pid_event_pf_sample(struct rc_pid_event_buffer *buf,
+					     s32 pf_sample, s32 prop_err,
+					     s32 int_err, s32 der_err)
+{
+	union rc_pid_event_data evd;
+
+	evd.pf_sample = pf_sample;
+	evd.prop_err = prop_err;
+	evd.int_err = int_err;
+	evd.der_err = der_err;
+	rate_control_pid_event(buf, RC_PID_EVENT_TYPE_PF_SAMPLE, &evd);
+}
+
+static int rate_control_pid_events_open(struct inode *inode, struct file *file)
+{
+	struct rc_pid_sta_info *sinfo = inode->i_private;
+	struct rc_pid_event_buffer *events = &sinfo->events;
+	struct rc_pid_events_file_info *file_info;
+	unsigned long status;
+
+	/* Allocate a state struct */
+	file_info = kmalloc(sizeof(*file_info), GFP_KERNEL);
+	if (file_info == NULL)
+		return -ENOMEM;
+
+	spin_lock_irqsave(&events->lock, status);
+
+	file_info->next_entry = events->next_entry;
+	file_info->events = events;
+
+	spin_unlock_irqrestore(&events->lock, status);
+
+	file->private_data = file_info;
+
+	return 0;
+}
+
+static int rate_control_pid_events_release(struct inode *inode,
+					   struct file *file)
+{
+	struct rc_pid_events_file_info *file_info = file->private_data;
+
+	kfree(file_info);
+
+	return 0;
+}
+
+static unsigned int rate_control_pid_events_poll(struct file *file,
+						 poll_table *wait)
+{
+	struct rc_pid_events_file_info *file_info = file->private_data;
+
+	poll_wait(file, &file_info->events->waitqueue, wait);
+
+	return POLLIN | POLLRDNORM;
+}
+
+#define RC_PID_PRINT_BUF_SIZE 64
+
+static ssize_t rate_control_pid_events_read(struct file *file, char __user *buf,
+					    size_t length, loff_t *offset)
+{
+	struct rc_pid_events_file_info *file_info = file->private_data;
+	struct rc_pid_event_buffer *events = file_info->events;
+	struct rc_pid_event *ev;
+	char pb[RC_PID_PRINT_BUF_SIZE];
+	int ret;
+	int p;
+	unsigned long status;
+
+	/* Check if there is something to read. */
+	if (events->next_entry == file_info->next_entry) {
+		if (file->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+
+		/* Wait */
+		ret = wait_event_interruptible(events->waitqueue,
+				events->next_entry != file_info->next_entry);
+
+		if (ret)
+			return ret;
+	}
+
+	/* Write out one event per call. I don't care whether it's a little
+	 * inefficient, this is debugging code anyway. */
+	spin_lock_irqsave(&events->lock, status);
+
+	/* Get an event */
+	ev = &(events->ring[file_info->next_entry]);
+	file_info->next_entry = (file_info->next_entry + 1) %
+				RC_PID_EVENT_RING_SIZE;
+
+	/* Print information about the event. Note that userspace needs to
+	 * provide large enough buffers. */
+	length = length < RC_PID_PRINT_BUF_SIZE ?
+		 length : RC_PID_PRINT_BUF_SIZE;
+	p = snprintf(pb, length, "%u %lu ", ev->id, ev->timestamp);
+	switch (ev->type) {
+	case RC_PID_EVENT_TYPE_TX_STATUS:
+		p += snprintf(pb + p, length - p, "tx_status %u %u",
+			      !(ev->data.flags & IEEE80211_TX_STAT_ACK),
+			      ev->data.tx_status.status.rates[0].idx);
+		break;
+	case RC_PID_EVENT_TYPE_RATE_CHANGE:
+		p += snprintf(pb + p, length - p, "rate_change %d %d",
+			      ev->data.index, ev->data.rate);
+		break;
+	case RC_PID_EVENT_TYPE_TX_RATE:
+		p += snprintf(pb + p, length - p, "tx_rate %d %d",
+			      ev->data.index, ev->data.rate);
+		break;
+	case RC_PID_EVENT_TYPE_PF_SAMPLE:
+		p += snprintf(pb + p, length - p,
+			      "pf_sample %d %d %d %d",
+			      ev->data.pf_sample, ev->data.prop_err,
+			      ev->data.int_err, ev->data.der_err);
+		break;
+	}
+	p += snprintf(pb + p, length - p, "\n");
+
+	spin_unlock_irqrestore(&events->lock, status);
+
+	if (copy_to_user(buf, pb, p))
+		return -EFAULT;
+
+	return p;
+}
+
+#undef RC_PID_PRINT_BUF_SIZE
+
+static const struct file_operations rc_pid_fop_events = {
+	.owner = THIS_MODULE,
+	.read = rate_control_pid_events_read,
+	.poll = rate_control_pid_events_poll,
+	.open = rate_control_pid_events_open,
+	.release = rate_control_pid_events_release,
+	.llseek = noop_llseek,
+};
+
+void xrmac_rate_control_pid_add_sta_debugfs(void *priv, void *priv_sta,
+					     struct dentry *dir)
+{
+	struct rc_pid_sta_info *spinfo = priv_sta;
+
+	spinfo->events_entry = debugfs_create_file("rc_pid_events", S_IRUGO,
+						   dir, spinfo,
+						   &rc_pid_fop_events);
+}
+
+void xrmac_rate_control_pid_remove_sta_debugfs(void *priv, void *priv_sta)
+{
+	struct rc_pid_sta_info *spinfo = priv_sta;
+
+	debugfs_remove(spinfo->events_entry);
+}
+#endif /* CONFIG_XRMAC_DEBUGFS */
diff -Naurp a/drivers/net/wireless/xr829/umac/rx.c b/drivers/net/wireless/xr829/umac/rx.c
--- a/drivers/net/wireless/xr829/umac/rx.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/rx.c	2022-08-27 01:22:42.954539862 +0300
@@ -0,0 +1,3253 @@
+/*
+ * Copyright 2002-2005, Instant802 Networks, Inc.
+ * Copyright 2005-2006, Devicescape Software, Inc.
+ * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
+ * Copyright 2007-2010	Johannes Berg <johannes@sipsolutions.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/jiffies.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/rcupdate.h>
+#include <linux/export.h>
+#include <net/mac80211.h>
+#include <net/ieee80211_radiotap.h>
+
+#include "ieee80211_i.h"
+#include "driver-ops.h"
+#include "led.h"
+#include "mesh.h"
+#include "wep.h"
+#include "wpa.h"
+#include "tkip.h"
+#include "wme.h"
+#include "wapi.h"
+
+static bool ieee80211_frame_eapol(u8 *data, int len);
+
+/*
+ * monitor mode reception
+ *
+ * This function cleans up the SKB, i.e. it removes all the stuff
+ * only useful for monitoring.
+ */
+static struct sk_buff *remove_monitor_info(struct ieee80211_local *local,
+					   struct sk_buff *skb)
+{
+	if (local->hw.flags & IEEE80211_HW_RX_INCLUDES_FCS) {
+		if (likely(skb->len > FCS_LEN))
+			__pskb_trim(skb, skb->len - FCS_LEN);
+		else {
+			/* driver bug */
+			WARN_ON(1);
+			dev_kfree_skb(skb);
+			skb = NULL;
+		}
+	}
+
+	return skb;
+}
+
+static inline int should_drop_frame(struct sk_buff *skb,
+				    int present_fcs_len)
+{
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+
+	if (status->flag & (RX_FLAG_FAILED_FCS_CRC | RX_FLAG_FAILED_PLCP_CRC))
+		return 1;
+	if (unlikely(skb->len < 16 + present_fcs_len))
+		return 1;
+	if (ieee80211_is_ctl(hdr->frame_control) &&
+	    !ieee80211_is_pspoll(hdr->frame_control) &&
+	    !ieee80211_is_back_req(hdr->frame_control))
+		return 1;
+	return 0;
+}
+
+static int
+ieee80211_rx_radiotap_len(struct ieee80211_local *local,
+			  struct ieee80211_rx_status *status)
+{
+	int len;
+
+	/* always present fields */
+	len = sizeof(struct ieee80211_radiotap_header) + 9;
+
+	if (status->flag & RX_FLAG_MACTIME_MPDU)
+		len += 8;
+	if (local->hw.flags & IEEE80211_HW_SIGNAL_DBM)
+		len += 1;
+
+	if (len & 1) /* padding for RX_FLAGS if necessary */
+		len++;
+
+	if (status->flag & RX_FLAG_HT) /* HT info */
+		len += 3;
+
+	return len;
+}
+
+/*
+ * ieee80211_add_rx_radiotap_header - add radiotap header
+ *
+ * add a radiotap header containing all the fields which the hardware provided.
+ */
+static void
+ieee80211_add_rx_radiotap_header(struct ieee80211_local *local,
+				 struct sk_buff *skb,
+				 struct ieee80211_rate *rate,
+				 int rtap_len)
+{
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
+	struct ieee80211_radiotap_header *rthdr;
+	unsigned char *pos;
+	u16 rx_flags = 0;
+
+	rthdr = (struct ieee80211_radiotap_header *)skb_push(skb, rtap_len);
+	memset(rthdr, 0, rtap_len);
+
+	/* radiotap header, set always present flags */
+	rthdr->it_present =
+		cpu_to_le32((1 << IEEE80211_RADIOTAP_FLAGS) |
+			    (1 << IEEE80211_RADIOTAP_CHANNEL) |
+			    (1 << IEEE80211_RADIOTAP_ANTENNA) |
+			    (1 << IEEE80211_RADIOTAP_RX_FLAGS));
+	rthdr->it_len = cpu_to_le16(rtap_len);
+
+	pos = (unsigned char *)(rthdr+1);
+
+	/* the order of the following fields is important */
+
+	/* IEEE80211_RADIOTAP_TSFT */
+	if (status->flag & RX_FLAG_MACTIME_MPDU) {
+		put_unaligned_le64(status->mactime, pos);
+		rthdr->it_present |=
+			cpu_to_le32(1 << IEEE80211_RADIOTAP_TSFT);
+		pos += 8;
+	}
+
+	/* IEEE80211_RADIOTAP_FLAGS */
+	if (local->hw.flags & IEEE80211_HW_RX_INCLUDES_FCS)
+		*pos |= IEEE80211_RADIOTAP_F_FCS;
+	if (status->flag & (RX_FLAG_FAILED_FCS_CRC | RX_FLAG_FAILED_PLCP_CRC))
+		*pos |= IEEE80211_RADIOTAP_F_BADFCS;
+	if (status->flag & RX_FLAG_SHORTPRE)
+		*pos |= IEEE80211_RADIOTAP_F_SHORTPRE;
+	pos++;
+
+	/* IEEE80211_RADIOTAP_RATE */
+	if (!rate || status->flag & RX_FLAG_HT) {
+		/*
+		 * Without rate information don't add it. If we have,
+		 * MCS information is a separate field in radiotap,
+		 * added below. The byte here is needed as padding
+		 * for the channel though, so initialise it to 0.
+		 */
+		*pos = 0;
+	} else {
+		rthdr->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_RATE);
+		*pos = rate->bitrate / 5;
+	}
+	pos++;
+
+	/* IEEE80211_RADIOTAP_CHANNEL */
+	put_unaligned_le16(status->freq, pos);
+	pos += 2;
+	if (status->band == NL80211_BAND_5GHZ)
+		put_unaligned_le16(IEEE80211_CHAN_OFDM | IEEE80211_CHAN_5GHZ,
+				   pos);
+	else if (status->flag & RX_FLAG_HT)
+		put_unaligned_le16(IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ,
+				   pos);
+	else if (rate && rate->flags & IEEE80211_RATE_ERP_G)
+		put_unaligned_le16(IEEE80211_CHAN_OFDM | IEEE80211_CHAN_2GHZ,
+				   pos);
+	else if (rate)
+		put_unaligned_le16(IEEE80211_CHAN_CCK | IEEE80211_CHAN_2GHZ,
+				   pos);
+	else
+		put_unaligned_le16(IEEE80211_CHAN_2GHZ, pos);
+	pos += 2;
+
+	/* IEEE80211_RADIOTAP_DBM_ANTSIGNAL */
+	if (local->hw.flags & IEEE80211_HW_SIGNAL_DBM) {
+		*pos = status->signal;
+		rthdr->it_present |=
+			cpu_to_le32(1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL);
+		pos++;
+	}
+
+	/* IEEE80211_RADIOTAP_LOCK_QUALITY is missing */
+
+	/* IEEE80211_RADIOTAP_ANTENNA */
+	*pos = status->antenna;
+	pos++;
+
+	/* IEEE80211_RADIOTAP_DB_ANTNOISE is not used */
+
+	/* IEEE80211_RADIOTAP_RX_FLAGS */
+	/* ensure 2 byte alignment for the 2 byte field as required */
+	if ((pos - (u8 *)rthdr) & 1)
+		pos++;
+	if (status->flag & RX_FLAG_FAILED_PLCP_CRC)
+		rx_flags |= IEEE80211_RADIOTAP_F_RX_BADPLCP;
+	put_unaligned_le16(rx_flags, pos);
+	pos += 2;
+
+	if (status->flag & RX_FLAG_HT) {
+		rthdr->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_MCS);
+		*pos++ = IEEE80211_RADIOTAP_MCS_HAVE_MCS |
+			 IEEE80211_RADIOTAP_MCS_HAVE_GI |
+			 IEEE80211_RADIOTAP_MCS_HAVE_BW;
+		*pos = 0;
+		if (status->flag & RX_FLAG_SHORT_GI)
+			*pos |= IEEE80211_RADIOTAP_MCS_SGI;
+		if (status->flag & RX_FLAG_40MHZ)
+			*pos |= IEEE80211_RADIOTAP_MCS_BW_40;
+		pos++;
+		*pos++ = status->rate_idx;
+	}
+}
+
+/*
+ * This function copies a received frame to all monitor interfaces and
+ * returns a cleaned-up SKB that no longer includes the FCS nor the
+ * radiotap header the driver might have added.
+ */
+static struct sk_buff *
+ieee80211_rx_monitor(struct ieee80211_local *local, struct sk_buff *origskb,
+		     struct ieee80211_rate *rate)
+{
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(origskb);
+	struct ieee80211_sub_if_data *sdata;
+	int needed_headroom = 0;
+	struct sk_buff *skb, *skb2;
+	struct net_device *prev_dev = NULL;
+	int present_fcs_len = 0;
+
+	/*
+	 * First, we may need to make a copy of the skb because
+	 *  (1) we need to modify it for radiotap (if not present), and
+	 *  (2) the other RX handlers will modify the skb we got.
+	 *
+	 * We don't need to, of course, if we aren't going to return
+	 * the SKB because it has a bad FCS/PLCP checksum.
+	 */
+
+	/* room for the radiotap header based on driver features */
+	needed_headroom = ieee80211_rx_radiotap_len(local, status);
+
+	if (local->hw.flags & IEEE80211_HW_RX_INCLUDES_FCS)
+		present_fcs_len = FCS_LEN;
+
+	/* make sure hdr->frame_control is on the linear part */
+	if (!pskb_may_pull(origskb, 2)) {
+		dev_kfree_skb(origskb);
+		return NULL;
+	}
+
+	if (!local->monitors) {
+		if (should_drop_frame(origskb, present_fcs_len)) {
+			dev_kfree_skb(origskb);
+			return NULL;
+		}
+
+		return remove_monitor_info(local, origskb);
+	}
+
+	if (should_drop_frame(origskb, present_fcs_len)) {
+		/* only need to expand headroom if necessary */
+		skb = origskb;
+		origskb = NULL;
+
+		/*
+		 * This shouldn't trigger often because most devices have an
+		 * RX header they pull before we get here, and that should
+		 * be big enough for our radiotap information. We should
+		 * probably export the length to drivers so that we can have
+		 * them allocate enough headroom to start with.
+		 */
+		if (skb_headroom(skb) < needed_headroom &&
+		    pskb_expand_head(skb, needed_headroom, 0, GFP_ATOMIC)) {
+			dev_kfree_skb(skb);
+			return NULL;
+		}
+	} else {
+		/*
+		 * Need to make a copy and possibly remove radiotap header
+		 * and FCS from the original.
+		 */
+		skb = skb_copy_expand(origskb, needed_headroom, 0, GFP_ATOMIC);
+
+		origskb = remove_monitor_info(local, origskb);
+
+		if (!skb)
+			return origskb;
+	}
+
+	/* prepend radiotap information */
+	ieee80211_add_rx_radiotap_header(local, skb, rate, needed_headroom);
+
+	skb_reset_mac_header(skb);
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+	skb->pkt_type = PACKET_OTHERHOST;
+	skb->protocol = htons(ETH_P_802_2);
+
+	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
+		if (sdata->vif.type != NL80211_IFTYPE_MONITOR)
+			continue;
+
+		if (sdata->u.mntr_flags & MONITOR_FLAG_COOK_FRAMES)
+			continue;
+
+		if (!ieee80211_sdata_running(sdata))
+			continue;
+
+		if (prev_dev) {
+			skb2 = skb_clone(skb, GFP_ATOMIC);
+			if (skb2) {
+				skb2->dev = prev_dev;
+				netif_receive_skb(skb2);
+			}
+		}
+
+		prev_dev = sdata->dev;
+		sdata->dev->stats.rx_packets++;
+		sdata->dev->stats.rx_bytes += skb->len;
+	}
+
+	if (prev_dev) {
+		skb->dev = prev_dev;
+		netif_receive_skb(skb);
+	} else
+		dev_kfree_skb(skb);
+
+	return origskb;
+}
+
+
+static void ieee80211_parse_qos(struct ieee80211_rx_data *rx)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);
+	int tid, seqno_idx, security_idx;
+
+	/* does the frame have a qos control field? */
+	if (ieee80211_is_data_qos(hdr->frame_control)) {
+		u8 *qc = ieee80211_get_qos_ctl(hdr);
+		/* frame has qos control */
+		tid = *qc & IEEE80211_QOS_CTL_TID_MASK;
+		if (*qc & IEEE80211_QOS_CTL_A_MSDU_PRESENT)
+			status->rx_flags |= IEEE80211_RX_AMSDU;
+
+		seqno_idx = tid;
+		security_idx = tid;
+	} else {
+		/*
+		 * IEEE 802.11-2007, 7.1.3.4.1 ("Sequence Number field"):
+		 *
+		 *	Sequence numbers for management frames, QoS data
+		 *	frames with a broadcast/multicast address in the
+		 *	Address 1 field, and all non-QoS data frames sent
+		 *	by QoS STAs are assigned using an additional single
+		 *	modulo-4096 counter, [...]
+		 *
+		 * We also use that counter for non-QoS STAs.
+		 */
+		seqno_idx = NUM_RX_DATA_QUEUES;
+		security_idx = 0;
+		if (ieee80211_is_mgmt(hdr->frame_control))
+			security_idx = NUM_RX_DATA_QUEUES;
+		tid = 0;
+	}
+
+	rx->seqno_idx = seqno_idx;
+	rx->security_idx = security_idx;
+	/* Set skb->priority to 1d tag if highest order bit of TID is not set.
+	 * For now, set skb->priority to 0 for other cases. */
+	rx->skb->priority = (tid > 7) ? 0 : tid;
+}
+
+/**
+ * DOC: Packet alignment
+ *
+ * Drivers always need to pass packets that are aligned to two-byte boundaries
+ * to the stack.
+ *
+ * Additionally, should, if possible, align the payload data in a way that
+ * guarantees that the contained IP header is aligned to a four-byte
+ * boundary. In the case of regular frames, this simply means aligning the
+ * payload to a four-byte boundary (because either the IP header is directly
+ * contained, or IV/RFC1042 headers that have a length divisible by four are
+ * in front of it).  If the payload data is not properly aligned and the
+ * architecture doesn't support efficient unaligned operations, mac80211
+ * will align the data.
+ *
+ * With A-MSDU frames, however, the payload data address must yield two modulo
+ * four because there are 14-byte 802.3 headers within the A-MSDU frames that
+ * push the IP header further back to a multiple of four again. Thankfully, the
+ * specs were sane enough this time around to require padding each A-MSDU
+ * subframe to a length that is a multiple of four.
+ *
+ * Padding like Atheros hardware adds which is between the 802.11 header and
+ * the payload is not supported, the driver is required to move the 802.11
+ * header to be directly in front of the payload in that case.
+ */
+static void ieee80211_verify_alignment(struct ieee80211_rx_data *rx)
+{
+#ifdef CONFIG_XRMAC_VERBOSE_DEBUG
+	WARN_ONCE((unsigned long)rx->skb->data & 1,
+		  "unaligned packet at 0x%p\n", rx->skb->data);
+#endif
+}
+
+
+/* rx handlers */
+
+static ieee80211_rx_result debug_noinline
+ieee80211_rx_h_passive_scan(struct ieee80211_rx_data *rx)
+{
+	struct ieee80211_local *local = rx->local;
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);
+	struct sk_buff *skb = rx->skb;
+
+	if (likely(!(status->rx_flags & IEEE80211_RX_IN_SCAN) &&
+		   !local->sched_scanning))
+		return RX_CONTINUE;
+
+	if (test_bit(SCAN_HW_SCANNING, &local->scanning) ||
+	    local->sched_scanning)
+		return mac80211_scan_rx(rx->sdata, skb);
+
+	if (test_bit(SCAN_SW_SCANNING, &local->scanning)) {
+		/* drop all the other packets during a software scan anyway */
+		if (mac80211_scan_rx(rx->sdata, skb) != RX_QUEUED)
+			dev_kfree_skb(skb);
+		return RX_QUEUED;
+	}
+
+	/* scanning finished during invoking of handlers */
+	I802_DEBUG_INC(local->rx_handlers_drop_passive_scan);
+	return RX_DROP_UNUSABLE;
+}
+
+
+static int ieee80211_is_unicast_robust_mgmt_frame(struct sk_buff *skb)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+
+	if (skb->len < 24 || is_multicast_ether_addr(hdr->addr1))
+		return 0;
+
+	return ieee80211_is_robust_mgmt_frame(skb);
+}
+
+
+static int ieee80211_is_multicast_robust_mgmt_frame(struct sk_buff *skb)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+
+	if (skb->len < 24 || !is_multicast_ether_addr(hdr->addr1))
+		return 0;
+
+	return ieee80211_is_robust_mgmt_frame(skb);
+}
+
+
+/* Get the BIP key index from MMIE; return -1 if this is not a BIP frame */
+static int ieee80211_get_mmie_keyidx(struct sk_buff *skb)
+{
+	struct ieee80211_mgmt *hdr = (struct ieee80211_mgmt *) skb->data;
+	struct ieee80211_mmie *mmie;
+
+	if (skb->len < 24 + sizeof(*mmie) ||
+	    !is_multicast_ether_addr(hdr->da))
+		return -1;
+
+	if (!ieee80211_is_robust_mgmt_frame(skb))
+		return -1; /* not a robust management frame */
+
+	mmie = (struct ieee80211_mmie *)
+		(skb->data + skb->len - sizeof(*mmie));
+	if (mmie->element_id != WLAN_EID_MMIE ||
+	    mmie->length != sizeof(*mmie) - 2)
+		return -1;
+
+	return le16_to_cpu(mmie->key_id);
+}
+
+
+static ieee80211_rx_result
+ieee80211_rx_mesh_check(struct ieee80211_rx_data *rx)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;
+	char *dev_addr = rx->sdata->vif.addr;
+
+	if (ieee80211_is_data(hdr->frame_control)) {
+		if (is_multicast_ether_addr(hdr->addr1)) {
+			if (ieee80211_has_tods(hdr->frame_control) ||
+				!ieee80211_has_fromds(hdr->frame_control))
+				return RX_DROP_MONITOR;
+			if (memcmp(hdr->addr3, dev_addr, ETH_ALEN) == 0)
+				return RX_DROP_MONITOR;
+		} else {
+			if (!ieee80211_has_a4(hdr->frame_control))
+				return RX_DROP_MONITOR;
+			if (memcmp(hdr->addr4, dev_addr, ETH_ALEN) == 0)
+				return RX_DROP_MONITOR;
+		}
+	}
+
+	/* If there is not an established peer link and this is not a peer link
+	 * establisment frame, beacon or probe, drop the frame.
+	 */
+
+	if (!rx->sta || sta_plink_state(rx->sta) != NL80211_PLINK_ESTAB) {
+		struct ieee80211_mgmt *mgmt;
+
+		if (!ieee80211_is_mgmt(hdr->frame_control))
+			return RX_DROP_MONITOR;
+
+		if (ieee80211_is_action(hdr->frame_control)) {
+			u8 category;
+			mgmt = (struct ieee80211_mgmt *)hdr;
+			category = mgmt->u.action.category;
+			if (category != WLAN_CATEGORY_MESH_ACTION &&
+				category != WLAN_CATEGORY_SELF_PROTECTED)
+				return RX_DROP_MONITOR;
+			return RX_CONTINUE;
+		}
+
+		if (ieee80211_is_probe_req(hdr->frame_control) ||
+		    ieee80211_is_probe_resp(hdr->frame_control) ||
+		    ieee80211_is_beacon(hdr->frame_control) ||
+		    ieee80211_is_auth(hdr->frame_control))
+			return RX_CONTINUE;
+
+		return RX_DROP_MONITOR;
+
+	}
+
+	return RX_CONTINUE;
+}
+
+#define SEQ_MODULO 0x1000
+#define SEQ_MASK   0xfff
+
+static inline int seq_less(u16 sq1, u16 sq2)
+{
+	return ((sq1 - sq2) & SEQ_MASK) > (SEQ_MODULO >> 1);
+}
+
+static inline u16 seq_inc(u16 sq)
+{
+	return (sq + 1) & SEQ_MASK;
+}
+
+static inline u16 seq_sub(u16 sq1, u16 sq2)
+{
+	return (sq1 - sq2) & SEQ_MASK;
+}
+
+
+static void ieee80211_release_reorder_frame(struct ieee80211_hw *hw,
+					    struct tid_ampdu_rx *tid_agg_rx,
+					    int index)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct sk_buff *skb = tid_agg_rx->reorder_buf[index];
+	struct ieee80211_rx_status *status;
+
+	lockdep_assert_held(&tid_agg_rx->reorder_lock);
+
+	if (!skb)
+		goto no_frame;
+
+	/* release the frame from the reorder ring buffer */
+	tid_agg_rx->stored_mpdu_num--;
+	tid_agg_rx->reorder_buf[index] = NULL;
+	status = IEEE80211_SKB_RXCB(skb);
+	status->rx_flags |= IEEE80211_RX_DEFERRED_RELEASE;
+	skb_queue_tail(&local->rx_skb_queue, skb);
+
+no_frame:
+	tid_agg_rx->head_seq_num = seq_inc(tid_agg_rx->head_seq_num);
+}
+
+static void ieee80211_release_reorder_frames(struct ieee80211_hw *hw,
+					     struct tid_ampdu_rx *tid_agg_rx,
+					     u16 head_seq_num)
+{
+	int index;
+
+	lockdep_assert_held(&tid_agg_rx->reorder_lock);
+
+	while (seq_less(tid_agg_rx->head_seq_num, head_seq_num)) {
+		index = seq_sub(tid_agg_rx->head_seq_num, tid_agg_rx->ssn) %
+							tid_agg_rx->buf_size;
+		ieee80211_release_reorder_frame(hw, tid_agg_rx, index);
+	}
+}
+
+/*
+ * Timeout (in jiffies) for skb's that are waiting in the RX reorder buffer. If
+ * the skb was added to the buffer longer than this time ago, the earlier
+ * frames that have not yet been received are assumed to be lost and the skb
+ * can be released for processing. This may also release other skb's from the
+ * reorder buffer if there are no additional gaps between the frames.
+ *
+ * Callers must hold tid_agg_rx->reorder_lock.
+ */
+#define HT_RX_REORDER_BUF_TIMEOUT (HZ / 10)
+
+static void ieee80211_sta_reorder_release(struct ieee80211_hw *hw,
+					  struct tid_ampdu_rx *tid_agg_rx)
+{
+	int index, j;
+
+	lockdep_assert_held(&tid_agg_rx->reorder_lock);
+
+	/* release the buffer until next missing frame */
+	index = seq_sub(tid_agg_rx->head_seq_num, tid_agg_rx->ssn) %
+						tid_agg_rx->buf_size;
+	if (!tid_agg_rx->reorder_buf[index] &&
+	    tid_agg_rx->stored_mpdu_num) {
+		/*
+		 * No buffers ready to be released, but check whether any
+		 * frames in the reorder buffer have timed out.
+		 */
+		int skipped = 1;
+		for (j = (index + 1) % tid_agg_rx->buf_size; j != index;
+		     j = (j + 1) % tid_agg_rx->buf_size) {
+			if (!tid_agg_rx->reorder_buf[j]) {
+				skipped++;
+				continue;
+			}
+			if (skipped &&
+			    !time_after(jiffies, tid_agg_rx->reorder_time[j] +
+					HT_RX_REORDER_BUF_TIMEOUT))
+				goto set_release_timer;
+
+#ifdef CONFIG_XRMAC_HT_DEBUG
+			if (net_ratelimit())
+				wiphy_debug(hw->wiphy,
+					    "release an RX reorder frame due to timeout on earlier frames\n");
+#endif
+			ieee80211_release_reorder_frame(hw, tid_agg_rx, j);
+
+			/*
+			 * Increment the head seq# also for the skipped slots.
+			 */
+			tid_agg_rx->head_seq_num =
+				(tid_agg_rx->head_seq_num + skipped) & SEQ_MASK;
+			skipped = 0;
+		}
+	} else {
+		while (tid_agg_rx->reorder_buf[index]) {
+			ieee80211_release_reorder_frame(hw, tid_agg_rx, index);
+			index =	seq_sub(tid_agg_rx->head_seq_num, tid_agg_rx->ssn) %
+							tid_agg_rx->buf_size;
+		}
+	}
+
+	if (tid_agg_rx->stored_mpdu_num) {
+		j = index = seq_sub(tid_agg_rx->head_seq_num,
+				    tid_agg_rx->ssn) % tid_agg_rx->buf_size;
+
+		for (; j != (index - 1) % tid_agg_rx->buf_size;
+		     j = (j + 1) % tid_agg_rx->buf_size) {
+			if (tid_agg_rx->reorder_buf[j])
+				break;
+		}
+
+ set_release_timer:
+
+		mod_timer(&tid_agg_rx->reorder_timer,
+			  tid_agg_rx->reorder_time[j] + 1 +
+			  HT_RX_REORDER_BUF_TIMEOUT);
+	} else {
+		del_timer(&tid_agg_rx->reorder_timer);
+	}
+}
+
+/*
+ * As this function belongs to the RX path it must be under
+ * rcu_read_lock protection. It returns false if the frame
+ * can be processed immediately, true if it was consumed.
+ */
+
+static u16 last_head_seq_num;
+static u16 same_counter;
+
+static bool ieee80211_sta_manage_reorder_buf(struct ieee80211_hw *hw,
+					     struct tid_ampdu_rx *tid_agg_rx,
+					     struct sk_buff *skb)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	u16 sc = le16_to_cpu(hdr->seq_ctrl);
+	u16 mpdu_seq_num = (sc & IEEE80211_SCTL_SEQ) >> 4;
+	u16 head_seq_num, buf_size;
+	int index;
+	bool ret = true;
+	bool isEapol = (ieee80211_is_data(hdr->frame_control) &&
+				ieee80211_frame_eapol(skb->data, skb->len));
+
+
+	spin_lock(&tid_agg_rx->reorder_lock);
+
+	buf_size = tid_agg_rx->buf_size;
+	head_seq_num = tid_agg_rx->head_seq_num;
+
+	/* frame with out of date sequence number */
+	if (seq_less(mpdu_seq_num, head_seq_num)) {
+#if 1
+		/*workaround begin*/
+		if (last_head_seq_num == head_seq_num)
+			same_counter++;
+		else
+			same_counter = 0;
+		last_head_seq_num = head_seq_num;
+		/*workaround end*/
+#endif
+
+#if 1
+		/*workaround begin*/
+		if (same_counter == 32) {
+			ieee80211_release_reorder_frames(hw, tid_agg_rx, mpdu_seq_num);
+			tid_agg_rx->head_seq_num = mpdu_seq_num;
+			head_seq_num = tid_agg_rx->head_seq_num;
+			same_counter = 0;
+		} else {
+		/*workaround end*/
+#endif
+			dev_kfree_skb(skb);
+			goto out;
+#if 1
+		}
+#endif
+	}
+
+	/*
+	 * If frame the sequence number exceeds our buffering window
+	 * size release some previous frames to make room for this one.
+	 */
+	if (!seq_less(mpdu_seq_num, head_seq_num + buf_size)) {
+		head_seq_num = seq_inc(seq_sub(mpdu_seq_num, buf_size));
+		/* release stored frames up to new head to stack */
+		ieee80211_release_reorder_frames(hw, tid_agg_rx, head_seq_num);
+	}
+
+	/* Now the new frame is always in the range of the reordering buffer */
+
+	index = seq_sub(mpdu_seq_num, tid_agg_rx->ssn) % tid_agg_rx->buf_size;
+
+	/* check if we already stored this frame */
+	if (tid_agg_rx->reorder_buf[index]) {
+		dev_kfree_skb(skb);
+		goto out;
+	}
+
+	/*
+	 * If the current MPDU is in the right order and nothing else
+	 * is stored we can process it directly, no need to buffer it.
+	 * If it is first but there's something stored, we may be able
+	 * to release frames after this one.
+	 */
+	if (mpdu_seq_num == tid_agg_rx->head_seq_num &&
+	    tid_agg_rx->stored_mpdu_num == 0) {
+		tid_agg_rx->head_seq_num = seq_inc(tid_agg_rx->head_seq_num);
+		ret = false;
+		goto out;
+	}
+
+	if (isEapol && mpdu_seq_num == (tid_agg_rx->head_seq_num + 1) &&
+		tid_agg_rx->stored_mpdu_num == 0) {
+		tid_agg_rx->head_seq_num = seq_inc(tid_agg_rx->head_seq_num);
+		ret = false;
+		goto out;
+	}
+
+	/* put the frame in the reordering buffer */
+	tid_agg_rx->reorder_buf[index] = skb;
+	tid_agg_rx->reorder_time[index] = jiffies;
+	tid_agg_rx->stored_mpdu_num++;
+	ieee80211_sta_reorder_release(hw, tid_agg_rx);
+
+ out:
+	spin_unlock(&tid_agg_rx->reorder_lock);
+	return ret;
+}
+
+/*
+ * Reorder MPDUs from A-MPDUs, keeping them on a buffer. Returns
+ * true if the MPDU was buffered, false if it should be processed.
+ */
+static void ieee80211_rx_reorder_ampdu(struct ieee80211_rx_data *rx)
+{
+	struct sk_buff *skb = rx->skb;
+	struct ieee80211_local *local = rx->local;
+	struct ieee80211_hw *hw = &local->hw;
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	struct sta_info *sta = rx->sta;
+	struct tid_ampdu_rx *tid_agg_rx;
+	u16 sc;
+	int tid;
+
+	if (!ieee80211_is_data_qos(hdr->frame_control))
+		goto dont_reorder;
+
+	/*
+	 * filter the QoS data rx stream according to
+	 * STA/TID and check if this STA/TID is on aggregation
+	 */
+
+	if (!sta)
+		goto dont_reorder;
+
+	tid = *ieee80211_get_qos_ctl(hdr) & IEEE80211_QOS_CTL_TID_MASK;
+
+	tid_agg_rx = rcu_dereference(sta->ampdu_mlme.tid_rx[tid]);
+	if (!tid_agg_rx)
+		goto dont_reorder;
+
+	/* qos null data frames are excluded */
+	if (unlikely(hdr->frame_control & cpu_to_le16(IEEE80211_STYPE_NULLFUNC)))
+		goto dont_reorder;
+
+	/* new, potentially un-ordered, ampdu frame - process it */
+
+	/* reset session timer */
+	if (tid_agg_rx->timeout)
+		mod_timer(&tid_agg_rx->session_timer,
+			  TU_TO_EXP_TIME(tid_agg_rx->timeout));
+
+	/* if this mpdu is fragmented - terminate rx aggregation session */
+	sc = le16_to_cpu(hdr->seq_ctrl);
+	if (sc & IEEE80211_SCTL_FRAG) {
+		skb->pkt_type = IEEE80211_SDATA_QUEUE_TYPE_FRAME;
+		skb_queue_tail(&rx->sdata->skb_queue, skb);
+		mac80211_queue_work(&local->hw, &rx->sdata->work);
+		return;
+	}
+
+	/*
+	 * No locking needed -- we will only ever process one
+	 * RX packet at a time, and thus own tid_agg_rx. All
+	 * other code manipulating it needs to (and does) make
+	 * sure that we cannot get to it any more before doing
+	 * anything with it.
+	 */
+	if (ieee80211_sta_manage_reorder_buf(hw, tid_agg_rx, skb))
+		return;
+
+ dont_reorder:
+	skb_queue_tail(&local->rx_skb_queue, skb);
+}
+
+static bool ieee80211_frame_eapol(u8 *data, int len)
+{
+	__le16 fc;
+	bool status = false;
+
+#define ETH_TYPE_OFFSET 30
+
+	fc = ((struct ieee80211_hdr *)data)->frame_control;
+	if ((ieee80211_is_data(fc)) && (len > 34)) {
+		u8 eapol_index = ETH_TYPE_OFFSET;
+		u16 ethertype;
+
+		if (ieee80211_is_data_qos(fc))
+			eapol_index = ETH_TYPE_OFFSET + 2;
+
+		ethertype = ((data[eapol_index] << 8) |
+				(data[eapol_index + 1]));
+		if (ethertype == ETH_P_PAE)
+			status = true;
+	}
+	return status;
+}
+
+static ieee80211_rx_result debug_noinline
+ieee80211_rx_h_check(struct ieee80211_rx_data *rx)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);
+
+	/* Drop duplicate 802.11 retransmissions (IEEE 802.11 Chap. 9.2.9) */
+	if (rx->sta && !is_multicast_ether_addr(hdr->addr1)) {
+		if (unlikely(ieee80211_has_retry(hdr->frame_control) &&
+			     rx->sta->last_seq_ctrl[rx->seqno_idx] ==
+			     hdr->seq_ctrl)) {
+			if (status->rx_flags & IEEE80211_RX_RA_MATCH) {
+				rx->local->dot11FrameDuplicateCount++;
+				rx->sta->num_duplicates++;
+			}
+			return RX_DROP_UNUSABLE;
+		} else
+			rx->sta->last_seq_ctrl[rx->seqno_idx] = hdr->seq_ctrl;
+	}
+
+	if (unlikely(rx->skb->len < 16)) {
+		I802_DEBUG_INC(rx->local->rx_handlers_drop_short);
+		return RX_DROP_MONITOR;
+	}
+
+	/* Drop disallowed frame classes based on STA auth/assoc state;
+	 * IEEE 802.11, Chap 5.5.
+	 *
+	 * mac80211 filters only based on association state, i.e. it drops
+	 * Class 3 frames from not associated stations. hostapd sends
+	 * deauth/disassoc frames when needed. In addition, hostapd is
+	 * responsible for filtering on both auth and assoc states.
+	 */
+
+	if (ieee80211_vif_is_mesh(&rx->sdata->vif))
+		return ieee80211_rx_mesh_check(rx);
+
+	if (unlikely((ieee80211_is_data(hdr->frame_control) ||
+		      ieee80211_is_pspoll(hdr->frame_control)) &&
+		     rx->sdata->vif.type != NL80211_IFTYPE_ADHOC &&
+		     rx->sdata->vif.type != NL80211_IFTYPE_WDS &&
+		     (!rx->sta || !test_sta_flag(rx->sta, WLAN_STA_ASSOC)))) {
+		if (rx->sta && rx->sta->dummy &&
+		    ieee80211_is_data_present(hdr->frame_control)) {
+			u16 ethertype;
+			u8 *payload;
+
+			payload = rx->skb->data +
+				ieee80211_hdrlen(hdr->frame_control);
+			ethertype = (payload[6] << 8) | payload[7];
+			if (cpu_to_be16(ethertype) ==
+			    rx->sdata->control_port_protocol)
+				return RX_CONTINUE;
+		}
+		if (!ieee80211_frame_eapol(rx->skb->data, rx->skb->len))
+			return RX_DROP_MONITOR;
+	}
+
+	return RX_CONTINUE;
+}
+
+
+static ieee80211_rx_result debug_noinline
+ieee80211_rx_h_decrypt(struct ieee80211_rx_data *rx)
+{
+	struct sk_buff *skb = rx->skb;
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+	int keyidx;
+	int hdrlen;
+	ieee80211_rx_result result = RX_DROP_UNUSABLE;
+	struct ieee80211_key *sta_ptk = NULL;
+	int mmie_keyidx = -1;
+	__le16 fc;
+
+	/*
+	 * Key selection 101
+	 *
+	 * There are four types of keys:
+	 *  - GTK (group keys)
+	 *  - IGTK (group keys for management frames)
+	 *  - PTK (pairwise keys)
+	 *  - STK (station-to-station pairwise keys)
+	 *
+	 * When selecting a key, we have to distinguish between multicast
+	 * (including broadcast) and unicast frames, the latter can only
+	 * use PTKs and STKs while the former always use GTKs and IGTKs.
+	 * Unless, of course, actual WEP keys ("pre-RSNA") are used, then
+	 * unicast frames can also use key indices like GTKs. Hence, if we
+	 * don't have a PTK/STK we check the key index for a WEP key.
+	 *
+	 * Note that in a regular BSS, multicast frames are sent by the
+	 * AP only, associated stations unicast the frame to the AP first
+	 * which then multicasts it on their behalf.
+	 *
+	 * There is also a slight problem in IBSS mode: GTKs are negotiated
+	 * with each station, that is something we don't currently handle.
+	 * The spec seems to expect that one negotiates the same key with
+	 * every station but there's no such requirement; VLANs could be
+	 * possible.
+	 */
+
+	/*
+	 * No point in finding a key and decrypting if the frame is neither
+	 * addressed to us nor a multicast frame.
+	 */
+	if (!(status->rx_flags & IEEE80211_RX_RA_MATCH))
+		return RX_CONTINUE;
+
+	/* start without a key */
+	rx->key = NULL;
+
+	if (rx->sta)
+		sta_ptk = rcu_dereference(rx->sta->ptk);
+
+	fc = hdr->frame_control;
+
+	if (!ieee80211_has_protected(fc))
+		mmie_keyidx = ieee80211_get_mmie_keyidx(rx->skb);
+
+	if (!is_multicast_ether_addr(hdr->addr1) && sta_ptk) {
+		rx->key = sta_ptk;
+		if ((status->flag & RX_FLAG_DECRYPTED) &&
+		    (status->flag & RX_FLAG_IV_STRIPPED))
+			return RX_CONTINUE;
+		/* Skip decryption if the frame is not protected. */
+		if (!ieee80211_has_protected(fc))
+			return RX_CONTINUE;
+	} else if (mmie_keyidx >= 0) {
+		/* Broadcast/multicast robust management frame / BIP */
+		if ((status->flag & RX_FLAG_DECRYPTED) &&
+		    (status->flag & RX_FLAG_IV_STRIPPED))
+			return RX_CONTINUE;
+
+		if (mmie_keyidx < NUM_DEFAULT_KEYS ||
+		    mmie_keyidx >= NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS)
+			return RX_DROP_MONITOR; /* unexpected BIP keyidx */
+		if (rx->sta)
+			rx->key = rcu_dereference(rx->sta->gtk[mmie_keyidx]);
+		if (!rx->key)
+			rx->key = rcu_dereference(rx->sdata->keys[mmie_keyidx]);
+	} else if (!ieee80211_has_protected(fc)) {
+		/*
+		 * The frame was not protected, so skip decryption. However, we
+		 * need to set rx->key if there is a key that could have been
+		 * used so that the frame may be dropped if encryption would
+		 * have been expected.
+		 */
+		struct ieee80211_key *key = NULL;
+		struct ieee80211_sub_if_data *sdata = rx->sdata;
+		int i;
+
+		key = rcu_dereference(rx->sdata->default_mgmt_key);
+		if (ieee80211_is_mgmt(fc) &&
+		    is_multicast_ether_addr(hdr->addr1) && key)
+			rx->key = key;
+		else {
+			if (rx->sta) {
+				for (i = 0; i < NUM_DEFAULT_KEYS; i++) {
+					key = rcu_dereference(rx->sta->gtk[i]);
+					if (key)
+						break;
+				}
+			}
+			if (!key) {
+				for (i = 0; i < NUM_DEFAULT_KEYS; i++) {
+					key = rcu_dereference(sdata->keys[i]);
+					if (key)
+						break;
+				}
+			}
+			if (key)
+				rx->key = key;
+		}
+		return RX_CONTINUE;
+	} else {
+		u8 keyid;
+		/*
+		 * The device doesn't give us the IV so we won't be
+		 * able to look up the key. That's ok though, we
+		 * don't need to decrypt the frame, we just won't
+		 * be able to keep statistics accurate.
+		 * Except for key threshold notifications, should
+		 * we somehow allow the driver to tell us which key
+		 * the hardware used if this flag is set?
+		 */
+		if ((status->flag & RX_FLAG_DECRYPTED) &&
+		    (status->flag & RX_FLAG_IV_STRIPPED))
+			return RX_CONTINUE;
+
+		hdrlen = ieee80211_hdrlen(fc);
+
+		if (rx->skb->len < 8 + hdrlen)
+			return RX_DROP_UNUSABLE; /* TODO: count this? */
+
+		/*
+		 * no need to call ieee80211_wep_get_keyidx,
+		 * it verifies a bunch of things we've done already
+		 */
+		skb_copy_bits(rx->skb, hdrlen + 3, &keyid, 1);
+		keyidx = keyid >> 6;
+
+		/* check per-station GTK first, if multicast packet */
+		if (is_multicast_ether_addr(hdr->addr1) && rx->sta)
+			rx->key = rcu_dereference(rx->sta->gtk[keyidx]);
+
+		/* if not found, try default key */
+		if (!rx->key) {
+			rx->key = rcu_dereference(rx->sdata->keys[keyidx]);
+
+			/*
+			 * RSNA-protected unicast frames should always be
+			 * sent with pairwise or station-to-station keys,
+			 * but for WEP we allow using a key index as well.
+			 */
+			if (rx->key &&
+			    rx->key->conf.cipher != WLAN_CIPHER_SUITE_WEP40 &&
+			    rx->key->conf.cipher != WLAN_CIPHER_SUITE_WEP104 &&
+			    !is_multicast_ether_addr(hdr->addr1))
+				rx->key = NULL;
+		}
+	}
+
+	if (rx->key) {
+		if (unlikely(rx->key->flags & KEY_FLAG_TAINTED))
+			return RX_DROP_MONITOR;
+
+		rx->key->tx_rx_count++;
+		/* TODO: add threshold stuff again */
+	} else {
+		return RX_DROP_MONITOR;
+	}
+
+	if (skb_linearize(rx->skb))
+		return RX_DROP_UNUSABLE;
+	/* the hdr variable is invalid now! */
+
+	switch (rx->key->conf.cipher) {
+	case WLAN_CIPHER_SUITE_WEP40:
+	case WLAN_CIPHER_SUITE_WEP104:
+		/* Check for weak IVs if possible */
+		if (rx->sta && ieee80211_is_data(fc) &&
+		    (!(status->flag & RX_FLAG_IV_STRIPPED) ||
+		     !(status->flag & RX_FLAG_DECRYPTED)) &&
+		    ieee80211_wep_is_weak_iv(rx->skb, rx->key))
+			rx->sta->wep_weak_iv_count++;
+
+		result = mac80211_crypto_wep_decrypt(rx);
+		break;
+	case WLAN_CIPHER_SUITE_TKIP:
+		result = mac80211_crypto_tkip_decrypt(rx);
+		break;
+	case WLAN_CIPHER_SUITE_CCMP:
+		result = mac80211_crypto_ccmp_decrypt(rx);
+		break;
+	case WLAN_CIPHER_SUITE_AES_CMAC:
+		result = mac80211_crypto_aes_cmac_decrypt(rx);
+		break;
+	case WLAN_CIPHER_SUITE_SMS4:
+		result = ieee80211_crypto_wapi_decrypt(rx);
+		break;
+	default:
+		/*
+		 * We can reach here only with HW-only algorithms
+		 * but why didn't it decrypt the frame?!
+		 */
+		return RX_DROP_UNUSABLE;
+	}
+
+	/* either the frame has been decrypted or will be dropped */
+	status->flag |= RX_FLAG_DECRYPTED;
+
+	return result;
+}
+
+static ieee80211_rx_result debug_noinline
+ieee80211_rx_h_check_more_data(struct ieee80211_rx_data *rx)
+{
+	struct ieee80211_local *local;
+	struct ieee80211_sub_if_data *sdata;
+	struct ieee80211_hdr *hdr;
+	struct sk_buff *skb;
+
+	local = rx->local;
+	sdata = rx->sdata;
+	skb = rx->skb;
+	hdr = (struct ieee80211_hdr *) skb->data;
+
+	if (!sdata->pspolling)
+		return RX_CONTINUE;
+
+	if (!ieee80211_has_fromds(hdr->frame_control))
+		/* this is not from AP */
+		return RX_CONTINUE;
+
+	if (!ieee80211_is_data(hdr->frame_control))
+		return RX_CONTINUE;
+
+	if (!ieee80211_has_moredata(hdr->frame_control)) {
+		/* AP has no more frames buffered for us */
+		sdata->pspolling = false;
+		return RX_CONTINUE;
+	}
+
+	/* more data bit is set, let's request a new frame from the AP */
+	mac80211_send_pspoll(local, rx->sdata);
+
+	return RX_CONTINUE;
+}
+
+static void ap_sta_ps_start(struct sta_info *sta)
+{
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
+	struct ieee80211_local *local = sdata->local;
+
+	atomic_inc(&sdata->bss->num_sta_ps);
+	set_sta_flag(sta, WLAN_STA_PS_STA);
+	if (!(local->hw.flags & IEEE80211_HW_AP_LINK_PS))
+		drv_sta_notify(local, sdata, STA_NOTIFY_SLEEP, &sta->sta);
+#ifdef CONFIG_XRMAC_VERBOSE_PS_DEBUG
+	printk(KERN_DEBUG "%s: STA %pM aid %d enters power save mode\n",
+	       sdata->name, sta->sta.addr, sta->sta.aid);
+#endif /* CONFIG_XRMAC_VERBOSE_PS_DEBUG */
+}
+
+static void ap_sta_ps_end(struct sta_info *sta)
+{
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
+
+	atomic_dec(&sdata->bss->num_sta_ps);
+
+#ifdef CONFIG_XRMAC_VERBOSE_PS_DEBUG
+	printk(KERN_DEBUG "%s: STA %pM aid %d exits power save mode\n",
+	       sdata->name, sta->sta.addr, sta->sta.aid);
+#endif /* CONFIG_XRMAC_VERBOSE_PS_DEBUG */
+
+	if (test_sta_flag(sta, WLAN_STA_PS_DRIVER)) {
+#ifdef CONFIG_XRMAC_VERBOSE_PS_DEBUG
+		printk(KERN_DEBUG "%s: STA %pM aid %d driver-ps-blocked\n",
+		       sdata->name, sta->sta.addr, sta->sta.aid);
+#endif /* CONFIG_XRMAC_VERBOSE_PS_DEBUG */
+		return;
+	}
+
+	mac80211_sta_ps_deliver_wakeup(sta);
+}
+
+int mac80211_sta_ps_transition(struct ieee80211_sta *sta, bool start)
+{
+	struct sta_info *sta_inf = container_of(sta, struct sta_info, sta);
+	bool in_ps;
+#if 0
+	WARN_ON(!(sta_inf->local->hw.flags & IEEE80211_HW_AP_LINK_PS));
+#endif
+
+	/* Don't let the same PS state be set twice */
+	in_ps = test_sta_flag(sta_inf, WLAN_STA_PS_STA);
+	if ((start && in_ps) || (!start && !in_ps))
+		return -EINVAL;
+
+	if (start)
+		ap_sta_ps_start(sta_inf);
+	else
+		ap_sta_ps_end(sta_inf);
+
+	return 0;
+}
+
+static ieee80211_rx_result debug_noinline
+ieee80211_rx_h_uapsd_and_pspoll(struct ieee80211_rx_data *rx)
+{
+	struct ieee80211_sub_if_data *sdata = rx->sdata;
+	struct ieee80211_hdr *hdr = (void *)rx->skb->data;
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);
+	int tid, ac;
+
+	if (!rx->sta || !(status->rx_flags & IEEE80211_RX_RA_MATCH))
+		return RX_CONTINUE;
+
+	if (sdata->vif.type != NL80211_IFTYPE_AP &&
+	    sdata->vif.type != NL80211_IFTYPE_AP_VLAN)
+		return RX_CONTINUE;
+
+	/*
+	 * The device handles station powersave, so don't do anything about
+	 * uAPSD and PS-Poll frames (the latter shouldn't even come up from
+	 * it to mac80211 since they're handled.)
+	 */
+	if (sdata->local->hw.flags & IEEE80211_HW_AP_LINK_PS)
+		return RX_CONTINUE;
+
+	/*
+	 * Don't do anything if the station isn't already asleep. In
+	 * the uAPSD case, the station will probably be marked asleep,
+	 * in the PS-Poll case the station must be confused ...
+	 */
+	if (!test_sta_flag(rx->sta, WLAN_STA_PS_STA))
+		return RX_CONTINUE;
+
+	if (unlikely(ieee80211_is_pspoll(hdr->frame_control))) {
+		if (!test_sta_flag(rx->sta, WLAN_STA_SP)) {
+			if (!test_sta_flag(rx->sta, WLAN_STA_PS_DRIVER))
+				mac80211_sta_ps_deliver_poll_response(rx->sta);
+			else
+				set_sta_flag(rx->sta, WLAN_STA_PSPOLL);
+		}
+
+		/* Free PS Poll skb here instead of returning RX_DROP that would
+		 * count as an dropped frame. */
+		dev_kfree_skb(rx->skb);
+
+		return RX_QUEUED;
+	} else if (!ieee80211_has_morefrags(hdr->frame_control) &&
+		   !(status->rx_flags & IEEE80211_RX_DEFERRED_RELEASE) &&
+		   ieee80211_has_pm(hdr->frame_control) &&
+		   (ieee80211_is_data_qos(hdr->frame_control) ||
+		    ieee80211_is_qos_nullfunc(hdr->frame_control))) {
+		tid = *ieee80211_get_qos_ctl(hdr) & IEEE80211_QOS_CTL_TID_MASK;
+		ac = mac802_1d_to_ac[tid & 7];
+
+		/*
+		 * If this AC is not trigger-enabled do nothing.
+		 *
+		 * NB: This could/should check a separate bitmap of trigger-
+		 * enabled queues, but for now we only implement uAPSD w/o
+		 * TSPEC changes to the ACs, so they're always the same.
+		 */
+		if (!(rx->sta->sta.uapsd_queues & BIT(ac)))
+			return RX_CONTINUE;
+
+		/* if we are in a service period, do nothing */
+		if (test_sta_flag(rx->sta, WLAN_STA_SP))
+			return RX_CONTINUE;
+
+		if (!test_sta_flag(rx->sta, WLAN_STA_PS_DRIVER))
+			mac80211_sta_ps_deliver_uapsd(rx->sta);
+		else
+			set_sta_flag(rx->sta, WLAN_STA_UAPSD);
+	}
+
+	return RX_CONTINUE;
+}
+
+static ieee80211_rx_result debug_noinline
+ieee80211_rx_h_sta_process(struct ieee80211_rx_data *rx)
+{
+	struct sta_info *sta = rx->sta;
+	struct sk_buff *skb = rx->skb;
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+
+	if (!sta)
+		return RX_CONTINUE;
+
+	/*
+	 * Update last_rx only for IBSS packets which are for the current
+	 * BSSID to avoid keeping the current IBSS network alive in cases
+	 * where other STAs start using different BSSID.
+	 */
+	if (rx->sdata->vif.type == NL80211_IFTYPE_ADHOC) {
+		u8 *bssid = mac80211_get_bssid(hdr, rx->skb->len,
+						NL80211_IFTYPE_ADHOC);
+		if (compare_ether_addr(bssid, rx->sdata->u.ibss.bssid) == 0) {
+			sta->last_rx = jiffies;
+			if (ieee80211_is_data(hdr->frame_control)) {
+				sta->last_rx_rate_idx = status->rate_idx;
+				sta->last_rx_rate_flag = status->flag;
+			}
+		}
+	} else if (!is_multicast_ether_addr(hdr->addr1)) {
+		/*
+		 * Mesh beacons will update last_rx when if they are found to
+		 * match the current local configuration when processed.
+		 */
+		sta->last_rx = jiffies;
+		if (ieee80211_is_data(hdr->frame_control)) {
+			sta->last_rx_rate_idx = status->rate_idx;
+			sta->last_rx_rate_flag = status->flag;
+		}
+	}
+
+	if (!(status->rx_flags & IEEE80211_RX_RA_MATCH))
+		return RX_CONTINUE;
+
+	if (rx->sdata->vif.type == NL80211_IFTYPE_STATION)
+		mac80211_sta_rx_notify(rx->sdata, hdr);
+
+	sta->rx_fragments++;
+	sta->rx_bytes += rx->skb->len;
+	sta->last_signal = status->signal;
+	ewma_add(&sta->avg_signal, -status->signal);
+
+	/*
+	 * Change STA power saving mode only at the end of a frame
+	 * exchange sequence.
+	 */
+	if (!(sta->local->hw.flags & IEEE80211_HW_AP_LINK_PS) &&
+	    !ieee80211_has_morefrags(hdr->frame_control) &&
+	    !(status->rx_flags & IEEE80211_RX_DEFERRED_RELEASE) &&
+	    (rx->sdata->vif.type == NL80211_IFTYPE_AP ||
+	     rx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN)) {
+		if (test_sta_flag(sta, WLAN_STA_PS_STA)) {
+			/*
+			 * Ignore doze->wake transitions that are
+			 * indicated by non-data frames, the standard
+			 * is unclear here, but for example going to
+			 * PS mode and then scanning would cause a
+			 * doze->wake transition for the probe request,
+			 * and that is clearly undesirable.
+			 */
+			if (ieee80211_is_data(hdr->frame_control) &&
+			    !ieee80211_has_pm(hdr->frame_control))
+				ap_sta_ps_end(sta);
+		} else {
+			if (ieee80211_has_pm(hdr->frame_control))
+				ap_sta_ps_start(sta);
+		}
+	}
+
+	/*
+	 * Drop (qos-)data::nullfunc frames silently, since they
+	 * are used only to control station power saving mode.
+	 */
+	if (ieee80211_is_nullfunc(hdr->frame_control) ||
+	    ieee80211_is_qos_nullfunc(hdr->frame_control)) {
+		I802_DEBUG_INC(rx->local->rx_handlers_drop_nullfunc);
+
+		/*
+		 * If we receive a 4-addr nullfunc frame from a STA
+		 * that was not moved to a 4-addr STA vlan yet, drop
+		 * the frame to the monitor interface, to make sure
+		 * that hostapd sees it
+		 */
+		if (ieee80211_has_a4(hdr->frame_control) &&
+		    (rx->sdata->vif.type == NL80211_IFTYPE_AP ||
+		     (rx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&
+		      !rx->sdata->u.vlan.sta)))
+			return RX_DROP_MONITOR;
+		/*
+		 * Update counter and free packet here to avoid
+		 * counting this as a dropped packed.
+		 */
+		sta->rx_packets++;
+		dev_kfree_skb(rx->skb);
+		return RX_QUEUED;
+	}
+
+	return RX_CONTINUE;
+} /* ieee80211_rx_h_sta_process */
+
+static inline struct ieee80211_fragment_entry *
+ieee80211_reassemble_add(struct ieee80211_sub_if_data *sdata,
+			 unsigned int frag, unsigned int seq, int rx_queue,
+			 struct sk_buff **skb)
+{
+	struct ieee80211_fragment_entry *entry;
+	int idx;
+
+	idx = sdata->fragment_next;
+	entry = &sdata->fragments[sdata->fragment_next++];
+	if (sdata->fragment_next >= IEEE80211_FRAGMENT_MAX)
+		sdata->fragment_next = 0;
+
+	if (!skb_queue_empty(&entry->skb_list)) {
+#ifdef CONFIG_XRMAC_VERBOSE_DEBUG
+		struct ieee80211_hdr *hdr =
+			(struct ieee80211_hdr *) entry->skb_list.next->data;
+		printk(KERN_DEBUG "%s: RX reassembly removed oldest "
+		       "fragment entry (idx=%d age=%lu seq=%d last_frag=%d "
+		       "addr1=%pM addr2=%pM\n",
+		       sdata->name, idx,
+		       jiffies - entry->first_frag_time, entry->seq,
+		       entry->last_frag, hdr->addr1, hdr->addr2);
+#endif
+		__skb_queue_purge(&entry->skb_list);
+	}
+
+	__skb_queue_tail(&entry->skb_list, *skb); /* no need for locking */
+	*skb = NULL;
+	entry->first_frag_time = jiffies;
+	entry->seq = seq;
+	entry->rx_queue = rx_queue;
+	entry->last_frag = frag;
+	entry->ccmp = 0;
+	entry->extra_len = 0;
+
+	return entry;
+}
+
+static inline struct ieee80211_fragment_entry *
+ieee80211_reassemble_find(struct ieee80211_sub_if_data *sdata,
+			  unsigned int frag, unsigned int seq,
+			  int rx_queue, struct ieee80211_hdr *hdr)
+{
+	struct ieee80211_fragment_entry *entry;
+	int i, idx;
+
+	idx = sdata->fragment_next;
+	for (i = 0; i < IEEE80211_FRAGMENT_MAX; i++) {
+		struct ieee80211_hdr *f_hdr;
+
+		idx--;
+		if (idx < 0)
+			idx = IEEE80211_FRAGMENT_MAX - 1;
+
+		entry = &sdata->fragments[idx];
+		if (skb_queue_empty(&entry->skb_list) || entry->seq != seq ||
+		    entry->rx_queue != rx_queue ||
+		    entry->last_frag + 1 != frag)
+			continue;
+
+		f_hdr = (struct ieee80211_hdr *)entry->skb_list.next->data;
+
+		/*
+		 * Check ftype and addresses are equal, else check next fragment
+		 */
+		if (((hdr->frame_control ^ f_hdr->frame_control) &
+		     cpu_to_le16(IEEE80211_FCTL_FTYPE)) ||
+		    compare_ether_addr(hdr->addr1, f_hdr->addr1) != 0 ||
+		    compare_ether_addr(hdr->addr2, f_hdr->addr2) != 0)
+			continue;
+
+		if (time_after(jiffies, entry->first_frag_time + 2 * HZ)) {
+			__skb_queue_purge(&entry->skb_list);
+			continue;
+		}
+		return entry;
+	}
+
+	return NULL;
+}
+
+static ieee80211_rx_result debug_noinline
+ieee80211_rx_h_defragment(struct ieee80211_rx_data *rx)
+{
+	struct ieee80211_hdr *hdr;
+	u16 sc;
+	__le16 fc;
+	unsigned int frag, seq;
+	struct ieee80211_fragment_entry *entry;
+	struct sk_buff *skb;
+	struct ieee80211_rx_status *status;
+
+	hdr = (struct ieee80211_hdr *)rx->skb->data;
+	fc = hdr->frame_control;
+	sc = le16_to_cpu(hdr->seq_ctrl);
+	frag = sc & IEEE80211_SCTL_FRAG;
+
+	if (likely((!ieee80211_has_morefrags(fc) && frag == 0) ||
+		   (rx->skb)->len < 24 ||
+		   is_multicast_ether_addr(hdr->addr1))) {
+		/* not fragmented */
+		goto out;
+	}
+	I802_DEBUG_INC(rx->local->rx_handlers_fragments);
+
+	if (skb_linearize(rx->skb))
+		return RX_DROP_UNUSABLE;
+
+	/*
+	 *  skb_linearize() might change the skb->data and
+	 *  previously cached variables (in this case, hdr) need to
+	 *  be refreshed with the new data.
+	 */
+	hdr = (struct ieee80211_hdr *)rx->skb->data;
+	seq = (sc & IEEE80211_SCTL_SEQ) >> 4;
+
+	if (frag == 0) {
+		/* This is the first fragment of a new frame. */
+		entry = ieee80211_reassemble_add(rx->sdata, frag, seq,
+						 rx->seqno_idx, &(rx->skb));
+		if (rx->key && rx->key->conf.cipher == WLAN_CIPHER_SUITE_CCMP &&
+		    ieee80211_has_protected(fc)) {
+			int queue = rx->security_idx;
+			/* Store CCMP PN so that we can verify that the next
+			 * fragment has a sequential PN value. */
+			entry->ccmp = 1;
+			memcpy(entry->last_pn,
+			       rx->key->u.ccmp.rx_pn[queue],
+			       CCMP_PN_LEN);
+		}
+		return RX_QUEUED;
+	}
+
+	/* This is a fragment for a frame that should already be pending in
+	 * fragment cache. Add this fragment to the end of the pending entry.
+	 */
+	entry = ieee80211_reassemble_find(rx->sdata, frag, seq,
+					  rx->seqno_idx, hdr);
+	if (!entry) {
+		I802_DEBUG_INC(rx->local->rx_handlers_drop_defrag);
+		return RX_DROP_MONITOR;
+	}
+
+	/* Verify that MPDUs within one MSDU have sequential PN values.
+	 * (IEEE 802.11i, 8.3.3.4.5) */
+	if (entry->ccmp) {
+		int i;
+		u8 pn[CCMP_PN_LEN], *rpn;
+		int queue;
+		if (!rx->key || rx->key->conf.cipher != WLAN_CIPHER_SUITE_CCMP)
+			return RX_DROP_UNUSABLE;
+		memcpy(pn, entry->last_pn, CCMP_PN_LEN);
+		for (i = CCMP_PN_LEN - 1; i >= 0; i--) {
+			pn[i]++;
+			if (pn[i])
+				break;
+		}
+		queue = rx->security_idx;
+		rpn = rx->key->u.ccmp.rx_pn[queue];
+		if (memcmp(pn, rpn, CCMP_PN_LEN))
+			return RX_DROP_UNUSABLE;
+		memcpy(entry->last_pn, pn, CCMP_PN_LEN);
+	}
+
+	skb_pull(rx->skb, ieee80211_hdrlen(fc));
+	__skb_queue_tail(&entry->skb_list, rx->skb);
+	entry->last_frag = frag;
+	entry->extra_len += rx->skb->len;
+	if (ieee80211_has_morefrags(fc)) {
+		rx->skb = NULL;
+		return RX_QUEUED;
+	}
+
+	rx->skb = __skb_dequeue(&entry->skb_list);
+	if (skb_tailroom(rx->skb) < entry->extra_len) {
+		I802_DEBUG_INC(rx->local->rx_expand_skb_head2);
+		if (unlikely(pskb_expand_head(rx->skb, 0, entry->extra_len,
+					      GFP_ATOMIC))) {
+			I802_DEBUG_INC(rx->local->rx_handlers_drop_defrag);
+			__skb_queue_purge(&entry->skb_list);
+			return RX_DROP_UNUSABLE;
+		}
+	}
+	while ((skb = __skb_dequeue(&entry->skb_list))) {
+		memcpy(skb_put(rx->skb, skb->len), skb->data, skb->len);
+		dev_kfree_skb(skb);
+	}
+
+	/* Complete frame has been reassembled - process it now */
+	status = IEEE80211_SKB_RXCB(rx->skb);
+	status->rx_flags |= IEEE80211_RX_FRAGMENTED;
+
+ out:
+	if (rx->sta)
+		rx->sta->rx_packets++;
+	if (is_multicast_ether_addr(hdr->addr1))
+		rx->local->dot11MulticastReceivedFrameCount++;
+	else
+		ieee80211_led_rx(rx->local);
+	return RX_CONTINUE;
+}
+
+static ieee80211_rx_result debug_noinline
+ieee80211_rx_h_remove_qos_control(struct ieee80211_rx_data *rx)
+{
+	u8 *data = rx->skb->data;
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)data;
+
+	if (!ieee80211_is_data_qos(hdr->frame_control))
+		return RX_CONTINUE;
+
+	/* remove the qos control field, update frame type and meta-data */
+	memmove(data + IEEE80211_QOS_CTL_LEN, data,
+		ieee80211_hdrlen(hdr->frame_control) - IEEE80211_QOS_CTL_LEN);
+	hdr = (struct ieee80211_hdr *)skb_pull(rx->skb, IEEE80211_QOS_CTL_LEN);
+	/* change frame type to non QOS */
+	hdr->frame_control &= ~cpu_to_le16(IEEE80211_STYPE_QOS_DATA);
+
+	return RX_CONTINUE;
+}
+
+static int
+ieee80211_802_1x_port_control(struct ieee80211_rx_data *rx)
+{
+	if (unlikely(!rx->sta ||
+	    !test_sta_flag(rx->sta, WLAN_STA_AUTHORIZED)))
+		return -EACCES;
+
+	return 0;
+}
+
+static int
+ieee80211_drop_unencrypted(struct ieee80211_rx_data *rx, __le16 fc)
+{
+	struct sk_buff *skb = rx->skb;
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
+
+	/*
+	 * Pass through unencrypted frames if the hardware has
+	 * decrypted them already.
+	 */
+	if (status->flag & RX_FLAG_DECRYPTED)
+		return 0;
+
+	/* Drop unencrypted frames if key is set. */
+	if (unlikely(!ieee80211_has_protected(fc) &&
+		     !ieee80211_is_nullfunc(fc) &&
+		     ieee80211_is_data(fc) &&
+		     (rx->key || rx->sdata->drop_unencrypted)))
+		return -EACCES;
+
+	return 0;
+}
+
+static int
+ieee80211_drop_unencrypted_mgmt(struct ieee80211_rx_data *rx)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);
+	__le16 fc = hdr->frame_control;
+
+	/*
+	 * Pass through unencrypted frames if the hardware has
+	 * decrypted them already.
+	 */
+	if (status->flag & RX_FLAG_DECRYPTED)
+		return 0;
+
+	if (rx->sta && test_sta_flag(rx->sta, WLAN_STA_MFP)) {
+		if (unlikely(!ieee80211_has_protected(fc) &&
+			     ieee80211_is_unicast_robust_mgmt_frame(rx->skb) &&
+			     rx->key)) {
+			if (ieee80211_is_deauth(fc) ||
+			    ieee80211_is_disassoc(fc))
+				cfg80211_rx_unprot_mlme_mgmt(rx->sdata->dev,
+							     rx->skb->data,
+							     rx->skb->len);
+			return -EACCES;
+		}
+		/* BIP does not use Protected field, so need to check MMIE */
+		if (unlikely(ieee80211_is_multicast_robust_mgmt_frame(rx->skb) &&
+			     ieee80211_get_mmie_keyidx(rx->skb) < 0)) {
+			if (ieee80211_is_deauth(fc) ||
+			    ieee80211_is_disassoc(fc))
+				cfg80211_rx_unprot_mlme_mgmt(rx->sdata->dev,
+							     rx->skb->data,
+							     rx->skb->len);
+			return -EACCES;
+		}
+		/*
+		 * When using MFP, Action frames are not allowed prior to
+		 * having configured keys.
+		 */
+		if (unlikely(ieee80211_is_action(fc) && !rx->key &&
+			     ieee80211_is_robust_mgmt_frame(rx->skb)))
+			return -EACCES;
+	}
+
+	return 0;
+}
+
+static int
+__ieee80211_data_to_8023(struct ieee80211_rx_data *rx, bool *port_control)
+{
+	struct ieee80211_sub_if_data *sdata = rx->sdata;
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;
+	bool check_port_control = false;
+	struct ethhdr *ehdr;
+	int ret;
+
+	*port_control = false;
+	if (ieee80211_has_a4(hdr->frame_control) &&
+	    sdata->vif.type == NL80211_IFTYPE_AP_VLAN && !sdata->u.vlan.sta)
+		return -1;
+
+	if (sdata->vif.type == NL80211_IFTYPE_STATION &&
+	    !!sdata->u.mgd.use_4addr != !!ieee80211_has_a4(hdr->frame_control)) {
+
+		if (!sdata->u.mgd.use_4addr)
+			return -1;
+		else
+			check_port_control = true;
+	}
+
+	if (is_multicast_ether_addr(hdr->addr1) &&
+	    sdata->vif.type == NL80211_IFTYPE_AP_VLAN && sdata->u.vlan.sta)
+		return -1;
+
+	ret = ieee80211_data_to_8023(rx->skb, sdata->vif.addr, sdata->vif.type);
+	if (ret < 0)
+		return ret;
+
+	ehdr = (struct ethhdr *) rx->skb->data;
+	if (ehdr->h_proto == rx->sdata->control_port_protocol)
+		*port_control = true;
+	else if (check_port_control)
+		return -1;
+
+	return 0;
+}
+
+/*
+ * requires that rx->skb is a frame with ethernet header
+ */
+static bool ieee80211_frame_allowed(struct ieee80211_rx_data *rx, __le16 fc)
+{
+	static const u8 pae_group_addr[ETH_ALEN] __aligned(2)
+		= { 0x01, 0x80, 0xC2, 0x00, 0x00, 0x03 };
+	struct ethhdr *ehdr = (struct ethhdr *) rx->skb->data;
+
+	/*
+	 * Allow EAPOL frames to us/the PAE group address regardless
+	 * of whether the frame was encrypted or not.
+	 */
+	if (ehdr->h_proto == rx->sdata->control_port_protocol &&
+	    (compare_ether_addr(ehdr->h_dest, rx->sdata->vif.addr) == 0 ||
+	     compare_ether_addr(ehdr->h_dest, pae_group_addr) == 0))
+		return true;
+
+	if (ieee80211_802_1x_port_control(rx) ||
+	    ieee80211_drop_unencrypted(rx, fc))
+		return false;
+
+	return true;
+}
+
+/*
+ * requires that rx->skb is a frame with ethernet header
+ */
+static void
+ieee80211_deliver_skb(struct ieee80211_rx_data *rx)
+{
+	struct ieee80211_sub_if_data *sdata = rx->sdata;
+	struct net_device *dev = sdata->dev;
+	struct sk_buff *skb, *xmit_skb;
+	struct ethhdr *ehdr = (struct ethhdr *) rx->skb->data;
+	struct sta_info *dsta;
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);
+
+	skb = rx->skb;
+	xmit_skb = NULL;
+
+	if ((sdata->vif.type == NL80211_IFTYPE_AP ||
+	     sdata->vif.type == NL80211_IFTYPE_AP_VLAN) &&
+	    !(sdata->flags & IEEE80211_SDATA_DONT_BRIDGE_PACKETS) &&
+	    (status->rx_flags & IEEE80211_RX_RA_MATCH) &&
+	    (sdata->vif.type != NL80211_IFTYPE_AP_VLAN || !sdata->u.vlan.sta)) {
+		if (is_multicast_ether_addr(ehdr->h_dest)) {
+			/*
+			 * send multicast frames both to higher layers in
+			 * local net stack and back to the wireless medium
+			 */
+			xmit_skb = skb_copy(skb, GFP_ATOMIC);
+			if (!xmit_skb && net_ratelimit())
+				printk(KERN_DEBUG "%s: failed to clone "
+				       "multicast frame\n", dev->name);
+		} else {
+			dsta = xrmac_sta_info_get(sdata, skb->data);
+			if (dsta) {
+				/*
+				 * The destination station is associated to
+				 * this AP (in this VLAN), so send the frame
+				 * directly to it and do not pass it to local
+				 * net stack.
+				 */
+				xmit_skb = skb;
+				skb = NULL;
+			}
+		}
+	}
+
+	if (skb) {
+		int align __maybe_unused;
+
+#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS
+		/*
+		 * 'align' will only take the values 0 or 2 here
+		 * since all frames are required to be aligned
+		 * to 2-byte boundaries when being passed to
+		 * mac80211. That also explains the __skb_push()
+		 * below.
+		 */
+		align = ((unsigned long)(skb->data + sizeof(struct ethhdr))) & 3;
+		if (align) {
+			if (WARN_ON(skb_headroom(skb) < 3)) {
+				dev_kfree_skb(skb);
+				skb = NULL;
+			} else {
+				u8 *data = skb->data;
+				size_t len = skb_headlen(skb);
+				skb->data -= align;
+				memmove(skb->data, data, len);
+				skb_set_tail_pointer(skb, len);
+			}
+		}
+#endif
+
+		if (skb) {
+			/* deliver to local stack */
+			skb->protocol = eth_type_trans(skb, dev);
+			memset(skb->cb, 0, sizeof(skb->cb));
+			netif_receive_skb(skb);
+		}
+	}
+
+	if (xmit_skb) {
+		/* send to wireless media */
+		xmit_skb->protocol = htons(ETH_P_802_3);
+		skb_reset_network_header(xmit_skb);
+		skb_reset_mac_header(xmit_skb);
+		dev_queue_xmit(xmit_skb);
+	}
+}
+#if 0
+static ieee80211_rx_result debug_noinline
+ieee80211_rx_h_amsdu(struct ieee80211_rx_data *rx)
+{
+	struct net_device *dev = rx->sdata->dev;
+	struct sk_buff *skb = rx->skb;
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+	__le16 fc = hdr->frame_control;
+	struct sk_buff_head frame_list;
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);
+
+	if (unlikely(!ieee80211_is_data(fc)))
+		return RX_CONTINUE;
+
+	if (unlikely(!ieee80211_is_data_present(fc)))
+		return RX_DROP_MONITOR;
+
+	if (!(status->rx_flags & IEEE80211_RX_AMSDU))
+		return RX_CONTINUE;
+
+	if (ieee80211_has_a4(hdr->frame_control) &&
+	    rx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&
+	    !rx->sdata->u.vlan.sta)
+		return RX_DROP_UNUSABLE;
+
+	if (is_multicast_ether_addr(hdr->addr1) &&
+	    ((rx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&
+	      rx->sdata->u.vlan.sta) ||
+	     (rx->sdata->vif.type == NL80211_IFTYPE_STATION &&
+	      rx->sdata->u.mgd.use_4addr)))
+		return RX_DROP_UNUSABLE;
+
+	skb->dev = dev;
+	__skb_queue_head_init(&frame_list);
+
+	if (skb_linearize(skb))
+		return RX_DROP_UNUSABLE;
+
+	ieee80211_amsdu_to_8023s(skb, &frame_list, dev->dev_addr,
+				 rx->sdata->vif.type,
+				 rx->local->hw.extra_tx_headroom, true);
+
+	while (!skb_queue_empty(&frame_list)) {
+		rx->skb = __skb_dequeue(&frame_list);
+
+		if (!ieee80211_frame_allowed(rx, fc)) {
+			dev_kfree_skb(rx->skb);
+			continue;
+		}
+		dev->stats.rx_packets++;
+		dev->stats.rx_bytes += rx->skb->len;
+
+		ieee80211_deliver_skb(rx);
+	}
+
+	return RX_QUEUED;
+}
+#endif
+
+
+static ieee80211_rx_result debug_noinline
+ieee80211_rx_h_amsdu(struct ieee80211_rx_data *rx)
+{
+	struct net_device *dev = rx->sdata->dev;
+	struct sk_buff *skb = rx->skb;
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+	__le16 fc = hdr->frame_control;
+	struct sk_buff_head frame_list;
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);
+	struct ethhdr ethhdr;
+	const u8 *check_da = ethhdr.h_dest, *check_sa = ethhdr.h_source;
+
+	if (unlikely(!ieee80211_is_data(fc)))
+		return RX_CONTINUE;
+
+	if (unlikely(!ieee80211_is_data_present(fc)))
+		return RX_DROP_MONITOR;
+
+	if (!(status->rx_flags & IEEE80211_RX_AMSDU))
+		return RX_CONTINUE;
+
+	if (unlikely(ieee80211_has_a4(hdr->frame_control))) {
+		switch (rx->sdata->vif.type) {
+		case NL80211_IFTYPE_AP_VLAN:
+			if (!rx->sdata->u.vlan.sta)
+				return RX_DROP_UNUSABLE;
+			break;
+		case NL80211_IFTYPE_STATION:
+			if (!rx->sdata->u.mgd.use_4addr)
+				return RX_DROP_UNUSABLE;
+			break;
+		default:
+			return RX_DROP_UNUSABLE;
+		}
+		check_da = NULL;
+		check_sa = NULL;
+	} else {
+		switch (rx->sdata->vif.type) {
+		case NL80211_IFTYPE_AP:
+		case NL80211_IFTYPE_AP_VLAN:
+			check_da = NULL;
+			break;
+		case NL80211_IFTYPE_STATION:
+			if (!rx->sta ||
+			    !test_sta_flag(rx->sta, WLAN_STA_TDLS_PEER))
+				check_sa = NULL;
+			break;
+		case NL80211_IFTYPE_MESH_POINT:
+			check_sa = NULL;
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (is_multicast_ether_addr(hdr->addr1))
+		return RX_DROP_UNUSABLE;
+
+	skb->dev = dev;
+	__skb_queue_head_init(&frame_list);
+
+	if (ieee80211_data_to_8023_exthdr(skb, &ethhdr,
+					  rx->sdata->vif.addr,
+					  rx->sdata->vif.type,
+					  0))
+		return RX_DROP_UNUSABLE;
+
+	ieee80211_amsdu_to_8023s(skb, &frame_list, dev->dev_addr,
+				 rx->sdata->vif.type,
+				 rx->local->hw.extra_tx_headroom,
+				 check_da, check_sa);
+
+	while (!skb_queue_empty(&frame_list)) {
+		rx->skb = __skb_dequeue(&frame_list);
+
+		if (!ieee80211_frame_allowed(rx, fc)) {
+			dev_kfree_skb(rx->skb);
+			continue;
+		}
+
+		ieee80211_deliver_skb(rx);
+	}
+
+	return RX_QUEUED;
+}
+
+
+
+#ifdef CONFIG_XRMAC_MESH
+static ieee80211_rx_result
+ieee80211_rx_h_mesh_fwding(struct ieee80211_rx_data *rx)
+{
+	struct ieee80211_hdr *hdr;
+	struct ieee80211s_hdr *mesh_hdr;
+	unsigned int hdrlen;
+	struct sk_buff *skb = rx->skb, *fwd_skb;
+	struct ieee80211_local *local = rx->local;
+	struct ieee80211_sub_if_data *sdata = rx->sdata;
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
+
+	hdr = (struct ieee80211_hdr *) skb->data;
+	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	mesh_hdr = (struct ieee80211s_hdr *) (skb->data + hdrlen);
+
+	/* frame is in RMC, don't forward */
+	if (ieee80211_is_data(hdr->frame_control) &&
+	    is_multicast_ether_addr(hdr->addr1) &&
+	    xrmac_mesh_rmc_check(hdr->addr3, mesh_hdr, rx->sdata))
+		return RX_DROP_MONITOR;
+
+	if (!ieee80211_is_data(hdr->frame_control))
+		return RX_CONTINUE;
+
+	if (!mesh_hdr->ttl)
+		/* illegal frame */
+		return RX_DROP_MONITOR;
+
+	if (mac80211_queue_stopped(&local->hw, skb_get_queue_mapping(skb))) {
+		IEEE80211_IFSTA_MESH_CTR_INC(&sdata->u.mesh,
+						dropped_frames_congestion);
+		return RX_DROP_MONITOR;
+	}
+
+	if (mesh_hdr->flags & MESH_FLAGS_AE) {
+		struct mesh_path *mppath;
+		char *proxied_addr;
+		char *mpp_addr;
+
+		if (is_multicast_ether_addr(hdr->addr1)) {
+			mpp_addr = hdr->addr3;
+			proxied_addr = mesh_hdr->eaddr1;
+		} else {
+			mpp_addr = hdr->addr4;
+			proxied_addr = mesh_hdr->eaddr2;
+		}
+
+		rcu_read_lock();
+		mppath = xrmac_mpp_path_lookup(proxied_addr, sdata);
+		if (!mppath) {
+			xrmac_mpp_path_add(proxied_addr, mpp_addr, sdata);
+		} else {
+			spin_lock_bh(&mppath->state_lock);
+			if (compare_ether_addr(mppath->mpp, mpp_addr) != 0)
+				memcpy(mppath->mpp, mpp_addr, ETH_ALEN);
+			spin_unlock_bh(&mppath->state_lock);
+		}
+		rcu_read_unlock();
+	}
+
+	/* Frame has reached destination.  Don't forward */
+	if (!is_multicast_ether_addr(hdr->addr1) &&
+	    compare_ether_addr(sdata->vif.addr, hdr->addr3) == 0)
+		return RX_CONTINUE;
+
+	mesh_hdr->ttl--;
+
+	if (status->rx_flags & IEEE80211_RX_RA_MATCH) {
+		if (!mesh_hdr->ttl)
+			IEEE80211_IFSTA_MESH_CTR_INC(&rx->sdata->u.mesh,
+						     dropped_frames_ttl);
+		else {
+			struct ieee80211_hdr *fwd_hdr;
+			struct ieee80211_tx_info *info;
+
+			fwd_skb = skb_copy(skb, GFP_ATOMIC);
+
+			if (!fwd_skb && net_ratelimit())
+				printk(KERN_DEBUG "%s: failed to clone mesh frame\n",
+						   sdata->name);
+			if (!fwd_skb)
+				goto out;
+
+			fwd_hdr =  (struct ieee80211_hdr *) fwd_skb->data;
+			memcpy(fwd_hdr->addr2, sdata->vif.addr, ETH_ALEN);
+			info = IEEE80211_SKB_CB(fwd_skb);
+			memset(info, 0, sizeof(*info));
+			info->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING;
+			info->control.vif = &rx->sdata->vif;
+			if (is_multicast_ether_addr(fwd_hdr->addr1)) {
+				IEEE80211_IFSTA_MESH_CTR_INC(&sdata->u.mesh,
+								fwded_mcast);
+				skb_set_queue_mapping(fwd_skb,
+					mac80211_select_queue(sdata, fwd_skb));
+				mac80211_set_qos_hdr(sdata, fwd_skb);
+			} else {
+				int err;
+				/*
+				 * Save TA to addr1 to send TA a path error if a
+				 * suitable next hop is not found
+				 */
+				memcpy(fwd_hdr->addr1, fwd_hdr->addr2,
+						ETH_ALEN);
+				err = xrmac_mesh_nexthop_lookup(fwd_skb, sdata);
+				/* Failed to immediately resolve next hop:
+				 * fwded frame was dropped or will be added
+				 * later to the pending skb queue.  */
+				if (err)
+					return RX_DROP_MONITOR;
+
+				IEEE80211_IFSTA_MESH_CTR_INC(&sdata->u.mesh,
+								fwded_unicast);
+			}
+			IEEE80211_IFSTA_MESH_CTR_INC(&sdata->u.mesh,
+						     fwded_frames);
+			mac80211_add_pending_skb(local, fwd_skb);
+		}
+	}
+
+ out:
+	if (is_multicast_ether_addr(hdr->addr1) ||
+	    sdata->dev->flags & IFF_PROMISC)
+		return RX_CONTINUE;
+	else
+		return RX_DROP_MONITOR;
+}
+#endif
+
+static ieee80211_rx_result debug_noinline
+ieee80211_rx_h_data(struct ieee80211_rx_data *rx)
+{
+	struct ieee80211_sub_if_data *sdata = rx->sdata;
+	struct ieee80211_local *local = rx->local;
+	struct net_device *dev = sdata->dev;
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;
+	__le16 fc = hdr->frame_control;
+	bool port_control;
+	int err;
+
+	if (unlikely(!ieee80211_is_data(hdr->frame_control)))
+		return RX_CONTINUE;
+
+	if (unlikely(!ieee80211_is_data_present(hdr->frame_control)))
+		return RX_DROP_MONITOR;
+
+	/*
+	 * Allow the cooked monitor interface of an AP to see 4-addr frames so
+	 * that a 4-addr station can be detected and moved into a separate VLAN
+	 */
+	if (ieee80211_has_a4(hdr->frame_control) &&
+	    sdata->vif.type == NL80211_IFTYPE_AP)
+		return RX_DROP_MONITOR;
+
+	err = __ieee80211_data_to_8023(rx, &port_control);
+	if (unlikely(err))
+		return RX_DROP_UNUSABLE;
+
+	if (!ieee80211_frame_allowed(rx, fc))
+		return RX_DROP_MONITOR;
+
+	if (rx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&
+	    unlikely(port_control) && sdata->bss) {
+		sdata = container_of(sdata->bss, struct ieee80211_sub_if_data,
+				     u.ap);
+		dev = sdata->dev;
+		rx->sdata = sdata;
+	}
+
+	rx->skb->dev = dev;
+
+	dev->stats.rx_packets++;
+	dev->stats.rx_bytes += rx->skb->len;
+
+	if (sdata->ps_allowed && sdata->vif.bss_conf.dynamic_ps_timeout > 0 &&
+	    !is_multicast_ether_addr(
+		    ((struct ethhdr *)rx->skb->data)->h_dest) &&
+	    (!local->scanning &&
+	     !test_bit(SDATA_STATE_OFFCHANNEL, &sdata->state))) {
+			mod_timer(&sdata->dynamic_ps_timer, jiffies +
+			 msecs_to_jiffies(sdata->vif.bss_conf.dynamic_ps_timeout));
+	}
+
+	ieee80211_deliver_skb(rx);
+
+	return RX_QUEUED;
+}
+
+static ieee80211_rx_result debug_noinline
+ieee80211_rx_h_ctrl(struct ieee80211_rx_data *rx)
+{
+	struct ieee80211_local *local = rx->local;
+	struct ieee80211_hw *hw = &local->hw;
+	struct sk_buff *skb = rx->skb;
+	struct ieee80211_bar *bar = (struct ieee80211_bar *)skb->data;
+	struct tid_ampdu_rx *tid_agg_rx;
+	u16 start_seq_num;
+	u16 tid;
+
+	if (likely(!ieee80211_is_ctl(bar->frame_control)))
+		return RX_CONTINUE;
+
+	if (ieee80211_is_back_req(bar->frame_control)) {
+		struct {
+			__le16 control, start_seq_num;
+		} __packed bar_data;
+
+		if (!rx->sta)
+			return RX_DROP_MONITOR;
+
+		if (skb_copy_bits(skb, offsetof(struct ieee80211_bar, control),
+				  &bar_data, sizeof(bar_data)))
+			return RX_DROP_MONITOR;
+
+		tid = le16_to_cpu(bar_data.control) >> 12;
+
+		tid_agg_rx = rcu_dereference(rx->sta->ampdu_mlme.tid_rx[tid]);
+		if (!tid_agg_rx)
+			return RX_DROP_MONITOR;
+
+		start_seq_num = le16_to_cpu(bar_data.start_seq_num) >> 4;
+
+		/* reset session timer */
+		if (tid_agg_rx->timeout)
+			mod_timer(&tid_agg_rx->session_timer,
+				  TU_TO_EXP_TIME(tid_agg_rx->timeout));
+
+		spin_lock(&tid_agg_rx->reorder_lock);
+		/* release stored frames up to start of BAR */
+		ieee80211_release_reorder_frames(hw, tid_agg_rx, start_seq_num);
+		spin_unlock(&tid_agg_rx->reorder_lock);
+
+		kfree_skb(skb);
+		return RX_QUEUED;
+	}
+
+	/*
+	 * After this point, we only want management frames,
+	 * so we can drop all remaining control frames to
+	 * cooked monitor interfaces.
+	 */
+	return RX_DROP_MONITOR;
+}
+
+static void ieee80211_process_sa_query_req(struct ieee80211_sub_if_data *sdata,
+					   struct ieee80211_mgmt *mgmt,
+					   size_t len)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct sk_buff *skb;
+	struct ieee80211_mgmt *resp;
+
+	if (compare_ether_addr(mgmt->da, sdata->vif.addr) != 0) {
+		/* Not to own unicast address */
+		return;
+	}
+
+	if (compare_ether_addr(mgmt->sa, sdata->u.mgd.bssid) != 0 ||
+	    compare_ether_addr(mgmt->bssid, sdata->u.mgd.bssid) != 0) {
+		/* Not from the current AP or not associated yet. */
+		return;
+	}
+
+	if (len < 24 + 1 + sizeof(resp->u.action.u.sa_query)) {
+		/* Too short SA Query request frame */
+		return;
+	}
+
+	skb = dev_alloc_skb(sizeof(*resp) + local->hw.extra_tx_headroom);
+	if (skb == NULL)
+		return;
+
+	skb_reserve(skb, local->hw.extra_tx_headroom);
+	resp = (struct ieee80211_mgmt *) skb_put(skb, 24);
+	memset(resp, 0, 24);
+	memcpy(resp->da, mgmt->sa, ETH_ALEN);
+	memcpy(resp->sa, sdata->vif.addr, ETH_ALEN);
+	memcpy(resp->bssid, sdata->u.mgd.bssid, ETH_ALEN);
+	resp->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+					  IEEE80211_STYPE_ACTION);
+	skb_put(skb, 1 + sizeof(resp->u.action.u.sa_query));
+	resp->u.action.category = WLAN_CATEGORY_SA_QUERY;
+	resp->u.action.u.sa_query.action = WLAN_ACTION_SA_QUERY_RESPONSE;
+	memcpy(resp->u.action.u.sa_query.trans_id,
+	       mgmt->u.action.u.sa_query.trans_id,
+	       WLAN_SA_QUERY_TR_ID_LEN);
+
+	ieee80211_tx_skb(sdata, skb);
+}
+
+static ieee80211_rx_result debug_noinline
+ieee80211_rx_h_mgmt_check(struct ieee80211_rx_data *rx)
+{
+	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *) rx->skb->data;
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);
+	struct ieee80211_sub_if_data *sdata = rx->sdata;
+
+	/*
+	 * From here on, look only at management frames.
+	 * Data and control frames are already handled,
+	 * and unknown (reserved) frames are useless.
+	 */
+	if (status->rx_flags & IEEE80211_RX_ERP_BEACON) {
+		rx->skb->pkt_type = IEEE80211_SDATA_QUEUE_TYPE_FRAME;
+		skb_queue_tail(&sdata->skb_queue, rx->skb);
+		mac80211_queue_work(&rx->local->hw, &sdata->work);
+		return RX_QUEUED;
+	}
+
+	if (rx->skb->len < 24)
+		return RX_DROP_MONITOR;
+
+	if (!ieee80211_is_mgmt(mgmt->frame_control))
+		return RX_DROP_MONITOR;
+
+	if (!(status->rx_flags & IEEE80211_RX_RA_MATCH))
+		return RX_DROP_MONITOR;
+
+	if (ieee80211_drop_unencrypted_mgmt(rx))
+		return RX_DROP_UNUSABLE;
+
+	return RX_CONTINUE;
+}
+
+static ieee80211_rx_result debug_noinline
+ieee80211_rx_h_action(struct ieee80211_rx_data *rx)
+{
+	struct ieee80211_local *local = rx->local;
+	struct ieee80211_sub_if_data *sdata = rx->sdata;
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sdata);
+	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *) rx->skb->data;
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);
+	int len = rx->skb->len;
+
+	if (!ieee80211_is_action(mgmt->frame_control))
+		return RX_CONTINUE;
+
+	/* drop too small frames */
+	if (len < IEEE80211_MIN_ACTION_SIZE)
+		return RX_DROP_UNUSABLE;
+
+	if (!rx->sta && mgmt->u.action.category != WLAN_CATEGORY_PUBLIC)
+		return RX_DROP_UNUSABLE;
+
+	if (!(status->rx_flags & IEEE80211_RX_RA_MATCH))
+		return RX_DROP_UNUSABLE;
+
+	switch (mgmt->u.action.category) {
+	case WLAN_CATEGORY_BACK:
+		/*
+		 * The aggregation code is not prepared to handle
+		 * anything but STA/AP due to the BSSID handling;
+		 * IBSS could work in the code but isn't supported
+		 * by drivers or the standard.
+		 */
+		if (sdata->vif.type != NL80211_IFTYPE_STATION &&
+		    sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&
+		    sdata->vif.type != NL80211_IFTYPE_AP)
+			break;
+
+		/* verify action_code is present */
+		if (len < IEEE80211_MIN_ACTION_SIZE + 1)
+			break;
+
+		switch (mgmt->u.action.u.addba_req.action_code) {
+		case WLAN_ACTION_ADDBA_REQ:
+			if (len < (IEEE80211_MIN_ACTION_SIZE +
+				   sizeof(mgmt->u.action.u.addba_req)))
+				goto invalid;
+			break;
+		case WLAN_ACTION_ADDBA_RESP:
+			if (len < (IEEE80211_MIN_ACTION_SIZE +
+				   sizeof(mgmt->u.action.u.addba_resp)))
+				goto invalid;
+			break;
+		case WLAN_ACTION_DELBA:
+			if (len < (IEEE80211_MIN_ACTION_SIZE +
+				   sizeof(mgmt->u.action.u.delba)))
+				goto invalid;
+			break;
+		default:
+			goto invalid;
+		}
+
+		goto queue;
+	case WLAN_CATEGORY_SPECTRUM_MGMT:
+		if (chan_state->conf.channel->band != NL80211_BAND_5GHZ)
+			break;
+
+		if (sdata->vif.type != NL80211_IFTYPE_STATION)
+			break;
+
+		/* verify action_code is present */
+		if (len < IEEE80211_MIN_ACTION_SIZE + 1)
+			break;
+
+		switch (mgmt->u.action.u.measurement.action_code) {
+		case WLAN_ACTION_SPCT_MSR_REQ:
+			if (len < (IEEE80211_MIN_ACTION_SIZE +
+				   sizeof(mgmt->u.action.u.measurement)))
+				break;
+			mac80211_process_measurement_req(sdata, mgmt, len);
+			goto handled;
+		case WLAN_ACTION_SPCT_CHL_SWITCH:
+			if (len < (IEEE80211_MIN_ACTION_SIZE +
+				   sizeof(mgmt->u.action.u.chan_switch)))
+				break;
+
+			if (sdata->vif.type != NL80211_IFTYPE_STATION)
+				break;
+
+			if (memcmp(mgmt->bssid, sdata->u.mgd.bssid, ETH_ALEN))
+				break;
+
+			goto queue;
+		}
+		break;
+	case WLAN_CATEGORY_SA_QUERY:
+		if (len < (IEEE80211_MIN_ACTION_SIZE +
+			   sizeof(mgmt->u.action.u.sa_query)))
+			break;
+
+		switch (mgmt->u.action.u.sa_query.action) {
+		case WLAN_ACTION_SA_QUERY_REQUEST:
+			if (sdata->vif.type != NL80211_IFTYPE_STATION)
+				break;
+			ieee80211_process_sa_query_req(sdata, mgmt, len);
+			goto handled;
+		}
+		break;
+	case WLAN_CATEGORY_SELF_PROTECTED:
+		switch (mgmt->u.action.u.self_prot.action_code) {
+		case WLAN_SP_MESH_PEERING_OPEN:
+		case WLAN_SP_MESH_PEERING_CLOSE:
+		case WLAN_SP_MESH_PEERING_CONFIRM:
+			if (!ieee80211_vif_is_mesh(&sdata->vif))
+				goto invalid;
+			if (sdata->u.mesh.security != IEEE80211_MESH_SEC_NONE)
+				/* userspace handles this frame */
+				break;
+			goto queue;
+		case WLAN_SP_MGK_INFORM:
+		case WLAN_SP_MGK_ACK:
+			if (!ieee80211_vif_is_mesh(&sdata->vif))
+				goto invalid;
+			break;
+		}
+		break;
+	case WLAN_CATEGORY_MESH_ACTION:
+		if (!ieee80211_vif_is_mesh(&sdata->vif))
+			break;
+		if (xrmac_mesh_action_is_path_sel(mgmt) &&
+		  (!mesh_path_sel_is_hwmp(sdata)))
+			break;
+		goto queue;
+	}
+
+	return RX_CONTINUE;
+
+ invalid:
+	status->rx_flags |= IEEE80211_RX_MALFORMED_ACTION_FRM;
+	/* will return in the next handlers */
+	return RX_CONTINUE;
+
+ handled:
+	if (rx->sta)
+		rx->sta->rx_packets++;
+	dev_kfree_skb(rx->skb);
+	return RX_QUEUED;
+
+ queue:
+	rx->skb->pkt_type = IEEE80211_SDATA_QUEUE_TYPE_FRAME;
+	skb_queue_tail(&sdata->skb_queue, rx->skb);
+	mac80211_queue_work(&local->hw, &sdata->work);
+	if (rx->sta)
+		rx->sta->rx_packets++;
+	return RX_QUEUED;
+}
+
+static ieee80211_rx_result debug_noinline
+ieee80211_rx_h_userspace_mgmt(struct ieee80211_rx_data *rx)
+{
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);
+
+	/* skip known-bad action frames and return them in the next handler */
+	if (status->rx_flags & IEEE80211_RX_MALFORMED_ACTION_FRM)
+		return RX_CONTINUE;
+
+	/*
+	 * Getting here means the kernel doesn't know how to handle
+	 * it, but maybe userspace does ... include returned frames
+	 * so userspace can register for those to know whether ones
+	 * it transmitted were processed or returned.
+	 */
+
+	if (cfg80211_rx_mgmt(&rx->sdata->wdev, status->freq, status->signal,
+			     rx->skb->data, rx->skb->len, 0)) {
+		if (rx->sta)
+			rx->sta->rx_packets++;
+		dev_kfree_skb(rx->skb);
+		return RX_QUEUED;
+	}
+
+
+	return RX_CONTINUE;
+}
+
+static ieee80211_rx_result debug_noinline
+ieee80211_rx_h_action_return(struct ieee80211_rx_data *rx)
+{
+	struct ieee80211_local *local = rx->local;
+	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *) rx->skb->data;
+	struct sk_buff *nskb;
+	struct ieee80211_sub_if_data *sdata = rx->sdata;
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);
+
+	if (!ieee80211_is_action(mgmt->frame_control))
+		return RX_CONTINUE;
+
+	/*
+	 * For AP mode, hostapd is responsible for handling any action
+	 * frames that we didn't handle, including returning unknown
+	 * ones. For all other modes we will return them to the sender,
+	 * setting the 0x80 bit in the action category, as required by
+	 * 802.11-2007 7.3.1.11.
+	 * Newer versions of hostapd shall also use the management frame
+	 * registration mechanisms, but older ones still use cooked
+	 * monitor interfaces so push all frames there.
+	 */
+	if (!(status->rx_flags & IEEE80211_RX_MALFORMED_ACTION_FRM) &&
+	    (sdata->vif.type == NL80211_IFTYPE_AP ||
+	     sdata->vif.type == NL80211_IFTYPE_AP_VLAN))
+		return RX_DROP_MONITOR;
+
+	/* do not return rejected action frames */
+	if (mgmt->u.action.category & 0x80)
+		return RX_DROP_UNUSABLE;
+
+	nskb = skb_copy_expand(rx->skb, local->hw.extra_tx_headroom, 0,
+			       GFP_ATOMIC);
+	if (nskb) {
+		struct ieee80211_mgmt *nmgmt = (void *)nskb->data;
+
+		nmgmt->u.action.category |= 0x80;
+		memcpy(nmgmt->da, nmgmt->sa, ETH_ALEN);
+		memcpy(nmgmt->sa, rx->sdata->vif.addr, ETH_ALEN);
+
+		memset(nskb->cb, 0, sizeof(nskb->cb));
+
+		ieee80211_tx_skb(rx->sdata, nskb);
+	}
+	dev_kfree_skb(rx->skb);
+	return RX_QUEUED;
+}
+
+static ieee80211_rx_result debug_noinline
+ieee80211_rx_h_mgmt(struct ieee80211_rx_data *rx)
+{
+	struct ieee80211_sub_if_data *sdata = rx->sdata;
+	ieee80211_rx_result rxs;
+	struct ieee80211_mgmt *mgmt = (void *)rx->skb->data;
+	__le16 stype;
+
+	rxs = ieee80211_work_rx_mgmt(rx->sdata, rx->skb);
+	if (rxs != RX_CONTINUE)
+		return rxs;
+
+	stype = mgmt->frame_control & cpu_to_le16(IEEE80211_FCTL_STYPE);
+
+	if (!ieee80211_vif_is_mesh(&sdata->vif) &&
+	    sdata->vif.type != NL80211_IFTYPE_ADHOC &&
+	    sdata->vif.type != NL80211_IFTYPE_STATION)
+		return RX_DROP_MONITOR;
+
+	switch (stype) {
+	case cpu_to_le16(IEEE80211_STYPE_BEACON):
+	case cpu_to_le16(IEEE80211_STYPE_PROBE_RESP):
+		/* process for all: mesh, mlme, ibss */
+		break;
+	case cpu_to_le16(IEEE80211_STYPE_DEAUTH):
+	case cpu_to_le16(IEEE80211_STYPE_DISASSOC):
+		if (is_multicast_ether_addr(mgmt->da) &&
+		    !is_broadcast_ether_addr(mgmt->da))
+			return RX_DROP_MONITOR;
+
+		/* process only for station */
+		if (sdata->vif.type != NL80211_IFTYPE_STATION)
+			return RX_DROP_MONITOR;
+		break;
+	case cpu_to_le16(IEEE80211_STYPE_PROBE_REQ):
+	case cpu_to_le16(IEEE80211_STYPE_AUTH):
+		/* process only for ibss */
+		if (sdata->vif.type != NL80211_IFTYPE_ADHOC)
+			return RX_DROP_MONITOR;
+		break;
+	default:
+		return RX_DROP_MONITOR;
+	}
+
+	/* queue up frame and kick off work to process it */
+	rx->skb->pkt_type = IEEE80211_SDATA_QUEUE_TYPE_FRAME;
+	skb_queue_tail(&sdata->skb_queue, rx->skb);
+	mac80211_queue_work(&rx->local->hw, &sdata->work);
+	if (rx->sta)
+		rx->sta->rx_packets++;
+
+	return RX_QUEUED;
+}
+
+/* TODO: use IEEE80211_RX_FRAGMENTED */
+static void ieee80211_rx_cooked_monitor(struct ieee80211_rx_data *rx,
+					struct ieee80211_rate *rate)
+{
+	struct ieee80211_sub_if_data *sdata;
+	struct ieee80211_local *local = rx->local;
+	struct ieee80211_rtap_hdr {
+		struct ieee80211_radiotap_header hdr;
+		u8 flags;
+		u8 rate_or_pad;
+		__le16 chan_freq;
+		__le16 chan_flags;
+	} __packed * rthdr;
+	struct sk_buff *skb = rx->skb, *skb2;
+	struct net_device *prev_dev = NULL;
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
+
+	/*
+	 * If cooked monitor has been processed already, then
+	 * don't do it again. If not, set the flag.
+	 */
+	if (rx->flags & IEEE80211_RX_CMNTR)
+		goto out_free_skb;
+	rx->flags |= IEEE80211_RX_CMNTR;
+
+	if (skb_headroom(skb) < sizeof(*rthdr) &&
+	    pskb_expand_head(skb, sizeof(*rthdr), 0, GFP_ATOMIC))
+		goto out_free_skb;
+
+	rthdr = (void *)skb_push(skb, sizeof(*rthdr));
+	memset(rthdr, 0, sizeof(*rthdr));
+	rthdr->hdr.it_len = cpu_to_le16(sizeof(*rthdr));
+	rthdr->hdr.it_present =
+		cpu_to_le32((1 << IEEE80211_RADIOTAP_FLAGS) |
+			    (1 << IEEE80211_RADIOTAP_CHANNEL));
+
+	if (rate) {
+		rthdr->rate_or_pad = rate->bitrate / 5;
+		rthdr->hdr.it_present |=
+			cpu_to_le32(1 << IEEE80211_RADIOTAP_RATE);
+	}
+	rthdr->chan_freq = cpu_to_le16(status->freq);
+
+	if (status->band == NL80211_BAND_5GHZ)
+		rthdr->chan_flags = cpu_to_le16(IEEE80211_CHAN_OFDM |
+						IEEE80211_CHAN_5GHZ);
+	else
+		rthdr->chan_flags = cpu_to_le16(IEEE80211_CHAN_DYN |
+						IEEE80211_CHAN_2GHZ);
+
+	skb_set_mac_header(skb, 0);
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+	skb->pkt_type = PACKET_OTHERHOST;
+	skb->protocol = htons(ETH_P_802_2);
+
+	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
+		if (!ieee80211_sdata_running(sdata))
+			continue;
+
+		if (sdata->vif.type != NL80211_IFTYPE_MONITOR ||
+		    !(sdata->u.mntr_flags & MONITOR_FLAG_COOK_FRAMES))
+			continue;
+
+		if (prev_dev) {
+			skb2 = skb_clone(skb, GFP_ATOMIC);
+			if (skb2) {
+				skb2->dev = prev_dev;
+				netif_receive_skb(skb2);
+			}
+		}
+
+		prev_dev = sdata->dev;
+		sdata->dev->stats.rx_packets++;
+		sdata->dev->stats.rx_bytes += skb->len;
+	}
+
+	if (prev_dev) {
+		skb->dev = prev_dev;
+		netif_receive_skb(skb);
+		return;
+	}
+
+ out_free_skb:
+	dev_kfree_skb(skb);
+}
+
+static void ieee80211_rx_handlers_result(struct ieee80211_rx_data *rx,
+					 ieee80211_rx_result res)
+{
+	switch (res) {
+	case RX_DROP_MONITOR:
+		I802_DEBUG_INC(rx->sdata->local->rx_handlers_drop);
+		if (rx->sta)
+			rx->sta->rx_dropped++;
+		/* fall through */
+	case RX_CONTINUE: {
+		struct ieee80211_rate *rate = NULL;
+		struct ieee80211_supported_band *sband;
+		struct ieee80211_rx_status *status;
+
+		status = IEEE80211_SKB_RXCB((rx->skb));
+
+		sband = rx->local->hw.wiphy->bands[status->band];
+		if (!(status->flag & RX_FLAG_HT))
+			rate = &sband->bitrates[status->rate_idx];
+
+		ieee80211_rx_cooked_monitor(rx, rate);
+		break;
+		}
+	case RX_DROP_UNUSABLE:
+		I802_DEBUG_INC(rx->sdata->local->rx_handlers_drop);
+		if (rx->sta)
+			rx->sta->rx_dropped++;
+		dev_kfree_skb(rx->skb);
+		break;
+	case RX_QUEUED:
+		I802_DEBUG_INC(rx->sdata->local->rx_handlers_queued);
+		break;
+	}
+}
+
+static void ieee80211_rx_handlers(struct ieee80211_rx_data *rx)
+{
+	ieee80211_rx_result res = RX_DROP_MONITOR;
+	struct sk_buff *skb, *tmp;
+	struct ieee80211_hdr *hdr;
+
+#define CALL_RXH(rxh)			\
+	do {				\
+		res = rxh(rx);		\
+		if (res != RX_CONTINUE)	\
+			goto rxh_next;  \
+	} while (0);
+
+	spin_lock(&rx->local->rx_skb_queue.lock);
+	if (rx->local->running_rx_handler)
+		goto unlock;
+
+	rx->local->running_rx_handler = true;
+
+	skb_queue_walk_safe(&rx->local->rx_skb_queue, skb, tmp) {
+		if (!skb)
+			break;
+		hdr = (struct ieee80211_hdr *) skb->data;
+		if (rx->sta && hdr) {
+		       if (ieee80211_is_data(hdr->frame_control)) {
+				if (memcmp(rx->sta->sta.addr, hdr->addr2, ETH_ALEN)) {
+					continue;
+				}
+		       }
+		}
+		__skb_unlink(skb, &rx->local->rx_skb_queue);
+		spin_unlock(&rx->local->rx_skb_queue.lock);
+
+		/*
+		 * all the other fields are valid across frames
+		 * that belong to an aMPDU since they are on the
+		 * same TID from the same station
+		 */
+		rx->skb = skb;
+
+		CALL_RXH(ieee80211_rx_h_decrypt)
+		CALL_RXH(ieee80211_rx_h_check_more_data)
+		CALL_RXH(ieee80211_rx_h_uapsd_and_pspoll)
+		CALL_RXH(ieee80211_rx_h_sta_process)
+		CALL_RXH(ieee80211_rx_h_defragment)
+		CALL_RXH(ieee80211_rx_h_xrmac_michael_mic_verify)
+		/* must be after MMIC verify so header is counted in MPDU mic */
+#ifdef CONFIG_XRMAC_MESH
+		if (ieee80211_vif_is_mesh(&rx->sdata->vif))
+			CALL_RXH(ieee80211_rx_h_mesh_fwding);
+#endif
+		CALL_RXH(ieee80211_rx_h_remove_qos_control)
+		CALL_RXH(ieee80211_rx_h_amsdu)
+		CALL_RXH(ieee80211_rx_h_data)
+		CALL_RXH(ieee80211_rx_h_ctrl);
+		CALL_RXH(ieee80211_rx_h_mgmt_check)
+		CALL_RXH(ieee80211_rx_h_action)
+		CALL_RXH(ieee80211_rx_h_userspace_mgmt)
+		CALL_RXH(ieee80211_rx_h_action_return)
+		CALL_RXH(ieee80211_rx_h_mgmt)
+
+rxh_next :
+		ieee80211_rx_handlers_result(rx, res);
+		spin_lock(&rx->local->rx_skb_queue.lock);
+#undef CALL_RXH
+	}
+
+	rx->local->running_rx_handler = false;
+
+ unlock:
+	spin_unlock(&rx->local->rx_skb_queue.lock);
+}
+
+static void ieee80211_invoke_rx_handlers(struct ieee80211_rx_data *rx)
+{
+	ieee80211_rx_result res = RX_DROP_MONITOR;
+
+#define CALL_RXH(rxh)			\
+	do {				\
+		res = rxh(rx);		\
+		if (res != RX_CONTINUE)	\
+			goto rxh_next;  \
+	} while (0);
+
+	CALL_RXH(ieee80211_rx_h_passive_scan)
+	CALL_RXH(ieee80211_rx_h_check)
+
+	ieee80211_rx_reorder_ampdu(rx);
+
+	ieee80211_rx_handlers(rx);
+	return;
+
+ rxh_next:
+	ieee80211_rx_handlers_result(rx, res);
+
+#undef CALL_RXH
+}
+
+/*
+ * This function makes calls into the RX path, therefore
+ * it has to be invoked under RCU read lock.
+ */
+void mac80211_release_reorder_timeout(struct sta_info *sta, int tid)
+{
+	struct ieee80211_rx_data rx = {
+		.sta = sta,
+		.sdata = sta->sdata,
+		.local = sta->local,
+		/* This is OK -- must be QoS data frame */
+		.security_idx = tid,
+		.seqno_idx = tid,
+		.flags = 0,
+	};
+	struct tid_ampdu_rx *tid_agg_rx;
+
+	tid_agg_rx = rcu_dereference(sta->ampdu_mlme.tid_rx[tid]);
+	if (!tid_agg_rx)
+		return;
+
+	spin_lock(&tid_agg_rx->reorder_lock);
+	ieee80211_sta_reorder_release(&sta->local->hw, tid_agg_rx);
+	spin_unlock(&tid_agg_rx->reorder_lock);
+
+	ieee80211_rx_handlers(&rx);
+}
+
+/* main receive path */
+
+static int prepare_for_handlers(struct ieee80211_rx_data *rx,
+				struct ieee80211_hdr *hdr)
+{
+	struct ieee80211_sub_if_data *sdata = rx->sdata;
+	struct sk_buff *skb = rx->skb;
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
+	u8 *bssid = mac80211_get_bssid(hdr, skb->len, sdata->vif.type);
+	int multicast = is_multicast_ether_addr(hdr->addr1);
+
+	switch (sdata->vif.type) {
+	case NL80211_IFTYPE_STATION:
+		if (!bssid && !sdata->u.mgd.use_4addr)
+			return 0;
+		if (!multicast &&
+		    compare_ether_addr(sdata->vif.addr, hdr->addr1) != 0) {
+			if (!(sdata->dev->flags & IFF_PROMISC) ||
+			    sdata->u.mgd.use_4addr)
+				return 0;
+			status->rx_flags &= ~IEEE80211_RX_RA_MATCH;
+		}
+		break;
+	case NL80211_IFTYPE_ADHOC:
+		if (!bssid)
+			return 0;
+		if (ieee80211_is_beacon(hdr->frame_control)) {
+			return 1;
+		} else if (!ieee80211_bssid_match(bssid, sdata->u.ibss.bssid)) {
+			if (!(status->rx_flags & IEEE80211_RX_IN_SCAN))
+				return 0;
+			status->rx_flags &= ~IEEE80211_RX_RA_MATCH;
+		} else if (!multicast &&
+			   compare_ether_addr(sdata->vif.addr,
+					      hdr->addr1) != 0) {
+			if (!(sdata->dev->flags & IFF_PROMISC))
+				return 0;
+			status->rx_flags &= ~IEEE80211_RX_RA_MATCH;
+		} else if (!rx->sta) {
+			int rate_idx;
+			if (status->flag & RX_FLAG_HT)
+				rate_idx = 0; /* TODO: HT rates */
+			else
+				rate_idx = status->rate_idx;
+			rx->sta = ieee80211_ibss_add_sta(sdata, bssid,
+					hdr->addr2, BIT(rate_idx), GFP_ATOMIC);
+		}
+		break;
+	case NL80211_IFTYPE_MESH_POINT:
+		if (!multicast &&
+		    compare_ether_addr(sdata->vif.addr,
+				       hdr->addr1) != 0) {
+			if (!(sdata->dev->flags & IFF_PROMISC))
+				return 0;
+
+			status->rx_flags &= ~IEEE80211_RX_RA_MATCH;
+		}
+		break;
+	case NL80211_IFTYPE_AP_VLAN:
+	case NL80211_IFTYPE_AP:
+		if (!bssid) {
+			if (compare_ether_addr(sdata->vif.addr,
+					       hdr->addr1))
+				return 0;
+		} else if (!ieee80211_bssid_match(bssid, sdata->vif.addr)) {
+			if (ieee80211_is_beacon(hdr->frame_control))
+				status->rx_flags |= IEEE80211_RX_ERP_BEACON;
+			else if (!(status->rx_flags & IEEE80211_RX_IN_SCAN) &&
+					ieee80211_is_public_action(hdr, skb->len))
+				return 1;
+			if (!(status->rx_flags & IEEE80211_RX_IN_SCAN) &&
+					!ieee80211_is_beacon(hdr->frame_control))
+				return 0;
+			status->rx_flags &= ~IEEE80211_RX_RA_MATCH;
+		}
+		break;
+	case NL80211_IFTYPE_WDS:
+		if (bssid || !ieee80211_is_data(hdr->frame_control))
+			return 0;
+		if (compare_ether_addr(sdata->u.wds.remote_addr, hdr->addr2))
+			return 0;
+		break;
+	case NL80211_IFTYPE_P2P_DEVICE:
+		if (!ieee80211_is_public_action(hdr, skb->len) &&
+		    !ieee80211_is_probe_req(hdr->frame_control) &&
+		    !ieee80211_is_probe_resp(hdr->frame_control) &&
+		    !ieee80211_is_beacon(hdr->frame_control))
+			return 0;
+		if (!multicast && !ether_addr_equal(sdata->vif.addr, hdr->addr1))
+			status->rx_flags &= ~IEEE80211_RX_RA_MATCH;
+		break;
+	default:
+		/* should never get here */
+		WARN_ON(1);
+		break;
+	}
+
+	return 1;
+}
+
+/*
+ * This function returns whether or not the SKB
+ * was destined for RX processing or not, which,
+ * if consume is true, is equivalent to whether
+ * or not the skb was consumed.
+ */
+static bool ieee80211_prepare_and_rx_handle(struct ieee80211_rx_data *rx,
+					    struct sk_buff *skb, bool consume)
+{
+	struct ieee80211_local *local = rx->local;
+	struct ieee80211_sub_if_data *sdata = rx->sdata;
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
+	struct ieee80211_hdr *hdr = (void *)skb->data;
+	int prepares;
+
+	rx->skb = skb;
+	status->rx_flags |= IEEE80211_RX_RA_MATCH;
+	prepares = prepare_for_handlers(rx, hdr);
+
+	if (!prepares)
+		return false;
+
+	if (!consume) {
+		skb = skb_copy(skb, GFP_ATOMIC);
+		if (!skb) {
+			if (net_ratelimit())
+				wiphy_debug(local->hw.wiphy,
+					"failed to copy skb for %s\n",
+					sdata->name);
+			return true;
+		}
+
+		rx->skb = skb;
+	}
+
+	ieee80211_invoke_rx_handlers(rx);
+	return true;
+}
+
+/*
+ * This is the actual Rx frames handler. as it blongs to Rx path it must
+ * be called with rcu_read_lock protection.
+ */
+static void __ieee80211_rx_handle_packet(struct ieee80211_hw *hw,
+					 struct sk_buff *skb)
+{
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct ieee80211_sub_if_data *sdata;
+	struct ieee80211_hdr *hdr;
+	__le16 fc;
+	struct ieee80211_rx_data rx;
+	struct ieee80211_sub_if_data *prev;
+	struct sta_info *sta, *tmp, *prev_sta;
+	int err = 0;
+
+	fc = ((struct ieee80211_hdr *)skb->data)->frame_control;
+	memset(&rx, 0, sizeof(rx));
+	rx.skb = skb;
+	rx.local = local;
+
+	if (ieee80211_is_data(fc) || ieee80211_is_mgmt(fc))
+		local->dot11ReceivedFragmentCount++;
+
+	if (unlikely(test_bit(SCAN_HW_SCANNING, &local->scanning) ||
+		     test_bit(SCAN_OFF_CHANNEL, &local->scanning)))
+		status->rx_flags |= IEEE80211_RX_IN_SCAN;
+
+	if (ieee80211_is_mgmt(fc))
+		err = skb_linearize(skb);
+	else
+		err = !pskb_may_pull(skb, ieee80211_hdrlen(fc));
+
+	if (err) {
+		dev_kfree_skb(skb);
+		return;
+	}
+
+	hdr = (struct ieee80211_hdr *)skb->data;
+	ieee80211_parse_qos(&rx);
+	ieee80211_verify_alignment(&rx);
+
+	if (ieee80211_is_data(fc)) {
+		prev_sta = NULL;
+
+		for_each_sta_info_rx(local, hdr->addr2, sta, tmp) {
+			if (!prev_sta) {
+				prev_sta = sta;
+				continue;
+			}
+
+			rx.sta = prev_sta;
+			rx.sdata = prev_sta->sdata;
+			ieee80211_prepare_and_rx_handle(&rx, skb, false);
+
+			prev_sta = sta;
+		}
+
+		if (prev_sta) {
+			rx.sta = prev_sta;
+			rx.sdata = prev_sta->sdata;
+
+			if (ieee80211_prepare_and_rx_handle(&rx, skb, true))
+				return;
+			goto out;
+		}
+	}
+
+	prev = NULL;
+
+	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
+		if (!ieee80211_sdata_running(sdata))
+			continue;
+
+		if (sdata->vif.type == NL80211_IFTYPE_MONITOR ||
+		    sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
+			continue;
+
+		/*
+		 * frame is destined for this interface, but if it's
+		 * not also for the previous one we handle that after
+		 * the loop to avoid copying the SKB once too much
+		 */
+
+		if (!prev) {
+			prev = sdata;
+			continue;
+		}
+
+		rx.sta = xrmac_sta_info_get_bss_rx(prev, hdr->addr2);
+		rx.sdata = prev;
+		ieee80211_prepare_and_rx_handle(&rx, skb, false);
+
+		prev = sdata;
+	}
+
+	if (prev) {
+		rx.sta = xrmac_sta_info_get_bss_rx(prev, hdr->addr2);
+		rx.sdata = prev;
+
+		if (ieee80211_prepare_and_rx_handle(&rx, skb, true))
+			return;
+	}
+
+ out:
+	dev_kfree_skb(skb);
+}
+
+/*
+ * This is the receive path handler. It is called by a low level driver when an
+ * 802.11 MPDU is received from the hardware.
+ */
+void mac80211_rx(struct ieee80211_hw *hw, struct sk_buff *skb)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct ieee80211_rate *rate = NULL;
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
+
+	WARN_ON_ONCE(softirq_count() == 0);
+
+	if (WARN_ON(status->band < 0 ||
+		    status->band >= NUM_NL80211_BANDS))
+		goto drop;
+
+	sband = local->hw.wiphy->bands[status->band];
+	if (WARN_ON(!sband))
+		goto drop;
+
+	/*
+	 * If we're suspending, it is possible although not too likely
+	 * that we'd be receiving frames after having already partially
+	 * quiesced the stack. We can't process such frames then since
+	 * that might, for example, cause stations to be added or other
+	 * driver callbacks be invoked.
+	 */
+	if (unlikely(local->quiescing || local->suspended))
+		goto drop;
+
+	/* We might be during a HW reconfig, prevent Rx for the same reason */
+	if (unlikely(local->in_reconfig))
+		goto drop;
+
+	/*
+	 * The same happens when we're not even started,
+	 * but that's worth a warning.
+	 */
+	if (WARN_ON(!local->started))
+		goto drop;
+
+	if (likely(!(status->flag & RX_FLAG_FAILED_PLCP_CRC))) {
+		/*
+		 * Validate the rate, unless a PLCP error means that
+		 * we probably can't have a valid rate here anyway.
+		 */
+
+		if (status->flag & RX_FLAG_HT) {
+			/*
+			 * rate_idx is MCS index, which can be [0-76]
+			 * as documented on:
+			 *
+			 * http://wireless.kernel.org/en/developers/Documentation/ieee80211/802.11n
+			 *
+			 * Anything else would be some sort of driver or
+			 * hardware error. The driver should catch hardware
+			 * errors.
+			 */
+			if (WARN((status->rate_idx < 0 ||
+				 status->rate_idx > 76),
+				 "Rate marked as an HT rate but passed "
+				 "status->rate_idx is not "
+				 "an MCS index [0-76]: %d (0x%02x)\n",
+				 status->rate_idx,
+				 status->rate_idx))
+				goto drop;
+		} else {
+			if (WARN_ON(status->rate_idx < 0 ||
+				    status->rate_idx >= sband->n_bitrates))
+				goto drop;
+			rate = &sband->bitrates[status->rate_idx];
+		}
+	}
+
+	status->rx_flags = 0;
+
+	/*
+	 * key references and virtual interfaces are protected using RCU
+	 * and this requires that we are in a read-side RCU section during
+	 * receive processing
+	 */
+	rcu_read_lock();
+
+	/*
+	 * Frames with failed FCS/PLCP checksum are not returned,
+	 * all other frames are returned without radiotap header
+	 * if it was previously present.
+	 * Also, frames with less than 16 bytes are dropped.
+	 */
+	skb = ieee80211_rx_monitor(local, skb, rate);
+	if (!skb) {
+		rcu_read_unlock();
+		return;
+	}
+
+	ieee80211_tpt_led_trig_rx(local,
+			((struct ieee80211_hdr *)skb->data)->frame_control,
+			skb->len);
+	__ieee80211_rx_handle_packet(hw, skb);
+
+	rcu_read_unlock();
+
+	return;
+ drop:
+	kfree_skb(skb);
+}
+
+/* This is a version of the rx handler that can be called from hard irq
+ * context. Post the skb on the queue and schedule the tasklet */
+void mac80211_rx_irqsafe(struct ieee80211_hw *hw, struct sk_buff *skb)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+
+	BUILD_BUG_ON(sizeof(struct ieee80211_rx_status) > sizeof(skb->cb));
+
+	skb->pkt_type = IEEE80211_RX_MSG;
+	skb_queue_tail(&local->skb_queue, skb);
+	tasklet_schedule(&local->tasklet);
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/scan.c b/drivers/net/wireless/xr829/umac/scan.c
--- a/drivers/net/wireless/xr829/umac/scan.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/scan.c	2022-08-27 01:22:42.954539862 +0300
@@ -0,0 +1,1004 @@
+/*
+ * Scanning implementation
+ *
+ * Copyright 2003, Jouni Malinen <jkmaline@cc.hut.fi>
+ * Copyright 2004, Instant802 Networks, Inc.
+ * Copyright 2005, Devicescape Software, Inc.
+ * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
+ * Copyright 2007, Michael Wu <flamingice@sourmilk.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/if_arp.h>
+#include <linux/rtnetlink.h>
+#include <linux/pm_qos.h>
+#include <net/sch_generic.h>
+#include <linux/slab.h>
+#include <linux/export.h>
+#include <net/mac80211.h>
+
+#include "ieee80211_i.h"
+#include "driver-ops.h"
+#include "mesh.h"
+
+#define IEEE80211_PROBE_DELAY (HZ / 33)
+#define IEEE80211_CHANNEL_TIME (HZ / 33)
+#define IEEE80211_PASSIVE_CHANNEL_TIME (HZ / 8)
+
+struct ieee80211_bss *
+mac80211_rx_bss_get(struct ieee80211_local *local, u8 *bssid, int freq,
+		     u8 *ssid, u8 ssid_len)
+{
+	struct cfg80211_bss *cbss;
+
+	cbss = cfg80211_get_bss(local->hw.wiphy,
+				ieee80211_get_channel(local->hw.wiphy, freq),
+				bssid, ssid, ssid_len, IEEE80211_BSS_TYPE_ANY, IEEE80211_PRIVACY_ANY);
+	if (!cbss)
+		return NULL;
+	return (void *)cbss->priv;
+}
+#if 0
+static void ieee80211_rx_bss_free(struct cfg80211_bss *cbss)
+{
+	struct ieee80211_bss *bss = (void *)cbss->priv;
+
+	kfree(bss_mesh_id(bss));
+	kfree(bss_mesh_cfg(bss));
+}
+#endif
+void mac80211_rx_bss_put(struct ieee80211_local *local,
+			  struct ieee80211_bss *bss)
+{
+	if (!bss)
+		return;
+	cfg80211_put_bss(local->hw.wiphy, container_of((void *)bss, struct cfg80211_bss, priv));
+}
+
+static bool is_uapsd_supported(struct ieee802_11_elems *elems)
+{
+	u8 qos_info;
+
+	if (elems->wmm_info && elems->wmm_info_len == 7
+	    && elems->wmm_info[5] == 1)
+		qos_info = elems->wmm_info[6];
+	else if (elems->wmm_param && elems->wmm_param_len == 24
+		 && elems->wmm_param[5] == 1)
+		qos_info = elems->wmm_param[6];
+	else
+		/* no valid wmm information or parameter element found */
+		return false;
+
+	return qos_info & IEEE80211_WMM_IE_AP_QOSINFO_UAPSD;
+}
+
+struct ieee80211_bss *
+mac80211_bss_info_update(struct ieee80211_local *local,
+			  struct ieee80211_rx_status *rx_status,
+			  struct ieee80211_mgmt *mgmt,
+			  size_t len,
+			  struct ieee802_11_elems *elems,
+			  struct ieee80211_channel *channel,
+			  bool beacon)
+{
+	struct cfg80211_bss *cbss;
+	struct ieee80211_bss *bss;
+	int clen, srlen;
+	s32 signal = 0;
+
+	if (local->hw.flags & IEEE80211_HW_SIGNAL_DBM)
+		signal = rx_status->signal * 100;
+	else if (local->hw.flags & IEEE80211_HW_SIGNAL_UNSPEC)
+		signal = (rx_status->signal * 100) / local->hw.max_signal;
+
+#ifdef USE_RSSI_SMOOTH
+	if (!local->dis_rssi_smooth) {
+		cbss = cfg80211_get_bss(local->hw.wiphy, channel, mgmt->bssid,
+				elems->ssid, elems->ssid_len, IEEE80211_BSS_TYPE_ANY, IEEE80211_PRIVACY_ANY);
+		if (cbss) {
+			signal = (cbss->signal*90 + signal*10)/100;
+		}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
+		cfg80211_put_bss(local->hw.wiphy, cbss);
+#else
+		cfg80211_put_bss(cbss);
+#endif
+	}
+#endif
+
+	cbss = cfg80211_inform_bss_frame(local->hw.wiphy, channel,
+					 mgmt, len, signal, GFP_ATOMIC);
+
+	if (!cbss)
+		return NULL;
+
+	/*cbss->free_priv = ieee80211_rx_bss_free;*/
+	bss = (void *)cbss->priv;
+
+	/* save the ERP value so that it is available at association time */
+	if (elems->erp_info && elems->erp_info_len >= 1) {
+		bss->erp_value = elems->erp_info[0];
+		bss->has_erp_value = 1;
+	}
+
+	if (elems->tim) {
+		struct ieee80211_tim_ie *tim_ie =
+			(struct ieee80211_tim_ie *)elems->tim;
+		bss->dtim_period = tim_ie->dtim_period;
+	}
+
+	/* If the beacon had no TIM IE, or it was invalid, use 1 */
+	if (beacon && !bss->dtim_period)
+		bss->dtim_period = 1;
+
+	/* replace old supported rates if we get new values */
+	srlen = 0;
+	if (elems->supp_rates) {
+		clen = IEEE80211_MAX_SUPP_RATES;
+		if (clen > elems->supp_rates_len)
+			clen = elems->supp_rates_len;
+		memcpy(bss->supp_rates, elems->supp_rates, clen);
+		srlen += clen;
+	}
+	if (elems->ext_supp_rates) {
+		clen = IEEE80211_MAX_SUPP_RATES - srlen;
+		if (clen > elems->ext_supp_rates_len)
+			clen = elems->ext_supp_rates_len;
+		memcpy(bss->supp_rates + srlen, elems->ext_supp_rates, clen);
+		srlen += clen;
+	}
+	if (srlen)
+		bss->supp_rates_len = srlen;
+
+	bss->wmm_used = elems->wmm_param || elems->wmm_info;
+	bss->uapsd_supported = is_uapsd_supported(elems);
+
+	if (!beacon)
+		bss->last_probe_resp = jiffies;
+
+	return bss;
+}
+
+ieee80211_rx_result
+mac80211_scan_rx(struct ieee80211_sub_if_data *sdata, struct sk_buff *skb)
+{
+	struct ieee80211_rx_status *rx_status = IEEE80211_SKB_RXCB(skb);
+	struct ieee80211_mgmt *mgmt;
+	struct ieee80211_bss *bss;
+	u8 *elements;
+	struct ieee80211_channel *channel;
+	size_t baselen;
+	int freq;
+	__le16 fc;
+	bool presp, beacon = false;
+	struct ieee802_11_elems elems;
+
+	if (skb->len < 2)
+		return RX_DROP_UNUSABLE;
+
+	mgmt = (struct ieee80211_mgmt *) skb->data;
+	fc = mgmt->frame_control;
+
+	if (ieee80211_is_ctl(fc))
+		return RX_CONTINUE;
+
+	if (skb->len < 24)
+		return RX_CONTINUE;
+
+	presp = ieee80211_is_probe_resp(fc);
+	if (presp) {
+		/* ignore ProbeResp to foreign address */
+		if (memcmp(mgmt->da, sdata->vif.addr, ETH_ALEN))
+			return RX_DROP_MONITOR;
+
+		presp = true;
+		elements = mgmt->u.probe_resp.variable;
+		baselen = offsetof(struct ieee80211_mgmt, u.probe_resp.variable);
+	} else {
+		beacon = ieee80211_is_beacon(fc);
+		baselen = offsetof(struct ieee80211_mgmt, u.beacon.variable);
+		elements = mgmt->u.beacon.variable;
+	}
+
+	if (!presp && !beacon)
+		return RX_CONTINUE;
+
+	if (baselen > skb->len)
+		return RX_DROP_MONITOR;
+
+	mac802_11_parse_elems(elements, skb->len - baselen, &elems);
+
+	if (elems.ds_params && elems.ds_params_len == 1)
+		freq = ieee80211_channel_to_frequency(elems.ds_params[0],
+						      rx_status->band);
+	else
+		freq = rx_status->freq;
+
+	channel = ieee80211_get_channel(sdata->local->hw.wiphy, freq);
+
+	if (!channel || channel->flags & IEEE80211_CHAN_DISABLED)
+		return RX_DROP_MONITOR;
+
+	bss = mac80211_bss_info_update(sdata->local, rx_status,
+					mgmt, skb->len, &elems,
+					channel, beacon);
+	if (bss)
+		mac80211_rx_bss_put(sdata->local, bss);
+
+	dev_kfree_skb(skb);
+	return RX_QUEUED;
+}
+
+/* return false if no more work */
+static bool ieee80211_prep_hw_scan(struct ieee80211_local *local)
+{
+	struct cfg80211_scan_request *req = local->scan_req;
+	enum nl80211_band band;
+	int i, ielen, n_chans;
+
+	do {
+		if (local->hw_scan_band == NUM_NL80211_BANDS)
+			return false;
+
+		band = local->hw_scan_band;
+		n_chans = 0;
+		for (i = 0; i < req->n_channels; i++) {
+			if (req->channels[i]->band == band) {
+				local->hw_scan_req->channels[n_chans] =
+							req->channels[i];
+				n_chans++;
+			}
+		}
+
+		local->hw_scan_band++;
+	} while (!n_chans);
+
+	local->hw_scan_req->n_channels = n_chans;
+
+	ielen = mac80211_build_preq_ies(local, (u8 *)local->hw_scan_req->ie,
+					 req->ie, req->ie_len, band,
+					 req->rates[band], 0);
+	local->hw_scan_req->ie_len = ielen;
+	local->hw_scan_req->no_cck = req->no_cck;
+
+	return true;
+}
+
+static void __mac80211_scan_completed(struct ieee80211_hw *hw, bool aborted,
+				       bool was_hw_scan)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct ieee80211_sub_if_data *sdata;
+	struct cfg80211_scan_request *scan_req;
+
+	lockdep_assert_held(&local->mtx);
+
+	/*
+	 * It's ok to abort a not-yet-running scan (that
+	 * we have one at all will be verified by checking
+	 * local->scan_req next), but not to complete it
+	 * successfully.
+	 */
+	if (WARN_ON(!local->scanning && !aborted))
+		aborted = true;
+
+	if (WARN_ON(!local->scan_req))
+		return;
+
+	if (was_hw_scan && !aborted && ieee80211_prep_hw_scan(local)) {
+		int rc = drv_hw_scan(local, local->scan_sdata, local->hw_scan_req);
+		if (rc == 0)
+			return;
+	}
+
+	kfree(local->hw_scan_req);
+	local->hw_scan_req = NULL;
+
+	scan_req = rcu_dereference_protected(local->scan_req,
+					     lockdep_is_held(&local->mtx));
+
+	if (local->scan_req != local->int_scan_req) {
+		local->scan_info.aborted = aborted;
+		cfg80211_scan_done(scan_req, &local->scan_info);
+	}
+	local->scan_req = NULL;
+	sdata = local->scan_sdata;
+	local->scan_sdata = NULL;
+
+	local->scanning = 0;
+	local->scan_channel = NULL;
+
+	mac80211_hw_config(local, IEEE80211_CONF_CHANGE_CHANNEL);
+	/*scan stuck kernel panic wa*/
+	if (!was_hw_scan && !aborted) {
+		mac80211_configure_filter(sdata);
+		drv_sw_scan_complete(local);
+		mac80211_offchannel_return(local, true);
+	}
+
+	mac80211_recalc_idle(local);
+
+	mac80211_mlme_notify_scan_completed(local);
+	mac80211_ibss_notify_scan_completed(local);
+	mac80211_mesh_notify_scan_completed(local);
+	mac80211_start_next_roc(local);
+	mac80211_queue_work(&local->hw, &local->work_work);
+}
+
+void mac80211_scan_completed(struct ieee80211_hw *hw,
+			      struct cfg80211_scan_info *info)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+
+	trace_api_scan_completed(local, info->aborted);
+
+	set_bit(SCAN_COMPLETED, &local->scanning);
+	if (info->aborted)
+		set_bit(SCAN_ABORTED, &local->scanning);
+	memcpy(&local->scan_info, info, sizeof(*info));
+	mac80211_queue_delayed_work(&local->hw, &local->scan_work, 0);
+}
+
+static int ieee80211_start_sw_scan(struct ieee80211_local *local)
+{
+	/*
+	 * Hardware/driver doesn't support hw_scan, so use software
+	 * scanning instead. First send a nullfunc frame with power save
+	 * bit on so that AP will buffer the frames for us while we are not
+	 * listening, then send probe requests to each channel and wait for
+	 * the responses. After all channels are scanned, tune back to the
+	 * original channel and send a nullfunc frame with power save bit
+	 * off to trigger the AP to send us all the buffered frames.
+	 *
+	 * Note that while local->sw_scanning is true everything else but
+	 * nullfunc frames and probe requests will be dropped in
+	 * ieee80211_tx_h_check_assoc().
+	 */
+	drv_sw_scan_start(local);
+
+	ieee80211_offchannel_stop_beaconing(local);
+
+	local->leave_oper_channel_time = 0;
+	local->next_scan_state = SCAN_DECISION;
+	local->scan_channel_idx = 0;
+
+	drv_flush(local, local->scan_sdata, false);
+
+	mac80211_configure_filter(local->scan_sdata);
+
+	/* We need to set power level at maximum rate for scanning. */
+	mac80211_hw_config(local, 0);
+
+	mac80211_queue_delayed_work(&local->hw,
+				     &local->scan_work,
+				     IEEE80211_CHANNEL_TIME);
+
+	return 0;
+}
+
+
+static int __ieee80211_start_scan(struct ieee80211_sub_if_data *sdata,
+				  struct cfg80211_scan_request *req)
+{
+	struct ieee80211_local *local = sdata->local;
+	int rc;
+
+	lockdep_assert_held(&local->mtx);
+
+	if (local->scan_req)
+		return -EBUSY;
+
+	if (!list_empty(&local->roc_list))
+		return -EBUSY;
+
+	if (!list_empty(&local->work_list)) {
+		/* wait for the work to finish/time out */
+		local->scan_req = req;
+		local->scan_sdata = sdata;
+		return 0;
+	}
+
+	if (local->ops->hw_scan) {
+		u8 *ies;
+
+		local->hw_scan_req = kmalloc(
+				sizeof(*local->hw_scan_req) +
+				req->n_channels * sizeof(req->channels[0]) +
+				2 + IEEE80211_MAX_SSID_LEN + local->scan_ies_len +
+				req->ie_len, GFP_KERNEL);
+		if (!local->hw_scan_req)
+			return -ENOMEM;
+
+		local->hw_scan_req->ssids = req->ssids;
+		local->hw_scan_req->n_ssids = req->n_ssids;
+		ies = (u8 *)local->hw_scan_req +
+			sizeof(*local->hw_scan_req) +
+			req->n_channels * sizeof(req->channels[0]);
+		local->hw_scan_req->ie = ies;
+
+		local->hw_scan_band = 0;
+
+		/*
+		 * After allocating local->hw_scan_req, we must
+		 * go through until ieee80211_prep_hw_scan(), so
+		 * anything that might be changed here and leave
+		 * this function early must not go after this
+		 * allocation.
+		 */
+	}
+
+	local->scan_req = req;
+	local->scan_sdata = sdata;
+
+	if (local->ops->hw_scan)
+		__set_bit(SCAN_HW_SCANNING, &local->scanning);
+	else
+		__set_bit(SCAN_SW_SCANNING, &local->scanning);
+
+	mac80211_recalc_idle(local);
+
+	if (local->ops->hw_scan) {
+		WARN_ON(!ieee80211_prep_hw_scan(local));
+		rc = drv_hw_scan(local, sdata, local->hw_scan_req);
+	} else
+		rc = ieee80211_start_sw_scan(local);
+
+	if (rc) {
+		kfree(local->hw_scan_req);
+		local->hw_scan_req = NULL;
+		local->scanning = 0;
+
+		mac80211_recalc_idle(local);
+
+		local->scan_req = NULL;
+		local->scan_sdata = NULL;
+	}
+
+	return rc;
+}
+
+static unsigned long
+ieee80211_scan_get_channel_time(struct ieee80211_channel *chan)
+{
+	/*
+	 * TODO: channel switching also consumes quite some time,
+	 * add that delay as well to get a better estimation
+	 */
+	if (chan->flags & (IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_RADAR))
+		return IEEE80211_PASSIVE_CHANNEL_TIME;
+	return IEEE80211_PROBE_DELAY + IEEE80211_CHANNEL_TIME;
+}
+
+static void ieee80211_scan_state_decision(struct ieee80211_local *local,
+					  unsigned long *next_delay)
+{
+	bool associated = false;
+	bool tx_empty = true;
+	bool bad_latency;
+	bool listen_int_exceeded = 0;
+	unsigned long min_beacon_int = 0;
+	struct ieee80211_sub_if_data *sdata;
+	struct ieee80211_channel *next_chan;
+
+	/*
+	 * check if at least one STA interface is associated,
+	 * check if at least one STA interface has pending tx frames
+	 * and grab the lowest used beacon interval
+	 */
+	mutex_lock(&local->iflist_mtx);
+	list_for_each_entry(sdata, &local->interfaces, list) {
+		if (!ieee80211_sdata_running(sdata))
+			continue;
+
+		if (sdata->vif.type == NL80211_IFTYPE_STATION) {
+			if (sdata->u.mgd.associated) {
+				associated = true;
+
+				if (sdata->vif.bss_conf.beacon_int <
+				    min_beacon_int || min_beacon_int == 0)
+					min_beacon_int =
+						sdata->vif.bss_conf.beacon_int;
+
+				if (!qdisc_all_tx_empty(sdata->dev)) {
+					tx_empty = false;
+					break;
+				}
+			}
+		}
+	}
+	mutex_unlock(&local->iflist_mtx);
+
+	if (local->scan_channel) {
+		/*
+		 * we're currently scanning a different channel, let's
+		 * see if we can scan another channel without interfering
+		 * with the current traffic situation.
+		 *
+		 * Since we don't know if the AP has pending frames for us
+		 * we can only check for our tx queues and use the current
+		 * pm_qos requirements for rx. Hence, if no tx traffic occurs
+		 * at all we will scan as many channels in a row as the pm_qos
+		 * latency allows us to. Additionally we also check for the
+		 * currently negotiated listen interval to prevent losing
+		 * frames unnecessarily.
+		 *
+		 * Otherwise switch back to the operating channel.
+		 */
+		next_chan = local->scan_req->channels[local->scan_channel_idx];
+
+		bad_latency = time_after(jiffies +
+				ieee80211_scan_get_channel_time(next_chan),
+				local->leave_oper_channel_time +
+				usecs_to_jiffies(xr_pm_qos_request(PM_QOS_NETWORK_LATENCY)));
+
+		list_for_each_entry(sdata, &local->interfaces, list) {
+			listen_int_exceeded = time_after(jiffies +
+					ieee80211_scan_get_channel_time(next_chan),
+					local->leave_oper_channel_time + /* XXX: leave_oper_channel_time ?*/
+					usecs_to_jiffies(min_beacon_int * 1024) *
+					sdata->vif.bss_conf.listen_interval);
+			if (listen_int_exceeded)
+				break;
+		}
+
+		if (associated && (!tx_empty || bad_latency ||
+		    listen_int_exceeded))
+			local->next_scan_state = SCAN_ENTER_OPER_CHANNEL;
+		else
+			local->next_scan_state = SCAN_SET_CHANNEL;
+	} else {
+		/*
+		 * we're on the operating channel currently, let's
+		 * leave that channel now to scan another one
+		 */
+		local->next_scan_state = SCAN_LEAVE_OPER_CHANNEL;
+	}
+
+	*next_delay = 0;
+}
+
+static void ieee80211_scan_state_leave_oper_channel(struct ieee80211_local *local,
+						    unsigned long *next_delay)
+{
+	struct ieee80211_sub_if_data *sdata;
+	ieee80211_offchannel_stop_station(local);
+
+	__set_bit(SCAN_OFF_CHANNEL, &local->scanning);
+
+	/*
+	 * What if the nullfunc frames didn't arrive?
+	 */
+	mutex_lock(&local->iflist_mtx);
+
+	list_for_each_entry(sdata, &local->interfaces, list)
+		drv_flush(local, sdata, false);
+
+	mutex_unlock(&local->iflist_mtx);
+	if (local->ops->flush)
+		*next_delay = 0;
+	else
+		*next_delay = HZ / 10;
+
+	/* remember when we left the operating channel */
+	local->leave_oper_channel_time = jiffies;
+
+	/* advance to the next channel to be scanned */
+	local->next_scan_state = SCAN_SET_CHANNEL;
+}
+
+static void ieee80211_scan_state_enter_oper_channel(struct ieee80211_local *local,
+						    unsigned long *next_delay)
+{
+	/* switch back to the operating channel */
+	local->scan_channel = NULL;
+	mac80211_hw_config(local, IEEE80211_CONF_CHANGE_CHANNEL);
+
+	/*
+	 * Only re-enable station mode interface now; beaconing will be
+	 * re-enabled once the full scan has been completed.
+	 */
+	mac80211_offchannel_return(local, false);
+
+	__clear_bit(SCAN_OFF_CHANNEL, &local->scanning);
+
+	*next_delay = HZ / 5;
+	local->next_scan_state = SCAN_DECISION;
+}
+
+static void ieee80211_scan_state_set_channel(struct ieee80211_local *local,
+					     unsigned long *next_delay)
+{
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, local->scan_sdata);
+	int skip;
+	struct ieee80211_channel *chan;
+
+	skip = 0;
+	chan = local->scan_req->channels[local->scan_channel_idx];
+
+	local->scan_channel = chan;
+
+	/* Only call hw-config if we really need to change channels. */
+	if (chan != chan_state->conf.channel)
+		if (mac80211_hw_config(local, IEEE80211_CONF_CHANGE_CHANNEL))
+			skip = 1;
+
+	/* advance state machine to next channel/band */
+	local->scan_channel_idx++;
+
+	if (skip) {
+		/* if we skip this channel return to the decision state */
+		local->next_scan_state = SCAN_DECISION;
+		return;
+	}
+
+	/*
+	 * Probe delay is used to update the NAV, cf. 11.1.3.2.2
+	 * (which unfortunately doesn't say _why_ step a) is done,
+	 * but it waits for the probe delay or until a frame is
+	 * received - and the received frame would update the NAV).
+	 * For now, we do not support waiting until a frame is
+	 * received.
+	 *
+	 * In any case, it is not necessary for a passive scan.
+	 */
+	if ((chan->flags & (IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_RADAR)) ||
+	    !local->scan_req->n_ssids) {
+		*next_delay = IEEE80211_PASSIVE_CHANNEL_TIME;
+		local->next_scan_state = SCAN_DECISION;
+		return;
+	}
+
+	/* active scan, send probes */
+	*next_delay = IEEE80211_PROBE_DELAY;
+	local->next_scan_state = SCAN_SEND_PROBE;
+}
+
+static void ieee80211_scan_state_send_probe(struct ieee80211_local *local,
+					    unsigned long *next_delay)
+{
+	int i;
+	struct ieee80211_sub_if_data *sdata = local->scan_sdata;
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sdata);
+	enum nl80211_band band = chan_state->conf.channel->band;
+
+	for (i = 0; i < local->scan_req->n_ssids; i++)
+		mac80211_send_probe_req(
+			sdata, NULL,
+			local->scan_req->ssids[i].ssid,
+			local->scan_req->ssids[i].ssid_len,
+			local->scan_req->ie, local->scan_req->ie_len,
+			local->scan_req->rates[band], false,
+			local->scan_req->no_cck);
+
+	/*
+	 * After sending probe requests, wait for probe responses
+	 * on the channel.
+	 */
+	*next_delay = IEEE80211_CHANNEL_TIME;
+	local->next_scan_state = SCAN_DECISION;
+}
+
+void mac80211_scan_work(struct work_struct *work)
+{
+	struct ieee80211_local *local =
+		container_of(work, struct ieee80211_local, scan_work.work);
+	struct ieee80211_sub_if_data *sdata;
+	unsigned long next_delay = 0;
+	bool aborted, hw_scan;
+
+	mutex_lock(&local->mtx);
+
+	sdata = local->scan_sdata;
+
+	if (test_and_clear_bit(SCAN_COMPLETED, &local->scanning)) {
+		aborted = test_and_clear_bit(SCAN_ABORTED, &local->scanning);
+		goto out_complete;
+	}
+
+	if (!sdata || !local->scan_req)
+		goto out;
+
+	if (local->scan_req && !local->scanning) {
+		struct cfg80211_scan_request *req = local->scan_req;
+		int rc;
+
+		local->scan_req = NULL;
+		local->scan_sdata = NULL;
+
+		rc = __ieee80211_start_scan(sdata, req);
+		if (rc) {
+			/* need to complete scan in cfg80211 */
+			local->scan_req = req;
+			aborted = true;
+			goto out_complete;
+		} else
+			goto out;
+	}
+
+	/*
+	 * Avoid re-scheduling when the sdata is going away.
+	 */
+	if (!ieee80211_sdata_running(sdata)) {
+		aborted = true;
+		goto out_complete;
+	}
+
+	/*
+	 * as long as no delay is required advance immediately
+	 * without scheduling a new work
+	 */
+	do {
+		if (!ieee80211_sdata_running(sdata)) {
+			aborted = true;
+			goto out_complete;
+		}
+
+		switch (local->next_scan_state) {
+		case SCAN_DECISION:
+			/* if no more bands/channels left, complete scan */
+			if (local->scan_channel_idx >= local->scan_req->n_channels) {
+				aborted = false;
+				goto out_complete;
+			}
+			ieee80211_scan_state_decision(local, &next_delay);
+			break;
+		case SCAN_SET_CHANNEL:
+			ieee80211_scan_state_set_channel(local, &next_delay);
+			break;
+		case SCAN_SEND_PROBE:
+			ieee80211_scan_state_send_probe(local, &next_delay);
+			break;
+		case SCAN_LEAVE_OPER_CHANNEL:
+			ieee80211_scan_state_leave_oper_channel(local, &next_delay);
+			break;
+		case SCAN_ENTER_OPER_CHANNEL:
+			ieee80211_scan_state_enter_oper_channel(local, &next_delay);
+			break;
+		}
+	} while (next_delay == 0);
+
+	mac80211_queue_delayed_work(&local->hw, &local->scan_work, next_delay);
+	goto out;
+
+out_complete:
+	hw_scan = test_bit(SCAN_HW_SCANNING, &local->scanning);
+	__mac80211_scan_completed(&local->hw, aborted, hw_scan);
+out:
+	mutex_unlock(&local->mtx);
+}
+
+int mac80211_request_scan(struct ieee80211_sub_if_data *sdata,
+			   struct cfg80211_scan_request *req)
+{
+	int res;
+
+	mutex_lock(&sdata->local->mtx);
+	res = __ieee80211_start_scan(sdata, req);
+	mutex_unlock(&sdata->local->mtx);
+
+	return res;
+}
+
+int ieee80211_request_internal_scan(struct ieee80211_sub_if_data *sdata,
+				    const u8 *ssid, u8 ssid_len,
+				    struct ieee80211_channel *chan)
+{
+	struct ieee80211_local *local = sdata->local;
+	int ret = -EBUSY;
+	enum nl80211_band band;
+
+	mutex_lock(&local->mtx);
+
+	/* busy scanning */
+	if (local->scan_req)
+		goto unlock;
+
+	/* fill internal scan request */
+	if (!chan) {
+		int i, nchan = 0;
+
+		for (band = 0; band < NUM_NL80211_BANDS; band++) {
+			if (!local->hw.wiphy->bands[band])
+				continue;
+			for (i = 0;
+			     i < local->hw.wiphy->bands[band]->n_channels;
+			     i++) {
+				local->int_scan_req->channels[nchan] =
+				    &local->hw.wiphy->bands[band]->channels[i];
+				nchan++;
+			}
+		}
+
+		local->int_scan_req->n_channels = nchan;
+	} else {
+		local->int_scan_req->channels[0] = chan;
+		local->int_scan_req->n_channels = 1;
+	}
+
+	local->int_scan_req->ssids = &local->scan_ssid;
+	local->int_scan_req->n_ssids = 1;
+	memcpy(local->int_scan_req->ssids[0].ssid, ssid, IEEE80211_MAX_SSID_LEN);
+	local->int_scan_req->ssids[0].ssid_len = ssid_len;
+
+	ret = __ieee80211_start_scan(sdata, sdata->local->int_scan_req);
+ unlock:
+	mutex_unlock(&local->mtx);
+	return ret;
+}
+
+/*
+ * Only call this function when a scan can't be queued -- under RTNL.
+ */
+void mac80211_scan_cancel(struct ieee80211_local *local)
+{
+	/*
+	 * We are canceling software scan, or deferred scan that was not
+	 * yet really started (see __ieee80211_start_scan ).
+	 *
+	 * Regarding hardware scan:
+	 * - we can not call  __mac80211_scan_completed() as when
+	 *   SCAN_HW_SCANNING bit is set this function change
+	 *   local->hw_scan_req to operate on 5G band, what race with
+	 *   driver which can use local->hw_scan_req
+	 *
+	 * - we can not cancel scan_work since driver can schedule it
+	 *   by mac80211_scan_completed(..., true) to finish scan
+	 *
+	 * Hence we only call the cancel_hw_scan() callback, but the low-level
+	 * driver is still responsible for calling mac80211_scan_completed()
+	 * after the scan was completed/aborted.
+	 */
+
+	mutex_lock(&local->mtx);
+	if (!local->scan_req)
+		goto out;
+
+	if (test_bit(SCAN_HW_SCANNING, &local->scanning)) {
+		if (local->ops->cancel_hw_scan)
+			drv_cancel_hw_scan(local, local->scan_sdata);
+		goto out;
+	}
+
+	/*
+	 * If the work is currently running, it must be blocked on
+	 * the mutex, but we'll set scan_sdata = NULL and it'll
+	 * simply exit once it acquires the mutex.
+	 */
+	cancel_delayed_work(&local->scan_work);
+	/* and clean up */
+	__mac80211_scan_completed(&local->hw, true, false);
+out:
+	mutex_unlock(&local->mtx);
+}
+
+int mac80211_request_sched_scan_start(struct ieee80211_sub_if_data *sdata,
+				       struct cfg80211_sched_scan_request *req)
+{
+	struct ieee80211_local *local = sdata->local;
+	int ret, i;
+
+	mutex_lock(&sdata->local->mtx);
+
+	if (local->sched_scanning) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	if (!local->ops->sched_scan_start) {
+		ret = -ENOTSUPP;
+		goto out;
+	}
+
+	for (i = 0; i < NUM_NL80211_BANDS; i++) {
+#ifdef ROAM_OFFLOAD
+		if (!local->hw.wiphy->bands[i])
+			continue;
+#endif /*ROAM_OFFLOAD*/
+		local->sched_scan_ies.ie[i] = kzalloc(2 +
+						      IEEE80211_MAX_SSID_LEN +
+						      local->scan_ies_len +
+						      req->ie_len,
+						      GFP_KERNEL);
+		if (!local->sched_scan_ies.ie[i]) {
+			ret = -ENOMEM;
+			goto out_free;
+		}
+
+		local->sched_scan_ies.len[i] =
+			mac80211_build_preq_ies(local,
+						 local->sched_scan_ies.ie[i],
+						 req->ie, req->ie_len, i,
+						 (u32) -1, 0);
+	}
+
+	ret = drv_sched_scan_start(local, sdata, req,
+				   &local->sched_scan_ies);
+	if (ret == 0) {
+		local->sched_scanning = true;
+		goto out;
+	}
+
+out_free:
+	while (i > 0)
+		kfree(local->sched_scan_ies.ie[--i]);
+out:
+	mutex_unlock(&sdata->local->mtx);
+	return ret;
+}
+
+int mac80211_request_sched_scan_stop(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_local *local = sdata->local;
+	int ret = 0, i;
+
+	mutex_lock(&sdata->local->mtx);
+
+	if (!local->ops->sched_scan_stop) {
+		ret = -ENOTSUPP;
+		goto out;
+	}
+
+	if (local->sched_scanning) {
+		for (i = 0; i < NUM_NL80211_BANDS; i++)
+			kfree(local->sched_scan_ies.ie[i]);
+
+		drv_sched_scan_stop(local, sdata);
+		local->sched_scanning = false;
+	}
+out:
+	mutex_unlock(&sdata->local->mtx);
+
+	return ret;
+}
+
+void mac80211_sched_scan_results(struct ieee80211_hw *hw)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+
+#ifdef ROAM_OFFLOAD
+	if (local->sched_scanning) {
+		local->sched_scanning = false;
+		return;
+	}
+#endif /*ROAM_OFFLOAD*/
+
+	trace_api_sched_scan_results(local);
+
+	cfg80211_sched_scan_results(hw->wiphy, 0);
+}
+
+void mac80211_sched_scan_stopped_work(struct work_struct *work)
+{
+	struct ieee80211_local *local =
+		container_of(work, struct ieee80211_local,
+			     sched_scan_stopped_work);
+	int i;
+
+	mutex_lock(&local->mtx);
+
+	if (!local->sched_scanning) {
+		mutex_unlock(&local->mtx);
+		return;
+	}
+
+	for (i = 0; i < NUM_NL80211_BANDS; i++)
+		kfree(local->sched_scan_ies.ie[i]);
+
+	local->sched_scanning = false;
+
+	mutex_unlock(&local->mtx);
+
+	cfg80211_sched_scan_stopped(local->hw.wiphy, 0);
+}
+
+void mac80211_sched_scan_stopped(struct ieee80211_hw *hw)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+
+	trace_api_sched_scan_stopped(local);
+
+	mac80211_queue_work(&local->hw, &local->sched_scan_stopped_work);
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/spectmgmt.c b/drivers/net/wireless/xr829/umac/spectmgmt.c
--- a/drivers/net/wireless/xr829/umac/spectmgmt.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/spectmgmt.c	2022-08-27 01:22:42.954539862 +0300
@@ -0,0 +1,82 @@
+/*
+ * spectrum management
+ *
+ * Copyright 2003, Jouni Malinen <jkmaline@cc.hut.fi>
+ * Copyright 2002-2005, Instant802 Networks, Inc.
+ * Copyright 2005-2006, Devicescape Software, Inc.
+ * Copyright 2006-2007  Jiri Benc <jbenc@suse.cz>
+ * Copyright 2007, Michael Wu <flamingice@sourmilk.net>
+ * Copyright 2007-2008, Intel Corporation
+ * Copyright 2008, Johannes Berg <johannes@sipsolutions.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/ieee80211.h>
+#include <net/cfg80211.h>
+#include <net/mac80211.h>
+#include "ieee80211_i.h"
+#include "sta_info.h"
+#include "wme.h"
+
+static void ieee80211_send_refuse_measurement_request(struct ieee80211_sub_if_data *sdata,
+					struct ieee80211_msrment_ie *request_ie,
+					const u8 *da, const u8 *bssid,
+					u8 dialog_token)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct sk_buff *skb;
+	struct ieee80211_mgmt *msr_report;
+
+	skb = dev_alloc_skb(sizeof(*msr_report) + local->hw.extra_tx_headroom +
+				sizeof(struct ieee80211_msrment_ie));
+	if (!skb)
+		return;
+
+	skb_reserve(skb, local->hw.extra_tx_headroom);
+	msr_report = (struct ieee80211_mgmt *)skb_put(skb, 24);
+	memset(msr_report, 0, 24);
+	memcpy(msr_report->da, da, ETH_ALEN);
+	memcpy(msr_report->sa, sdata->vif.addr, ETH_ALEN);
+	memcpy(msr_report->bssid, bssid, ETH_ALEN);
+	msr_report->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+						IEEE80211_STYPE_ACTION);
+
+	skb_put(skb, 1 + sizeof(msr_report->u.action.u.measurement));
+	msr_report->u.action.category = WLAN_CATEGORY_SPECTRUM_MGMT;
+	msr_report->u.action.u.measurement.action_code =
+				WLAN_ACTION_SPCT_MSR_RPRT;
+	msr_report->u.action.u.measurement.dialog_token = dialog_token;
+
+	msr_report->u.action.u.measurement.element_id = WLAN_EID_MEASURE_REPORT;
+	msr_report->u.action.u.measurement.length =
+			sizeof(struct ieee80211_msrment_ie);
+
+	memset(&msr_report->u.action.u.measurement.msr_elem, 0,
+		sizeof(struct ieee80211_msrment_ie));
+	msr_report->u.action.u.measurement.msr_elem.token = request_ie->token;
+	msr_report->u.action.u.measurement.msr_elem.mode |=
+			IEEE80211_SPCT_MSR_RPRT_MODE_REFUSED;
+	msr_report->u.action.u.measurement.msr_elem.type = request_ie->type;
+
+	ieee80211_tx_skb(sdata, skb);
+}
+
+void mac80211_process_measurement_req(struct ieee80211_sub_if_data *sdata,
+				       struct ieee80211_mgmt *mgmt,
+				       size_t len)
+{
+	/*
+	 * Ignoring measurement request is spec violation.
+	 * Mandatory measurements must be reported optional
+	 * measurements might be refused or reported incapable
+	 * For now just refuse
+	 * TODO: Answer basic measurement as unmeasured
+	 */
+	ieee80211_send_refuse_measurement_request(sdata,
+			&mgmt->u.action.u.measurement.msr_elem,
+			mgmt->sa, mgmt->bssid,
+			mgmt->u.action.u.measurement.dialog_token);
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/sta_info.c b/drivers/net/wireless/xr829/umac/sta_info.c
--- a/drivers/net/wireless/xr829/umac/sta_info.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/sta_info.c	2022-08-27 01:22:42.954539862 +0300
@@ -0,0 +1,1574 @@
+/*
+ * Copyright 2002-2005, Instant802 Networks, Inc.
+ * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/timer.h>
+#include <linux/rtnetlink.h>
+#include <linux/time64.h>
+
+#include <net/mac80211.h>
+#include "ieee80211_i.h"
+#include "driver-ops.h"
+#include "rate.h"
+#include "sta_info.h"
+#include "debugfs_sta.h"
+#include "mesh.h"
+#include "wme.h"
+
+/**
+ * DOC: STA information lifetime rules
+ *
+ * STA info structures (&struct sta_info) are managed in a hash table
+ * for faster lookup and a list for iteration. They are managed using
+ * RCU, i.e. access to the list and hash table is protected by RCU.
+ *
+ * Upon allocating a STA info structure with xrmac_sta_info_alloc(), the caller
+ * owns that structure. It must then insert it into the hash table using
+ * either xrmac_sta_info_insert() or xrmac_sta_info_insert_rcu(); only in the latter
+ * case (which acquires an rcu read section but must not be called from
+ * within one) will the pointer still be valid after the call. Note that
+ * the caller may not do much with the STA info before inserting it, in
+ * particular, it may not start any mesh peer link management or add
+ * encryption keys.
+ *
+ * When the insertion fails (xrmac_sta_info_insert()) returns non-zero), the
+ * structure will have been freed by xrmac_sta_info_insert()!
+ *
+ * Station entries are added by mac80211 when you establish a link with a
+ * peer. This means different things for the different type of interfaces
+ * we support. For a regular station this mean we add the AP sta when we
+ * receive an association response from the AP. For IBSS this occurs when
+ * get to know about a peer on the same IBSS. For WDS we add the sta for
+ * the peer immediately upon device open. When using AP mode we add stations
+ * for each respective station upon request from userspace through nl80211.
+ *
+ * In order to remove a STA info structure, various sta_info_destroy_*()
+ * calls are available.
+ *
+ * There is no concept of ownership on a STA entry, each structure is
+ * owned by the global hash table/list until it is removed. All users of
+ * the structure need to be RCU protected so that the structure won't be
+ * freed before they are done using it.
+ */
+
+/* Caller must hold local->sta_lock */
+static int sta_info_hash_del(struct ieee80211_local *local,
+			     struct sta_info *sta)
+{
+	struct sta_info *s;
+
+	s = rcu_dereference_protected(local->sta_hash[STA_HASH(sta->sta.addr)],
+				      lockdep_is_held(&local->sta_lock));
+	if (!s)
+		return -ENOENT;
+	if (s == sta) {
+		rcu_assign_pointer(local->sta_hash[STA_HASH(sta->sta.addr)],
+				   s->hnext);
+		return 0;
+	}
+
+	while (rcu_access_pointer(s->hnext) &&
+	       rcu_access_pointer(s->hnext) != sta)
+		s = rcu_dereference_protected(s->hnext,
+					lockdep_is_held(&local->sta_lock));
+	if (rcu_access_pointer(s->hnext)) {
+		rcu_assign_pointer(s->hnext, sta->hnext);
+		return 0;
+	}
+
+	return -ENOENT;
+}
+
+/* protected by RCU */
+struct sta_info *xrmac_sta_info_get(struct ieee80211_sub_if_data *sdata,
+			      const u8 *addr)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct sta_info *sta;
+
+	sta = rcu_dereference_check(local->sta_hash[STA_HASH(addr)],
+				    lockdep_is_held(&local->sta_lock) ||
+				    lockdep_is_held(&local->sta_mtx));
+	while (sta) {
+		if (sta->sdata == sdata && !sta->dummy &&
+		    memcmp(sta->sta.addr, addr, ETH_ALEN) == 0)
+			break;
+		sta = rcu_dereference_check(sta->hnext,
+					    lockdep_is_held(&local->sta_lock) ||
+					    lockdep_is_held(&local->sta_mtx));
+	}
+	return sta;
+}
+
+/* get a station info entry even if it is a dummy station*/
+struct sta_info *xrmac_sta_info_get_rx(struct ieee80211_sub_if_data *sdata,
+			      const u8 *addr)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct sta_info *sta;
+
+	sta = rcu_dereference_check(local->sta_hash[STA_HASH(addr)],
+				    lockdep_is_held(&local->sta_lock) ||
+				    lockdep_is_held(&local->sta_mtx));
+	while (sta) {
+		if (sta->sdata == sdata &&
+		    memcmp(sta->sta.addr, addr, ETH_ALEN) == 0)
+			break;
+		sta = rcu_dereference_check(sta->hnext,
+					    lockdep_is_held(&local->sta_lock) ||
+					    lockdep_is_held(&local->sta_mtx));
+	}
+	return sta;
+}
+
+/*
+ * Get sta info either from the specified interface
+ * or from one of its vlans
+ */
+struct sta_info *xrmac_sta_info_get_bss(struct ieee80211_sub_if_data *sdata,
+				  const u8 *addr)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct sta_info *sta;
+
+	sta = rcu_dereference_check(local->sta_hash[STA_HASH(addr)],
+				    lockdep_is_held(&local->sta_lock) ||
+				    lockdep_is_held(&local->sta_mtx));
+	while (sta) {
+		if ((sta->sdata == sdata ||
+		     (sta->sdata->bss && sta->sdata->bss == sdata->bss)) &&
+		    !sta->dummy &&
+		    memcmp(sta->sta.addr, addr, ETH_ALEN) == 0)
+			break;
+		sta = rcu_dereference_check(sta->hnext,
+					    lockdep_is_held(&local->sta_lock) ||
+					    lockdep_is_held(&local->sta_mtx));
+	}
+	return sta;
+}
+
+/*
+ * Get sta info either from the specified interface
+ * or from one of its vlans (including dummy stations)
+ */
+struct sta_info *xrmac_sta_info_get_bss_rx(struct ieee80211_sub_if_data *sdata,
+				  const u8 *addr)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct sta_info *sta;
+
+	sta = rcu_dereference_check(local->sta_hash[STA_HASH(addr)],
+				    lockdep_is_held(&local->sta_lock) ||
+				    lockdep_is_held(&local->sta_mtx));
+	while (sta) {
+		if ((sta->sdata == sdata ||
+		     (sta->sdata->bss && sta->sdata->bss == sdata->bss)) &&
+		    memcmp(sta->sta.addr, addr, ETH_ALEN) == 0)
+			break;
+		sta = rcu_dereference_check(sta->hnext,
+					    lockdep_is_held(&local->sta_lock) ||
+					    lockdep_is_held(&local->sta_mtx));
+	}
+	return sta;
+}
+
+struct sta_info *xrmac_sta_info_get_by_idx(struct ieee80211_sub_if_data *sdata,
+				     int idx)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct sta_info *sta;
+	int i = 0;
+
+	list_for_each_entry_rcu(sta, &local->sta_list, list) {
+		if (sdata != sta->sdata)
+			continue;
+		if (i < idx) {
+			++i;
+			continue;
+		}
+		return sta;
+	}
+
+	return NULL;
+}
+
+/**
+ * __sta_info_free - internal STA free helper
+ *
+ * @local: pointer to the global information
+ * @sta: STA info to free
+ *
+ * This function must undo everything done by xrmac_sta_info_alloc()
+ * that may happen before xrmac_sta_info_insert().
+ */
+static void __sta_info_free(struct ieee80211_local *local,
+			    struct sta_info *sta)
+{
+	if (sta->rate_ctrl) {
+		rate_control_free_sta(sta);
+		rate_control_put(sta->rate_ctrl);
+	}
+
+#ifdef CONFIG_XRMAC_VERBOSE_DEBUG
+	wiphy_debug(local->hw.wiphy, "Destroyed STA %pM\n", sta->sta.addr);
+#endif /* CONFIG_XRMAC_VERBOSE_DEBUG */
+
+	kfree(sta);
+}
+
+#ifdef CONFIG_XRMAC_XR_ROAMING_CHANGES
+static void sta_xrmac_free_work(struct work_struct *wk)
+{
+	struct sta_info *sta = container_of(wk, struct sta_info, sta_free_wk);
+	struct ieee80211_local *local = sta->local;
+
+	cancel_work_sync(&sta->drv_unblock_wk);
+	__sta_info_free(local, sta);
+}
+
+/**
+ * sta_info_free_rcu - STA free rcu callback
+ */
+void sta_info_free_rcu(struct rcu_head *rcu_h)
+{
+	struct sta_info *sta = container_of(rcu_h, struct sta_info, rcu);
+	struct ieee80211_local *local = sta->local;
+	struct ieee80211_hw *hw = local_to_hw(local);
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	rate_control_remove_sta_debugfs(sta);
+	mac80211_sta_debugfs_remove(sta);
+#endif /* CONFIG_XRMAC_DEBUGFS */
+	mac80211_queue_work(hw, &sta->sta_free_wk);
+}
+#endif
+/* Caller must hold local->sta_lock */
+static void sta_info_hash_add(struct ieee80211_local *local,
+			      struct sta_info *sta)
+{
+	sta->hnext = local->sta_hash[STA_HASH(sta->sta.addr)];
+	rcu_assign_pointer(local->sta_hash[STA_HASH(sta->sta.addr)], sta);
+}
+
+static void sta_unblock(struct work_struct *wk)
+{
+	struct sta_info *sta;
+
+	sta = container_of(wk, struct sta_info, drv_unblock_wk);
+
+	if (sta->dead)
+		return;
+
+	if (!test_sta_flag(sta, WLAN_STA_PS_STA))
+		mac80211_sta_ps_deliver_wakeup(sta);
+	else if (test_and_clear_sta_flag(sta, WLAN_STA_PSPOLL)) {
+		clear_sta_flag(sta, WLAN_STA_PS_DRIVER);
+
+		local_bh_disable();
+		mac80211_sta_ps_deliver_poll_response(sta);
+		local_bh_enable();
+	} else if (test_and_clear_sta_flag(sta, WLAN_STA_UAPSD)) {
+		clear_sta_flag(sta, WLAN_STA_PS_DRIVER);
+
+		local_bh_disable();
+		mac80211_sta_ps_deliver_uapsd(sta);
+		local_bh_enable();
+	} else
+		clear_sta_flag(sta, WLAN_STA_PS_DRIVER);
+}
+
+static int sta_prepare_rate_control(struct ieee80211_local *local,
+				    struct sta_info *sta, gfp_t gfp)
+{
+	if (local->hw.flags & IEEE80211_HW_HAS_RATE_CONTROL)
+		return 0;
+
+	sta->rate_ctrl = rate_control_get(local->rate_ctrl);
+	sta->rate_ctrl_priv = rate_control_alloc_sta(sta->rate_ctrl,
+						     &sta->sta, gfp);
+	if (!sta->rate_ctrl_priv) {
+		rate_control_put(sta->rate_ctrl);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+struct sta_info *xrmac_sta_info_alloc(struct ieee80211_sub_if_data *sdata,
+				const u8 *addr, gfp_t gfp)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct sta_info *sta;
+	struct timespec64 uptime;
+	int i;
+
+	sta = kzalloc(sizeof(*sta) + local->hw.sta_data_size, gfp);
+	if (!sta)
+		return NULL;
+
+	spin_lock_init(&sta->lock);
+	spin_lock_init(&sta->ps_lock);
+	INIT_WORK(&sta->drv_unblock_wk, sta_unblock);
+#ifdef CONFIG_XRMAC_XR_ROAMING_CHANGES
+	INIT_WORK(&sta->sta_free_wk, sta_xrmac_free_work);
+#endif
+	INIT_WORK(&sta->ampdu_mlme.work, mac80211_ba_session_work);
+	mutex_init(&sta->ampdu_mlme.mtx);
+
+	memcpy(sta->sta.addr, addr, ETH_ALEN);
+	sta->local = local;
+	sta->sdata = sdata;
+	sta->last_rx = jiffies;
+
+	ktime_get_ts(&uptime);
+	sta->last_connected = uptime.tv_sec;
+	ewma_init(&sta->avg_signal, 1024, 8);
+
+	if (sta_prepare_rate_control(local, sta, gfp)) {
+		kfree(sta);
+		return NULL;
+	}
+
+	for (i = 0; i < STA_TID_NUM; i++) {
+		/*
+		 * timer_to_tid must be initialized with identity mapping
+		 * to enable session_timer's data differentiation. See
+		 * sta_rx_agg_session_timer_expired for usage.
+		 */
+		sta->timer_to_tid[i] = i;
+	}
+	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
+		skb_queue_head_init(&sta->ps_tx_buf[i]);
+		skb_queue_head_init(&sta->tx_filtered[i]);
+	}
+
+	for (i = 0; i < NUM_RX_DATA_QUEUES; i++)
+		sta->last_seq_ctrl[i] = cpu_to_le16(USHRT_MAX);
+
+#ifdef CONFIG_XRMAC_VERBOSE_DEBUG
+	wiphy_debug(local->hw.wiphy, "Allocated STA %pM\n", sta->sta.addr);
+#endif /* CONFIG_XRMAC_VERBOSE_DEBUG */
+
+#ifdef CONFIG_XRMAC_MESH
+	sta->plink_state = NL80211_PLINK_LISTEN;
+	init_timer(&sta->plink_timer);
+#endif
+
+	return sta;
+}
+
+static int sta_info_finish_insert(struct sta_info *sta,
+				bool async, bool dummy_reinsert)
+{
+	struct ieee80211_local *local = sta->local;
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
+	struct station_info sinfo;
+	unsigned long flags;
+	int err = 0;
+
+	lockdep_assert_held(&local->sta_mtx);
+
+	if (!sta->dummy || dummy_reinsert) {
+		/* notify driver */
+		if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
+			sdata = container_of(sdata->bss,
+					     struct ieee80211_sub_if_data,
+					     u.ap);
+		err = drv_sta_add(local, sdata, &sta->sta);
+		if (err) {
+			if (!async)
+				return err;
+			printk(KERN_DEBUG "%s: failed to add IBSS STA %pM to "
+					  "driver (%d) - keeping it anyway.\n",
+			       sdata->name, sta->sta.addr, err);
+		} else {
+			sta->uploaded = true;
+#ifdef CONFIG_XRMAC_VERBOSE_DEBUG
+			if (async)
+				wiphy_debug(local->hw.wiphy,
+					    "Finished adding IBSS STA %pM\n",
+					    sta->sta.addr);
+#endif
+		}
+
+		sdata = sta->sdata;
+	}
+
+	if (!dummy_reinsert) {
+		if (!async) {
+			local->num_sta++;
+			local->sta_generation++;
+			smp_mb();
+
+			/* make the station visible */
+			spin_lock_irqsave(&local->sta_lock, flags);
+			sta_info_hash_add(local, sta);
+			spin_unlock_irqrestore(&local->sta_lock, flags);
+		}
+
+		list_add(&sta->list, &local->sta_list);
+	} else {
+		sta->dummy = false;
+	}
+
+	if (!sta->dummy) {
+#ifdef CONFIG_XRMAC_DEBUGFS
+		mac80211_sta_debugfs_add(sta);
+		rate_control_add_sta_debugfs(sta);
+#endif
+		memset(&sinfo, 0, sizeof(sinfo));
+		sinfo.filled = 0;
+		sinfo.generation = local->sta_generation;
+		cfg80211_new_sta(sdata->dev, sta->sta.addr, &sinfo, GFP_KERNEL);
+	}
+
+	return 0;
+}
+
+static void sta_info_finish_pending(struct ieee80211_local *local)
+{
+	struct sta_info *sta;
+	unsigned long flags;
+
+	spin_lock_irqsave(&local->sta_lock, flags);
+	while (!list_empty(&local->sta_pending_list)) {
+		sta = list_first_entry(&local->sta_pending_list,
+				       struct sta_info, list);
+		list_del(&sta->list);
+		spin_unlock_irqrestore(&local->sta_lock, flags);
+
+		sta_info_finish_insert(sta, true, false);
+
+		spin_lock_irqsave(&local->sta_lock, flags);
+	}
+	spin_unlock_irqrestore(&local->sta_lock, flags);
+}
+
+static void sta_info_finish_work(struct work_struct *work)
+{
+	struct ieee80211_local *local =
+		container_of(work, struct ieee80211_local, sta_finish_work);
+
+	mutex_lock(&local->sta_mtx);
+	sta_info_finish_pending(local);
+	mutex_unlock(&local->sta_mtx);
+}
+
+static int xrmac_sta_info_insert_check(struct sta_info *sta)
+{
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
+
+	/*
+	 * Can't be a WARN_ON because it can be triggered through a race:
+	 * something inserts a STA (on one CPU) without holding the RTNL
+	 * and another CPU turns off the net device.
+	 */
+	if (unlikely(!ieee80211_sdata_running(sdata)))
+		return -ENETDOWN;
+
+	if (WARN_ON(compare_ether_addr(sta->sta.addr, sdata->vif.addr) == 0 ||
+		    is_multicast_ether_addr(sta->sta.addr)))
+		return -EINVAL;
+
+	return 0;
+}
+
+static int xrmac_sta_info_insert_ibss(struct sta_info *sta) __acquires(RCU)
+{
+	struct ieee80211_local *local = sta->local;
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
+	unsigned long flags;
+
+	spin_lock_irqsave(&local->sta_lock, flags);
+	/* check if STA exists already */
+	if (xrmac_sta_info_get_bss_rx(sdata, sta->sta.addr)) {
+		spin_unlock_irqrestore(&local->sta_lock, flags);
+		rcu_read_lock();
+		return -EEXIST;
+	}
+
+	local->num_sta++;
+	local->sta_generation++;
+	smp_mb();
+	sta_info_hash_add(local, sta);
+
+	list_add_tail(&sta->list, &local->sta_pending_list);
+
+	rcu_read_lock();
+	spin_unlock_irqrestore(&local->sta_lock, flags);
+
+#ifdef CONFIG_XRMAC_VERBOSE_DEBUG
+	wiphy_debug(local->hw.wiphy, "Added IBSS STA %pM\n",
+			sta->sta.addr);
+#endif /* CONFIG_XRMAC_VERBOSE_DEBUG */
+
+	mac80211_queue_work(&local->hw, &local->sta_finish_work);
+
+	return 0;
+}
+
+/*
+ * should be called with sta_mtx locked
+ * this function replaces the mutex lock
+ * with a RCU lock
+ */
+static int xrmac_sta_info_insert_non_ibss(struct sta_info *sta) __acquires(RCU)
+{
+	struct ieee80211_local *local = sta->local;
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
+	unsigned long flags;
+	struct sta_info *exist_sta;
+	bool dummy_reinsert = false;
+	int err = 0;
+
+	lockdep_assert_held(&local->sta_mtx);
+
+	/*
+	 * On first glance, this will look racy, because the code
+	 * in this function, which inserts a station with sleeping,
+	 * unlocks the sta_lock between checking existence in the
+	 * hash table and inserting into it.
+	 *
+	 * However, it is not racy against itself because it keeps
+	 * the mutex locked.
+	 */
+
+	spin_lock_irqsave(&local->sta_lock, flags);
+	/*
+	 * check if STA exists already.
+	 * only accept a scenario of a second call to xrmac_sta_info_insert_non_ibss
+	 * with a dummy station entry that was inserted earlier
+	 * in that case - assume that the dummy station flag should
+	 * be removed.
+	 */
+	exist_sta = xrmac_sta_info_get_bss_rx(sdata, sta->sta.addr);
+	if (exist_sta) {
+		if (exist_sta == sta && sta->dummy) {
+			dummy_reinsert = true;
+		} else {
+			spin_unlock_irqrestore(&local->sta_lock, flags);
+			mutex_unlock(&local->sta_mtx);
+			rcu_read_lock();
+			return -EEXIST;
+		}
+	}
+
+	spin_unlock_irqrestore(&local->sta_lock, flags);
+
+	err = sta_info_finish_insert(sta, false, dummy_reinsert);
+	if (err) {
+		mutex_unlock(&local->sta_mtx);
+		rcu_read_lock();
+		return err;
+	}
+
+#ifdef CONFIG_XRMAC_VERBOSE_DEBUG
+	wiphy_debug(local->hw.wiphy, "Inserted %sSTA %pM\n",
+			sta->dummy ? "dummy " : "", sta->sta.addr);
+#endif /* CONFIG_XRMAC_VERBOSE_DEBUG */
+
+	/* move reference to rcu-protected */
+	rcu_read_lock();
+	mutex_unlock(&local->sta_mtx);
+
+	if (ieee80211_vif_is_mesh(&sdata->vif))
+		xrmac_mesh_accept_plinks_update(sdata);
+
+	return 0;
+}
+
+int xrmac_sta_info_insert_rcu(struct sta_info *sta) __acquires(RCU)
+{
+	struct ieee80211_local *local = sta->local;
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
+	int err = 0;
+
+	err = xrmac_sta_info_insert_check(sta);
+	if (err) {
+		rcu_read_lock();
+		goto out_free;
+	}
+
+	/*
+	 * In ad-hoc mode, we sometimes need to insert stations
+	 * from tasklet context from the RX path. To avoid races,
+	 * always do so in that case -- see the comment below.
+	 */
+	if (sdata->vif.type == NL80211_IFTYPE_ADHOC) {
+		err = xrmac_sta_info_insert_ibss(sta);
+		if (err)
+			goto out_free;
+
+		return 0;
+	}
+
+	/*
+	 * It might seem that the function called below is in race against
+	 * the function call above that atomically inserts the station... That,
+	 * however, is not true because the above code can only
+	 * be invoked for IBSS interfaces, and the below code will
+	 * not be -- and the two do not race against each other as
+	 * the hash table also keys off the interface.
+	 */
+
+	might_sleep();
+
+	mutex_lock(&local->sta_mtx);
+
+	err = xrmac_sta_info_insert_non_ibss(sta);
+	if (err)
+		goto out_free;
+
+	return 0;
+ out_free:
+	BUG_ON(!err);
+	__sta_info_free(local, sta);
+	return err;
+}
+
+int xrmac_sta_info_insert(struct sta_info *sta)
+{
+	int err = xrmac_sta_info_insert_rcu(sta);
+
+	rcu_read_unlock();
+
+	return err;
+}
+
+/* Caller must hold sta->local->sta_mtx */
+int sta_info_reinsert(struct sta_info *sta)
+{
+	struct ieee80211_local *local = sta->local;
+	int err = 0;
+
+	err = xrmac_sta_info_insert_check(sta);
+	if (err) {
+		mutex_unlock(&local->sta_mtx);
+		return err;
+	}
+
+	might_sleep();
+
+	err = xrmac_sta_info_insert_non_ibss(sta);
+	rcu_read_unlock();
+	return err;
+}
+
+static inline void __bss_tim_set(struct ieee80211_if_ap *bss, u16 aid)
+{
+	/*
+	 * This format has been mandated by the IEEE specifications,
+	 * so this line may not be changed to use the __set_bit() format.
+	 */
+	bss->tim[aid / 8] |= (1 << (aid % 8));
+}
+
+static inline void __bss_tim_clear(struct ieee80211_if_ap *bss, u16 aid)
+{
+	/*
+	 * This format has been mandated by the IEEE specifications,
+	 * so this line may not be changed to use the __clear_bit() format.
+	 */
+	bss->tim[aid / 8] &= ~(1 << (aid % 8));
+}
+
+static unsigned long ieee80211_tids_for_ac(int ac)
+{
+	/* If we ever support TIDs > 7, this obviously needs to be adjusted */
+	switch (ac) {
+	case IEEE80211_AC_VO:
+		return BIT(6) | BIT(7);
+	case IEEE80211_AC_VI:
+		return BIT(4) | BIT(5);
+	case IEEE80211_AC_BE:
+		return BIT(0) | BIT(3);
+	case IEEE80211_AC_BK:
+		return BIT(1) | BIT(2);
+	default:
+		WARN_ON(1);
+		return 0;
+	}
+}
+
+void xrmac_sta_info_recalc_tim(struct sta_info *sta)
+{
+	struct ieee80211_local *local = sta->local;
+	struct ieee80211_if_ap *bss = sta->sdata->bss;
+	unsigned long flags;
+	bool indicate_tim = false;
+	u8 ignore_for_tim = sta->sta.uapsd_queues;
+	int ac;
+
+	if (WARN_ON_ONCE(!sta->sdata->bss))
+		return;
+
+	/* No need to do anything if the driver does all */
+	if (local->hw.flags & IEEE80211_HW_AP_LINK_PS)
+		return;
+
+	if (sta->dead)
+		goto done;
+
+	/*
+	 * If all ACs are delivery-enabled then we should build
+	 * the TIM bit for all ACs anyway; if only some are then
+	 * we ignore those and build the TIM bit using only the
+	 * non-enabled ones.
+	 */
+	if (ignore_for_tim == BIT(IEEE80211_NUM_ACS) - 1)
+		ignore_for_tim = 0;
+
+	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
+		unsigned long tids;
+
+		if (ignore_for_tim & BIT(ac))
+			continue;
+
+		indicate_tim |= !skb_queue_empty(&sta->tx_filtered[ac]) ||
+				!skb_queue_empty(&sta->ps_tx_buf[ac]);
+		if (indicate_tim)
+			break;
+
+		tids = ieee80211_tids_for_ac(ac);
+
+		indicate_tim |=
+			sta->driver_buffered_tids & tids;
+	}
+
+ done:
+	spin_lock_irqsave(&local->sta_lock, flags);
+
+	if (indicate_tim)
+		__bss_tim_set(bss, sta->sta.aid);
+	else
+		__bss_tim_clear(bss, sta->sta.aid);
+
+	if (local->ops->set_tim) {
+		local->tim_in_locked_section = true;
+		drv_set_tim(local, &sta->sta, indicate_tim);
+		local->tim_in_locked_section = false;
+	}
+
+	spin_unlock_irqrestore(&local->sta_lock, flags);
+}
+
+static bool sta_info_buffer_expired(struct sta_info *sta, struct sk_buff *skb)
+{
+	struct ieee80211_tx_info *info;
+	int timeout;
+
+	if (!skb)
+		return false;
+
+	info = IEEE80211_SKB_CB(skb);
+
+	/* Timeout: (2 * listen_interval * beacon_int * 1024 / 1000000) sec */
+	timeout = (sta->listen_interval *
+		   sta->sdata->vif.bss_conf.beacon_int *
+		   32 / 15625) * HZ;
+	/* Timeout limited to range 5-10sec */
+	if (timeout < STA_TX_BUFFER_EXPIRE)
+		timeout = STA_TX_BUFFER_EXPIRE;
+	else if (timeout > (10 * HZ))
+		timeout = 10 * HZ;
+	return time_after(jiffies, info->control.jiffies + timeout);
+}
+
+
+static bool sta_info_cleanup_expire_buffered_ac(struct ieee80211_local *local,
+						struct sta_info *sta, int ac)
+{
+	unsigned long flags;
+	struct sk_buff *skb;
+
+	/*
+	 * First check for frames that should expire on the filtered
+	 * queue. Frames here were rejected by the driver and are on
+	 * a separate queue to avoid reordering with normal PS-buffered
+	 * frames. They also aren't accounted for right now in the
+	 * total_ps_buffered counter.
+	 */
+	for (;;) {
+		spin_lock_irqsave(&sta->tx_filtered[ac].lock, flags);
+		skb = skb_peek(&sta->tx_filtered[ac]);
+		if (sta_info_buffer_expired(sta, skb))
+			skb = __skb_dequeue(&sta->tx_filtered[ac]);
+		else
+			skb = NULL;
+		spin_unlock_irqrestore(&sta->tx_filtered[ac].lock, flags);
+
+		/*
+		 * Frames are queued in order, so if this one
+		 * hasn't expired yet we can stop testing. If
+		 * we actually reached the end of the queue we
+		 * also need to stop, of course.
+		 */
+		if (!skb)
+			break;
+		dev_kfree_skb(skb);
+	}
+
+	/*
+	 * Now also check the normal PS-buffered queue, this will
+	 * only find something if the filtered queue was emptied
+	 * since the filtered frames are all before the normal PS
+	 * buffered frames.
+	 */
+	for (;;) {
+		spin_lock_irqsave(&sta->ps_tx_buf[ac].lock, flags);
+		skb = skb_peek(&sta->ps_tx_buf[ac]);
+		if (sta_info_buffer_expired(sta, skb))
+			skb = __skb_dequeue(&sta->ps_tx_buf[ac]);
+		else
+			skb = NULL;
+		spin_unlock_irqrestore(&sta->ps_tx_buf[ac].lock, flags);
+
+		/*
+		 * frames are queued in order, so if this one
+		 * hasn't expired yet (or we reached the end of
+		 * the queue) we can stop testing
+		 */
+		if (!skb)
+			break;
+
+		local->total_ps_buffered--;
+#ifdef CONFIG_XRMAC_VERBOSE_PS_DEBUG
+		printk(KERN_DEBUG "Buffered frame expired (STA %pM)\n",
+		       sta->sta.addr);
+#endif
+		dev_kfree_skb(skb);
+	}
+
+	/*
+	 * Finally, recalculate the TIM bit for this station -- it might
+	 * now be clear because the station was too slow to retrieve its
+	 * frames.
+	 */
+	xrmac_sta_info_recalc_tim(sta);
+
+	/*
+	 * Return whether there are any frames still buffered, this is
+	 * used to check whether the cleanup timer still needs to run,
+	 * if there are no frames we don't need to rearm the timer.
+	 */
+	return !(skb_queue_empty(&sta->ps_tx_buf[ac]) &&
+		 skb_queue_empty(&sta->tx_filtered[ac]));
+}
+
+static bool sta_info_cleanup_expire_buffered(struct ieee80211_local *local,
+					     struct sta_info *sta)
+{
+	bool have_buffered = false;
+	int ac;
+
+	/* This is only necessary for stations on BSS interfaces */
+	if (!sta->sdata->bss)
+		return false;
+
+	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++)
+		have_buffered |=
+			sta_info_cleanup_expire_buffered_ac(local, sta, ac);
+
+	return have_buffered;
+}
+
+static int __must_check __sta_info_destroy(struct sta_info *sta)
+{
+	struct ieee80211_local *local;
+	struct ieee80211_sub_if_data *sdata;
+	unsigned long flags;
+	int ret, i, ac;
+
+	might_sleep();
+
+	if (!sta)
+		return -ENOENT;
+
+	local = sta->local;
+	sdata = sta->sdata;
+
+	/*
+	 * Before removing the station from the driver and
+	 * rate control, it might still start new aggregation
+	 * sessions -- block that to make sure the tear-down
+	 * will be sufficient.
+	 */
+	set_sta_flag(sta, WLAN_STA_BLOCK_BA);
+	mac80211_sta_tear_down_BA_sessions(sta, true);
+
+	spin_lock_irqsave(&local->sta_lock, flags);
+	ret = sta_info_hash_del(local, sta);
+	/* this might still be the pending list ... which is fine */
+	if (!ret)
+		list_del(&sta->list);
+	spin_unlock_irqrestore(&local->sta_lock, flags);
+	if (ret)
+		return ret;
+
+	mutex_lock(&local->key_mtx);
+	for (i = 0; i < NUM_DEFAULT_KEYS; i++)
+		__mac80211_key_free(key_mtx_dereference(local, sta->gtk[i]));
+	if (sta->ptk)
+		__mac80211_key_free(key_mtx_dereference(local, sta->ptk));
+	mutex_unlock(&local->key_mtx);
+
+	sta->dead = true;
+
+	if (test_sta_flag(sta, WLAN_STA_PS_STA) ||
+	    test_sta_flag(sta, WLAN_STA_PS_DRIVER)) {
+		BUG_ON(!sdata->bss);
+
+		clear_sta_flag(sta, WLAN_STA_PS_STA);
+		clear_sta_flag(sta, WLAN_STA_PS_DRIVER);
+
+		atomic_dec(&sdata->bss->num_sta_ps);
+		xrmac_sta_info_recalc_tim(sta);
+	}
+
+	local->num_sta--;
+	local->sta_generation++;
+
+	if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
+		RCU_INIT_POINTER(sdata->u.vlan.sta, NULL);
+
+	if (sta->uploaded) {
+		if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
+			sdata = container_of(sdata->bss,
+					     struct ieee80211_sub_if_data,
+					     u.ap);
+		drv_sta_remove(local, sdata, &sta->sta);
+		sdata = sta->sdata;
+	}
+#ifdef CONFIG_XRMAC_XR_ROAMING_CHANGES
+	/*
+	 * In STA mode use non blocking rcu to decrease
+	 * roaming time.
+	 */
+	if (sdata->vif.type == NL80211_IFTYPE_STATION) {
+		cfg80211_del_sta(sdata->dev, sta->sta.addr, GFP_KERNEL);
+
+#ifdef CONFIG_XRMAC_VERBOSE_DEBUG
+		wiphy_debug(local->hw.wiphy,
+			"Removed STA %pM\n", sta->sta.addr);
+#endif /* CONFIG_XRMAC_VERBOSE_DEBUG */
+
+		call_rcu(&sta->rcu, sta_info_free_rcu);
+		return 0;
+	}
+#endif
+
+	/*
+	 * At this point, after we wait for an RCU grace period,
+	 * neither mac80211 nor the driver can reference this
+	 * sta struct any more except by still existing timers
+	 * associated with this station that we clean up below.
+	 */
+	synchronize_rcu();
+
+	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
+		local->total_ps_buffered -= skb_queue_len(&sta->ps_tx_buf[ac]);
+		__skb_queue_purge(&sta->ps_tx_buf[ac]);
+		__skb_queue_purge(&sta->tx_filtered[ac]);
+	}
+
+#ifdef CONFIG_XRMAC_MESH
+	if (ieee80211_vif_is_mesh(&sdata->vif))
+		xrmac_mesh_accept_plinks_update(sdata);
+#endif
+
+#ifdef CONFIG_XRMAC_VERBOSE_DEBUG
+	wiphy_debug(local->hw.wiphy, "Removed STA %pM\n", sta->sta.addr);
+#endif /* CONFIG_XRMAC_VERBOSE_DEBUG */
+	cancel_work_sync(&sta->drv_unblock_wk);
+
+	cfg80211_del_sta(sdata->dev, sta->sta.addr, GFP_KERNEL);
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	rate_control_remove_sta_debugfs(sta);
+	mac80211_sta_debugfs_remove(sta);
+#endif /* CONFIG_XRMAC_DEBUGFS */
+
+#ifdef CONFIG_XRMAC_MESH
+	if (ieee80211_vif_is_mesh(&sta->sdata->vif)) {
+		xrmac_mesh_plink_deactivate(sta);
+		del_timer_sync(&sta->plink_timer);
+	}
+#endif
+
+	__sta_info_free(local, sta);
+
+	return 0;
+}
+
+int xrmac_sta_info_destroy_addr(struct ieee80211_sub_if_data *sdata, const u8 *addr)
+{
+	struct sta_info *sta;
+	int ret;
+
+	mutex_lock(&sdata->local->sta_mtx);
+	sta = xrmac_sta_info_get_rx(sdata, addr);
+	ret = __sta_info_destroy(sta);
+	mutex_unlock(&sdata->local->sta_mtx);
+
+	return ret;
+}
+
+int xrmac_sta_info_destroy_addr_bss(struct ieee80211_sub_if_data *sdata,
+			      const u8 *addr)
+{
+	struct sta_info *sta;
+	int ret;
+
+	mutex_lock(&sdata->local->sta_mtx);
+	sta = xrmac_sta_info_get_bss_rx(sdata, addr);
+	ret = __sta_info_destroy(sta);
+	mutex_unlock(&sdata->local->sta_mtx);
+
+	return ret;
+}
+
+static void sta_info_cleanup(struct timer_list *t)
+{
+	struct ieee80211_local *local = from_timer(local, t, sta_cleanup);
+	struct sta_info *sta;
+	bool timer_needed = false;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(sta, &local->sta_list, list)
+		if (sta_info_cleanup_expire_buffered(local, sta))
+			timer_needed = true;
+	rcu_read_unlock();
+
+	if (local->quiescing)
+		return;
+
+	if (!timer_needed)
+		return;
+
+	mod_timer(&local->sta_cleanup,
+		  round_jiffies(jiffies + STA_INFO_CLEANUP_INTERVAL));
+}
+
+void xrmac_sta_info_init(struct ieee80211_local *local)
+{
+	spin_lock_init(&local->sta_lock);
+	mutex_init(&local->sta_mtx);
+	INIT_LIST_HEAD(&local->sta_list);
+	INIT_LIST_HEAD(&local->sta_pending_list);
+	INIT_WORK(&local->sta_finish_work, sta_info_finish_work);
+
+	timer_setup(&local->sta_cleanup, sta_info_cleanup, 0);
+}
+
+void xrmac_sta_info_stop(struct ieee80211_local *local)
+{
+	del_timer_sync(&local->sta_cleanup);
+	xrmac_sta_info_flush(local, NULL);
+}
+
+/**
+ * xrmac_sta_info_flush - flush matching STA entries from the STA table
+ *
+ * Returns the number of removed STA entries.
+ *
+ * @local: local interface data
+ * @sdata: matching rule for the net device (sta->dev) or %NULL to match all STAs
+ */
+int xrmac_sta_info_flush(struct ieee80211_local *local,
+		   struct ieee80211_sub_if_data *sdata)
+{
+	struct sta_info *sta, *tmp;
+	int ret = 0;
+
+	might_sleep();
+
+	mutex_lock(&local->sta_mtx);
+
+	sta_info_finish_pending(local);
+
+	list_for_each_entry_safe(sta, tmp, &local->sta_list, list) {
+		if (!sdata || sdata == sta->sdata)
+			WARN_ON(__sta_info_destroy(sta));
+	}
+	mutex_unlock(&local->sta_mtx);
+
+	return ret;
+}
+
+void mac80211_sta_expire(struct ieee80211_sub_if_data *sdata,
+			  unsigned long exp_time)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct sta_info *sta, *tmp;
+
+	mutex_lock(&local->sta_mtx);
+	list_for_each_entry_safe(sta, tmp, &local->sta_list, list)
+		if (time_after(jiffies, sta->last_rx + exp_time)) {
+#ifdef CONFIG_XRMAC_IBSS_DEBUG
+			printk(KERN_DEBUG "%s: expiring inactive STA %pM\n",
+			       sdata->name, sta->sta.addr);
+#endif
+			WARN_ON(__sta_info_destroy(sta));
+		}
+	mutex_unlock(&local->sta_mtx);
+}
+
+struct ieee80211_sta *mac80211_find_sta_by_ifaddr(struct ieee80211_hw *hw,
+					       const u8 *addr,
+					       const u8 *localaddr)
+{
+	struct sta_info *sta, *nxt;
+
+	/*
+	 * Just return a random station if localaddr is NULL
+	 * ... first in list.
+	 */
+	for_each_sta_info(hw_to_local(hw), addr, sta, nxt) {
+		if (localaddr &&
+		    compare_ether_addr(sta->sdata->vif.addr, localaddr) != 0)
+			continue;
+		if (!sta->uploaded)
+			return NULL;
+		return &sta->sta;
+	}
+
+	return NULL;
+}
+
+struct ieee80211_sta *mac80211_find_sta(struct ieee80211_vif *vif,
+					 const u8 *addr)
+{
+	struct sta_info *sta;
+
+	if (!vif)
+		return NULL;
+
+	sta = xrmac_sta_info_get_bss(vif_to_sdata(vif), addr);
+	if (!sta)
+		return NULL;
+
+	if (!sta->uploaded)
+		return NULL;
+
+	return &sta->sta;
+}
+
+static void clear_sta_ps_flags(void *_sta)
+{
+	struct sta_info *sta = _sta;
+
+	clear_sta_flag(sta, WLAN_STA_PS_DRIVER);
+	clear_sta_flag(sta, WLAN_STA_PS_STA);
+}
+
+/* powersave support code */
+void mac80211_sta_ps_deliver_wakeup(struct sta_info *sta)
+{
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
+	struct ieee80211_local *local = sdata->local;
+	struct sk_buff_head pending;
+	int filtered = 0, buffered = 0, ac;
+	unsigned long flags = 0;  /*refer to backports-3.16.1.*/
+
+	clear_sta_flag(sta, WLAN_STA_SP);
+
+	BUILD_BUG_ON(BITS_TO_LONGS(STA_TID_NUM) > 1);
+	sta->driver_buffered_tids = 0;
+
+	if (!(local->hw.flags & IEEE80211_HW_AP_LINK_PS))
+		drv_sta_notify(local, sdata, STA_NOTIFY_AWAKE, &sta->sta);
+
+	skb_queue_head_init(&pending);
+
+	/* sync with ieee80211_tx_h_unicast_ps_buf */
+	spin_lock(&sta->ps_lock);  /*refer to backports-3.16.1.*/
+	/* Send all buffered frames to the station */
+	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
+		int count = skb_queue_len(&pending), tmp;
+
+		spin_lock_irqsave(&sta->tx_filtered[ac].lock, flags);  /*refer to backports-3.16.1.*/
+		skb_queue_splice_tail_init(&sta->tx_filtered[ac], &pending);
+		spin_unlock_irqrestore(&sta->tx_filtered[ac].lock, flags);  /*refer to backports-3.16.1.*/
+		tmp = skb_queue_len(&pending);
+		filtered += tmp - count;
+		count = tmp;
+
+		spin_lock_irqsave(&sta->ps_tx_buf[ac].lock, flags);  /*refer to backports-3.16.1.*/
+		skb_queue_splice_tail_init(&sta->ps_tx_buf[ac], &pending);
+		spin_unlock_irqrestore(&sta->ps_tx_buf[ac].lock, flags); /*refer to backports-3.16.1.*/
+		tmp = skb_queue_len(&pending);
+		buffered += tmp - count;
+	}
+	mac80211_add_pending_skbs_fn(local, &pending, clear_sta_ps_flags, sta);
+	spin_unlock(&sta->ps_lock); /*refer to backports-3.16.1.*/
+
+	local->total_ps_buffered -= buffered;
+
+	xrmac_sta_info_recalc_tim(sta);
+
+#ifdef CONFIG_XRMAC_VERBOSE_PS_DEBUG
+	printk(KERN_DEBUG "%s: STA %pM aid %d sending %d filtered/%d PS frames "
+	       "since STA not sleeping anymore\n", sdata->name,
+	       sta->sta.addr, sta->sta.aid, filtered, buffered);
+#endif /* CONFIG_XRMAC_VERBOSE_PS_DEBUG */
+}
+
+static void ieee80211_send_null_response(struct ieee80211_sub_if_data *sdata,
+					 struct sta_info *sta, int tid,
+					 enum ieee80211_frame_release_type reason)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_qos_hdr *nullfunc;
+	struct sk_buff *skb;
+	int size = sizeof(*nullfunc);
+	__le16 fc;
+	bool qos = test_sta_flag(sta, WLAN_STA_WME);
+	struct ieee80211_tx_info *info;
+
+	if (qos) {
+		fc = cpu_to_le16(IEEE80211_FTYPE_DATA |
+				 IEEE80211_STYPE_QOS_NULLFUNC |
+				 IEEE80211_FCTL_FROMDS);
+	} else {
+		size -= 2;
+		fc = cpu_to_le16(IEEE80211_FTYPE_DATA |
+				 IEEE80211_STYPE_NULLFUNC |
+				 IEEE80211_FCTL_FROMDS);
+	}
+
+	skb = dev_alloc_skb(local->hw.extra_tx_headroom + size);
+	if (!skb)
+		return;
+
+	skb_reserve(skb, local->hw.extra_tx_headroom);
+
+	nullfunc = (void *) skb_put(skb, size);
+	nullfunc->frame_control = fc;
+	nullfunc->duration_id = 0;
+	memcpy(nullfunc->addr1, sta->sta.addr, ETH_ALEN);
+	memcpy(nullfunc->addr2, sdata->vif.addr, ETH_ALEN);
+	memcpy(nullfunc->addr3, sdata->vif.addr, ETH_ALEN);
+
+	skb->priority = tid;
+	skb_set_queue_mapping(skb, mac802_1d_to_ac[tid]);
+	if (qos) {
+		nullfunc->qos_ctrl = cpu_to_le16(tid);
+
+		if (reason == IEEE80211_FRAME_RELEASE_UAPSD)
+			nullfunc->qos_ctrl |=
+				cpu_to_le16(IEEE80211_QOS_CTL_EOSP);
+	}
+
+	info = IEEE80211_SKB_CB(skb);
+
+	/*
+	 * Tell TX path to send this frame even though the
+	 * STA may still remain is PS mode after this frame
+	 * exchange. Also set EOSP to indicate this packet
+	 * ends the poll/service period.
+	 */
+	info->flags |= IEEE80211_TX_CTL_POLL_RESPONSE |
+		       IEEE80211_TX_STATUS_EOSP |
+		       IEEE80211_TX_CTL_REQ_TX_STATUS;
+
+	drv_allow_buffered_frames(local, sta, BIT(tid), 1, reason, false);
+
+	mac80211_xmit(sdata, skb);
+}
+
+static void
+ieee80211_sta_ps_deliver_response(struct sta_info *sta,
+				  int n_frames, u8 ignored_acs,
+				  enum ieee80211_frame_release_type reason)
+{
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
+	struct ieee80211_local *local = sdata->local;
+	bool found = false;
+	bool more_data = false;
+	int ac;
+	unsigned long driver_release_tids = 0;
+	struct sk_buff_head frames;
+
+	/* Service or PS-Poll period starts */
+	set_sta_flag(sta, WLAN_STA_SP);
+
+	__skb_queue_head_init(&frames);
+
+	/*
+	 * Get response frame(s) and more data bit for it.
+	 */
+	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
+		unsigned long tids;
+
+		if (ignored_acs & BIT(ac))
+			continue;
+
+		tids = ieee80211_tids_for_ac(ac);
+
+		if (!found) {
+			driver_release_tids = sta->driver_buffered_tids & tids;
+			if (driver_release_tids) {
+				found = true;
+			} else {
+				struct sk_buff *skb;
+
+				while (n_frames > 0) {
+					skb = skb_dequeue(&sta->tx_filtered[ac]);
+					if (!skb) {
+						skb = skb_dequeue(
+							&sta->ps_tx_buf[ac]);
+						if (skb)
+							local->total_ps_buffered--;
+					}
+					if (!skb)
+						break;
+					n_frames--;
+					found = true;
+					__skb_queue_tail(&frames, skb);
+				}
+			}
+
+			/*
+			 * If the driver has data on more than one TID then
+			 * certainly there's more data if we release just a
+			 * single frame now (from a single TID).
+			 */
+			if (reason == IEEE80211_FRAME_RELEASE_PSPOLL &&
+			    hweight16(driver_release_tids) > 1) {
+				more_data = true;
+				driver_release_tids =
+					BIT(ffs(driver_release_tids) - 1);
+				break;
+			}
+		}
+
+		if (!skb_queue_empty(&sta->tx_filtered[ac]) ||
+		    !skb_queue_empty(&sta->ps_tx_buf[ac])) {
+			more_data = true;
+			break;
+		}
+	}
+
+	if (!found) {
+		int tid;
+
+		/*
+		 * For PS-Poll, this can only happen due to a race condition
+		 * when we set the TIM bit and the station notices it, but
+		 * before it can poll for the frame we expire it.
+		 *
+		 * For uAPSD, this is said in the standard (11.2.1.5 h):
+		 *	At each unscheduled SP for a non-AP STA, the AP shall
+		 *	attempt to transmit at least one MSDU or MMPDU, but no
+		 *	more than the value specified in the Max SP Length field
+		 *	in the QoS Capability element from delivery-enabled ACs,
+		 *	that are destined for the non-AP STA.
+		 *
+		 * Since we have no other MSDU/MMPDU, transmit a QoS null frame.
+		 */
+
+		/* This will evaluate to 1, 3, 5 or 7. */
+		tid = 7 - ((ffs(~ignored_acs) - 1) << 1);
+
+		ieee80211_send_null_response(sdata, sta, tid, reason);
+		return;
+	}
+
+	if (!driver_release_tids || !local->ops->release_buffered_frames) {
+		struct sk_buff_head pending;
+		struct sk_buff *skb;
+		int num = 0;
+		u16 tids = 0;
+
+		skb_queue_head_init(&pending);
+
+		while ((skb = __skb_dequeue(&frames))) {
+			struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+			struct ieee80211_hdr *hdr = (void *) skb->data;
+			u8 *qoshdr = NULL;
+
+			num++;
+
+			/*
+			 * Tell TX path to send this frame even though the
+			 * STA may still remain is PS mode after this frame
+			 * exchange.
+			 */
+			info->flags |= IEEE80211_TX_CTL_POLL_RESPONSE;
+
+			/*
+			 * Use MoreData flag to indicate whether there are
+			 * more buffered frames for this STA
+			 */
+			if (more_data || !skb_queue_empty(&frames))
+				hdr->frame_control |=
+					cpu_to_le16(IEEE80211_FCTL_MOREDATA);
+			else
+				hdr->frame_control &=
+					cpu_to_le16(~IEEE80211_FCTL_MOREDATA);
+
+			if (ieee80211_is_data_qos(hdr->frame_control) ||
+			    ieee80211_is_qos_nullfunc(hdr->frame_control))
+				qoshdr = ieee80211_get_qos_ctl(hdr);
+
+			/* set EOSP for the frame */
+			if (reason == IEEE80211_FRAME_RELEASE_UAPSD &&
+			    qoshdr && skb_queue_empty(&frames))
+				*qoshdr |= IEEE80211_QOS_CTL_EOSP;
+
+			info->flags |= IEEE80211_TX_STATUS_EOSP |
+				       IEEE80211_TX_CTL_REQ_TX_STATUS;
+
+			if (qoshdr)
+				tids |= BIT(*qoshdr & IEEE80211_QOS_CTL_TID_MASK);
+			else
+				tids |= BIT(0);
+
+			__skb_queue_tail(&pending, skb);
+		}
+
+		drv_allow_buffered_frames(local, sta, tids, num,
+					  reason, more_data);
+
+		mac80211_add_pending_skbs(local, &pending);
+
+		xrmac_sta_info_recalc_tim(sta);
+	} else {
+		/*
+		 * We need to release a frame that is buffered somewhere in the
+		 * driver ... it'll have to handle that.
+		 * Note that, as per the comment above, it'll also have to see
+		 * if there is more than just one frame on the specific TID that
+		 * we're releasing from, and it needs to set the more-data bit
+		 * accordingly if we tell it that there's no more data. If we do
+		 * tell it there's more data, then of course the more-data bit
+		 * needs to be set anyway.
+		 */
+		drv_release_buffered_frames(local, sta, driver_release_tids,
+					    n_frames, reason, more_data);
+
+		/*
+		 * Note that we don't recalculate the TIM bit here as it would
+		 * most likely have no effect at all unless the driver told us
+		 * that the TID became empty before returning here from the
+		 * release function.
+		 * Either way, however, when the driver tells us that the TID
+		 * became empty we'll do the TIM recalculation.
+		 */
+	}
+}
+
+void mac80211_sta_ps_deliver_poll_response(struct sta_info *sta)
+{
+	u8 ignore_for_response = sta->sta.uapsd_queues;
+
+	/*
+	 * If all ACs are delivery-enabled then we should reply
+	 * from any of them, if only some are enabled we reply
+	 * only from the non-enabled ones.
+	 */
+	if (ignore_for_response == BIT(IEEE80211_NUM_ACS) - 1)
+		ignore_for_response = 0;
+
+	ieee80211_sta_ps_deliver_response(sta, 1, ignore_for_response,
+					  IEEE80211_FRAME_RELEASE_PSPOLL);
+}
+
+void mac80211_sta_ps_deliver_uapsd(struct sta_info *sta)
+{
+	int n_frames = sta->sta.max_sp;
+	u8 delivery_enabled = sta->sta.uapsd_queues;
+
+	/*
+	 * If we ever grow support for TSPEC this might happen if
+	 * the TSPEC update from hostapd comes in between a trigger
+	 * frame setting WLAN_STA_UAPSD in the RX path and this
+	 * actually getting called.
+	 */
+	if (!delivery_enabled)
+		return;
+
+	switch (sta->sta.max_sp) {
+	case 1:
+		n_frames = 2;
+		break;
+	case 2:
+		n_frames = 4;
+		break;
+	case 3:
+		n_frames = 6;
+		break;
+	case 0:
+		/* XXX: what is a good value? */
+		n_frames = 8;
+		break;
+	}
+
+	ieee80211_sta_ps_deliver_response(sta, n_frames, ~delivery_enabled,
+					  IEEE80211_FRAME_RELEASE_UAPSD);
+}
+
+void mac80211_sta_block_awake(struct ieee80211_hw *hw,
+			       struct ieee80211_sta *pubsta, bool block)
+{
+	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
+
+	trace_api_sta_block_awake(sta->local, pubsta, block);
+
+	if (block)
+		set_sta_flag(sta, WLAN_STA_PS_DRIVER);
+	else if (test_sta_flag(sta, WLAN_STA_PS_DRIVER))
+		mac80211_queue_work(hw, &sta->drv_unblock_wk);
+}
+
+void mac80211_sta_eosp_irqsafe(struct ieee80211_sta *pubsta)
+{
+	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
+	struct ieee80211_local *local = sta->local;
+	struct sk_buff *skb;
+	struct skb_eosp_msg_data *data;
+
+	trace_api_eosp(local, pubsta);
+
+	skb = alloc_skb(0, GFP_ATOMIC);
+	if (!skb) {
+		/* too bad ... but race is better than loss */
+		clear_sta_flag(sta, WLAN_STA_SP);
+		return;
+	}
+
+	data = (void *)skb->cb;
+	memcpy(data->sta, pubsta->addr, ETH_ALEN);
+	memcpy(data->iface, sta->sdata->vif.addr, ETH_ALEN);
+	skb->pkt_type = IEEE80211_EOSP_MSG;
+	skb_queue_tail(&local->skb_queue, skb);
+	tasklet_schedule(&local->tasklet);
+}
+
+void mac80211_sta_set_buffered(struct ieee80211_sta *pubsta,
+				u8 tid, bool buffered)
+{
+	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
+
+	if (WARN_ON(tid >= STA_TID_NUM))
+		return;
+
+	if (buffered)
+		set_bit(tid, &sta->driver_buffered_tids);
+	else
+		clear_bit(tid, &sta->driver_buffered_tids);
+
+	xrmac_sta_info_recalc_tim(sta);
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/sta_info.h b/drivers/net/wireless/xr829/umac/sta_info.h
--- a/drivers/net/wireless/xr829/umac/sta_info.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/sta_info.h	2022-08-27 01:22:42.958539877 +0300
@@ -0,0 +1,548 @@
+/*
+ * Copyright 2002-2005, Devicescape Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef STA_INFO_H
+#define STA_INFO_H
+
+#include <linux/list.h>
+#include <linux/types.h>
+#include <linux/if_ether.h>
+#include <linux/workqueue.h>
+#include <linux/average.h>
+#include "key.h"
+
+/**
+ * enum ieee80211_sta_info_flags - Stations flags
+ *
+ * These flags are used with &struct sta_info's @flags member, but
+ * only indirectly with set_sta_flag() and friends.
+ *
+ * @WLAN_STA_AUTH: Station is authenticated.
+ * @WLAN_STA_ASSOC: Station is associated.
+ * @WLAN_STA_PS_STA: Station is in power-save mode
+ * @WLAN_STA_AUTHORIZED: Station is authorized to send/receive traffic.
+ *	This bit is always checked so needs to be enabled for all stations
+ *	when virtual port control is not in use.
+ * @WLAN_STA_SHORT_PREAMBLE: Station is capable of receiving short-preamble
+ *	frames.
+ * @WLAN_STA_ASSOC_AP: We're associated to that station, it is an AP.
+ * @WLAN_STA_WME: Station is a QoS-STA.
+ * @WLAN_STA_WDS: Station is one of our WDS peers.
+ * @WLAN_STA_CLEAR_PS_FILT: Clear PS filter in hardware (using the
+ *	IEEE80211_TX_CTL_CLEAR_PS_FILT control flag) when the next
+ *	frame to this station is transmitted.
+ * @WLAN_STA_MFP: Management frame protection is used with this STA.
+ * @WLAN_STA_BLOCK_BA: Used to deny ADDBA requests (both TX and RX)
+ *	during suspend/resume and station removal.
+ * @WLAN_STA_PS_DRIVER: driver requires keeping this station in
+ *	power-save mode logically to flush frames that might still
+ *	be in the queues
+ * @WLAN_STA_PSPOLL: Station sent PS-poll while driver was keeping
+ *	station in power-save mode, reply when the driver unblocks.
+ * @WLAN_STA_TDLS_PEER: Station is a TDLS peer.
+ * @WLAN_STA_TDLS_PEER_AUTH: This TDLS peer is authorized to send direct
+ *	packets. This means the link is enabled.
+ * @WLAN_STA_UAPSD: Station requested unscheduled SP while driver was
+ *	keeping station in power-save mode, reply when the driver
+ *	unblocks the station.
+ * @WLAN_STA_SP: Station is in a service period, so don't try to
+ *	reply to other uAPSD trigger frames or PS-Poll.
+ */
+enum ieee80211_sta_info_flags {
+	WLAN_STA_AUTH,
+	WLAN_STA_ASSOC,
+	WLAN_STA_PS_STA,
+	WLAN_STA_AUTHORIZED,
+	WLAN_STA_SHORT_PREAMBLE,
+	WLAN_STA_ASSOC_AP,
+	WLAN_STA_WME,
+	WLAN_STA_WDS,
+	WLAN_STA_CLEAR_PS_FILT,
+	WLAN_STA_MFP,
+	WLAN_STA_BLOCK_BA,
+	WLAN_STA_PS_DRIVER,
+	WLAN_STA_PSPOLL,
+	WLAN_STA_TDLS_PEER,
+	WLAN_STA_TDLS_PEER_AUTH,
+	WLAN_STA_UAPSD,
+	WLAN_STA_SP,
+};
+
+#define STA_TID_NUM 16
+#define ADDBA_RESP_INTERVAL HZ
+#define HT_AGG_MAX_RETRIES		0x3
+
+#define HT_AGG_STATE_DRV_READY		0
+#define HT_AGG_STATE_RESPONSE_RECEIVED	1
+#define HT_AGG_STATE_OPERATIONAL	2
+#define HT_AGG_STATE_STOPPING		3
+#define HT_AGG_STATE_WANT_START		4
+#define HT_AGG_STATE_WANT_STOP		5
+
+/**
+ * struct tid_ampdu_tx - TID aggregation information (Tx).
+ *
+ * @rcu_head: rcu head for freeing structure
+ * @session_timer: check if we keep Tx-ing on the TID (by timeout value)
+ * @addba_resp_timer: timer for peer's response to addba request
+ * @pending: pending frames queue -- use sta's spinlock to protect
+ * @sta: station we are attached to
+ * @dialog_token: dialog token for aggregation session
+ * @timeout: session timeout value to be filled in ADDBA requests
+ * @tid: TID number
+ * @state: session state (see above)
+ * @last_tx: jiffies of last tx activity
+ * @stop_initiator: initiator of a session stop
+ * @tx_stop: TX DelBA frame when stopping
+ * @buf_size: reorder buffer size at receiver
+ * @failed_bar_ssn: ssn of the last failed BAR tx attempt
+ * @bar_pending: BAR needs to be re-sent
+ * @amsdu: support A-MSDU withing A-MDPU
+ *
+ * This structure's lifetime is managed by RCU, assignments to
+ * the array holding it must hold the aggregation mutex.
+ *
+ * The TX path can access it under RCU lock-free if, and
+ * only if, the state has the flag %HT_AGG_STATE_OPERATIONAL
+ * set. Otherwise, the TX path must also acquire the spinlock
+ * and re-check the state, see comments in the tx code
+ * touching it.
+ */
+struct tid_ampdu_tx {
+	struct rcu_head rcu_head;
+	//struct timer_list session_timer;
+	struct timer_list addba_resp_timer;
+	struct sk_buff_head pending;
+	struct sta_info *sta;
+	unsigned long state;
+	unsigned long last_tx;
+	u16 timeout;
+	u8 dialog_token;
+	u8 stop_initiator;
+	bool tx_stop;
+	u16 buf_size;
+
+	u16 failed_bar_ssn;
+	bool bar_pending;
+	bool amsdu;
+	u8 tid;
+};
+
+
+/**
+ * struct tid_ampdu_rx - TID aggregation information (Rx).
+ *
+ * @reorder_buf: buffer to reorder incoming aggregated MPDUs. An MPDU may be an
+ *	A-MSDU with individually reported subframes.
+ * @reorder_buf_filtered: bitmap indicating where there are filtered frames in
+ *	the reorder buffer that should be ignored when releasing frames
+ * @reorder_time: jiffies when skb was added
+ * @session_timer: check if peer keeps Tx-ing on the TID (by timeout value)
+ * @reorder_timer: releases expired frames from the reorder buffer.
+ * @sta: station we are attached to
+ * @last_rx: jiffies of last rx activity
+ * @head_seq_num: head sequence number in reordering buffer.
+ * @stored_mpdu_num: number of MPDUs in reordering buffer
+ * @ssn: Starting Sequence Number expected to be aggregated.
+ * @buf_size: buffer size for incoming A-MPDUs
+ * @timeout: reset timer value (in TUs).
+ * @tid: TID number
+ * @rcu_head: RCU head used for freeing this struct
+ * @reorder_lock: serializes access to reorder buffer, see below.
+ * @auto_seq: used for offloaded BA sessions to automatically pick head_seq_and
+ *	and ssn.
+ * @removed: this session is removed (but might have been found due to RCU)
+ * @started: this session has started (head ssn or higher was received)
+ *
+ * This structure's lifetime is managed by RCU, assignments to
+ * the array holding it must hold the aggregation mutex.
+ *
+ * The @reorder_lock is used to protect the members of this
+ * struct, except for @timeout, @buf_size and @dialog_token,
+ * which are constant across the lifetime of the struct (the
+ * dialog token being used only for debugging).
+ */
+struct tid_ampdu_rx {
+	struct rcu_head rcu_head;
+	spinlock_t reorder_lock;
+	u64 reorder_buf_filtered;
+	struct sk_buff **reorder_buf;
+	unsigned long *reorder_time;
+	struct sta_info *sta;
+	struct timer_list session_timer;
+	struct timer_list reorder_timer;
+	unsigned long last_rx;
+	u16 head_seq_num;
+	u16 stored_mpdu_num;
+	u16 ssn;
+	u16 buf_size;
+	u16 timeout;
+	u8 dialog_token;
+	u8 tid;
+};
+
+/**
+ * struct sta_ampdu_mlme - STA aggregation information.
+ *
+ * @tid_rx: aggregation info for Rx per TID -- RCU protected
+ * @tid_tx: aggregation info for Tx per TID
+ * @tid_start_tx: sessions where start was requested
+ * @addba_req_num: number of times addBA request has been sent.
+ * @dialog_token_allocator: dialog token enumerator for each new session;
+ * @work: work struct for starting/stopping aggregation
+ * @tid_rx_timer_expired: bitmap indicating on which TIDs the
+ *	RX timer expired until the work for it runs
+ * @tid_rx_stop_requested:  bitmap indicating which BA sessions per TID the
+ *	driver requested to close until the work for it runs
+ * @mtx: mutex to protect all TX data (except non-NULL assignments
+ *	to tid_tx[idx], which are protected by the sta spinlock)
+ */
+struct sta_ampdu_mlme {
+	struct mutex mtx;
+	/* rx */
+	struct tid_ampdu_rx __rcu *tid_rx[STA_TID_NUM];
+	unsigned long tid_rx_timer_expired[BITS_TO_LONGS(STA_TID_NUM)];
+	unsigned long tid_rx_stop_requested[BITS_TO_LONGS(STA_TID_NUM)];
+	/* tx */
+	struct work_struct work;
+	struct tid_ampdu_tx __rcu *tid_tx[STA_TID_NUM];
+	struct tid_ampdu_tx *tid_start_tx[STA_TID_NUM];
+	u8 addba_req_num[STA_TID_NUM];
+	u8 dialog_token_allocator;
+};
+
+
+/**
+ * struct sta_info - STA information
+ *
+ * This structure collects information about a station that
+ * mac80211 is communicating with.
+ *
+ * @list: global linked list entry
+ * @hnext: hash table linked list pointer
+ * @local: pointer to the global information
+ * @sdata: virtual interface this station belongs to
+ * @ptk: peer key negotiated with this station, if any
+ * @gtk: group keys negotiated with this station, if any
+ * @rate_ctrl: rate control algorithm reference
+ * @rate_ctrl_priv: rate control private per-STA pointer
+ * @last_tx_rate: rate used for last transmit, to report to userspace as
+ *	"the" transmit rate
+ * @last_rx_rate_idx: rx status rate index of the last data packet
+ * @last_rx_rate_flag: rx status flag of the last data packet
+ * @lock: used for locking all fields that require locking, see comments
+ *	in the header file.
+ * @drv_unblock_wk: used for driver PS unblocking
+ * @listen_interval: listen interval of this station, when we're acting as AP
+ * @_flags: STA flags, see &enum ieee80211_sta_info_flags, do not use directly
+ * @ps_tx_buf: buffers (per AC) of frames to transmit to this station
+ *	when it leaves power saving state or polls
+ * @tx_filtered: buffers (per AC) of frames we already tried to
+ *	transmit but were filtered by hardware due to STA having
+ *	entered power saving state, these are also delivered to
+ *	the station when it leaves powersave or polls for frames
+ * @driver_buffered_tids: bitmap of TIDs the driver has data buffered on
+ * @rx_packets: Number of MSDUs received from this STA
+ * @rx_bytes: Number of bytes received from this STA
+ * @wep_weak_iv_count: number of weak WEP IVs received from this station
+ * @last_rx: time (in jiffies) when last frame was received from this STA
+ * @last_connected: time (in seconds) when a station got connected
+ * @num_duplicates: number of duplicate frames received from this STA
+ * @rx_fragments: number of received MPDUs
+ * @rx_dropped: number of dropped MPDUs from this STA
+ * @last_signal: signal of last received frame from this STA
+ * @avg_signal: moving average of signal of received frames from this STA
+ * @last_seq_ctrl: last received seq/frag number from this STA (per RX queue)
+ * @tx_filtered_count: number of frames the hardware filtered for this STA
+ * @tx_retry_failed: number of frames that failed retry
+ * @tx_retry_count: total number of retries for frames to this STA
+ * @fail_avg: moving percentage of failed MSDUs
+ * @tx_packets: number of RX/TX MSDUs
+ * @tx_bytes: number of bytes transmitted to this STA
+ * @tx_fragments: number of transmitted MPDUs
+ * @tid_seq: per-TID sequence numbers for sending to this STA
+ * @ampdu_mlme: A-MPDU state machine state
+ * @timer_to_tid: identity mapping to ID timers
+ * @llid: Local link ID
+ * @plid: Peer link ID
+ * @reason: Cancel reason on PLINK_HOLDING state
+ * @plink_retries: Retries in establishment
+ * @ignore_plink_timer: ignore the peer-link timer (used internally)
+ * @plink_state: peer link state
+ * @plink_timeout: timeout of peer link
+ * @plink_timer: peer link watch timer
+ * @plink_timer_was_running: used by suspend/resume to restore timers
+ * @debugfs: debug filesystem info
+ * @dead: set to true when sta is unlinked
+ * @uploaded: set to true when sta is uploaded to the driver
+ * @lost_packets: number of consecutive lost packets
+ * @dummy: indicate a dummy station created for receiving
+ *	EAP frames before association
+ * @sta: station information we share with the driver
+ */
+struct sta_info {
+	/* General information, mostly static */
+	struct list_head list;
+	struct sta_info __rcu *hnext;
+	struct ieee80211_local *local;
+	struct ieee80211_sub_if_data *sdata;
+	struct ieee80211_key __rcu *gtk[NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS];
+	struct ieee80211_key __rcu *ptk;
+#ifdef CONFIG_XRMAC_XR_ROAMING_CHANGES
+	struct rcu_head rcu;
+#endif
+	struct rate_control_ref *rate_ctrl;
+	void *rate_ctrl_priv;
+	spinlock_t lock;
+
+	struct work_struct drv_unblock_wk;
+#ifdef CONFIG_XRMAC_XR_ROAMING_CHANGES
+	struct work_struct sta_free_wk;
+#endif
+
+	u16 listen_interval;
+
+	bool dead;
+
+	bool uploaded;
+
+	/* use the accessors defined below */
+	unsigned long _flags;
+
+	/*
+	 * STA powersave frame queues, no more than the internal
+	 * locking required.
+	 */
+	spinlock_t ps_lock;
+	struct sk_buff_head ps_tx_buf[IEEE80211_NUM_ACS];
+	struct sk_buff_head tx_filtered[IEEE80211_NUM_ACS];
+	unsigned long driver_buffered_tids;
+
+	/* Updated from RX path only, no locking requirements */
+	unsigned long rx_packets, rx_bytes;
+	unsigned long wep_weak_iv_count;
+	unsigned long last_rx;
+	long last_connected;
+	unsigned long num_duplicates;
+	unsigned long rx_fragments;
+	unsigned long rx_dropped;
+	int last_signal;
+	struct ewma avg_signal;
+	/* Plus 1 for non-QoS frames */
+	__le16 last_seq_ctrl[NUM_RX_DATA_QUEUES + 1];
+
+	/* Updated from TX status path only, no locking requirements */
+	unsigned long tx_filtered_count;
+	unsigned long tx_retry_failed, tx_retry_count;
+	/* moving percentage of failed MSDUs */
+	unsigned int fail_avg;
+
+	/* Updated from TX path only, no locking requirements */
+	unsigned long tx_packets;
+	unsigned long tx_bytes;
+	unsigned long tx_fragments;
+	struct ieee80211_tx_rate last_tx_rate;
+	int last_rx_rate_idx;
+	int last_rx_rate_flag;
+	u16 tid_seq[IEEE80211_QOS_CTL_TID_MASK + 1];
+
+	/*
+	 * Aggregation information, locked with lock.
+	 */
+	struct sta_ampdu_mlme ampdu_mlme;
+	u8 timer_to_tid[STA_TID_NUM];
+
+#ifdef CONFIG_XRMAC_MESH
+	/*
+	 * Mesh peer link attributes
+	 * TODO: move to a sub-structure that is referenced with pointer?
+	 */
+	__le16 llid;
+	__le16 plid;
+	__le16 reason;
+	u8 plink_retries;
+	bool ignore_plink_timer;
+	bool plink_timer_was_running;
+	enum nl80211_plink_state plink_state;
+	u32 plink_timeout;
+	struct timer_list plink_timer;
+#endif
+
+#ifdef CONFIG_XRMAC_DEBUGFS
+	struct sta_info_debugfsdentries {
+		struct dentry *dir;
+		bool add_has_run;
+	} debugfs;
+#endif
+
+	unsigned int lost_packets;
+
+	/* should be right in front of sta to be in the same cache line */
+	bool dummy;
+
+	/* keep last! */
+	struct ieee80211_sta sta;
+};
+
+static inline enum nl80211_plink_state sta_plink_state(struct sta_info *sta)
+{
+#ifdef CONFIG_XRMAC_MESH
+	return sta->plink_state;
+#endif
+	return NL80211_PLINK_LISTEN;
+}
+
+static inline void set_sta_flag(struct sta_info *sta,
+				enum ieee80211_sta_info_flags flag)
+{
+	set_bit(flag, &sta->_flags);
+}
+
+static inline void clear_sta_flag(struct sta_info *sta,
+				  enum ieee80211_sta_info_flags flag)
+{
+	clear_bit(flag, &sta->_flags);
+}
+
+static inline int test_sta_flag(struct sta_info *sta,
+				enum ieee80211_sta_info_flags flag)
+{
+	return test_bit(flag, &sta->_flags);
+}
+
+static inline int test_and_clear_sta_flag(struct sta_info *sta,
+					  enum ieee80211_sta_info_flags flag)
+{
+	return test_and_clear_bit(flag, &sta->_flags);
+}
+
+void mac80211_assign_tid_tx(struct sta_info *sta, int tid,
+			     struct tid_ampdu_tx *tid_tx);
+
+static inline struct tid_ampdu_tx *
+rcu_dereference_protected_tid_tx(struct sta_info *sta, int tid)
+{
+	return rcu_dereference_protected(sta->ampdu_mlme.tid_tx[tid],
+					 lockdep_is_held(&sta->lock) ||
+					 lockdep_is_held(&sta->ampdu_mlme.mtx));
+}
+
+#define STA_HASH_SIZE 256
+#define STA_HASH(sta) (sta[5])
+
+
+/* Maximum number of frames to buffer per power saving station per AC */
+#define STA_MAX_TX_BUFFER	64
+
+/* Minimum buffered frame expiry time. If STA uses listen interval that is
+ * smaller than this value, the minimum value here is used instead. */
+#define STA_TX_BUFFER_EXPIRE (5 * HZ)
+
+/* How often station data is cleaned up (e.g., expiration of buffered frames)
+ */
+#define STA_INFO_CLEANUP_INTERVAL (4 * HZ)
+
+/*
+ * Get a STA info, must be under RCU read lock.
+ */
+struct sta_info *xrmac_sta_info_get(struct ieee80211_sub_if_data *sdata,
+			      const u8 *addr);
+
+struct sta_info *xrmac_sta_info_get_rx(struct ieee80211_sub_if_data *sdata,
+			      const u8 *addr);
+
+struct sta_info *xrmac_sta_info_get_bss(struct ieee80211_sub_if_data *sdata,
+				  const u8 *addr);
+
+struct sta_info *xrmac_sta_info_get_bss_rx(struct ieee80211_sub_if_data *sdata,
+				  const u8 *addr);
+
+static inline
+void for_each_sta_info_type_check(struct ieee80211_local *local,
+				 const u8 *addr,
+				 struct sta_info *sta,
+				 struct sta_info *nxt) {
+}
+
+#define for_each_sta_info(local, _addr, _sta, nxt) 			\
+	for (/* initialise loop */					\
+		_sta = rcu_dereference(local->sta_hash[STA_HASH(_addr)]), \
+		nxt = _sta ? rcu_dereference(_sta->hnext) : NULL;	\
+		/* typecheck */						\
+		for_each_sta_info_type_check(local, (_addr), _sta, nxt), \
+		/* continue condition */				\
+		_sta;							\
+		/* advance loop */					\
+		_sta = nxt,						\
+		nxt = _sta ? rcu_dereference(_sta->hnext) : NULL	\
+	     )								\
+	/* run code only if address matches and it's not a dummy sta */	\
+	if (memcmp(_sta->sta.addr, (_addr), ETH_ALEN) == 0 &&		\
+		!_sta->dummy)
+
+#define for_each_sta_info_rx(local, _addr, _sta, nxt)			\
+	for (/* initialise loop */					\
+		_sta = rcu_dereference(local->sta_hash[STA_HASH(_addr)]), \
+		nxt = _sta ? rcu_dereference(_sta->hnext) : NULL;	\
+		/* typecheck */						\
+		for_each_sta_info_type_check(local, (_addr), _sta, nxt), \
+		/* continue condition */				\
+		_sta;							\
+		/* advance loop */					\
+		_sta = nxt,						\
+		nxt = _sta ? rcu_dereference(_sta->hnext) : NULL	\
+	     )								\
+	/* compare address and run code only if it matches */		\
+	if (memcmp(_sta->sta.addr, (_addr), ETH_ALEN) == 0)
+
+/*
+ * Get STA info by index, BROKEN!
+ */
+struct sta_info *xrmac_sta_info_get_by_idx(struct ieee80211_sub_if_data *sdata,
+				     int idx);
+/*
+ * Create a new STA info, caller owns returned structure
+ * until xrmac_sta_info_insert().
+ */
+struct sta_info *xrmac_sta_info_alloc(struct ieee80211_sub_if_data *sdata,
+				const u8 *addr, gfp_t gfp);
+/*
+ * Insert STA info into hash table/list, returns zero or a
+ * -EEXIST if (if the same MAC address is already present).
+ *
+ * Calling the non-rcu version makes the caller relinquish,
+ * the _rcu version calls read_lock_rcu() and must be called
+ * without it held.
+ */
+int xrmac_sta_info_insert(struct sta_info *sta);
+int xrmac_sta_info_insert_rcu(struct sta_info *sta) __acquires(RCU);
+int xrmac_sta_info_insert_atomic(struct sta_info *sta);
+int sta_info_reinsert(struct sta_info *sta);
+
+int xrmac_sta_info_destroy_addr(struct ieee80211_sub_if_data *sdata,
+			  const u8 *addr);
+int xrmac_sta_info_destroy_addr_bss(struct ieee80211_sub_if_data *sdata,
+			      const u8 *addr);
+
+void xrmac_sta_info_recalc_tim(struct sta_info *sta);
+
+void xrmac_sta_info_init(struct ieee80211_local *local);
+void xrmac_sta_info_stop(struct ieee80211_local *local);
+int xrmac_sta_info_flush(struct ieee80211_local *local,
+		   struct ieee80211_sub_if_data *sdata);
+void mac80211_sta_expire(struct ieee80211_sub_if_data *sdata,
+			  unsigned long exp_time);
+
+void mac80211_sta_ps_deliver_wakeup(struct sta_info *sta);
+void mac80211_sta_ps_deliver_poll_response(struct sta_info *sta);
+void mac80211_sta_ps_deliver_uapsd(struct sta_info *sta);
+#ifdef CONFIG_XRMAC_XR_ROAMING_CHANGES
+void sta_info_free_rcu(struct rcu_head *rcu_h);
+#endif
+
+#endif /* STA_INFO_H */
diff -Naurp a/drivers/net/wireless/xr829/umac/status.c b/drivers/net/wireless/xr829/umac/status.c
--- a/drivers/net/wireless/xr829/umac/status.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/status.c	2022-08-27 01:22:42.958539877 +0300
@@ -0,0 +1,644 @@
+/*
+ * Copyright 2002-2005, Instant802 Networks, Inc.
+ * Copyright 2005-2006, Devicescape Software, Inc.
+ * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
+ * Copyright 2008-2010	Johannes Berg <johannes@sipsolutions.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/export.h>
+#include <net/mac80211.h>
+#include "ieee80211_i.h"
+#include "rate.h"
+#include "mesh.h"
+#include "led.h"
+#include "wme.h"
+
+
+void mac80211_tx_status_irqsafe(struct ieee80211_hw *hw,
+				 struct sk_buff *skb)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	int tmp;
+
+	skb->pkt_type = IEEE80211_TX_STATUS_MSG;
+	skb_queue_tail(info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS ?
+		       &local->skb_queue : &local->skb_queue_unreliable, skb);
+	tmp = skb_queue_len(&local->skb_queue) +
+		skb_queue_len(&local->skb_queue_unreliable);
+	while (tmp > IEEE80211_IRQSAFE_QUEUE_LIMIT &&
+	       (skb = skb_dequeue(&local->skb_queue_unreliable))) {
+		dev_kfree_skb_irq(skb);
+		tmp--;
+		I802_DEBUG_INC(local->tx_status_drop);
+	}
+	tasklet_schedule(&local->tasklet);
+}
+
+static void ieee80211_handle_filtered_frame(struct ieee80211_local *local,
+					    struct sta_info *sta,
+					    struct sk_buff *skb)
+{
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	struct ieee80211_hdr *hdr = (void *)skb->data;
+	int ac;
+
+	/*
+	 * This skb 'survived' a round-trip through the driver, and
+	 * hopefully the driver didn't mangle it too badly. However,
+	 * we can definitely not rely on the control information
+	 * being correct. Clear it so we don't get junk there, and
+	 * indicate that it needs new processing, but must not be
+	 * modified/encrypted again.
+	 */
+	memset(&info->control, 0, sizeof(info->control));
+
+	info->control.jiffies = jiffies;
+	info->control.vif = &sta->sdata->vif;
+	info->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING |
+		       IEEE80211_TX_INTFL_RETRANSMISSION;
+	info->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;
+
+	sta->tx_filtered_count++;
+
+	/*
+	 * Clear more-data bit on filtered frames, it might be set
+	 * but later frames might time out so it might have to be
+	 * clear again ... It's all rather unlikely (this frame
+	 * should time out first, right?) but let's not confuse
+	 * peers unnecessarily.
+	 */
+	if (hdr->frame_control & cpu_to_le16(IEEE80211_FCTL_MOREDATA))
+		hdr->frame_control &= ~cpu_to_le16(IEEE80211_FCTL_MOREDATA);
+
+	if (ieee80211_is_data_qos(hdr->frame_control)) {
+		u8 *p = ieee80211_get_qos_ctl(hdr);
+		int tid = *p & IEEE80211_QOS_CTL_TID_MASK;
+
+		/*
+		 * Clear EOSP if set, this could happen e.g.
+		 * if an absence period (us being a P2P GO)
+		 * shortens the SP.
+		 */
+		if (*p & IEEE80211_QOS_CTL_EOSP)
+			*p &= ~IEEE80211_QOS_CTL_EOSP;
+		ac = mac802_1d_to_ac[tid & 7];
+	} else {
+		ac = IEEE80211_AC_BE;
+	}
+
+	/*
+	 * Clear the TX filter mask for this STA when sending the next
+	 * packet. If the STA went to power save mode, this will happen
+	 * when it wakes up for the next time.
+	 */
+	set_sta_flag(sta, WLAN_STA_CLEAR_PS_FILT);
+
+	/*
+	 * This code races in the following way:
+	 *
+	 *  (1) STA sends frame indicating it will go to sleep and does so
+	 *  (2) hardware/firmware adds STA to filter list, passes frame up
+	 *  (3) hardware/firmware processes TX fifo and suppresses a frame
+	 *  (4) we get TX status before having processed the frame and
+	 *	knowing that the STA has gone to sleep.
+	 *
+	 * This is actually quite unlikely even when both those events are
+	 * processed from interrupts coming in quickly after one another or
+	 * even at the same time because we queue both TX status events and
+	 * RX frames to be processed by a tasklet and process them in the
+	 * same order that they were received or TX status last. Hence, there
+	 * is no race as long as the frame RX is processed before the next TX
+	 * status, which drivers can ensure, see below.
+	 *
+	 * Note that this can only happen if the hardware or firmware can
+	 * actually add STAs to the filter list, if this is done by the
+	 * driver in response to set_tim() (which will only reduce the race
+	 * this whole filtering tries to solve, not completely solve it)
+	 * this situation cannot happen.
+	 *
+	 * To completely solve this race drivers need to make sure that they
+	 *  (a) don't mix the irq-safe/not irq-safe TX status/RX processing
+	 *	functions and
+	 *  (b) always process RX events before TX status events if ordering
+	 *      can be unknown, for example with different interrupt status
+	 *	bits.
+	 *  (c) if PS mode transitions are manual (i.e. the flag
+	 *      %IEEE80211_HW_AP_LINK_PS is set), always process PS state
+	 *      changes before calling TX status events if ordering can be
+	 *	unknown.
+	 */
+	if (test_sta_flag(sta, WLAN_STA_PS_STA) &&
+	    skb_queue_len(&sta->tx_filtered[ac]) < STA_MAX_TX_BUFFER) {
+		skb_queue_tail(&sta->tx_filtered[ac], skb);
+		xrmac_sta_info_recalc_tim(sta);
+
+		if (!timer_pending(&local->sta_cleanup))
+			mod_timer(&local->sta_cleanup,
+				  round_jiffies(jiffies +
+						STA_INFO_CLEANUP_INTERVAL));
+		return;
+	}
+
+	if (!test_sta_flag(sta, WLAN_STA_PS_STA) &&
+	    !(info->flags & IEEE80211_TX_INTFL_RETRIED)) {
+		/* Software retry the packet once */
+		info->flags |= IEEE80211_TX_INTFL_RETRIED;
+		mac80211_add_pending_skb(local, skb);
+		return;
+	}
+
+#ifdef CONFIG_XRMAC_VERBOSE_DEBUG
+	if (net_ratelimit())
+		wiphy_debug(local->hw.wiphy,
+			    "dropped TX filtered frame, queue_len=%d PS=%d @%lu\n",
+			    skb_queue_len(&sta->tx_filtered[ac]),
+			    !!test_sta_flag(sta, WLAN_STA_PS_STA), jiffies);
+#endif
+	dev_kfree_skb(skb);
+}
+
+static void ieee80211_check_pending_bar(struct sta_info *sta, u8 *addr, u8 tid)
+{
+	struct tid_ampdu_tx *tid_tx;
+
+	tid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[tid]);
+	if (!tid_tx || !tid_tx->bar_pending)
+		return;
+
+	tid_tx->bar_pending = false;
+	mac80211_send_bar(&sta->sdata->vif, addr, tid, tid_tx->failed_bar_ssn);
+}
+
+static void ieee80211_frame_acked(struct sta_info *sta, struct sk_buff *skb)
+{
+	struct ieee80211_mgmt *mgmt = (void *) skb->data;
+	struct ieee80211_local *local = sta->local;
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
+
+	if (ieee80211_is_data_qos(mgmt->frame_control)) {
+		struct ieee80211_hdr *hdr = (void *) skb->data;
+		u8 *qc = ieee80211_get_qos_ctl(hdr);
+		u16 tid = qc[0] & 0xf;
+
+		ieee80211_check_pending_bar(sta, hdr->addr1, tid);
+	}
+
+	if (ieee80211_is_action(mgmt->frame_control) &&
+	    sdata->vif.type == NL80211_IFTYPE_STATION &&
+	    mgmt->u.action.category == WLAN_CATEGORY_HT &&
+	    mgmt->u.action.u.ht_smps.action == WLAN_HT_ACTION_SMPS) {
+		/*
+		 * This update looks racy, but isn't -- if we come
+		 * here we've definitely got a station that we're
+		 * talking to, and on a managed interface that can
+		 * only be the AP. And the only other place updating
+		 * this variable is before we're associated.
+		 */
+		switch (mgmt->u.action.u.ht_smps.smps_control) {
+		case WLAN_HT_SMPS_CONTROL_DYNAMIC:
+			sta->sdata->u.mgd.ap_smps = IEEE80211_SMPS_DYNAMIC;
+			break;
+		case WLAN_HT_SMPS_CONTROL_STATIC:
+			sta->sdata->u.mgd.ap_smps = IEEE80211_SMPS_STATIC;
+			break;
+		case WLAN_HT_SMPS_CONTROL_DISABLED:
+		default: /* shouldn't happen since we don't send that */
+			sta->sdata->u.mgd.ap_smps = IEEE80211_SMPS_OFF;
+			break;
+		}
+
+		mac80211_queue_work(&local->hw, &local->recalc_smps);
+	}
+}
+
+static inline u16 IEEE_GET_BE16(const u8 *a)
+{
+	return (a[0] << 8) | a[1];
+}
+static void ieee80211_4way_frame_acked (struct sta_info *sta, struct ieee80211_hdr *hdr)
+{
+	const unsigned int machdrlen = ieee80211_hdrlen(hdr->frame_control);
+	const int LLC_TYPE_OFF = 6;
+	const int ETHERNET_TYPE_LEN = 2;
+
+	u8 *eapol_frame = (u8 *)hdr + machdrlen + LLC_TYPE_OFF + ETHERNET_TYPE_LEN;
+	struct ieee80211_eapol_key *key_data =
+		(struct ieee80211_eapol_key *) (eapol_frame + sizeof(struct ieee802_1x_hdr));
+	u16 key_info = IEEE_GET_BE16(key_data->key_info);
+
+	if (!!(key_info & IEEE80211_KEY_INFO_KEY_TYPE) == 1) {
+		if (!!(key_info & IEEE80211_KEY_INFO_ACK) == 0) {
+			if (!!(key_info & IEEE80211_KEY_INFO_SECURE) == 1) {
+				if (sta->sdata->fourway_state == SDATA_4WAY_STATE_FINISH2) {
+					sta->sdata->fourway_state = SDATA_4WAY_STATE_FINISH4;
+					wake_up(&sta->sdata->setkey_wq);
+				}
+			} else {
+				sta->sdata->fourway_state = SDATA_4WAY_STATE_FINISH2;
+			}
+		}
+	}
+}
+
+static void ieee80211_set_bar_pending(struct sta_info *sta, u8 tid, u16 ssn)
+{
+	struct tid_ampdu_tx *tid_tx;
+
+	tid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[tid]);
+	if (!tid_tx)
+		return;
+
+	tid_tx->failed_bar_ssn = ssn;
+	tid_tx->bar_pending = true;
+}
+
+static int ieee80211_tx_radiotap_len(struct ieee80211_tx_info *info)
+{
+	int len = sizeof(struct ieee80211_radiotap_header);
+
+	/* IEEE80211_RADIOTAP_RATE rate */
+	if (info->status.rates[0].idx >= 0 &&
+	    !(info->status.rates[0].flags & IEEE80211_TX_RC_MCS))
+		len += 2;
+
+	/* IEEE80211_RADIOTAP_TX_FLAGS */
+	len += 2;
+
+	/* IEEE80211_RADIOTAP_DATA_RETRIES */
+	len += 1;
+
+	/* IEEE80211_TX_RC_MCS */
+	if (info->status.rates[0].idx >= 0 &&
+	    info->status.rates[0].flags & IEEE80211_TX_RC_MCS)
+		len += 3;
+
+	return len;
+}
+
+static void ieee80211_add_tx_radiotap_header(struct ieee80211_supported_band
+					     *sband, struct sk_buff *skb,
+					     int retry_count, int rtap_len)
+{
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	struct ieee80211_radiotap_header *rthdr;
+	unsigned char *pos;
+	u16 txflags;
+
+	rthdr = (struct ieee80211_radiotap_header *) skb_push(skb, rtap_len);
+
+	memset(rthdr, 0, rtap_len);
+	rthdr->it_len = cpu_to_le16(rtap_len);
+	rthdr->it_present =
+		cpu_to_le32((1 << IEEE80211_RADIOTAP_TX_FLAGS) |
+			    (1 << IEEE80211_RADIOTAP_DATA_RETRIES));
+	pos = (unsigned char *)(rthdr + 1);
+
+	/*
+	 * XXX: Once radiotap gets the bitmap reset thing the vendor
+	 *	extensions proposal contains, we can actually report
+	 *	the whole set of tries we did.
+	 */
+
+	/* IEEE80211_RADIOTAP_RATE */
+	if (info->status.rates[0].idx >= 0 &&
+	    !(info->status.rates[0].flags & IEEE80211_TX_RC_MCS)) {
+		rthdr->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_RATE);
+		*pos = sband->bitrates[info->status.rates[0].idx].bitrate / 5;
+		/* padding for tx flags */
+		pos += 2;
+	}
+
+	/* IEEE80211_RADIOTAP_TX_FLAGS */
+	txflags = 0;
+	if (!(info->flags & IEEE80211_TX_STAT_ACK) &&
+	    !is_multicast_ether_addr(hdr->addr1))
+		txflags |= IEEE80211_RADIOTAP_F_TX_FAIL;
+
+	if ((info->status.rates[0].flags & IEEE80211_TX_RC_USE_RTS_CTS) ||
+	    (info->status.rates[0].flags & IEEE80211_TX_RC_USE_CTS_PROTECT))
+		txflags |= IEEE80211_RADIOTAP_F_TX_CTS;
+	else if (info->status.rates[0].flags & IEEE80211_TX_RC_USE_RTS_CTS)
+		txflags |= IEEE80211_RADIOTAP_F_TX_RTS;
+
+	put_unaligned_le16(txflags, pos);
+	pos += 2;
+
+	/* IEEE80211_RADIOTAP_DATA_RETRIES */
+	/* for now report the total retry_count */
+	*pos = retry_count;
+	pos++;
+
+	/* IEEE80211_TX_RC_MCS */
+	if (info->status.rates[0].idx >= 0 &&
+	    info->status.rates[0].flags & IEEE80211_TX_RC_MCS) {
+		rthdr->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_MCS);
+		pos[0] = IEEE80211_RADIOTAP_MCS_HAVE_MCS |
+			 IEEE80211_RADIOTAP_MCS_HAVE_GI |
+			 IEEE80211_RADIOTAP_MCS_HAVE_BW;
+		if (info->status.rates[0].flags & IEEE80211_TX_RC_SHORT_GI)
+			pos[1] |= IEEE80211_RADIOTAP_MCS_SGI;
+		if (info->status.rates[0].flags & IEEE80211_TX_RC_40_MHZ_WIDTH)
+			pos[1] |= IEEE80211_RADIOTAP_MCS_BW_40;
+		if (info->status.rates[0].flags & IEEE80211_TX_RC_GREEN_FIELD)
+			pos[1] |= IEEE80211_RADIOTAP_MCS_FMT_GF;
+		pos[2] = info->status.rates[0].idx;
+		pos += 3;
+	}
+
+}
+
+/*
+ * Use a static threshold for now, best value to be determined
+ * by testing ...
+ * Should it depend on:
+ *  - on # of retransmissions
+ *  - current throughput (higher value for higher tpt)?
+ */
+#define STA_LOST_PKT_THRESHOLD	50
+
+void mac80211_tx_status(struct ieee80211_hw *hw, struct sk_buff *skb)
+{
+	struct sk_buff *skb2;
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	u16 frag, type;
+	__le16 fc;
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_sub_if_data *sdata;
+	struct net_device *prev_dev = NULL;
+	struct sta_info *sta, *tmp;
+	int retry_count = -1, i;
+	int rates_idx = -1;
+	bool send_to_cooked;
+	bool acked;
+	struct ieee80211_bar *bar;
+	u16 tid;
+	int rtap_len;
+
+	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {
+		if (info->status.rates[i].idx < 0) {
+			break;
+		} else if (i >= hw->max_report_rates) {
+			/* the HW cannot have attempted that rate */
+			info->status.rates[i].idx = -1;
+			info->status.rates[i].count = 0;
+			break;
+		}
+
+		retry_count += info->status.rates[i].count;
+	}
+	rates_idx = i - 1;
+
+	if (retry_count < 0)
+		retry_count = 0;
+
+	rcu_read_lock();
+
+	sband = local->hw.wiphy->bands[info->band];
+	fc = hdr->frame_control;
+
+	for_each_sta_info(local, hdr->addr1, sta, tmp) {
+		/* skip wrong virtual interface */
+		if (memcmp(hdr->addr2, sta->sdata->vif.addr, ETH_ALEN))
+			continue;
+
+		if (info->flags & IEEE80211_TX_STATUS_EOSP)
+			clear_sta_flag(sta, WLAN_STA_SP);
+
+		acked = !!(info->flags & IEEE80211_TX_STAT_ACK);
+		if (!acked && test_sta_flag(sta, WLAN_STA_PS_STA)) {
+			/*
+			 * The STA is in power save mode, so assume
+			 * that this TX packet failed because of that.
+			 */
+			ieee80211_handle_filtered_frame(local, sta, skb);
+			rcu_read_unlock();
+			return;
+		}
+
+		if ((local->hw.flags & IEEE80211_HW_HAS_RATE_CONTROL) &&
+		    (rates_idx != -1))
+			sta->last_tx_rate = info->status.rates[rates_idx];
+
+		if ((info->flags & IEEE80211_TX_STAT_AMPDU_NO_BACK) &&
+		    (ieee80211_is_data_qos(fc))) {
+			u16 tid, ssn;
+			u8 *qc;
+
+			qc = ieee80211_get_qos_ctl(hdr);
+			tid = qc[0] & 0xf;
+			ssn = ((le16_to_cpu(hdr->seq_ctrl) + 0x10)
+						& IEEE80211_SCTL_SEQ);
+			mac80211_send_bar(&sta->sdata->vif, hdr->addr1,
+					   tid, ssn);
+		}
+
+		if (!acked && ieee80211_is_back_req(fc)) {
+			u16 control;
+
+			/*
+			 * BAR failed, store the last SSN and retry sending
+			 * the BAR when the next unicast transmission on the
+			 * same TID succeeds.
+			 */
+			bar = (struct ieee80211_bar *) skb->data;
+			control = le16_to_cpu(bar->control);
+			if (!(control & IEEE80211_BAR_CTRL_MULTI_TID)) {
+				u16 ssn = le16_to_cpu(bar->start_seq_num);
+
+				tid = (control &
+				       IEEE80211_BAR_CTRL_TID_INFO_MASK) >>
+				      IEEE80211_BAR_CTRL_TID_INFO_SHIFT;
+
+				ieee80211_set_bar_pending(sta, tid, ssn);
+			}
+		}
+
+		if (info->flags & IEEE80211_TX_STAT_TX_FILTERED) {
+			ieee80211_handle_filtered_frame(local, sta, skb);
+			rcu_read_unlock();
+			return;
+		} else {
+			if (!acked)
+				sta->tx_retry_failed++;
+			sta->tx_retry_count += retry_count;
+		}
+
+		rate_control_tx_status(local, sband, sta, skb);
+		if (ieee80211_vif_is_mesh(&sta->sdata->vif))
+			mac80211s_update_metric(local, sta, skb);
+
+		if (!(info->flags & IEEE80211_TX_CTL_INJECTED) && acked)
+			ieee80211_frame_acked(sta, skb);
+
+		if ((sta->sdata->vif.type == NL80211_IFTYPE_STATION) &&
+		    (local->hw.flags & IEEE80211_HW_REPORTS_TX_ACK_STATUS))
+			mac80211_sta_tx_notify(sta->sdata, (void *) skb->data, acked);
+
+		if ((sta->sdata->vif.type == NL80211_IFTYPE_STATION) &&
+			sta->sdata->u.mgd.associated != NULL &&
+			(ieee80211_is_eapol_key(hdr))) {
+			ieee80211_4way_frame_acked(sta, hdr);
+		}
+
+		if (local->hw.flags & IEEE80211_HW_REPORTS_TX_ACK_STATUS) {
+			if (info->flags & IEEE80211_TX_STAT_ACK) {
+				if (sta->lost_packets)
+					sta->lost_packets = 0;
+			} else if (++sta->lost_packets >= STA_LOST_PKT_THRESHOLD) {
+				cfg80211_cqm_pktloss_notify(sta->sdata->dev,
+							    sta->sta.addr,
+							    sta->lost_packets,
+							    GFP_ATOMIC);
+				sta->lost_packets = 0;
+			}
+		}
+	}
+
+	rcu_read_unlock();
+
+	ieee80211_led_tx(local, 0);
+
+	/* SNMP counters
+	 * Fragments are passed to low-level drivers as separate skbs, so these
+	 * are actually fragments, not frames. Update frame counters only for
+	 * the first fragment of the frame. */
+
+	frag = le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_FRAG;
+	type = le16_to_cpu(hdr->frame_control) & IEEE80211_FCTL_FTYPE;
+
+	if (info->flags & IEEE80211_TX_STAT_ACK) {
+		if (frag == 0) {
+			local->dot11TransmittedFrameCount++;
+			if (is_multicast_ether_addr(hdr->addr1))
+				local->dot11MulticastTransmittedFrameCount++;
+			if (retry_count > 0)
+				local->dot11RetryCount++;
+			if (retry_count > 1)
+				local->dot11MultipleRetryCount++;
+		}
+
+		/* This counter shall be incremented for an acknowledged MPDU
+		 * with an individual address in the address 1 field or an MPDU
+		 * with a multicast address in the address 1 field of type Data
+		 * or Management. */
+		if (!is_multicast_ether_addr(hdr->addr1) ||
+		    type == IEEE80211_FTYPE_DATA ||
+		    type == IEEE80211_FTYPE_MGMT)
+			local->dot11TransmittedFragmentCount++;
+	} else {
+		if (frag == 0)
+			local->dot11FailedCount++;
+	}
+
+	sdata = vif_to_sdata(info->control.vif);
+	/*printk(KERN_ERR "%s, sdata=%p, &sdata->wdev=%p\n", __func__, sdata, &sdata->wdev);*/
+	if (ieee80211_is_nullfunc(fc) && ieee80211_has_pm(fc) &&
+	    (local->hw.flags & IEEE80211_HW_REPORTS_TX_ACK_STATUS) &&
+	    !(info->flags & IEEE80211_TX_CTL_INJECTED) &&
+	    sdata->ps_allowed && !(local->scanning)) {
+		if (info->flags & IEEE80211_TX_STAT_ACK)
+			sdata->u.mgd.flags |= IEEE80211_STA_NULLFUNC_ACKED;
+		else
+			mod_timer(&sdata->dynamic_ps_timer, jiffies +
+					msecs_to_jiffies(10));
+	}
+
+	if (info->flags & IEEE80211_TX_INTFL_NL80211_FRAME_TX) {
+		u64 cookie = (unsigned long)skb;
+		acked = !!(info->flags & IEEE80211_TX_STAT_ACK);
+		/*
+		printk(KERN_ERR "%s, sdata1=%p, &sdata->wdev1=%p\n", __func__,
+			IEEE80211_DEV_TO_SUB_IF(skb->dev), &(IEEE80211_DEV_TO_SUB_IF(skb->dev))->wdev);
+		*/
+		if (skb->dev) {
+			cfg80211_mgmt_tx_status(
+				&(IEEE80211_DEV_TO_SUB_IF(skb->dev))->wdev, cookie, skb->data, skb->len,
+				!!(info->flags & IEEE80211_TX_STAT_ACK), GFP_ATOMIC);
+		} else {
+			struct ieee80211_sub_if_data *p2p_sdata;
+
+			rcu_read_lock();
+
+			p2p_sdata = rcu_dereference(local->p2p_sdata);
+			if (p2p_sdata) {
+				cfg80211_mgmt_tx_status(
+					&p2p_sdata->wdev, cookie, skb->data,
+					skb->len, acked, GFP_ATOMIC);
+			}
+			rcu_read_unlock();
+		}
+	}
+
+	/* Need to make a copy before skb->cb gets cleared */
+	send_to_cooked = !!(info->flags & IEEE80211_TX_CTL_INJECTED) ||
+			(type != IEEE80211_FTYPE_DATA);
+
+	/*
+	 * This is a bit racy but we can avoid a lot of work
+	 * with this test...
+	 */
+	if (!local->monitors && (!send_to_cooked || !local->cooked_mntrs)) {
+		dev_kfree_skb(skb);
+		return;
+	}
+
+	/* send frame to monitor interfaces now */
+	rtap_len = ieee80211_tx_radiotap_len(info);
+	if (WARN_ON_ONCE(skb_headroom(skb) < rtap_len)) {
+		printk(KERN_ERR "mac80211_tx_status: headroom too small\n");
+		dev_kfree_skb(skb);
+		return;
+	}
+	ieee80211_add_tx_radiotap_header(sband, skb, retry_count, rtap_len);
+
+	/* XXX: is this sufficient for BPF? */
+	skb_set_mac_header(skb, 0);
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+	skb->pkt_type = PACKET_OTHERHOST;
+	skb->protocol = htons(ETH_P_802_2);
+	memset(skb->cb, 0, sizeof(skb->cb));
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
+		if (sdata->vif.type == NL80211_IFTYPE_MONITOR) {
+			if (!ieee80211_sdata_running(sdata))
+				continue;
+
+			if ((sdata->u.mntr_flags & MONITOR_FLAG_COOK_FRAMES) &&
+			    !send_to_cooked)
+				continue;
+
+			if (prev_dev) {
+				skb2 = skb_clone(skb, GFP_ATOMIC);
+				if (skb2) {
+					skb2->dev = prev_dev;
+					netif_rx(skb2);
+				}
+			}
+
+			prev_dev = sdata->dev;
+		}
+	}
+	if (prev_dev) {
+		skb->dev = prev_dev;
+		netif_rx(skb);
+		skb = NULL;
+	}
+	rcu_read_unlock();
+	dev_kfree_skb(skb);
+}
+
+void mac80211_report_low_ack(struct ieee80211_sta *pubsta, u32 num_packets)
+{
+	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
+	cfg80211_cqm_pktloss_notify(sta->sdata->dev, sta->sta.addr,
+				    num_packets, GFP_ATOMIC);
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/tkip.c b/drivers/net/wireless/xr829/umac/tkip.c
--- a/drivers/net/wireless/xr829/umac/tkip.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/tkip.c	2022-08-27 01:22:42.958539877 +0300
@@ -0,0 +1,356 @@
+/*
+ * Copyright 2002-2004, Instant802 Networks, Inc.
+ * Copyright 2005, Devicescape Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/kernel.h>
+#include <linux/bitops.h>
+#include <linux/types.h>
+#include <linux/netdevice.h>
+#include <linux/export.h>
+#include <asm/unaligned.h>
+
+#include <net/mac80211.h>
+#include "driver-ops.h"
+#include "key.h"
+#include "tkip.h"
+#include "wep.h"
+
+#define PHASE1_LOOP_COUNT 8
+
+/*
+ * 2-byte by 2-byte subset of the full AES S-box table; second part of this
+ * table is identical to first part but byte-swapped
+ */
+static const u16 tkip_sbox[256] = {
+	0xC6A5, 0xF884, 0xEE99, 0xF68D, 0xFF0D, 0xD6BD, 0xDEB1, 0x9154,
+	0x6050, 0x0203, 0xCEA9, 0x567D, 0xE719, 0xB562, 0x4DE6, 0xEC9A,
+	0x8F45, 0x1F9D, 0x8940, 0xFA87, 0xEF15, 0xB2EB, 0x8EC9, 0xFB0B,
+	0x41EC, 0xB367, 0x5FFD, 0x45EA, 0x23BF, 0x53F7, 0xE496, 0x9B5B,
+	0x75C2, 0xE11C, 0x3DAE, 0x4C6A, 0x6C5A, 0x7E41, 0xF502, 0x834F,
+	0x685C, 0x51F4, 0xD134, 0xF908, 0xE293, 0xAB73, 0x6253, 0x2A3F,
+	0x080C, 0x9552, 0x4665, 0x9D5E, 0x3028, 0x37A1, 0x0A0F, 0x2FB5,
+	0x0E09, 0x2436, 0x1B9B, 0xDF3D, 0xCD26, 0x4E69, 0x7FCD, 0xEA9F,
+	0x121B, 0x1D9E, 0x5874, 0x342E, 0x362D, 0xDCB2, 0xB4EE, 0x5BFB,
+	0xA4F6, 0x764D, 0xB761, 0x7DCE, 0x527B, 0xDD3E, 0x5E71, 0x1397,
+	0xA6F5, 0xB968, 0x0000, 0xC12C, 0x4060, 0xE31F, 0x79C8, 0xB6ED,
+	0xD4BE, 0x8D46, 0x67D9, 0x724B, 0x94DE, 0x98D4, 0xB0E8, 0x854A,
+	0xBB6B, 0xC52A, 0x4FE5, 0xED16, 0x86C5, 0x9AD7, 0x6655, 0x1194,
+	0x8ACF, 0xE910, 0x0406, 0xFE81, 0xA0F0, 0x7844, 0x25BA, 0x4BE3,
+	0xA2F3, 0x5DFE, 0x80C0, 0x058A, 0x3FAD, 0x21BC, 0x7048, 0xF104,
+	0x63DF, 0x77C1, 0xAF75, 0x4263, 0x2030, 0xE51A, 0xFD0E, 0xBF6D,
+	0x814C, 0x1814, 0x2635, 0xC32F, 0xBEE1, 0x35A2, 0x88CC, 0x2E39,
+	0x9357, 0x55F2, 0xFC82, 0x7A47, 0xC8AC, 0xBAE7, 0x322B, 0xE695,
+	0xC0A0, 0x1998, 0x9ED1, 0xA37F, 0x4466, 0x547E, 0x3BAB, 0x0B83,
+	0x8CCA, 0xC729, 0x6BD3, 0x283C, 0xA779, 0xBCE2, 0x161D, 0xAD76,
+	0xDB3B, 0x6456, 0x744E, 0x141E, 0x92DB, 0x0C0A, 0x486C, 0xB8E4,
+	0x9F5D, 0xBD6E, 0x43EF, 0xC4A6, 0x39A8, 0x31A4, 0xD337, 0xF28B,
+	0xD532, 0x8B43, 0x6E59, 0xDAB7, 0x018C, 0xB164, 0x9CD2, 0x49E0,
+	0xD8B4, 0xACFA, 0xF307, 0xCF25, 0xCAAF, 0xF48E, 0x47E9, 0x1018,
+	0x6FD5, 0xF088, 0x4A6F, 0x5C72, 0x3824, 0x57F1, 0x73C7, 0x9751,
+	0xCB23, 0xA17C, 0xE89C, 0x3E21, 0x96DD, 0x61DC, 0x0D86, 0x0F85,
+	0xE090, 0x7C42, 0x71C4, 0xCCAA, 0x90D8, 0x0605, 0xF701, 0x1C12,
+	0xC2A3, 0x6A5F, 0xAEF9, 0x69D0, 0x1791, 0x9958, 0x3A27, 0x27B9,
+	0xD938, 0xEB13, 0x2BB3, 0x2233, 0xD2BB, 0xA970, 0x0789, 0x33A7,
+	0x2DB6, 0x3C22, 0x1592, 0xC920, 0x8749, 0xAAFF, 0x5078, 0xA57A,
+	0x038F, 0x59F8, 0x0980, 0x1A17, 0x65DA, 0xD731, 0x84C6, 0xD0B8,
+	0x82C3, 0x29B0, 0x5A77, 0x1E11, 0x7BCB, 0xA8FC, 0x6DD6, 0x2C3A,
+};
+
+static u16 tkipS(u16 val)
+{
+	return tkip_sbox[val & 0xff] ^ swab16(tkip_sbox[val >> 8]);
+}
+
+static u8 *write_tkip_iv(u8 *pos, u16 iv16)
+{
+	*pos++ = iv16 >> 8;
+	*pos++ = ((iv16 >> 8) | 0x20) & 0x7f;
+	*pos++ = iv16 & 0xFF;
+	return pos;
+}
+
+/*
+ * P1K := Phase1(TA, TK, TSC)
+ * TA = transmitter address (48 bits)
+ * TK = dot11DefaultKeyValue or dot11KeyMappingValue (128 bits)
+ * TSC = TKIP sequence counter (48 bits, only 32 msb bits used)
+ * P1K: 80 bits
+ */
+static void tkip_mixing_phase1(const u8 *tk, struct tkip_ctx *ctx,
+			       const u8 *ta, u32 tsc_IV32)
+{
+	int i, j;
+	u16 *p1k = ctx->p1k;
+
+	p1k[0] = tsc_IV32 & 0xFFFF;
+	p1k[1] = tsc_IV32 >> 16;
+	p1k[2] = get_unaligned_le16(ta + 0);
+	p1k[3] = get_unaligned_le16(ta + 2);
+	p1k[4] = get_unaligned_le16(ta + 4);
+
+	for (i = 0; i < PHASE1_LOOP_COUNT; i++) {
+		j = 2 * (i & 1);
+		p1k[0] += tkipS(p1k[4] ^ get_unaligned_le16(tk + 0 + j));
+		p1k[1] += tkipS(p1k[0] ^ get_unaligned_le16(tk + 4 + j));
+		p1k[2] += tkipS(p1k[1] ^ get_unaligned_le16(tk + 8 + j));
+		p1k[3] += tkipS(p1k[2] ^ get_unaligned_le16(tk + 12 + j));
+		p1k[4] += tkipS(p1k[3] ^ get_unaligned_le16(tk + 0 + j)) + i;
+	}
+	ctx->state = TKIP_STATE_PHASE1_DONE;
+	ctx->p1k_iv32 = tsc_IV32;
+}
+
+static void tkip_mixing_phase2(const u8 *tk, struct tkip_ctx *ctx,
+			       u16 tsc_IV16, u8 *rc4key)
+{
+	u16 ppk[6];
+	const u16 *p1k = ctx->p1k;
+	int i;
+
+	ppk[0] = p1k[0];
+	ppk[1] = p1k[1];
+	ppk[2] = p1k[2];
+	ppk[3] = p1k[3];
+	ppk[4] = p1k[4];
+	ppk[5] = p1k[4] + tsc_IV16;
+
+	ppk[0] += tkipS(ppk[5] ^ get_unaligned_le16(tk + 0));
+	ppk[1] += tkipS(ppk[0] ^ get_unaligned_le16(tk + 2));
+	ppk[2] += tkipS(ppk[1] ^ get_unaligned_le16(tk + 4));
+	ppk[3] += tkipS(ppk[2] ^ get_unaligned_le16(tk + 6));
+	ppk[4] += tkipS(ppk[3] ^ get_unaligned_le16(tk + 8));
+	ppk[5] += tkipS(ppk[4] ^ get_unaligned_le16(tk + 10));
+	ppk[0] += ror16(ppk[5] ^ get_unaligned_le16(tk + 12), 1);
+	ppk[1] += ror16(ppk[0] ^ get_unaligned_le16(tk + 14), 1);
+	ppk[2] += ror16(ppk[1], 1);
+	ppk[3] += ror16(ppk[2], 1);
+	ppk[4] += ror16(ppk[3], 1);
+	ppk[5] += ror16(ppk[4], 1);
+
+	rc4key = write_tkip_iv(rc4key, tsc_IV16);
+	*rc4key++ = ((ppk[5] ^ get_unaligned_le16(tk)) >> 1) & 0xFF;
+
+	for (i = 0; i < 6; i++)
+		put_unaligned_le16(ppk[i], rc4key + 2 * i);
+}
+
+/* Add TKIP IV and Ext. IV at @pos. @iv0, @iv1, and @iv2 are the first octets
+ * of the IV. Returns pointer to the octet following IVs (i.e., beginning of
+ * the packet payload). */
+u8 *mac80211_tkip_add_iv(u8 *pos, struct ieee80211_key *key)
+{
+	lockdep_assert_held(&key->u.tkip.txlock);
+
+	pos = write_tkip_iv(pos, key->u.tkip.tx.iv16);
+	*pos++ = (key->conf.keyidx << 6) | (1 << 5) /* Ext IV */;
+	put_unaligned_le32(key->u.tkip.tx.iv32, pos);
+	return pos + 4;
+}
+
+static void ieee80211_compute_tkip_p1k(struct ieee80211_key *key, u32 iv32)
+{
+	struct ieee80211_sub_if_data *sdata = key->sdata;
+	struct tkip_ctx *ctx = &key->u.tkip.tx;
+	const u8 *tk = &key->conf.key[NL80211_TKIP_DATA_OFFSET_ENCR_KEY];
+
+	lockdep_assert_held(&key->u.tkip.txlock);
+
+	/*
+	 * Update the P1K when the IV32 is different from the value it
+	 * had when we last computed it (or when not initialised yet).
+	 * This might flip-flop back and forth if packets are processed
+	 * out-of-order due to the different ACs, but then we have to
+	 * just compute the P1K more often.
+	 */
+	if (ctx->p1k_iv32 != iv32 || ctx->state == TKIP_STATE_NOT_INIT)
+		tkip_mixing_phase1(tk, ctx, sdata->vif.addr, iv32);
+}
+
+void mac80211_get_tkip_p1k_iv(struct ieee80211_key_conf *keyconf,
+			       u32 iv32, u16 *p1k)
+{
+	struct ieee80211_key *key = (struct ieee80211_key *)
+			container_of(keyconf, struct ieee80211_key, conf);
+	struct tkip_ctx *ctx = &key->u.tkip.tx;
+	unsigned long flags;
+
+	spin_lock_irqsave(&key->u.tkip.txlock, flags);
+	ieee80211_compute_tkip_p1k(key, iv32);
+	memcpy(p1k, ctx->p1k, sizeof(ctx->p1k));
+	spin_unlock_irqrestore(&key->u.tkip.txlock, flags);
+}
+
+void mac80211_get_tkip_rx_p1k(struct ieee80211_key_conf *keyconf,
+							const u8 *ta, u32 iv32, u16 *p1k)
+{
+	const u8 *tk = &keyconf->key[NL80211_TKIP_DATA_OFFSET_ENCR_KEY];
+	struct tkip_ctx ctx;
+
+	tkip_mixing_phase1(tk, &ctx, ta, iv32);
+	memcpy(p1k, ctx.p1k, sizeof(ctx.p1k));
+}
+
+void mac80211_get_tkip_p2k(struct ieee80211_key_conf *keyconf,
+			    struct sk_buff *skb, u8 *p2k)
+{
+	struct ieee80211_key *key = (struct ieee80211_key *)
+			container_of(keyconf, struct ieee80211_key, conf);
+	const u8 *tk = &key->conf.key[NL80211_TKIP_DATA_OFFSET_ENCR_KEY];
+	struct tkip_ctx *ctx = &key->u.tkip.tx;
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+	const u8 *data = (u8 *)hdr + ieee80211_hdrlen(hdr->frame_control);
+	u32 iv32 = get_unaligned_le32(&data[4]);
+	u16 iv16 = data[2] | (data[0] << 8);
+	unsigned long flags;
+
+	spin_lock_irqsave(&key->u.tkip.txlock, flags);
+	ieee80211_compute_tkip_p1k(key, iv32);
+	tkip_mixing_phase2(tk, ctx, iv16, p2k);
+	spin_unlock_irqrestore(&key->u.tkip.txlock, flags);
+}
+
+/*
+ * Encrypt packet payload with TKIP using @key. @pos is a pointer to the
+ * beginning of the buffer containing payload. This payload must include
+ * the IV/Ext.IV and space for (taildroom) four octets for ICV.
+ * @payload_len is the length of payload (_not_ including IV/ICV length).
+ * @ta is the transmitter addresses.
+ */
+int mac80211_tkip_encrypt_data(struct arc4_ctx *ctx,
+				struct ieee80211_key *key,
+				struct sk_buff *skb,
+				u8 *payload, size_t payload_len)
+{
+	u8 rc4key[16];
+
+	mac80211_get_tkip_p2k(&key->conf, skb, rc4key);
+
+	return mac80211_wep_encrypt_data(ctx, rc4key, 16,
+					  payload, payload_len);
+}
+
+/* Decrypt packet payload with TKIP using @key. @pos is a pointer to the
+ * beginning of the buffer containing IEEE 802.11 header payload, i.e.,
+ * including IV, Ext. IV, real data, Michael MIC, ICV. @payload_len is the
+ * length of payload, including IV, Ext. IV, MIC, ICV.  */
+int mac80211_tkip_decrypt_data(struct arc4_ctx *ctx,
+				struct ieee80211_key *key,
+				u8 *payload, size_t payload_len, u8 *ta,
+				u8 *ra, int only_iv, int queue,
+				u32 *out_iv32, u16 *out_iv16)
+{
+	u32 iv32;
+	u32 iv16;
+	u8 rc4key[16], keyid, *pos = payload;
+	int res;
+	const u8 *tk = &key->conf.key[NL80211_TKIP_DATA_OFFSET_ENCR_KEY];
+
+	if (payload_len < 12)
+		return -1;
+
+	iv16 = (pos[0] << 8) | pos[2];
+	keyid = pos[3];
+	iv32 = get_unaligned_le32(pos + 4);
+	pos += 8;
+#ifdef CONFIG_XRMAC_TKIP_DEBUG
+	{
+		int i;
+		printk(KERN_DEBUG "TKIP decrypt: data(len=%zd)", payload_len);
+		for (i = 0; i < payload_len; i++)
+			printk(" %02x", payload[i]);
+		printk("\n");
+		printk(KERN_DEBUG "TKIP decrypt: iv16=%04x iv32=%08x\n",
+		       iv16, iv32);
+	}
+#endif
+
+	if (!(keyid & (1 << 5)))
+		return TKIP_DECRYPT_NO_EXT_IV;
+
+	if ((keyid >> 6) != key->conf.keyidx)
+		return TKIP_DECRYPT_INVALID_KEYIDX;
+
+	if (key->u.tkip.rx[queue].state != TKIP_STATE_NOT_INIT &&
+	    (iv32 < key->u.tkip.rx[queue].iv32 ||
+	     (iv32 == key->u.tkip.rx[queue].iv32 &&
+	      iv16 <= key->u.tkip.rx[queue].iv16))) {
+#ifdef CONFIG_XRMAC_TKIP_DEBUG
+		printk(KERN_DEBUG "TKIP replay detected for RX frame from "
+		       "%pM (RX IV (%04x, %02x) <= prev. IV (%04x, %02x)\n",
+		       ta,
+		       iv32, iv16, key->u.tkip.rx[queue].iv32,
+		       key->u.tkip.rx[queue].iv16);
+#endif
+		return TKIP_DECRYPT_REPLAY;
+	}
+
+	if (only_iv) {
+		res = TKIP_DECRYPT_OK;
+		key->u.tkip.rx[queue].state = TKIP_STATE_PHASE1_HW_UPLOADED;
+		goto done;
+	}
+
+	if (key->u.tkip.rx[queue].state == TKIP_STATE_NOT_INIT ||
+	    key->u.tkip.rx[queue].iv32 != iv32) {
+		/* IV16 wrapped around - perform TKIP phase 1 */
+		tkip_mixing_phase1(tk, &key->u.tkip.rx[queue], ta, iv32);
+#ifdef CONFIG_XRMAC_TKIP_DEBUG
+		{
+			int i;
+			u8 key_offset = NL80211_TKIP_DATA_OFFSET_ENCR_KEY;
+			printk(KERN_DEBUG "TKIP decrypt: Phase1 TA=%pM"
+			       " TK=", ta);
+			for (i = 0; i < 16; i++)
+				printk("%02x ",
+				       key->conf.key[key_offset + i]);
+			printk("\n");
+			printk(KERN_DEBUG "TKIP decrypt: P1K=");
+			for (i = 0; i < 5; i++)
+				printk("%04x ", key->u.tkip.rx[queue].p1k[i]);
+			printk("\n");
+		}
+#endif
+	}
+	if (key->local->ops->update_tkip_key &&
+	    key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE &&
+	    key->u.tkip.rx[queue].state != TKIP_STATE_PHASE1_HW_UPLOADED) {
+		struct ieee80211_sub_if_data *sdata = key->sdata;
+
+		if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
+			sdata = container_of(key->sdata->bss,
+					struct ieee80211_sub_if_data, u.ap);
+		drv_update_tkip_key(key->local, sdata, &key->conf, key->sta,
+				iv32, key->u.tkip.rx[queue].p1k);
+		key->u.tkip.rx[queue].state = TKIP_STATE_PHASE1_HW_UPLOADED;
+	}
+
+	tkip_mixing_phase2(tk, &key->u.tkip.rx[queue], iv16, rc4key);
+#ifdef CONFIG_XRMAC_TKIP_DEBUG
+	{
+		int i;
+		printk(KERN_DEBUG "TKIP decrypt: Phase2 rc4key=");
+		for (i = 0; i < 16; i++)
+			printk("%02x ", rc4key[i]);
+		printk("\n");
+	}
+#endif
+
+	res = mac80211_wep_decrypt_data(ctx, rc4key, 16, pos, payload_len - 12);
+ done:
+	if (res == TKIP_DECRYPT_OK) {
+		/*
+		 * Record previously received IV, will be copied into the
+		 * key information after MIC verification. It is possible
+		 * that we don't catch replays of fragments but that's ok
+		 * because the Michael MIC verication will then fail.
+		 */
+		*out_iv32 = iv32;
+		*out_iv16 = iv16;
+	}
+
+	return res;
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/tkip.h b/drivers/net/wireless/xr829/umac/tkip.h
--- a/drivers/net/wireless/xr829/umac/tkip.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/tkip.h	2022-08-27 01:22:42.958539877 +0300
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2002-2004, Instant802 Networks, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef TKIP_H
+#define TKIP_H
+
+#include <linux/types.h>
+#include <linux/crypto.h>
+#include "key.h"
+
+u8 *mac80211_tkip_add_iv(u8 *pos, struct ieee80211_key *key);
+
+int mac80211_tkip_encrypt_data(struct arc4_ctx *ctx,
+				struct ieee80211_key *key,
+				struct sk_buff *skb,
+				u8 *payload, size_t payload_len);
+
+enum {
+	TKIP_DECRYPT_OK = 0,
+	TKIP_DECRYPT_NO_EXT_IV = -1,
+	TKIP_DECRYPT_INVALID_KEYIDX = -2,
+	TKIP_DECRYPT_REPLAY = -3,
+};
+int mac80211_tkip_decrypt_data(struct arc4_ctx *ctx,
+				struct ieee80211_key *key,
+				u8 *payload, size_t payload_len, u8 *ta,
+				u8 *ra, int only_iv, int queue,
+				u32 *out_iv32, u16 *out_iv16);
+
+#endif /* TKIP_H */
diff -Naurp a/drivers/net/wireless/xr829/umac/tx.c b/drivers/net/wireless/xr829/umac/tx.c
--- a/drivers/net/wireless/xr829/umac/tx.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/tx.c	2022-08-27 01:22:42.958539877 +0300
@@ -0,0 +1,2745 @@
+/*
+ * Copyright 2002-2005, Instant802 Networks, Inc.
+ * Copyright 2005-2006, Devicescape Software, Inc.
+ * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
+ * Copyright 2007	Johannes Berg <johannes@sipsolutions.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *
+ * Transmit and frame generation functions.
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/skbuff.h>
+#include <linux/etherdevice.h>
+#include <linux/bitmap.h>
+#include <linux/rcupdate.h>
+#include <linux/export.h>
+#include <net/net_namespace.h>
+#include <net/ieee80211_radiotap.h>
+#include <net/cfg80211.h>
+#include <net/mac80211.h>
+#include <asm/unaligned.h>
+
+#include "ieee80211_i.h"
+#include "driver-ops.h"
+#include "led.h"
+#include "mesh.h"
+#include "wep.h"
+#include "wpa.h"
+#include "wapi.h"
+#include "wme.h"
+#include "rate.h"
+
+/* misc utils */
+
+static __le16 ieee80211_duration(struct ieee80211_tx_data *tx, int group_addr,
+				 int next_frag_len)
+{
+	int rate, mrate, erp, dur, i;
+	struct ieee80211_rate *txrate;
+	struct ieee80211_local *local = tx->local;
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_hdr *hdr;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);
+
+	/* assume HW handles this */
+	if (info->control.rates[0].flags & IEEE80211_TX_RC_MCS)
+		return 0;
+
+	/* uh huh? */
+	if (WARN_ON_ONCE(info->control.rates[0].idx < 0))
+		return 0;
+
+	sband = local->hw.wiphy->bands[tx->channel->band];
+	txrate = &sband->bitrates[info->control.rates[0].idx];
+
+	erp = txrate->flags & IEEE80211_RATE_ERP_G;
+
+	/*
+	 * data and mgmt (except PS Poll):
+	 * - during CFP: 32768
+	 * - during contention period:
+	 *   if addr1 is group address: 0
+	 *   if more fragments = 0 and addr1 is individual address: time to
+	 *      transmit one ACK plus SIFS
+	 *   if more fragments = 1 and addr1 is individual address: time to
+	 *      transmit next fragment plus 2 x ACK plus 3 x SIFS
+	 *
+	 * IEEE 802.11, 9.6:
+	 * - control response frame (CTS or ACK) shall be transmitted using the
+	 *   same rate as the immediately previous frame in the frame exchange
+	 *   sequence, if this rate belongs to the PHY mandatory rates, or else
+	 *   at the highest possible rate belonging to the PHY rates in the
+	 *   BSSBasicRateSet
+	 */
+	hdr = (struct ieee80211_hdr *)tx->skb->data;
+	if (ieee80211_is_ctl(hdr->frame_control)) {
+		/* TODO: These control frames are not currently sent by
+		 * mac80211, but should they be implemented, this function
+		 * needs to be updated to support duration field calculation.
+		 *
+		 * RTS: time needed to transmit pending data/mgmt frame plus
+		 *    one CTS frame plus one ACK frame plus 3 x SIFS
+		 * CTS: duration of immediately previous RTS minus time
+		 *    required to transmit CTS and its SIFS
+		 * ACK: 0 if immediately previous directed data/mgmt had
+		 *    more=0, with more=1 duration in ACK frame is duration
+		 *    from previous frame minus time needed to transmit ACK
+		 *    and its SIFS
+		 * PS Poll: BIT(15) | BIT(14) | aid
+		 */
+		return 0;
+	}
+
+	/* data/mgmt */
+	if (0 /* FIX: data/mgmt during CFP */)
+		return cpu_to_le16(32768);
+
+	if (group_addr) /* Group address as the destination - no ACK */
+		return 0;
+
+	/* Individual destination address:
+	 * IEEE 802.11, Ch. 9.6 (after IEEE 802.11g changes)
+	 * CTS and ACK frames shall be transmitted using the highest rate in
+	 * basic rate set that is less than or equal to the rate of the
+	 * immediately previous frame and that is using the same modulation
+	 * (CCK or OFDM). If no basic rate set matches with these requirements,
+	 * the highest mandatory rate of the PHY that is less than or equal to
+	 * the rate of the previous frame is used.
+	 * Mandatory rates for IEEE 802.11g PHY: 1, 2, 5.5, 11, 6, 12, 24 Mbps
+	 */
+	rate = -1;
+	/* use lowest available if everything fails */
+	mrate = sband->bitrates[0].bitrate;
+	for (i = 0; i < sband->n_bitrates; i++) {
+		struct ieee80211_rate *r = &sband->bitrates[i];
+
+		if (r->bitrate > txrate->bitrate)
+			break;
+
+		if (tx->sdata->vif.bss_conf.basic_rates & BIT(i))
+			rate = r->bitrate;
+
+		switch (sband->band) {
+		case NL80211_BAND_2GHZ: {
+			u32 flag;
+			if (tx->sdata->flags & IEEE80211_SDATA_OPERATING_GMODE)
+				flag = IEEE80211_RATE_MANDATORY_G;
+			else
+				flag = IEEE80211_RATE_MANDATORY_B;
+			if (r->flags & flag)
+				mrate = r->bitrate;
+			break;
+		}
+		case NL80211_BAND_5GHZ:
+			if (r->flags & IEEE80211_RATE_MANDATORY_A)
+				mrate = r->bitrate;
+			break;
+		case NL80211_BAND_60GHZ:
+		case NL80211_BAND_6GHZ:
+			break;
+		case NUM_NL80211_BANDS:
+			WARN_ON(1);
+			break;
+		}
+	}
+	if (rate == -1) {
+		/* No matching basic rate found; use highest suitable mandatory
+		 * PHY rate */
+		rate = mrate;
+	}
+
+	/* Time needed to transmit ACK
+	 * (10 bytes + 4-byte FCS = 112 bits) plus SIFS; rounded up
+	 * to closest integer */
+
+	dur = mac80211_frame_duration(sband->band, 10, rate, erp,
+				tx->sdata->vif.bss_conf.use_short_preamble);
+
+	if (next_frag_len) {
+		/* Frame is fragmented: duration increases with time needed to
+		 * transmit next fragment plus ACK and 2 x SIFS. */
+		dur *= 2; /* ACK + SIFS */
+		/* next fragment */
+		dur += mac80211_frame_duration(sband->band, next_frag_len,
+				txrate->bitrate, erp,
+				tx->sdata->vif.bss_conf.use_short_preamble);
+	}
+
+	return cpu_to_le16(dur);
+}
+
+static inline int is_ieee80211_device(struct ieee80211_local *local,
+				      struct net_device *dev)
+{
+	return local == wdev_priv(dev->ieee80211_ptr);
+}
+
+/* tx handlers */
+static ieee80211_tx_result debug_noinline
+ieee80211_tx_h_dynamic_ps(struct ieee80211_tx_data *tx)
+{
+	struct ieee80211_local *local = tx->local;
+	struct ieee80211_if_managed *ifmgd;
+
+	/* driver doesn't support power save */
+	if (!(local->hw.flags & IEEE80211_HW_SUPPORTS_PS))
+		return TX_CONTINUE;
+
+	/* hardware does dynamic power save */
+	if (local->hw.flags & IEEE80211_HW_SUPPORTS_DYNAMIC_PS)
+		return TX_CONTINUE;
+
+	/* dynamic power save disabled */
+	if (tx->sdata->vif.bss_conf.dynamic_ps_timeout <= 0)
+		return TX_CONTINUE;
+
+	/* we are scanning, don't enable power save */
+	if (local->scanning)
+		return TX_CONTINUE;
+
+	if (!tx->sdata->ps_allowed)
+		return TX_CONTINUE;
+
+	/* No point if we're going to suspend */
+	if (local->quiescing)
+		return TX_CONTINUE;
+
+	/* dynamic ps is supported only in managed mode */
+	if (tx->sdata->vif.type != NL80211_IFTYPE_STATION)
+		return TX_CONTINUE;
+
+	ifmgd = &tx->sdata->u.mgd;
+
+	/*
+	 * Don't wakeup from power save if u-apsd is enabled, voip ac has
+	 * u-apsd enabled and the frame is in voip class. This effectively
+	 * means that even if all access categories have u-apsd enabled, in
+	 * practise u-apsd is only used with the voip ac. This is a
+	 * workaround for the case when received voip class packets do not
+	 * have correct qos tag for some reason, due the network or the
+	 * peer application.
+	 *
+	 * Note: local->uapsd_queues access is racy here. If the value is
+	 * changed via debugfs, user needs to reassociate manually to have
+	 * everything in sync.
+	 */
+	if ((ifmgd->flags & IEEE80211_STA_UAPSD_ENABLED)
+	    && (local->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VO)
+	    && skb_get_queue_mapping(tx->skb) == 0)
+		return TX_CONTINUE;
+
+	if (tx->sdata->vif.bss_conf.ps_enabled) {
+		// XXX: update this to new queue locking API
+		mac80211_stop_queues_by_reason(&local->hw,
+						IEEE80211_QUEUE_STOP_REASON_PS);
+		ifmgd->flags &= ~IEEE80211_STA_NULLFUNC_ACKED;
+		mac80211_queue_work(&local->hw,
+				     &tx->sdata->dynamic_ps_disable_work);
+	}
+
+	/* Don't restart the timer if we're not disassociated */
+	if (!ifmgd->associated)
+		return TX_CONTINUE;
+
+	mod_timer(&tx->sdata->dynamic_ps_timer, jiffies +
+		  msecs_to_jiffies(tx->sdata->vif.bss_conf.dynamic_ps_timeout));
+
+	return TX_CONTINUE;
+}
+
+static ieee80211_tx_result debug_noinline
+ieee80211_tx_h_check_assoc(struct ieee80211_tx_data *tx)
+{
+
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);
+	bool assoc = false;
+
+	if (unlikely(info->flags & IEEE80211_TX_CTL_INJECTED))
+		return TX_CONTINUE;
+
+	if (unlikely(test_bit(SCAN_OFF_CHANNEL, &tx->local->scanning)) &&
+	    !ieee80211_is_probe_req(hdr->frame_control) &&
+	    !ieee80211_is_nullfunc(hdr->frame_control))
+		/*
+		 * When software scanning only nullfunc frames (to notify
+		 * the sleep state to the AP) and probe requests (for the
+		 * active scan) are allowed, all other frames should not be
+		 * sent and we should not get here, but if we do
+		 * nonetheless, drop them to avoid sending them
+		 * off-channel. See the link below and
+		 * ieee80211_start_scan() for more.
+		 *
+		 * http://article.gmane.org/gmane.linux.kernel.wireless.general/30089
+		 */
+		return TX_DROP;
+
+	if (tx->sdata->vif.type == NL80211_IFTYPE_WDS)
+		return TX_CONTINUE;
+
+	if (tx->sdata->vif.type == NL80211_IFTYPE_MESH_POINT)
+		return TX_CONTINUE;
+
+	if (tx->flags & IEEE80211_TX_PS_BUFFERED)
+		return TX_CONTINUE;
+
+	if (tx->sta)
+		assoc = test_sta_flag(tx->sta, WLAN_STA_ASSOC);
+
+	if (likely(tx->flags & IEEE80211_TX_UNICAST)) {
+		if (unlikely(!assoc &&
+			     tx->sdata->vif.type != NL80211_IFTYPE_ADHOC &&
+			     ieee80211_is_data(hdr->frame_control))) {
+#ifdef CONFIG_XRMAC_VERBOSE_DEBUG
+			printk(KERN_DEBUG "%s: dropped data frame to not "
+			       "associated station %pM\n",
+			       tx->sdata->name, hdr->addr1);
+#endif /* CONFIG_XRMAC_VERBOSE_DEBUG */
+			I802_DEBUG_INC(tx->local->tx_handlers_drop_not_assoc);
+			return TX_DROP;
+		}
+	} else {
+		if (unlikely(ieee80211_is_data(hdr->frame_control) &&
+			     tx->local->num_sta == 0 &&
+			     tx->sdata->vif.type != NL80211_IFTYPE_ADHOC)) {
+			/*
+			 * No associated STAs - no need to send multicast
+			 * frames.
+			 */
+			return TX_DROP;
+		}
+		return TX_CONTINUE;
+	}
+
+	return TX_CONTINUE;
+}
+
+/* This function is called whenever the AP is about to exceed the maximum limit
+ * of buffered frames for power saving STAs. This situation should not really
+ * happen often during normal operation, so dropping the oldest buffered packet
+ * from each queue should be OK to make some room for new frames. */
+static void purge_old_ps_buffers(struct ieee80211_local *local)
+{
+	int total = 0, purged = 0;
+	struct sk_buff *skb;
+	struct ieee80211_sub_if_data *sdata;
+	struct sta_info *sta;
+
+	/*
+	 * virtual interfaces are protected by RCU
+	 */
+	rcu_read_lock();
+
+	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
+		struct ieee80211_if_ap *ap;
+		if (sdata->vif.type != NL80211_IFTYPE_AP)
+			continue;
+		ap = &sdata->u.ap;
+		skb = skb_dequeue(&ap->ps_bc_buf);
+		if (skb) {
+			purged++;
+			dev_kfree_skb(skb);
+		}
+		total += skb_queue_len(&ap->ps_bc_buf);
+	}
+
+	/*
+	 * Drop one frame from each station from the lowest-priority
+	 * AC that has frames at all.
+	 */
+	list_for_each_entry_rcu(sta, &local->sta_list, list) {
+		int ac;
+
+		for (ac = IEEE80211_AC_BK; ac >= IEEE80211_AC_VO; ac--) {
+			skb = skb_dequeue(&sta->ps_tx_buf[ac]);
+			total += skb_queue_len(&sta->ps_tx_buf[ac]);
+			if (skb) {
+				purged++;
+				dev_kfree_skb(skb);
+				break;
+			}
+		}
+	}
+
+	rcu_read_unlock();
+
+	local->total_ps_buffered = total;
+#ifdef CONFIG_XRMAC_VERBOSE_PS_DEBUG
+	wiphy_debug(local->hw.wiphy, "PS buffers full - purged %d frames\n",
+		    purged);
+#endif
+}
+
+static ieee80211_tx_result
+ieee80211_tx_h_multicast_ps_buf(struct ieee80211_tx_data *tx)
+{
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;
+
+	/*
+	 * broadcast/multicast frame
+	 *
+	 * If any of the associated stations is in power save mode,
+	 * the frame is buffered to be sent after DTIM beacon frame.
+	 * This is done either by the hardware or us.
+	 */
+
+	/* powersaving STAs only in AP/VLAN mode */
+	if (!tx->sdata->bss)
+		return TX_CONTINUE;
+
+	/* no buffering for ordered frames */
+	if (ieee80211_has_order(hdr->frame_control))
+		return TX_CONTINUE;
+
+	/* no stations in PS mode */
+	if (!atomic_read(&tx->sdata->bss->num_sta_ps))
+		return TX_CONTINUE;
+
+	info->flags |= IEEE80211_TX_CTL_SEND_AFTER_DTIM;
+	if (tx->local->hw.flags & IEEE80211_HW_QUEUE_CONTROL)
+		info->hw_queue = tx->sdata->vif.cab_queue;
+
+	/* device releases frame after DTIM beacon */
+	if (!(tx->local->hw.flags & IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING))
+		return TX_CONTINUE;
+
+	/* buffered in mac80211 */
+	if (tx->local->total_ps_buffered >= TOTAL_MAX_TX_BUFFER)
+		purge_old_ps_buffers(tx->local);
+
+	if (skb_queue_len(&tx->sdata->bss->ps_bc_buf) >= AP_MAX_BC_BUFFER) {
+#ifdef CONFIG_XRMAC_VERBOSE_PS_DEBUG
+		if (net_ratelimit())
+			printk(KERN_DEBUG "%s: BC TX buffer full - dropping the oldest frame\n",
+			       tx->sdata->name);
+#endif
+		dev_kfree_skb(skb_dequeue(&tx->sdata->bss->ps_bc_buf));
+	} else
+		tx->local->total_ps_buffered++;
+
+	skb_queue_tail(&tx->sdata->bss->ps_bc_buf, tx->skb);
+
+	return TX_QUEUED;
+}
+
+static int ieee80211_use_mfp(__le16 fc, struct sta_info *sta,
+			     struct sk_buff *skb)
+{
+	if (!ieee80211_is_mgmt(fc))
+		return 0;
+
+	if (sta == NULL || !test_sta_flag(sta, WLAN_STA_MFP))
+		return 0;
+
+	if (!ieee80211_is_robust_mgmt_frame(skb))
+		return 0;
+
+	return 1;
+}
+
+static ieee80211_tx_result
+ieee80211_tx_h_unicast_ps_buf(struct ieee80211_tx_data *tx)
+{
+	struct sta_info *sta = tx->sta;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;
+	struct ieee80211_local *local = tx->local;
+
+	if (unlikely(!sta ||
+		     ieee80211_is_probe_resp(hdr->frame_control) ||
+		     ieee80211_is_auth(hdr->frame_control) ||
+		     ieee80211_is_assoc_resp(hdr->frame_control) ||
+		     ieee80211_is_reassoc_resp(hdr->frame_control)))
+		return TX_CONTINUE;
+
+	if (unlikely((test_sta_flag(sta, WLAN_STA_PS_STA) ||
+		      test_sta_flag(sta, WLAN_STA_PS_DRIVER)) &&
+		     !(info->flags & IEEE80211_TX_CTL_POLL_RESPONSE))) {
+		int ac = skb_get_queue_mapping(tx->skb);
+
+#ifdef CONFIG_XRMAC_VERBOSE_PS_DEBUG
+		printk(KERN_DEBUG "STA %pM aid %d: PS buffer for AC %d\n",
+		       sta->sta.addr, sta->sta.aid, ac);
+#endif /* CONFIG_XRMAC_VERBOSE_PS_DEBUG */
+		if (tx->local->total_ps_buffered >= TOTAL_MAX_TX_BUFFER)
+			purge_old_ps_buffers(tx->local);
+
+		/* start --refer to backports-3.16.1 */
+		/* sync with mac80211_sta_ps_deliver_wakeup */
+		spin_lock(&sta->ps_lock);
+		/*
+		 * STA woke up the meantime and all the frames on ps_tx_buf have
+		 * been queued to pending queue. No reordering can happen, go
+		 * ahead and Tx the packet.
+		 */
+		if (!test_sta_flag(sta, WLAN_STA_PS_STA) &&
+		    !test_sta_flag(sta, WLAN_STA_PS_DRIVER)) {
+			spin_unlock(&sta->ps_lock);
+			return TX_CONTINUE;
+		}
+		/* end --refer to backports-3.16.1 */
+
+		if (skb_queue_len(&sta->ps_tx_buf[ac]) >= STA_MAX_TX_BUFFER) {
+			struct sk_buff *old = skb_dequeue(&sta->ps_tx_buf[ac]);
+#ifdef CONFIG_XRMAC_VERBOSE_PS_DEBUG
+			if (net_ratelimit())
+				printk(KERN_DEBUG "%s: STA %pM TX buffer for "
+				       "AC %d full - dropping oldest frame\n",
+				       tx->sdata->name, sta->sta.addr, ac);
+#endif
+			dev_kfree_skb(old);
+		} else
+			tx->local->total_ps_buffered++;
+
+		info->control.jiffies = jiffies;
+		info->control.vif = &tx->sdata->vif;
+		info->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING;
+		skb_queue_tail(&sta->ps_tx_buf[ac], tx->skb);
+		spin_unlock(&sta->ps_lock);  /* refer to backports-3.16.1 */
+
+		if (!timer_pending(&local->sta_cleanup))
+			mod_timer(&local->sta_cleanup,
+				  round_jiffies(jiffies +
+						STA_INFO_CLEANUP_INTERVAL));
+
+		/*
+		 * We queued up some frames, so the TIM bit might
+		 * need to be set, recalculate it.
+		 */
+		xrmac_sta_info_recalc_tim(sta);
+
+		return TX_QUEUED;
+	}
+#ifdef CONFIG_XRMAC_VERBOSE_PS_DEBUG
+	else if (unlikely(test_sta_flag(sta, WLAN_STA_PS_STA))) {
+		printk(KERN_DEBUG
+		       "%s: STA %pM in PS mode, but polling/in SP -> send frame\n",
+		       tx->sdata->name, sta->sta.addr);
+	}
+#endif /* CONFIG_XRMAC_VERBOSE_PS_DEBUG */
+
+	return TX_CONTINUE;
+}
+
+static ieee80211_tx_result debug_noinline
+ieee80211_tx_h_ps_buf(struct ieee80211_tx_data *tx)
+{
+	if (unlikely(tx->flags & IEEE80211_TX_PS_BUFFERED))
+		return TX_CONTINUE;
+
+	if (tx->flags & IEEE80211_TX_UNICAST)
+		return ieee80211_tx_h_unicast_ps_buf(tx);
+	else
+		return ieee80211_tx_h_multicast_ps_buf(tx);
+}
+
+static ieee80211_tx_result debug_noinline
+ieee80211_tx_h_check_control_port_protocol(struct ieee80211_tx_data *tx)
+{
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);
+
+	if (unlikely(tx->sdata->control_port_protocol == tx->skb->protocol &&
+		     tx->sdata->control_port_no_encrypt))
+		info->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
+
+	return TX_CONTINUE;
+}
+
+static ieee80211_tx_result debug_noinline
+ieee80211_tx_h_select_key(struct ieee80211_tx_data *tx)
+{
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;
+
+	if (unlikely(info->flags & IEEE80211_TX_INTFL_DONT_ENCRYPT))
+		tx->key = NULL;
+	else if (tx->sta && (rcu_dereference(tx->sta->ptk)))
+		tx->key = rcu_dereference(tx->sta->ptk);
+	else if (ieee80211_is_mgmt(hdr->frame_control) &&
+		 is_multicast_ether_addr(hdr->addr1) &&
+		 ieee80211_is_robust_mgmt_frame(tx->skb) &&
+		 (rcu_dereference(tx->sdata->default_mgmt_key)))
+		tx->key = rcu_dereference(tx->sdata->default_mgmt_key);
+	else if (is_multicast_ether_addr(hdr->addr1) &&
+		 (rcu_dereference(tx->sdata->default_multicast_key)))
+		tx->key = rcu_dereference(tx->sdata->default_multicast_key);
+	else if (!is_multicast_ether_addr(hdr->addr1) &&
+		 (rcu_dereference(tx->sdata->default_unicast_key)))
+		tx->key = rcu_dereference(tx->sdata->default_unicast_key);
+	else if (tx->sdata->drop_unencrypted &&
+		 (tx->skb->protocol != tx->sdata->control_port_protocol) &&
+		 !(info->flags & IEEE80211_TX_CTL_INJECTED) &&
+		 (!ieee80211_is_robust_mgmt_frame(tx->skb) ||
+		  (ieee80211_is_action(hdr->frame_control) &&
+		   tx->sta && test_sta_flag(tx->sta, WLAN_STA_MFP)))) {
+		I802_DEBUG_INC(tx->local->tx_handlers_drop_unencrypted);
+		return TX_DROP;
+	} else
+		tx->key = NULL;
+
+	if (tx->key) {
+		bool skip_hw = false;
+
+		tx->key->tx_rx_count++;
+		/* TODO: add threshold stuff again */
+
+		switch (tx->key->conf.cipher) {
+		case WLAN_CIPHER_SUITE_WEP40:
+		case WLAN_CIPHER_SUITE_WEP104:
+			if (ieee80211_is_auth(hdr->frame_control))
+				break;
+		case WLAN_CIPHER_SUITE_TKIP:
+			if (!ieee80211_is_data_present(hdr->frame_control))
+				tx->key = NULL;
+			break;
+		case WLAN_CIPHER_SUITE_CCMP:
+			if (!ieee80211_is_data_present(hdr->frame_control) &&
+			    !ieee80211_use_mfp(hdr->frame_control, tx->sta,
+					       tx->skb))
+				tx->key = NULL;
+			else
+				skip_hw = (tx->key->conf.flags &
+					   IEEE80211_KEY_FLAG_SW_MGMT) &&
+					ieee80211_is_mgmt(hdr->frame_control);
+			break;
+		case WLAN_CIPHER_SUITE_AES_CMAC:
+			if (!ieee80211_is_mgmt(hdr->frame_control))
+				tx->key = NULL;
+			break;
+
+		case WLAN_CIPHER_SUITE_SMS4:
+			if (tx->ethertype == ETH_P_WAPI)
+				tx->key = NULL;
+			break;
+		}
+
+		if (unlikely(tx->key && tx->key->flags & KEY_FLAG_TAINTED))
+			return TX_DROP;
+
+		if (!skip_hw && tx->key &&
+		    tx->key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE)
+			info->control.hw_key = &tx->key->conf;
+	}
+
+	return TX_CONTINUE;
+}
+
+static ieee80211_tx_result debug_noinline
+ieee80211_tx_h_rate_ctrl(struct ieee80211_tx_data *tx)
+{
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);
+	struct ieee80211_hdr *hdr = (void *)tx->skb->data;
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_rate *rate;
+	int i;
+	u32 len;
+	bool inval = false, rts = false, short_preamble = false;
+	struct ieee80211_tx_rate_control txrc;
+	bool assoc = false;
+
+	memset(&txrc, 0, sizeof(txrc));
+
+	sband = tx->local->hw.wiphy->bands[tx->channel->band];
+
+	len = min_t(u32, tx->skb->len + FCS_LEN,
+			 tx->local->hw.wiphy->frag_threshold);
+
+	/* set up the tx rate control struct we give the RC algo */
+	txrc.hw = local_to_hw(tx->local);
+	txrc.sband = sband;
+	txrc.bss_conf = &tx->sdata->vif.bss_conf;
+	txrc.skb = tx->skb;
+	txrc.reported_rate.idx = -1;
+	txrc.rate_idx_mask = tx->sdata->rc_rateidx_mask[tx->channel->band];
+	if (txrc.rate_idx_mask == (1 << sband->n_bitrates) - 1)
+		txrc.max_rate_idx = -1;
+	else
+		txrc.max_rate_idx = fls(txrc.rate_idx_mask) - 1;
+	txrc.bss = (tx->sdata->vif.type == NL80211_IFTYPE_AP ||
+		    tx->sdata->vif.type == NL80211_IFTYPE_ADHOC);
+
+	/* set up RTS protection if desired */
+	if (len > tx->sdata->wdev.wiphy->rts_threshold)
+		txrc.rts = rts = true;
+
+	/*
+	 * Use short preamble if the BSS can handle it, but not for
+	 * management frames unless we know the receiver can handle
+	 * that -- the management frame might be to a station that
+	 * just wants a probe response.
+	 */
+	if (tx->sdata->vif.bss_conf.use_short_preamble &&
+	    (ieee80211_is_data(hdr->frame_control) ||
+	     (tx->sta && test_sta_flag(tx->sta, WLAN_STA_SHORT_PREAMBLE))))
+		txrc.short_preamble = short_preamble = true;
+
+	if (tx->sta)
+		assoc = test_sta_flag(tx->sta, WLAN_STA_ASSOC);
+
+	/*
+	 * Lets not bother rate control if we're associated and cannot
+	 * talk to the sta. This should not happen.
+	 */
+	if (WARN(test_bit(SCAN_SW_SCANNING, &tx->local->scanning) && assoc &&
+		 !rate_usable_index_exists(sband, &tx->sta->sta),
+		 "%s: Dropped data frame as no usable bitrate found while "
+		 "scanning and associated. Target station: "
+		 "%pM on %d GHz band\n",
+		 tx->sdata->name, hdr->addr1,
+		 tx->channel->band ? 5 : 2))
+		return TX_DROP;
+
+	/*
+	 * If we're associated with the sta at this point we know we can at
+	 * least send the frame at the lowest bit rate.
+	 */
+	xrmac_rate_control_get_rate(tx->sdata, tx->sta, &txrc);
+
+	if (unlikely(info->control.rates[0].idx < 0))
+		return TX_DROP;
+
+	if (txrc.reported_rate.idx < 0) {
+		txrc.reported_rate = info->control.rates[0];
+		if (tx->sta && ieee80211_is_data(hdr->frame_control))
+			tx->sta->last_tx_rate = txrc.reported_rate;
+	} else if (tx->sta)
+		tx->sta->last_tx_rate = txrc.reported_rate;
+
+	if (unlikely(!info->control.rates[0].count))
+		info->control.rates[0].count = 1;
+
+	if (WARN_ON_ONCE((info->control.rates[0].count > 1) &&
+			 (info->flags & IEEE80211_TX_CTL_NO_ACK)))
+		info->control.rates[0].count = 1;
+
+	if (is_multicast_ether_addr(hdr->addr1)) {
+		/*
+		 * XXX: verify the rate is in the basic rateset
+		 */
+		return TX_CONTINUE;
+	}
+
+	/*
+	 * set up the RTS/CTS rate as the fastest basic rate
+	 * that is not faster than the data rate
+	 *
+	 * XXX: Should this check all retry rates?
+	 */
+	if (!(info->control.rates[0].flags & IEEE80211_TX_RC_MCS)) {
+		s8 baserate = 0;
+
+		rate = &sband->bitrates[info->control.rates[0].idx];
+
+		for (i = 0; i < sband->n_bitrates; i++) {
+			/* must be a basic rate */
+			if (!(tx->sdata->vif.bss_conf.basic_rates & BIT(i)))
+				continue;
+			/* must not be faster than the data rate */
+			if (sband->bitrates[i].bitrate > rate->bitrate)
+				continue;
+			/* maximum */
+			if (sband->bitrates[baserate].bitrate <
+			     sband->bitrates[i].bitrate)
+				baserate = i;
+		}
+
+		info->control.rts_cts_rate_idx = baserate;
+	}
+
+	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {
+		/*
+		 * make sure there's no valid rate following
+		 * an invalid one, just in case drivers don't
+		 * take the API seriously to stop at -1.
+		 */
+		if (inval) {
+			info->control.rates[i].idx = -1;
+			continue;
+		}
+		if (info->control.rates[i].idx < 0) {
+			inval = true;
+			continue;
+		}
+
+		/*
+		 * For now assume MCS is already set up correctly, this
+		 * needs to be fixed.
+		 */
+		if (info->control.rates[i].flags & IEEE80211_TX_RC_MCS) {
+			WARN_ON(info->control.rates[i].idx > 76);
+			continue;
+		}
+
+		/* set up RTS protection if desired */
+		if (rts)
+			info->control.rates[i].flags |=
+				IEEE80211_TX_RC_USE_RTS_CTS;
+
+		/* RC is busted */
+		if (WARN_ON_ONCE(info->control.rates[i].idx >=
+				 sband->n_bitrates)) {
+			info->control.rates[i].idx = -1;
+			continue;
+		}
+
+		rate = &sband->bitrates[info->control.rates[i].idx];
+
+		/* set up short preamble */
+		if (short_preamble &&
+		    rate->flags & IEEE80211_RATE_SHORT_PREAMBLE)
+			info->control.rates[i].flags |=
+				IEEE80211_TX_RC_USE_SHORT_PREAMBLE;
+
+		/* set up G protection */
+		if (!rts && tx->sdata->vif.bss_conf.use_cts_prot &&
+		    rate->flags & IEEE80211_RATE_ERP_G)
+			info->control.rates[i].flags |=
+				IEEE80211_TX_RC_USE_CTS_PROTECT;
+	}
+
+	return TX_CONTINUE;
+}
+
+static ieee80211_tx_result debug_noinline
+ieee80211_tx_h_sequence(struct ieee80211_tx_data *tx)
+{
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;
+	u16 *seq;
+	u8 *qc;
+	int tid;
+
+	/*
+	 * Packet injection may want to control the sequence
+	 * number, if we have no matching interface then we
+	 * neither assign one ourselves nor ask the driver to.
+	 */
+	if (unlikely(info->control.vif->type == NL80211_IFTYPE_MONITOR))
+		return TX_CONTINUE;
+
+	if (unlikely(ieee80211_is_ctl(hdr->frame_control)))
+		return TX_CONTINUE;
+
+	if (ieee80211_hdrlen(hdr->frame_control) < 24)
+		return TX_CONTINUE;
+
+	if (ieee80211_is_qos_nullfunc(hdr->frame_control))
+		return TX_CONTINUE;
+
+	/*
+	 * Anything but QoS data that has a sequence number field
+	 * (is long enough) gets a sequence number from the global
+	 * counter.
+	 */
+	if (!ieee80211_is_data_qos(hdr->frame_control)) {
+		/* driver should assign sequence number */
+		info->flags |= IEEE80211_TX_CTL_ASSIGN_SEQ;
+		/* for pure STA mode without beacons, we can do it */
+		hdr->seq_ctrl = cpu_to_le16(tx->sdata->sequence_number);
+		tx->sdata->sequence_number += 0x10;
+		return TX_CONTINUE;
+	}
+
+	/*
+	 * This should be true for injected/management frames only, for
+	 * management frames we have set the IEEE80211_TX_CTL_ASSIGN_SEQ
+	 * above since they are not QoS-data frames.
+	 */
+	if (!tx->sta)
+		return TX_CONTINUE;
+
+	/* include per-STA, per-TID sequence counter */
+
+	qc = ieee80211_get_qos_ctl(hdr);
+	tid = *qc & IEEE80211_QOS_CTL_TID_MASK;
+	seq = &tx->sta->tid_seq[tid];
+
+	hdr->seq_ctrl = cpu_to_le16(*seq);
+
+	/* Increase the sequence number. */
+	*seq = (*seq + 0x10) & IEEE80211_SCTL_SEQ;
+
+	return TX_CONTINUE;
+}
+
+static int ieee80211_fragment(struct ieee80211_local *local,
+			      struct sk_buff *skb, int hdrlen,
+			      int frag_threshold)
+{
+	struct sk_buff *tail = skb, *tmp;
+	int per_fragm = frag_threshold - hdrlen - FCS_LEN;
+	int pos = hdrlen + per_fragm;
+	int rem = skb->len - hdrlen - per_fragm;
+
+	if (WARN_ON(rem < 0))
+		return -EINVAL;
+
+	while (rem) {
+		int fraglen = per_fragm;
+
+		if (fraglen > rem)
+			fraglen = rem;
+		rem -= fraglen;
+		tmp = dev_alloc_skb(local->tx_headroom +
+				    frag_threshold +
+				    IEEE80211_ENCRYPT_HEADROOM +
+				    IEEE80211_ENCRYPT_TAILROOM);
+		if (!tmp)
+			return -ENOMEM;
+		tail->next = tmp;
+		tail = tmp;
+		skb_reserve(tmp, local->tx_headroom +
+				 IEEE80211_ENCRYPT_HEADROOM);
+		/* copy control information */
+		memcpy(tmp->cb, skb->cb, sizeof(tmp->cb));
+		skb_copy_queue_mapping(tmp, skb);
+		tmp->priority = skb->priority;
+		tmp->dev = skb->dev;
+
+		/* copy header and data */
+		memcpy(skb_put(tmp, hdrlen), skb->data, hdrlen);
+		memcpy(skb_put(tmp, fraglen), skb->data + pos, fraglen);
+
+		pos += fraglen;
+	}
+
+	skb->len = hdrlen + per_fragm;
+	return 0;
+}
+
+static ieee80211_tx_result debug_noinline
+ieee80211_tx_h_fragment(struct ieee80211_tx_data *tx)
+{
+	struct sk_buff *skb = tx->skb;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	struct ieee80211_hdr *hdr = (void *)skb->data;
+	int frag_threshold = tx->local->hw.wiphy->frag_threshold;
+	int hdrlen;
+	int fragnum;
+
+	if (info->flags & IEEE80211_TX_CTL_DONTFRAG)
+		return TX_CONTINUE;
+
+	if (tx->local->ops->set_frag_threshold)
+		return TX_CONTINUE;
+
+	/*
+	 * Warn when submitting a fragmented A-MPDU frame and drop it.
+	 * This scenario is handled in ieee80211_tx_prepare but extra
+	 * caution taken here as fragmented ampdu may cause Tx stop.
+	 */
+	if (WARN_ON(info->flags & IEEE80211_TX_CTL_AMPDU))
+		return TX_DROP;
+
+	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+
+	/* internal error, why isn't DONTFRAG set? */
+	if (WARN_ON(skb->len + FCS_LEN <= frag_threshold))
+		return TX_DROP;
+
+	/*
+	 * Now fragment the frame. This will allocate all the fragments and
+	 * chain them (using skb as the first fragment) to skb->next.
+	 * During transmission, we will remove the successfully transmitted
+	 * fragments from this list. When the low-level driver rejects one
+	 * of the fragments then we will simply pretend to accept the skb
+	 * but store it away as pending.
+	 */
+	if (ieee80211_fragment(tx->local, skb, hdrlen, frag_threshold))
+		return TX_DROP;
+
+	/* update duration/seq/flags of fragments */
+	fragnum = 0;
+	do {
+		int next_len;
+		const __le16 morefrags = cpu_to_le16(IEEE80211_FCTL_MOREFRAGS);
+
+		hdr = (void *)skb->data;
+		info = IEEE80211_SKB_CB(skb);
+
+		if (skb->next) {
+			hdr->frame_control |= morefrags;
+			next_len = skb->next->len;
+			/*
+			 * No multi-rate retries for fragmented frames, that
+			 * would completely throw off the NAV at other STAs.
+			 */
+			info->control.rates[1].idx = -1;
+			info->control.rates[2].idx = -1;
+			info->control.rates[3].idx = -1;
+			info->control.rates[4].idx = -1;
+			BUILD_BUG_ON(IEEE80211_TX_MAX_RATES != 5);
+			info->flags &= ~IEEE80211_TX_CTL_RATE_CTRL_PROBE;
+		} else {
+			hdr->frame_control &= ~morefrags;
+			next_len = 0;
+		}
+		hdr->duration_id = ieee80211_duration(tx, 0, next_len);
+		hdr->seq_ctrl |= cpu_to_le16(fragnum & IEEE80211_SCTL_FRAG);
+		fragnum++;
+	} while ((skb = skb->next));
+
+	return TX_CONTINUE;
+}
+
+static ieee80211_tx_result debug_noinline
+ieee80211_tx_h_stats(struct ieee80211_tx_data *tx)
+{
+	struct sk_buff *skb = tx->skb;
+
+	if (!tx->sta)
+		return TX_CONTINUE;
+
+	tx->sta->tx_packets++;
+	do {
+		tx->sta->tx_fragments++;
+		tx->sta->tx_bytes += skb->len;
+	} while ((skb = skb->next));
+
+	return TX_CONTINUE;
+}
+
+static ieee80211_tx_result debug_noinline
+ieee80211_tx_h_encrypt(struct ieee80211_tx_data *tx)
+{
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);
+
+	if (!tx->key)
+		return TX_CONTINUE;
+
+	switch (tx->key->conf.cipher) {
+	case WLAN_CIPHER_SUITE_WEP40:
+	case WLAN_CIPHER_SUITE_WEP104:
+		return mac80211_crypto_wep_encrypt(tx);
+	case WLAN_CIPHER_SUITE_TKIP:
+		return mac80211_crypto_tkip_encrypt(tx);
+	case WLAN_CIPHER_SUITE_CCMP:
+		return mac80211_crypto_ccmp_encrypt(tx);
+	case WLAN_CIPHER_SUITE_AES_CMAC:
+		return mac80211_crypto_aes_cmac_encrypt(tx);
+	default:
+		/* handle hw-only algorithm */
+		if (info->control.hw_key) {
+			mac80211_tx_set_protected(tx);
+			return TX_CONTINUE;
+		}
+		break;
+
+	}
+
+	return TX_DROP;
+}
+
+static ieee80211_tx_result debug_noinline
+ieee80211_tx_h_calculate_duration(struct ieee80211_tx_data *tx)
+{
+	struct sk_buff *skb = tx->skb;
+	struct ieee80211_hdr *hdr;
+	int next_len;
+	bool group_addr;
+
+	do {
+		hdr = (void *) skb->data;
+		if (unlikely(ieee80211_is_pspoll(hdr->frame_control)))
+			break; /* must not overwrite AID */
+		next_len = skb->next ? skb->next->len : 0;
+		group_addr = is_multicast_ether_addr(hdr->addr1);
+
+		hdr->duration_id =
+			ieee80211_duration(tx, group_addr, next_len);
+	} while ((skb = skb->next));
+
+	return TX_CONTINUE;
+}
+
+/* actual transmit path */
+
+static bool ieee80211_tx_prep_agg(struct ieee80211_tx_data *tx,
+				  struct sk_buff *skb,
+				  struct ieee80211_tx_info *info,
+				  struct tid_ampdu_tx *tid_tx,
+				  int tid)
+{
+	bool queued = false;
+
+	if (test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state)) {
+		info->flags |= IEEE80211_TX_CTL_AMPDU;
+	} else if (test_bit(HT_AGG_STATE_WANT_START, &tid_tx->state)) {
+		/*
+		 * nothing -- this aggregation session is being started
+		 * but that might still fail with the driver
+		 */
+	} else {
+		spin_lock(&tx->sta->lock);
+		/*
+		 * Need to re-check now, because we may get here
+		 *
+		 *  1) in the window during which the setup is actually
+		 *     already done, but not marked yet because not all
+		 *     packets are spliced over to the driver pending
+		 *     queue yet -- if this happened we acquire the lock
+		 *     either before or after the splice happens, but
+		 *     need to recheck which of these cases happened.
+		 *
+		 *  2) during session teardown, if the OPERATIONAL bit
+		 *     was cleared due to the teardown but the pointer
+		 *     hasn't been assigned NULL yet (or we loaded it
+		 *     before it was assigned) -- in this case it may
+		 *     now be NULL which means we should just let the
+		 *     packet pass through because splicing the frames
+		 *     back is already done.
+		 */
+		tid_tx = rcu_dereference_protected_tid_tx(tx->sta, tid);
+
+		if (!tid_tx) {
+			/* do nothing, let packet pass through */
+		} else if (test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state)) {
+			info->flags |= IEEE80211_TX_CTL_AMPDU;
+		} else {
+			queued = true;
+			info->control.vif = &tx->sdata->vif;
+			info->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING;
+			__skb_queue_tail(&tid_tx->pending, skb);
+		}
+		spin_unlock(&tx->sta->lock);
+	}
+
+	return queued;
+}
+
+/*
+ * initialises @tx
+ */
+static ieee80211_tx_result
+ieee80211_tx_prepare(struct ieee80211_sub_if_data *sdata,
+		     struct ieee80211_tx_data *tx,
+		     struct sk_buff *skb)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sdata);
+	struct ieee80211_hdr *hdr;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	int hdrlen, tid;
+	u8 *qc;
+
+	memset(tx, 0, sizeof(*tx));
+	tx->skb = skb;
+	tx->local = local;
+	tx->sdata = sdata;
+	tx->channel = chan_state->conf.channel;
+
+	/*
+	 * If this flag is set to true anywhere, and we get here,
+	 * we are doing the needed processing, so remove the flag
+	 * now.
+	 */
+	info->flags &= ~IEEE80211_TX_INTFL_NEED_TXPROCESSING;
+
+	hdr = (struct ieee80211_hdr *) skb->data;
+
+	if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {
+		tx->sta = rcu_dereference(sdata->u.vlan.sta);
+		if (!tx->sta && sdata->dev->ieee80211_ptr->use_4addr)
+			return TX_DROP;
+	} else if (info->flags & IEEE80211_TX_CTL_INJECTED) {
+		tx->sta = xrmac_sta_info_get_bss(sdata, hdr->addr1);
+	}
+	if (!tx->sta)
+		tx->sta = xrmac_sta_info_get(sdata, hdr->addr1);
+
+	if (tx->sta && ieee80211_is_data_qos(hdr->frame_control) &&
+	    !ieee80211_is_qos_nullfunc(hdr->frame_control) &&
+	    (local->hw.flags & IEEE80211_HW_AMPDU_AGGREGATION) &&
+	    !(local->hw.flags & IEEE80211_HW_TX_AMPDU_SETUP_IN_HW)) {
+		struct tid_ampdu_tx *tid_tx;
+
+		qc = ieee80211_get_qos_ctl(hdr);
+		tid = *qc & IEEE80211_QOS_CTL_TID_MASK;
+
+		tid_tx = rcu_dereference(tx->sta->ampdu_mlme.tid_tx[tid]);
+		if (tid_tx) {
+			bool queued;
+
+			queued = ieee80211_tx_prep_agg(tx, skb, info,
+						       tid_tx, tid);
+
+			if (unlikely(queued))
+				return TX_QUEUED;
+		}
+	}
+
+	if (is_multicast_ether_addr(hdr->addr1)) {
+		tx->flags &= ~IEEE80211_TX_UNICAST;
+		info->flags |= IEEE80211_TX_CTL_NO_ACK;
+	} else {
+		tx->flags |= IEEE80211_TX_UNICAST;
+		if (unlikely(local->wifi_wme_noack_test))
+			info->flags |= IEEE80211_TX_CTL_NO_ACK;
+		/*
+		 * Flags are initialized to 0. Hence, no need to
+		 * explicitly unset IEEE80211_TX_CTL_NO_ACK since
+		 * it might already be set for injected frames.
+		 */
+	}
+
+	if (!(info->flags & IEEE80211_TX_CTL_DONTFRAG)) {
+		if (!(tx->flags & IEEE80211_TX_UNICAST) ||
+		    skb->len + FCS_LEN <= local->hw.wiphy->frag_threshold ||
+		    info->flags & IEEE80211_TX_CTL_AMPDU)
+			info->flags |= IEEE80211_TX_CTL_DONTFRAG;
+	}
+
+	if (!tx->sta)
+		info->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT;
+	else if (test_and_clear_sta_flag(tx->sta, WLAN_STA_CLEAR_PS_FILT))
+		info->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT;
+
+	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	if (skb->len > hdrlen + sizeof(rfc1042_header) + 2) {
+		u8 *pos = &skb->data[hdrlen + sizeof(rfc1042_header)];
+		tx->ethertype = (pos[0] << 8) | pos[1];
+	}
+
+	info->flags |= IEEE80211_TX_CTL_FIRST_FRAGMENT;
+
+	return TX_CONTINUE;
+}
+
+/*
+ * Returns false if the frame couldn't be transmitted but was queued instead.
+ */
+static bool __ieee80211_tx(struct ieee80211_local *local, struct sk_buff **skbp,
+			   struct sta_info *sta, bool txpending)
+{
+	struct sk_buff *skb = *skbp, *next;
+	struct ieee80211_tx_info *info;
+	struct ieee80211_sub_if_data *sdata;
+	unsigned long flags;
+	int len;
+	bool fragm = false;
+
+	while (skb) {
+		int q = skb_get_queue_mapping(skb);
+		__le16 fc;
+
+		spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
+		if (local->queue_stop_reasons[q] ||
+		    (!txpending && !skb_queue_empty(&local->pending[q]))) {
+			/*
+			 * Since queue is stopped, queue up frames for later
+			 * transmission from the tx-pending tasklet when the
+			 * queue is woken again.
+			 */
+
+			do {
+				next = skb->next;
+				skb->next = NULL;
+				/*
+				 * NB: If txpending is true, next must already
+				 * be NULL since we must've gone through this
+				 * loop before already; therefore we can just
+				 * queue the frame to the head without worrying
+				 * about reordering of fragments.
+				 */
+				if (unlikely(txpending))
+					__skb_queue_head(&local->pending[q],
+							 skb);
+				else
+					__skb_queue_tail(&local->pending[q],
+							 skb);
+			} while ((skb = next));
+
+			spin_unlock_irqrestore(&local->queue_stop_reason_lock,
+					       flags);
+			return false;
+		}
+		spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
+
+		info = IEEE80211_SKB_CB(skb);
+
+		if (fragm)
+			info->flags &= ~(IEEE80211_TX_CTL_CLEAR_PS_FILT |
+					 IEEE80211_TX_CTL_FIRST_FRAGMENT);
+
+		next = skb->next;
+		len = skb->len;
+
+		if (next)
+			info->flags |= IEEE80211_TX_CTL_MORE_FRAMES;
+
+		sdata = vif_to_sdata(info->control.vif);
+
+		switch (sdata->vif.type) {
+		case NL80211_IFTYPE_MONITOR:
+			info->control.vif = NULL;
+			break;
+		case NL80211_IFTYPE_AP_VLAN:
+			info->control.vif = &container_of(sdata->bss,
+				struct ieee80211_sub_if_data, u.ap)->vif;
+			break;
+		default:
+			/* keep */
+			break;
+		}
+
+		if (sta && sta->uploaded)
+			info->control.sta = &sta->sta;
+		else
+			info->control.sta = NULL;
+
+		fc = ((struct ieee80211_hdr *)skb->data)->frame_control;
+		drv_tx(local, skb);
+
+		ieee80211_tpt_led_trig_tx(local, fc, len);
+		*skbp = skb = next;
+		ieee80211_led_tx(local, 1);
+		fragm = true;
+	}
+
+	return true;
+}
+
+/*
+ * Invoke TX handlers, return 0 on success and non-zero if the
+ * frame was dropped or queued.
+ */
+static int invoke_tx_handlers(struct ieee80211_tx_data *tx)
+{
+	struct sk_buff *skb = tx->skb;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	ieee80211_tx_result res = TX_DROP;
+
+#define CALL_TXH(txh) \
+	do {				\
+		res = txh(tx);		\
+		if (res != TX_CONTINUE)	\
+			goto txh_done;	\
+	} while (0)
+
+	CALL_TXH(ieee80211_tx_h_dynamic_ps);
+	CALL_TXH(ieee80211_tx_h_check_assoc);
+	CALL_TXH(ieee80211_tx_h_ps_buf);
+	CALL_TXH(ieee80211_tx_h_check_control_port_protocol);
+	CALL_TXH(ieee80211_tx_h_select_key);
+	if (!(tx->local->hw.flags & IEEE80211_HW_HAS_RATE_CONTROL))
+		CALL_TXH(ieee80211_tx_h_rate_ctrl);
+
+	if (unlikely(info->flags & IEEE80211_TX_INTFL_RETRANSMISSION))
+		goto txh_done;
+
+	CALL_TXH(mac80211_tx_h_xrmac_michael_mic_add);
+	CALL_TXH(ieee80211_tx_h_sequence);
+	CALL_TXH(ieee80211_tx_h_fragment);
+	/* handlers after fragment must be aware of tx info fragmentation! */
+	CALL_TXH(ieee80211_tx_h_stats);
+	CALL_TXH(ieee80211_tx_h_encrypt);
+	if (!(tx->local->hw.flags & IEEE80211_HW_HAS_RATE_CONTROL))
+		CALL_TXH(ieee80211_tx_h_calculate_duration);
+#undef CALL_TXH
+
+ txh_done:
+	if (unlikely(res == TX_DROP)) {
+		I802_DEBUG_INC(tx->local->tx_handlers_drop);
+		while (skb) {
+			struct sk_buff *next;
+
+			next = skb->next;
+			dev_kfree_skb(skb);
+			skb = next;
+		}
+		return -1;
+	} else if (unlikely(res == TX_QUEUED)) {
+		I802_DEBUG_INC(tx->local->tx_handlers_queued);
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+ * Returns false if the frame couldn't be transmitted but was queued instead.
+ */
+static bool ieee80211_tx(struct ieee80211_sub_if_data *sdata,
+			 struct sk_buff *skb, bool txpending)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sdata);
+	struct ieee80211_tx_data tx;
+	ieee80211_tx_result res_prepare;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	bool result = true;
+
+	if (unlikely(skb->len < 10)) {
+		dev_kfree_skb(skb);
+		return true;
+	}
+
+	rcu_read_lock();
+
+	/* initialises tx */
+	res_prepare = ieee80211_tx_prepare(sdata, &tx, skb);
+
+	if (unlikely(res_prepare == TX_DROP)) {
+		dev_kfree_skb(skb);
+		goto out;
+	} else if (unlikely(res_prepare == TX_QUEUED)) {
+		goto out;
+	}
+
+	tx.channel = chan_state->conf.channel;
+	info->band = tx.channel->band;
+
+	/* set up hw_queue value early */
+	if (!(info->flags & IEEE80211_TX_CTL_TX_OFFCHAN) ||
+	    !(local->hw.flags & IEEE80211_HW_QUEUE_CONTROL))
+		info->hw_queue =
+			sdata->vif.hw_queue[skb_get_queue_mapping(skb)];
+
+	if (!invoke_tx_handlers(&tx))
+		result = __ieee80211_tx(local, &tx.skb, tx.sta, txpending);
+ out:
+	rcu_read_unlock();
+	return result;
+}
+
+/* device xmit handlers */
+
+static int ieee80211_skb_resize(struct ieee80211_sub_if_data *sdata,
+				struct sk_buff *skb,
+				int head_need, bool may_encrypt)
+{
+	struct ieee80211_local *local = sdata->local;
+	int tail_need = 0;
+
+	if (may_encrypt && sdata->crypto_tx_tailroom_needed_cnt) {
+		tail_need = IEEE80211_ENCRYPT_TAILROOM;
+		tail_need -= skb_tailroom(skb);
+		tail_need = max_t(int, tail_need, 0);
+	}
+
+	if (skb_cloned(skb))
+		I802_DEBUG_INC(local->tx_expand_skb_head_cloned);
+	else if (head_need || tail_need)
+		I802_DEBUG_INC(local->tx_expand_skb_head);
+	else
+		return 0;
+
+	if (pskb_expand_head(skb, head_need, tail_need, GFP_ATOMIC)) {
+		wiphy_debug(local->hw.wiphy,
+			    "failed to reallocate TX buffer\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+void mac80211_xmit(struct ieee80211_sub_if_data *sdata, struct sk_buff *skb)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	int headroom;
+	bool may_encrypt;
+
+	rcu_read_lock();
+
+	may_encrypt = !(info->flags & IEEE80211_TX_INTFL_DONT_ENCRYPT);
+
+	headroom = local->tx_headroom;
+	if (may_encrypt)
+		headroom += IEEE80211_ENCRYPT_HEADROOM;
+	headroom -= skb_headroom(skb);
+	headroom = max_t(int, 0, headroom);
+
+	if (ieee80211_skb_resize(sdata, skb, headroom, may_encrypt)) {
+		dev_kfree_skb(skb);
+		rcu_read_unlock();
+		return;
+	}
+
+	hdr = (struct ieee80211_hdr *) skb->data;
+	info->control.vif = &sdata->vif;
+
+	if (ieee80211_vif_is_mesh(&sdata->vif) &&
+	    ieee80211_is_data(hdr->frame_control) &&
+		!is_multicast_ether_addr(hdr->addr1))
+			if (xrmac_mesh_nexthop_lookup(skb, sdata)) {
+				/* skb queued: don't free */
+				rcu_read_unlock();
+				return;
+			}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 27))
+	/* Older kernels do not have the select_queue callback */
+	skb_set_queue_mapping(skb, mac80211_select_queue(sdata, skb));
+#endif
+	mac80211_set_qos_hdr(sdata, skb);
+	ieee80211_tx(sdata, skb, false);
+	rcu_read_unlock();
+}
+
+static bool ieee80211_parse_tx_radiotap(struct sk_buff *skb)
+{
+	struct ieee80211_radiotap_iterator iterator;
+	struct ieee80211_radiotap_header *rthdr =
+		(struct ieee80211_radiotap_header *) skb->data;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	int ret = ieee80211_radiotap_iterator_init(&iterator, rthdr, skb->len,
+						   NULL);
+	u16 txflags;
+
+	info->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |
+		       IEEE80211_TX_CTL_DONTFRAG;
+
+	/*
+	 * for every radiotap entry that is present
+	 * (ieee80211_radiotap_iterator_next returns -ENOENT when no more
+	 * entries present, or -EINVAL on error)
+	 */
+
+	while (!ret) {
+		ret = ieee80211_radiotap_iterator_next(&iterator);
+
+		if (ret)
+			continue;
+
+		/* see if this argument is something we can use */
+		switch (iterator.this_arg_index) {
+		/*
+		 * You must take care when dereferencing iterator.this_arg
+		 * for multibyte types... the pointer is not aligned.  Use
+		 * get_unaligned((type *)iterator.this_arg) to dereference
+		 * iterator.this_arg for type "type" safely on all arches.
+		*/
+		case IEEE80211_RADIOTAP_FLAGS:
+			if (*iterator.this_arg & IEEE80211_RADIOTAP_F_FCS) {
+				/*
+				 * this indicates that the skb we have been
+				 * handed has the 32-bit FCS CRC at the end...
+				 * we should react to that by snipping it off
+				 * because it will be recomputed and added
+				 * on transmission
+				 */
+				if (skb->len < (iterator._max_length + FCS_LEN))
+					return false;
+
+				skb_trim(skb, skb->len - FCS_LEN);
+			}
+			if (*iterator.this_arg & IEEE80211_RADIOTAP_F_WEP)
+				info->flags &= ~IEEE80211_TX_INTFL_DONT_ENCRYPT;
+			if (*iterator.this_arg & IEEE80211_RADIOTAP_F_FRAG)
+				info->flags &= ~IEEE80211_TX_CTL_DONTFRAG;
+			break;
+
+		case IEEE80211_RADIOTAP_TX_FLAGS:
+			txflags = get_unaligned_le16(iterator.this_arg);
+			if (txflags & IEEE80211_RADIOTAP_F_TX_NOACK)
+				info->flags |= IEEE80211_TX_CTL_NO_ACK;
+			break;
+
+		/*
+		 * Please update the file
+		 * Documentation/networking/mac80211-injection.txt
+		 * when parsing new fields here.
+		 */
+
+		default:
+			break;
+		}
+	}
+
+	if (ret != -ENOENT) /* ie, if we didn't simply run out of fields */
+		return false;
+
+	/*
+	 * remove the radiotap header
+	 * iterator->_max_length was sanity-checked against
+	 * skb->len by iterator init
+	 */
+	skb_pull(skb, iterator._max_length);
+
+	return true;
+}
+
+netdev_tx_t mac80211_monitor_start_xmit(struct sk_buff *skb,
+					 struct net_device *dev)
+{
+	struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);
+	struct ieee80211_sub_if_data *tmp_sdata, *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_radiotap_header *prthdr =
+		(struct ieee80211_radiotap_header *)skb->data;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	struct ieee80211_hdr *hdr;
+	u16 len_rthdr;
+	int hdrlen;
+
+	/*
+	 * Frame injection is not allowed if beaconing is not allowed
+	 * or if we need radar detection. Beaconing is usually not allowed when
+	 * the mode or operation (Adhoc, AP, Mesh) does not support DFS.
+	 * Passive scan is also used in world regulatory domains where
+	 * your country is not known and as such it should be treated as
+	 * NO TX unless the channel is explicitly allowed in which case
+	 * your current regulatory domain would not have the passive scan
+	 * flag.
+	 *
+	 * Since AP mode uses monitor interfaces to inject/TX management
+	 * frames we can make AP mode the exception to this rule once it
+	 * supports radar detection as its implementation can deal with
+	 * radar detection by itself. We can do that later by adding a
+	 * monitor flag interfaces used for AP support.
+	 */
+
+	/* check for not even having the fixed radiotap header part */
+	if (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))
+		goto fail; /* too short to be possibly valid */
+
+	/* is it a header version we can trust to find length from? */
+	if (unlikely(prthdr->it_version))
+		goto fail; /* only version 0 is supported */
+
+	/* then there must be a radiotap header with a length we can use */
+	len_rthdr = ieee80211_get_radiotap_len(skb->data);
+
+	/* does the skb contain enough to deliver on the alleged length? */
+	if (unlikely(skb->len < len_rthdr))
+		goto fail; /* skb too short for claimed rt header extent */
+
+	/*
+	 * fix up the pointers accounting for the radiotap
+	 * header still being in there.  We are being given
+	 * a precooked IEEE80211 header so no need for
+	 * normal processing
+	 */
+	skb_set_mac_header(skb, len_rthdr);
+	/*
+	 * these are just fixed to the end of the rt area since we
+	 * don't have any better information and at this point, nobody cares
+	 */
+	skb_set_network_header(skb, len_rthdr);
+	skb_set_transport_header(skb, len_rthdr);
+
+	if (skb->len < len_rthdr + 2)
+		goto fail;
+
+	hdr = (struct ieee80211_hdr *)(skb->data + len_rthdr);
+	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+
+	if (skb->len < len_rthdr + hdrlen)
+		goto fail;
+
+	/*
+	 * Initialize skb->protocol if the injected frame is a data frame
+	 * carrying a rfc1042 header
+	 */
+	if (ieee80211_is_data(hdr->frame_control) &&
+	    skb->len >= len_rthdr + hdrlen + sizeof(rfc1042_header) + 2) {
+		u8 *payload = (u8 *)hdr + hdrlen;
+
+		if (compare_ether_addr(payload, rfc1042_header) == 0)
+			skb->protocol = cpu_to_be16((payload[6] << 8) |
+						    payload[7]);
+	}
+
+	memset(info, 0, sizeof(*info));
+
+	info->flags = IEEE80211_TX_CTL_REQ_TX_STATUS |
+		      IEEE80211_TX_CTL_INJECTED;
+
+	/* process and remove the injection radiotap header */
+	if (!ieee80211_parse_tx_radiotap(skb))
+		goto fail;
+
+	rcu_read_lock();
+
+	/*
+	 * We process outgoing injected frames that have a local address
+	 * we handle as though they are non-injected frames.
+	 * This code here isn't entirely correct, the local MAC address
+	 * isn't always enough to find the interface to use; for proper
+	 * VLAN/WDS support we will need a different mechanism (which
+	 * likely isn't going to be monitor interfaces).
+	 */
+	list_for_each_entry_rcu(tmp_sdata, &local->interfaces, list) {
+		if (!ieee80211_sdata_running(tmp_sdata))
+			continue;
+		if (tmp_sdata->vif.type == NL80211_IFTYPE_MONITOR ||
+		    tmp_sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||
+		    tmp_sdata->vif.type == NL80211_IFTYPE_WDS)
+			continue;
+		if (compare_ether_addr(tmp_sdata->vif.addr, hdr->addr2) == 0) {
+			sdata = tmp_sdata;
+			break;
+		}
+	}
+
+	mac80211_xmit(sdata, skb);
+	rcu_read_unlock();
+
+	return NETDEV_TX_OK;
+
+fail:
+	dev_kfree_skb(skb);
+	return NETDEV_TX_OK; /* meaning, we dealt with the skb */
+}
+
+/**
+ * mac80211_subif_start_xmit - netif start_xmit function for Ethernet-type
+ * subinterfaces (wlan#, WDS, and VLAN interfaces)
+ * @skb: packet to be sent
+ * @dev: incoming interface
+ *
+ * Returns: 0 on success (and frees skb in this case) or 1 on failure (skb will
+ * not be freed, and caller is responsible for either retrying later or freeing
+ * skb).
+ *
+ * This function takes in an Ethernet header and encapsulates it with suitable
+ * IEEE 802.11 header based on which interface the packet is coming in. The
+ * encapsulated packet will then be passed to master interface, wlan#.11, for
+ * transmission (through low-level driver).
+ */
+netdev_tx_t mac80211_subif_start_xmit(struct sk_buff *skb,
+				    struct net_device *dev)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_tx_info *info;
+	int ret = NETDEV_TX_BUSY, head_need;
+	u16 ethertype, hdrlen,  meshhdrlen = 0;
+	__le16 fc;
+	struct ieee80211_hdr hdr;
+	struct ieee80211s_hdr mesh_hdr __maybe_unused;
+	struct mesh_path __maybe_unused *mppath = NULL;
+	const u8 *encaps_data;
+	int encaps_len, skip_header_bytes;
+	int nh_pos, h_pos;
+	struct sta_info *sta = NULL;
+	bool wme_sta = false, authorized = false, tdls_auth = false;
+	struct sk_buff *tmp_skb;
+	bool tdls_direct = false;
+
+	if (unlikely(skb->len < ETH_HLEN)) {
+		ret = NETDEV_TX_OK;
+		goto fail;
+	}
+
+	/* convert Ethernet header to proper 802.11 header (based on
+	 * operation mode) */
+	ethertype = (skb->data[12] << 8) | skb->data[13];
+	fc = cpu_to_le16(IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA);
+
+	switch (sdata->vif.type) {
+	case NL80211_IFTYPE_AP_VLAN:
+		rcu_read_lock();
+		sta = rcu_dereference(sdata->u.vlan.sta);
+		if (sta) {
+			fc |= cpu_to_le16(IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS);
+			/* RA TA DA SA */
+			memcpy(hdr.addr1, sta->sta.addr, ETH_ALEN);
+			memcpy(hdr.addr2, sdata->vif.addr, ETH_ALEN);
+			memcpy(hdr.addr3, skb->data, ETH_ALEN);
+			memcpy(hdr.addr4, skb->data + ETH_ALEN, ETH_ALEN);
+			hdrlen = 30;
+			authorized = test_sta_flag(sta, WLAN_STA_AUTHORIZED);
+			wme_sta = test_sta_flag(sta, WLAN_STA_WME);
+		}
+		rcu_read_unlock();
+		if (sta)
+			break;
+		/* fall through */
+	case NL80211_IFTYPE_AP:
+		fc |= cpu_to_le16(IEEE80211_FCTL_FROMDS);
+		/* DA BSSID SA */
+		memcpy(hdr.addr1, skb->data, ETH_ALEN);
+		memcpy(hdr.addr2, sdata->vif.addr, ETH_ALEN);
+		memcpy(hdr.addr3, skb->data + ETH_ALEN, ETH_ALEN);
+		hdrlen = 24;
+		break;
+	case NL80211_IFTYPE_WDS:
+		fc |= cpu_to_le16(IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS);
+		/* RA TA DA SA */
+		memcpy(hdr.addr1, sdata->u.wds.remote_addr, ETH_ALEN);
+		memcpy(hdr.addr2, sdata->vif.addr, ETH_ALEN);
+		memcpy(hdr.addr3, skb->data, ETH_ALEN);
+		memcpy(hdr.addr4, skb->data + ETH_ALEN, ETH_ALEN);
+		hdrlen = 30;
+		break;
+#ifdef CONFIG_XRMAC_MESH
+	case NL80211_IFTYPE_MESH_POINT:
+		if (!sdata->u.mesh.mshcfg.dot11MeshTTL) {
+			/* Do not send frames with mesh_ttl == 0 */
+			sdata->u.mesh.mshstats.dropped_frames_ttl++;
+			ret = NETDEV_TX_OK;
+			goto fail;
+		}
+		rcu_read_lock();
+		if (!is_multicast_ether_addr(skb->data))
+			mppath = xrmac_mpp_path_lookup(skb->data, sdata);
+
+		/*
+		 * Use address extension if it is a packet from
+		 * another interface or if we know the destination
+		 * is being proxied by a portal (i.e. portal address
+		 * differs from proxied address)
+		 */
+		if (compare_ether_addr(sdata->vif.addr,
+				       skb->data + ETH_ALEN) == 0 &&
+		    !(mppath && compare_ether_addr(mppath->mpp, skb->data))) {
+			hdrlen = mac80211_fill_mesh_addresses(&hdr, &fc,
+					skb->data, skb->data + ETH_ALEN);
+			rcu_read_unlock();
+			meshhdrlen = mac80211_new_mesh_header(&mesh_hdr,
+					sdata, NULL, NULL);
+		} else {
+			int is_mesh_mcast = 1;
+			const u8 *mesh_da;
+
+			if (is_multicast_ether_addr(skb->data))
+				/* DA TA mSA AE:SA */
+				mesh_da = skb->data;
+			else {
+				static const u8 bcast[ETH_ALEN] = {
+					0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+				if (mppath) {
+					/* RA TA mDA mSA AE:DA SA */
+					mesh_da = mppath->mpp;
+					is_mesh_mcast = 0;
+				} else {
+					/* DA TA mSA AE:SA */
+					mesh_da = bcast;
+				}
+			}
+			hdrlen = mac80211_fill_mesh_addresses(&hdr, &fc,
+					mesh_da, sdata->vif.addr);
+			rcu_read_unlock();
+			if (is_mesh_mcast)
+				meshhdrlen =
+					mac80211_new_mesh_header(&mesh_hdr,
+							sdata,
+							skb->data + ETH_ALEN,
+							NULL);
+			else
+				meshhdrlen =
+					mac80211_new_mesh_header(&mesh_hdr,
+							sdata,
+							skb->data,
+							skb->data + ETH_ALEN);
+
+		}
+		break;
+#endif
+	case NL80211_IFTYPE_STATION:
+		if (sdata->wdev.wiphy->flags & WIPHY_FLAG_SUPPORTS_TDLS) {
+			bool tdls_peer = false;
+
+			rcu_read_lock();
+			sta = xrmac_sta_info_get(sdata, skb->data);
+			if (sta) {
+				authorized = test_sta_flag(sta,
+							WLAN_STA_AUTHORIZED);
+				wme_sta = test_sta_flag(sta, WLAN_STA_WME);
+				tdls_peer = test_sta_flag(sta,
+							 WLAN_STA_TDLS_PEER);
+				tdls_auth = test_sta_flag(sta,
+						WLAN_STA_TDLS_PEER_AUTH);
+			}
+			rcu_read_unlock();
+
+			/*
+			 * If the TDLS link is enabled, send everything
+			 * directly. Otherwise, allow TDLS setup frames
+			 * to be transmitted indirectly.
+			 */
+			tdls_direct = tdls_peer && (tdls_auth ||
+				 !(ethertype == ETH_P_TDLS && skb->len > 14 &&
+				   skb->data[14] == WLAN_TDLS_SNAP_RFTYPE));
+		}
+
+		if (tdls_direct) {
+			/* link during setup - throw out frames to peer */
+			if (!tdls_auth) {
+				ret = NETDEV_TX_OK;
+				goto fail;
+			}
+
+			/* DA SA BSSID */
+			memcpy(hdr.addr1, skb->data, ETH_ALEN);
+			memcpy(hdr.addr2, skb->data + ETH_ALEN, ETH_ALEN);
+			memcpy(hdr.addr3, sdata->u.mgd.bssid, ETH_ALEN);
+			hdrlen = 24;
+		}  else if (sdata->u.mgd.use_4addr &&
+			    cpu_to_be16(ethertype) != sdata->control_port_protocol) {
+			fc |= cpu_to_le16(IEEE80211_FCTL_FROMDS |
+					  IEEE80211_FCTL_TODS);
+			/* RA TA DA SA */
+			memcpy(hdr.addr1, sdata->u.mgd.bssid, ETH_ALEN);
+			memcpy(hdr.addr2, sdata->vif.addr, ETH_ALEN);
+			memcpy(hdr.addr3, skb->data, ETH_ALEN);
+			memcpy(hdr.addr4, skb->data + ETH_ALEN, ETH_ALEN);
+			hdrlen = 30;
+		} else {
+			fc |= cpu_to_le16(IEEE80211_FCTL_TODS);
+			/* BSSID SA DA */
+			memcpy(hdr.addr1, sdata->u.mgd.bssid, ETH_ALEN);
+			memcpy(hdr.addr2, skb->data + ETH_ALEN, ETH_ALEN);
+			memcpy(hdr.addr3, skb->data, ETH_ALEN);
+			hdrlen = 24;
+		}
+		break;
+	case NL80211_IFTYPE_ADHOC:
+		/* DA SA BSSID */
+		memcpy(hdr.addr1, skb->data, ETH_ALEN);
+		memcpy(hdr.addr2, skb->data + ETH_ALEN, ETH_ALEN);
+		memcpy(hdr.addr3, sdata->u.ibss.bssid, ETH_ALEN);
+		hdrlen = 24;
+		break;
+	default:
+		ret = NETDEV_TX_OK;
+		goto fail;
+	}
+
+	/*
+	 * There's no need to try to look up the destination
+	 * if it is a multicast address (which can only happen
+	 * in AP mode)
+	 */
+	if (!is_multicast_ether_addr(hdr.addr1)) {
+		rcu_read_lock();
+		sta = xrmac_sta_info_get(sdata, hdr.addr1);
+		if (sta) {
+			authorized = test_sta_flag(sta, WLAN_STA_AUTHORIZED);
+			wme_sta = test_sta_flag(sta, WLAN_STA_WME);
+		}
+		rcu_read_unlock();
+	}
+
+	/* For mesh, the use of the QoS header is mandatory */
+	if (ieee80211_vif_is_mesh(&sdata->vif))
+		wme_sta = true;
+
+	/* receiver and we are QoS enabled, use a QoS type frame */
+	if (wme_sta && local->hw.queues >= IEEE80211_NUM_ACS) {
+		fc |= cpu_to_le16(IEEE80211_STYPE_QOS_DATA);
+		hdrlen += 2;
+	}
+
+	/*
+	 * Drop unicast frames to unauthorised stations unless they are
+	 * EAPOL frames from the local station.
+	 */
+	if (unlikely(!ieee80211_vif_is_mesh(&sdata->vif) &&
+		     !is_multicast_ether_addr(hdr.addr1) && !authorized &&
+		     (cpu_to_be16(ethertype) != sdata->control_port_protocol ||
+		      compare_ether_addr(sdata->vif.addr, skb->data + ETH_ALEN)))) {
+#ifdef CONFIG_XRMAC_VERBOSE_DEBUG
+		if (net_ratelimit())
+			printk(KERN_DEBUG "%s: dropped frame to %pM"
+			       " (unauthorized port)\n", dev->name,
+			       hdr.addr1);
+#endif
+
+		I802_DEBUG_INC(local->tx_handlers_drop_unauth_port);
+
+		ret = NETDEV_TX_OK;
+		goto fail;
+	}
+
+	/*
+	 * If the skb is shared we need to obtain our own copy.
+	 */
+	if (skb_shared(skb)) {
+		tmp_skb = skb;
+		skb = skb_clone(skb, GFP_ATOMIC);
+		kfree_skb(tmp_skb);
+
+		if (!skb) {
+			ret = NETDEV_TX_OK;
+			goto fail;
+		}
+	}
+
+	hdr.frame_control = fc;
+	hdr.duration_id = 0;
+	hdr.seq_ctrl = 0;
+
+	skip_header_bytes = ETH_HLEN;
+	if (ethertype == ETH_P_AARP || ethertype == ETH_P_IPX) {
+		encaps_data = bridge_tunnel_header;
+		encaps_len = sizeof(bridge_tunnel_header);
+		skip_header_bytes -= 2;
+	} else if (ethertype >= 0x600) {
+		encaps_data = rfc1042_header;
+		encaps_len = sizeof(rfc1042_header);
+		skip_header_bytes -= 2;
+	} else {
+		encaps_data = NULL;
+		encaps_len = 0;
+	}
+
+	nh_pos = skb_network_header(skb) - skb->data;
+	h_pos = skb_transport_header(skb) - skb->data;
+
+	skb_pull(skb, skip_header_bytes);
+	nh_pos -= skip_header_bytes;
+	h_pos -= skip_header_bytes;
+
+	head_need = hdrlen + encaps_len + meshhdrlen - skb_headroom(skb);
+
+	/*
+	 * So we need to modify the skb header and hence need a copy of
+	 * that. The head_need variable above doesn't, so far, include
+	 * the needed header space that we don't need right away. If we
+	 * can, then we don't reallocate right now but only after the
+	 * frame arrives at the master device (if it does...)
+	 *
+	 * If we cannot, however, then we will reallocate to include all
+	 * the ever needed space. Also, if we need to reallocate it anyway,
+	 * make it big enough for everything we may ever need.
+	 */
+
+	if (head_need > 0 || skb_cloned(skb)) {
+		head_need += IEEE80211_ENCRYPT_HEADROOM;
+		head_need += local->tx_headroom;
+		head_need = max_t(int, 0, head_need);
+		if (ieee80211_skb_resize(sdata, skb, head_need, true))
+			goto fail;
+	}
+
+	if (encaps_data) {
+		memcpy(skb_push(skb, encaps_len), encaps_data, encaps_len);
+		nh_pos += encaps_len;
+		h_pos += encaps_len;
+	}
+
+#ifdef CONFIG_XRMAC_MESH
+	if (meshhdrlen > 0) {
+		memcpy(skb_push(skb, meshhdrlen), &mesh_hdr, meshhdrlen);
+		nh_pos += meshhdrlen;
+		h_pos += meshhdrlen;
+	}
+#endif
+
+	if (ieee80211_is_data_qos(fc)) {
+		__le16 *qos_control;
+
+		qos_control = (__le16 *)skb_push(skb, 2);
+		memcpy(skb_push(skb, hdrlen - 2), &hdr, hdrlen - 2);
+		/*
+		 * Maybe we could actually set some fields here, for now just
+		 * initialise to zero to indicate no special operation.
+		 */
+		*qos_control = 0;
+	} else
+		memcpy(skb_push(skb, hdrlen), &hdr, hdrlen);
+
+	nh_pos += hdrlen;
+	h_pos += hdrlen;
+
+	dev->stats.tx_packets++;
+	dev->stats.tx_bytes += skb->len;
+
+	/* Update skb pointers to various headers since this modified frame
+	 * is going to go through Linux networking code that may potentially
+	 * need things like pointer to IP header. */
+	skb_set_mac_header(skb, 0);
+	skb_set_network_header(skb, nh_pos);
+	skb_set_transport_header(skb, h_pos);
+
+	info = IEEE80211_SKB_CB(skb);
+	memset(info, 0, sizeof(*info));
+
+	//dev->trans_start = jiffies;
+	netif_trans_update(dev);
+	mac80211_xmit(sdata, skb);
+
+	return NETDEV_TX_OK;
+
+ fail:
+	if (ret == NETDEV_TX_OK)
+		dev_kfree_skb(skb);
+
+	return ret;
+}
+
+
+/*
+ * mac80211_clear_tx_pending may not be called in a context where
+ * it is possible that it packets could come in again.
+ */
+void mac80211_clear_tx_pending(struct ieee80211_local *local)
+{
+	int i;
+
+	for (i = 0; i < local->hw.queues; i++)
+		skb_queue_purge(&local->pending[i]);
+}
+
+/*
+ * Returns false if the frame couldn't be transmitted but was queued instead,
+ * which in this case means re-queued -- take as an indication to stop sending
+ * more pending frames.
+ */
+static bool mac80211_tx_pending_skb(struct ieee80211_local *local,
+				     struct sk_buff *skb)
+{
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	struct ieee80211_sub_if_data *sdata;
+	struct sta_info *sta;
+	struct ieee80211_hdr *hdr;
+	bool result;
+
+	sdata = vif_to_sdata(info->control.vif);
+
+	if (info->flags & IEEE80211_TX_INTFL_NEED_TXPROCESSING) {
+		result = ieee80211_tx(sdata, skb, true);
+	} else {
+		hdr = (struct ieee80211_hdr *)skb->data;
+		sta = xrmac_sta_info_get(sdata, hdr->addr1);
+
+		result = __ieee80211_tx(local, &skb, sta, true);
+	}
+
+	return result;
+}
+
+/*
+ * Transmit all pending packets. Called from tasklet.
+ */
+void mac80211_tx_pending(unsigned long data)
+{
+	struct ieee80211_local *local = (struct ieee80211_local *)data;
+	unsigned long flags;
+	int i;
+	bool txok;
+
+	rcu_read_lock();
+
+	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
+	for (i = 0; i < local->hw.queues; i++) {
+		/*
+		 * If queue is stopped by something other than due to pending
+		 * frames, or we have no pending frames, proceed to next queue.
+		 */
+		if (local->queue_stop_reasons[i] ||
+		    skb_queue_empty(&local->pending[i]))
+			continue;
+
+		while (!skb_queue_empty(&local->pending[i])) {
+			struct sk_buff *skb = __skb_dequeue(&local->pending[i]);
+			struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+
+			if (WARN_ON(!info->control.vif)) {
+				kfree_skb(skb);
+				continue;
+			}
+
+			spin_unlock_irqrestore(&local->queue_stop_reason_lock,
+						flags);
+
+			txok = mac80211_tx_pending_skb(local, skb);
+			spin_lock_irqsave(&local->queue_stop_reason_lock,
+					  flags);
+			if (!txok)
+				break;
+		}
+
+		if (skb_queue_empty(&local->pending[i]))
+			mac80211_propagate_queue_wake(local, i);
+	}
+	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
+
+	rcu_read_unlock();
+}
+
+/* functions for drivers to get certain frames */
+
+static void ieee80211_beacon_add_tim(struct ieee80211_if_ap *bss,
+				     struct sk_buff *skb,
+				     struct beacon_data *beacon)
+{
+	u8 *pos, *tim;
+	int aid0 = 0;
+	int i, have_bits = 0, n1, n2;
+
+	/* Generate bitmap for TIM only if there are any STAs in power save
+	 * mode. */
+	if (atomic_read(&bss->num_sta_ps) > 0)
+		/* in the hope that this is faster than
+		 * checking byte-for-byte */
+		have_bits = !bitmap_empty((unsigned long *)bss->tim,
+					  IEEE80211_MAX_AID+1);
+
+	if (bss->dtim_count == 0)
+		bss->dtim_count = beacon->dtim_period - 1;
+	else
+		bss->dtim_count--;
+
+	tim = pos = (u8 *) skb_put(skb, 6);
+	*pos++ = WLAN_EID_TIM;
+	*pos++ = 4;
+	*pos++ = bss->dtim_count;
+	*pos++ = beacon->dtim_period;
+
+	if (bss->dtim_count == 0 && !skb_queue_empty(&bss->ps_bc_buf))
+		aid0 = 1;
+
+	bss->dtim_bc_mc = aid0 == 1;
+
+	if (have_bits) {
+		/* Find largest even number N1 so that bits numbered 1 through
+		 * (N1 x 8) - 1 in the bitmap are 0 and number N2 so that bits
+		 * (N2 + 1) x 8 through 2007 are 0. */
+		n1 = 0;
+		for (i = 0; i < IEEE80211_MAX_TIM_LEN; i++) {
+			if (bss->tim[i]) {
+				n1 = i & 0xfe;
+				break;
+			}
+		}
+		n2 = n1;
+		for (i = IEEE80211_MAX_TIM_LEN - 1; i >= n1; i--) {
+			if (bss->tim[i]) {
+				n2 = i;
+				break;
+			}
+		}
+
+		/* Bitmap control */
+		*pos++ = n1 | aid0;
+		/* Part Virt Bitmap */
+		memcpy(pos, bss->tim + n1, n2 - n1 + 1);
+
+		tim[1] = n2 - n1 + 4;
+		skb_put(skb, n2 - n1);
+	} else {
+		*pos++ = aid0; /* Bitmap control */
+		*pos++ = 0; /* Part Virt Bitmap */
+	}
+}
+
+struct sk_buff *mac80211_beacon_get_tim(struct ieee80211_hw *hw,
+					 struct ieee80211_vif *vif,
+					 u16 *tim_offset, u16 *tim_length)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct ieee80211_channel_state *chan_state;
+	struct sk_buff *skb = NULL;
+	struct ieee80211_tx_info *info;
+	struct ieee80211_sub_if_data *sdata = NULL;
+	struct ieee80211_if_ap *ap = NULL;
+	struct beacon_data *beacon;
+	struct ieee80211_supported_band *sband;
+	enum nl80211_band band;
+	struct ieee80211_tx_rate_control txrc;
+
+	rcu_read_lock();
+
+	sdata = vif_to_sdata(vif);
+	chan_state = ieee80211_get_channel_state(local, sdata);
+	band = chan_state->conf.channel->band;
+	sband = local->hw.wiphy->bands[band];
+
+	if (!ieee80211_sdata_running(sdata))
+		goto out;
+
+	if (tim_offset)
+		*tim_offset = 0;
+	if (tim_length)
+		*tim_length = 0;
+
+	if (sdata->vif.type == NL80211_IFTYPE_AP) {
+		ap = &sdata->u.ap;
+		beacon = rcu_dereference(ap->beacon);
+		if (beacon) {
+			/*
+			 * headroom, head length,
+			 * tail length and maximum TIM length
+			 */
+			skb = dev_alloc_skb(local->tx_headroom +
+					    beacon->head_len +
+					    beacon->tail_len + 256);
+			if (!skb)
+				goto out;
+
+			skb_reserve(skb, local->tx_headroom);
+			memcpy(skb_put(skb, beacon->head_len), beacon->head,
+			       beacon->head_len);
+
+			/*
+			 * Not very nice, but we want to allow the driver to call
+			 * ieee80211_beacon_get() as a response to the set_tim()
+			 * callback. That, however, is already invoked under the
+			 * sta_lock to guarantee consistent and race-free update
+			 * of the tim bitmap in mac80211 and the driver.
+			 */
+			if (local->tim_in_locked_section) {
+				ieee80211_beacon_add_tim(ap, skb, beacon);
+			} else {
+				unsigned long flags;
+
+				spin_lock_irqsave(&local->sta_lock, flags);
+				ieee80211_beacon_add_tim(ap, skb, beacon);
+				spin_unlock_irqrestore(&local->sta_lock, flags);
+			}
+
+			if (tim_offset)
+				*tim_offset = beacon->head_len;
+			if (tim_length)
+				*tim_length = skb->len - beacon->head_len;
+
+			if (beacon->tail)
+				memcpy(skb_put(skb, beacon->tail_len),
+				       beacon->tail, beacon->tail_len);
+		} else
+			goto out;
+	} else if (sdata->vif.type == NL80211_IFTYPE_ADHOC) {
+		struct ieee80211_if_ibss *ifibss = &sdata->u.ibss;
+		struct ieee80211_hdr *hdr;
+		struct sk_buff *presp = rcu_dereference(ifibss->presp);
+
+		if (!presp)
+			goto out;
+
+		skb = skb_copy(presp, GFP_ATOMIC);
+		if (!skb)
+			goto out;
+
+		hdr = (struct ieee80211_hdr *) skb->data;
+		hdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+						 IEEE80211_STYPE_BEACON);
+	} else if (ieee80211_vif_is_mesh(&sdata->vif)) {
+		struct ieee80211_mgmt *mgmt;
+		u8 *pos;
+
+#ifdef CONFIG_XRMAC_MESH
+		if (!sdata->u.mesh.mesh_id_len)
+			goto out;
+#endif
+
+		/* headroom, head length, tail length and maximum TIM length */
+		skb = dev_alloc_skb(local->tx_headroom + 400 +
+				sdata->u.mesh.ie_len);
+		if (!skb)
+			goto out;
+
+		skb_reserve(skb, local->hw.extra_tx_headroom);
+		mgmt = (struct ieee80211_mgmt *)
+			skb_put(skb, 24 + sizeof(mgmt->u.beacon));
+		memset(mgmt, 0, 24 + sizeof(mgmt->u.beacon));
+		mgmt->frame_control =
+		    cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_BEACON);
+		memset(mgmt->da, 0xff, ETH_ALEN);
+		memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
+		memcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);
+		mgmt->u.beacon.beacon_int =
+			cpu_to_le16(sdata->vif.bss_conf.beacon_int);
+		mgmt->u.beacon.capab_info |= cpu_to_le16(
+			sdata->u.mesh.security ? WLAN_CAPABILITY_PRIVACY : 0);
+
+		pos = skb_put(skb, 2);
+		*pos++ = WLAN_EID_SSID;
+		*pos++ = 0x0;
+
+		if (mac80211_add_srates_ie(&sdata->vif, skb) ||
+		    xrmac_mesh_add_ds_params_ie(skb, sdata) ||
+		    mac80211_add_ext_srates_ie(&sdata->vif, skb) ||
+		    xrmac_mesh_add_rsn_ie(skb, sdata) ||
+		    xrmac_mesh_add_meshid_ie(skb, sdata) ||
+		    xrmac_mesh_add_meshconf_ie(skb, sdata) ||
+		    xrmac_mesh_add_vendor_ies(skb, sdata)) {
+			pr_err("o11s: couldn't add ies!\n");
+			goto out;
+		}
+	} else {
+		WARN_ON(1);
+		goto out;
+	}
+
+	info = IEEE80211_SKB_CB(skb);
+
+	info->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
+	info->flags |= IEEE80211_TX_CTL_NO_ACK;
+	info->band = band;
+
+	memset(&txrc, 0, sizeof(txrc));
+	txrc.hw = hw;
+	txrc.sband = sband;
+	txrc.bss_conf = &sdata->vif.bss_conf;
+	txrc.skb = skb;
+	txrc.reported_rate.idx = -1;
+	txrc.rate_idx_mask = sdata->rc_rateidx_mask[band];
+	if (txrc.rate_idx_mask == (1 << sband->n_bitrates) - 1)
+		txrc.max_rate_idx = -1;
+	else
+		txrc.max_rate_idx = fls(txrc.rate_idx_mask) - 1;
+	txrc.bss = true;
+	xrmac_rate_control_get_rate(sdata, NULL, &txrc);
+
+	info->control.vif = vif;
+
+	info->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT |
+			IEEE80211_TX_CTL_ASSIGN_SEQ |
+			IEEE80211_TX_CTL_FIRST_FRAGMENT;
+ out:
+	rcu_read_unlock();
+	return skb;
+}
+
+#ifdef PROBE_RESP_EXTRA_IE
+struct sk_buff *mac80211_proberesp_get(struct ieee80211_hw *hw,
+						   struct ieee80211_vif *vif)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct sk_buff *skb = NULL;
+	struct ieee80211_channel_state *chan_state;
+	struct ieee80211_tx_info *info;
+	struct ieee80211_sub_if_data *sdata = NULL;
+	struct ieee80211_if_ap *ap = NULL;
+	struct proberesp_data *proberesp;
+	struct ieee80211_supported_band *sband;
+	enum nl80211_band band;
+	struct ieee80211_tx_rate_control txrc;
+
+	rcu_read_lock();
+
+	sdata = vif_to_sdata(vif);
+	chan_state = ieee80211_get_channel_state(local, sdata);
+	band = chan_state->conf.channel->band;
+	sband = local->hw.wiphy->bands[band];
+
+	if (!ieee80211_sdata_running(sdata))
+		goto out;
+
+	if (sdata->vif.type == NL80211_IFTYPE_AP) {
+		ap = &sdata->u.ap;
+		proberesp = rcu_dereference(ap->proberesp);
+		if (proberesp) {
+			/*
+			 * headroom, head length,
+			 * tail length and probe response ie length
+			 */
+			skb = dev_alloc_skb(local->tx_headroom +
+					    proberesp->head_len + proberesp->proberesp_data_ies_len +
+					    proberesp->tail_len);
+			if (!skb)
+				goto out;
+
+			skb_reserve(skb, local->tx_headroom);
+			memcpy(skb_put(skb, proberesp->head_len), proberesp->head,
+			       proberesp->head_len);
+
+			if (proberesp->tail)
+				memcpy(skb_put(skb, proberesp->tail_len),
+				       proberesp->tail, proberesp->tail_len);
+
+			if (proberesp->proberesp_data_ies)
+				memcpy(skb_put(skb, proberesp->proberesp_data_ies_len),
+				       proberesp->proberesp_data_ies, proberesp->proberesp_data_ies_len);
+
+		} else
+			goto out;
+	} else {
+		WARN_ON(1);
+		goto out;
+	}
+
+	info = IEEE80211_SKB_CB(skb);
+
+	info->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
+	/*info->flags |= IEEE80211_TX_CTL_NO_ACK;*/
+	info->band = band;
+
+	memset(&txrc, 0, sizeof(txrc));
+	txrc.hw = hw;
+	txrc.sband = sband;
+	txrc.bss_conf = &sdata->vif.bss_conf;
+	txrc.skb = skb;
+	txrc.reported_rate.idx = -1;
+	txrc.rate_idx_mask = sdata->rc_rateidx_mask[band];
+	if (txrc.rate_idx_mask == (1 << sband->n_bitrates) - 1)
+		txrc.max_rate_idx = -1;
+	else
+		txrc.max_rate_idx = fls(txrc.rate_idx_mask) - 1;
+	txrc.bss = true;
+	xrmac_rate_control_get_rate(sdata, NULL, &txrc);
+
+	info->control.vif = vif;
+
+	info->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT |
+			IEEE80211_TX_CTL_ASSIGN_SEQ |
+			IEEE80211_TX_CTL_FIRST_FRAGMENT;
+ out:
+	rcu_read_unlock();
+	return skb;
+}
+#endif
+
+struct sk_buff *mac80211_pspoll_get(struct ieee80211_hw *hw,
+				     struct ieee80211_vif *vif)
+{
+	struct ieee80211_sub_if_data *sdata;
+	struct ieee80211_if_managed *ifmgd;
+	struct ieee80211_pspoll *pspoll;
+	struct ieee80211_local *local;
+	struct sk_buff *skb;
+
+	if (WARN_ON(vif->type != NL80211_IFTYPE_STATION))
+		return NULL;
+
+	sdata = vif_to_sdata(vif);
+	ifmgd = &sdata->u.mgd;
+	local = sdata->local;
+
+	skb = dev_alloc_skb(local->hw.extra_tx_headroom + sizeof(*pspoll));
+	if (!skb)
+		return NULL;
+
+	skb_reserve(skb, local->hw.extra_tx_headroom);
+
+	pspoll = (struct ieee80211_pspoll *) skb_put(skb, sizeof(*pspoll));
+	memset(pspoll, 0, sizeof(*pspoll));
+	pspoll->frame_control = cpu_to_le16(IEEE80211_FTYPE_CTL |
+					    IEEE80211_STYPE_PSPOLL);
+	pspoll->aid = cpu_to_le16(ifmgd->aid);
+
+	/* aid in PS-Poll has its two MSBs each set to 1 */
+	pspoll->aid |= cpu_to_le16(1 << 15 | 1 << 14);
+
+	memcpy(pspoll->bssid, ifmgd->bssid, ETH_ALEN);
+	memcpy(pspoll->ta, vif->addr, ETH_ALEN);
+
+	return skb;
+}
+
+struct sk_buff *mac80211_nullfunc_get(struct ieee80211_hw *hw,
+				       struct ieee80211_vif *vif)
+{
+	struct ieee80211_hdr_3addr *nullfunc;
+	struct ieee80211_sub_if_data *sdata;
+	struct ieee80211_if_managed *ifmgd;
+	struct ieee80211_local *local;
+	struct sk_buff *skb;
+
+	if (WARN_ON(vif->type != NL80211_IFTYPE_STATION))
+		return NULL;
+
+	sdata = vif_to_sdata(vif);
+	ifmgd = &sdata->u.mgd;
+	local = sdata->local;
+
+	skb = dev_alloc_skb(local->hw.extra_tx_headroom + sizeof(*nullfunc));
+	if (!skb)
+		return NULL;
+
+	skb_reserve(skb, local->hw.extra_tx_headroom);
+
+	nullfunc = (struct ieee80211_hdr_3addr *) skb_put(skb,
+							  sizeof(*nullfunc));
+	memset(nullfunc, 0, sizeof(*nullfunc));
+	nullfunc->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |
+					      IEEE80211_STYPE_NULLFUNC |
+					      IEEE80211_FCTL_TODS);
+	memcpy(nullfunc->addr1, ifmgd->bssid, ETH_ALEN);
+	memcpy(nullfunc->addr2, vif->addr, ETH_ALEN);
+	memcpy(nullfunc->addr3, ifmgd->bssid, ETH_ALEN);
+
+	return skb;
+}
+
+struct sk_buff *ieee80211_qosnullfunc_get(struct ieee80211_hw *hw,
+					  struct ieee80211_vif *vif)
+{
+	struct ieee80211_qos_hdr *nullfunc;
+	struct ieee80211_sub_if_data *sdata;
+	struct ieee80211_if_managed *ifmgd;
+	struct ieee80211_local *local;
+	struct sk_buff *skb;
+
+	if (WARN_ON(vif->type != NL80211_IFTYPE_STATION))
+		return NULL;
+
+	sdata = vif_to_sdata(vif);
+	ifmgd = &sdata->u.mgd;
+	local = sdata->local;
+
+	skb = dev_alloc_skb(local->hw.extra_tx_headroom + sizeof(*nullfunc));
+	if (!skb) {
+		printk(KERN_DEBUG "%s: failed to allocate buffer for qos "
+		       "nullfunc template\n", sdata->name);
+		return NULL;
+	}
+	skb_reserve(skb, local->hw.extra_tx_headroom);
+
+	nullfunc = (struct ieee80211_qos_hdr *) skb_put(skb,
+							  sizeof(*nullfunc));
+	memset(nullfunc, 0, sizeof(*nullfunc));
+	nullfunc->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |
+					      IEEE80211_STYPE_QOS_NULLFUNC |
+					      IEEE80211_FCTL_TODS);
+	memcpy(nullfunc->addr1, ifmgd->bssid, ETH_ALEN);
+	memcpy(nullfunc->addr2, vif->addr, ETH_ALEN);
+	memcpy(nullfunc->addr3, ifmgd->bssid, ETH_ALEN);
+
+	return skb;
+}
+
+struct sk_buff *mac80211_probereq_get(struct ieee80211_hw *hw,
+				       struct ieee80211_vif *vif,
+				       const u8 *ssid, size_t ssid_len,
+				       const u8 *ie, size_t ie_len)
+{
+	struct ieee80211_sub_if_data *sdata;
+	struct ieee80211_local *local;
+	struct ieee80211_hdr_3addr *hdr;
+	struct sk_buff *skb;
+	size_t ie_ssid_len;
+	u8 *pos;
+
+	sdata = vif_to_sdata(vif);
+	local = sdata->local;
+	ie_ssid_len = 2 + ssid_len;
+
+	skb = dev_alloc_skb(local->hw.extra_tx_headroom + sizeof(*hdr) +
+			    ie_ssid_len + ie_len);
+	if (!skb)
+		return NULL;
+
+	skb_reserve(skb, local->hw.extra_tx_headroom);
+
+	hdr = (struct ieee80211_hdr_3addr *) skb_put(skb, sizeof(*hdr));
+	memset(hdr, 0, sizeof(*hdr));
+	hdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+					 IEEE80211_STYPE_PROBE_REQ);
+	memset(hdr->addr1, 0xff, ETH_ALEN);
+	memcpy(hdr->addr2, vif->addr, ETH_ALEN);
+	memset(hdr->addr3, 0xff, ETH_ALEN);
+
+	pos = skb_put(skb, ie_ssid_len);
+	*pos++ = WLAN_EID_SSID;
+	*pos++ = ssid_len;
+	if (ssid)
+		memcpy(pos, ssid, ssid_len);
+	pos += ssid_len;
+
+	if (ie) {
+		pos = skb_put(skb, ie_len);
+		memcpy(pos, ie, ie_len);
+	}
+
+	return skb;
+}
+
+void mac80211_rts_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		       const void *frame, size_t frame_len,
+		       const struct ieee80211_tx_info *frame_txctl,
+		       struct ieee80211_rts *rts)
+{
+	const struct ieee80211_hdr *hdr = frame;
+
+	rts->frame_control =
+	    cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_RTS);
+	rts->duration = mac80211_rts_duration(hw, vif, frame_len,
+					       frame_txctl);
+	memcpy(rts->ra, hdr->addr1, sizeof(rts->ra));
+	memcpy(rts->ta, hdr->addr2, sizeof(rts->ta));
+}
+
+void mac80211_ctstoself_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			     const void *frame, size_t frame_len,
+			     const struct ieee80211_tx_info *frame_txctl,
+			     struct ieee80211_cts *cts)
+{
+	const struct ieee80211_hdr *hdr = frame;
+
+	cts->frame_control =
+	    cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_CTS);
+	cts->duration = mac80211_ctstoself_duration(hw, vif,
+						     frame_len, frame_txctl);
+	memcpy(cts->ra, hdr->addr1, sizeof(cts->ra));
+}
+
+struct sk_buff *
+mac80211_get_buffered_bc(struct ieee80211_hw *hw,
+			  struct ieee80211_vif *vif)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sdata);
+	struct sk_buff *skb = NULL;
+	struct ieee80211_tx_data tx;
+	struct ieee80211_if_ap *bss = NULL;
+	struct beacon_data *beacon;
+	struct ieee80211_tx_info *info;
+
+	bss = &sdata->u.ap;
+
+	rcu_read_lock();
+	beacon = rcu_dereference(bss->beacon);
+
+	if (sdata->vif.type != NL80211_IFTYPE_AP || !beacon || !beacon->head)
+		goto out;
+
+	if (bss->dtim_count != 0 || !bss->dtim_bc_mc)
+		goto out; /* send buffered bc/mc only after DTIM beacon */
+
+	while (1) {
+		skb = skb_dequeue(&bss->ps_bc_buf);
+		if (!skb)
+			goto out;
+		local->total_ps_buffered--;
+
+		if (!skb_queue_empty(&bss->ps_bc_buf) && skb->len >= 2) {
+			struct ieee80211_hdr *hdr =
+				(struct ieee80211_hdr *) skb->data;
+			/* more buffered multicast/broadcast frames ==> set
+			 * MoreData flag in IEEE 802.11 header to inform PS
+			 * STAs */
+			hdr->frame_control |=
+				cpu_to_le16(IEEE80211_FCTL_MOREDATA);
+		}
+
+		if (!ieee80211_tx_prepare(sdata, &tx, skb))
+			break;
+		dev_kfree_skb_any(skb);
+	}
+
+	info = IEEE80211_SKB_CB(skb);
+
+	tx.flags |= IEEE80211_TX_PS_BUFFERED;
+	tx.channel = chan_state->conf.channel;
+	info->band = tx.channel->band;
+
+	if (invoke_tx_handlers(&tx))
+		skb = NULL;
+ out:
+	rcu_read_unlock();
+
+	return skb;
+}
+
+void ieee80211_tx_skb(struct ieee80211_sub_if_data *sdata, struct sk_buff *skb)
+{
+	skb_set_mac_header(skb, 0);
+	skb_set_network_header(skb, 0);
+	skb_set_transport_header(skb, 0);
+
+	/* Send all internal mgmt frames on VO. Accordingly set TID to 7. */
+	skb_set_queue_mapping(skb, IEEE80211_AC_VO);
+	skb->priority = 7;
+
+	/*
+	 * The other path calling mac80211_xmit is from the tasklet,
+	 * and while we can handle concurrent transmissions locking
+	 * requirements are that we do not come into tx with bhs on.
+	 */
+	local_bh_disable();
+	mac80211_xmit(sdata, skb);
+	local_bh_enable();
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/util.c b/drivers/net/wireless/xr829/umac/util.c
--- a/drivers/net/wireless/xr829/umac/util.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/util.c	2022-08-27 01:22:42.958539877 +0300
@@ -0,0 +1,1813 @@
+/*
+ * Copyright 2002-2005, Instant802 Networks, Inc.
+ * Copyright 2005-2006, Devicescape Software, Inc.
+ * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
+ * Copyright 2007	Johannes Berg <johannes@sipsolutions.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * utilities for mac80211
+ */
+
+#include <net/mac80211.h>
+#include <linux/netdevice.h>
+#include <linux/export.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/skbuff.h>
+#include <linux/etherdevice.h>
+#include <linux/if_arp.h>
+#include <linux/bitmap.h>
+#include <linux/crc32.h>
+#include <net/net_namespace.h>
+#include <net/cfg80211.h>
+#include <net/rtnetlink.h>
+
+#include "ieee80211_i.h"
+#include "driver-ops.h"
+#include "rate.h"
+#include "mesh.h"
+#include "wme.h"
+#include "led.h"
+#include "wep.h"
+
+/* privid for wiphys to determine whether they belong to us or not */
+void *xrmac_wiphy_privid = &xrmac_wiphy_privid;
+
+struct ieee80211_hw *xrmac_wiphy_to_ieee80211_hw(struct wiphy *wiphy)
+{
+	struct ieee80211_local *local;
+	BUG_ON(!wiphy);
+
+	local = wiphy_priv(wiphy);
+	return &local->hw;
+}
+
+u8 *mac80211_get_bssid(struct ieee80211_hdr *hdr, size_t len,
+			enum nl80211_iftype type)
+{
+	__le16 fc = hdr->frame_control;
+
+	 /* drop ACK/CTS frames and incorrect hdr len (ctrl) */
+	if (len < 16)
+		return NULL;
+
+	if (ieee80211_is_data(fc)) {
+		if (len < 24) /* drop incorrect hdr len (data) */
+			return NULL;
+
+		if (ieee80211_has_a4(fc))
+			return NULL;
+		if (ieee80211_has_tods(fc))
+			return hdr->addr1;
+		if (ieee80211_has_fromds(fc))
+			return hdr->addr2;
+
+		return hdr->addr3;
+	}
+
+	if (ieee80211_is_mgmt(fc)) {
+		if (len < 24) /* drop incorrect hdr len (mgmt) */
+			return NULL;
+		return hdr->addr3;
+	}
+
+	if (ieee80211_is_ctl(fc)) {
+		if (ieee80211_is_pspoll(fc))
+			return hdr->addr1;
+
+		if (ieee80211_is_back_req(fc)) {
+			switch (type) {
+			case NL80211_IFTYPE_STATION:
+				return hdr->addr2;
+			case NL80211_IFTYPE_AP:
+			case NL80211_IFTYPE_AP_VLAN:
+				return hdr->addr1;
+			default:
+				break; /* fall through to the return */
+			}
+		}
+	}
+
+	return NULL;
+}
+
+void mac80211_tx_set_protected(struct ieee80211_tx_data *tx)
+{
+	struct sk_buff *skb = tx->skb;
+	struct ieee80211_hdr *hdr;
+
+	do {
+		hdr = (struct ieee80211_hdr *) skb->data;
+		hdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);
+	} while ((skb = skb->next));
+}
+
+int mac80211_frame_duration(enum nl80211_band band, size_t len,
+			     int rate, int erp, int short_preamble)
+{
+	int dur;
+
+	/* calculate duration (in microseconds, rounded up to next higher
+	 * integer if it includes a fractional microsecond) to send frame of
+	 * len bytes (does not include FCS) at the given rate. Duration will
+	 * also include SIFS.
+	 *
+	 * rate is in 100 kbps, so divident is multiplied by 10 in the
+	 * DIV_ROUND_UP() operations.
+	 */
+
+	if (band == NL80211_BAND_5GHZ || erp) {
+		/*
+		 * OFDM:
+		 *
+		 * N_DBPS = DATARATE x 4
+		 * N_SYM = Ceiling((16+8xLENGTH+6) / N_DBPS)
+		 *	(16 = SIGNAL time, 6 = tail bits)
+		 * TXTIME = T_PREAMBLE + T_SIGNAL + T_SYM x N_SYM + Signal Ext
+		 *
+		 * T_SYM = 4 usec
+		 * 802.11a - 17.5.2: aSIFSTime = 16 usec
+		 * 802.11g - 19.8.4: aSIFSTime = 10 usec +
+		 *	signal ext = 6 usec
+		 */
+		dur = 16; /* SIFS + signal ext */
+		dur += 16; /* 17.3.2.3: T_PREAMBLE = 16 usec */
+		dur += 4; /* 17.3.2.3: T_SIGNAL = 4 usec */
+		dur += 4 * DIV_ROUND_UP((16 + 8 * (len + 4) + 6) * 10,
+					4 * rate); /* T_SYM x N_SYM */
+	} else {
+		/*
+		 * 802.11b or 802.11g with 802.11b compatibility:
+		 * 18.3.4: TXTIME = PreambleLength + PLCPHeaderTime +
+		 * Ceiling(((LENGTH+PBCC)x8)/DATARATE). PBCC=0.
+		 *
+		 * 802.11 (DS): 15.3.3, 802.11b: 18.3.4
+		 * aSIFSTime = 10 usec
+		 * aPreambleLength = 144 usec or 72 usec with short preamble
+		 * aPLCPHeaderLength = 48 usec or 24 usec with short preamble
+		 */
+		dur = 10; /* aSIFSTime = 10 usec */
+		dur += short_preamble ? (72 + 24) : (144 + 48);
+
+		dur += DIV_ROUND_UP(8 * (len + 4) * 10, rate);
+	}
+
+	return dur;
+}
+
+/* Exported duration function for driver use */
+__le16 mac80211_generic_frame_duration(struct ieee80211_hw *hw,
+					struct ieee80211_vif *vif,
+					enum nl80211_band band,
+					size_t frame_len,
+					struct ieee80211_rate *rate)
+{
+	struct ieee80211_sub_if_data *sdata;
+	u16 dur;
+	int erp;
+	bool short_preamble = false;
+
+	erp = 0;
+	if (vif) {
+		sdata = vif_to_sdata(vif);
+		short_preamble = sdata->vif.bss_conf.use_short_preamble;
+		if (sdata->flags & IEEE80211_SDATA_OPERATING_GMODE)
+			erp = rate->flags & IEEE80211_RATE_ERP_G;
+	}
+
+	dur = mac80211_frame_duration(band, frame_len, rate->bitrate, erp,
+				       short_preamble);
+
+	return cpu_to_le16(dur);
+}
+
+__le16 mac80211_rts_duration(struct ieee80211_hw *hw,
+			      struct ieee80211_vif *vif, size_t frame_len,
+			      const struct ieee80211_tx_info *frame_txctl)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct ieee80211_rate *rate;
+	struct ieee80211_sub_if_data *sdata;
+	bool short_preamble;
+	int erp;
+	u16 dur;
+	struct ieee80211_supported_band *sband;
+
+	sband = local->hw.wiphy->bands[frame_txctl->band];
+
+	short_preamble = false;
+
+	rate = &sband->bitrates[frame_txctl->control.rts_cts_rate_idx];
+
+	erp = 0;
+	if (vif) {
+		sdata = vif_to_sdata(vif);
+		short_preamble = sdata->vif.bss_conf.use_short_preamble;
+		if (sdata->flags & IEEE80211_SDATA_OPERATING_GMODE)
+			erp = rate->flags & IEEE80211_RATE_ERP_G;
+	}
+
+	/* CTS duration */
+	dur = mac80211_frame_duration(sband->band, 10, rate->bitrate,
+				       erp, short_preamble);
+	/* Data frame duration */
+	dur += mac80211_frame_duration(sband->band, frame_len, rate->bitrate,
+					erp, short_preamble);
+	/* ACK duration */
+	dur += mac80211_frame_duration(sband->band, 10, rate->bitrate,
+					erp, short_preamble);
+
+	return cpu_to_le16(dur);
+}
+
+__le16 mac80211_ctstoself_duration(struct ieee80211_hw *hw,
+				    struct ieee80211_vif *vif,
+				    size_t frame_len,
+				    const struct ieee80211_tx_info *frame_txctl)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct ieee80211_rate *rate;
+	struct ieee80211_sub_if_data *sdata;
+	bool short_preamble;
+	int erp;
+	u16 dur;
+	struct ieee80211_supported_band *sband;
+
+	sband = local->hw.wiphy->bands[frame_txctl->band];
+
+	short_preamble = false;
+
+	rate = &sband->bitrates[frame_txctl->control.rts_cts_rate_idx];
+	erp = 0;
+	if (vif) {
+		sdata = vif_to_sdata(vif);
+		short_preamble = sdata->vif.bss_conf.use_short_preamble;
+		if (sdata->flags & IEEE80211_SDATA_OPERATING_GMODE)
+			erp = rate->flags & IEEE80211_RATE_ERP_G;
+	}
+
+	/* Data frame duration */
+	dur = mac80211_frame_duration(sband->band, frame_len, rate->bitrate,
+				       erp, short_preamble);
+	if (!(frame_txctl->flags & IEEE80211_TX_CTL_NO_ACK)) {
+		/* ACK duration */
+		dur += mac80211_frame_duration(sband->band, 10, rate->bitrate,
+						erp, short_preamble);
+	}
+
+	return cpu_to_le16(dur);
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 23))
+static bool ieee80211_all_queues_started(struct ieee80211_hw *hw)
+{
+	unsigned int queue;
+
+	for (queue = 0; queue < hw->queues; queue++)
+		if (mac80211_queue_stopped(hw, queue))
+			return false;
+	return true;
+}
+#endif
+
+void mac80211_propagate_queue_wake(struct ieee80211_local *local, int queue)
+{
+	struct ieee80211_sub_if_data *sdata;
+
+	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
+		int ac;
+
+		if (!sdata->dev)
+			continue;
+#ifdef CONFIG_XRMAC_XR_ROAMING_CHANGES
+		if (test_bit(SDATA_STATE_OFFCHANNEL, &sdata->state)
+			    || sdata->queues_locked)
+#else
+		if (test_bit(SDATA_STATE_OFFCHANNEL, &sdata->state))
+#endif
+			continue;
+
+		if (sdata->vif.cab_queue != IEEE80211_INVAL_HW_QUEUE &&
+		    local->queue_stop_reasons[sdata->vif.cab_queue] != 0)
+			continue;
+
+		for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
+			int ac_queue = sdata->vif.hw_queue[ac];
+
+			if (ac_queue == queue ||
+			    (sdata->vif.cab_queue == queue &&
+			     local->queue_stop_reasons[ac_queue] == 0 &&
+			     skb_queue_empty(&local->pending[ac_queue])))
+				netif_wake_subqueue(sdata->dev, ac);
+		}
+	}
+}
+
+static void __mac80211_wake_queue(struct ieee80211_hw *hw, int queue,
+				   enum queue_stop_reason reason)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+
+	trace_wake_queue(local, queue, reason);
+
+	if (WARN_ON(queue >= hw->queues))
+		return;
+
+	if (!test_bit(reason, &local->queue_stop_reasons[queue]))
+		return;
+
+	__clear_bit(reason, &local->queue_stop_reasons[queue]);
+
+	if (local->queue_stop_reasons[queue] != 0)
+		/* someone still has this queue stopped */
+		return;
+
+	if (skb_queue_empty(&local->pending[queue])) {
+		rcu_read_lock();
+		mac80211_propagate_queue_wake(local, queue);
+		rcu_read_unlock();
+	} else
+		tasklet_schedule(&local->tx_pending_tasklet);
+}
+
+void mac80211_wake_queue_by_reason(struct ieee80211_hw *hw, int queue,
+				    enum queue_stop_reason reason)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	unsigned long flags;
+
+	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
+	__mac80211_wake_queue(hw, queue, reason);
+	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
+}
+
+void mac80211_wake_queue(struct ieee80211_hw *hw, int queue)
+{
+	mac80211_wake_queue_by_reason(hw, queue,
+				       IEEE80211_QUEUE_STOP_REASON_DRIVER);
+}
+
+static void __mac80211_stop_queue(struct ieee80211_hw *hw, int queue,
+				   enum queue_stop_reason reason)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct ieee80211_sub_if_data *sdata;
+
+	trace_stop_queue(local, queue, reason);
+
+	if (WARN_ON(queue >= hw->queues))
+		return;
+
+	if (test_bit(reason, &local->queue_stop_reasons[queue]))
+		return;
+
+	__set_bit(reason, &local->queue_stop_reasons[queue]);
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
+		int ac;
+
+		if (!sdata->dev)
+			continue;
+
+		for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
+			if (sdata->vif.hw_queue[ac] == queue ||
+			    sdata->vif.cab_queue == queue)
+				netif_stop_subqueue(sdata->dev, ac);
+		}
+	}
+	rcu_read_unlock();
+}
+
+void mac80211_stop_queue_by_reason(struct ieee80211_hw *hw, int queue,
+				    enum queue_stop_reason reason)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	unsigned long flags;
+
+	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
+	__mac80211_stop_queue(hw, queue, reason);
+	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
+}
+
+void mac80211_stop_queue(struct ieee80211_hw *hw, int queue)
+{
+	mac80211_stop_queue_by_reason(hw, queue,
+				       IEEE80211_QUEUE_STOP_REASON_DRIVER);
+}
+
+void mac80211_add_pending_skb(struct ieee80211_local *local,
+			       struct sk_buff *skb)
+{
+	struct ieee80211_hw *hw = &local->hw;
+	unsigned long flags;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	int queue = info->hw_queue;
+
+	if (WARN_ON(!info->control.vif)) {
+		kfree_skb(skb);
+		return;
+	}
+
+	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
+	__mac80211_stop_queue(hw, queue, IEEE80211_QUEUE_STOP_REASON_SKB_ADD);
+	__skb_queue_tail(&local->pending[queue], skb);
+	__mac80211_wake_queue(hw, queue, IEEE80211_QUEUE_STOP_REASON_SKB_ADD);
+	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
+}
+
+void mac80211_add_pending_skbs_fn(struct ieee80211_local *local,
+				   struct sk_buff_head *skbs,
+				   void (*fn)(void *data), void *data)
+{
+	struct ieee80211_hw *hw = &local->hw;
+	struct sk_buff *skb;
+	unsigned long flags;
+	int queue, i;
+
+	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
+	while ((skb = skb_dequeue(skbs))) {
+		struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+
+		if (WARN_ON(!info->control.vif)) {
+			kfree_skb(skb);
+			continue;
+		}
+
+		queue = info->hw_queue;
+
+		__mac80211_stop_queue(hw, queue,
+				IEEE80211_QUEUE_STOP_REASON_SKB_ADD);
+
+		__skb_queue_tail(&local->pending[queue], skb);
+	}
+
+	if (fn)
+		fn(data);
+
+	for (i = 0; i < hw->queues; i++)
+		__mac80211_wake_queue(hw, i,
+			IEEE80211_QUEUE_STOP_REASON_SKB_ADD);
+	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
+}
+
+void mac80211_add_pending_skbs(struct ieee80211_local *local,
+				struct sk_buff_head *skbs)
+{
+	mac80211_add_pending_skbs_fn(local, skbs, NULL, NULL);
+}
+
+void mac80211_stop_queues_by_reason(struct ieee80211_hw *hw,
+				    enum queue_stop_reason reason)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	unsigned long flags;
+	int i;
+
+	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
+
+	for (i = 0; i < hw->queues; i++)
+		__mac80211_stop_queue(hw, i, reason);
+
+	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
+}
+
+void mac80211_stop_queues(struct ieee80211_hw *hw)
+{
+	mac80211_stop_queues_by_reason(hw,
+					IEEE80211_QUEUE_STOP_REASON_DRIVER);
+}
+
+int mac80211_queue_stopped(struct ieee80211_hw *hw, int queue)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	unsigned long flags;
+	int ret;
+
+	if (WARN_ON(queue >= hw->queues))
+		return true;
+
+	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
+	ret = !!local->queue_stop_reasons[queue];
+	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
+	return ret;
+}
+
+void mac80211_wake_queues_by_reason(struct ieee80211_hw *hw,
+				     enum queue_stop_reason reason)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	unsigned long flags;
+	int i;
+
+	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
+
+	for (i = 0; i < hw->queues; i++)
+		__mac80211_wake_queue(hw, i, reason);
+
+	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
+}
+
+void mac80211_wake_queues(struct ieee80211_hw *hw)
+{
+	mac80211_wake_queues_by_reason(hw, IEEE80211_QUEUE_STOP_REASON_DRIVER);
+}
+
+void mac80211_iterate_active_interfaces(
+	struct ieee80211_hw *hw,
+	void (*iterator)(void *data, u8 *mac,
+			 struct ieee80211_vif *vif),
+	void *data)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct ieee80211_sub_if_data *sdata;
+
+	mutex_lock(&local->iflist_mtx);
+
+	list_for_each_entry(sdata, &local->interfaces, list) {
+		switch (sdata->vif.type) {
+		case NL80211_IFTYPE_MONITOR:
+		case NL80211_IFTYPE_AP_VLAN:
+			continue;
+		default:
+			break;
+		}
+		if (ieee80211_sdata_running(sdata))
+			iterator(data, sdata->vif.addr,
+				 &sdata->vif);
+	}
+
+	mutex_unlock(&local->iflist_mtx);
+}
+
+void mac80211_iterate_active_interfaces_atomic(
+	struct ieee80211_hw *hw,
+	void (*iterator)(void *data, u8 *mac,
+			 struct ieee80211_vif *vif),
+	void *data)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct ieee80211_sub_if_data *sdata;
+
+	rcu_read_lock();
+
+	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
+		switch (sdata->vif.type) {
+		case NL80211_IFTYPE_MONITOR:
+		case NL80211_IFTYPE_AP_VLAN:
+			continue;
+		default:
+			break;
+		}
+		if (ieee80211_sdata_running(sdata))
+			iterator(data, sdata->vif.addr,
+				 &sdata->vif);
+	}
+
+	rcu_read_unlock();
+}
+
+/*
+ * Nothing should have been stuffed into the workqueue during
+ * the suspend->resume cycle. If this WARN is seen then there
+ * is a bug with either the driver suspend or something in
+ * mac80211 stuffing into the workqueue which we haven't yet
+ * cleared during mac80211's suspend cycle.
+ */
+static bool ieee80211_can_queue_work(struct ieee80211_local *local)
+{
+	if (WARN(local->suspended && !local->resuming,
+		 "queueing ieee80211 work while going to suspend\n"))
+		return false;
+
+	return true;
+}
+
+void mac80211_queue_work(struct ieee80211_hw *hw, struct work_struct *work)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+
+	if (!ieee80211_can_queue_work(local))
+		return;
+
+	queue_work(local->workqueue, work);
+}
+
+void mac80211_queue_delayed_work(struct ieee80211_hw *hw,
+				  struct delayed_work *dwork,
+				  unsigned long delay)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+
+	if (!ieee80211_can_queue_work(local))
+		return;
+
+	queue_delayed_work(local->workqueue, dwork, delay);
+}
+u32 mac802_11_parse_elems_crc(u8 *start, size_t len,
+			       struct ieee802_11_elems *elems,
+			       u64 filter, u32 crc)
+{
+	size_t left = len;
+	u8 *pos = start;
+	bool calc_crc = filter != 0;
+	DECLARE_BITMAP(seen_elems, 256);
+
+	bitmap_zero(seen_elems, 256);
+	memset(elems, 0, sizeof(*elems));
+	elems->ie_start = start;
+	elems->total_len = len;
+
+	while (left >= 2) {
+		u8 id, elen;
+		bool elem_parse_failed;
+
+		id = *pos++;
+		elen = *pos++;
+		left -= 2;
+
+		if (elen > left) {
+			elems->parse_error = true;
+			break;
+		}
+
+		switch (id) {
+		case WLAN_EID_SSID:
+		case WLAN_EID_SUPP_RATES:
+		case WLAN_EID_FH_PARAMS:
+		case WLAN_EID_DS_PARAMS:
+		case WLAN_EID_CF_PARAMS:
+		case WLAN_EID_TIM:
+		case WLAN_EID_IBSS_PARAMS:
+		case WLAN_EID_CHALLENGE:
+		case WLAN_EID_RSN:
+		case WLAN_EID_ERP_INFO:
+		case WLAN_EID_EXT_SUPP_RATES:
+		case WLAN_EID_HT_CAPABILITY:
+		case WLAN_EID_MESH_ID:
+		case WLAN_EID_MESH_CONFIG:
+		case WLAN_EID_PEER_MGMT:
+		case WLAN_EID_PREQ:
+		case WLAN_EID_PREP:
+		case WLAN_EID_PERR:
+		case WLAN_EID_RANN:
+		case WLAN_EID_CHANNEL_SWITCH:
+		case WLAN_EID_EXT_CHANSWITCH_ANN:
+		case WLAN_EID_COUNTRY:
+		case WLAN_EID_PWR_CONSTRAINT:
+		case WLAN_EID_TIMEOUT_INTERVAL:
+			if (test_bit(id, seen_elems)) {
+				elems->parse_error = true;
+				left -= elen;
+				pos += elen;
+				continue;
+			}
+			break;
+		}
+
+		if (calc_crc && id < 64 && (filter & (1ULL << id)))
+			crc = crc32_be(crc, pos - 2, elen + 2);
+
+		elem_parse_failed = false;
+
+		switch (id) {
+		case WLAN_EID_SSID:
+			elems->ssid = pos;
+			elems->ssid_len = elen;
+			break;
+		case WLAN_EID_SUPP_RATES:
+			elems->supp_rates = pos;
+			elems->supp_rates_len = elen;
+			break;
+		case WLAN_EID_FH_PARAMS:
+			elems->fh_params = pos;
+			elems->fh_params_len = elen;
+			break;
+		case WLAN_EID_DS_PARAMS:
+			elems->ds_params = pos;
+			elems->ds_params_len = elen;
+			break;
+		case WLAN_EID_CF_PARAMS:
+			elems->cf_params = pos;
+			elems->cf_params_len = elen;
+			break;
+		case WLAN_EID_TIM:
+			if (elen >= sizeof(struct ieee80211_tim_ie)) {
+				elems->tim = (void *)pos;
+				elems->tim_len = elen;
+			} else
+				elem_parse_failed = true;
+			break;
+		case WLAN_EID_IBSS_PARAMS:
+			elems->ibss_params = pos;
+			elems->ibss_params_len = elen;
+			break;
+		case WLAN_EID_CHALLENGE:
+			elems->challenge = pos;
+			elems->challenge_len = elen;
+			break;
+		case WLAN_EID_VENDOR_SPECIFIC:
+			if (elen >= 4 && pos[0] == 0x00 && pos[1] == 0x50 &&
+			    pos[2] == 0xf2) {
+				/* Microsoft OUI (00:50:F2) */
+
+				if (calc_crc)
+					crc = crc32_be(crc, pos - 2, elen + 2);
+
+				if (pos[3] == 1) {
+					/* OUI Type 1 - WPA IE */
+					elems->wpa = pos;
+					elems->wpa_len = elen;
+				} else if (elen >= 5 && pos[3] == 2) {
+					/* OUI Type 2 - WMM IE */
+					if (pos[4] == 0) {
+						elems->wmm_info = pos;
+						elems->wmm_info_len = elen;
+					} else if (pos[4] == 1) {
+						elems->wmm_param = pos;
+						elems->wmm_param_len = elen;
+					}
+				}
+			}
+			break;
+		case WLAN_EID_RSN:
+			elems->rsn = pos;
+			elems->rsn_len = elen;
+			break;
+		case WLAN_EID_ERP_INFO:
+			elems->erp_info = pos;
+			elems->erp_info_len = elen;
+			break;
+		case WLAN_EID_EXT_SUPP_RATES:
+			elems->ext_supp_rates = pos;
+			elems->ext_supp_rates_len = elen;
+			break;
+		case WLAN_EID_HT_CAPABILITY:
+			if (elen >= sizeof(struct ieee80211_ht_cap))
+				elems->ht_cap_elem = (void *)pos;
+			else
+				elem_parse_failed = true;
+			break;
+		case WLAN_EID_HT_INFORMATION:
+			if (elen >= sizeof(struct ieee80211_ht_operation))
+				elems->ht_info_elem = (void *)pos;
+			else
+				elem_parse_failed = true;
+			break;
+		case WLAN_EID_MESH_ID:
+			elems->mesh_id = pos;
+			elems->mesh_id_len = elen;
+			break;
+		case WLAN_EID_MESH_CONFIG:
+			if (elen >= sizeof(struct ieee80211_meshconf_ie))
+				elems->mesh_config = (void *)pos;
+			else
+				elem_parse_failed = true;
+			break;
+		case WLAN_EID_PEER_MGMT:
+			elems->peering = pos;
+			elems->peering_len = elen;
+			break;
+		case WLAN_EID_PREQ:
+			elems->preq = pos;
+			elems->preq_len = elen;
+			break;
+		case WLAN_EID_PREP:
+			elems->prep = pos;
+			elems->prep_len = elen;
+			break;
+		case WLAN_EID_PERR:
+			elems->perr = pos;
+			elems->perr_len = elen;
+			break;
+		case WLAN_EID_RANN:
+			if (elen >= sizeof(struct ieee80211_rann_ie))
+				elems->rann = (void *)pos;
+			else
+				elem_parse_failed = true;
+			break;
+		case WLAN_EID_CHANNEL_SWITCH:
+			elems->ch_switch_elem = pos;
+			elems->ch_switch_elem_len = elen;
+			break;
+		case WLAN_EID_QUIET:
+			if (!elems->quiet_elem) {
+				elems->quiet_elem = pos;
+				elems->quiet_elem_len = elen;
+			}
+			elems->num_of_quiet_elem++;
+			break;
+		case WLAN_EID_COUNTRY:
+			elems->country_elem = pos;
+			elems->country_elem_len = elen;
+			break;
+		case WLAN_EID_PWR_CONSTRAINT:
+			elems->pwr_constr_elem = pos;
+			elems->pwr_constr_elem_len = elen;
+			break;
+		case WLAN_EID_TIMEOUT_INTERVAL:
+			elems->timeout_int = pos;
+			elems->timeout_int_len = elen;
+			break;
+		default:
+			break;
+		}
+
+		if (elem_parse_failed)
+			elems->parse_error = true;
+		else
+			set_bit(id, seen_elems);
+
+		left -= elen;
+		pos += elen;
+	}
+
+	if (left != 0)
+		elems->parse_error = true;
+
+	return crc;
+}
+
+void mac802_11_parse_elems(u8 *start, size_t len,
+			    struct ieee802_11_elems *elems)
+{
+	mac802_11_parse_elems_crc(start, len, elems, 0, 0);
+}
+
+void mac80211_set_wmm_default(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sdata);
+	struct ieee80211_tx_queue_params qparam;
+	int ac;
+	bool use_11b;
+	int aCWmin, aCWmax;
+
+	if (!local->ops->conf_tx)
+		return;
+
+	if (local->hw.queues < IEEE80211_NUM_ACS)
+		return;
+
+	memset(&qparam, 0, sizeof(qparam));
+
+	use_11b = (chan_state->conf.channel->band == NL80211_BAND_2GHZ) &&
+		 !(sdata->flags & IEEE80211_SDATA_OPERATING_GMODE);
+
+	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
+		/* Set defaults according to 802.11-2007 Table 7-37 */
+		aCWmax = 1023;
+		if (use_11b)
+			aCWmin = 31;
+		else
+			aCWmin = 15;
+
+		switch (ac) {
+		case 3: /* AC_BK */
+			qparam.cw_max = aCWmax;
+			qparam.cw_min = aCWmin;
+			qparam.txop = 0;
+			qparam.aifs = 7;
+			break;
+		default: /* never happens but let's not leave undefined */
+		case 2: /* AC_BE */
+			qparam.cw_max = aCWmax;
+			qparam.cw_min = aCWmin;
+			qparam.txop = 0;
+			qparam.aifs = 3;
+			break;
+		case 1: /* AC_VI */
+			qparam.cw_max = aCWmin;
+			qparam.cw_min = (aCWmin + 1) / 2 - 1;
+			if (use_11b)
+				qparam.txop = 6016/32;
+			else
+				qparam.txop = 3008/32;
+			qparam.aifs = 2;
+			break;
+		case 0: /* AC_VO */
+			qparam.cw_max = (aCWmin + 1) / 2 - 1;
+			qparam.cw_min = (aCWmin + 1) / 4 - 1;
+			if (use_11b)
+				qparam.txop = 3264/32;
+			else
+				qparam.txop = 1504/32;
+			qparam.aifs = 2;
+			break;
+		}
+
+		qparam.uapsd = false;
+
+		sdata->tx_conf[ac] = qparam;
+		drv_conf_tx(local, sdata, ac, &qparam);
+	}
+
+	/* after reinitialize QoS TX queues setting to default,
+	 * disable QoS at all */
+
+	if (sdata->vif.type != NL80211_IFTYPE_MONITOR &&
+	    sdata->vif.type != NL80211_IFTYPE_P2P_DEVICE) {
+		sdata->vif.bss_conf.qos =
+			sdata->vif.type != NL80211_IFTYPE_STATION;
+		mac80211_bss_info_change_notify(sdata, BSS_CHANGED_QOS);
+	}
+}
+
+void mac80211_sta_def_wmm_params(struct ieee80211_sub_if_data *sdata,
+				  const size_t supp_rates_len,
+				  const u8 *supp_rates)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sdata);
+	int i, have_higher_than_11mbit = 0;
+
+	/* cf. IEEE 802.11 9.2.12 */
+	for (i = 0; i < supp_rates_len; i++)
+		if ((supp_rates[i] & 0x7f) * 5 > 110)
+			have_higher_than_11mbit = 1;
+
+	if (chan_state->conf.channel->band == NL80211_BAND_2GHZ &&
+	    have_higher_than_11mbit)
+		sdata->flags |= IEEE80211_SDATA_OPERATING_GMODE;
+	else
+		sdata->flags &= ~IEEE80211_SDATA_OPERATING_GMODE;
+
+	mac80211_set_wmm_default(sdata);
+}
+
+u32 mac80211_mandatory_rates(struct ieee80211_local *local,
+			      enum nl80211_band band)
+{
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_rate *bitrates;
+	u32 mandatory_rates;
+	enum ieee80211_rate_flags mandatory_flag;
+	int i;
+
+	sband = local->hw.wiphy->bands[band];
+	if (WARN_ON(!sband))
+		return 1;
+
+	if (band == NL80211_BAND_2GHZ)
+		mandatory_flag = IEEE80211_RATE_MANDATORY_B;
+	else
+		mandatory_flag = IEEE80211_RATE_MANDATORY_A;
+
+	bitrates = sband->bitrates;
+	mandatory_rates = 0;
+	for (i = 0; i < sband->n_bitrates; i++)
+		if (bitrates[i].flags & mandatory_flag)
+			mandatory_rates |= BIT(i);
+	return mandatory_rates;
+}
+
+void mac80211_send_auth(struct ieee80211_sub_if_data *sdata,
+			 u16 transaction, u16 auth_alg,
+			 u8 *extra, size_t extra_len, const u8 *bssid,
+			 const u8 *key, u8 key_len, u8 key_idx)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct sk_buff *skb;
+	struct ieee80211_mgmt *mgmt;
+	int err;
+
+/*
+	skb = dev_alloc_skb(local->hw.extra_tx_headroom +
+			    sizeof(*mgmt) + 6 + extra_len);
+*/
+	skb = dev_alloc_skb(local->hw.extra_tx_headroom + IEEE80211_WEP_IV_LEN +
+					24 + 6 + extra_len + IEEE80211_WEP_ICV_LEN);
+
+	if (!skb)
+		return;
+
+	skb_reserve(skb, local->hw.extra_tx_headroom + IEEE80211_WEP_IV_LEN);
+
+	mgmt = (struct ieee80211_mgmt *) skb_put(skb, 24 + 6);
+	memset(mgmt, 0, 24 + 6);
+	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+					  IEEE80211_STYPE_AUTH);
+	memcpy(mgmt->da, bssid, ETH_ALEN);
+	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
+	memcpy(mgmt->bssid, bssid, ETH_ALEN);
+	mgmt->u.auth.auth_alg = cpu_to_le16(auth_alg);
+	mgmt->u.auth.auth_transaction = cpu_to_le16(transaction);
+	mgmt->u.auth.status_code = cpu_to_le16(0);
+	if (extra)
+		memcpy(skb_put(skb, extra_len), extra, extra_len);
+
+	if (auth_alg == WLAN_AUTH_SHARED_KEY && transaction == 3) {
+		mgmt->frame_control |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);
+		err = mac80211_wep_encrypt(local, skb, key, key_len, key_idx);
+		WARN_ON(err);
+	}
+
+	IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
+	ieee80211_tx_skb(sdata, skb);
+}
+
+int mac80211_build_preq_ies(struct ieee80211_local *local, u8 *buffer,
+			     const u8 *ie, size_t ie_len,
+			     enum nl80211_band band, u32 rate_mask,
+			     u8 channel)
+{
+	struct ieee80211_supported_band *sband;
+	u8 *pos;
+	size_t offset = 0, noffset;
+	int supp_rates_len, i;
+	u8 rates[32];
+	int num_rates;
+	int ext_rates_len;
+
+	sband = local->hw.wiphy->bands[band];
+
+	pos = buffer;
+
+#ifdef ROAM_OFFLOAD
+	if (!sband)
+		goto out;
+#endif /*ROAM_OFFLOAD*/
+
+	num_rates = 0;
+	for (i = 0; i < sband->n_bitrates; i++) {
+		if ((BIT(i) & rate_mask) == 0)
+			continue; /* skip rate */
+		rates[num_rates++] = (u8) (sband->bitrates[i].bitrate / 5);
+	}
+
+	supp_rates_len = min_t(int, num_rates, 8);
+
+	*pos++ = WLAN_EID_SUPP_RATES;
+	*pos++ = supp_rates_len;
+	memcpy(pos, rates, supp_rates_len);
+	pos += supp_rates_len;
+
+	/* insert "request information" if in custom IEs */
+	if (ie && ie_len) {
+		static const u8 before_extrates[] = {
+			WLAN_EID_SSID,
+			WLAN_EID_SUPP_RATES,
+			WLAN_EID_REQUEST,
+		};
+		noffset = mac80211_ie_split(ie, ie_len,
+					     before_extrates,
+					     ARRAY_SIZE(before_extrates),
+					     offset);
+		memcpy(pos, ie + offset, noffset - offset);
+		pos += noffset - offset;
+		offset = noffset;
+	}
+
+	ext_rates_len = num_rates - supp_rates_len;
+	if (ext_rates_len > 0) {
+		*pos++ = WLAN_EID_EXT_SUPP_RATES;
+		*pos++ = ext_rates_len;
+		memcpy(pos, rates + supp_rates_len, ext_rates_len);
+		pos += ext_rates_len;
+	}
+
+	if (channel && sband->band == NL80211_BAND_2GHZ) {
+		*pos++ = WLAN_EID_DS_PARAMS;
+		*pos++ = 1;
+		*pos++ = channel;
+	}
+
+	/* insert custom IEs that go before HT */
+	if (ie && ie_len) {
+		static const u8 before_ht[] = {
+			WLAN_EID_SSID,
+			WLAN_EID_SUPP_RATES,
+			WLAN_EID_REQUEST,
+			WLAN_EID_EXT_SUPP_RATES,
+			WLAN_EID_DS_PARAMS,
+			WLAN_EID_SUPPORTED_REGULATORY_CLASSES,
+		};
+		noffset = mac80211_ie_split(ie, ie_len,
+					     before_ht, ARRAY_SIZE(before_ht),
+					     offset);
+		memcpy(pos, ie + offset, noffset - offset);
+		pos += noffset - offset;
+		offset = noffset;
+	}
+
+	if (sband->ht_cap.ht_supported) {
+		u16 cap = sband->ht_cap.cap;
+		__le16 tmp;
+
+		*pos++ = WLAN_EID_HT_CAPABILITY;
+		*pos++ = sizeof(struct ieee80211_ht_cap);
+		memset(pos, 0, sizeof(struct ieee80211_ht_cap));
+		tmp = cpu_to_le16(cap);
+		memcpy(pos, &tmp, sizeof(u16));
+		pos += sizeof(u16);
+		*pos++ = sband->ht_cap.ampdu_factor |
+			 (sband->ht_cap.ampdu_density <<
+				IEEE80211_HT_AMPDU_PARM_DENSITY_SHIFT);
+		memcpy(pos, &sband->ht_cap.mcs, sizeof(sband->ht_cap.mcs));
+		pos += sizeof(sband->ht_cap.mcs);
+		pos += 2 + 4 + 1; /* ext info, BF cap, antsel */
+	}
+
+	/*
+	 * If adding more here, adjust code in main.c
+	 * that calculates local->scan_ies_len.
+	 */
+
+	/* add any remaining custom IEs */
+	if (ie && ie_len) {
+		noffset = ie_len;
+		memcpy(pos, ie + offset, noffset - offset);
+		pos += noffset - offset;
+	}
+#ifdef ROAM_OFFLOAD
+out:
+#endif /*ROAM_OFFLOAD*/
+	return pos - buffer;
+}
+
+struct sk_buff *mac80211_build_probe_req(struct ieee80211_sub_if_data *sdata,
+					  u8 *dst, u32 ratemask,
+					  const u8 *ssid, size_t ssid_len,
+					  const u8 *ie, size_t ie_len,
+					  bool directed)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sdata);
+	struct sk_buff *skb;
+	struct ieee80211_mgmt *mgmt;
+	size_t buf_len;
+	u8 *buf;
+	u8 chan;
+
+	/* FIXME: come up with a proper value */
+	buf = kmalloc(200 + ie_len, GFP_KERNEL);
+	if (!buf)
+		return NULL;
+
+	/*
+	 * Do not send DS Channel parameter for directed probe requests
+	 * in order to maximize the chance that we get a response.  Some
+	 * badly-behaved APs don't respond when this parameter is included.
+	 */
+	if (directed)
+		chan = 0;
+	else
+		chan = ieee80211_frequency_to_channel(
+			chan_state->conf.channel->center_freq);
+
+	buf_len = mac80211_build_preq_ies(local, buf, ie, ie_len,
+					   chan_state->conf.channel->band,
+					   ratemask, chan);
+
+	skb = mac80211_probereq_get(&local->hw, &sdata->vif,
+				     ssid, ssid_len,
+				     buf, buf_len);
+	if (!skb)
+		goto out;
+
+	if (dst) {
+		mgmt = (struct ieee80211_mgmt *) skb->data;
+		memcpy(mgmt->da, dst, ETH_ALEN);
+		memcpy(mgmt->bssid, dst, ETH_ALEN);
+	}
+
+	IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
+
+ out:
+	kfree(buf);
+
+	return skb;
+}
+
+void mac80211_send_probe_req(struct ieee80211_sub_if_data *sdata, u8 *dst,
+			      const u8 *ssid, size_t ssid_len,
+			      const u8 *ie, size_t ie_len,
+			      u32 ratemask, bool directed, bool no_cck)
+{
+	struct sk_buff *skb;
+
+	skb = mac80211_build_probe_req(sdata, dst, ratemask, ssid, ssid_len,
+					ie, ie_len, directed);
+	if (skb) {
+		if (no_cck)
+			IEEE80211_SKB_CB(skb)->flags |=
+				IEEE80211_TX_CTL_NO_CCK_RATE;
+		ieee80211_tx_skb(sdata, skb);
+	}
+}
+
+u32 mac80211_sta_get_rates(struct ieee80211_local *local,
+			    struct ieee802_11_elems *elems,
+			    enum nl80211_band band)
+{
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_rate *bitrates;
+	size_t num_rates;
+	u32 supp_rates;
+	int i, j;
+	sband = local->hw.wiphy->bands[band];
+
+	if (WARN_ON(!sband))
+		return 1;
+
+	bitrates = sband->bitrates;
+	num_rates = sband->n_bitrates;
+	supp_rates = 0;
+	for (i = 0; i < elems->supp_rates_len +
+		     elems->ext_supp_rates_len; i++) {
+		u8 rate = 0;
+		int own_rate;
+		if (i < elems->supp_rates_len)
+			rate = elems->supp_rates[i];
+		else if (elems->ext_supp_rates)
+			rate = elems->ext_supp_rates
+				[i - elems->supp_rates_len];
+		own_rate = 5 * (rate & 0x7f);
+		for (j = 0; j < num_rates; j++)
+			if (bitrates[j].bitrate == own_rate)
+				supp_rates |= BIT(j);
+	}
+	return supp_rates;
+}
+
+void mac80211_stop_device(struct ieee80211_local *local)
+{
+	ieee80211_led_radio(local, false);
+	ieee80211_mod_tpt_led_trig(local, 0, IEEE80211_TPT_LEDTRIG_FL_RADIO);
+	flush_workqueue(local->workqueue);
+	drv_stop(local);
+}
+
+int mac80211_reconfig(struct ieee80211_local *local)
+{
+	struct ieee80211_hw *hw = &local->hw;
+	struct ieee80211_sub_if_data *sdata;
+	struct sta_info *sta;
+	int res, i;
+	bool reconfig_due_to_wowlan = false;
+	bool suspended = local->suspended;
+
+#ifdef CONFIG_PM
+	if (local->suspended)
+		local->resuming = true;
+
+	if (local->wowlan) {
+		local->wowlan = false;
+		/*
+		* When the driver is resumed, first data is dropped
+		* by MAC layer. To eliminate it, the local->suspended
+		* should be clear.
+		*/
+		local->suspended = false;
+		res = drv_resume(local);
+		if (res < 0) {
+			local->suspended = suspended;
+			local->resuming = false;
+			return res;
+		}
+		if (res == 0)
+			goto wake_up;
+		WARN_ON(res > 1);
+		/*
+		 * res is 1, which means the driver requested
+		 * to go through a regular reset on wakeup.
+		 */
+		reconfig_due_to_wowlan = true;
+	}
+#endif
+	/*
+	 * In case of hw_restart during suspend (without wowlan),
+	 * cancel restart work, as we are reconfiguring the device
+	 * anyway.
+	 * Note that restart_work is scheduled on a frozen workqueue,
+	 * so we can't deadlock in this case.
+	 */
+	if (suspended && local->in_reconfig && !reconfig_due_to_wowlan)
+		cancel_work_sync(&local->restart_work);
+
+	/* setup fragmentation threshold */
+	drv_set_frag_threshold(local, hw->wiphy->frag_threshold);
+
+	/* reset coverage class */
+	drv_set_coverage_class(local, hw->wiphy->coverage_class);
+
+	/* everything else happens only if HW was up & running */
+	if (!local->open_count)
+		goto wake_up;
+
+	/*
+	 * Upon resume hardware can sometimes be goofy due to
+	 * various platform / driver / bus issues, so restarting
+	 * the device may at times not work immediately. Propagate
+	 * the error.
+	 */
+	res = drv_start(local);
+	if (res) {
+		WARN(local->suspended, "Hardware became unavailable "
+		     "upon resume. This could be a software issue "
+		     "prior to suspend or a hardware issue.\n");
+		return res;
+	}
+
+	ieee80211_led_radio(local, true);
+	ieee80211_mod_tpt_led_trig(local,
+				   IEEE80211_TPT_LEDTRIG_FL_RADIO, 0);
+
+	/* add interfaces */
+	list_for_each_entry(sdata, &local->interfaces, list) {
+		if (sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&
+		    sdata->vif.type != NL80211_IFTYPE_MONITOR &&
+		    ieee80211_sdata_running(sdata))
+			res = drv_add_interface(local, &sdata->vif);
+	}
+
+	/* add STAs back */
+	mutex_lock(&local->sta_mtx);
+	list_for_each_entry(sta, &local->sta_list, list) {
+		if (sta->uploaded) {
+			sdata = sta->sdata;
+			if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
+				sdata = container_of(sdata->bss,
+					     struct ieee80211_sub_if_data,
+					     u.ap);
+
+			WARN_ON(drv_sta_add(local, sdata, &sta->sta));
+		}
+	}
+	mutex_unlock(&local->sta_mtx);
+
+	/* reconfigure tx conf */
+	if (hw->queues >= IEEE80211_NUM_ACS) {
+		list_for_each_entry(sdata, &local->interfaces, list) {
+			if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||
+			    sdata->vif.type == NL80211_IFTYPE_MONITOR ||
+			    !ieee80211_sdata_running(sdata))
+				continue;
+
+			for (i = 0; i < IEEE80211_NUM_ACS; i++)
+				drv_conf_tx(local, sdata, i,
+					    &sdata->tx_conf[i]);
+		}
+	}
+
+	/* reconfigure hardware */
+	mac80211_hw_config(local, ~0);
+
+	list_for_each_entry(sdata, &local->interfaces, list)
+		mac80211_configure_filter(sdata);
+
+	/* Finally also reconfigure all the BSS information */
+	list_for_each_entry(sdata, &local->interfaces, list) {
+		u32 changed;
+
+		if (!ieee80211_sdata_running(sdata))
+			continue;
+
+		/* common change flags for all interface types */
+		changed = BSS_CHANGED_ERP_CTS_PROT |
+			  BSS_CHANGED_ERP_PREAMBLE |
+			  BSS_CHANGED_ERP_SLOT |
+			  BSS_CHANGED_HT |
+			  BSS_CHANGED_BASIC_RATES |
+			  BSS_CHANGED_BEACON_INT |
+			  BSS_CHANGED_BSSID |
+			  BSS_CHANGED_CQM |
+			  BSS_CHANGED_QOS |
+			  BSS_CHANGED_PS;
+
+		switch (sdata->vif.type) {
+		case NL80211_IFTYPE_STATION:
+			changed |= BSS_CHANGED_ASSOC;
+			mutex_lock(&sdata->u.mgd.mtx);
+			mac80211_bss_info_change_notify(sdata, changed);
+			mutex_unlock(&sdata->u.mgd.mtx);
+			break;
+		case NL80211_IFTYPE_ADHOC:
+			changed |= BSS_CHANGED_IBSS;
+			/* fall through */
+		case NL80211_IFTYPE_AP:
+			changed |= BSS_CHANGED_SSID;
+			/* fall through */
+		case NL80211_IFTYPE_MESH_POINT:
+			changed |= BSS_CHANGED_BEACON |
+				   BSS_CHANGED_BEACON_ENABLED;
+			mac80211_bss_info_change_notify(sdata, changed);
+			break;
+		case NL80211_IFTYPE_WDS:
+		case NL80211_IFTYPE_NAN:
+			break;
+		case NL80211_IFTYPE_AP_VLAN:
+		case NL80211_IFTYPE_MONITOR:
+			/* ignore virtual */
+			break;
+		case NL80211_IFTYPE_P2P_DEVICE:
+			changed = BSS_CHANGED_IDLE;
+			break;
+		case NL80211_IFTYPE_OCB:
+			changed |= BSS_CHANGED_OCB;
+			mac80211_bss_info_change_notify(sdata, changed);
+			break;
+		case NL80211_IFTYPE_UNSPECIFIED:
+		case NUM_NL80211_IFTYPES:
+		case NL80211_IFTYPE_P2P_CLIENT:
+		case NL80211_IFTYPE_P2P_GO:
+			WARN_ON(1);
+			break;
+		}
+	}
+
+	/*
+	 * Clear the WLAN_STA_BLOCK_BA flag so new aggregation
+	 * sessions can be established after a resume.
+	 *
+	 * Also tear down aggregation sessions since reconfiguring
+	 * them in a hardware restart scenario is not easily done
+	 * right now, and the hardware will have lost information
+	 * about the sessions, but we and the AP still think they
+	 * are active. This is really a workaround though.
+	 */
+	if (hw->flags & IEEE80211_HW_AMPDU_AGGREGATION) {
+		mutex_lock(&local->sta_mtx);
+
+		list_for_each_entry(sta, &local->sta_list, list) {
+			mac80211_sta_tear_down_BA_sessions(sta, true);
+			clear_sta_flag(sta, WLAN_STA_BLOCK_BA);
+		}
+
+		mutex_unlock(&local->sta_mtx);
+	}
+
+	/* add back keys */
+	list_for_each_entry(sdata, &local->interfaces, list)
+		if (ieee80211_sdata_running(sdata))
+			mac80211_enable_keys(sdata);
+
+
+	/* setup RTS threshold */
+	/*
+	list_for_each_entry(sdata, &local->interfaces, list)
+	   drv_set_rts_threshold(local, sdata, sdata->wdev.rts_threshold);
+	  */
+
+ wake_up:
+	if (local->in_reconfig) {
+		local->in_reconfig = false;
+		barrier();
+	}
+
+	mac80211_wake_queues_by_reason(hw,
+			IEEE80211_QUEUE_STOP_REASON_SUSPEND);
+
+	/*
+	 * If this is for hw restart things are still running.
+	 * We may want to change that later, however.
+	 */
+	if (!local->suspended)
+		return 0;
+
+#ifdef CONFIG_PM
+	/* first set suspended false, then resuming */
+	local->suspended = false;
+	mb();
+	local->resuming = false;
+
+	list_for_each_entry(sdata, &local->interfaces, list) {
+		switch (sdata->vif.type) {
+		case NL80211_IFTYPE_STATION:
+			mac80211_sta_restart(sdata);
+			break;
+		case NL80211_IFTYPE_ADHOC:
+			mac80211_ibss_restart(sdata);
+			break;
+		case NL80211_IFTYPE_MESH_POINT:
+			mac80211_mesh_restart(sdata);
+			break;
+		default:
+			break;
+		}
+	}
+
+	mod_timer(&local->sta_cleanup, jiffies + 1);
+
+	mutex_lock(&local->sta_mtx);
+	list_for_each_entry(sta, &local->sta_list, list)
+		xrmac_mesh_plink_restart(sta);
+	mutex_unlock(&local->sta_mtx);
+#else
+	WARN_ON(1);
+#endif
+	return 0;
+}
+
+void mac80211_resume_disconnect(struct ieee80211_vif *vif)
+{
+	struct ieee80211_sub_if_data *sdata;
+	struct ieee80211_local *local;
+	struct ieee80211_key *key;
+
+	if (WARN_ON(!vif))
+		return;
+
+	sdata = vif_to_sdata(vif);
+	local = sdata->local;
+
+	if (WARN_ON(!local->resuming))
+		return;
+
+	if (WARN_ON(vif->type != NL80211_IFTYPE_STATION))
+		return;
+
+	sdata->flags |= IEEE80211_SDATA_DISCONNECT_RESUME;
+
+	mutex_lock(&local->key_mtx);
+	list_for_each_entry(key, &sdata->key_list, list)
+		key->flags |= KEY_FLAG_TAINTED;
+	mutex_unlock(&local->key_mtx);
+}
+
+static int check_mgd_smps(struct ieee80211_if_managed *ifmgd,
+			  enum ieee80211_smps_mode *smps_mode)
+{
+	if (ifmgd->associated) {
+		*smps_mode = ifmgd->ap_smps;
+
+		if (*smps_mode == IEEE80211_SMPS_AUTOMATIC) {
+			if (ifmgd->powersave)
+				*smps_mode = IEEE80211_SMPS_DYNAMIC;
+			else
+				*smps_mode = IEEE80211_SMPS_OFF;
+		}
+
+		return 1;
+	}
+
+	return 0;
+}
+
+/* must hold iflist_mtx */
+void mac80211_recalc_smps(struct ieee80211_local *local)
+{
+	struct ieee80211_sub_if_data *sdata;
+	enum ieee80211_smps_mode smps_mode = IEEE80211_SMPS_OFF;
+	int count = 0;
+
+	lockdep_assert_held(&local->iflist_mtx);
+
+	/*
+	 * This function could be improved to handle multiple
+	 * interfaces better, but right now it makes any
+	 * non-station interfaces force SM PS to be turned
+	 * off. If there are multiple station interfaces it
+	 * could also use the best possible mode, e.g. if
+	 * one is in static and the other in dynamic then
+	 * dynamic is ok.
+	 */
+
+	list_for_each_entry(sdata, &local->interfaces, list) {
+		if (!ieee80211_sdata_running(sdata))
+			continue;
+		if (sdata->vif.type == NL80211_IFTYPE_P2P_DEVICE)
+			continue;
+		if (sdata->vif.type != NL80211_IFTYPE_STATION)
+			goto set;
+
+		count += check_mgd_smps(&sdata->u.mgd, &smps_mode);
+
+		if (count > 1) {
+			smps_mode = IEEE80211_SMPS_OFF;
+			break;
+		}
+	}
+
+	if (smps_mode == local->smps_mode)
+		return;
+
+ set:
+	local->smps_mode = smps_mode;
+	/* changed flag is auto-detected for this */
+	mac80211_hw_config(local, 0);
+}
+
+static bool ieee80211_id_in_list(const u8 *ids, int n_ids, u8 id)
+{
+	int i;
+
+	for (i = 0; i < n_ids; i++)
+		if (ids[i] == id)
+			return true;
+	return false;
+}
+
+/**
+ * mac80211_ie_split - split an IE buffer according to ordering
+ *
+ * @ies: the IE buffer
+ * @ielen: the length of the IE buffer
+ * @ids: an array with element IDs that are allowed before
+ *	the split
+ * @n_ids: the size of the element ID array
+ * @offset: offset where to start splitting in the buffer
+ *
+ * This function splits an IE buffer by updating the @offset
+ * variable to point to the location where the buffer should be
+ * split.
+ *
+ * It assumes that the given IE buffer is well-formed, this
+ * has to be guaranteed by the caller!
+ *
+ * It also assumes that the IEs in the buffer are ordered
+ * correctly, if not the result of using this function will not
+ * be ordered correctly either, i.e. it does no reordering.
+ *
+ * The function returns the offset where the next part of the
+ * buffer starts, which may be @ielen if the entire (remainder)
+ * of the buffer should be used.
+ */
+size_t mac80211_ie_split(const u8 *ies, size_t ielen,
+			  const u8 *ids, int n_ids, size_t offset)
+{
+	size_t pos = offset;
+
+	while (pos < ielen && ieee80211_id_in_list(ids, n_ids, ies[pos]))
+		pos += 2 + ies[pos + 1];
+
+	return pos;
+}
+
+size_t mac80211_ie_split_vendor(const u8 *ies, size_t ielen, size_t offset)
+{
+	size_t pos = offset;
+
+	while (pos < ielen && ies[pos] != WLAN_EID_VENDOR_SPECIFIC)
+		pos += 2 + ies[pos + 1];
+
+	return pos;
+}
+
+static void _mac80211_enable_rssi_reports(struct ieee80211_sub_if_data *sdata,
+					    int rssi_min_thold,
+					    int rssi_max_thold)
+{
+	trace_api_enable_rssi_reports(sdata, rssi_min_thold, rssi_max_thold);
+
+	if (WARN_ON(sdata->vif.type != NL80211_IFTYPE_STATION))
+		return;
+
+	/*
+	 * Scale up threshold values before storing it, as the RSSI averaging
+	 * algorithm uses a scaled up value as well. Change this scaling
+	 * factor if the RSSI averaging algorithm changes.
+	 */
+	sdata->u.mgd.rssi_min_thold = rssi_min_thold*16;
+	sdata->u.mgd.rssi_max_thold = rssi_max_thold*16;
+}
+
+void mac80211_enable_rssi_reports(struct ieee80211_vif *vif,
+				    int rssi_min_thold,
+				    int rssi_max_thold)
+{
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+
+	WARN_ON(rssi_min_thold == rssi_max_thold ||
+		rssi_min_thold > rssi_max_thold);
+
+	_mac80211_enable_rssi_reports(sdata, rssi_min_thold,
+				       rssi_max_thold);
+}
+
+void mac80211_disable_rssi_reports(struct ieee80211_vif *vif)
+{
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+
+	_mac80211_enable_rssi_reports(sdata, 0, 0);
+}
+
+int mac80211_add_srates_ie(struct ieee80211_vif *vif, struct sk_buff *skb)
+{
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sdata);
+	struct ieee80211_supported_band *sband;
+	int rate;
+	u8 i, rates, *pos;
+
+	sband = local->hw.wiphy->bands[chan_state->conf.channel->band];
+	rates = sband->n_bitrates;
+	if (rates > 8)
+		rates = 8;
+
+	if (skb_tailroom(skb) < rates + 2)
+		return -ENOMEM;
+
+	pos = skb_put(skb, rates + 2);
+	*pos++ = WLAN_EID_SUPP_RATES;
+	*pos++ = rates;
+	for (i = 0; i < rates; i++) {
+		rate = sband->bitrates[i].bitrate;
+		*pos++ = (u8) (rate / 5);
+	}
+
+	return 0;
+}
+
+int mac80211_add_ext_srates_ie(struct ieee80211_vif *vif, struct sk_buff *skb)
+{
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_channel_state *chan_state = ieee80211_get_channel_state(local, sdata);
+	struct ieee80211_supported_band *sband;
+	int rate;
+	u8 i, exrates, *pos;
+
+	sband = local->hw.wiphy->bands[chan_state->conf.channel->band];
+	exrates = sband->n_bitrates;
+	if (exrates > 8)
+		exrates -= 8;
+	else
+		exrates = 0;
+
+	if (skb_tailroom(skb) < exrates + 2)
+		return -ENOMEM;
+
+	if (exrates) {
+		pos = skb_put(skb, exrates + 2);
+		*pos++ = WLAN_EID_EXT_SUPP_RATES;
+		*pos++ = exrates;
+		for (i = 8; i < sband->n_bitrates; i++) {
+			rate = sband->bitrates[i].bitrate;
+			*pos++ = (u8) (rate / 5);
+		}
+	}
+	return 0;
+}
+
+bool ieee80211_cs_valid(const struct ieee80211_cipher_scheme *cs)
+{
+	return !(cs == NULL || cs->cipher == 0 ||
+		 cs->hdr_len < cs->pn_len + cs->pn_off ||
+		 cs->hdr_len <= cs->key_idx_off ||
+		 cs->key_idx_shift > 7 ||
+		 cs->key_idx_mask == 0);
+}
+
+bool ieee80211_cs_list_valid(const struct ieee80211_cipher_scheme *cs, int n)
+{
+	int i;
+
+	/* Ensure we have enough iftype bitmap space for all iftype values */
+	WARN_ON((NUM_NL80211_IFTYPES / 8 + 1) > sizeof(cs[0].iftype));
+
+	for (i = 0; i < n; i++)
+		if (!ieee80211_cs_valid(&cs[i]))
+			return false;
+
+	return true;
+}
+
+const struct ieee80211_cipher_scheme *
+ieee80211_cs_get(struct ieee80211_local *local, u32 cipher,
+		 enum nl80211_iftype iftype)
+{
+	const struct ieee80211_cipher_scheme *l = local->hw.cipher_schemes;
+	int n = local->hw.n_cipher_schemes;
+	int i;
+	const struct ieee80211_cipher_scheme *cs = NULL;
+
+	for (i = 0; i < n; i++) {
+		if (l[i].cipher == cipher) {
+			cs = &l[i];
+			break;
+		}
+	}
+
+	if (!cs || !(cs->iftype & BIT(iftype)))
+		return NULL;
+
+	return cs;
+}
+
+int ieee80211_cs_headroom(struct ieee80211_local *local,
+			  struct cfg80211_crypto_settings *crypto,
+			  enum nl80211_iftype iftype)
+{
+	const struct ieee80211_cipher_scheme *cs;
+	int headroom = IEEE80211_ENCRYPT_HEADROOM;
+	int i;
+
+	for (i = 0; i < crypto->n_ciphers_pairwise; i++) {
+		cs = ieee80211_cs_get(local, crypto->ciphers_pairwise[i],
+				      iftype);
+
+		if (cs && headroom < cs->hdr_len)
+			headroom = cs->hdr_len;
+	}
+
+	cs = ieee80211_cs_get(local, crypto->cipher_group, iftype);
+	if (cs && headroom < cs->hdr_len)
+		headroom = cs->hdr_len;
+
+	return headroom;
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/wapi.c b/drivers/net/wireless/xr829/umac/wapi.c
--- a/drivers/net/wireless/xr829/umac/wapi.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/wapi.c	2022-08-27 01:22:42.958539877 +0300
@@ -0,0 +1,71 @@
+/*
+ * Software WAPI encryption implementation
+ * Copyright (c) 2011, XRadioTech
+ * Author: Janusz Dziedzic <janusz.dziedzic@tieto.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/netdevice.h>
+#include <linux/types.h>
+#include <linux/random.h>
+#include <linux/compiler.h>
+#include <linux/crc32.h>
+#include <linux/crypto.h>
+#include <linux/err.h>
+#include <linux/mm.h>
+#include <linux/scatterlist.h>
+#include <linux/slab.h>
+#include <asm/unaligned.h>
+
+#include <net/mac80211.h>
+#include "ieee80211_i.h"
+#include "wapi.h"
+
+
+static int ieee80211_wapi_decrypt(struct ieee80211_local *local,
+				  struct sk_buff *skb,
+				  struct ieee80211_key *key)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+	int hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
+	int data_len;
+
+	if (!(status->flag & RX_FLAG_DECRYPTED)) {
+		/* TODO - SMS4 decryption for firmware without
+		 * SMS4 support */
+		return RX_DROP_UNUSABLE;
+	}
+
+
+	data_len = skb->len - hdrlen - WAPI_IV_LEN - WAPI_ICV_LEN;
+	if (data_len < 0)
+		return RX_DROP_UNUSABLE;
+
+	/* Trim ICV */
+	skb_trim(skb, skb->len - WAPI_ICV_LEN);
+
+	/* Remove IV */
+	memmove(skb->data + WAPI_IV_LEN, skb->data, hdrlen);
+	skb_pull(skb, WAPI_IV_LEN);
+
+	return RX_CONTINUE;
+}
+
+ieee80211_rx_result
+ieee80211_crypto_wapi_decrypt(struct ieee80211_rx_data *rx)
+{
+	struct sk_buff *skb = rx->skb;
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+
+	if (!ieee80211_is_data(hdr->frame_control))
+		return RX_CONTINUE;
+
+	if (ieee80211_wapi_decrypt(rx->local, rx->skb, rx->key))
+		return RX_DROP_UNUSABLE;
+
+	return RX_CONTINUE;
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/wapi.h b/drivers/net/wireless/xr829/umac/wapi.h
--- a/drivers/net/wireless/xr829/umac/wapi.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/wapi.h	2022-08-27 01:22:42.958539877 +0300
@@ -0,0 +1,27 @@
+/*
+ * Software WAPI encryption implementation
+ * Copyright (c) 2011, XRadioTech
+ * Author: Janusz Dziedzic <janusz.dziedzic@tieto.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef WAPI_H
+#define WAPI_H
+
+#include <linux/skbuff.h>
+#include <linux/types.h>
+#include "ieee80211_i.h"
+#include "key.h"
+
+#ifndef ETH_P_WAPI
+#define ETH_P_WAPI     0x88B4
+#endif
+
+
+ieee80211_rx_result
+ieee80211_crypto_wapi_decrypt(struct ieee80211_rx_data *rx);
+
+#endif /* WAPI_H */
diff -Naurp a/drivers/net/wireless/xr829/umac/wep.c b/drivers/net/wireless/xr829/umac/wep.c
--- a/drivers/net/wireless/xr829/umac/wep.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/wep.c	2022-08-27 01:22:42.958539877 +0300
@@ -0,0 +1,327 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Software WEP encryption implementation
+ * Copyright 2002, Jouni Malinen <jkmaline@cc.hut.fi>
+ * Copyright 2003, Instant802 Networks, Inc.
+ */
+
+#include <linux/netdevice.h>
+#include <linux/types.h>
+#include <linux/random.h>
+#include <linux/compiler.h>
+#include <linux/crc32.h>
+#include <linux/crypto.h>
+#include <linux/err.h>
+#include <linux/mm.h>
+#include <linux/scatterlist.h>
+#include <linux/slab.h>
+#include <asm/unaligned.h>
+
+#include <net/mac80211.h>
+#include "ieee80211_i.h"
+#include "wep.h"
+
+
+int mac80211_wep_init(struct ieee80211_local *local)
+{
+	/* start WEP IV from a random value */
+	get_random_bytes(&local->wep_iv, IEEE80211_WEP_IV_LEN);
+
+	return 0;
+}
+
+static inline bool ieee80211_wep_weak_iv(u32 iv, int keylen)
+{
+	/*
+	 * Fluhrer, Mantin, and Shamir have reported weaknesses in the
+	 * key scheduling algorithm of RC4. At least IVs (KeyByte + 3,
+	 * 0xff, N) can be used to speedup attacks, so avoid using them.
+	 */
+	if ((iv & 0xff00) == 0xff00) {
+		u8 B = (iv >> 16) & 0xff;
+		if (B >= 3 && B < 3 + keylen)
+			return true;
+	}
+	return false;
+}
+
+
+static void ieee80211_wep_get_iv(struct ieee80211_local *local,
+				 int keylen, int keyidx, u8 *iv)
+{
+	local->wep_iv++;
+	if (ieee80211_wep_weak_iv(local->wep_iv, keylen))
+		local->wep_iv += 0x0100;
+
+	if (!iv)
+		return;
+
+	*iv++ = (local->wep_iv >> 16) & 0xff;
+	*iv++ = (local->wep_iv >> 8) & 0xff;
+	*iv++ = local->wep_iv & 0xff;
+	*iv++ = keyidx << 6;
+}
+
+
+static u8 *ieee80211_wep_add_iv(struct ieee80211_local *local,
+				struct sk_buff *skb,
+				int keylen, int keyidx)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	unsigned int hdrlen;
+	u8 *newhdr;
+
+	hdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);
+
+	if (WARN_ON(skb_headroom(skb) < IEEE80211_WEP_IV_LEN))
+		return NULL;
+
+	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	newhdr = skb_push(skb, IEEE80211_WEP_IV_LEN);
+	memmove(newhdr, newhdr + IEEE80211_WEP_IV_LEN, hdrlen);
+
+	/* the HW only needs room for the IV, but not the actual IV */
+	if (info->control.hw_key &&
+	    (info->control.hw_key->flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE))
+		return newhdr + hdrlen;
+
+	ieee80211_wep_get_iv(local, keylen, keyidx, newhdr + hdrlen);
+	return newhdr + hdrlen;
+}
+
+
+static void ieee80211_wep_remove_iv(struct ieee80211_local *local,
+				    struct sk_buff *skb,
+				    struct ieee80211_key *key)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+	unsigned int hdrlen;
+
+	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	memmove(skb->data + IEEE80211_WEP_IV_LEN, skb->data, hdrlen);
+	skb_pull(skb, IEEE80211_WEP_IV_LEN);
+}
+
+
+/* Perform WEP encryption using given key. data buffer must have tailroom
+ * for 4-byte ICV. data_len must not include this ICV. Note: this function
+ * does _not_ add IV. data = RC4(data | CRC32(data)) */
+int mac80211_wep_encrypt_data(struct arc4_ctx *ctx, u8 *rc4key,
+			       size_t klen, u8 *data, size_t data_len)
+{
+	__le32 icv;
+
+	icv = cpu_to_le32(~crc32_le(~0, data, data_len));
+	put_unaligned(icv, (__le32 *)(data + data_len));
+
+	arc4_setkey(ctx, rc4key, klen);
+	arc4_crypt(ctx, data, data, data_len + IEEE80211_WEP_ICV_LEN);
+	memzero_explicit(ctx, sizeof(*ctx));
+
+	return 0;
+}
+
+
+/* Perform WEP encryption on given skb. 4 bytes of extra space (IV) in the
+ * beginning of the buffer 4 bytes of extra space (ICV) in the end of the
+ * buffer will be added. Both IV and ICV will be transmitted, so the
+ * payload length increases with 8 bytes.
+ *
+ * WEP frame payload: IV + TX key idx, RC4(data), ICV = RC4(CRC32(data))
+ */
+int mac80211_wep_encrypt(struct ieee80211_local *local,
+			  struct sk_buff *skb,
+			  const u8 *key, int keylen, int keyidx)
+{
+	u8 *iv;
+	size_t len;
+	u8 rc4key[3 + WLAN_KEY_LEN_WEP104];
+
+	if (WARN_ON(skb_tailroom(skb) < IEEE80211_WEP_ICV_LEN))
+		return -1;
+
+	iv = ieee80211_wep_add_iv(local, skb, keylen, keyidx);
+	if (!iv)
+		return -1;
+
+	len = skb->len - (iv + IEEE80211_WEP_IV_LEN - skb->data);
+
+	/* Prepend 24-bit IV to RC4 key */
+	memcpy(rc4key, iv, 3);
+
+	/* Copy rest of the WEP key (the secret part) */
+	memcpy(rc4key + 3, key, keylen);
+
+	/* Add room for ICV */
+	skb_put(skb, IEEE80211_WEP_ICV_LEN);
+
+	return mac80211_wep_encrypt_data(&local->wep_tx_ctx, rc4key, keylen + 3,
+					  iv + IEEE80211_WEP_IV_LEN, len);
+}
+
+
+/* Perform WEP decryption using given key. data buffer includes encrypted
+ * payload, including 4-byte ICV, but _not_ IV. data_len must not include ICV.
+ * Return 0 on success and -1 on ICV mismatch. */
+int mac80211_wep_decrypt_data(struct arc4_ctx *ctx, u8 *rc4key,
+			       size_t klen, u8 *data, size_t data_len)
+{
+	__le32 crc;
+
+	arc4_setkey(ctx, rc4key, klen);
+	arc4_crypt(ctx, data, data, data_len + IEEE80211_WEP_ICV_LEN);
+	memzero_explicit(ctx, sizeof(*ctx));
+
+	crc = cpu_to_le32(~crc32_le(~0, data, data_len));
+	if (memcmp(&crc, data + data_len, IEEE80211_WEP_ICV_LEN) != 0)
+		/* ICV mismatch */
+		return -1;
+
+	return 0;
+}
+
+
+/* Perform WEP decryption on given skb. Buffer includes whole WEP part of
+ * the frame: IV (4 bytes), encrypted payload (including SNAP header),
+ * ICV (4 bytes). skb->len includes both IV and ICV.
+ *
+ * Returns 0 if frame was decrypted successfully and ICV was correct and -1 on
+ * failure. If frame is OK, IV and ICV will be removed, i.e., decrypted payload
+ * is moved to the beginning of the skb and skb length will be reduced.
+ */
+static int ieee80211_wep_decrypt(struct ieee80211_local *local,
+				 struct sk_buff *skb,
+				 struct ieee80211_key *key)
+{
+	u32 klen;
+	u8 rc4key[3 + WLAN_KEY_LEN_WEP104];
+	u8 keyidx;
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+	unsigned int hdrlen;
+	size_t len;
+	int ret = 0;
+
+	if (!ieee80211_has_protected(hdr->frame_control))
+		return -1;
+
+	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	if (skb->len < hdrlen + IEEE80211_WEP_IV_LEN + IEEE80211_WEP_ICV_LEN)
+		return -1;
+
+	len = skb->len - hdrlen - IEEE80211_WEP_IV_LEN - IEEE80211_WEP_ICV_LEN;
+
+	keyidx = skb->data[hdrlen + 3] >> 6;
+
+	if (!key || keyidx != key->conf.keyidx)
+		return -1;
+
+	klen = 3 + key->conf.keylen;
+
+	/* Prepend 24-bit IV to RC4 key */
+	memcpy(rc4key, skb->data + hdrlen, 3);
+
+	/* Copy rest of the WEP key (the secret part) */
+	memcpy(rc4key + 3, key->conf.key, key->conf.keylen);
+
+	if (mac80211_wep_decrypt_data(&local->wep_rx_ctx, rc4key, klen,
+				       skb->data + hdrlen +
+				       IEEE80211_WEP_IV_LEN, len))
+		ret = -1;
+
+	/* Trim ICV */
+	skb_trim(skb, skb->len - IEEE80211_WEP_ICV_LEN);
+
+	/* Remove IV */
+	memmove(skb->data + IEEE80211_WEP_IV_LEN, skb->data, hdrlen);
+	skb_pull(skb, IEEE80211_WEP_IV_LEN);
+
+	return ret;
+}
+
+bool ieee80211_wep_is_weak_iv(struct sk_buff *skb,
+			      struct ieee80211_key *key)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+	unsigned int hdrlen;
+	u8 *ivpos;
+	u32 iv;
+
+	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	ivpos = skb->data + hdrlen;
+	iv = (ivpos[0] << 16) | (ivpos[1] << 8) | ivpos[2];
+
+	return ieee80211_wep_weak_iv(iv, key->conf.keylen);
+}
+
+ieee80211_rx_result
+mac80211_crypto_wep_decrypt(struct ieee80211_rx_data *rx)
+{
+	struct sk_buff *skb = rx->skb;
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+	__le16 fc = hdr->frame_control;
+
+	if (!ieee80211_is_data(fc) && !ieee80211_is_auth(fc))
+		return RX_CONTINUE;
+
+	if (!(status->flag & RX_FLAG_DECRYPTED)) {
+		if (skb_linearize(rx->skb))
+			return RX_DROP_UNUSABLE;
+		if (ieee80211_wep_decrypt(rx->local, rx->skb, rx->key))
+			return RX_DROP_UNUSABLE;
+	} else if (!(status->flag & RX_FLAG_IV_STRIPPED)) {
+		if (!pskb_may_pull(rx->skb, ieee80211_hdrlen(fc) +
+					    IEEE80211_WEP_IV_LEN))
+			return RX_DROP_UNUSABLE;
+		ieee80211_wep_remove_iv(rx->local, rx->skb, rx->key);
+		/* remove ICV */
+		/* NOTE: !(status->flag & RX_FLAG_ICV_STRIPPED) maybe used for
+		 * controlompatibility with other versions of umac.
+		 */
+		if (pskb_trim(rx->skb, rx->skb->len - IEEE80211_WEP_ICV_LEN))
+			return RX_DROP_UNUSABLE;
+	}
+
+	return RX_CONTINUE;
+}
+
+static int wep_encrypt_skb(struct ieee80211_tx_data *tx, struct sk_buff *skb)
+{
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	struct ieee80211_key_conf *hw_key = info->control.hw_key;
+
+	if (!hw_key) {
+		if (mac80211_wep_encrypt(tx->local, skb, tx->key->conf.key,
+					  tx->key->conf.keylen,
+					  tx->key->conf.keyidx))
+			return -1;
+	} else if ((hw_key->flags & IEEE80211_KEY_FLAG_GENERATE_IV) ||
+		   (hw_key->flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE)) {
+		if (!ieee80211_wep_add_iv(tx->local, skb,
+					  tx->key->conf.keylen,
+					  tx->key->conf.keyidx))
+			return -1;
+	}
+
+	return 0;
+}
+
+ieee80211_tx_result
+mac80211_crypto_wep_encrypt(struct ieee80211_tx_data *tx)
+{
+	struct sk_buff *skb;
+
+	mac80211_tx_set_protected(tx);
+
+	skb = tx->skb;
+	do {
+		if (wep_encrypt_skb(tx, skb) < 0) {
+			I802_DEBUG_INC(tx->local->tx_handlers_drop_wep);
+			return TX_DROP;
+		}
+	} while ((skb = skb->next));
+
+
+	return TX_CONTINUE;
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/wep.h b/drivers/net/wireless/xr829/umac/wep.h
--- a/drivers/net/wireless/xr829/umac/wep.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/wep.h	2022-08-27 01:22:42.958539877 +0300
@@ -0,0 +1,35 @@
+/*
+ * Software WEP encryption implementation
+ * Copyright 2002, Jouni Malinen <jkmaline@cc.hut.fi>
+ * Copyright 2003, Instant802 Networks, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef WEP_H
+#define WEP_H
+
+#include <linux/skbuff.h>
+#include <linux/types.h>
+#include "ieee80211_i.h"
+#include "key.h"
+
+int mac80211_wep_init(struct ieee80211_local *local);
+//void mac80211_wep_free(struct ieee80211_local *local);
+int mac80211_wep_encrypt_data(struct arc4_ctx *ctx, u8 *rc4key,
+				size_t klen, u8 *data, size_t data_len);
+int mac80211_wep_encrypt(struct ieee80211_local *local,
+			  struct sk_buff *skb,
+			  const u8 *key, int keylen, int keyidx);
+int mac80211_wep_decrypt_data(struct arc4_ctx *ctx, u8 *rc4key,
+			       size_t klen, u8 *data, size_t data_len);
+bool ieee80211_wep_is_weak_iv(struct sk_buff *skb, struct ieee80211_key *key);
+
+ieee80211_rx_result
+mac80211_crypto_wep_decrypt(struct ieee80211_rx_data *rx);
+ieee80211_tx_result
+mac80211_crypto_wep_encrypt(struct ieee80211_tx_data *tx);
+
+#endif /* WEP_H */
diff -Naurp a/drivers/net/wireless/xr829/umac/wme.c b/drivers/net/wireless/xr829/umac/wme.c
--- a/drivers/net/wireless/xr829/umac/wme.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/wme.c	2022-08-27 01:22:42.958539877 +0300
@@ -0,0 +1,166 @@
+/*
+ * Copyright 2004, Instant802 Networks, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/module.h>
+#include <linux/if_arp.h>
+#include <linux/types.h>
+#include <net/ip.h>
+#include <net/pkt_sched.h>
+
+#include <net/mac80211.h>
+#include "ieee80211_i.h"
+#include "wme.h"
+
+/* Default mapping in classifier to work with default
+ * queue setup.
+ */
+const int mac802_1d_to_ac[8] = {
+	IEEE80211_AC_BE,
+	IEEE80211_AC_BK,
+	IEEE80211_AC_BK,
+	IEEE80211_AC_BE,
+	IEEE80211_AC_VI,
+	IEEE80211_AC_VI,
+	IEEE80211_AC_VO,
+	IEEE80211_AC_VO
+};
+
+static int wme_downgrade_ac(struct sk_buff *skb)
+{
+	switch (skb->priority) {
+	case 6:
+	case 7:
+		skb->priority = 5; /* VO -> VI */
+		return 0;
+	case 4:
+	case 5:
+		skb->priority = 3; /* VI -> BE */
+		return 0;
+	case 0:
+	case 3:
+		skb->priority = 2; /* BE -> BK */
+		return 0;
+	default:
+		return -1;
+	}
+}
+
+
+/* Indicate which queue to use. */
+u16 mac80211_select_queue(struct ieee80211_sub_if_data *sdata,
+			   struct sk_buff *skb)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct sta_info *sta = NULL;
+	const u8 *ra = NULL;
+	bool qos = false;
+
+	if (local->hw.queues < IEEE80211_NUM_ACS || skb->len < 6) {
+		skb->priority = 0; /* required for correct WPA/11i MIC */
+		return 0;
+	}
+
+	rcu_read_lock();
+	switch (sdata->vif.type) {
+	case NL80211_IFTYPE_AP_VLAN:
+		sta = rcu_dereference(sdata->u.vlan.sta);
+		if (sta) {
+			qos = test_sta_flag(sta, WLAN_STA_WME);
+			break;
+		}
+	case NL80211_IFTYPE_AP:
+		ra = skb->data;
+		break;
+	case NL80211_IFTYPE_WDS:
+		ra = sdata->u.wds.remote_addr;
+		break;
+#ifdef CONFIG_XRMAC_MESH
+	case NL80211_IFTYPE_MESH_POINT:
+		ra = skb->data;
+		break;
+#endif
+	case NL80211_IFTYPE_STATION:
+		ra = sdata->u.mgd.bssid;
+		break;
+	case NL80211_IFTYPE_ADHOC:
+		ra = skb->data;
+		break;
+	default:
+		break;
+	}
+
+	if (!sta && ra && !is_multicast_ether_addr(ra)) {
+		sta = xrmac_sta_info_get(sdata, ra);
+		if (sta)
+			qos = test_sta_flag(sta, WLAN_STA_WME);
+	}
+	rcu_read_unlock();
+
+	if (!qos) {
+		skb->priority = 0; /* required for correct WPA/11i MIC */
+		return IEEE80211_AC_BE;
+	}
+
+	/* use the data classifier to determine what 802.1d tag the
+	 * data frame has */
+	skb->priority = cfg80211_classify8021d(skb, NULL);
+
+	return mac80211_downgrade_queue(local, skb);
+}
+
+u16 mac80211_downgrade_queue(struct ieee80211_local *local,
+			      struct sk_buff *skb)
+{
+	/* in case we are a client verify acm is not set for this ac */
+#ifdef CONFIG_XRADIO_TESTMODE
+	/*And if acm is set check whether the ac has been admitted */
+	while (unlikely((local->wmm_acm & BIT(skb->priority)) &&
+		!(local->wmm_admitted_ups & BIT(skb->priority)))) {
+#else
+	while (unlikely(local->wmm_acm & BIT(skb->priority))) {
+#endif /*CONFIG_XRADIO_TESTMODE*/
+		if (wme_downgrade_ac(skb)) {
+			/*
+			 * This should not really happen. The AP has marked all
+			 * lower ACs to require admission control which is not
+			 * a reasonable configuration. Allow the frame to be
+			 * transmitted using AC_BK as a workaround.
+			 */
+			break;
+		}
+	}
+
+	/* look up which queue to use for frames with this 1d tag */
+	return mac802_1d_to_ac[skb->priority];
+}
+
+void mac80211_set_qos_hdr(struct ieee80211_sub_if_data *sdata,
+			   struct sk_buff *skb)
+{
+	struct ieee80211_hdr *hdr = (void *)skb->data;
+
+	/* Fill in the QoS header if there is one. */
+	if (ieee80211_is_data_qos(hdr->frame_control)) {
+		u8 *p = ieee80211_get_qos_ctl(hdr);
+		u8 ack_policy, tid;
+
+		tid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;
+
+		/* preserve EOSP bit */
+		ack_policy = *p & IEEE80211_QOS_CTL_EOSP;
+
+		if (unlikely(sdata->local->wifi_wme_noack_test))
+			ack_policy |= IEEE80211_QOS_CTL_ACK_POLICY_NOACK;
+		/* qos header is 2 bytes */
+		*p++ = ack_policy | tid;
+		*p = ieee80211_vif_is_mesh(&sdata->vif) ?
+			(IEEE80211_QOS_CTL_MESH_CONTROL_PRESENT >> 8) : 0;
+	}
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/wme.h b/drivers/net/wireless/xr829/umac/wme.h
--- a/drivers/net/wireless/xr829/umac/wme.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/wme.h	2022-08-27 01:22:42.958539877 +0300
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2004, Instant802 Networks, Inc.
+ * Copyright 2005, Devicescape Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _WME_H
+#define _WME_H
+
+#include <linux/netdevice.h>
+#include "ieee80211_i.h"
+
+extern const int mac802_1d_to_ac[8];
+
+u16 mac80211_select_queue(struct ieee80211_sub_if_data *sdata,
+			   struct sk_buff *skb);
+void mac80211_set_qos_hdr(struct ieee80211_sub_if_data *sdata,
+			   struct sk_buff *skb);
+u16 mac80211_downgrade_queue(struct ieee80211_local *local,
+				struct sk_buff *skb);
+
+
+#endif /* _WME_H */
diff -Naurp a/drivers/net/wireless/xr829/umac/work.c b/drivers/net/wireless/xr829/umac/work.c
--- a/drivers/net/wireless/xr829/umac/work.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/work.c	2022-08-27 01:22:42.962539893 +0300
@@ -0,0 +1,1345 @@
+/*
+ * mac80211 work implementation
+ *
+ * Copyright 2003-2008, Jouni Malinen <j@w1.fi>
+ * Copyright 2004, Instant802 Networks, Inc.
+ * Copyright 2005, Devicescape Software, Inc.
+ * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
+ * Copyright 2007, Michael Wu <flamingice@sourmilk.net>
+ * Copyright 2009, Johannes Berg <johannes@sipsolutions.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/if_ether.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/etherdevice.h>
+#include <linux/crc32.h>
+#include <linux/slab.h>
+#include <net/mac80211.h>
+#include <asm/unaligned.h>
+
+#include "ieee80211_i.h"
+#include "rate.h"
+#include "driver-ops.h"
+
+#define IEEE80211_AUTH_TIMEOUT (HZ / 2)
+#define IEEE80211_AUTH_MAX_TRIES 3
+#define IEEE80211_ASSOC_TIMEOUT (HZ / 2)
+#define IEEE80211_ASSOC_MAX_TRIES 3
+
+enum work_action {
+	WORK_ACT_MISMATCH,
+	WORK_ACT_NONE,
+	WORK_ACT_TIMEOUT,
+	WORK_ACT_DONE,
+};
+
+
+/* utils */
+static inline void ASSERT_WORK_MTX(struct ieee80211_local *local)
+{
+	lockdep_assert_held(&local->mtx);
+}
+
+/*
+ * We can have multiple work items (and connection probing)
+ * scheduling this timer, but we need to take care to only
+ * reschedule it when it should fire _earlier_ than it was
+ * asked for before, or if it's not pending right now. This
+ * function ensures that. Note that it then is required to
+ * run this function for all timeouts after the first one
+ * has happened -- the work that runs from this timer will
+ * do that.
+ */
+static void run_again(struct ieee80211_local *local,
+		      unsigned long timeout)
+{
+	ASSERT_WORK_MTX(local);
+
+	if (!timer_pending(&local->work_timer) ||
+	    time_before(timeout, local->work_timer.expires))
+		mod_timer(&local->work_timer, timeout);
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 40))
+void xrmac_free_work(struct ieee80211_work *wk)
+{
+	kfree_rcu(wk, rcu_head);
+}
+#else
+static void work_free_rcu(struct rcu_head *head)
+{
+	struct ieee80211_work *wk =
+		container_of(head, struct ieee80211_work, rcu_head);
+
+	kfree(wk);
+}
+
+void xrmac_free_work(struct ieee80211_work *wk)
+{
+	call_rcu(&wk->rcu_head, work_free_rcu);
+}
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 40)) */
+
+static int ieee80211_compatible_rates(const u8 *supp_rates, int supp_rates_len,
+				      struct ieee80211_supported_band *sband,
+				      u32 *rates)
+{
+	int i, j, count;
+	*rates = 0;
+	count = 0;
+	for (i = 0; i < supp_rates_len; i++) {
+		int rate = (supp_rates[i] & 0x7F) * 5;
+
+		for (j = 0; j < sband->n_bitrates; j++)
+			if (sband->bitrates[j].bitrate == rate) {
+				*rates |= BIT(j);
+				count++;
+				break;
+			}
+	}
+
+	return count;
+}
+
+/* frame sending functions */
+
+static void ieee80211_add_ht_ie(struct sk_buff *skb, const u8 *ht_info_ie,
+				struct ieee80211_supported_band *sband,
+				struct ieee80211_channel *channel,
+				enum ieee80211_smps_mode smps)
+{
+	struct ieee80211_ht_operation *ht_info;
+	u8 *pos;
+	u32 flags = channel->flags;
+	u16 cap = sband->ht_cap.cap;
+	__le16 tmp;
+
+	if (!sband->ht_cap.ht_supported)
+		return;
+
+	if (!ht_info_ie)
+		return;
+
+	if (ht_info_ie[1] < sizeof(struct ieee80211_ht_operation))
+		return;
+
+	ht_info = (struct ieee80211_ht_operation *)(ht_info_ie + 2);
+
+	/* determine capability flags */
+
+	switch (ht_info->ht_param & IEEE80211_HT_PARAM_CHA_SEC_OFFSET) {
+	case IEEE80211_HT_PARAM_CHA_SEC_ABOVE:
+		if (flags & IEEE80211_CHAN_NO_HT40PLUS) {
+			cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;
+			cap &= ~IEEE80211_HT_CAP_SGI_40;
+		}
+		break;
+	case IEEE80211_HT_PARAM_CHA_SEC_BELOW:
+		if (flags & IEEE80211_CHAN_NO_HT40MINUS) {
+			cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;
+			cap &= ~IEEE80211_HT_CAP_SGI_40;
+		}
+		break;
+	}
+
+	/* set SM PS mode properly */
+	cap &= ~IEEE80211_HT_CAP_SM_PS;
+	switch (smps) {
+	case IEEE80211_SMPS_AUTOMATIC:
+	case IEEE80211_SMPS_NUM_MODES:
+		WARN_ON(1);
+	case IEEE80211_SMPS_OFF:
+		cap |= WLAN_HT_CAP_SM_PS_DISABLED <<
+			IEEE80211_HT_CAP_SM_PS_SHIFT;
+		break;
+	case IEEE80211_SMPS_STATIC:
+		cap |= WLAN_HT_CAP_SM_PS_STATIC <<
+			IEEE80211_HT_CAP_SM_PS_SHIFT;
+		break;
+	case IEEE80211_SMPS_DYNAMIC:
+		cap |= WLAN_HT_CAP_SM_PS_DYNAMIC <<
+			IEEE80211_HT_CAP_SM_PS_SHIFT;
+		break;
+	}
+
+	/* reserve and fill IE */
+
+	pos = skb_put(skb, sizeof(struct ieee80211_ht_cap) + 2);
+	*pos++ = WLAN_EID_HT_CAPABILITY;
+	*pos++ = sizeof(struct ieee80211_ht_cap);
+	memset(pos, 0, sizeof(struct ieee80211_ht_cap));
+
+	/* capability flags */
+	tmp = cpu_to_le16(cap);
+	memcpy(pos, &tmp, sizeof(u16));
+	pos += sizeof(u16);
+
+	/* AMPDU parameters */
+	*pos++ = sband->ht_cap.ampdu_factor |
+		 (sband->ht_cap.ampdu_density <<
+			IEEE80211_HT_AMPDU_PARM_DENSITY_SHIFT);
+
+	/* MCS set */
+	memcpy(pos, &sband->ht_cap.mcs, sizeof(sband->ht_cap.mcs));
+	pos += sizeof(sband->ht_cap.mcs);
+
+	/* extended capabilities */
+	pos += sizeof(__le16);
+
+	/* BF capabilities */
+	pos += sizeof(__le32);
+
+	/* antenna selection */
+	pos += sizeof(u8);
+}
+
+static void ieee80211_send_assoc(struct ieee80211_sub_if_data *sdata,
+				 struct ieee80211_work *wk)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct sk_buff *skb;
+	struct ieee80211_mgmt *mgmt;
+	u8 *pos, qos_info;
+	size_t offset = 0, noffset;
+	int i, count, rates_len, supp_rates_len;
+	u16 capab;
+	struct ieee80211_supported_band *sband;
+	u32 rates = 0;
+
+	sband = local->hw.wiphy->bands[wk->chan->band];
+
+	if (wk->assoc.supp_rates_len) {
+		/*
+		 * Get all rates supported by the device and the AP as
+		 * some APs don't like getting a superset of their rates
+		 * in the association request (e.g. D-Link DAP 1353 in
+		 * b-only mode)...
+		 */
+		rates_len = ieee80211_compatible_rates(wk->assoc.supp_rates,
+						       wk->assoc.supp_rates_len,
+						       sband, &rates);
+	} else {
+		/*
+		 * In case AP not provide any supported rates information
+		 * before association, we send information element(s) with
+		 * all rates that we support.
+		 */
+		rates = ~0;
+		rates_len = sband->n_bitrates;
+	}
+
+	skb = alloc_skb(local->hw.extra_tx_headroom +
+			sizeof(*mgmt) + /* bit too much but doesn't matter */
+			2 + wk->assoc.ssid_len + /* SSID */
+			4 + rates_len + /* (extended) rates */
+			4 + /* power capability */
+			2 + 2 * sband->n_channels + /* supported channels */
+			2 + sizeof(struct ieee80211_ht_cap) + /* HT */
+			wk->ie_len + /* extra IEs */
+			9, /* WMM */
+			GFP_KERNEL);
+	if (!skb)
+		return;
+
+	skb_reserve(skb, local->hw.extra_tx_headroom);
+
+	capab = WLAN_CAPABILITY_ESS;
+
+	if (sband->band == NL80211_BAND_2GHZ) {
+		if (!(local->hw.flags & IEEE80211_HW_2GHZ_SHORT_SLOT_INCAPABLE))
+			capab |= WLAN_CAPABILITY_SHORT_SLOT_TIME;
+		if (!(local->hw.flags & IEEE80211_HW_2GHZ_SHORT_PREAMBLE_INCAPABLE))
+			capab |= WLAN_CAPABILITY_SHORT_PREAMBLE;
+	}
+
+	if (wk->assoc.capability & WLAN_CAPABILITY_PRIVACY)
+		capab |= WLAN_CAPABILITY_PRIVACY;
+
+	if ((wk->assoc.capability & WLAN_CAPABILITY_SPECTRUM_MGMT) &&
+	    (local->hw.flags & IEEE80211_HW_SPECTRUM_MGMT))
+		capab |= WLAN_CAPABILITY_SPECTRUM_MGMT;
+
+	mgmt = (struct ieee80211_mgmt *) skb_put(skb, 24);
+	memset(mgmt, 0, 24);
+	memcpy(mgmt->da, wk->filter_ta, ETH_ALEN);
+	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
+	memcpy(mgmt->bssid, wk->filter_ta, ETH_ALEN);
+
+	if (!sdata->vif.p2p && !is_zero_ether_addr(wk->assoc.prev_bssid)) {
+		skb_put(skb, 10);
+		mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+						  IEEE80211_STYPE_REASSOC_REQ);
+		mgmt->u.reassoc_req.capab_info = cpu_to_le16(capab);
+		mgmt->u.reassoc_req.listen_interval =
+				cpu_to_le16(sdata->vif.bss_conf.listen_interval);
+		memcpy(mgmt->u.reassoc_req.current_ap, wk->assoc.prev_bssid,
+		       ETH_ALEN);
+	} else {
+		skb_put(skb, 4);
+		mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+						  IEEE80211_STYPE_ASSOC_REQ);
+		mgmt->u.assoc_req.capab_info = cpu_to_le16(capab);
+		mgmt->u.assoc_req.listen_interval =
+				cpu_to_le16(sdata->vif.bss_conf.listen_interval);
+	}
+
+	/* SSID */
+	pos = skb_put(skb, 2 + wk->assoc.ssid_len);
+	*pos++ = WLAN_EID_SSID;
+	*pos++ = wk->assoc.ssid_len;
+	memcpy(pos, wk->assoc.ssid, wk->assoc.ssid_len);
+
+	/* add all rates which were marked to be used above */
+	supp_rates_len = rates_len;
+	if (supp_rates_len > 8)
+		supp_rates_len = 8;
+
+	pos = skb_put(skb, supp_rates_len + 2);
+	*pos++ = WLAN_EID_SUPP_RATES;
+	*pos++ = supp_rates_len;
+
+	count = 0;
+	for (i = 0; i < sband->n_bitrates; i++) {
+		if (BIT(i) & rates) {
+			int rate = sband->bitrates[i].bitrate;
+			*pos++ = (u8) (rate / 5);
+			if (++count == 8)
+				break;
+		}
+	}
+
+	if (rates_len > count) {
+		pos = skb_put(skb, rates_len - count + 2);
+		*pos++ = WLAN_EID_EXT_SUPP_RATES;
+		*pos++ = rates_len - count;
+
+		for (i++; i < sband->n_bitrates; i++) {
+			if (BIT(i) & rates) {
+				int rate = sband->bitrates[i].bitrate;
+				*pos++ = (u8) (rate / 5);
+			}
+		}
+	}
+
+	if (capab & WLAN_CAPABILITY_SPECTRUM_MGMT) {
+		/* 1. power capabilities */
+		pos = skb_put(skb, 4);
+		*pos++ = WLAN_EID_PWR_CAPABILITY;
+		*pos++ = 2;
+		*pos++ = 0; /* min tx power */
+		*pos++ = wk->chan->max_power; /* max tx power */
+
+		/* 2. supported channels */
+		/* TODO: get this in reg domain format */
+		pos = skb_put(skb, 2 * sband->n_channels + 2);
+		*pos++ = WLAN_EID_SUPPORTED_CHANNELS;
+		*pos++ = 2 * sband->n_channels;
+		for (i = 0; i < sband->n_channels; i++) {
+			*pos++ = ieee80211_frequency_to_channel(
+					sband->channels[i].center_freq);
+			*pos++ = 1; /* one channel in the subband*/
+		}
+	}
+
+	/* if present, add any custom IEs that go before HT */
+	if (wk->ie_len != 0 && wk->ie != NULL) {
+		static const u8 before_ht[] = {
+			WLAN_EID_SSID,
+			WLAN_EID_SUPP_RATES,
+			WLAN_EID_EXT_SUPP_RATES,
+			WLAN_EID_PWR_CAPABILITY,
+			WLAN_EID_SUPPORTED_CHANNELS,
+			WLAN_EID_RSN,
+			WLAN_EID_QOS_CAPA,
+			WLAN_EID_RRM_ENABLED_CAPABILITIES,
+			WLAN_EID_MOBILITY_DOMAIN,
+			WLAN_EID_SUPPORTED_REGULATORY_CLASSES,
+		};
+		noffset = mac80211_ie_split(wk->ie, wk->ie_len,
+					     before_ht, ARRAY_SIZE(before_ht),
+					     offset);
+		pos = skb_put(skb, noffset - offset);
+		memcpy(pos, wk->ie + offset, noffset - offset);
+		offset = noffset;
+	}
+
+	if (wk->assoc.use_11n && wk->assoc.wmm_used &&
+	    local->hw.queues >= 4)
+		ieee80211_add_ht_ie(skb, wk->assoc.ht_information_ie,
+				    sband, wk->chan, wk->assoc.smps);
+
+	/* if present, add any custom non-vendor IEs that go after HT */
+	if (wk->ie_len != 0 && wk->ie != NULL) {
+		noffset = mac80211_ie_split_vendor(wk->ie, wk->ie_len,
+						    offset);
+		pos = skb_put(skb, noffset - offset);
+		memcpy(pos, wk->ie + offset, noffset - offset);
+		offset = noffset;
+	}
+
+	if (wk->assoc.wmm_used && local->hw.queues >= 4) {
+		if (wk->assoc.uapsd_used) {
+			qos_info = local->uapsd_queues;
+			qos_info |= (local->uapsd_max_sp_len <<
+				     IEEE80211_WMM_IE_STA_QOSINFO_SP_SHIFT);
+		} else {
+			qos_info = 0;
+		}
+
+		pos = skb_put(skb, 9);
+		*pos++ = WLAN_EID_VENDOR_SPECIFIC;
+		*pos++ = 7; /* len */
+		*pos++ = 0x00; /* Microsoft OUI 00:50:F2 */
+		*pos++ = 0x50;
+		*pos++ = 0xf2;
+		*pos++ = 2; /* WME */
+		*pos++ = 0; /* WME info */
+		*pos++ = 1; /* WME ver */
+		*pos++ = qos_info;
+	}
+
+	/* add any remaining custom (i.e. vendor specific here) IEs */
+	if (wk->ie_len != 0 && wk->ie != NULL) {
+		noffset = wk->ie_len;
+		pos = skb_put(skb, noffset - offset);
+		memcpy(pos, wk->ie + offset, noffset - offset);
+	}
+
+	IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
+	ieee80211_tx_skb(sdata, skb);
+}
+
+static void ieee80211_remove_auth_bss(struct ieee80211_local *local,
+				      struct ieee80211_work *wk)
+{
+	struct cfg80211_bss *cbss;
+	enum ieee80211_privacy privacy;
+
+	privacy = IEEE80211_PRIVACY_OFF;
+	if (wk->probe_auth.privacy)
+		privacy = IEEE80211_PRIVACY_ON;
+
+	cbss = cfg80211_get_bss(local->hw.wiphy, wk->chan, wk->filter_ta,
+				wk->probe_auth.ssid, wk->probe_auth.ssid_len,
+				IEEE80211_BSS_TYPE_ESS, privacy);
+	if (!cbss)
+		return;
+
+	cfg80211_unlink_bss(local->hw.wiphy, cbss);
+	cfg80211_put_bss(local->hw.wiphy, cbss);
+}
+
+static enum work_action __must_check
+ieee80211_direct_probe(struct ieee80211_work *wk)
+{
+	struct ieee80211_sub_if_data *sdata = wk->sdata;
+	struct ieee80211_local *local = sdata->local;
+
+	if (!wk->probe_auth.synced) {
+		int ret = drv_tx_sync(local, sdata, wk->filter_ta,
+				      IEEE80211_TX_SYNC_AUTH);
+		if (ret)
+			return WORK_ACT_TIMEOUT;
+	}
+	wk->probe_auth.synced = true;
+
+	wk->probe_auth.tries++;
+	if (wk->probe_auth.tries > IEEE80211_AUTH_MAX_TRIES) {
+		printk(KERN_DEBUG "%s: direct probe to %pM timed out\n",
+		       sdata->name, wk->filter_ta);
+
+		/*
+		 * Most likely AP is not in the range so remove the
+		 * bss struct for that AP.
+		 */
+		ieee80211_remove_auth_bss(local, wk);
+
+		return WORK_ACT_TIMEOUT;
+	}
+
+	printk(KERN_DEBUG "%s: direct probe to %pM (try %d/%i)\n",
+	       sdata->name, wk->filter_ta, wk->probe_auth.tries,
+	       IEEE80211_AUTH_MAX_TRIES);
+
+	/*
+	 * Direct probe is sent to broadcast address as some APs
+	 * will not answer to direct packet in unassociated state.
+	 */
+	mac80211_send_probe_req(sdata, NULL, wk->probe_auth.ssid,
+				 wk->probe_auth.ssid_len, NULL, 0,
+				 (u32) -1, true, false);
+
+	wk->timeout = jiffies + IEEE80211_AUTH_TIMEOUT;
+	run_again(local, wk->timeout);
+
+	return WORK_ACT_NONE;
+}
+
+
+static enum work_action __must_check
+ieee80211_authenticate(struct ieee80211_work *wk)
+{
+	struct ieee80211_sub_if_data *sdata = wk->sdata;
+	struct ieee80211_local *local = sdata->local;
+	struct cfg80211_bss *bss;
+	struct cfg80211_bss *prev_bss = NULL;
+	u16 trans = 1;
+
+	if (!wk->probe_auth.synced) {
+		int ret = drv_tx_sync(local, sdata, wk->filter_ta,
+				      IEEE80211_TX_SYNC_AUTH);
+		if (ret)
+			return WORK_ACT_TIMEOUT;
+	}
+	wk->probe_auth.synced = true;
+
+	/* HACK!!! xradio device requires SSID to be available at AUTH stage.
+	 * cfg80211 beacon cache is designed to handle multi-SSID BSSes, so
+	 * bss struct returned by cfg80211_get_bss() has random SSID if BSS
+	 * just changed SSID before authentication (typical for p2p).
+	 * This is a firmware design fault, however as a workaround cfg80211
+	 * beacon cache is purged to make sure target BSS is searchable
+	 * in rb-tree at the AUTH stage.
+	 */
+	while (true) {
+		const u8 *ssidie;
+		const struct cfg80211_bss_ies *ies;
+		ies = rcu_access_pointer(wk->probe_auth.bss->ies);
+		if (ies) {
+			ssidie = cfg80211_find_ie(WLAN_EID_SSID, ies->data, ies->len);
+			if (ssidie) {
+				bss = cfg80211_get_bss(local->hw.wiphy,
+						wk->probe_auth.bss->channel,
+						wk->probe_auth.bss->bssid,
+						ssidie + 2, ssidie[1], IEEE80211_BSS_TYPE_ANY,
+						IEEE80211_PRIVACY_ANY);
+				if (bss) {
+					cfg80211_put_bss(local->hw.wiphy, bss);
+					break;
+				}
+			}
+		}
+		bss = cfg80211_get_bss(local->hw.wiphy,
+				wk->probe_auth.bss->channel,
+				wk->probe_auth.bss->bssid,
+				NULL, 0, IEEE80211_BSS_TYPE_ANY,
+				IEEE80211_PRIVACY_ANY);
+		if (WARN_ON(!bss))
+			break;
+		if (bss == wk->probe_auth.bss) {
+			cfg80211_put_bss(local->hw.wiphy, bss);
+			break;
+		}
+		if (prev_bss == bss) {
+			printk(KERN_ERR "cfg80211_unlink_bss failed, break now\n");
+			break;
+		}
+		prev_bss = bss;
+		cfg80211_unlink_bss(local->hw.wiphy, bss);
+	}
+	/* End of the hack */
+
+#ifdef CONFIG_XRMAC_XR_ROAMING_CHANGES
+	/*
+	 * IEEE 802.11r - Fast BSS Transition is currently not supported by
+	 * XR solution.
+	 * TODO: When 11r will be supported check if we can lock queues
+	 * when algorithm == WLAN_AUTH_FT.
+	 */
+	if (WLAN_AUTH_FT != wk->probe_auth.algorithm)
+		sdata->queues_locked = 1;
+#endif
+	wk->probe_auth.tries++;
+	if (wk->probe_auth.tries > IEEE80211_AUTH_MAX_TRIES) {
+		printk(KERN_DEBUG "%s: authentication with %pM"
+		       " timed out\n", sdata->name, wk->filter_ta);
+
+		/*
+		 * Most likely AP is not in the range so remove the
+		 * bss struct for that AP.
+		 */
+		ieee80211_remove_auth_bss(local, wk);
+#ifdef CONFIG_XRMAC_XR_ROAMING_CHANGES
+		sdata->queues_locked = 0;
+#endif
+
+		return WORK_ACT_TIMEOUT;
+	}
+
+	printk(KERN_DEBUG "%s: authenticate with %pM (try %d)\n",
+	       sdata->name, wk->filter_ta, wk->probe_auth.tries);
+
+	if (wk->probe_auth.algorithm == WLAN_AUTH_SAE) {
+		if (wk->probe_auth.transaction == 1)
+			wk->probe_auth.transaction = 1;
+		else if (wk->probe_auth.transaction == 2) {
+			trans = 2;
+			wk->probe_auth.transaction = 2;
+		}
+	}
+	else {
+		wk->probe_auth.transaction = 2;
+	}
+	mac80211_send_auth(sdata, trans, wk->probe_auth.algorithm, wk->ie,
+			    wk->ie_len, wk->filter_ta, NULL, 0, 0);
+
+	wk->timeout = jiffies + IEEE80211_AUTH_TIMEOUT;
+	run_again(local, wk->timeout);
+
+	return WORK_ACT_NONE;
+}
+
+static enum work_action __must_check
+ieee80211_associate(struct ieee80211_work *wk)
+{
+	struct ieee80211_sub_if_data *sdata = wk->sdata;
+	struct ieee80211_local *local = sdata->local;
+
+	if (!wk->assoc.synced) {
+		int ret = drv_tx_sync(local, sdata, wk->filter_ta,
+				      IEEE80211_TX_SYNC_ASSOC);
+		if (ret)
+			return WORK_ACT_TIMEOUT;
+	}
+	wk->assoc.synced = true;
+
+	wk->assoc.tries++;
+	if (wk->assoc.tries > IEEE80211_ASSOC_MAX_TRIES) {
+		printk(KERN_DEBUG "%s: association with %pM"
+		       " timed out\n",
+		       sdata->name, wk->filter_ta);
+
+		/*
+		 * Most likely AP is not in the range so remove the
+		 * bss struct for that AP.
+		 */
+		if (wk->assoc.bss)
+			cfg80211_unlink_bss(local->hw.wiphy, wk->assoc.bss);
+
+		return WORK_ACT_TIMEOUT;
+	}
+
+	printk(KERN_DEBUG "%s: associate with %pM (try %d)\n",
+	       sdata->name, wk->filter_ta, wk->assoc.tries);
+	ieee80211_send_assoc(sdata, wk);
+
+	wk->timeout = jiffies + IEEE80211_ASSOC_TIMEOUT;
+	run_again(local, wk->timeout);
+
+	return WORK_ACT_NONE;
+}
+
+static enum work_action __must_check
+ieee80211_remain_on_channel_timeout(struct ieee80211_work *wk)
+{
+	/*
+	 * First time we run, do nothing -- the generic code will
+	 * have switched to the right channel etc.
+	 */
+	if (!wk->started) {
+		wk->timeout = jiffies + msecs_to_jiffies(wk->remain.duration);
+
+		/*
+		cfg80211_ready_on_channel(wk->sdata->dev, (unsigned long) wk,
+					  wk->chan, wk->chan_type,
+					  wk->remain.duration, GFP_KERNEL);
+		*/
+		cfg80211_ready_on_channel(&wk->sdata->wdev, (unsigned long) wk,
+				  wk->chan, wk->remain.duration,
+				  GFP_KERNEL);
+
+
+		return WORK_ACT_NONE;
+	}
+
+	return WORK_ACT_TIMEOUT;
+}
+
+#if 0
+static enum work_action __must_check
+ieee80211_offchannel_tx(struct ieee80211_work *wk)
+{
+	if (!wk->started) {
+		wk->timeout = jiffies + msecs_to_jiffies(wk->offchan_tx.wait);
+
+		/*
+		 * After this, offchan_tx.frame remains but now is no
+		 * longer a valid pointer -- we still need it as the
+		 * cookie for canceling this work/status matching.
+		 */
+		ieee80211_tx_skb(wk->sdata, wk->offchan_tx.frame);
+
+		return WORK_ACT_NONE;
+	}
+
+	return WORK_ACT_TIMEOUT;
+}
+#endif
+
+static enum work_action __must_check
+ieee80211_assoc_beacon_wait(struct ieee80211_work *wk)
+{
+	if (wk->started)
+		return WORK_ACT_TIMEOUT;
+
+	/*
+	 * Wait up to one beacon interval ...
+	 * should this be more if we miss one?
+	 */
+	printk(KERN_DEBUG "%s: waiting for beacon from %pM\n",
+	       wk->sdata->name, wk->filter_ta);
+	wk->timeout = TU_TO_EXP_TIME(wk->assoc.bss->beacon_interval);
+	return WORK_ACT_NONE;
+}
+
+static void ieee80211_auth_challenge(struct ieee80211_work *wk,
+				     struct ieee80211_mgmt *mgmt,
+				     size_t len)
+{
+	struct ieee80211_sub_if_data *sdata = wk->sdata;
+	u8 *pos;
+	struct ieee802_11_elems elems;
+
+	pos = mgmt->u.auth.variable;
+	mac802_11_parse_elems(pos, len - (pos - (u8 *) mgmt), &elems);
+	if (!elems.challenge)
+		return;
+	mac80211_send_auth(sdata, 3, wk->probe_auth.algorithm,
+			    elems.challenge - 2, elems.challenge_len + 2,
+			    wk->filter_ta, wk->probe_auth.key,
+			    wk->probe_auth.key_len, wk->probe_auth.key_idx);
+	wk->probe_auth.transaction = 4;
+}
+
+static enum work_action __must_check
+ieee80211_rx_mgmt_auth(struct ieee80211_work *wk,
+		       struct ieee80211_mgmt *mgmt, size_t len)
+{
+	u16 auth_alg, auth_transaction, status_code;
+
+	if (wk->type != IEEE80211_WORK_AUTH)
+		return WORK_ACT_MISMATCH;
+
+	if (len < 24 + 6)
+		return WORK_ACT_NONE;
+
+	auth_alg = le16_to_cpu(mgmt->u.auth.auth_alg);
+	auth_transaction = le16_to_cpu(mgmt->u.auth.auth_transaction);
+	status_code = le16_to_cpu(mgmt->u.auth.status_code);
+
+	if (auth_alg != wk->probe_auth.algorithm ||
+	    auth_transaction != wk->probe_auth.transaction)
+		return WORK_ACT_NONE;
+
+	if (status_code != WLAN_STATUS_SUCCESS) {
+		printk(KERN_DEBUG "%s: %pM denied authentication (status %d)\n",
+		       wk->sdata->name, mgmt->sa, status_code);
+#ifdef CONFIG_XRMAC_XR_ROAMING_CHANGES
+		wk->sdata->queues_locked = 0;
+#endif
+		return WORK_ACT_DONE;
+	}
+
+	switch (wk->probe_auth.algorithm) {
+	case WLAN_AUTH_OPEN:
+	case WLAN_AUTH_LEAP:
+	case WLAN_AUTH_FT:
+	case WLAN_AUTH_SAE:
+		break;
+	case WLAN_AUTH_SHARED_KEY:
+		if (wk->probe_auth.transaction != 4) {
+			ieee80211_auth_challenge(wk, mgmt, len);
+			/* need another frame */
+			return WORK_ACT_NONE;
+		}
+		break;
+	default:
+		WARN_ON(1);
+		return WORK_ACT_NONE;
+	}
+
+	printk(KERN_DEBUG "%s: authenticated\n", wk->sdata->name);
+	return WORK_ACT_DONE;
+}
+
+static enum work_action __must_check
+ieee80211_rx_mgmt_assoc_resp(struct ieee80211_work *wk,
+			     struct ieee80211_mgmt *mgmt, size_t len,
+			     bool reassoc)
+{
+	struct ieee80211_sub_if_data *sdata = wk->sdata;
+	struct ieee80211_local *local = sdata->local;
+	u16 capab_info, status_code, aid;
+	struct ieee802_11_elems elems;
+	u8 *pos;
+
+	if (wk->type != IEEE80211_WORK_ASSOC)
+		return WORK_ACT_MISMATCH;
+
+	/*
+	 * AssocResp and ReassocResp have identical structure, so process both
+	 * of them in this function.
+	 */
+
+	if (len < 24 + 6)
+		return WORK_ACT_NONE;
+
+	capab_info = le16_to_cpu(mgmt->u.assoc_resp.capab_info);
+	status_code = le16_to_cpu(mgmt->u.assoc_resp.status_code);
+	aid = le16_to_cpu(mgmt->u.assoc_resp.aid);
+
+	printk(KERN_DEBUG "%s: RX %sssocResp from %pM (capab=0x%x "
+	       "status=%d aid=%d)\n",
+	       sdata->name, reassoc ? "Rea" : "A", mgmt->sa,
+	       capab_info, status_code, (u16)(aid & ~(BIT(15) | BIT(14))));
+
+	pos = mgmt->u.assoc_resp.variable;
+	mac802_11_parse_elems(pos, len - (pos - (u8 *) mgmt), &elems);
+
+	if (status_code == WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY &&
+	    elems.timeout_int && elems.timeout_int_len == 5 &&
+	    elems.timeout_int[0] == WLAN_TIMEOUT_ASSOC_COMEBACK) {
+		u32 tu, ms;
+		tu = get_unaligned_le32(elems.timeout_int + 1);
+		ms = tu * 1024 / 1000;
+		printk(KERN_DEBUG "%s: %pM rejected association temporarily; "
+		       "comeback duration %u TU (%u ms)\n",
+		       sdata->name, mgmt->sa, tu, ms);
+		wk->timeout = jiffies + msecs_to_jiffies(ms);
+		if (ms > IEEE80211_ASSOC_TIMEOUT)
+			run_again(local, wk->timeout);
+		return WORK_ACT_NONE;
+	}
+
+	if (status_code != WLAN_STATUS_SUCCESS)
+		printk(KERN_DEBUG "%s: %pM denied association (code=%d)\n",
+		       sdata->name, mgmt->sa, status_code);
+	else
+		printk(KERN_DEBUG "%s: associated\n", sdata->name);
+#ifdef CONFIG_XRMAC_XR_ROAMING_CHANGES
+	sdata->queues_locked = 0;
+#endif
+
+	return WORK_ACT_DONE;
+}
+
+static enum work_action __must_check
+ieee80211_rx_mgmt_probe_resp(struct ieee80211_work *wk,
+			     struct ieee80211_mgmt *mgmt, size_t len,
+			     struct ieee80211_rx_status *rx_status)
+{
+	struct ieee80211_sub_if_data *sdata = wk->sdata;
+	struct ieee80211_local *local = sdata->local;
+	size_t baselen;
+
+	ASSERT_WORK_MTX(local);
+
+	if (wk->type != IEEE80211_WORK_DIRECT_PROBE)
+		return WORK_ACT_MISMATCH;
+
+	if (len < 24 + 12)
+		return WORK_ACT_NONE;
+
+	baselen = (u8 *) mgmt->u.probe_resp.variable - (u8 *) mgmt;
+	if (baselen > len)
+		return WORK_ACT_NONE;
+
+	printk(KERN_DEBUG "%s: direct probe responded\n", sdata->name);
+	return WORK_ACT_DONE;
+}
+
+static enum work_action __must_check
+ieee80211_rx_mgmt_beacon(struct ieee80211_work *wk,
+			 struct ieee80211_mgmt *mgmt, size_t len)
+{
+	struct ieee80211_sub_if_data *sdata = wk->sdata;
+	struct ieee80211_local *local = sdata->local;
+
+	ASSERT_WORK_MTX(local);
+
+	if (wk->type != IEEE80211_WORK_ASSOC_BEACON_WAIT)
+		return WORK_ACT_MISMATCH;
+
+	if (len < 24 + 12)
+		return WORK_ACT_NONE;
+
+	printk(KERN_DEBUG "%s: beacon received\n", sdata->name);
+	return WORK_ACT_DONE;
+}
+
+static void ieee80211_work_rx_queued_mgmt(struct ieee80211_local *local,
+					  struct sk_buff *skb)
+{
+	struct ieee80211_rx_status *rx_status;
+	struct ieee80211_mgmt *mgmt;
+	struct ieee80211_work *wk;
+	enum work_action rma = WORK_ACT_NONE;
+	u16 fc;
+
+	rx_status = (struct ieee80211_rx_status *) skb->cb;
+	mgmt = (struct ieee80211_mgmt *) skb->data;
+	fc = le16_to_cpu(mgmt->frame_control);
+
+	mutex_lock(&local->mtx);
+
+	list_for_each_entry(wk, &local->work_list, list) {
+		const u8 *bssid = NULL;
+
+		switch (wk->type) {
+		case IEEE80211_WORK_DIRECT_PROBE:
+		case IEEE80211_WORK_AUTH:
+		case IEEE80211_WORK_ASSOC:
+		case IEEE80211_WORK_ASSOC_BEACON_WAIT:
+			bssid = wk->filter_ta;
+			break;
+		default:
+			continue;
+		}
+
+		/*
+		 * Before queuing, we already verified mgmt->sa,
+		 * so this is needed just for matching.
+		 */
+		if (compare_ether_addr(bssid, mgmt->bssid))
+			continue;
+
+		switch (fc & IEEE80211_FCTL_STYPE) {
+		case IEEE80211_STYPE_BEACON:
+			rma = ieee80211_rx_mgmt_beacon(wk, mgmt, skb->len);
+			break;
+		case IEEE80211_STYPE_PROBE_RESP:
+			rma = ieee80211_rx_mgmt_probe_resp(wk, mgmt, skb->len,
+							   rx_status);
+			break;
+		case IEEE80211_STYPE_AUTH:
+			rma = ieee80211_rx_mgmt_auth(wk, mgmt, skb->len);
+			break;
+		case IEEE80211_STYPE_ASSOC_RESP:
+			rma = ieee80211_rx_mgmt_assoc_resp(wk, mgmt,
+							   skb->len, false);
+			break;
+		case IEEE80211_STYPE_REASSOC_RESP:
+			rma = ieee80211_rx_mgmt_assoc_resp(wk, mgmt,
+							   skb->len, true);
+			break;
+		default:
+			WARN_ON(1);
+			rma = WORK_ACT_NONE;
+		}
+
+		/*
+		 * We've either received an unexpected frame, or we have
+		 * multiple work items and need to match the frame to the
+		 * right one.
+		 */
+		if (rma == WORK_ACT_MISMATCH)
+			continue;
+
+		/*
+		 * We've processed this frame for that work, so it can't
+		 * belong to another work struct.
+		 * NB: this is also required for correctness for 'rma'!
+		 */
+		break;
+	}
+
+	switch (rma) {
+	case WORK_ACT_MISMATCH:
+		/* ignore this unmatched frame */
+		break;
+	case WORK_ACT_NONE:
+		break;
+	case WORK_ACT_DONE:
+		list_del_rcu(&wk->list);
+		break;
+	default:
+		WARN(1, "unexpected: %d", rma);
+	}
+
+	mutex_unlock(&local->mtx);
+
+	if (rma != WORK_ACT_DONE)
+		goto out;
+
+	switch (wk->done(wk, skb)) {
+	case WORK_DONE_DESTROY:
+		xrmac_free_work(wk);
+		break;
+	case WORK_DONE_REQUEUE:
+		synchronize_rcu();
+		wk->started = false; /* restart */
+		mutex_lock(&local->mtx);
+		list_add_tail(&wk->list, &local->work_list);
+		mutex_unlock(&local->mtx);
+	}
+
+ out:
+	kfree_skb(skb);
+}
+
+static bool ieee80211_work_ct_coexists(enum nl80211_channel_type wk_ct,
+				       enum nl80211_channel_type oper_ct)
+{
+	switch (wk_ct) {
+	case NL80211_CHAN_NO_HT:
+		return true;
+	case NL80211_CHAN_HT20:
+		if (oper_ct != NL80211_CHAN_NO_HT)
+			return true;
+		return false;
+	case NL80211_CHAN_HT40MINUS:
+	case NL80211_CHAN_HT40PLUS:
+		return (wk_ct == oper_ct);
+	}
+	WARN_ON(1); /* shouldn't get here */
+	return false;
+}
+
+static void ieee80211_work_timer(struct timer_list *t)
+{
+	struct ieee80211_local *local = from_timer(local, t, work_timer);
+
+	if (local->quiescing)
+		return;
+
+	mac80211_queue_work(&local->hw, &local->work_work);
+}
+
+static void ieee80211_work_work(struct work_struct *work)
+{
+	struct ieee80211_local *local =
+		container_of(work, struct ieee80211_local, work_work);
+	struct ieee80211_channel_state *chan_state = &local->chan_state;
+	struct sk_buff *skb;
+	struct ieee80211_work *wk, *tmp;
+	LIST_HEAD(xrmac_free_work);
+	enum work_action rma;
+	bool remain_off_channel = false;
+
+	if (local->scanning)
+		return;
+
+	/*
+	 * mac80211_queue_work() should have picked up most cases,
+	 * here we'll pick the rest.
+	 */
+	if (WARN(local->suspended, "work scheduled while going to suspend\n"))
+		return;
+
+	/* first process frames to avoid timing out while a frame is pending */
+	while ((skb = skb_dequeue(&local->work_skb_queue)))
+		ieee80211_work_rx_queued_mgmt(local, skb);
+
+	mutex_lock(&local->mtx);
+
+	mac80211_recalc_idle(local);
+
+	list_for_each_entry_safe(wk, tmp, &local->work_list, list) {
+		bool started = wk->started;
+
+		/* mark work as started if it's on the current off-channel */
+		if (!started && chan_state->tmp_channel &&
+		    wk->chan == chan_state->tmp_channel &&
+		    wk->chan_type == chan_state->tmp_channel_type) {
+			started = true;
+			wk->timeout = jiffies;
+		}
+
+		if (!started && !chan_state->tmp_channel) {
+			/*
+			 * TODO: could optimize this by leaving the
+			 *	 station vifs in awake mode if they
+			 *	 happen to be on the same channel as
+			 *	 the requested channel
+			 */
+			ieee80211_offchannel_stop_beaconing(local);
+			ieee80211_offchannel_stop_station(local);
+
+			chan_state->tmp_channel = wk->chan;
+			chan_state->tmp_channel_type = wk->chan_type;
+			mac80211_hw_config(local, 0);
+			started = true;
+			wk->timeout = jiffies;
+		}
+
+		/* don't try to work with items that aren't started */
+		if (!started)
+			continue;
+
+		if (time_is_after_jiffies(wk->timeout)) {
+			/*
+			 * This work item isn't supposed to be worked on
+			 * right now, but take care to adjust the timer
+			 * properly.
+			 */
+			run_again(local, wk->timeout);
+			continue;
+		}
+
+		switch (wk->type) {
+		default:
+			WARN_ON(1);
+			/* nothing */
+			rma = WORK_ACT_NONE;
+			break;
+		case IEEE80211_WORK_ABORT:
+			rma = WORK_ACT_TIMEOUT;
+			break;
+		case IEEE80211_WORK_DIRECT_PROBE:
+			rma = ieee80211_direct_probe(wk);
+			break;
+		case IEEE80211_WORK_AUTH:
+			rma = ieee80211_authenticate(wk);
+			break;
+		case IEEE80211_WORK_ASSOC:
+			rma = ieee80211_associate(wk);
+			break;
+		case IEEE80211_WORK_REMAIN_ON_CHANNEL:
+			rma = ieee80211_remain_on_channel_timeout(wk);
+			break;
+		case IEEE80211_WORK_ASSOC_BEACON_WAIT:
+			rma = ieee80211_assoc_beacon_wait(wk);
+			break;
+		}
+
+		wk->started = started;
+
+		switch (rma) {
+		case WORK_ACT_NONE:
+			/* might have changed the timeout */
+			run_again(local, wk->timeout);
+			break;
+		case WORK_ACT_TIMEOUT:
+			list_del_rcu(&wk->list);
+			synchronize_rcu();
+			list_add(&wk->list, &xrmac_free_work);
+			break;
+		default:
+			WARN(1, "unexpected: %d", rma);
+		}
+	}
+
+	list_for_each_entry(wk, &local->work_list, list) {
+		if (!wk->started)
+			continue;
+		if (wk->chan != chan_state->tmp_channel)
+			continue;
+		if (!ieee80211_work_ct_coexists(wk->chan_type,
+						chan_state->tmp_channel_type))
+			continue;
+		remain_off_channel = true;
+	}
+
+	if (!remain_off_channel && chan_state->tmp_channel) {
+		chan_state->tmp_channel = NULL;
+		/* If tmp_channel wasn't operating channel, then
+		 * we need to go back on-channel.
+		 * NOTE:  If we can ever be here while scannning,
+		 * or if the hw_config() channel config logic changes,
+		 * then we may need to do a more thorough check to see if
+		 * we still need to do a hardware config.  Currently,
+		 * we cannot be here while scanning, however.
+		 */
+		mac80211_hw_config(local, 0);
+
+		/* At the least, we need to disable offchannel_ps,
+		 * so just go ahead and run the entire offchannel
+		 * return logic here.  We *could* skip enabling
+		 * beaconing if we were already on-oper-channel
+		 * as a future optimization.
+		 */
+		mac80211_offchannel_return(local, true);
+
+		/* give connection some time to breathe */
+		run_again(local, jiffies + HZ/2);
+	}
+
+	if (list_empty(&local->work_list) && local->scan_req &&
+	    !local->scanning)
+		mac80211_queue_delayed_work(&local->hw,
+					     &local->scan_work,
+					     round_jiffies_relative(0));
+
+	mac80211_recalc_idle(local);
+
+	mutex_unlock(&local->mtx);
+
+	list_for_each_entry_safe(wk, tmp, &xrmac_free_work, list) {
+		wk->done(wk, NULL);
+		list_del(&wk->list);
+		kfree(wk);
+	}
+}
+
+void mac80211_add_work(struct ieee80211_work *wk)
+{
+	struct ieee80211_local *local;
+
+	if (WARN_ON(!wk->chan))
+		return;
+
+	if (WARN_ON(!wk->sdata))
+		return;
+
+	if (WARN_ON(!wk->done))
+		return;
+
+	if (WARN_ON(!ieee80211_sdata_running(wk->sdata)))
+		return;
+
+	wk->started = false;
+
+	local = wk->sdata->local;
+	mutex_lock(&local->mtx);
+	list_add_tail(&wk->list, &local->work_list);
+	mutex_unlock(&local->mtx);
+
+	mac80211_queue_work(&local->hw, &local->work_work);
+}
+
+void mac80211_work_init(struct ieee80211_local *local)
+{
+	INIT_LIST_HEAD(&local->work_list);
+	timer_setup(&local->work_timer, ieee80211_work_timer, 0);
+	INIT_WORK(&local->work_work, ieee80211_work_work);
+	skb_queue_head_init(&local->work_skb_queue);
+}
+
+void mac80211_work_purge(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_work *wk;
+	bool cleanup = false;
+
+	cancel_work_sync(&sdata->reconfig_filter);
+
+	mutex_lock(&local->mtx);
+	list_for_each_entry(wk, &local->work_list, list) {
+		if (wk->sdata != sdata)
+			continue;
+		cleanup = true;
+		wk->type = IEEE80211_WORK_ABORT;
+		wk->started = true;
+		wk->timeout = jiffies;
+	}
+	mutex_unlock(&local->mtx);
+
+	/* run cleanups etc. */
+	if (cleanup)
+		ieee80211_work_work(&local->work_work);
+
+	mutex_lock(&local->mtx);
+	list_for_each_entry(wk, &local->work_list, list) {
+		if (wk->sdata != sdata)
+			continue;
+		WARN_ON(1);
+		break;
+	}
+	mutex_unlock(&local->mtx);
+}
+
+ieee80211_rx_result ieee80211_work_rx_mgmt(struct ieee80211_sub_if_data *sdata,
+					   struct sk_buff *skb)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_mgmt *mgmt;
+	struct ieee80211_work *wk;
+	u16 fc;
+
+	if (skb->len < 24)
+		return RX_DROP_MONITOR;
+
+	mgmt = (struct ieee80211_mgmt *) skb->data;
+	fc = le16_to_cpu(mgmt->frame_control);
+
+	list_for_each_entry_rcu(wk, &local->work_list, list) {
+		if (sdata != wk->sdata)
+			continue;
+		if (compare_ether_addr(wk->filter_ta, mgmt->sa))
+			continue;
+		if (compare_ether_addr(wk->filter_ta, mgmt->bssid))
+			continue;
+
+		switch (fc & IEEE80211_FCTL_STYPE) {
+		case IEEE80211_STYPE_AUTH:
+		case IEEE80211_STYPE_PROBE_RESP:
+		case IEEE80211_STYPE_ASSOC_RESP:
+		case IEEE80211_STYPE_REASSOC_RESP:
+		case IEEE80211_STYPE_BEACON:
+			skb_queue_tail(&local->work_skb_queue, skb);
+			mac80211_queue_work(&local->hw, &local->work_work);
+			return RX_QUEUED;
+		}
+	}
+
+	return RX_CONTINUE;
+}
+
+static enum work_done_result ieee80211_remain_done(struct ieee80211_work *wk,
+						   struct sk_buff *skb)
+{
+	/*
+	 * We are done serving the remain-on-channel command.
+	 */
+	cfg80211_remain_on_channel_expired(&wk->sdata->wdev, (unsigned long) wk,
+					   wk->chan, GFP_KERNEL);
+
+	return WORK_DONE_DESTROY;
+}
+
+int mac80211_wk_remain_on_channel(struct ieee80211_sub_if_data *sdata,
+				   struct ieee80211_channel *chan,
+				   enum nl80211_channel_type channel_type,
+				   unsigned int duration, u64 *cookie)
+{
+	struct ieee80211_work *wk;
+
+	wk = kzalloc(sizeof(*wk), GFP_KERNEL);
+	if (!wk)
+		return -ENOMEM;
+
+	wk->type = IEEE80211_WORK_REMAIN_ON_CHANNEL;
+	wk->chan = chan;
+	wk->chan_type = channel_type;
+	wk->sdata = sdata;
+	wk->done = ieee80211_remain_done;
+
+	wk->remain.duration = duration;
+
+	*cookie = (unsigned long) wk;
+
+	mac80211_add_work(wk);
+
+	return 0;
+}
+
+int mac80211_wk_cancel_remain_on_channel(struct ieee80211_sub_if_data *sdata,
+					  u64 cookie)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_work *wk, *tmp;
+	bool found = false;
+
+	mutex_lock(&local->mtx);
+	list_for_each_entry_safe(wk, tmp, &local->work_list, list) {
+		if ((unsigned long) wk == cookie) {
+			wk->timeout = jiffies;
+			found = true;
+			break;
+		}
+	}
+	mutex_unlock(&local->mtx);
+
+	if (!found)
+		return -ENOENT;
+
+	mac80211_queue_work(&local->hw, &local->work_work);
+
+	return 0;
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/wpa.c b/drivers/net/wireless/xr829/umac/wpa.c
--- a/drivers/net/wireless/xr829/umac/wpa.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/wpa.c	2022-08-27 01:22:42.962539893 +0300
@@ -0,0 +1,668 @@
+/*
+ * Copyright 2002-2004, Instant802 Networks, Inc.
+ * Copyright 2008, Jouni Malinen <j@w1.fi>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/netdevice.h>
+#include <linux/types.h>
+#include <linux/skbuff.h>
+#include <linux/compiler.h>
+#include <linux/ieee80211.h>
+#include <linux/gfp.h>
+#include <asm/unaligned.h>
+#include <net/mac80211.h>
+#include <crypto/aes.h>
+
+#include "ieee80211_i.h"
+#include "michael.h"
+#include "tkip.h"
+#include "aes_ccm.h"
+#include "aes_cmac.h"
+#include "wpa.h"
+
+ieee80211_tx_result
+mac80211_tx_h_xrmac_michael_mic_add(struct ieee80211_tx_data *tx)
+{
+	u8 *data, *key, *mic;
+	size_t data_len;
+	unsigned int hdrlen;
+	struct ieee80211_hdr *hdr;
+	struct sk_buff *skb = tx->skb;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	int tail;
+
+	hdr = (struct ieee80211_hdr *)skb->data;
+	if (!tx->key || tx->key->conf.cipher != WLAN_CIPHER_SUITE_TKIP ||
+	    skb->len < 24 || !ieee80211_is_data_present(hdr->frame_control))
+		return TX_CONTINUE;
+
+	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	if (skb->len < hdrlen)
+		return TX_DROP;
+
+	data = skb->data + hdrlen;
+	data_len = skb->len - hdrlen;
+
+	if (unlikely(info->flags & IEEE80211_TX_INTFL_TKIP_MIC_FAILURE)) {
+		/* Need to use software crypto for the test */
+		info->control.hw_key = NULL;
+	}
+
+	if (info->control.hw_key &&
+	    (info->flags & IEEE80211_TX_CTL_DONTFRAG ||
+	     tx->local->ops->set_frag_threshold) &&
+	    !(tx->key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_MMIC)) {
+		/* hwaccel - with no need for SW-generated MMIC */
+		return TX_CONTINUE;
+	}
+
+	tail = MICHAEL_MIC_LEN;
+	if (!info->control.hw_key)
+		tail += TKIP_ICV_LEN;
+
+	if (WARN_ON(skb_tailroom(skb) < tail ||
+		    skb_headroom(skb) < TKIP_IV_LEN))
+		return TX_DROP;
+
+	key = &tx->key->conf.key[NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY];
+	mic = skb_put(skb, MICHAEL_MIC_LEN);
+	xrmac_michael_mic(key, hdr, data, data_len, mic);
+	if (unlikely(info->flags & IEEE80211_TX_INTFL_TKIP_MIC_FAILURE))
+		mic[0]++;
+
+	return TX_CONTINUE;
+}
+
+
+ieee80211_rx_result
+ieee80211_rx_h_xrmac_michael_mic_verify(struct ieee80211_rx_data *rx)
+{
+	u8 *data, *key = NULL;
+	size_t data_len;
+	unsigned int hdrlen;
+	u8 mic[MICHAEL_MIC_LEN];
+	struct sk_buff *skb = rx->skb;
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+
+	/*
+	 * it makes no sense to check for MIC errors on anything other
+	 * than data frames.
+	 */
+	if (!ieee80211_is_data_present(hdr->frame_control))
+		return RX_CONTINUE;
+
+	/*
+	 * No way to verify the MIC if the hardware stripped it or
+	 * the IV with the key index. In this case we have solely rely
+	 * on the driver to set RX_FLAG_MMIC_ERROR in the event of a
+	 * MIC failure report.
+	 */
+	if (status->flag & (RX_FLAG_MMIC_STRIPPED | RX_FLAG_IV_STRIPPED)) {
+		if (status->flag & RX_FLAG_MMIC_ERROR)
+			goto mic_fail;
+
+		if (!(status->flag & RX_FLAG_IV_STRIPPED) && rx->key)
+			goto update_iv;
+
+		return RX_CONTINUE;
+	}
+
+	/*
+	 * Some hardware seems to generate Michael MIC failure reports; even
+	 * though, the frame was not encrypted with TKIP and therefore has no
+	 * MIC. Ignore the flag them to avoid triggering countermeasures.
+	 */
+	if (!rx->key || rx->key->conf.cipher != WLAN_CIPHER_SUITE_TKIP ||
+	    !(status->flag & RX_FLAG_DECRYPTED))
+		return RX_CONTINUE;
+
+	if (rx->sdata->vif.type == NL80211_IFTYPE_AP && rx->key->conf.keyidx) {
+		/*
+		 * APs with pairwise keys should never receive Michael MIC
+		 * errors for non-zero keyidx because these are reserved for
+		 * group keys and only the AP is sending real multicast
+		 * frames in the BSS. (
+		 */
+		return RX_DROP_UNUSABLE;
+	}
+
+	if (status->flag & RX_FLAG_MMIC_ERROR)
+		goto mic_fail;
+
+	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	if (skb->len < hdrlen + MICHAEL_MIC_LEN)
+		return RX_DROP_UNUSABLE;
+
+	data = skb->data + hdrlen;
+	data_len = skb->len - hdrlen - MICHAEL_MIC_LEN;
+	key = &rx->key->conf.key[NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY];
+	xrmac_michael_mic(key, hdr, data, data_len, mic);
+	if (memcmp(mic, data + data_len, MICHAEL_MIC_LEN) != 0)
+		goto mic_fail;
+
+	/* remove Michael MIC from payload */
+	skb_trim(skb, skb->len - MICHAEL_MIC_LEN);
+
+update_iv:
+	/* update IV in key information to be able to detect replays */
+	rx->key->u.tkip.rx[rx->security_idx].iv32 = rx->tkip_iv32;
+	rx->key->u.tkip.rx[rx->security_idx].iv16 = rx->tkip_iv16;
+
+	return RX_CONTINUE;
+
+mic_fail:
+	/*
+	 * In some cases the key can be unset - e.g. a multicast packet, in
+	 * a driver that supports HW encryption. Send up the key idx only if
+	 * the key is set.
+	 */
+	xrmac_ev_michael_mic_failure(rx->sdata,
+					rx->key ? rx->key->conf.keyidx : -1,
+					(void *) skb->data, NULL, GFP_ATOMIC);
+	return RX_DROP_UNUSABLE;
+}
+
+
+static int tkip_encrypt_skb(struct ieee80211_tx_data *tx, struct sk_buff *skb)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	struct ieee80211_key *key = tx->key;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	unsigned long flags;
+	unsigned int hdrlen;
+	int len, tail;
+	u8 *pos;
+
+	if (info->control.hw_key &&
+	    !(info->control.hw_key->flags & IEEE80211_KEY_FLAG_GENERATE_IV)) {
+		/* hwaccel - with no need for software-generated IV */
+		return 0;
+	}
+
+	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	len = skb->len - hdrlen;
+
+	if (info->control.hw_key)
+		tail = 0;
+	else
+		tail = TKIP_ICV_LEN;
+
+	if (WARN_ON(skb_tailroom(skb) < tail ||
+		    skb_headroom(skb) < TKIP_IV_LEN))
+		return -1;
+
+	pos = skb_push(skb, TKIP_IV_LEN);
+	memmove(pos, pos + TKIP_IV_LEN, hdrlen);
+	pos += hdrlen;
+
+	/* Increase IV for the frame */
+	spin_lock_irqsave(&key->u.tkip.txlock, flags);
+	key->u.tkip.tx.iv16++;
+	if (key->u.tkip.tx.iv16 == 0)
+		key->u.tkip.tx.iv32++;
+	pos = mac80211_tkip_add_iv(pos, key);
+	spin_unlock_irqrestore(&key->u.tkip.txlock, flags);
+
+	/* hwaccel - with software IV */
+	if (info->control.hw_key)
+		return 0;
+
+	/* Add room for ICV */
+	skb_put(skb, TKIP_ICV_LEN);
+
+	return mac80211_tkip_encrypt_data(&tx->local->wep_tx_ctx,
+					   key, skb, pos, len);
+}
+
+
+ieee80211_tx_result
+mac80211_crypto_tkip_encrypt(struct ieee80211_tx_data *tx)
+{
+	struct sk_buff *skb = tx->skb;
+
+	mac80211_tx_set_protected(tx);
+
+	do {
+		if (tkip_encrypt_skb(tx, skb) < 0)
+			return TX_DROP;
+	} while ((skb = skb->next));
+
+	return TX_CONTINUE;
+}
+
+
+ieee80211_rx_result
+mac80211_crypto_tkip_decrypt(struct ieee80211_rx_data *rx)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) rx->skb->data;
+	int hdrlen, res, hwaccel = 0;
+	struct ieee80211_key *key = rx->key;
+	struct sk_buff *skb = rx->skb;
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
+
+	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+
+	if (!ieee80211_is_data(hdr->frame_control))
+		return RX_CONTINUE;
+
+	if (!rx->sta || skb->len - hdrlen < 12)
+		return RX_DROP_UNUSABLE;
+
+	/*
+	 * Let TKIP code verify IV, but skip decryption.
+	 * In the case where hardware checks the IV as well,
+	 * we don't even get here, see ieee80211_rx_h_decrypt()
+	 */
+	if (status->flag & RX_FLAG_DECRYPTED)
+		hwaccel = 1;
+
+	res = mac80211_tkip_decrypt_data(&rx->local->wep_rx_ctx,
+					  key, skb->data + hdrlen,
+					  skb->len - hdrlen, rx->sta->sta.addr,
+					  hdr->addr1, hwaccel, rx->security_idx,
+					  &rx->tkip_iv32,
+					  &rx->tkip_iv16);
+	if (res != TKIP_DECRYPT_OK)
+		return RX_DROP_UNUSABLE;
+
+	/* Trim ICV */
+	skb_trim(skb, skb->len - TKIP_ICV_LEN);
+
+	/* Remove IV */
+	memmove(skb->data + TKIP_IV_LEN, skb->data, hdrlen);
+	skb_pull(skb, TKIP_IV_LEN);
+
+	return RX_CONTINUE;
+}
+
+
+static void ccmp_special_blocks(struct sk_buff *skb, u8 *pn, u8 *scratch,
+				int encrypted)
+{
+	__le16 mask_fc;
+	int a4_included, mgmt;
+	u8 qos_tid;
+	u8 *b_0, *aad;
+	u16 data_len, len_a;
+	unsigned int hdrlen;
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+
+	memset(scratch, 0, 6 * AES_BLOCK_SIZE);
+
+	b_0 = scratch + 3 * AES_BLOCK_SIZE;
+	aad = scratch + 4 * AES_BLOCK_SIZE;
+
+	/*
+	 * Mask FC: zero subtype b4 b5 b6 (if not mgmt)
+	 * Retry, PwrMgt, MoreData; set Protected
+	 */
+	mgmt = ieee80211_is_mgmt(hdr->frame_control);
+	mask_fc = hdr->frame_control;
+	mask_fc &= ~cpu_to_le16(IEEE80211_FCTL_RETRY |
+				IEEE80211_FCTL_PM | IEEE80211_FCTL_MOREDATA);
+	if (!mgmt)
+		mask_fc &= ~cpu_to_le16(0x0070);
+	mask_fc |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);
+
+	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	len_a = hdrlen - 2;
+	a4_included = ieee80211_has_a4(hdr->frame_control);
+
+	if (ieee80211_is_data_qos(hdr->frame_control))
+		qos_tid = *ieee80211_get_qos_ctl(hdr) & IEEE80211_QOS_CTL_TID_MASK;
+	else
+		qos_tid = 0;
+
+	data_len = skb->len - hdrlen - CCMP_HDR_LEN;
+	if (encrypted)
+		data_len -= CCMP_MIC_LEN;
+
+	/* First block, b_0 */
+	b_0[0] = 0x59; /* flags: Adata: 1, M: 011, L: 001 */
+	/* Nonce: Nonce Flags | A2 | PN
+	 * Nonce Flags: Priority (b0..b3) | Management (b4) | Reserved (b5..b7)
+	 */
+	b_0[1] = qos_tid | (mgmt << 4);
+	memcpy(&b_0[2], hdr->addr2, ETH_ALEN);
+	memcpy(&b_0[8], pn, CCMP_PN_LEN);
+	/* l(m) */
+	put_unaligned_be16(data_len, &b_0[14]);
+
+	/* AAD (extra authenticate-only data) / masked 802.11 header
+	 * FC | A1 | A2 | A3 | SC | [A4] | [QC] */
+	put_unaligned_be16(len_a, &aad[0]);
+	put_unaligned(mask_fc, (__le16 *)&aad[2]);
+	memcpy(&aad[4], &hdr->addr1, 3 * ETH_ALEN);
+
+	/* Mask Seq#, leave Frag# */
+	aad[22] = *((u8 *) &hdr->seq_ctrl) & 0x0f;
+	aad[23] = 0;
+
+	if (a4_included) {
+		memcpy(&aad[24], hdr->addr4, ETH_ALEN);
+		aad[30] = qos_tid;
+		aad[31] = 0;
+	} else {
+		memset(&aad[24], 0, ETH_ALEN + IEEE80211_QOS_CTL_LEN);
+		aad[24] = qos_tid;
+	}
+}
+
+
+static inline void ccmp_pn2hdr(u8 *hdr, u8 *pn, int key_id)
+{
+	hdr[0] = pn[5];
+	hdr[1] = pn[4];
+	hdr[2] = 0;
+	hdr[3] = 0x20 | (key_id << 6);
+	hdr[4] = pn[3];
+	hdr[5] = pn[2];
+	hdr[6] = pn[1];
+	hdr[7] = pn[0];
+}
+
+
+static inline void ccmp_hdr2pn(u8 *pn, u8 *hdr)
+{
+	pn[0] = hdr[7];
+	pn[1] = hdr[6];
+	pn[2] = hdr[5];
+	pn[3] = hdr[4];
+	pn[4] = hdr[1];
+	pn[5] = hdr[0];
+}
+
+
+static int ccmp_encrypt_skb(struct ieee80211_tx_data *tx, struct sk_buff *skb)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	struct ieee80211_key *key = tx->key;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	int hdrlen, len, tail;
+	u8 *pos;
+	u8 pn[6];
+	u64 pn64;
+	u8 scratch[6 * AES_BLOCK_SIZE];
+
+	if (info->control.hw_key &&
+	    !(info->control.hw_key->flags & IEEE80211_KEY_FLAG_GENERATE_IV)) {
+		/*
+		 * hwaccel has no need for preallocated room for CCMP
+		 * header or MIC fields
+		 */
+		return 0;
+	}
+
+	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	len = skb->len - hdrlen;
+
+	if (info->control.hw_key)
+		tail = 0;
+	else
+		tail = CCMP_MIC_LEN;
+
+	if (WARN_ON(skb_tailroom(skb) < tail ||
+		    skb_headroom(skb) < CCMP_HDR_LEN))
+		return -1;
+
+	pos = skb_push(skb, CCMP_HDR_LEN);
+	memmove(pos, pos + CCMP_HDR_LEN, hdrlen);
+	hdr = (struct ieee80211_hdr *) pos;
+	pos += hdrlen;
+
+	pn64 = atomic64_inc_return(&key->u.ccmp.tx_pn);
+
+	pn[5] = pn64;
+	pn[4] = pn64 >> 8;
+	pn[3] = pn64 >> 16;
+	pn[2] = pn64 >> 24;
+	pn[1] = pn64 >> 32;
+	pn[0] = pn64 >> 40;
+
+	ccmp_pn2hdr(pos, pn, key->conf.keyidx);
+
+	/* hwaccel - with software CCMP header */
+	if (info->control.hw_key)
+		return 0;
+
+	pos += CCMP_HDR_LEN;
+	ccmp_special_blocks(skb, pn, scratch, 0);
+	mac80211_aes_ccm_encrypt(key->u.ccmp.tfm, scratch, pos, len,
+				  pos, skb_put(skb, CCMP_MIC_LEN));
+
+	return 0;
+}
+
+
+ieee80211_tx_result
+mac80211_crypto_ccmp_encrypt(struct ieee80211_tx_data *tx)
+{
+	struct sk_buff *skb = tx->skb;
+
+	mac80211_tx_set_protected(tx);
+
+	do {
+		if (ccmp_encrypt_skb(tx, skb) < 0)
+			return TX_DROP;
+	} while ((skb = skb->next));
+
+	return TX_CONTINUE;
+}
+
+
+ieee80211_rx_result
+mac80211_crypto_ccmp_decrypt(struct ieee80211_rx_data *rx)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;
+	int hdrlen;
+	struct ieee80211_key *key = rx->key;
+	struct sk_buff *skb = rx->skb;
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
+	u8 pn[CCMP_PN_LEN];
+	int data_len;
+	int queue;
+	static const u8 zero_pn[6] = {0};
+
+	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+
+	if (!ieee80211_is_data(hdr->frame_control) &&
+	    !ieee80211_is_robust_mgmt_frame(skb))
+		return RX_CONTINUE;
+
+	data_len = skb->len - hdrlen - CCMP_HDR_LEN - CCMP_MIC_LEN;
+	if (!rx->sta || data_len < 0)
+		return RX_DROP_UNUSABLE;
+
+	ccmp_hdr2pn(pn, skb->data + hdrlen);
+
+	queue = rx->security_idx;
+
+    /*Fix bug for first encrypt packet drop after 8021x, the bug makes dhcp process slow.*/
+	if ((memcmp(key->u.ccmp.rx_pn[queue], zero_pn, CCMP_PN_LEN) == 0) &&
+		(memcmp(pn, zero_pn, CCMP_PN_LEN) == 0)) {
+		/*do nothing*/
+    } else if (memcmp(pn, key->u.ccmp.rx_pn[queue], CCMP_PN_LEN) <= 0) {
+		key->u.ccmp.replays++;
+		return RX_DROP_UNUSABLE;
+	}
+
+	if (!(status->flag & RX_FLAG_DECRYPTED)) {
+		u8 scratch[6 * AES_BLOCK_SIZE];
+		/* hardware didn't decrypt/verify MIC */
+		ccmp_special_blocks(skb, pn, scratch, 1);
+
+		if (mac80211_aes_ccm_decrypt(
+			    key->u.ccmp.tfm, scratch,
+			    skb->data + hdrlen + CCMP_HDR_LEN, data_len,
+			    skb->data + skb->len - CCMP_MIC_LEN,
+			    skb->data + hdrlen + CCMP_HDR_LEN))
+			return RX_DROP_UNUSABLE;
+	}
+
+	/* As long as u.ccmp.rx_pn and u.ccmp.prev_rx_pn are equal, no
+	race condition induced.
+	It is seen that with Cisco AP and with PTK re-negotiation feature
+	enabled on Cisco to do key-negotiaton periodically, even after the
+	RX PN is reset by the supplicant, at MAC, we still keep getting
+	previous RX PN packets.
+	This is due to race condition when this feature is enabled with
+	throughput test and is introduced because of the combination of
+	different TIDs used for data and EAPOL packets and aggregation.
+	The RX PN gets reset to lower value after a while and at that time
+	the RX PN value becomes lower then the maintained current PN at MAC.
+	As a result, the replay detection code chips in and starts dropping all
+	packets till the PN re-match. This causes throughput to stall
+	intermittently for the duration till RX PN match with current PN.
+	So to take care of this we maintain u.ccmp.prev_rx_pn, which doesn't get
+	reset when new PTK is plumbed by supplicant and use it for detecting
+	this transition i.e. from higher PN to lower PN and once this situation
+	happens start updating u.ccmp.rx_pn and thereafter u.ccmp.rx_pn and
+	u.ccmp.prev_rx_pn should be same. In normal scenario, i.e. no new key
+	plumbed both counters should be same. */
+	if ((memcmp(key->u.ccmp.prev_rx_pn[queue],
+		key->u.ccmp.rx_pn[queue], CCMP_PN_LEN) == 0) ||
+		(memcmp(key->u.ccmp.prev_rx_pn[queue], pn, CCMP_PN_LEN) > 0)) {
+		memcpy(key->u.ccmp.rx_pn[queue], pn, CCMP_PN_LEN);
+		memcpy(key->u.ccmp.prev_rx_pn[queue], pn, CCMP_PN_LEN);
+	}
+
+	/* If u.ccmp.rx_pn gets reset to zero due to PTK re-negotiaton then
+	don't update it and just keep updating the u.ccmp.prev_rx_pn.
+	This is to detect the transition that will happen later i.e. from higher
+	RX PN to lower RX PN in case of race condition scenario. */
+	if (memcmp(key->u.ccmp.rx_pn[queue], zero_pn, CCMP_PN_LEN) == 0)
+		memcpy(key->u.ccmp.prev_rx_pn[queue], pn, CCMP_PN_LEN);
+
+	/* Remove CCMP header and MIC */
+	skb_trim(skb, skb->len - CCMP_MIC_LEN);
+	memmove(skb->data + CCMP_HDR_LEN, skb->data, hdrlen);
+	skb_pull(skb, CCMP_HDR_LEN);
+
+	return RX_CONTINUE;
+}
+
+
+static void bip_aad(struct sk_buff *skb, u8 *aad)
+{
+	/* BIP AAD: FC(masked) || A1 || A2 || A3 */
+
+	/* FC type/subtype */
+	aad[0] = skb->data[0];
+	/* Mask FC Retry, PwrMgt, MoreData flags to zero */
+	aad[1] = skb->data[1] & ~(BIT(4) | BIT(5) | BIT(6));
+	/* A1 || A2 || A3 */
+	memcpy(aad + 2, skb->data + 4, 3 * ETH_ALEN);
+}
+
+
+static inline void bip_ipn_set64(u8 *d, u64 pn)
+{
+	*d++ = pn;
+	*d++ = pn >> 8;
+	*d++ = pn >> 16;
+	*d++ = pn >> 24;
+	*d++ = pn >> 32;
+	*d = pn >> 40;
+}
+
+static inline void bip_ipn_swap(u8 *d, const u8 *s)
+{
+	*d++ = s[5];
+	*d++ = s[4];
+	*d++ = s[3];
+	*d++ = s[2];
+	*d++ = s[1];
+	*d = s[0];
+}
+
+
+ieee80211_tx_result
+mac80211_crypto_aes_cmac_encrypt(struct ieee80211_tx_data *tx)
+{
+	struct sk_buff *skb = tx->skb;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	struct ieee80211_key *key = tx->key;
+	struct ieee80211_mmie *mmie;
+	u8 aad[20];
+	u64 pn64;
+
+	if (info->control.hw_key)
+		return 0;
+
+	if (WARN_ON(skb_tailroom(skb) < sizeof(*mmie)))
+		return TX_DROP;
+
+	mmie = (struct ieee80211_mmie *) skb_put(skb, sizeof(*mmie));
+	mmie->element_id = WLAN_EID_MMIE;
+	mmie->length = sizeof(*mmie) - 2;
+	mmie->key_id = cpu_to_le16(key->conf.keyidx);
+
+	/* PN = PN + 1 */
+	pn64 = atomic64_inc_return(&key->u.aes_cmac.tx_pn);
+
+	bip_ipn_set64(mmie->sequence_number, pn64);
+
+	bip_aad(skb, aad);
+
+	/*
+	 * MIC = AES-128-CMAC(IGTK, AAD || Management Frame Body || MMIE, 64)
+	 */
+	mac80211_aes_cmac(key->u.aes_cmac.tfm, aad,
+			   skb->data + 24, skb->len - 24, mmie->mic);
+
+	return TX_CONTINUE;
+}
+
+
+ieee80211_rx_result
+mac80211_crypto_aes_cmac_decrypt(struct ieee80211_rx_data *rx)
+{
+	struct sk_buff *skb = rx->skb;
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
+	struct ieee80211_key *key = rx->key;
+	struct ieee80211_mmie *mmie;
+	u8 aad[20], mic[8], ipn[6];
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+
+	if (!ieee80211_is_mgmt(hdr->frame_control))
+		return RX_CONTINUE;
+
+	if (skb->len < 24 + sizeof(*mmie))
+		return RX_DROP_UNUSABLE;
+
+	mmie = (struct ieee80211_mmie *)
+		(skb->data + skb->len - sizeof(*mmie));
+	if (mmie->element_id != WLAN_EID_MMIE ||
+	    mmie->length != sizeof(*mmie) - 2)
+		return RX_DROP_UNUSABLE; /* Invalid MMIE */
+
+	bip_ipn_swap(ipn, mmie->sequence_number);
+
+	if (memcmp(ipn, key->u.aes_cmac.rx_pn, 6) <= 0) {
+		key->u.aes_cmac.replays++;
+		return RX_DROP_UNUSABLE;
+	}
+
+	if (!(status->flag & RX_FLAG_DECRYPTED)) {
+		/* hardware didn't decrypt/verify MIC */
+		bip_aad(skb, aad);
+		mac80211_aes_cmac(key->u.aes_cmac.tfm, aad,
+				   skb->data + 24, skb->len - 24, mic);
+		if (memcmp(mic, mmie->mic, sizeof(mmie->mic)) != 0) {
+			key->u.aes_cmac.icverrors++;
+			return RX_DROP_UNUSABLE;
+		}
+	}
+
+	memcpy(key->u.aes_cmac.rx_pn, ipn, 6);
+
+	/* Remove MMIE */
+	skb_trim(skb, skb->len - sizeof(*mmie));
+
+	return RX_CONTINUE;
+}
diff -Naurp a/drivers/net/wireless/xr829/umac/wpa.h b/drivers/net/wireless/xr829/umac/wpa.h
--- a/drivers/net/wireless/xr829/umac/wpa.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/umac/wpa.h	2022-08-27 01:22:42.962539893 +0300
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2002-2004, Instant802 Networks, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef WPA_H
+#define WPA_H
+
+#include <linux/skbuff.h>
+#include <linux/types.h>
+#include "ieee80211_i.h"
+
+ieee80211_tx_result
+mac80211_tx_h_xrmac_michael_mic_add(struct ieee80211_tx_data *tx);
+ieee80211_rx_result
+ieee80211_rx_h_xrmac_michael_mic_verify(struct ieee80211_rx_data *rx);
+
+ieee80211_tx_result
+mac80211_crypto_tkip_encrypt(struct ieee80211_tx_data *tx);
+ieee80211_rx_result
+mac80211_crypto_tkip_decrypt(struct ieee80211_rx_data *rx);
+
+ieee80211_tx_result
+mac80211_crypto_ccmp_encrypt(struct ieee80211_tx_data *tx);
+ieee80211_rx_result
+mac80211_crypto_ccmp_decrypt(struct ieee80211_rx_data *rx);
+
+ieee80211_tx_result
+mac80211_crypto_aes_cmac_encrypt(struct ieee80211_tx_data *tx);
+ieee80211_rx_result
+mac80211_crypto_aes_cmac_decrypt(struct ieee80211_rx_data *rx);
+
+#endif /* WPA_H */
diff -Naurp a/drivers/net/wireless/xr829/wlan/ap.c b/drivers/net/wireless/xr829/wlan/ap.c
--- a/drivers/net/wireless/xr829/wlan/ap.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/ap.c	2022-08-27 01:22:42.962539893 +0300
@@ -0,0 +1,2291 @@
+/*
+ * STA and AP APIs for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "xradio.h"
+#include "sta.h"
+#include "ap.h"
+#include "bh.h"
+#include "net/mac80211.h"
+
+#define XRADIO_LINK_ID_GC_TIMEOUT        ((unsigned long)(10 * HZ))
+#define XRADIO_ENABLE_ARP_FILTER_OFFLOAD  3
+
+#ifndef ERP_INFO_BYTE_OFFSET
+#define ERP_INFO_BYTE_OFFSET 2
+#endif
+
+#ifdef IPV6_FILTERING
+#define XRADIO_ENABLE_NDP_FILTER_OFFLOAD	3
+#endif /*IPV6_FILTERING */
+
+static int xradio_upload_beacon(struct xradio_vif *priv);
+#ifdef PROBE_RESP_EXTRA_IE
+static int xradio_upload_proberesp(struct xradio_vif *priv);
+#endif
+static int xradio_upload_pspoll(struct xradio_vif *priv);
+static int xradio_upload_null(struct xradio_vif *priv);
+static int xradio_upload_qosnull(struct xradio_vif *priv);
+static int xradio_start_ap(struct xradio_vif *priv);
+static int xradio_update_beaconing(struct xradio_vif *priv);
+/*
+static int xradio_enable_beaconing(struct xradio_vif *priv,
+				   bool enable);
+*/
+static void __xradio_sta_notify(struct xradio_vif *priv,
+				enum sta_notify_cmd notify_cmd, int link_id);
+
+/* ******************************************************************** */
+/* AP API */
+int xradio_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		   struct ieee80211_sta *sta)
+{
+	struct xradio_sta_priv *sta_priv =
+	    (struct xradio_sta_priv *)&sta->drv_priv;
+	struct xradio_vif *priv = xrwl_get_vif_from_ieee80211(vif);
+	struct xradio_link_entry *entry;
+	struct sk_buff *skb;
+#ifdef AP_AGGREGATE_FW_FIX
+	struct xradio_common *hw_priv = hw->priv;
+#endif
+
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	if (!atomic_read(&priv->enabled)) {
+		ap_printk(XRADIO_DBG_NIY, "%s vif(type=%d) is not enable!\n",
+				__func__, vif->type);
+		return 0;
+	}
+
+#ifdef P2P_MULTIVIF
+	SYS_WARN(priv->if_id == XRWL_GENERIC_IF_ID);
+#endif
+
+	if (priv->mode != NL80211_IFTYPE_AP) {
+		return 0;
+	}
+
+	sta_priv->priv = priv;
+	sta_priv->link_id = xradio_find_link_id(priv, sta->addr);
+	if (SYS_WARN(!sta_priv->link_id)) {
+		/* Impossible error */
+		ap_printk(XRADIO_DBG_ERROR, "No more link IDs available.\n");
+		return -ENOENT;
+	}
+
+	entry = &priv->link_id_db[sta_priv->link_id - 1];
+	spin_lock_bh(&priv->ps_state_lock);
+	if ((sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_MASK) ==
+	    IEEE80211_WMM_IE_STA_QOSINFO_AC_MASK) {
+		priv->sta_asleep_mask |= BIT(sta_priv->link_id);
+	}
+	entry->status = XRADIO_LINK_HARD;
+	while ((skb = skb_dequeue(&entry->rx_queue)))
+		mac80211_rx_irqsafe(priv->hw, skb);
+	spin_unlock_bh(&priv->ps_state_lock);
+
+#ifdef AP_AGGREGATE_FW_FIX
+	hw_priv->connected_sta_cnt++;
+	if (hw_priv->connected_sta_cnt > 1 &&
+		WSM_VERSION_BF(hw_priv->wsm_caps, 8, 39)) {
+		wsm_lock_tx(hw_priv);
+		SYS_WARN(wsm_set_block_ack_policy(hw_priv,
+						  XRADIO_TX_BLOCK_ACK_DISABLED_FOR_ALL_TID,
+						  XRADIO_RX_BLOCK_ACK_DISABLED_FOR_ALL_TID,
+						  priv->if_id));
+		wsm_unlock_tx(hw_priv);
+		ap_printk(XRADIO_DBG_WARN, "%s: disable BA.\n", __func__);
+	}
+#endif
+
+	return 0;
+}
+
+int xradio_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		      struct ieee80211_sta *sta)
+{
+	struct xradio_common *hw_priv = hw->priv;
+	struct xradio_sta_priv *sta_priv =
+	    (struct xradio_sta_priv *)&sta->drv_priv;
+	struct xradio_vif *priv = xrwl_get_vif_from_ieee80211(vif);
+	struct xradio_link_entry *entry;
+	int suspend_lock_state;
+
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	suspend_lock_state = atomic_cmpxchg(&hw_priv->suspend_lock_state,
+								XRADIO_SUSPEND_LOCK_IDEL, XRADIO_SUSPEND_LOCK_OTHERS);
+	if (suspend_lock_state == XRADIO_SUSPEND_LOCK_SUSPEND) {
+		sta_printk(XRADIO_DBG_WARN,
+				"%s:refuse because of suspend\n", __func__);
+		return -EBUSY;
+	}
+	down(&hw_priv->conf_lock);
+	atomic_set(&hw_priv->suspend_lock_state, XRADIO_SUSPEND_LOCK_IDEL);
+
+	if (!atomic_read(&priv->enabled)) {
+		up(&hw_priv->conf_lock);
+		ap_printk(XRADIO_DBG_NIY, "%s vif(type=%d) is not enable!\n",
+				__func__, vif->type);
+		return 0;
+	}
+
+#ifdef P2P_MULTIVIF
+	SYS_WARN(priv->if_id == XRWL_GENERIC_IF_ID);
+#endif
+
+	if (priv->mode != NL80211_IFTYPE_AP || !sta_priv->link_id) {
+		up(&hw_priv->conf_lock);
+		ap_printk(XRADIO_DBG_NIY, "no station to remove\n");
+		return 0;
+	}
+
+	entry = &priv->link_id_db[sta_priv->link_id - 1];
+	spin_lock_bh(&priv->ps_state_lock);
+	entry->status = XRADIO_LINK_RESERVE;
+	entry->timestamp = jiffies;
+	wsm_lock_tx_async(hw_priv);
+	if (queue_work(hw_priv->workqueue, &priv->link_id_work) <= 0)
+		wsm_unlock_tx(hw_priv);
+	spin_unlock_bh(&priv->ps_state_lock);
+	up(&hw_priv->conf_lock);
+	flush_workqueue(hw_priv->workqueue);
+	flush_workqueue(hw_priv->spare_workqueue);
+
+#ifdef AP_AGGREGATE_FW_FIX
+	hw_priv->connected_sta_cnt--;
+	if (hw_priv->connected_sta_cnt <= 1 &&
+		WSM_VERSION_BF(hw_priv->wsm_caps, 8, 39)) {
+		if ((priv->if_id != 1) ||
+		    ((priv->if_id == 1) && hw_priv->is_go_thru_go_neg)) {
+			wsm_lock_tx(hw_priv);
+			SYS_WARN(wsm_set_block_ack_policy(hw_priv,
+							  XRADIO_TX_BLOCK_ACK_ENABLED_FOR_ALL_TID,
+							  XRADIO_RX_BLOCK_ACK_ENABLED_FOR_ALL_TID,
+							  priv->if_id));
+			wsm_unlock_tx(hw_priv);
+		}
+	}
+#endif
+
+	return 0;
+}
+
+static void __xradio_sta_notify(struct xradio_vif *priv,
+				enum sta_notify_cmd notify_cmd, int link_id)
+{
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	u32 bit, prev;
+
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	/* Zero link id means "for all link IDs" */
+	if (link_id)
+		bit = BIT(link_id);
+	else if (WARN_ON_ONCE(notify_cmd != STA_NOTIFY_AWAKE))
+		bit = 0;
+	else
+		bit = priv->link_id_map;
+	prev = priv->sta_asleep_mask & bit;
+
+	switch (notify_cmd) {
+	case STA_NOTIFY_SLEEP:
+		if (!prev) {
+			if (priv->buffered_multicasts && !priv->sta_asleep_mask)
+				queue_work(hw_priv->workqueue,
+					   &priv->multicast_start_work);
+			priv->sta_asleep_mask |= bit;
+			ap_printk(XRADIO_DBG_NIY, "%s STAs sleep: 0x%08X\n",
+				__func__, bit);
+		}
+		break;
+	case STA_NOTIFY_AWAKE:
+		if (prev) {
+			priv->sta_asleep_mask &= ~bit;
+			priv->pspoll_mask &= ~bit;
+			if (priv->tx_multicast && link_id &&
+			    !priv->sta_asleep_mask)
+				queue_work(hw_priv->workqueue,
+					   &priv->multicast_stop_work);
+			xradio_proc_wakeup(hw_priv);
+			ap_printk(XRADIO_DBG_NIY, "%s STAs awake: 0x%08X\n",
+				__func__, bit);
+		}
+		break;
+	}
+}
+
+void xradio_sta_notify(struct ieee80211_hw *dev,
+		       struct ieee80211_vif *vif,
+		       enum sta_notify_cmd notify_cmd,
+		       struct ieee80211_sta *sta)
+{
+	struct xradio_vif *priv = xrwl_get_vif_from_ieee80211(vif);
+	struct xradio_sta_priv *sta_priv =
+	    (struct xradio_sta_priv *)&sta->drv_priv;
+
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	if (!atomic_read(&priv->enabled)) {
+		ap_printk(XRADIO_DBG_NIY, "%s vif(type=%d) is not enable!\n",
+				__func__, vif->type);
+		return ;
+	}
+
+#ifdef P2P_MULTIVIF
+	SYS_WARN(priv->if_id == XRWL_GENERIC_IF_ID);
+#endif
+	spin_lock_bh(&priv->ps_state_lock);
+	__xradio_sta_notify(priv, notify_cmd, sta_priv->link_id);
+	spin_unlock_bh(&priv->ps_state_lock);
+}
+
+static void xradio_ps_notify(struct xradio_vif *priv, int link_id, bool ps)
+{
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (link_id > MAX_STA_IN_AP_MODE) {
+		ap_printk(XRADIO_DBG_WARN, "link_id is invalid=%d\n", link_id);
+		return;
+	}
+
+	ap_printk(XRADIO_DBG_NIY, "%s for LinkId: %d. STAs asleep: %.8X\n",
+		  ps ? "Stop" : "Start", link_id, priv->sta_asleep_mask);
+
+	/* TODO:COMBO: __xradio_sta_notify changed. */
+	__xradio_sta_notify(priv, ps ? STA_NOTIFY_SLEEP : STA_NOTIFY_AWAKE,
+			    link_id);
+}
+
+static int xradio_set_tim_impl(struct xradio_vif *priv, bool aid0_bit_set)
+{
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	struct sk_buff *skb;
+	struct wsm_update_ie update_ie = {
+		.what = WSM_UPDATE_IE_BEACON,
+		.count = 1,
+	};
+	u16 tim_offset, tim_length;
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	ap_printk(XRADIO_DBG_MSG, "%s mcast: %s.\n", __func__,
+		      aid0_bit_set ? "ena" : "dis");
+
+	skb = mac80211_beacon_get_tim(priv->hw, priv->vif, &tim_offset,
+				&tim_length);
+	if (!skb) {
+		__xradio_flush(hw_priv, true, priv->if_id);
+		return -ENOENT;
+	}
+
+	if (tim_offset && tim_length >= 6) {
+		/* Ignore DTIM count from mac80211:
+		 * firmware handles DTIM internally. */
+		skb->data[tim_offset + 2] = 0;
+
+		/* Set/reset aid0 bit */
+		if (aid0_bit_set)
+			skb->data[tim_offset + 4] |= 1;
+		else
+			skb->data[tim_offset + 4] &= ~1;
+	}
+
+	update_ie.ies = &skb->data[tim_offset];
+	update_ie.length = tim_length;
+	/*filter same tim info*/
+	if (memcmp(priv->last_tim, update_ie.ies, tim_length)) {
+		SYS_WARN(wsm_update_ie(hw_priv, &update_ie, priv->if_id));
+		memcpy(priv->last_tim, update_ie.ies, tim_length);
+		ap_printk(XRADIO_DBG_MSG, "%02x %02x %02x %02x %02x %02x\n",
+			  update_ie.ies[0], update_ie.ies[1], update_ie.ies[2],
+			  update_ie.ies[3], update_ie.ies[4], update_ie.ies[5]);
+	}
+
+	dev_kfree_skb(skb);
+
+	return 0;
+}
+
+void xradio_set_tim_work(struct work_struct *work)
+{
+	struct xradio_vif *priv =
+	    container_of(work, struct xradio_vif, set_tim_work);
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	xradio_set_tim_impl(priv, priv->aid0_bit_set);
+}
+
+int xradio_set_tim(struct ieee80211_hw *dev, struct ieee80211_sta *sta,
+		   bool set)
+{
+	struct xradio_sta_priv *sta_priv =
+	    (struct xradio_sta_priv *)&sta->drv_priv;
+	struct xradio_vif *priv = sta_priv->priv;
+
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	if (!atomic_read(&priv->enabled)) {
+		ap_printk(XRADIO_DBG_WARN, "%s vif is not enable!\n", __func__);
+		return 0;
+	}
+
+#ifdef P2P_MULTIVIF
+	SYS_WARN(priv->if_id == XRWL_GENERIC_IF_ID);
+#endif
+	SYS_WARN(priv->mode != NL80211_IFTYPE_AP);
+	queue_work(priv->hw_priv->workqueue, &priv->set_tim_work);
+	return 0;
+}
+
+void xradio_set_cts_work(struct work_struct *work)
+{
+	struct xradio_vif *priv =
+	    container_of(work, struct xradio_vif, set_cts_work.work);
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	u8 erp_ie[3] = { WLAN_EID_ERP_INFO, 0x1, 0 };
+	struct wsm_update_ie update_ie = {
+		.what = WSM_UPDATE_IE_BEACON,
+		.count = 1,
+		.ies = erp_ie,
+		.length = 3,
+	};
+	u32 erp_info;
+	__le32 use_cts_prot;
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	down(&hw_priv->conf_lock);
+	erp_info = priv->erp_info;
+	up(&hw_priv->conf_lock);
+	use_cts_prot = (erp_info & WLAN_ERP_USE_PROTECTION) ?
+			__cpu_to_le32(1) : 0;
+
+	erp_ie[ERP_INFO_BYTE_OFFSET] = erp_info;
+
+	ap_printk(XRADIO_DBG_MSG, "ERP information 0x%x\n", erp_info);
+
+	/* TODO:COMBO: If 2 interfaces are on the same channel they share
+	   the same ERP values */
+	SYS_WARN(wsm_write_mib(hw_priv, WSM_MIB_ID_NON_ERP_PROTECTION,
+			       &use_cts_prot, sizeof(use_cts_prot),
+			       priv->if_id));
+	/* If STA Mode update_ie is not required */
+	if (priv->mode != NL80211_IFTYPE_STATION &&
+		priv->mode != NL80211_IFTYPE_P2P_DEVICE) {
+		SYS_WARN(wsm_update_ie(hw_priv, &update_ie, priv->if_id));
+	}
+
+	return;
+}
+
+static int xradio_set_btcoexinfo(struct xradio_vif *priv)
+{
+	struct wsm_override_internal_txrate arg;
+	int ret = 0;
+
+#ifdef SUPPORT_HT40
+
+	u8 rateIndex = 0x0;
+
+#endif
+
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (priv->mode == NL80211_IFTYPE_STATION ||
+		priv->mode == NL80211_IFTYPE_P2P_DEVICE) {
+		/* Plumb PSPOLL and NULL template */
+		SYS_WARN(xradio_upload_pspoll(priv));
+		SYS_WARN(xradio_upload_null(priv));
+	} else {
+		return 0;
+	}
+
+	memset(&arg, 0, sizeof(struct wsm_override_internal_txrate));
+
+	if (!priv->vif->p2p) {
+		/* STATION mode */
+		if (priv->bss_params.operationalRateSet & ~0xF) {
+			ap_printk(XRADIO_DBG_NIY, "STA has ERP rates\n");
+			/* G or BG mode */
+
+#ifdef SUPPORT_HT40
+
+			rateIndex =
+			(__ffs(priv->bss_params.operationalRateSet & ~0xF));
+
+			arg.internalTxRateEntry =
+				xradio_get_rate_entry(priv->hw_priv, 0, 0,
+								rateIndex);
+
+#else
+
+			arg.internalTxRate =
+			    (__ffs(priv->bss_params.operationalRateSet & ~0xF));
+
+#endif
+		} else {
+			ap_printk(XRADIO_DBG_NIY, "STA has non ERP rates\n");
+			/* B only mode */
+
+#ifdef SUPPORT_HT40
+
+			rateIndex =
+			(__ffs(priv->association_mode.basicRateSet));
+
+			arg.internalTxRateEntry =
+				xradio_get_rate_entry(priv->hw_priv, 0, 0,
+								rateIndex);
+
+#else
+
+			arg.internalTxRate =
+			    (__ffs(priv->association_mode.basicRateSet));
+
+#endif
+		}
+
+#ifdef SUPPORT_HT40
+
+		rateIndex = (__ffs(priv->association_mode.basicRateSet));
+		arg.nonErpInterTxRateEntry =
+			xradio_get_rate_entry(priv->hw_priv, 0, 0, rateIndex);
+
+#else
+		arg.nonErpInternalTxRate =
+		    (__ffs(priv->association_mode.basicRateSet));
+
+#endif
+	} else {
+		/* P2P mode */
+
+#ifdef SUPPORT_HT40
+
+		rateIndex = (__ffs(priv->bss_params.operationalRateSet & ~0xF));
+
+		arg.internalTxRateEntry =
+			xradio_get_rate_entry(priv->hw_priv, 0, 0, rateIndex);
+
+		arg.nonErpInterTxRateEntry = arg.internalTxRateEntry;
+
+#else
+
+		arg.internalTxRate =
+		    (__ffs(priv->bss_params.operationalRateSet & ~0xF));
+		arg.nonErpInternalTxRate =
+		    (__ffs(priv->bss_params.operationalRateSet & ~0xF));
+
+#endif
+
+	}
+
+#ifdef SUPPORT_HT40
+
+	ap_printk(XRADIO_DBG_NIY, "[STA] BTCOEX_INFO" \
+		"MODE %d, internalTxRateEntry : " \
+		"0x%04x, nonErpInterTxRateEntry: 0x%04x\n",
+		priv->mode, arg.internalTxRateEntry,
+		arg.nonErpInterTxRateEntry);
+
+#else
+
+	ap_printk(XRADIO_DBG_NIY, "BTCOEX_INFO" "MODE %d, internalTxRate : %x, " \
+		  "nonErpInternalTxRate: %x\n", priv->mode, arg.internalTxRate,
+		  arg.nonErpInternalTxRate);
+
+#endif
+
+	ret = SYS_WARN(wsm_write_mib(xrwl_vifpriv_to_hwpriv(priv),
+				     WSM_MIB_ID_OVERRIDE_INTERNAL_TX_RATE,
+				     &arg, sizeof(arg), priv->if_id));
+
+	return ret;
+}
+
+void xradio_bss_info_changed(struct ieee80211_hw *dev,
+			     struct ieee80211_vif *vif,
+			     struct ieee80211_bss_conf *info, u32 changed)
+{
+	struct xradio_common *hw_priv = dev->priv;
+	struct xradio_vif *priv = xrwl_get_vif_from_ieee80211(vif);
+	int suspend_lock_state;
+
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (hw_priv->bh_error) {
+		ap_printk(XRADIO_DBG_ERROR, "%s bh_error occurs, changed=0x%0x\n",
+			__func__, changed);
+		return;
+	}
+
+#ifdef P2P_MULTIVIF
+	if (priv->if_id == XRWL_GENERIC_IF_ID)
+		return;
+#endif
+
+	suspend_lock_state = atomic_cmpxchg(&hw_priv->suspend_lock_state,
+								XRADIO_SUSPEND_LOCK_IDEL, XRADIO_SUSPEND_LOCK_OTHERS);
+	if (suspend_lock_state == XRADIO_SUSPEND_LOCK_SUSPEND) {
+		ap_printk(XRADIO_DBG_WARN,
+			   "%s:refuse because of suspend\n", __func__);
+		return;
+	}
+
+	down(&hw_priv->conf_lock);
+	atomic_set(&hw_priv->suspend_lock_state, XRADIO_SUSPEND_LOCK_IDEL);
+
+	/*We do somethings first which is not of priv.*/
+	if (changed & BSS_CHANGED_RETRY_LIMITS) {
+		spin_lock_bh(&hw_priv->tx_policy_cache.lock);
+		/*TODO:COMBO: for now it's still handled per hw and kept
+		 * in xradio_common */
+#ifdef ENHANCE_ANTI_INTERFERE
+		hw_priv->long_frame_max_tx_count  = 15;
+		hw_priv->short_frame_max_tx_count = 15;
+#else
+		hw_priv->long_frame_max_tx_count  = info->retry_long;
+		hw_priv->short_frame_max_tx_count =
+				(info->retry_short < 0x0F ? info->retry_short : 0x0F);
+#endif
+
+		hw_priv->hw->max_rate_tries = hw_priv->short_frame_max_tx_count;
+		spin_unlock_bh(&hw_priv->tx_policy_cache.lock);
+		ap_printk(XRADIO_DBG_NIY, "Retry limits: long=%d(%d), short=%d(%d).\n",
+			  hw_priv->short_frame_max_tx_count, info->retry_long,
+			  hw_priv->long_frame_max_tx_count, info->retry_short);
+		/* TBD: I think we don't need tx_policy_force_upload().
+		 * Outdated policies will leave cache in a normal way. */
+		/* SYS_WARN(tx_policy_force_upload(priv)); */
+	}
+
+	/*We check priv before operation of priv.*/
+	if (!atomic_read(&priv->enabled)) {
+		if (changed & ~BSS_CHANGED_RETRY_LIMITS)
+			ap_printk(XRADIO_DBG_WARN, "%s vif(type=%d) is not enable!" \
+					"changed=0x%x\n", __func__, vif->type, changed);
+		up(&hw_priv->conf_lock);
+		return ;
+	}
+
+	if (changed & BSS_CHANGED_BSSID) {
+#ifdef CONFIG_XRADIO_TESTMODE
+		spin_lock_bh(&hw_priv->tsm_lock);
+		if (hw_priv->tsm_info.sta_associated) {
+			unsigned now = jiffies;
+			hw_priv->tsm_info.sta_roamed = 1;
+			if ((now - hw_priv->tsm_info.txconf_timestamp_vo) >
+			    (now - hw_priv->tsm_info.rx_timestamp_vo))
+				hw_priv->tsm_info.use_rx_roaming = 1;
+		} else {
+			hw_priv->tsm_info.sta_associated = 1;
+		}
+		spin_unlock_bh(&hw_priv->tsm_lock);
+#endif /*CONFIG_XRADIO_TESTMODE */
+		memcpy(priv->bssid, info->bssid, ETH_ALEN);
+		xradio_setup_mac_pvif(priv);
+	}
+
+	/* TODO: BSS_CHANGED_IBSS */
+	if (changed & BSS_CHANGED_ARP_FILTER) {
+		struct wsm_arp_ipv4_filter filter = { 0 };
+		int i;
+		ap_printk(XRADIO_DBG_MSG,
+			  "[STA] BSS_CHANGED_ARP_FILTER enabled: %d, cnt: %d\n",
+			  info->arp_filter_enabled, info->arp_addr_cnt);
+
+		if (info->arp_filter_enabled) {
+			if (vif->type == NL80211_IFTYPE_STATION ||
+				vif->type == NL80211_IFTYPE_P2P_DEVICE)
+				filter.enable =
+				    (u32) XRADIO_ENABLE_ARP_FILTER_OFFLOAD;
+			else if (priv->join_status == XRADIO_JOIN_STATUS_AP)
+				filter.enable = (u32) (1 << 1);
+			else
+				filter.enable = 0;
+		}
+
+		/* Currently only one IP address is supported by firmware.
+		 * In case of more IPs arp filtering will be disabled. */
+		if (info->arp_addr_cnt > 0 &&
+		    info->arp_addr_cnt <= WSM_MAX_ARP_IP_ADDRTABLE_ENTRIES) {
+			for (i = 0; i < info->arp_addr_cnt; i++) {
+				filter.ipv4Address[i] = info->arp_addr_list[i];
+				ap_printk(XRADIO_DBG_NIY,
+					  "[STA]addr[%d]: 0x%X\n", i,
+					  filter.ipv4Address[i]);
+			}
+		} else
+			filter.enable = 0;
+
+		if (filter.enable)
+			xradio_set_arpreply(dev, vif);
+
+		priv->filter4.enable = filter.enable;
+		ap_printk(XRADIO_DBG_NIY, "[STA]arp ip filter enable: %d\n",
+			  __le32_to_cpu(filter.enable));
+
+		if (wsm_set_arp_ipv4_filter(hw_priv, &filter, priv->if_id))
+			SYS_WARN(1);
+
+		if (filter.enable &&
+		    (priv->join_status == XRADIO_JOIN_STATUS_STA)) {
+			/* Firmware requires that value for this 1-byte field must
+			 * be specified in units of 500us. Values above the 128ms
+			 * threshold are not supported. */
+			if (info->dynamic_ps_timeout >= 0x80)
+				priv->powersave_mode.fastPsmIdlePeriod = 0xFF;
+			else
+				priv->powersave_mode.fastPsmIdlePeriod =
+				    info->dynamic_ps_timeout << 1;
+
+			ap_printk(XRADIO_DBG_NIY,
+				  "[STA]fastPsmIdle=%d, apPsmChange=%d\n",
+				  priv->powersave_mode.fastPsmIdlePeriod,
+				  priv->powersave_mode.apPsmChangePeriod);
+
+			if (priv->setbssparams_done) {
+				int ret = 0;
+				struct wsm_set_pm pm = priv->powersave_mode;
+				if (priv->user_power_set_true)
+					priv->powersave_mode.pmMode = priv->user_pm_mode;
+				else if ((priv->power_set_true &&
+					 ((priv->powersave_mode.pmMode == WSM_PSM_ACTIVE) ||
+					 (priv->powersave_mode.pmMode == WSM_PSM_PS)))    ||
+					 !priv->power_set_true)
+					priv->powersave_mode.pmMode = WSM_PSM_FAST_PS;
+
+				priv->powersave_mode.pmMode |= WSM_PSM_IP_ALLOCATED;
+				ret = xradio_set_pm(priv, &priv->powersave_mode);
+				priv->powersave_mode.pmMode &= ~WSM_PSM_IP_ALLOCATED;
+				if (ret)
+					priv->powersave_mode = pm;
+			} else {
+				ap_printk(XRADIO_DBG_WARN, "arp_addr_cnt not clear at disconnecting,filter abnormal enable!!!\n");
+			}
+			priv->power_set_true = 0;
+			priv->user_power_set_true = 0;
+		}
+	}
+
+#ifdef IPV6_FILTERING
+	if (changed & BSS_CHANGED_NDP_FILTER) {
+		int i;
+		struct wsm_ndp_ipv6_filter filter = { 0 };
+		u16 *ipv6addr = NULL;
+
+		ap_printk(XRADIO_DBG_MSG,
+			  "[STA] BSS_CHANGED_NDP_FILTER enabled: %d, cnt: %d\n",
+			  info->ndp_filter_enabled, info->ndp_addr_cnt);
+
+		if (info->ndp_filter_enabled) {
+			if (vif->type == NL80211_IFTYPE_STATION ||
+				vif->type == NL80211_IFTYPE_P2P_DEVICE)
+				filter.enable =
+				    (u32) XRADIO_ENABLE_NDP_FILTER_OFFLOAD;
+			else if (vif->type == NL80211_IFTYPE_AP)
+				filter.enable = (u32) (1 << 1);
+			else
+				filter.enable = 0;
+		}
+
+		/* Currently only one IP address is supported by firmware.
+		 * In case of more IPs ndp filtering will be disabled. */
+		if (info->ndp_addr_cnt > 0 &&
+		    info->ndp_addr_cnt <= WSM_MAX_NDP_IP_ADDRTABLE_ENTRIES) {
+			for (i = 0; i < info->ndp_addr_cnt; i++) {
+				filter.ipv6Address[i] = info->ndp_addr_list[i];
+				priv->filter6.ipv6Address[i] = filter.ipv6Address[i];
+				ipv6addr = (u16 *)(&filter.ipv6Address[i]);
+				ap_printk(XRADIO_DBG_MSG,
+					  "[STA] ipv6 addr[%d]: %x:%x:%x:%x:%x:%x:%x:%x\n",
+					  i, cpu_to_be16(*(ipv6addr + 0)),
+					  cpu_to_be16(*(ipv6addr + 1)),
+					  cpu_to_be16(*(ipv6addr + 2)),
+					  cpu_to_be16(*(ipv6addr + 3)),
+					  cpu_to_be16(*(ipv6addr + 4)),
+					  cpu_to_be16(*(ipv6addr + 5)),
+					  cpu_to_be16(*(ipv6addr + 6)),
+					  cpu_to_be16(*(ipv6addr + 7)));
+			}
+		} else {
+			filter.enable = 0;
+			for (i = 0; i < info->ndp_addr_cnt; i++) {
+				ipv6addr = (u16 *) (&info->ndp_addr_list[i]);
+				ap_printk(XRADIO_DBG_MSG,
+					  "[STA] ipv6 addr[%d]: %x:%x:%x:%x:%x:%x:%x:%x\n",
+					  i, cpu_to_be16(*(ipv6addr + 0)),
+					  cpu_to_be16(*(ipv6addr + 1)),
+					  cpu_to_be16(*(ipv6addr + 2)),
+					  cpu_to_be16(*(ipv6addr + 3)),
+					  cpu_to_be16(*(ipv6addr + 4)),
+					  cpu_to_be16(*(ipv6addr + 5)),
+					  cpu_to_be16(*(ipv6addr + 6)),
+					  cpu_to_be16(*(ipv6addr + 7)));
+			}
+		}
+
+		ap_printk(XRADIO_DBG_NIY, "[STA] ndp ip filter enable: %d\n",
+			   __le32_to_cpu(filter.enable));
+
+		if (filter.enable)
+			xradio_set_na(dev, vif);
+
+		priv->filter6.enable = filter.enable;
+
+		if (wsm_set_ndp_ipv6_filter(hw_priv, &filter, priv->if_id))
+			SYS_WARN(1);
+#if 0				/*Commented out to disable Power Save in IPv6 */
+		if (filter.enable
+		    && (priv->join_status == XRADIO_JOIN_STATUS_STA)
+		    && (priv->vif->p2p)
+		    && !(priv->firmware_ps_mode.pmMode & WSM_PSM_FAST_PS)) {
+			if (priv->setbssparams_done) {
+				int ret = 0;
+				struct wsm_set_pm pm = priv->powersave_mode;
+
+				priv->powersave_mode.pmMode = WSM_PSM_FAST_PS;
+				ret = xradio_set_pm(priv, &priv->powersave_mode);
+				if (ret) {
+					priv->powersave_mode = pm;
+				}
+			} else {
+				priv->powersave_mode.pmMode = WSM_PSM_FAST_PS;
+			}
+		}
+#endif
+	}
+#endif /*IPV6_FILTERING */
+
+	if (changed & BSS_CHANGED_BEACON_ENABLED) {
+		priv->enable_beacon = info->enable_beacon;
+		ap_printk(XRADIO_DBG_NIY, "BSS_CHANGED_BEACON_ENABLED %s\n",
+			priv->enable_beacon ? "enable" : "disable");
+	}
+
+	if (changed & BSS_CHANGED_BEACON) {
+		ap_printk(XRADIO_DBG_NIY, "BSS_CHANGED_BEACON(enable=%d)\n",
+			priv->enable_beacon);
+		if (priv->enable_beacon) {
+#ifdef HIDDEN_SSID
+			if (priv->join_status != XRADIO_JOIN_STATUS_AP) {
+				priv->hidden_ssid = info->hidden_ssid;
+				priv->ssid_length = info->ssid_len;
+				ap_printk(XRADIO_DBG_NIY, "hidden_ssid=%d, ssid_len=%zu\n",
+					  info->hidden_ssid, info->ssid_len);
+				if (info->ssid_len) {
+					memcpy(priv->ssid, info->ssid, info->ssid_len);
+					ap_printk(XRADIO_DBG_NIY, "ssid=%s\n", info->ssid);
+				}
+			} else
+				ap_printk(XRADIO_DBG_NIY, "priv->join_status=%d\n",
+					  priv->join_status);
+#endif
+			SYS_WARN(xradio_upload_beacon(priv));
+			SYS_WARN(xradio_update_beaconing(priv));
+		}
+	}
+
+	if (changed & BSS_CHANGED_BEACON_INT) {
+		ap_printk(XRADIO_DBG_NIY, "CHANGED_BEACON_INT\n");
+		/* Restart AP only when connected */
+		if (priv->join_status == XRADIO_JOIN_STATUS_AP)
+			SYS_WARN(xradio_update_beaconing(priv));
+	}
+
+
+	if (changed & BSS_CHANGED_ASSOC) {
+		wsm_lock_tx(hw_priv);
+		priv->wep_default_key_id = -1;
+		wsm_unlock_tx(hw_priv);
+
+		if (!info->assoc /* && !info->ibss_joined */) {
+			priv->cqm_link_loss_count = XRADIO_LINK_LOSS_THOLD_DEF;
+			priv->cqm_beacon_loss_count = XRADIO_BSS_LOSS_THOLD_DEF;
+			priv->cqm_tx_failure_thold = 0;
+		}
+		priv->cqm_tx_failure_count = 0;
+	}
+
+	if (changed &
+	    (BSS_CHANGED_ASSOC        |
+	     BSS_CHANGED_BASIC_RATES  |
+	     BSS_CHANGED_ERP_PREAMBLE |
+	     BSS_CHANGED_HT           |
+	     BSS_CHANGED_ERP_SLOT)) {
+		int is_combo = 0;
+		int i;
+		struct xradio_vif *tmp_priv;
+		ap_printk(XRADIO_DBG_NIY, "BSS_CHANGED_ASSOC.\n");
+		/*Driver is already do unjoin.*/
+		if (priv->if_id == 0 && priv->vif->type == NL80211_IFTYPE_STATION &&
+			priv->join_status == XRADIO_JOIN_STATUS_PASSIVE) {
+			changed &= ~BSS_CHANGED_ASSOC;
+			ap_printk(XRADIO_DBG_WARN, "BSS_CHANGED_ASSOC but driver is unjoined.\n");
+			mac80211_connection_loss(priv->vif);
+		}
+		/* TODO: ibss_joined */
+		if (info->assoc && priv->join_status != XRADIO_JOIN_STATUS_PASSIVE) {
+			struct ieee80211_sta *sta = NULL;
+
+#ifdef SUPPORT_HT40
+			struct phy_mode_cfg PhyModeCfg;
+#endif
+			if (info->dtim_period)
+				priv->join_dtim_period = info->dtim_period;
+			priv->beacon_int = info->beacon_int;
+
+			/* Associated: kill join timeout */
+			cancel_delayed_work(&priv->join_timeout);
+
+			rcu_read_lock();
+			if (info->bssid)
+				sta = mac80211_find_sta(vif, info->bssid);
+			if (sta) {
+				/* TODO:COMBO:Change this once
+				 * mac80211 changes are available */
+				SYS_BUG(!hw_priv->channel);
+				hw_priv->ht_info.ht_cap = sta->ht_cap;
+				priv->bss_params.operationalRateSet =
+				  __cpu_to_le32(xradio_rate_mask_to_wsm(hw_priv,
+						sta->supp_rates[hw_priv->channel->band]));
+				hw_priv->ht_info.channel_type   = info->channel_type;
+				hw_priv->ht_info.operation_mode = info->ht_operation_mode;
+				priv->oper_rates = sta->supp_rates[hw_priv->channel->band];
+			} else {
+				ap_printk(XRADIO_DBG_NIY, "BSS_CHANGED_ASSOC no sta.\n");
+				memset(&hw_priv->ht_info, 0, sizeof(hw_priv->ht_info));
+				priv->bss_params.operationalRateSet = -1;
+				priv->oper_rates = -1;
+			}
+			rcu_read_unlock();
+			priv->htcap = (sta && xradio_is_ht(&hw_priv->ht_info));
+			xradio_for_each_vif(hw_priv, tmp_priv, i) {
+#ifdef P2P_MULTIVIF
+				if ((i == (XRWL_MAX_VIFS - 1)) || !tmp_priv)
+#else
+				if (!tmp_priv)
+#endif
+					continue;
+				if (tmp_priv->join_status >= XRADIO_JOIN_STATUS_STA)
+					is_combo++;
+			}
+
+			if (is_combo > 1) {
+				hw_priv->vif0_throttle = XRWL_HOST_VIF0_11BG_THROTTLE;
+				hw_priv->vif1_throttle = XRWL_HOST_VIF1_11BG_THROTTLE;
+				ap_printk(XRADIO_DBG_WARN, "%sASSOC is_combo %d\n",
+					 (priv->join_status == XRADIO_JOIN_STATUS_STA) ?
+					  "[STA] " : "", hw_priv->vif0_throttle);
+			} else if ((priv->join_status == XRADIO_JOIN_STATUS_STA)
+				   && priv->htcap) {
+				hw_priv->vif0_throttle = XRWL_HOST_VIF0_11N_THROTTLE;
+				hw_priv->vif1_throttle = XRWL_HOST_VIF1_11N_THROTTLE;
+				ap_printk(XRADIO_DBG_WARN, "[STA] ASSOC HTCAP 11N %d\n",
+					  hw_priv->vif0_throttle);
+			} else {
+				hw_priv->vif0_throttle = XRWL_HOST_VIF0_11BG_THROTTLE;
+				hw_priv->vif1_throttle = XRWL_HOST_VIF1_11BG_THROTTLE;
+				ap_printk(XRADIO_DBG_WARN, "ASSOC not_combo 11BG %d\n",
+					  hw_priv->vif0_throttle);
+			}
+
+			if (sta) {
+
+#ifdef SUPPORT_HT40
+
+				__le32 ht_prot = 0;
+
+				if (hw_priv->ht_info.operation_mode & IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT)
+					ht_prot |= cpu_to_le32(WSM_NON_GREENFIELD_STA);
+
+				ht_prot |= cpu_to_le32((hw_priv->ht_info.operation_mode & IEEE80211_HT_OP_MODE_PROTECTION) << 2);
+
+				ap_printk(XRADIO_DBG_WARN, "[HT40][%s]" \
+					"[ht_prot:0x%08x][HtProtMode:0x%04x]" \
+					"[Green:0x%04x]",
+					__func__, ht_prot,
+					hw_priv->ht_info.operation_mode & IEEE80211_HT_OP_MODE_PROTECTION,
+					hw_priv->ht_info.operation_mode & IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);
+
+				WARN_ON(wsm_write_mib(hw_priv,
+					WSM_MID_ID_SET_HT_PROTECTION,
+					&ht_prot, sizeof(ht_prot), priv->if_id));
+
+#else
+
+				__le32 val = 0;
+				if (hw_priv->ht_info.operation_mode &
+				    IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT) {
+					ap_printk(XRADIO_DBG_NIY, "[STA] Non-GF STA present\n");
+					/* Non Green field capable STA */
+					val = __cpu_to_le32(BIT(1));
+				}
+				SYS_WARN(wsm_write_mib(hw_priv, WSM_MID_ID_SET_HT_PROTECTION,
+						       &val, sizeof(val), priv->if_id));
+
+#endif
+
+			}
+
+#ifdef SUPPORT_HT40
+
+			PhyModeCfg.BandCfg = hw_priv->channel->band;
+
+			if (PhyModeCfg.BandCfg == NL80211_BAND_5GHZ)
+				PhyModeCfg.ModemFlags = (MODEM_F_A_OFDM|MODEM_F_N_OFDM);
+			else
+				PhyModeCfg.ModemFlags = (MODEM_F_B_DSSS|MODEM_F_A_OFDM|MODEM_F_N_OFDM);
+
+			if (info->channel_type == NL80211_CHAN_HT40MINUS) {
+				PhyModeCfg.ChWidthCfg = CHAN_WIDTH_40MHz;
+				PhyModeCfg.PriChCfg   = PRIMARY_CH_1ST;
+			} else if (info->channel_type == NL80211_CHAN_HT40PLUS) {
+				PhyModeCfg.ChWidthCfg = CHAN_WIDTH_40MHz;
+				PhyModeCfg.PriChCfg   = PRIMARY_CH_2ND;
+			} else {
+				PhyModeCfg.ChWidthCfg = CHAN_WIDTH_20MHz;
+				PhyModeCfg.PriChCfg   = PRIMARY_CH_1ST;
+			}
+
+			if (info->channel_type == NL80211_CHAN_NO_HT) {
+				PhyModeCfg.ModemFlags &= ~(MODEM_F_N_OFDM);
+				PhyModeCfg.SGI_Enable = false;
+				PhyModeCfg.GF_Enable = false;
+			} else {
+				PhyModeCfg.SGI_Enable = xradio_ht_ShortGI(&hw_priv->ht_info);
+				PhyModeCfg.GF_Enable  = xradio_ht_greenfield(&hw_priv->ht_info);
+			}
+
+			PhyModeCfg.STBC_Enable = false;
+			PhyModeCfg.PreambleCfg = info->use_short_preamble ?
+				WSM_JOIN_PREAMBLE_SHORT :
+				WSM_JOIN_PREAMBLE_LONG;
+
+			priv->association_mode.PhyModeCfg = PhyModeCfg;
+
+			priv->association_mode.flags =
+				WSM_ASSOCIATION_MODE_USE_PHY_MODE_CFG |
+				WSM_ASSOCIATION_MODE_USE_BASIC_RATE_SET |
+				WSM_ASSOCIATION_MODE_USE_MPDU_START_SPACING;
+
+#else
+			priv->association_mode.greenfieldMode =
+			    xradio_ht_greenfield(&hw_priv->ht_info);
+			priv->association_mode.flags =
+			    WSM_ASSOCIATION_MODE_SNOOP_ASSOC_FRAMES |
+			    WSM_ASSOCIATION_MODE_USE_PREAMBLE_TYPE |
+			    WSM_ASSOCIATION_MODE_USE_HT_MODE |
+			    WSM_ASSOCIATION_MODE_USE_BASIC_RATE_SET |
+			    WSM_ASSOCIATION_MODE_USE_MPDU_START_SPACING;
+
+			priv->association_mode.preambleType =
+			  (info->use_short_preamble ? WSM_JOIN_PREAMBLE_SHORT :
+			   WSM_JOIN_PREAMBLE_LONG);
+
+#endif
+
+			priv->association_mode.basicRateSet =
+			    __cpu_to_le32(xradio_rate_mask_to_wsm(hw_priv,
+					  info->basic_rates));
+			priv->base_rates = info->basic_rates;
+			priv->association_mode.mpduStartSpacing =
+			    xradio_ht_ampdu_density(&hw_priv->ht_info);
+
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+			priv->cqm_beacon_loss_count =
+			    info->cqm_beacon_miss_thold;
+			priv->cqm_tx_failure_thold = info->cqm_tx_fail_thold;
+			priv->cqm_tx_failure_count = 0;
+			cancel_delayed_work_sync(&priv->bss_loss_work);
+			cancel_delayed_work_sync(&priv->connection_loss_work);
+#endif /* CONFIG_XRADIO_USE_EXTENSIONS */
+
+			priv->bss_params.beaconLostCount = (priv->cqm_beacon_loss_count ?
+			  priv->cqm_beacon_loss_count : priv->cqm_link_loss_count);
+
+			priv->bss_params.aid = info->aid;
+
+			if (priv->join_dtim_period < 1)
+				priv->join_dtim_period = 1;
+
+#ifdef SUPPORT_HT40
+
+			ap_printk(XRADIO_DBG_WARN, "[HT40][%s]"\
+				"[PhyModeCfg:0x%04x]\n"\
+				"[ModemFlags    :0x%08x]\n"\
+				"[ChWidthCfg    :0x%08x]\n"\
+				"[PriChCfg      :0x%08x]\n"\
+				"[BandCfg       :0x%08x]\n"\
+				"[STBC_Enable   :0x%08x]\n"\
+				"[PreambleCfg   :0x%08x]\n"\
+				"[SGI_Enable    :0x%08x]\n"\
+				"[GF_Enable     :0x%08x]\n",
+				__func__,
+				*(u16 *)&(priv->association_mode.PhyModeCfg),
+				priv->association_mode.PhyModeCfg.ModemFlags,
+				priv->association_mode.PhyModeCfg.ChWidthCfg,
+				priv->association_mode.PhyModeCfg.PriChCfg,
+				priv->association_mode.PhyModeCfg.BandCfg,
+				priv->association_mode.PhyModeCfg.STBC_Enable,
+				priv->association_mode.PhyModeCfg.PreambleCfg,
+				priv->association_mode.PhyModeCfg.SGI_Enable,
+				priv->association_mode.PhyModeCfg.GF_Enable);
+
+			ap_printk(XRADIO_DBG_MSG, "[STA] DTIM %d, "\
+				"interval: %d\n",
+				priv->join_dtim_period, priv->beacon_int);
+
+			ap_printk(XRADIO_DBG_MSG, "[STA] Preamble: %d, "\
+				"Greenfield: %d, Aid: %d, "\
+				"Rates: 0x%.8X, Basic: 0x%.8X\n",
+				priv->association_mode.PhyModeCfg.PreambleCfg,
+				priv->association_mode.PhyModeCfg.GF_Enable,
+				priv->bss_params.aid,
+				priv->bss_params.operationalRateSet,
+				priv->association_mode.basicRateSet);
+
+#else
+
+			ap_printk(XRADIO_DBG_MSG, "[STA] DTIM %d, interval: %d\n",
+				  priv->join_dtim_period, priv->beacon_int);
+			ap_printk(XRADIO_DBG_MSG, "[STA] Preamble: %d, " \
+				  "Greenfield: %d, Aid: %d, " \
+				  "Rates: 0x%.8X, Basic: 0x%.8X\n",
+				  priv->association_mode.preambleType,
+				  priv->association_mode.greenfieldMode,
+				  priv->bss_params.aid,
+				  priv->bss_params.operationalRateSet,
+				  priv->association_mode.basicRateSet);
+
+#endif
+
+			SYS_WARN(wsm_set_association_mode(hw_priv,
+				 &priv->association_mode, priv->if_id));
+			SYS_WARN(wsm_keep_alive_period(hw_priv,
+						       XRADIO_KEEP_ALIVE_PERIOD /* sec */,
+						       priv->if_id));
+			SYS_WARN(wsm_set_bss_params(hw_priv,
+				 &priv->bss_params, priv->if_id));
+			priv->setbssparams_done = true;
+#ifdef XRADIO_USE_LONG_DTIM_PERIOD
+			{
+				int join_dtim_period_extend;
+				if (priv->join_dtim_period <= 3) {
+					join_dtim_period_extend = priv->join_dtim_period * 3;
+				} else if (priv->join_dtim_period <= 5) {
+					join_dtim_period_extend = priv->join_dtim_period * 2;
+				} else {
+					join_dtim_period_extend = priv->join_dtim_period;
+				}
+				SYS_WARN(wsm_set_beacon_wakeup_period(hw_priv,
+					((priv->beacon_int * join_dtim_period_extend) >
+					MAX_BEACON_SKIP_TIME_MS ?
+					1 : join_dtim_period_extend), 0, priv->if_id));
+			}
+#else
+			SYS_WARN(wsm_set_beacon_wakeup_period(hw_priv,
+				 ((priv->beacon_int * priv->join_dtim_period) >
+				 MAX_BEACON_SKIP_TIME_MS ?
+				 1 : priv->join_dtim_period), 0, priv->if_id));
+#endif
+			if (priv->htcap) {
+				wsm_lock_tx(hw_priv);
+				/* Statically enabling block ack for TX/RX */
+				SYS_WARN(wsm_set_block_ack_policy(hw_priv,
+					 hw_priv->ba_tid_mask, hw_priv->ba_tid_mask,
+					 priv->if_id));
+				wsm_unlock_tx(hw_priv);
+			}
+			if (priv->filter4.enable || !(priv->powersave_mode.pmMode&WSM_PSM_PS)) {
+				xradio_set_pm(priv, &priv->powersave_mode);
+			}
+			if (priv->vif->p2p) {
+				ap_printk(XRADIO_DBG_NIY,
+					  "[STA] Setting p2p powersave configuration.\n");
+				SYS_WARN(wsm_set_p2p_ps_modeinfo(hw_priv,
+					 &priv->p2p_ps_modeinfo, priv->if_id));
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+				xradio_notify_noa(priv, XRADIO_NOA_NOTIFICATION_DELAY);
+#endif
+			}
+
+			if (priv->mode == NL80211_IFTYPE_STATION ||
+				priv->mode == NL80211_IFTYPE_P2P_DEVICE)
+				SYS_WARN(xradio_upload_qosnull(priv));
+
+			if (hw_priv->is_BT_Present)
+				SYS_WARN(xradio_set_btcoexinfo(priv));
+#if 0
+			/* It's better to override internal TX rete; otherwise
+			 * device sends RTS at too high rate. However device
+			 * can't receive CTS at 1 and 2 Mbps. Well, 5.5 is a
+			 * good choice for RTS/CTS, but that means PS poll
+			 * will be sent at the same rate - impact on link
+			 * budget. Not sure what is better.. */
+
+			/* Update: internal rate selection algorythm is not
+			 * bad: if device is not receiving CTS at high rate,
+			 * it drops RTS rate.
+			 * So, conclusion: if-0 the code. Keep code just for
+			 * information:
+			 * Do not touch WSM_MIB_ID_OVERRIDE_INTERNAL_TX_RATE! */
+
+			/* ~3 is a bug in device: RTS/CTS is not working at
+			 * low rates */
+			__le32 internal_tx_rate =
+			    __cpu_to_le32(__ffs(priv->association_mode.basicRateSet & ~3));
+			SYS_WARN(wsm_write_mib(priv, WSM_MIB_ID_OVERRIDE_INTERNAL_TX_RATE,
+				 &internal_tx_rate, sizeof(internal_tx_rate)));
+#endif
+		} else {
+			ap_printk(XRADIO_DBG_NIY, "BSS_CHANGED_ASSOC not assoc, change=0x%08x.\n", changed);
+			memset(&priv->association_mode, 0, sizeof(priv->association_mode));
+			memset(&priv->bss_params, 0, sizeof(priv->bss_params));
+			priv->base_rates = -1;
+			priv->oper_rates = -1;
+		}
+	}
+	if (changed & (BSS_CHANGED_ASSOC | BSS_CHANGED_ERP_CTS_PROT)) {
+		u32 prev_erp_info = priv->erp_info;
+		if (priv->join_status == XRADIO_JOIN_STATUS_AP) {
+			if (info->use_cts_prot)
+				priv->erp_info |= WLAN_ERP_USE_PROTECTION;
+			else if (!(prev_erp_info & WLAN_ERP_NON_ERP_PRESENT))
+				priv->erp_info &= ~WLAN_ERP_USE_PROTECTION;
+
+			if (prev_erp_info != priv->erp_info)
+				queue_delayed_work(hw_priv->workqueue,
+						   &priv->set_cts_work, 0*HZ);
+		}
+	}
+
+	if (changed & (BSS_CHANGED_ASSOC | BSS_CHANGED_ERP_SLOT)) {
+		__le32 slot_time = info->use_short_slot ?
+				   __cpu_to_le32(9) : __cpu_to_le32(20);
+		ap_printk(XRADIO_DBG_MSG, "[STA] Slot time :%d us.\n",
+			  __le32_to_cpu(slot_time));
+		SYS_WARN(wsm_write_mib(hw_priv, WSM_MIB_ID_DOT11_SLOT_TIME,
+				       &slot_time, sizeof(slot_time), priv->if_id));
+	}
+	if (changed & (BSS_CHANGED_ASSOC | BSS_CHANGED_CQM)) {
+		struct wsm_rcpi_rssi_threshold threshold = {
+			.rollingAverageCount = 8,
+		};
+
+#if 0
+		/* For verification purposes */
+		info->cqm_rssi_thold = -50;
+		info->cqm_rssi_hyst = 4;
+#endif /* 0 */
+
+		ap_printk(XRADIO_DBG_NIY,
+			  "[CQM] RSSI threshold subscribe: %d(+-%d)\n",
+			  info->cqm_rssi_thold, info->cqm_rssi_hyst);
+
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+		ap_printk(XRADIO_DBG_NIY, "[CQM] Beacon loss subscribe: %d\n",
+			  info->cqm_beacon_miss_thold);
+		ap_printk(XRADIO_DBG_NIY, "[CQM] TX failure subscribe: %d\n",
+			  info->cqm_tx_fail_thold);
+		priv->cqm_rssi_thold = info->cqm_rssi_thold;
+		priv->cqm_rssi_hyst  = info->cqm_rssi_hyst;
+#endif /* CONFIG_XRADIO_USE_EXTENSIONS */
+
+		if (info->cqm_rssi_thold || info->cqm_rssi_hyst) {
+			/* RSSI subscription enabled */
+			/* TODO: It's not a correct way of setting threshold.
+			 * Upper and lower must be set equal here and adjusted
+			 * in callback. However current implementation is much
+			 * more relaible and stable. */
+			if (priv->cqm_use_rssi) {
+				threshold.upperThreshold = info->cqm_rssi_thold +
+							   info->cqm_rssi_hyst;
+				threshold.lowerThreshold = info->cqm_rssi_thold;
+			} else {
+				/* convert RSSI to RCPI, RCPI = (RSSI + 110) * 2 */
+				threshold.upperThreshold = (info->cqm_rssi_thold +
+							    info->cqm_rssi_hyst + 110)<<1;
+				threshold.lowerThreshold = (info->cqm_rssi_thold + 110)<<1;
+			}
+			threshold.rssiRcpiMode |= WSM_RCPI_RSSI_THRESHOLD_ENABLE;
+		} else {
+			/* There is a bug in FW, see sta.c. We have to enable
+			 * dummy subscription to get correct RSSI values. */
+			threshold.rssiRcpiMode |= WSM_RCPI_RSSI_THRESHOLD_ENABLE |
+						  WSM_RCPI_RSSI_DONT_USE_UPPER   |
+						  WSM_RCPI_RSSI_DONT_USE_LOWER;
+		}
+		SYS_WARN(wsm_set_rcpi_rssi_threshold(hw_priv, &threshold, priv->if_id));
+
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+		priv->cqm_tx_failure_thold = info->cqm_tx_fail_thold;
+		priv->cqm_tx_failure_count = 0;
+
+		if (priv->cqm_beacon_loss_count != info->cqm_beacon_miss_thold) {
+			priv->cqm_beacon_loss_count = info->cqm_beacon_miss_thold;
+			priv->bss_params.beaconLostCount = (priv->cqm_beacon_loss_count ?
+			  priv->cqm_beacon_loss_count : priv->cqm_link_loss_count);
+			/* Make sure we are associated before sending
+			 * set_bss_params to firmware */
+			if (priv->bss_params.aid) {
+				SYS_WARN(wsm_set_bss_params(hw_priv,
+					 &priv->bss_params, priv->if_id));
+				priv->setbssparams_done = true;
+			}
+		}
+#endif /* CONFIG_XRADIO_USE_EXTENSIONS */
+	}
+
+	if (changed & BSS_CHANGED_PS) {
+		if (info->ps_enabled == false)
+			priv->powersave_mode.pmMode = WSM_PSM_ACTIVE;
+		else if (info->dynamic_ps_timeout <= 0)
+			priv->powersave_mode.pmMode = WSM_PSM_PS;
+		else
+			priv->powersave_mode.pmMode = WSM_PSM_FAST_PS;
+
+		ap_printk(XRADIO_DBG_MSG, "[STA] Aid: %d, Joined: %s, Powersave: %s\n",
+		   priv->bss_params.aid,
+		   priv->join_status == XRADIO_JOIN_STATUS_STA ? "yes" : "no",
+		  (priv->powersave_mode.pmMode == WSM_PSM_ACTIVE ? "WSM_PSM_ACTIVE" :
+		   priv->powersave_mode.pmMode == WSM_PSM_PS ? "WSM_PSM_PS" :
+		   priv->powersave_mode.pmMode == WSM_PSM_FAST_PS ? "WSM_PSM_FAST_PS" :
+						  "UNKNOWN"));
+
+		/* Firmware requires that value for this 1-byte field must
+		 * be specified in units of 500us. Values above the 128ms
+		 * threshold are not supported. */
+		if (info->dynamic_ps_timeout >= 0x80)
+			priv->powersave_mode.fastPsmIdlePeriod = 0xFF;
+		else
+			priv->powersave_mode.fastPsmIdlePeriod =
+					     info->dynamic_ps_timeout << 1;
+		ap_printk(XRADIO_DBG_NIY,
+			  "[STA]CHANGED_PS fastPsmIdle=%d, apPsmChange=%d\n",
+			  priv->powersave_mode.fastPsmIdlePeriod,
+			  priv->powersave_mode.apPsmChangePeriod);
+
+		if (priv->join_status == XRADIO_JOIN_STATUS_STA
+		    && priv->bss_params.aid
+		    && priv->setbssparams_done && priv->filter4.enable)
+			xradio_set_pm(priv, &priv->powersave_mode);
+		else
+			priv->power_set_true = 1;
+	}
+
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+	if (changed & BSS_CHANGED_P2P_PS) {
+		struct wsm_p2p_ps_modeinfo *modeinfo;
+		modeinfo = &priv->p2p_ps_modeinfo;
+		ap_printk(XRADIO_DBG_NIY, "[AP] BSS_CHANGED_P2P_PS\n");
+		ap_printk(XRADIO_DBG_NIY,
+			  "[AP] Legacy PS: %d for AID %d in %d mode.\n",
+			  info->p2p_ps.legacy_ps, priv->bss_params.aid,
+			  priv->join_status);
+
+		if (info->p2p_ps.legacy_ps >= 0) {
+			if (info->p2p_ps.legacy_ps > 0)
+				priv->powersave_mode.pmMode = WSM_PSM_PS;
+			else
+				priv->powersave_mode.pmMode = WSM_PSM_ACTIVE;
+
+			if (info->p2p_ps.ctwindow && info->p2p_ps.opp_ps)
+				priv->powersave_mode.pmMode = WSM_PSM_PS;
+			if (priv->join_status == XRADIO_JOIN_STATUS_STA)
+				xradio_set_pm(priv, &priv->powersave_mode);
+		}
+
+		ap_printk(XRADIO_DBG_MSG, "[AP] CTWindow: %d\n",
+			  info->p2p_ps.ctwindow);
+		if (info->p2p_ps.ctwindow >= 128)
+			modeinfo->oppPsCTWindow = 127;
+		else if (info->p2p_ps.ctwindow >= 0)
+			modeinfo->oppPsCTWindow = info->p2p_ps.ctwindow;
+
+		ap_printk(XRADIO_DBG_MSG, "[AP] Opportunistic: %d\n",
+			  info->p2p_ps.opp_ps);
+		switch (info->p2p_ps.opp_ps) {
+		case 0:
+			modeinfo->oppPsCTWindow &= ~(BIT(7));
+			break;
+		case 1:
+			modeinfo->oppPsCTWindow |= BIT(7);
+			break;
+		default:
+			break;
+		}
+
+		ap_printk(XRADIO_DBG_MSG, "[AP] NOA: %d, %d, %d, %d\n",
+			  info->p2p_ps.count, info->p2p_ps.start,
+			  info->p2p_ps.duration, info->p2p_ps.interval);
+		/* Notice of Absence */
+		modeinfo->count = info->p2p_ps.count;
+
+		if (info->p2p_ps.count) {
+			/* In case P2P_GO we need some extra time to be sure
+			 * we will update beacon/probe_resp IEs correctly */
+#define NOA_DELAY_START_MS	300
+			if (priv->join_status == XRADIO_JOIN_STATUS_AP)
+				modeinfo->startTime =
+				    __cpu_to_le32(info->p2p_ps.start + NOA_DELAY_START_MS);
+			else
+				modeinfo->startTime = __cpu_to_le32(info->p2p_ps.start);
+			modeinfo->duration    = __cpu_to_le32(info->p2p_ps.duration);
+			modeinfo->interval    = __cpu_to_le32(info->p2p_ps.interval);
+			modeinfo->dtimCount   = 1;
+			modeinfo->reserved    = 0;
+		} else {
+			modeinfo->dtimCount = 0;
+			modeinfo->startTime = 0;
+			modeinfo->reserved  = 0;
+			modeinfo->duration  = 0;
+			modeinfo->interval  = 0;
+		}
+
+#if defined(CONFIG_XRADIO_DEBUG)
+		print_hex_dump_bytes("p2p_set_ps_modeinfo: ", DUMP_PREFIX_NONE,
+				     (u8 *)modeinfo, sizeof(*modeinfo));
+#endif /* CONFIG_XRADIO_DEBUG */
+
+		if (priv->join_status == XRADIO_JOIN_STATUS_STA ||
+		    priv->join_status == XRADIO_JOIN_STATUS_AP) {
+			SYS_WARN(wsm_set_p2p_ps_modeinfo(hw_priv, modeinfo, priv->if_id));
+		}
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+		/* Temporary solution while firmware don't support NOA change
+		 * notification yet */
+		xradio_notify_noa(priv, 10);
+#endif
+	}
+#endif /* CONFIG_XRADIO_USE_EXTENSIONS */
+
+	up(&hw_priv->conf_lock);
+}
+
+void xradio_multicast_start_work(struct work_struct *work)
+{
+	struct xradio_vif *priv =
+	    container_of(work, struct xradio_vif, multicast_start_work);
+	long tmo = priv->join_dtim_period * (priv->beacon_int + 20) * HZ / 1024;
+
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	cancel_work_sync(&priv->multicast_stop_work);
+	if (!priv->aid0_bit_set) {
+		wsm_lock_tx(priv->hw_priv);
+		xradio_set_tim_impl(priv, true);
+		priv->aid0_bit_set = true;
+		mod_timer(&priv->mcast_timeout, jiffies + tmo);
+		wsm_unlock_tx(priv->hw_priv);
+	}
+}
+
+void xradio_multicast_stop_work(struct work_struct *work)
+{
+	struct xradio_vif *priv =
+	    container_of(work, struct xradio_vif, multicast_stop_work);
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (priv->aid0_bit_set) {
+		del_timer_sync(&priv->mcast_timeout);
+		wsm_lock_tx(priv->hw_priv);
+		priv->aid0_bit_set = false;
+		xradio_set_tim_impl(priv, false);
+		wsm_unlock_tx(priv->hw_priv);
+	}
+}
+
+void xradio_mcast_timeout(struct timer_list *t)
+{
+	struct xradio_vif *priv = from_timer(priv, t, mcast_timeout);
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	ap_printk(XRADIO_DBG_WARN, "Multicast delivery timeout.\n");
+	spin_lock_bh(&priv->ps_state_lock);
+	priv->tx_multicast = priv->aid0_bit_set && priv->buffered_multicasts;
+	if (priv->tx_multicast)
+		xradio_proc_wakeup(xrwl_vifpriv_to_hwpriv(priv));
+	spin_unlock_bh(&priv->ps_state_lock);
+}
+
+int xradio_ampdu_action(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			enum ieee80211_ampdu_mlme_action action,
+			struct ieee80211_sta *sta,
+			u16 tid, u16 *ssn, u8 buf_size)
+{
+	/* Aggregation is implemented fully in firmware,
+	 * including block ack negotiation.
+	 * In case of AMPDU aggregation in RX direction
+	 * re-ordering of packets takes place on host. mac80211
+	 * needs the ADDBA Request to setup reodering.mac80211 also
+	 * sends ADDBA Response which is discarded in the driver as
+	 * FW generates the ADDBA Response on its own.*/
+	int ret;
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	switch (action) {
+	case IEEE80211_AMPDU_RX_START:
+	case IEEE80211_AMPDU_RX_STOP:
+		/* Just return OK to mac80211 */
+		ret = 0;
+		break;
+	default:
+		ret = -ENOTSUPP;
+	}
+	return ret;
+}
+
+/* ******************************************************************** */
+/* WSM callback								*/
+void xradio_suspend_resume(struct xradio_vif *priv,
+			   struct wsm_suspend_resume *arg)
+{
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+#if 0
+	ap_printk(XRADIO_DBG_MSG, "[AP] %s: %s\n",
+		  arg->stop ? "stop" : "start",
+		  arg->multicast ? "broadcast" : "unicast");
+#endif
+	if (arg->multicast) {
+		bool cancel_tmo = false;
+		spin_lock_bh(&priv->ps_state_lock);
+		if (arg->stop) {
+			priv->tx_multicast = false;
+		} else {
+			/* Firmware sends this indication every DTIM if there
+			 * is a STA in powersave connected. There is no reason
+			 * to suspend, following wakeup will consume much more
+			 * power than it could be saved. */
+#ifdef CONFIG_PM
+#ifndef CONFIG_XRADIO_SUSPEND_POWER_OFF
+			xradio_pm_stay_awake(&hw_priv->pm_state,
+					     (priv->join_dtim_period * \
+					     (priv->beacon_int + 20) * HZ / 1024));
+#endif
+#endif
+			priv->tx_multicast = priv->aid0_bit_set &&
+					     priv->buffered_multicasts;
+			if (priv->tx_multicast) {
+				cancel_tmo = true;
+				xradio_proc_wakeup(hw_priv);
+			}
+		}
+		spin_unlock_bh(&priv->ps_state_lock);
+		if (cancel_tmo)
+			del_timer_sync(&priv->mcast_timeout);
+	} else {
+		spin_lock_bh(&priv->ps_state_lock);
+		xradio_ps_notify(priv, arg->link_id, arg->stop);
+		spin_unlock_bh(&priv->ps_state_lock);
+		if (!arg->stop)
+			xradio_proc_wakeup(hw_priv);
+	}
+	return;
+}
+
+/* ******************************************************************** */
+/* AP privates								*/
+
+static int xradio_upload_beacon(struct xradio_vif *priv)
+{
+	int ret = 0;
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	struct wsm_template_frame frame = {
+		.frame_type = WSM_FRAME_TYPE_BEACON,
+	};
+	struct ieee80211_mgmt *mgmt;
+	u8 *erp_inf, *ies, *ht_info;
+	u32 ies_len;
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+#ifdef SUPPORT_HT40
+
+	frame.rate = ((RATE_MODEM_LEGACY  << MODEMTYPE_SHIFT) |
+				(RATE_BANDWIDTH_20M << BANDWIDTH_SHIFT));
+	if (priv->vif->p2p || hw_priv->channel->band == NL80211_BAND_5GHZ)
+		frame.rate |= (A_RATES_OFF << RATEINDEX_SHIFT);
+
+#else
+
+	if (priv->vif->p2p || hw_priv->channel->band == NL80211_BAND_5GHZ)
+		frame.rate = WSM_TRANSMIT_RATE_6;
+
+#endif
+
+	frame.skb = ieee80211_beacon_get(priv->hw, priv->vif);
+	if (SYS_WARN(!frame.skb))
+		return -ENOMEM;
+
+	mgmt = (void *)frame.skb->data;
+	ies = mgmt->u.beacon.variable;
+	ies_len = frame.skb->len - (u32) (ies - (u8 *) mgmt);
+
+	ht_info = (u8 *)cfg80211_find_ie(WLAN_EID_HT_INFORMATION, ies, ies_len);
+	if (ht_info) {
+		/* Enable RIFS */
+		ht_info[3] |= 8;
+	}
+
+	erp_inf = (u8 *)cfg80211_find_ie(WLAN_EID_ERP_INFO, ies, ies_len);
+	if (erp_inf) {
+		if (erp_inf[ERP_INFO_BYTE_OFFSET]
+				& WLAN_ERP_BARKER_PREAMBLE)
+			priv->erp_info |= WLAN_ERP_BARKER_PREAMBLE;
+		else
+			priv->erp_info &= ~WLAN_ERP_BARKER_PREAMBLE;
+
+		if (erp_inf[ERP_INFO_BYTE_OFFSET]
+				& WLAN_ERP_NON_ERP_PRESENT) {
+			ap_printk(XRADIO_DBG_NIY, "WLAN_ERP_NON_ERP_PRESENT.\n");
+			priv->erp_info |= WLAN_ERP_USE_PROTECTION;
+			priv->erp_info |= WLAN_ERP_NON_ERP_PRESENT;
+		} else {
+			ap_printk(XRADIO_DBG_NIY, "No WLAN_ERP_NON_ERP_PRESENT.\n");
+			priv->erp_info &= ~WLAN_ERP_USE_PROTECTION;
+			priv->erp_info &= ~WLAN_ERP_NON_ERP_PRESENT;
+		}
+	}
+
+#ifdef HIDDEN_SSID
+	if (priv->hidden_ssid) {
+		u8 *ssid_ie;
+		u8 ssid_len;
+		/*
+		 * Hidden ap set by two ways:
+		 * 1. ssid len != 0, and ssid filled with zero.
+		 * 2. ssid len = 0, and no ssid in beacon or probe_resp.
+		 */
+		ap_printk(XRADIO_DBG_NIY, "%s: hidden_ssid set\n", __func__);
+		ssid_ie = (u8 *) cfg80211_find_ie(WLAN_EID_SSID, ies, ies_len);
+		SYS_WARN(!ssid_ie);
+		ssid_len = ssid_ie[1];
+		if (ssid_len) {
+			ap_printk(XRADIO_DBG_MSG, "hidden_ssid with zero content ssid\n");
+			ssid_ie[1] = 0;
+			memmove(ssid_ie + 2, ssid_ie + 2 + ssid_len,
+				(ies + ies_len - (ssid_ie + 2 + ssid_len)));
+			frame.skb->len -= ssid_len;
+		} else {
+			ap_printk(XRADIO_DBG_NIY,
+				  "hidden ssid with ssid len 0, we have nothing to do!");
+		}
+	}
+#endif
+
+	ret = wsm_set_template_frame(hw_priv, &frame, priv->if_id);
+	if (!ret) {
+#ifdef PROBE_RESP_EXTRA_IE
+		ret = xradio_upload_proberesp(priv);
+#else
+		/* TODO: Distille probe resp; remove TIM
+		 * and other beacon-specific IEs */
+		*(__le16 *)frame.skb->data =
+		    __cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_PROBE_RESP);
+		frame.frame_type = WSM_FRAME_TYPE_PROBE_RESPONSE;
+		/* TODO: Ideally probe response template should separately
+		   configured by supplicant through openmac. This is a
+		   temporary work-around known to fail p2p group info
+		   attribute related tests
+		 */
+		if (0 /* priv->vif->p2p */)
+			ret = wsm_set_probe_responder(priv, true);
+		else {
+			ret = wsm_set_template_frame(hw_priv, &frame, priv->if_id);
+			SYS_WARN(wsm_set_probe_responder(priv, false));
+		}
+#endif
+	}
+	dev_kfree_skb(frame.skb);
+
+	return ret;
+}
+
+#ifdef PROBE_RESP_EXTRA_IE
+static int xradio_upload_proberesp(struct xradio_vif *priv)
+{
+	int ret = 0;
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	struct wsm_template_frame frame = {
+		.frame_type = WSM_FRAME_TYPE_PROBE_RESPONSE,
+	};
+#ifdef HIDDEN_SSID
+	u8 *ssid_ie;
+#endif
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+#ifdef SUPPORT_HT40
+
+	frame.rate = ((RATE_MODEM_LEGACY  << MODEMTYPE_SHIFT) |
+				(RATE_BANDWIDTH_20M << BANDWIDTH_SHIFT));
+	if (priv->vif->p2p || hw_priv->channel->band == NL80211_BAND_5GHZ)
+		frame.rate |= (A_RATES_OFF << RATEINDEX_SHIFT);
+
+#else
+
+	if (priv->vif->p2p || hw_priv->channel->band == NL80211_BAND_5GHZ)
+		frame.rate = WSM_TRANSMIT_RATE_6;
+
+#endif
+
+	frame.skb = mac80211_proberesp_get(priv->hw, priv->vif);
+	if (SYS_WARN(!frame.skb))
+		return -ENOMEM;
+
+#ifdef HIDDEN_SSID
+	if (priv->hidden_ssid) {
+		int offset;
+		u8 ssid_len;
+		/* we are assuming beacon from upper layer will always contain
+		 * zero filled ssid for hidden ap. The beacon shall never have
+		 * ssid len = 0.
+		 */
+		/* Upper layer will set ssid len = 0 for for hidden ap too.
+		 * --13:23 2017/1/9
+		 */
+
+		offset  = offsetof(struct ieee80211_mgmt, u.probe_resp.variable);
+		ssid_ie = (u8 *)cfg80211_find_ie(WLAN_EID_SSID,
+						 frame.skb->data + offset,
+						 frame.skb->len - offset);
+		if (!ssid_ie) {
+			ap_printk(XRADIO_DBG_ERROR,
+					  "%s:ssid is not found in probe_resp\n", __func__);
+			dev_kfree_skb(frame.skb);
+			return -1;
+		}
+
+		if (!priv->ssid_length) {
+			ap_printk(XRADIO_DBG_ERROR,
+				  "%s:hidden ssid is Not config yet.\n", __func__);
+			dev_kfree_skb(frame.skb);
+			return -1;
+		} else {
+			ap_printk(XRADIO_DBG_NIY,
+				  "%s: hidden ssid in probe_resp=%s\n",
+				  __func__, priv->ssid);
+		}
+
+		ssid_len = ssid_ie[1];
+		if (ssid_len) {
+			if (ssid_len == priv->ssid_length) {
+				memcpy(ssid_ie + 2, priv->ssid, ssid_len);
+			} else {
+				ap_printk(XRADIO_DBG_ERROR,
+					  "%s: hidden ssid with mismatched ssid_len %d\n",
+					  __func__, ssid_len);
+				dev_kfree_skb(frame.skb);
+				return -1;
+			}
+		} else {
+			if (skb_tailroom(frame.skb) >= priv->ssid_length) {
+				u8 move_len = (frame.skb->data +
+						frame.skb->len) - (ssid_ie + 2);
+				skb_put(frame.skb, priv->ssid_length);
+				ssid_ie[1] = priv->ssid_length;
+				memmove(&ssid_ie[2 + priv->ssid_length],
+						&ssid_ie[2], move_len);
+				memcpy(&ssid_ie[2], priv->ssid, priv->ssid_length);
+			} else {
+				ap_printk(XRADIO_DBG_ERROR,
+				  "%s: no room in probe_resp for hidden ssid len=%zu\n",
+				  __func__, priv->ssid_length);
+				dev_kfree_skb(frame.skb);
+				return -1;
+			}
+		}
+	}
+#endif
+	ret = wsm_set_template_frame(hw_priv, &frame,  priv->if_id);
+	SYS_WARN(wsm_set_probe_responder(priv, false));
+
+	dev_kfree_skb(frame.skb);
+
+	return ret;
+}
+#endif
+
+static int xradio_upload_pspoll(struct xradio_vif *priv)
+{
+	int ret = 0;
+	struct wsm_template_frame frame = {
+		.frame_type = WSM_FRAME_TYPE_PS_POLL,
+		.rate = 0xFF,
+	};
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	frame.skb = mac80211_pspoll_get(priv->hw, priv->vif);
+	if (SYS_WARN(!frame.skb))
+		return -ENOMEM;
+	ret = wsm_set_template_frame(xrwl_vifpriv_to_hwpriv(priv),
+				     &frame, priv->if_id);
+	dev_kfree_skb(frame.skb);
+	return ret;
+}
+
+static int xradio_upload_null(struct xradio_vif *priv)
+{
+	int ret = 0;
+	struct wsm_template_frame frame = {
+		.frame_type = WSM_FRAME_TYPE_NULL,
+		.rate = 0xFF,
+	};
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	frame.skb = mac80211_nullfunc_get(priv->hw, priv->vif);
+	if (SYS_WARN(!frame.skb))
+		return -ENOMEM;
+
+	ret = wsm_set_template_frame(xrwl_vifpriv_to_hwpriv(priv),
+				     &frame, priv->if_id);
+	dev_kfree_skb(frame.skb);
+	return ret;
+}
+
+static int xradio_upload_qosnull(struct xradio_vif *priv)
+{
+	int ret = 0;
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	struct wsm_template_frame frame = {
+		.frame_type = WSM_FRAME_TYPE_QOS_NULL,
+		.rate = 0xFF,
+	};
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	frame.skb = ieee80211_qosnullfunc_get(priv->hw, priv->vif);
+	if (SYS_WARN(!frame.skb))
+		return -ENOMEM;
+
+	ret = wsm_set_template_frame(hw_priv, &frame, priv->if_id);
+	dev_kfree_skb(frame.skb);
+	return ret;
+}
+
+/* This API is nolonegr present in WSC */
+#if 0
+static int xradio_enable_beaconing(struct xradio_vif *priv, bool enable)
+{
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	struct wsm_beacon_transmit transmit = {
+		.enableBeaconing = enable,
+	};
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	return wsm_beacon_transmit(hw_priv, &transmit, priv->if_id);
+}
+#endif
+
+static int xradio_start_ap(struct xradio_vif *priv)
+{
+	int ret;
+#ifndef HIDDEN_SSID
+	const u8 *ssidie;
+	struct sk_buff *skb;
+	int offset;
+#endif
+	struct ieee80211_bss_conf *conf = &priv->vif->bss_conf;
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+
+#ifdef SUPPORT_HT40
+
+	struct ieee80211_supported_band *sband;
+	struct phy_mode_cfg PhyModeCfg;
+
+	struct wsm_start start = {
+		.mode = priv->vif->p2p ? WSM_START_MODE_P2P_GO :
+					WSM_START_MODE_AP,
+		/* TODO:COMBO:Change once mac80211 support is available */
+		.channelNumber = hw_priv->channel->hw_value,
+		.beaconInterval = conf->beacon_int,
+		.DTIMPeriod = conf->dtim_period,
+		.probeDelay = 100,
+		.basicRateSet =
+			xradio_rate_mask_to_wsm(hw_priv, conf->basic_rates),
+#ifdef P2P_MULTIVIF
+		.CTWindow = priv->vif->p2p ? 0xFFFFFFFF : 0,
+#endif
+	};
+
+#else
+
+	struct wsm_start start = {
+		.mode = priv->vif->p2p ? WSM_START_MODE_P2P_GO : WSM_START_MODE_AP,
+		/* TODO:COMBO:Change once mac80211 support is available */
+		.band = (hw_priv->channel->band == NL80211_BAND_5GHZ) ?
+				     WSM_PHY_BAND_5G : WSM_PHY_BAND_2_4G,
+		.channelNumber = hw_priv->channel->hw_value,
+		.beaconInterval = conf->beacon_int,
+		.DTIMPeriod = conf->dtim_period,
+		.preambleType = conf->use_short_preamble ?
+				WSM_JOIN_PREAMBLE_SHORT : WSM_JOIN_PREAMBLE_LONG,
+		.probeDelay = 100,
+		.basicRateSet = xradio_rate_mask_to_wsm(hw_priv, conf->basic_rates),
+#ifdef P2P_MULTIVIF
+		.CTWindow = priv->vif->p2p ? 0xFFFFFFFF : 0,
+#endif
+	};
+
+#endif
+
+	struct wsm_operational_mode mode = {
+		.power_mode = wsm_power_mode_quiescent,
+		.disableMoreFlagUsage = true,
+	};
+
+#ifdef TES_P2P_000B_EXTEND_INACTIVITY_CNT
+	/*
+	 * TES_P2P_000B WorkAround:
+	 * when inactivity count of a peer device is zero,
+	 * which will reset while receiving a peer device frame,
+	 * firmware will disconnect with it.
+	 * due to some reason, such as scan/phy error, we miss these frame.
+	 * then we can't keep connection with peer device.
+	 * we set the min_inactivity value to large as WorkAround.
+	 */
+	struct wsm_inactivity inactivity = {
+		.min_inactivity = 20,
+		.max_inactivity = 10,
+	};
+#else
+	struct wsm_inactivity inactivity = {
+		.min_inactivity = 9,
+		.max_inactivity = 1,
+	};
+#endif
+
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+#ifdef SUPPORT_HT40
+
+	sband = priv->hw->wiphy->bands[hw_priv->channel->band];
+
+	PhyModeCfg.BandCfg = hw_priv->channel->band;
+	if (PhyModeCfg.BandCfg == NL80211_BAND_5GHZ)
+		PhyModeCfg.ModemFlags = (MODEM_F_A_OFDM |
+					MODEM_F_N_OFDM);
+	else
+		PhyModeCfg.ModemFlags = (MODEM_F_B_DSSS |
+					MODEM_F_A_OFDM |
+					MODEM_F_N_OFDM);
+
+	if (conf->channel_type == NL80211_CHAN_HT40MINUS) {
+		PhyModeCfg.ChWidthCfg = CHAN_WIDTH_40MHz;
+		PhyModeCfg.PriChCfg   = PRIMARY_CH_1ST;
+	} else if (conf->channel_type == NL80211_CHAN_HT40PLUS) {
+		PhyModeCfg.ChWidthCfg = CHAN_WIDTH_40MHz;
+		PhyModeCfg.PriChCfg   = PRIMARY_CH_2ND;
+	} else {
+		PhyModeCfg.ChWidthCfg = CHAN_WIDTH_20MHz;
+		PhyModeCfg.PriChCfg   = PRIMARY_CH_1ST;
+	}
+
+	if (conf->channel_type == NL80211_CHAN_NO_HT) {
+		PhyModeCfg.ModemFlags &= ~(MODEM_F_N_OFDM);
+		PhyModeCfg.SGI_Enable = false;
+		PhyModeCfg.GF_Enable = false;
+	} else {
+		PhyModeCfg.GF_Enable  =
+			(sband->ht_cap.cap&IEEE80211_HT_CAP_GRN_FLD) ?
+								true : false;
+		PhyModeCfg.SGI_Enable =
+			(sband->ht_cap.cap&
+			(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40)) ?
+								true : false;
+	}
+
+	PhyModeCfg.STBC_Enable = false;
+	PhyModeCfg.PreambleCfg = conf->use_short_preamble ?
+		WSM_JOIN_PREAMBLE_SHORT : WSM_JOIN_PREAMBLE_LONG;
+
+	start.PhyModeCfg = PhyModeCfg;
+
+#endif
+
+	if (priv->if_id)
+		start.mode |= WSM_FLAG_MAC_INSTANCE_1;
+	else
+		start.mode &= ~WSM_FLAG_MAC_INSTANCE_1;
+
+	hw_priv->connected_sta_cnt = 0;
+
+#ifndef HIDDEN_SSID
+	/* Get SSID */
+	skb = ieee80211_beacon_get(priv->hw, priv->vif);
+	if (SYS_WARN(!skb)) {
+		ap_printk(XRADIO_DBG_ERROR, "%s, ieee80211_beacon_get failed\n",
+			  __func__);
+		return -ENOMEM;
+	}
+
+	offset = offsetof(struct ieee80211_mgmt, u.beacon.variable);
+	ssidie = cfg80211_find_ie(WLAN_EID_SSID, skb->data + offset,
+				  skb->len - offset);
+
+	memset(priv->ssid, 0, sizeof(priv->ssid));
+	if (ssidie) {
+		priv->ssid_length = ssidie[1];
+		if (SYS_WARN(priv->ssid_length > sizeof(priv->ssid)))
+			priv->ssid_length = sizeof(priv->ssid);
+		memcpy(priv->ssid, &ssidie[2], priv->ssid_length);
+	} else {
+		priv->ssid_length = 0;
+	}
+	dev_kfree_skb(skb);
+#endif
+
+	priv->beacon_int = conf->beacon_int;
+	priv->join_dtim_period = conf->dtim_period;
+	memset(&priv->last_tim[0], 0, sizeof(priv->last_tim));
+
+	start.ssidLength = priv->ssid_length;
+	memcpy(&start.ssid[0], priv->ssid, start.ssidLength);
+
+	memset(&priv->link_id_db, 0, sizeof(priv->link_id_db));
+
+#ifdef SUPPORT_HT40
+
+	ap_printk(XRADIO_DBG_NIY, "[AP] ch: %d(%d), bcn: %d(%d), "\
+				"bss_rate: 0x%.8X, ssid: %.*s.\n",
+				start.channelNumber, start.PhyModeCfg.BandCfg,
+				start.beaconInterval, start.DTIMPeriod,
+				start.basicRateSet, start.ssidLength,
+				start.ssid);
+	ret = SYS_WARN(wsm_start(hw_priv, &start, priv->if_id));
+
+	ap_printk(XRADIO_DBG_WARN, "[HT40][%s][PhyModeCfg:0x%04x]\n",
+				__func__, *(u16 *)&start.PhyModeCfg);
+
+#else
+
+	ap_printk(XRADIO_DBG_NIY, "[AP] ch: %d(%d), bcn: %d(%d), " \
+		  "bss_rate: 0x%.8X, ssid: %.*s.\n",
+		  start.channelNumber,  start.band,
+		  start.beaconInterval, start.DTIMPeriod,
+		  start.basicRateSet, start.ssidLength, start.ssid);
+	ret = SYS_WARN(wsm_start(hw_priv, &start, priv->if_id));
+
+#endif
+	if (!ret && priv->vif->p2p) {
+		ap_printk(XRADIO_DBG_NIY,
+			  "[AP] Setting p2p powersave configuration.\n");
+		SYS_WARN(wsm_set_p2p_ps_modeinfo(hw_priv,
+			&priv->p2p_ps_modeinfo, priv->if_id));
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+		xradio_notify_noa(priv, XRADIO_NOA_NOTIFICATION_DELAY);
+#endif
+	}
+
+	/*Set Inactivity time */
+	if (!(strstr(&start.ssid[0], "6.1.12"))) {
+		wsm_set_inactivity(hw_priv, &inactivity, priv->if_id);
+	}
+	if (!ret) {
+#ifndef AP_AGGREGATE_FW_FIX
+		SYS_WARN(wsm_set_block_ack_policy(hw_priv,
+			 XRADIO_TX_BLOCK_ACK_DISABLED_FOR_ALL_TID,
+			 XRADIO_RX_BLOCK_ACK_DISABLED_FOR_ALL_TID, priv->if_id));
+#else
+		if ((priv->if_id == 1) && !hw_priv->is_go_thru_go_neg)
+			SYS_WARN(wsm_set_block_ack_policy(hw_priv,
+				 XRADIO_TX_BLOCK_ACK_ENABLED_FOR_ALL_TID,
+				 XRADIO_RX_BLOCK_ACK_ENABLED_FOR_ALL_TID, priv->if_id));
+		else
+			SYS_WARN(wsm_set_block_ack_policy(hw_priv,
+				 XRADIO_TX_BLOCK_ACK_ENABLED_FOR_ALL_TID,
+				 XRADIO_RX_BLOCK_ACK_ENABLED_FOR_ALL_TID, priv->if_id));
+#endif
+		priv->join_status = XRADIO_JOIN_STATUS_AP;
+		/* xradio_update_filtering(priv); */
+	}
+	SYS_WARN(wsm_set_operational_mode(hw_priv, &mode, priv->if_id));
+	hw_priv->vif0_throttle = XRWL_HOST_VIF0_11N_THROTTLE;
+	hw_priv->vif1_throttle = XRWL_HOST_VIF0_11N_THROTTLE;
+	ap_printk(XRADIO_DBG_WARN, "vif%d, AP/GO mode THROTTLE=%d\n",
+		  priv->if_id, priv->if_id == 0 ?
+		  hw_priv->vif0_throttle : hw_priv->vif1_throttle);
+	return ret;
+}
+
+static int xradio_update_beaconing(struct xradio_vif *priv)
+{
+	struct ieee80211_bss_conf *conf = &priv->vif->bss_conf;
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	struct wsm_reset reset = {
+		.link_id = 0,
+		.reset_statistics = true,
+	};
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (priv->mode == NL80211_IFTYPE_AP) {
+		/* TODO: check if changed channel, band */
+		if (priv->join_status != XRADIO_JOIN_STATUS_AP ||
+		    priv->beacon_int != conf->beacon_int) {
+			ap_printk(XRADIO_DBG_WARN, "ap restarting!\n");
+			wsm_lock_tx(hw_priv);
+			if (priv->join_status != XRADIO_JOIN_STATUS_PASSIVE)
+				SYS_WARN(wsm_reset(hw_priv, &reset, priv->if_id));
+			priv->join_status = XRADIO_JOIN_STATUS_PASSIVE;
+			SYS_WARN(xradio_start_ap(priv));
+			wsm_unlock_tx(hw_priv);
+		} else
+			ap_printk(XRADIO_DBG_NIY, "ap started join_status: %d\n",
+				  priv->join_status);
+	}
+	return 0;
+}
+
+int xradio_find_link_id(struct xradio_vif *priv, const u8 *mac)
+{
+	int i, ret = 0;
+	spin_lock_bh(&priv->ps_state_lock);
+	for (i = 0; i < MAX_STA_IN_AP_MODE; ++i) {
+		if (!memcmp(mac, priv->link_id_db[i].mac, ETH_ALEN) &&
+		    priv->link_id_db[i].status) {
+			priv->link_id_db[i].timestamp = jiffies;
+			ret = i + 1;
+			break;
+		}
+	}
+	spin_unlock_bh(&priv->ps_state_lock);
+	return ret;
+}
+
+int xradio_alloc_link_id(struct xradio_vif *priv, const u8 *mac)
+{
+	int i, ret = 0;
+	unsigned long max_inactivity = 0;
+	unsigned long now = jiffies;
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	spin_lock_bh(&priv->ps_state_lock);
+	for (i = 0; i < MAX_STA_IN_AP_MODE; ++i) {
+		if (!priv->link_id_db[i].status) {
+			ret = i + 1;
+			break;
+		} else if (priv->link_id_db[i].status != XRADIO_LINK_HARD &&
+			   !hw_priv->tx_queue_stats.link_map_cache[priv->if_id][i + 1]) {
+			unsigned long inactivity = now - priv->link_id_db[i].timestamp;
+			if (inactivity < max_inactivity)
+				continue;
+			max_inactivity = inactivity;
+			ret = i + 1;
+		}
+	}
+	if (ret) {
+		struct xradio_link_entry *entry = &priv->link_id_db[ret - 1];
+		ap_printk(XRADIO_DBG_NIY, "STA added, link_id: %d\n", ret);
+		entry->status = XRADIO_LINK_RESERVE;
+		memcpy(&entry->mac, mac, ETH_ALEN);
+		memset(&entry->buffered, 0, XRADIO_MAX_TID);
+		skb_queue_head_init(&entry->rx_queue);
+		wsm_lock_tx_async(hw_priv);
+		if (queue_work(hw_priv->workqueue, &priv->link_id_work) <= 0)
+			wsm_unlock_tx(hw_priv);
+	} else {
+		ap_printk(XRADIO_DBG_WARN, "Early: no more link IDs available.\n");
+	}
+
+	spin_unlock_bh(&priv->ps_state_lock);
+	return ret;
+}
+
+void xradio_link_id_work(struct work_struct *work)
+{
+	struct xradio_vif *priv =
+	    container_of(work, struct xradio_vif, link_id_work);
+	struct xradio_common *hw_priv = priv->hw_priv;
+
+	wsm_flush_tx(hw_priv);
+	xradio_link_id_gc_work(&priv->link_id_gc_work.work);
+	wsm_unlock_tx(hw_priv);
+}
+
+void xradio_link_id_gc_work(struct work_struct *work)
+{
+	struct xradio_vif *priv =
+	    container_of(work, struct xradio_vif, link_id_gc_work.work);
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	struct wsm_map_link map_link = {
+		.link_id = 0,
+	};
+	unsigned long now = jiffies;
+	unsigned long next_gc = -1;
+	long ttl;
+	bool need_reset;
+	u32 mask;
+	int i;
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (priv->join_status != XRADIO_JOIN_STATUS_AP)
+		return;
+
+	wsm_lock_tx(hw_priv);
+	spin_lock_bh(&priv->ps_state_lock);
+	for (i = 0; i < MAX_STA_IN_AP_MODE; ++i) {
+		need_reset = false;
+		mask = BIT(i + 1);
+		if (priv->link_id_db[i].status == XRADIO_LINK_RESERVE ||
+		    (priv->link_id_db[i].status == XRADIO_LINK_HARD &&
+		     !(priv->link_id_map & mask))) {
+			if (priv->link_id_map & mask) {
+				priv->sta_asleep_mask &= ~mask;
+				priv->pspoll_mask &= ~mask;
+				need_reset = true;
+			}
+			priv->link_id_map |= mask;
+			if (priv->link_id_db[i].status != XRADIO_LINK_HARD)
+				priv->link_id_db[i].status = XRADIO_LINK_SOFT;
+			memcpy(map_link.mac_addr, priv->link_id_db[i].mac, ETH_ALEN);
+			spin_unlock_bh(&priv->ps_state_lock);
+			if (need_reset) {
+				SYS_WARN(xrwl_unmap_link(priv, i + 1));
+			}
+			map_link.link_id = i + 1;
+			SYS_WARN(wsm_map_link(hw_priv, &map_link, priv->if_id));
+			next_gc = min(next_gc, XRADIO_LINK_ID_GC_TIMEOUT);
+			spin_lock_bh(&priv->ps_state_lock);
+		} else if (priv->link_id_db[i].status == XRADIO_LINK_SOFT) {
+			ttl = priv->link_id_db[i].timestamp - now +
+			      XRADIO_LINK_ID_GC_TIMEOUT;
+			if (ttl <= 0) {
+				need_reset = true;
+				priv->link_id_db[i].status = XRADIO_LINK_OFF;
+				priv->link_id_map &= ~mask;
+				priv->sta_asleep_mask &= ~mask;
+				priv->pspoll_mask &= ~mask;
+				memset(map_link.mac_addr, 0, ETH_ALEN);
+				spin_unlock_bh(&priv->ps_state_lock);
+				SYS_WARN(xrwl_unmap_link(priv, i + 1));
+				spin_lock_bh(&priv->ps_state_lock);
+			} else {
+				next_gc = min_t(unsigned long, next_gc, ttl);
+			}
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+		} else if (priv->link_id_db[i].status == XRADIO_LINK_RESET ||
+			   priv->link_id_db[i].status == XRADIO_LINK_RESET_REMAP) {
+			int status = priv->link_id_db[i].status;
+			priv->link_id_db[i].status = XRADIO_LINK_OFF;
+			priv->link_id_db[i].timestamp = now;
+			spin_unlock_bh(&priv->ps_state_lock);
+			SYS_WARN(xrwl_unmap_link(priv, i + 1));
+			if (status == XRADIO_LINK_RESET_REMAP) {
+				memcpy(map_link.mac_addr, priv->link_id_db[i].mac, ETH_ALEN);
+				map_link.link_id = i + 1;
+				SYS_WARN(wsm_map_link(hw_priv, &map_link, priv->if_id));
+				next_gc = min(next_gc, XRADIO_LINK_ID_GC_TIMEOUT);
+				priv->link_id_db[i].status = priv->link_id_db[i].prev_status;
+			}
+			spin_lock_bh(&priv->ps_state_lock);
+#endif
+		}
+		if (need_reset) {
+			skb_queue_purge(&priv->link_id_db[i].rx_queue);
+			ap_printk(XRADIO_DBG_NIY, "STA removed, link_id: %d\n", i + 1);
+		}
+	}
+	spin_unlock_bh(&priv->ps_state_lock);
+	if (next_gc != -1)
+		queue_delayed_work(hw_priv->workqueue,
+				   &priv->link_id_gc_work, next_gc);
+	wsm_unlock_tx(hw_priv);
+}
+
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+void xradio_notify_noa(struct xradio_vif *priv, int delay)
+{
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	struct cfg80211_p2p_ps p2p_ps = { 0 };
+	struct wsm_p2p_ps_modeinfo *modeinfo;
+	modeinfo = &priv->p2p_ps_modeinfo;
+
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (priv->join_status != XRADIO_JOIN_STATUS_AP)
+		return;
+
+	if (delay)
+		msleep(delay);
+
+	if (!SYS_WARN(wsm_get_p2p_ps_modeinfo(hw_priv, modeinfo))) {
+#if defined(CONFIG_XRADIO_DEBUG)
+		print_hex_dump_bytes("[AP] p2p_get_ps_modeinfo: ", DUMP_PREFIX_NONE,
+				    (u8 *)modeinfo, sizeof(*modeinfo));
+#endif /* CONFIG_XRADIO_DEBUG */
+		p2p_ps.opp_ps = !!(modeinfo->oppPsCTWindow & BIT(7));
+		p2p_ps.ctwindow = modeinfo->oppPsCTWindow & (~BIT(7));
+		p2p_ps.count = modeinfo->count;
+		p2p_ps.start = __le32_to_cpu(modeinfo->startTime);
+		p2p_ps.duration = __le32_to_cpu(modeinfo->duration);
+		p2p_ps.interval = __le32_to_cpu(modeinfo->interval);
+		p2p_ps.index = modeinfo->reserved;
+
+		/* ieee80211_p2p_noa_notify(priv->vif, &p2p_ps, GFP_KERNEL); */
+	}
+}
+#endif
+
+int xrwl_unmap_link(struct xradio_vif *priv, int link_id)
+{
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	int ret = 0;
+	struct wsm_operational_mode mode = {
+		.power_mode = wsm_power_mode_quiescent,
+		.disableMoreFlagUsage = true,
+	};
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (is_hardware_xradio(hw_priv)) {
+		struct wsm_map_link maplink = {
+			.link_id = link_id,
+			.unmap = true,
+		};
+		if (link_id)
+			memcpy(&maplink.mac_addr[0],
+			       priv->link_id_db[link_id - 1].mac, ETH_ALEN);
+		return wsm_map_link(hw_priv, &maplink, priv->if_id);
+	} else {
+		struct wsm_reset reset = {
+			.link_id = link_id,
+			.reset_statistics = true,
+		};
+		ret = wsm_reset(hw_priv, &reset, priv->if_id);
+		SYS_WARN(wsm_set_operational_mode(hw_priv, &mode, priv->if_id));
+		return ret;
+	}
+}
+
+#ifdef AP_HT_CAP_UPDATE
+void xradio_ht_info_update_work(struct work_struct *work)
+{
+	struct sk_buff *skb;
+	struct ieee80211_mgmt *mgmt;
+	u8 *ht_info, *ies;
+	u32 ies_len;
+	struct xradio_vif *priv =
+	    container_of(work, struct xradio_vif, ht_info_update_work);
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	struct wsm_update_ie update_ie = {
+		.what = WSM_UPDATE_IE_BEACON,
+		.count = 1,
+	};
+	ap_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	skb = ieee80211_beacon_get(priv->hw, priv->vif);
+	if (SYS_WARN(!skb))
+		return;
+
+	mgmt = (void *)skb->data;
+	ies = mgmt->u.beacon.variable;
+	ies_len = skb->len - (u32)(ies - (u8 *)mgmt);
+	ht_info = (u8 *)cfg80211_find_ie(WLAN_EID_HT_INFORMATION, ies, ies_len);
+	if (ht_info && priv->ht_info == HT_INFO_MASK) {
+		ht_info[HT_INFO_OFFSET] |= 0x11;
+		update_ie.ies = ht_info;
+		update_ie.length = HT_INFO_IE_LEN + 2;
+		SYS_WARN(wsm_update_ie(hw_priv, &update_ie, priv->if_id));
+	}
+	dev_kfree_skb(skb);
+}
+#endif
diff -Naurp a/drivers/net/wireless/xr829/wlan/ap.h b/drivers/net/wireless/xr829/wlan/ap.h
--- a/drivers/net/wireless/xr829/wlan/ap.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/ap.h	2022-08-27 01:22:42.962539893 +0300
@@ -0,0 +1,60 @@
+/*
+ * STA and AP APIs for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef AP_H_INCLUDED
+#define AP_H_INCLUDED
+
+#define XRADIO_NOA_NOTIFICATION_DELAY 10
+
+#ifdef AP_HT_CAP_UPDATE
+#define HT_INFO_OFFSET 4
+#define HT_INFO_MASK 0x0011
+#define HT_INFO_IE_LEN 22
+#endif
+
+int xradio_set_tim(struct ieee80211_hw *dev, struct ieee80211_sta *sta,
+		   bool set);
+int xradio_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		   struct ieee80211_sta *sta);
+int xradio_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		      struct ieee80211_sta *sta);
+void xradio_sta_notify(struct ieee80211_hw *dev, struct ieee80211_vif *vif,
+		       enum sta_notify_cmd notify_cmd,
+		       struct ieee80211_sta *sta);
+void xradio_bss_info_changed(struct ieee80211_hw *dev,
+			     struct ieee80211_vif *vif,
+			     struct ieee80211_bss_conf *info, u32 changed);
+int xradio_ampdu_action(struct ieee80211_hw *hw,
+			struct ieee80211_vif *vif,
+			enum ieee80211_ampdu_mlme_action action,
+			struct ieee80211_sta *sta, u16 tid, u16 *ssn,
+			u8 buf_size);
+
+void xradio_suspend_resume(struct xradio_vif *priv,
+			   struct wsm_suspend_resume *arg);
+void xradio_set_tim_work(struct work_struct *work);
+void xradio_set_cts_work(struct work_struct *work);
+void xradio_multicast_start_work(struct work_struct *work);
+void xradio_multicast_stop_work(struct work_struct *work);
+void xradio_mcast_timeout(struct timer_list *t);
+int xradio_find_link_id(struct xradio_vif *priv, const u8 *mac);
+int xradio_alloc_link_id(struct xradio_vif *priv, const u8 *mac);
+void xradio_link_id_work(struct work_struct *work);
+void xradio_link_id_gc_work(struct work_struct *work);
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+void xradio_notify_noa(struct xradio_vif *priv, int delay);
+#endif
+int xrwl_unmap_link(struct xradio_vif *priv, int link_id);
+#ifdef AP_HT_CAP_UPDATE
+void xradio_ht_info_update_work(struct work_struct *work);
+#endif
+
+#endif
diff -Naurp a/drivers/net/wireless/xr829/wlan/bh.c b/drivers/net/wireless/xr829/wlan/bh.c
--- a/drivers/net/wireless/xr829/wlan/bh.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/bh.c	2022-08-27 01:22:42.962539893 +0300
@@ -0,0 +1,2068 @@
+/*
+ * Data Transmission thread implementation for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <net/mac80211.h>
+#include <linux/kthread.h>
+#include <uapi/linux/sched/types.h>
+
+#include "xradio.h"
+#include "bh.h"
+#include "hwio.h"
+#include "wsm.h"
+#include "sbus.h"
+
+#ifdef SUPPORT_FW_DBG_INF
+#include "fw_dbg_inf.h"
+#endif
+
+/* TODO: Verify these numbers with WSM specification. */
+#define DOWNLOAD_BLOCK_SIZE_WR	(0x1000 - 4)
+/* an SPI message cannot be bigger than (2"12-1)*2 bytes
+ * "*2" to cvt to bytes */
+#define MAX_SZ_RD_WR_BUFFERS	(DOWNLOAD_BLOCK_SIZE_WR*2)
+#define PIGGYBACK_CTRL_REG	(2)
+#define EFFECTIVE_BUF_SIZE	(MAX_SZ_RD_WR_BUFFERS - PIGGYBACK_CTRL_REG)
+
+#define DEV_WAKEUP_MAX_TIME  (HZ<<1)   /* =HZ*2 = 2s*/
+#define DEV_WAKEUP_WAIT_TIME (HZ/50)   /*=20ms*/
+#define BH_TX_BURST_NONTXOP  (16)
+
+#if (SDIO_BLOCK_SIZE > 500)
+#define SKB_CACHE_LEN   (SDIO_BLOCK_SIZE)
+#elif (SDIO_BLOCK_SIZE > 250)
+#define SKB_CACHE_LEN   (SDIO_BLOCK_SIZE<<1)
+#else
+#define SKB_CACHE_LEN    xr_sdio_blksize_align(500)
+#endif
+#define SKB_RESV_MAX    (1900)
+
+int tx_burst_limit = BH_TX_BURST_NONTXOP;
+
+/* Suspend state privates */
+enum xradio_bh_pm_state {
+	XRADIO_BH_RESUMED = 0,
+	XRADIO_BH_SUSPEND,
+	XRADIO_BH_SUSPENDED,
+	XRADIO_BH_RESUME,
+};
+typedef int (*xradio_wsm_handler) (struct xradio_common *hw_priv, u8 *data,
+				   size_t size);
+
+static inline u32 bh_time_interval(struct timeval *oldtime)
+{
+	u32 time_int;
+	struct timeval newtime;
+	xr_do_gettimeofday(&newtime);
+	time_int = (newtime.tv_sec - oldtime->tv_sec) * 1000000 + \
+			   (long)(newtime.tv_usec - oldtime->tv_usec);
+	return time_int;
+}
+
+
+#ifdef MCAST_FWDING
+int wsm_release_buffer_to_fw(struct xradio_vif *priv, int count);
+#endif
+static int xradio_bh(void *arg);
+static void xradio_put_skb(struct xradio_common *hw_priv, struct sk_buff *skb);
+static struct sk_buff *xradio_get_skb(struct xradio_common *hw_priv, size_t len, u8 *flags);
+static inline int xradio_put_resv_skb(struct xradio_common *hw_priv,
+									  struct sk_buff *skb, u8 flags);
+
+#ifdef BH_PROC_THREAD
+static int xradio_proc(void *arg);
+int bh_proc_init(struct xradio_common *hw_priv)
+{
+	int ret = 0;
+	int i;
+	struct bh_items *pool = NULL;
+	bh_printk(XRADIO_DBG_MSG, "%s\n", __func__);
+
+	memset(&hw_priv->proc, 0, sizeof(struct bh_proc));
+	/* init locks and wait_queue */
+	spin_lock_init(&hw_priv->proc.lock);
+	init_waitqueue_head(&hw_priv->proc.proc_wq);
+
+	/* init pool and txrx queues */
+	atomic_set(&hw_priv->proc.proc_tx, 0);
+	atomic_set(&hw_priv->proc.rx_queued, 0);
+	atomic_set(&hw_priv->proc.tx_queued, 0);
+	INIT_LIST_HEAD(&hw_priv->proc.bh_tx);
+	INIT_LIST_HEAD(&hw_priv->proc.bh_rx);
+	INIT_LIST_HEAD(&hw_priv->proc.bh_free);
+	pool = xr_kzalloc(PROC_POOL_SIZE, false);
+	if (!pool)
+		return -ENOMEM;
+	else
+		hw_priv->proc.bh_pool[0] = pool;
+	for (i = 0; i < ITEM_RESERVED; ++i)
+		list_add_tail(&pool[i].head, &hw_priv->proc.bh_free);
+
+	/* init proc thread.*/
+	hw_priv->proc.proc_state = 0;
+	hw_priv->proc.proc_thread =
+		kthread_create(&xradio_proc, hw_priv, XRADIO_PROC_THREAD);
+	if (IS_ERR(hw_priv->proc.proc_thread)) {
+		ret = PTR_ERR(hw_priv->proc.proc_thread);
+		hw_priv->proc.proc_thread = NULL;
+	} else {
+#ifdef HAS_PUT_TASK_STRUCT
+		get_task_struct(hw_priv->proc.proc_thread);
+#endif
+		wake_up_process(hw_priv->proc.proc_thread);
+	}
+	return ret;
+}
+
+int bh_proc_flush_txqueue(struct xradio_common *hw_priv, int if_id)
+{
+	struct bh_items *item = NULL, *tmp = NULL;
+	spin_lock(&hw_priv->proc.lock);
+	/*flush proc tx queue, no need to dev_kfree_skb */
+	list_for_each_entry_safe(item, tmp, &hw_priv->proc.bh_tx, head) {
+		if (item) {
+			if (XRWL_ALL_IFS == if_id || item->if_id == if_id) {
+				item->data = NULL;
+				list_move_tail(&item->head, &hw_priv->proc.bh_free);
+				atomic_sub(1, &hw_priv->proc.tx_queued);
+			}
+		} else {
+			bh_printk(XRADIO_DBG_ERROR,
+					"%s tx item is NULL!\n", __func__);
+		}
+	}
+	if (XRWL_ALL_IFS == if_id) {
+		INIT_LIST_HEAD(&hw_priv->proc.bh_tx);
+		atomic_set(&hw_priv->proc.tx_queued, 0);
+		atomic_set(&hw_priv->proc.proc_tx, 0);
+	}
+	spin_unlock(&hw_priv->proc.lock);
+	return 0;
+}
+int bh_proc_flush_queue(struct xradio_common *hw_priv)
+{
+	struct bh_items *item = NULL;
+	spin_lock(&hw_priv->proc.lock);
+	/*flush proc rx queue */
+	while (!list_empty(&hw_priv->proc.bh_rx)) {
+		item = list_first_entry(&hw_priv->proc.bh_rx,
+							struct bh_items, head);
+		if (item) {
+			if (item->data) {
+				dev_kfree_skb((struct sk_buff *)item->data);
+				item->data = NULL;
+			} else {
+				bh_printk(XRADIO_DBG_ERROR,
+					"%s item->data is NULL!\n", __func__);
+			}
+			list_move_tail(&item->head, &hw_priv->proc.bh_free);
+		} else {
+			bh_printk(XRADIO_DBG_ERROR,
+					"%s rx item is NULL!\n", __func__);
+		}
+	}
+	INIT_LIST_HEAD(&hw_priv->proc.bh_rx);
+	atomic_set(&hw_priv->proc.rx_queued, 0);
+	spin_unlock(&hw_priv->proc.lock);
+
+	/*flush proc tx queue, no need to dev_kfree_skb */
+	bh_proc_flush_txqueue(hw_priv, XRWL_ALL_IFS);
+	return 0;
+}
+
+void bh_proc_deinit(struct xradio_common *hw_priv)
+{
+	struct task_struct *thread = hw_priv->proc.proc_thread;
+	int i = 0;
+	bh_printk(XRADIO_DBG_MSG, "%s\n", __func__);
+
+	/* deinit proc thread */
+	if (thread) {
+		hw_priv->proc.proc_thread = NULL;
+		kthread_stop(thread);
+	#ifdef HAS_PUT_TASK_STRUCT
+		put_task_struct(thread);
+	#endif
+	} else {
+		bh_printk(XRADIO_DBG_WARN,
+			"%s thread is NULL!\n", __func__);
+	}
+
+	/* clear tx/rx queue */
+	bh_proc_flush_queue(hw_priv);
+
+	/* clear free queue */
+	INIT_LIST_HEAD(&hw_priv->proc.bh_free);
+
+	/*free proc pool*/
+	for (i = 0; i < PROC_POOL_NUM; i++) {
+		if (hw_priv->proc.bh_pool[i]) {
+			kfree(hw_priv->proc.bh_pool[i]);
+			hw_priv->proc.bh_pool[i] = NULL;
+		} else if (i == 0) {
+			bh_printk(XRADIO_DBG_WARN,
+				"%s bh_pool[0] is NULL!\n", __func__);
+		}
+	}
+
+	return ;
+}
+
+int bh_proc_reinit(struct xradio_common *hw_priv)
+{
+	bh_proc_deinit(hw_priv);
+	return bh_proc_init(hw_priv);
+}
+
+static struct bh_items *xradio_get_free_item(struct xradio_common *hw_priv)
+{
+	struct bh_items *item = NULL;
+	if (likely(!list_empty(&hw_priv->proc.bh_free))) {
+		item = list_first_entry(&hw_priv->proc.bh_free,
+			struct bh_items, head);
+	} else {
+		int i = 0;
+		struct bh_items *pool = NULL;
+		for (i = 0; i < PROC_POOL_NUM; i++) {
+			if (!hw_priv->proc.bh_pool[i]) {
+				pool = xr_kzalloc(PROC_POOL_SIZE, false);
+				hw_priv->proc.bh_pool[i] = pool;
+				break;
+			}
+		}
+		if (pool) {
+			bh_printk(XRADIO_DBG_WARN, "%s alloc pool%d!\n",
+				__func__, i);
+			for (i = 0; i < ITEM_RESERVED; ++i)
+				list_add_tail(&pool[i].head, &hw_priv->proc.bh_free);
+			item = list_first_entry(&hw_priv->proc.bh_free,
+				struct bh_items, head);
+		} else {
+			bh_printk(XRADIO_DBG_ERROR, "%s Failed alloc pool%d!\n",
+				__func__, i);
+		}
+	}
+	return item;
+}
+
+void xradio_proc_wakeup(struct xradio_common *hw_priv)
+{
+	bh_printk(XRADIO_DBG_MSG, "%s\n", __func__);
+#if BH_PROC_TX
+	if (atomic_add_return(1, &hw_priv->proc.proc_tx) == 1) {
+		bh_printk(XRADIO_DBG_NIY, "%s\n", __func__);
+		wake_up(&hw_priv->proc.proc_wq);
+	}
+#else
+	xradio_bh_wakeup(hw_priv);
+#endif
+}
+
+#if PERF_INFO_TEST
+struct timeval proc_start_time;
+#endif
+
+#if BH_PROC_DPA
+#define PROC_HIGH_IDX  0
+#define PROC_LOW_IDX  4
+const struct thread_dpa g_dpa[] = {
+	{SCHED_FIFO,  25},
+	{SCHED_FIFO,  50},
+	{SCHED_FIFO,  75},
+	{SCHED_FIFO,  99},
+	{SCHED_NORMAL, 0}
+};
+int thread_dpa_up(struct task_struct *p, s8 *prio_index)
+{
+	int ret = 0;
+	s8  idx = 0;
+	if (unlikely(!p || !prio_index)) {
+		bh_printk(XRADIO_DBG_ERROR,
+			"%s, task_struct=%p, prio_index=%p\n",
+			__func__, p, prio_index);
+		return -EINVAL;
+	}
+	idx = (*prio_index) - 1;
+	if (idx > PROC_HIGH_IDX) {
+		struct sched_param param = {
+			.sched_priority = g_dpa[idx].priority
+		};
+		bh_printk(XRADIO_DBG_NIY, "%s=%d\n", __func__, idx);
+		ret = sched_setscheduler(p, g_dpa[idx].policy, &param);
+		if (!ret)
+			*prio_index = idx;
+		else
+			bh_printk(XRADIO_DBG_ERROR,
+				"%s, sched_setscheduler failed, idx=%d\n",
+				__func__, idx);
+		return ret;
+	} else {
+		bh_printk(XRADIO_DBG_NIY, "%s, prio_index=%d\n",
+			__func__, idx + 1);
+		return 0;
+	}
+}
+int thread_dpa_down(struct task_struct *p, u8 *prio_index)
+{
+	int ret = 0;
+	s8  idx = 0;
+	if (unlikely(!p || !prio_index)) {
+		bh_printk(XRADIO_DBG_ERROR,
+			"%s, task_struct=%p, prio_index=%p\n",
+			__func__, p, prio_index);
+		return -EINVAL;
+	}
+	idx = (*prio_index) + 1;
+	if (idx < PROC_LOW_IDX) {
+		struct sched_param param = {
+			.sched_priority = g_dpa[idx].priority
+		};
+		bh_printk(XRADIO_DBG_NIY, "%s=%d\n", __func__, idx);
+		ret = sched_setscheduler(p, g_dpa[idx].policy, &param);
+		if (!ret)
+			*prio_index = idx;
+		else
+			bh_printk(XRADIO_DBG_ERROR,
+				"%s, sched_setscheduler failed, idx=%d\n",
+				__func__, idx);
+		return ret;
+	} else {
+		bh_printk(XRADIO_DBG_NIY, "%s, prio_index=%d\n",
+			__func__, idx - 1);
+		return 0;
+	}
+}
+static inline int proc_set_priority(struct xradio_common *hw_priv, u8 idx)
+{
+	struct sched_param param = {
+		.sched_priority = g_dpa[idx].priority
+	};
+	hw_priv->proc.proc_prio = idx;
+	return sched_setscheduler(hw_priv->proc.proc_thread,
+			g_dpa[idx].policy, &param);
+}
+int dpa_proc_tx;
+int dpa_proc_rx;
+u32 proc_dpa_cnt;
+u32 proc_up_cnt;
+u32 proc_down_cnt;
+static inline int proc_dpa_update(struct xradio_common *hw_priv)
+{
+	int tx_ret = 0;
+	int rx_ret = 0;
+	int dpa_old = 0;
+	int i = 0;
+
+	if (!hw_priv->proc.proc_thread)
+		return -ENOENT;
+	++proc_dpa_cnt;
+	/*update by rx.*/
+	dpa_old = dpa_proc_rx;
+	dpa_proc_rx = atomic_read(&hw_priv->proc.rx_queued);
+	if (dpa_proc_rx >= (ITEM_RESERVED>>2) ||
+		dpa_proc_rx >= (dpa_old + 10)) {
+		rx_ret = 1;
+	} else if ((dpa_proc_rx + 20) < dpa_old ||
+		dpa_proc_rx < (ITEM_RESERVED>>5)) {
+		rx_ret = -1;
+	}
+
+	/* update by tx.*/
+	dpa_old = dpa_proc_tx;
+	for (dpa_proc_tx = 0, i = 0; i < 4; ++i) {
+		dpa_proc_tx += hw_priv->tx_queue[i].num_queued -
+			hw_priv->tx_queue[i].num_pending;
+	}
+	if (dpa_proc_tx > (dpa_old + 10) ||
+		dpa_proc_tx > XRWL_HOST_VIF0_11N_THROTTLE) {
+		tx_ret = 1;
+	} else if ((dpa_proc_tx + 10) < dpa_old ||
+		dpa_proc_tx < (XRWL_HOST_VIF0_11N_THROTTLE>>2)) {
+		tx_ret = -1;
+	}
+
+	if (rx_ret > 0 || tx_ret > 0) {
+		++proc_up_cnt;
+		if (++hw_priv->proc.prio_cnt > 10) {
+			hw_priv->proc.prio_cnt = 0;
+			return thread_dpa_up(hw_priv->proc.proc_thread,
+				&hw_priv->proc.proc_prio);
+		}
+	} else if (rx_ret < 0 && tx_ret < 0) {
+		++proc_down_cnt;
+		if (--hw_priv->proc.prio_cnt < -10) {
+			hw_priv->proc.prio_cnt = 0;
+			return thread_dpa_down(hw_priv->proc.proc_thread,
+				&hw_priv->proc.proc_prio);
+		}
+	}
+	return 0;
+}
+#endif
+
+static int xradio_proc(void *arg)
+{
+	struct xradio_common *hw_priv = arg;
+#if !BH_PROC_DPA
+	struct sched_param param = {
+		.sched_priority = 99
+	};
+#endif
+	int ret = 0;
+	int term = 0;
+	int tx = 0;
+	int rx = 0;
+#if BH_PROC_DPA
+	int dpa_num = 0;
+#endif
+	bh_printk(XRADIO_DBG_MSG, "%s\n", __func__);
+
+#if BH_PROC_DPA
+	ret = proc_set_priority(hw_priv, 3);
+#else
+	ret = sched_setscheduler(hw_priv->proc.proc_thread,
+			SCHED_FIFO, &param);
+#endif
+	if (ret)
+		bh_printk(XRADIO_DBG_WARN, "%s sched_setscheduler failed(%d)\n",
+			__func__, ret);
+
+	for (;;) {
+		PERF_INFO_GETTIME(&proc_start_time);
+		ret = wait_event_interruptible(hw_priv->proc.proc_wq, ({
+			term = kthread_should_stop();
+#if BH_PROC_RX
+			rx = atomic_read(&hw_priv->proc.rx_queued);
+#else
+			rx = 0;
+#endif
+#if BH_PROC_TX
+			tx = atomic_xchg(&hw_priv->proc.proc_tx, 0);
+#else
+			tx = 0;
+#endif
+			(term || ((rx || tx) &&
+			!hw_priv->bh_error && !hw_priv->proc.proc_state &&
+			XRADIO_BH_RESUMED == atomic_read(&hw_priv->bh_suspend))); }));
+
+		/* 0--proc is going to be shut down */
+		if (term) {
+			bh_printk(XRADIO_DBG_NIY, "%s exit!\n", __func__);
+			break;
+		} else if (ret < 0) {
+			bh_printk(XRADIO_DBG_ERROR, "%s wait_event err=%d!\n",
+				__func__, ret);
+			continue;  /*continue to wait for exit */
+		}
+		PERF_INFO_STAMP_UPDATE(&proc_start_time, &proc_wait, 0);
+
+		while (rx || tx) {
+			bh_printk(XRADIO_DBG_NIY, "%s rx=%d, tx=%d\n",
+				__func__, rx, tx);
+#if BH_PROC_RX
+			/* 1--handle rx*/
+			if (rx) {
+				size_t rx_len = 0;
+				spin_lock(&hw_priv->proc.lock);
+				if (likely(!list_empty(&hw_priv->proc.bh_rx))) {
+					struct bh_items *rx_item = NULL;
+					struct sk_buff *rx_skb   = NULL;
+					u8 flags = 0;
+					rx_item = list_first_entry(&hw_priv->proc.bh_rx,
+						struct bh_items, head);
+					if (rx_item) {
+						rx_skb = (struct sk_buff *)rx_item->data;
+						flags  = rx_item->flags;
+						rx_item->data = NULL;
+						rx_len = rx_item->datalen;
+						list_move_tail(&rx_item->head,
+							&hw_priv->proc.bh_free);
+					}
+					rx = atomic_sub_return(1, &hw_priv->proc.rx_queued);
+					spin_unlock(&hw_priv->proc.lock);
+					if (rx_skb) {
+						ret = wsm_handle_rx(hw_priv, rx_item->flags, &rx_skb);
+						/* Reclaim the SKB buffer */
+						if (rx_skb) {
+							if (xradio_put_resv_skb(hw_priv, rx_skb, rx_item->flags))
+								xradio_put_skb(hw_priv, rx_skb);
+							rx_skb = NULL;
+						}
+						if (ret) {
+							bh_printk(XRADIO_DBG_ERROR,
+								"wsm_handle_rx err=%d!\n", ret);
+							break;
+						}
+					} else {
+						bh_printk(XRADIO_DBG_ERROR,
+							"%s rx_item data is NULL\n", __func__);
+					}
+					hw_priv->proc.rxed_num++;
+				} else {
+					rx = 0;
+					hw_priv->proc.proc_state = 1;  /*need to restart proc*/
+					bh_printk(XRADIO_DBG_WARN,
+						"rx_queued=%d, but proc.bh_rx is empty!\n",
+						atomic_read(&hw_priv->proc.rx_queued));
+					spin_unlock(&hw_priv->proc.lock);
+				}
+				PERF_INFO_STAMP_UPDATE(&proc_start_time, &proc_rx, rx_len);
+			}
+#endif
+
+#if BH_PROC_TX
+			/* 2--handle tx*/
+			if (tx) {
+				u8 *data = NULL;
+				size_t tx_len = 0;
+				int burst = 0;
+				int vif_selected = 0;
+				ret = wsm_get_tx(hw_priv, &data, &tx_len,
+					&burst, &vif_selected);
+				if (ret < 0) {
+					bh_printk(XRADIO_DBG_ERROR,
+								"wsm_get_tx err=%d!\n", ret);
+					tx = 0;
+					break;
+				} else if (ret) {
+					struct bh_items *item  = NULL;
+					spin_lock(&hw_priv->proc.lock);
+					item = xradio_get_free_item(hw_priv);
+					if (likely(item)) {
+						SYS_BUG(item->data);
+						item->data = data;
+						item->datalen = tx_len;
+						if (unlikely(item->datalen != tx_len)) {
+							bh_printk(XRADIO_DBG_ERROR,
+								"%s datalen=%u, tx_len=%zu.\n",
+								__func__, item->datalen, tx_len);
+						}
+						item->if_id = vif_selected;
+						item->flags = 0;
+						list_move_tail(&item->head, &hw_priv->proc.bh_tx);
+						spin_unlock(&hw_priv->proc.lock);
+						if (atomic_add_return(1, &hw_priv->proc.tx_queued) == 1 &&
+							hw_priv->bh_thread) {
+							xradio_bh_wakeup(hw_priv);
+						}
+						hw_priv->proc.txed_num++;
+						bh_printk(XRADIO_DBG_NIY,
+							"%s Tx if=%d, datalen=%zu, queued=%d\n",
+							__func__, vif_selected, tx_len,
+							atomic_read(&hw_priv->proc.tx_queued));
+					} else {
+						bh_printk(XRADIO_DBG_ERROR,
+							"%s pool is empty\n", __func__);
+						spin_unlock(&hw_priv->proc.lock);
+						hw_priv->proc.proc_state = 1; /*need to restart proc*/
+						break;
+					}
+				} else {
+					tx = 0;
+					bh_printk(XRADIO_DBG_NIY, "wsm_get_tx no data!\n");
+				}
+				PERF_INFO_STAMP_UPDATE(&proc_start_time, &proc_tx, tx_len);
+			}
+#endif
+
+#if BH_PROC_DPA
+			if (++dpa_num > 20) {
+				proc_dpa_update(hw_priv);
+				dpa_num = 0;
+			}
+#endif
+		}  /* while */
+
+		if (hw_priv->proc.proc_state) {
+			/* proc error occurs, to restart driver.*/
+			hw_priv->bh_error = 1;
+		}
+
+#if 0
+		/* for debug */
+		if (!atomic_read(&hw_priv->proc.proc_tx)) {
+			int num = 0;
+			int pending = 0;
+			int i = 0;
+			for (i = 0; i < 4; ++i) {
+				pending += hw_priv->tx_queue[i].num_pending;
+				num += hw_priv->tx_queue[i].num_queued -
+					hw_priv->tx_queue[i].num_pending;
+			}
+			if (num && !atomic_read(&hw_priv->proc.proc_tx)) {
+				bh_printk(XRADIO_DBG_NIY,
+					"%s rx=%d, tx=%d, num=%d, pending=%d, "
+					" rx_queued=%d, bufuse=%d\n",
+					__func__, rx, tx, num, pending,
+					atomic_read(&hw_priv->proc.rx_queued),
+					hw_priv->hw_bufs_used);
+			}
+		}
+#endif
+
+	} /* for (;;) */
+	return 0;
+}
+
+#if BH_PROC_TX
+static inline int xradio_bh_get(struct xradio_common *hw_priv, u8 **data,
+			size_t *tx_len, int *burst, int *vif_selected)
+{
+	int ret = 0;
+	bh_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	/* check cmd first */
+	spin_lock(&hw_priv->wsm_cmd.lock);
+	if (hw_priv->wsm_cmd.ptr) {
+		*data = hw_priv->wsm_cmd.ptr;
+		*tx_len = hw_priv->wsm_cmd.len;
+		*burst = atomic_read(&hw_priv->proc.tx_queued) + 1;
+		*vif_selected = -1;
+		spin_unlock(&hw_priv->wsm_cmd.lock);
+		return 1;
+	}
+	spin_unlock(&hw_priv->wsm_cmd.lock);
+
+	/* check tx data */
+	spin_lock(&hw_priv->proc.lock);
+	if (!list_empty(&hw_priv->proc.bh_tx) &&
+		!atomic_read(&hw_priv->tx_lock) &&
+		hw_priv->hw_bufs_used < hw_priv->wsm_caps.numInpChBufs) {
+		struct bh_items *item = list_first_entry(
+			&hw_priv->proc.bh_tx, struct bh_items, head);
+		if (item && item->data) {
+			struct xradio_queue_item *queue_item =
+				(struct xradio_queue_item *)item->data;
+			queue_item->xmit_timestamp = jiffies;
+			queue_item->xmit_to_fw = 1;
+			*data = queue_item->skb->data;
+			*tx_len = item->datalen;
+			*vif_selected = item->if_id;
+			*burst = atomic_sub_return(1, &hw_priv->proc.tx_queued) + 1;
+			item->data = NULL;
+			list_move_tail(&item->head, &hw_priv->proc.bh_free);
+			ret = 1;
+			bh_printk(XRADIO_DBG_NIY, "%s tx_len=%zu, burst=%d!\n",
+				__func__, *tx_len, *burst);
+		} else {
+			bh_printk(XRADIO_DBG_ERROR, "%s item=%p, data=%p!\n",
+				__func__, item, item->data);
+			ret = -ENOENT;
+		}
+	}
+	spin_unlock(&hw_priv->proc.lock);
+	return ret;
+}
+#endif
+
+#if PERF_INFO_TEST
+struct timeval bh_put_time;
+#endif
+
+static inline int xradio_bh_put(struct xradio_common *hw_priv,
+		struct sk_buff **skb_p, u8 flags)
+{
+	struct bh_items *item = NULL;
+	bh_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	PERF_INFO_GETTIME(&bh_put_time);
+	spin_lock(&hw_priv->proc.lock);
+	if (unlikely(!hw_priv->proc.proc_thread)) {
+		spin_unlock(&hw_priv->proc.lock);
+		bh_printk(XRADIO_DBG_WARN,
+			"%s proc_thread is stopped!\n", __func__);
+		dev_kfree_skb(*skb_p);
+		*skb_p = NULL;
+		return 0;
+	}
+	item = xradio_get_free_item(hw_priv);
+	if (likely(item)) {
+		SYS_BUG(item->data);
+		item->data = (u8 *)(*skb_p);
+		item->datalen = (*skb_p)->len;
+		if (unlikely(item->datalen != (*skb_p)->len)) {
+			bh_printk(XRADIO_DBG_ERROR,
+				"%s datalen=%u, skblen=%u.\n",
+				__func__, item->datalen, (*skb_p)->len);
+		}
+		item->flags = flags;
+		if ((flags & ITEM_F_CMDCFM))
+			list_move(&item->head, &hw_priv->proc.bh_rx);
+		else
+			list_move_tail(&item->head, &hw_priv->proc.bh_rx);
+		spin_unlock(&hw_priv->proc.lock);
+		PERF_INFO_STAMP_UPDATE(&bh_put_time, &get_item, 0);
+		if (atomic_add_return(1, &hw_priv->proc.rx_queued) == 1) {
+			wake_up(&hw_priv->proc.proc_wq);
+		}
+		*skb_p = NULL;
+		PERF_INFO_STAMP(&bh_put_time, &wake_proc, 0);
+	} else {
+		bh_printk(XRADIO_DBG_ERROR,
+			"%s pool is empty!\n", __func__);
+		goto err;
+	}
+	return 0;
+
+err:
+	spin_unlock(&hw_priv->proc.lock);
+	return -ENOENT;
+}
+#endif /* #ifdef BH_PROC_THREAD */
+
+int xradio_register_bh(struct xradio_common *hw_priv)
+{
+	int err = 0;
+	bh_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	SYS_BUG(hw_priv->bh_thread);
+	atomic_set(&hw_priv->bh_rx, 0);
+	atomic_set(&hw_priv->bh_tx, 0);
+	atomic_set(&hw_priv->bh_term, 0);
+	atomic_set(&hw_priv->bh_suspend, XRADIO_BH_RESUMED);
+	hw_priv->buf_id_tx = 0;
+	hw_priv->buf_id_rx = 0;
+#ifdef BH_USE_SEMAPHORE
+	sema_init(&hw_priv->bh_sem, 0);
+	atomic_set(&hw_priv->bh_wk, 0);
+#else
+	init_waitqueue_head(&hw_priv->bh_wq);
+#endif
+	init_waitqueue_head(&hw_priv->bh_evt_wq);
+
+	hw_priv->bh_thread = kthread_create(&xradio_bh, hw_priv, XRADIO_BH_THREAD);
+	if (IS_ERR(hw_priv->bh_thread)) {
+		err = PTR_ERR(hw_priv->bh_thread);
+		hw_priv->bh_thread = NULL;
+	} else {
+#ifdef HAS_PUT_TASK_STRUCT
+		get_task_struct(hw_priv->bh_thread);
+#endif
+		wake_up_process(hw_priv->bh_thread);
+	}
+
+	return err;
+}
+
+void xradio_unregister_bh(struct xradio_common *hw_priv)
+{
+	struct task_struct *thread = hw_priv->bh_thread;
+	bh_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (SYS_WARN(!thread))
+		return;
+
+	hw_priv->bh_thread = NULL;
+	kthread_stop(thread);
+#ifdef HAS_PUT_TASK_STRUCT
+	put_task_struct(thread);
+#endif
+	bh_printk(XRADIO_DBG_NIY, "Unregister success.\n");
+}
+
+void xradio_irq_handler(void *priv)
+{
+	struct xradio_common *hw_priv = (struct xradio_common *)priv;
+	bh_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	DBG_INT_ADD(irq_count);
+	if (/* SYS_WARN */(hw_priv->bh_error))
+		return;
+#ifdef BH_USE_SEMAPHORE
+	atomic_add(1, &hw_priv->bh_rx);
+	if (atomic_add_return(1, &hw_priv->bh_wk) == 1) {
+		up(&hw_priv->bh_sem);
+	}
+#else
+	if (atomic_add_return(1, &hw_priv->bh_rx) == 1) {
+		wake_up(&hw_priv->bh_wq);
+	}
+#endif
+
+}
+
+void xradio_bh_wakeup(struct xradio_common *hw_priv)
+{
+	bh_printk(XRADIO_DBG_MSG, "%s\n", __func__);
+	if (hw_priv->bh_error) {
+		bh_printk(XRADIO_DBG_ERROR, "%s bh_error=%d\n",
+			__func__, hw_priv->bh_error);
+		return;
+	}
+#ifdef BH_USE_SEMAPHORE
+	atomic_add(1, &hw_priv->bh_tx);
+	if (atomic_add_return(1, &hw_priv->bh_wk) == 1) {
+		up(&hw_priv->bh_sem);
+	}
+#else
+	if (atomic_add_return(1, &hw_priv->bh_tx) == 1) {
+		wake_up(&hw_priv->bh_wq);
+	}
+#endif
+}
+
+int xradio_bh_suspend(struct xradio_common *hw_priv)
+{
+
+#ifdef MCAST_FWDING
+	int i = 0;
+	struct xradio_vif *priv = NULL;
+#endif
+
+	bh_printk(XRADIO_DBG_MSG, "%s\n", __func__);
+
+	if (hw_priv->bh_thread == NULL)
+		return 0;
+
+	if (hw_priv->bh_error)
+		return -EINVAL;
+
+#ifdef MCAST_FWDING
+	xradio_for_each_vif(hw_priv, priv, i) {
+		if (!priv)
+			continue;
+		if ((priv->multicast_filter.enable)
+		    && (priv->join_status == XRADIO_JOIN_STATUS_AP)) {
+			wsm_release_buffer_to_fw(priv,
+						 (hw_priv->wsm_caps.
+						  numInpChBufs - 1));
+			break;
+		}
+	}
+#endif
+
+	atomic_set(&hw_priv->bh_suspend, XRADIO_BH_SUSPEND);
+#ifdef BH_USE_SEMAPHORE
+	up(&hw_priv->bh_sem);
+#else
+	wake_up(&hw_priv->bh_wq);
+#endif
+	return wait_event_timeout(hw_priv->bh_evt_wq, (hw_priv->bh_error ||
+		XRADIO_BH_SUSPENDED == atomic_read(&hw_priv->bh_suspend)),
+		    1 * HZ) ? 0 : -ETIMEDOUT;
+}
+
+int xradio_bh_resume(struct xradio_common *hw_priv)
+{
+
+#ifdef MCAST_FWDING
+	int ret;
+	int i = 0;
+	struct xradio_vif *priv = NULL;
+#endif
+
+	bh_printk(XRADIO_DBG_MSG, "%s\n", __func__);
+	if (hw_priv->bh_error || atomic_read(&hw_priv->bh_term)) {
+		return -EINVAL;
+	}
+
+	atomic_set(&hw_priv->bh_suspend, XRADIO_BH_RESUME);
+#ifdef BH_USE_SEMAPHORE
+	up(&hw_priv->bh_sem);
+#else
+	wake_up(&hw_priv->bh_wq);
+#endif
+
+#ifdef MCAST_FWDING
+	ret = wait_event_timeout(hw_priv->bh_evt_wq, (hw_priv->bh_error ||
+	     XRADIO_BH_RESUMED == atomic_read(&hw_priv->bh_suspend)), 1 * HZ) ?
+	     0 : -ETIMEDOUT;
+
+	xradio_for_each_vif(hw_priv, priv, i) {
+		if (!priv)
+			continue;
+		if ((priv->join_status == XRADIO_JOIN_STATUS_AP) &&
+			  (priv->multicast_filter.enable)) {
+			u8 count = 0;
+			SYS_WARN(wsm_request_buffer_request(priv, &count));
+			bh_printk(XRADIO_DBG_NIY, "Reclaim Buff %d \n", count);
+			break;
+		}
+	}
+
+	return ret;
+#else
+	return wait_event_timeout(hw_priv->bh_evt_wq, hw_priv->bh_error ||
+		(XRADIO_BH_RESUMED == atomic_read(&hw_priv->bh_suspend)),
+		1 * HZ) ? 0 : -ETIMEDOUT;
+#endif
+
+}
+
+static inline void wsm_alloc_tx_buffer(struct xradio_common *hw_priv)
+{
+	++hw_priv->hw_bufs_used;
+}
+
+int wsm_release_tx_buffer(struct xradio_common *hw_priv, int count)
+{
+	int ret = 0;
+	int hw_bufs_used = hw_priv->hw_bufs_used;
+	bh_printk(XRADIO_DBG_MSG, "%s\n", __func__);
+
+	hw_priv->hw_bufs_used -= count;
+	if (SYS_WARN(hw_priv->hw_bufs_used < 0)) {
+		/* Tx data patch stops when all but one hw buffers are used.
+		   So, re-start tx path in case we find hw_bufs_used equals
+		   numInputChBufs - 1.
+		 */
+		bh_printk(XRADIO_DBG_ERROR, "%s, hw_bufs_used=%d, count=%d.\n",
+			  __func__, hw_priv->hw_bufs_used, count);
+		ret = -1;
+	} else if (hw_bufs_used >= (hw_priv->wsm_caps.numInpChBufs - 1))
+		ret = 1;
+	if (!hw_priv->hw_bufs_used)
+		wake_up(&hw_priv->bh_evt_wq);
+	return ret;
+}
+
+int wsm_release_vif_tx_buffer(struct xradio_common *hw_priv,
+							  int if_id, int count)
+{
+	int ret = 0;
+	bh_printk(XRADIO_DBG_MSG, "%s\n", __func__);
+
+	hw_priv->hw_bufs_used_vif[if_id] -= count;
+	if (!hw_priv->hw_bufs_used_vif[if_id])
+		wake_up(&hw_priv->bh_evt_wq);
+
+	if (hw_priv->hw_bufs_used_vif[if_id] < 0) {
+		bh_printk(XRADIO_DBG_WARN,
+			"%s, if=%d, used=%d, count=%d.\n", __func__, if_id,
+			hw_priv->hw_bufs_used_vif[if_id], count);
+		ret = -1;
+	}
+	return ret;
+}
+
+#ifdef MCAST_FWDING
+int wsm_release_buffer_to_fw(struct xradio_vif *priv, int count)
+{
+	int i;
+	u8 flags;
+	struct wsm_hdr *wsm;
+	struct xradio_common *hw_priv = priv->hw_priv;
+	struct wsm_buf *buf = &hw_priv->wsm_release_buf;
+	size_t buf_len = buf->end - buf->begin;
+
+	bh_printk(XRADIO_DBG_MSG, "%s\n", __func__);
+
+	if (priv->join_status != XRADIO_JOIN_STATUS_AP || buf_len == 0) {
+		return 0;
+	}
+	bh_printk(XRADIO_DBG_NIY, "Rel buffer to FW %d, %d\n",
+		  count, hw_priv->hw_bufs_used);
+
+	for (i = 0; i < count; i++) {
+		if ((hw_priv->hw_bufs_used + 1) < hw_priv->wsm_caps.numInpChBufs) {
+			/* Fill Buffer Request Msg */
+			flags = i ? 0 : 0x1;
+			buf->data[0] = flags;
+
+			/* Add sequence number */
+			wsm = (struct wsm_hdr *)buf->begin;
+			wsm->id &= __cpu_to_le32(~WSM_TX_SEQ(WSM_TX_SEQ_MAX));
+			wsm->id |= cpu_to_le32(WSM_TX_SEQ(hw_priv->wsm_tx_seq));
+			bh_printk(XRADIO_DBG_NIY, "REL %d, len=%d, buflen=%zu\n",
+				  hw_priv->wsm_tx_seq, wsm->len, buf_len);
+
+			wsm_alloc_tx_buffer(hw_priv);
+			if (SYS_WARN(xradio_data_write(hw_priv, buf->begin, buf_len))) {
+				break;
+			}
+			hw_priv->buf_released = 1;
+			hw_priv->wsm_tx_seq = (hw_priv->wsm_tx_seq + 1) & WSM_TX_SEQ_MAX;
+		} else
+			break;
+	}
+
+	if (i == count) {
+		return 0;
+	}
+
+	/* Should not be here */
+	bh_printk(XRADIO_DBG_ERROR, "Error, Less HW buf %d, %d.\n",
+		  hw_priv->hw_bufs_used, hw_priv->wsm_caps.numInpChBufs);
+	SYS_WARN(1);
+	return -1;
+}
+#endif
+
+/* reserve a packet for the case dev_alloc_skb failed in bh.*/
+int xradio_init_resv_skb(struct xradio_common *hw_priv)
+{
+	int len = SKB_RESV_MAX + WSM_TX_EXTRA_HEADROOM + \
+			   8 + 12;	/* TKIP IV + ICV and MIC */
+	len = xr_sdio_blksize_align(len);
+	bh_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	spin_lock_init(&hw_priv->cache_lock);
+	hw_priv->skb_reserved = xr_alloc_skb(len);
+	if (hw_priv->skb_reserved) {
+		hw_priv->skb_resv_len = len;
+		skb_reserve(hw_priv->skb_reserved,
+			WSM_TX_EXTRA_HEADROOM + 8 /* TKIP IV */
+			- WSM_RX_EXTRA_HEADROOM);
+	} else {
+		bh_printk(XRADIO_DBG_WARN, "%s xr_alloc_skb failed(%d)\n",
+			__func__, len);
+	}
+	return 0;
+}
+
+void xradio_deinit_resv_skb(struct xradio_common *hw_priv)
+{
+	bh_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	if (hw_priv->skb_reserved) {
+		dev_kfree_skb(hw_priv->skb_reserved);
+		hw_priv->skb_reserved = NULL;
+		hw_priv->skb_resv_len = 0;
+	}
+}
+
+int xradio_realloc_resv_skb(struct xradio_common *hw_priv,
+							struct sk_buff *skb, u8 flags)
+{
+	/* spin_lock(&hw_priv->cache_lock); */
+	if (!hw_priv->skb_reserved && hw_priv->skb_resv_len) {
+		hw_priv->skb_reserved = xr_alloc_skb(hw_priv->skb_resv_len);
+		if (!hw_priv->skb_reserved && (flags & ITEM_F_RESERVE)) {
+			hw_priv->skb_reserved = skb;
+			skb_reserve(hw_priv->skb_reserved,
+				WSM_TX_EXTRA_HEADROOM + 8 /* TKIP IV */
+				- WSM_RX_EXTRA_HEADROOM);
+			/* spin_unlock(&hw_priv->cache_lock); */
+			bh_printk(XRADIO_DBG_WARN, "%s xr_alloc_skb failed(%d)\n",
+				__func__, hw_priv->skb_resv_len);
+			return -1;
+		}
+	}
+	/* spin_unlock(&hw_priv->cache_lock); */
+	return 0; /* realloc sbk success, deliver to upper.*/
+}
+
+static inline struct sk_buff *xradio_get_resv_skb(struct xradio_common *hw_priv,
+												  size_t len)
+{	struct sk_buff *skb = NULL;
+	/* spin_lock(&hw_priv->cache_lock); */
+	if (hw_priv->skb_reserved && len <= hw_priv->skb_resv_len) {
+		skb = hw_priv->skb_reserved;
+		hw_priv->skb_reserved = NULL;
+	}
+	/* spin_unlock(&hw_priv->cache_lock); */
+	return skb;
+}
+
+static inline int xradio_put_resv_skb(struct xradio_common *hw_priv,
+									  struct sk_buff *skb, u8 flags)
+{
+	/* spin_lock(&hw_priv->cache_lock); */
+	if (!hw_priv->skb_reserved && hw_priv->skb_resv_len &&
+	    (flags & ITEM_F_RESERVE)) {
+		hw_priv->skb_reserved = skb;
+		/* spin_unlock(&hw_priv->cache_lock); */
+		return 0;
+	}
+	/* spin_unlock(&hw_priv->cache_lock); */
+	return 1; /* sbk not put to reserve*/
+}
+
+static struct sk_buff *xradio_get_skb(struct xradio_common *hw_priv, size_t len, u8 *flags)
+{
+	struct sk_buff *skb = NULL;
+	size_t alloc_len = (len > SKB_CACHE_LEN) ? len : SKB_CACHE_LEN;
+	bh_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	/* TKIP IV + TKIP ICV and MIC - Piggyback.*/
+	alloc_len += WSM_TX_EXTRA_HEADROOM + 8 + 12 - 2;
+	if (len > SKB_CACHE_LEN || !hw_priv->skb_cache) {
+		skb = xr_alloc_skb_pf(alloc_len);
+		/* In AP mode RXed SKB can be looped back as a broadcast.
+		 * Here we reserve enough space for headers. */
+		if (skb) {
+			skb_reserve(skb, WSM_TX_EXTRA_HEADROOM + 8 /* TKIP IV */
+					    - WSM_RX_EXTRA_HEADROOM);
+		} else {
+			skb = xradio_get_resv_skb(hw_priv, alloc_len);
+			if (skb) {
+				*flags |= ITEM_F_RESERVE;
+				bh_printk(XRADIO_DBG_WARN, "%s get skb_reserved(%zu)!\n",
+					__func__, alloc_len);
+			} else {
+				bh_printk(XRADIO_DBG_ERROR, "%s xr_alloc_skb failed(%zu)!\n",
+					__func__, alloc_len);
+			}
+		}
+	} else {
+		/* don't care cache because min len is SKB_CACHE_LEN*/
+		/* spin_lock(&hw_priv->cache_lock); */
+		skb = hw_priv->skb_cache;
+		hw_priv->skb_cache = NULL;
+		/* spin_unlock(&hw_priv->cache_lock); */
+	}
+	return skb;
+}
+
+static void xradio_put_skb(struct xradio_common *hw_priv, struct sk_buff *skb)
+{
+	bh_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	/* spin_lock(&hw_priv->cache_lock); */
+	if (hw_priv->skb_cache)
+		dev_kfree_skb(skb);
+	else {
+		hw_priv->skb_cache = skb;
+	}
+	/* spin_unlock(&hw_priv->cache_lock); */
+}
+
+static int xradio_bh_read_ctrl_reg(struct xradio_common *hw_priv,
+				   u16 *ctrl_reg)
+{
+	int ret = 0;
+
+	ret = xradio_reg_read_16(hw_priv, HIF_CONTROL_REG_ID, ctrl_reg);
+	if (ret) {
+		*ctrl_reg = 0;
+		ret = 0;
+		bh_printk(XRADIO_DBG_NIY, "read ctrl failed, SDIO DCE occupied!\n");
+		ret = xradio_reg_read_16(hw_priv, HIF_CONTROL_REG_ID, ctrl_reg);
+		if (ret) {
+			hw_priv->bh_error = 1;
+			bh_printk(XRADIO_DBG_ERROR, "Failed to read control register.\n");
+		}
+	}
+	return ret;
+}
+
+static inline int xradio_device_sleep(struct xradio_common *hw_priv)
+{
+	int ret;
+	ret = xradio_reg_write_32(hw_priv, HIF_CONTROL_REG_ID, 0);
+	if (ret) {
+		hw_priv->bh_error = 1;
+		bh_printk(XRADIO_DBG_ERROR, "%s:control reg failed.\n", __func__);
+	}
+
+	return ret;
+}
+
+struct timeval wakeup_time;
+static int xradio_device_wakeup(struct xradio_common *hw_priv, u16 *ctrl_reg_ptr)
+{
+	int ret = 0;
+	unsigned long time = 0;
+
+	bh_printk(XRADIO_DBG_MSG, "%s\n", __func__);
+
+	PERF_INFO_GETTIME(&wakeup_time);
+	/* To force the device to be always-on, the host sets WLAN_UP to 1 */
+	ret = xradio_reg_write_16(hw_priv, HIF_CONTROL_REG_ID, HIF_CTRL_WUP_BIT);
+	if (SYS_WARN(ret))
+		return ret;
+
+	ret = xradio_bh_read_ctrl_reg(hw_priv, ctrl_reg_ptr);
+	if (SYS_WARN(ret))
+		return ret;
+
+	/* If the device returns WLAN_RDY as 1, the device is active and will
+	 * remain active. */
+	time = jiffies + DEV_WAKEUP_MAX_TIME;
+	while (!(*ctrl_reg_ptr & (HIF_CTRL_RDY_BIT|HIF_CTRL_NEXT_LEN_MASK)) &&
+		   time_before(jiffies, time) && !ret) {
+#ifdef BH_USE_SEMAPHORE
+		msleep(1);
+#else
+		wait_event_timeout(hw_priv->bh_wq,
+				atomic_read(&hw_priv->bh_rx), DEV_WAKEUP_WAIT_TIME);
+#endif
+		ret = xradio_bh_read_ctrl_reg(hw_priv, ctrl_reg_ptr);
+	}
+
+	PERF_INFO_STAMP(&wakeup_time, &dev_wake, 0);
+
+	if (likely(*ctrl_reg_ptr & HIF_CTRL_RDY_BIT)) {
+		bh_printk(XRADIO_DBG_NIY, "Device awake, t=%ldms.\n",
+			(jiffies+DEV_WAKEUP_MAX_TIME-time)*1000/HZ);
+		return 1;
+	} else if (*ctrl_reg_ptr & HIF_CTRL_NEXT_LEN_MASK) { /*device has data to rx.*/
+		bh_printk(XRADIO_DBG_NIY, "To rx data before wakeup, len=%d.\n",
+				(*ctrl_reg_ptr & HIF_CTRL_NEXT_LEN_MASK)<<1);
+		return (int)(*ctrl_reg_ptr & HIF_CTRL_NEXT_LEN_MASK);
+	} else {
+		bh_printk(XRADIO_DBG_ERROR, "Device cannot wakeup in %dms.\n",
+				DEV_WAKEUP_MAX_TIME*1000/HZ);
+		return -1;
+	}
+}
+
+#ifdef BH_COMINGRX_FORECAST
+static bool xradio_comingrx_update(struct xradio_common *hw_priv)
+{
+	static bool is_full;
+	static unsigned long tmo;
+	if (hw_priv->hw_bufs_used >= (hw_priv->wsm_caps.numInpChBufs-1)) {
+		if (is_full == false) {
+			tmo = jiffies + (HZ/166);/*1/166s = 6ms*/
+		}
+		is_full = true;
+	} else {
+		tmo = jiffies - 1;
+		is_full = false;
+	}
+
+	if (time_before(jiffies, tmo))
+		return true;
+	else
+		return false;
+
+}
+#endif
+
+/* Must be called from BH thraed. */
+void xradio_enable_powersave(struct xradio_vif *priv, bool enable)
+{
+	priv->powersave_enabled = enable;
+	bh_printk(XRADIO_DBG_NIY, "Powerave is %s.\n",
+		  enable ? "enabled" : "disabled");
+}
+
+#if PERF_INFO_TEST
+struct timeval tx_start_time1;
+struct timeval tx_start_time2;
+struct timeval rx_start_time1;
+struct timeval rx_start_time2;
+struct timeval bh_start_time;
+struct timeval sdio_reg_time;
+extern struct timeval last_showtime;
+#endif
+
+u32  sdio_reg_cnt1;
+u32  sdio_reg_cnt2;
+u32  sdio_reg_cnt3;
+u32  sdio_reg_cnt4;
+u32  sdio_reg_cnt5;
+u32  sdio_reg_cnt6;
+u32  tx_limit_cnt1;
+u32  tx_limit_cnt2;
+u32  tx_limit_cnt3;
+u32  tx_limit_cnt4;
+u32  tx_limit_cnt5;
+u32  tx_limit_cnt6;
+
+static int xradio_bh(void *arg)
+{
+	struct xradio_common *hw_priv = arg;
+	struct sched_param param = {
+		.sched_priority = 1
+	};
+	int ret = 0;
+	struct sk_buff *skb_rx = NULL;
+	size_t read_len = 0;
+	int rx = 0, tx = 0, term, suspend;
+	struct wsm_hdr *wsm;
+	size_t wsm_len;
+	int wsm_id;
+	u8 wsm_seq;
+	int rx_resync = 1;
+	u16 ctrl_reg = 0;
+	int tx_allowed;
+	int pending_tx = 0;
+	int tx_burst;
+	int tx_bursted = 0;
+	int rx_burst = 0;
+	long status;
+	bool coming_rx = false;
+#if 0
+	u32 dummy;
+#endif
+	int reg_read = 1;
+	int vif_selected;
+
+	bh_printk(XRADIO_DBG_MSG, "%s\n", __func__);
+	ret = sched_setscheduler(hw_priv->bh_thread, SCHED_FIFO, &param);
+	if (ret)
+		bh_printk(XRADIO_DBG_WARN, "%s sched_setscheduler failed(%d)\n",
+			__func__, ret);
+
+	PERF_INFO_GETTIME(&last_showtime);
+	for (;;) {
+		PERF_INFO_GETTIME(&bh_start_time);
+		/* Check if devices can sleep, and set time to wait for interrupt. */
+		if (!hw_priv->hw_bufs_used && !pending_tx &&
+		    hw_priv->powersave_enabled && !hw_priv->device_can_sleep &&
+		    !atomic_read(&hw_priv->recent_scan) &&
+		    atomic_read(&hw_priv->bh_rx) == 0 &&
+		    atomic_read(&hw_priv->bh_tx) == 0) {
+			bh_printk(XRADIO_DBG_MSG, "Device idle, can sleep.\n");
+			SYS_WARN(xradio_device_sleep(hw_priv));
+			hw_priv->device_can_sleep = true;
+			status = (HZ>>3);	/*1/8s = 125ms*/
+		} else if (hw_priv->hw_bufs_used >=
+			(hw_priv->wsm_caps.numInpChBufs - 1)) {
+			/* don't wait too long if some frames to confirm
+			 * and miss interrupt.*/
+			status = (HZ>>4);	/*1/16s=62ms.*/
+		} else {
+			status = (HZ>>3);	/*1/8s = 125ms*/
+		}
+
+
+#if 0
+		/* Dummy Read for SDIO retry mechanism */
+		if (atomic_read(&hw_priv->bh_rx) == 0 &&
+		    atomic_read(&hw_priv->bh_tx) == 0) {
+			xradio_reg_read(hw_priv, HIF_CONFIG_REG_ID, &dummy, sizeof(dummy));
+		}
+#endif
+
+#if 0
+		/* If a packet has already been txed to the device then read the
+		 * control register for a probable interrupt miss before going
+		 * further to wait for interrupt; if the read length is non-zero
+		 * then it means there is some data to be received */
+		if (hw_priv->hw_bufs_used) {
+			PERF_INFO_GETTIME(&sdio_reg_time);
+			atomic_xchg(&hw_priv->bh_rx, 0);
+			xradio_bh_read_ctrl_reg(hw_priv, &ctrl_reg);
+			++reg_read;
+			++sdio_reg_cnt1;
+			PERF_INFO_STAMP(&sdio_reg_time, &sdio_reg, 4);
+			if (ctrl_reg & HIF_CTRL_NEXT_LEN_MASK) {
+				DBG_INT_ADD(fix_miss_cnt);
+				rx = 1;
+				goto data_proc;
+			} else {
+				++sdio_reg_cnt5;
+			}
+		}
+#endif
+
+#ifdef BH_COMINGRX_FORECAST
+		coming_rx = xradio_comingrx_update(hw_priv);
+
+		if (coming_rx) {
+			PERF_INFO_GETTIME(&sdio_reg_time);
+			atomic_xchg(&hw_priv->bh_rx, 0);
+			xradio_bh_read_ctrl_reg(hw_priv, &ctrl_reg);
+			++reg_read;
+			++sdio_reg_cnt1;
+			PERF_INFO_STAMP(&sdio_reg_time, &sdio_reg, 4);
+			if (ctrl_reg & HIF_CTRL_NEXT_LEN_MASK) {
+				DBG_INT_ADD(fix_miss_cnt);
+				rx = 1;
+				goto data_proc;
+			} else {
+				++sdio_reg_cnt5;
+			}
+		}
+#endif
+
+		PERF_INFO_GETTIME(&sdio_reg_time);
+		/* Wait for Events in HZ/8 */
+#ifdef BH_USE_SEMAPHORE
+		rx = atomic_xchg(&hw_priv->bh_rx, 0);
+		tx = atomic_xchg(&hw_priv->bh_tx, 0);
+		suspend = pending_tx ? 0 : atomic_read(&hw_priv->bh_suspend);
+		term = kthread_should_stop();
+		if (!(rx || tx || coming_rx || term || suspend || hw_priv->bh_error)) {
+			atomic_set(&hw_priv->bh_wk, 0);
+			status = (long)(down_timeout(&hw_priv->bh_sem, status) != -ETIME);
+			rx = atomic_xchg(&hw_priv->bh_rx, 0);
+			tx = atomic_xchg(&hw_priv->bh_tx, 0);
+			suspend = pending_tx ? 0 : atomic_read(&hw_priv->bh_suspend);
+			term = kthread_should_stop();
+		}
+#else
+		status = wait_event_interruptible_timeout(hw_priv->bh_wq, ({
+			 rx = atomic_xchg(&hw_priv->bh_rx, 0);
+			 tx = atomic_xchg(&hw_priv->bh_tx, 0);
+			 term = kthread_should_stop();
+			 suspend = pending_tx ? 0 : atomic_read(&hw_priv->bh_suspend);
+			 (rx || tx || coming_rx || term || suspend || hw_priv->bh_error); }),
+			 status);
+#endif
+		PERF_INFO_STAMP(&sdio_reg_time, &bh_wait, 0);
+
+		/* 0--bh is going to be shut down */
+		if (term) {
+			bh_printk(XRADIO_DBG_MSG, "xradio_bh exit!\n");
+			break;
+		}
+		/* 1--An fatal error occurs */
+		if (status < 0 || hw_priv->bh_error) {
+			bh_printk(XRADIO_DBG_ERROR, "bh_error=%d, status=%ld\n",
+				  hw_priv->bh_error, status);
+			hw_priv->bh_error = __LINE__;
+			break;
+		}
+
+		/* 2--Wait for interrupt time out */
+		if (!status) {
+			DBG_INT_ADD(bh_idle);
+			/* Check if miss interrupt. */
+			PERF_INFO_GETTIME(&sdio_reg_time);
+			xradio_bh_read_ctrl_reg(hw_priv, &ctrl_reg);
+			PERF_INFO_STAMP(&sdio_reg_time, &sdio_reg, 4);
+			++reg_read;
+			++sdio_reg_cnt2;
+			if (ctrl_reg & HIF_CTRL_NEXT_LEN_MASK) {
+				bh_printk(XRADIO_DBG_WARN, "miss interrupt!\n");
+				DBG_INT_ADD(int_miss_cnt);
+				rx = 1;
+				goto data_proc;
+			} else {
+				++sdio_reg_cnt5;
+			}
+
+			/* There are some frames to be confirmed. */
+			if (hw_priv->hw_bufs_used) {
+				long timeout = 0;
+				bool pending = 0;
+				bh_printk(XRADIO_DBG_NIY, "Need confirm:%d!\n",
+					  hw_priv->hw_bufs_used);
+				/* Check if frame transmission is timed out. */
+				pending = xradio_query_txpkt_timeout(hw_priv, XRWL_ALL_IFS,
+					       hw_priv->pending_frame_id, &timeout);
+				/* There are some frames confirm time out. */
+				if (pending && timeout < 0) {
+					bh_printk(XRADIO_DBG_ERROR,
+						  "query_txpkt_timeout:%ld!\n", timeout);
+					hw_priv->bh_error = __LINE__;
+					break;
+				}
+				rx = 1;	/* Go to check rx again. */
+			} else if (!pending_tx) {
+				if (hw_priv->powersave_enabled &&
+					!hw_priv->device_can_sleep &&
+					!atomic_read(&hw_priv->recent_scan)) {
+					/* Device is idle, we can go to sleep. */
+					bh_printk(XRADIO_DBG_MSG,
+						  "Device idle(timeout), can sleep.\n");
+					SYS_WARN(xradio_device_sleep(hw_priv));
+					hw_priv->device_can_sleep = true;
+				}
+				PERF_INFO_STAMP(&bh_start_time, &bh_others, 0);
+				continue;
+			}
+		/* 3--Host suspend request. */
+		} else if (suspend) {
+			bh_printk(XRADIO_DBG_NIY, "Host suspend request.\n");
+			/* Check powersave setting again. */
+			if (hw_priv->powersave_enabled) {
+				bh_printk(XRADIO_DBG_MSG,
+					 "Device idle(host suspend), can sleep.\n");
+				SYS_WARN(xradio_device_sleep(hw_priv));
+				hw_priv->device_can_sleep = true;
+			}
+
+			/* bh thread go to suspend. */
+			atomic_set(&hw_priv->bh_suspend, XRADIO_BH_SUSPENDED);
+			wake_up(&hw_priv->bh_evt_wq);
+#ifdef BH_USE_SEMAPHORE
+			do {
+				status = down_timeout(&hw_priv->bh_sem, HZ/10);
+				term = kthread_should_stop();
+			} while (XRADIO_BH_RESUME != atomic_read(&hw_priv->bh_suspend) &&
+				     !term && !hw_priv->bh_error);
+			if (XRADIO_BH_RESUME != atomic_read(&hw_priv->bh_suspend))
+				status = -1;
+			else
+				status = 0;
+#else
+			status = wait_event_interruptible(hw_priv->bh_wq, ({
+				term = kthread_should_stop();
+				(XRADIO_BH_RESUME == atomic_read(&hw_priv->bh_suspend) ||
+				term || hw_priv->bh_error); }));
+#endif
+			if (hw_priv->bh_error) {
+				bh_printk(XRADIO_DBG_ERROR, "bh error during bh suspend.\n");
+				break;
+			} else if (term) {
+				bh_printk(XRADIO_DBG_WARN, "bh exit during bh suspend.\n");
+				break;
+			} else if (status < 0) {
+				bh_printk(XRADIO_DBG_ERROR,
+					  "Failed to wait for resume: %ld.\n", status);
+				hw_priv->bh_error = __LINE__;
+				break;
+			}
+			bh_printk(XRADIO_DBG_NIY, "Host resume.\n");
+			atomic_set(&hw_priv->bh_suspend, XRADIO_BH_RESUMED);
+			wake_up(&hw_priv->bh_evt_wq);
+			atomic_add(1, &hw_priv->bh_rx);
+			continue;
+		}
+		/* query stuck frames in firmware. */
+		if (atomic_xchg(&hw_priv->query_cnt, 0)) {
+			if (schedule_work(&hw_priv->query_work) <= 0)
+				atomic_add(1, &hw_priv->query_cnt);
+		}
+
+#if 0
+		/* If a packet has already been txed to the device then read the
+		 * control register for a probable interrupt miss before going
+		 * further to wait for interrupt; if the read length is non-zero
+		 * then it means there is some data to be received */
+		if ((hw_priv->wsm_caps.numInpChBufs -
+			hw_priv->hw_bufs_used) <= 1 && !reg_read) {
+			PERF_INFO_GETTIME(&sdio_reg_time);
+			atomic_xchg(&hw_priv->bh_rx, 0);
+			xradio_bh_read_ctrl_reg(hw_priv, &ctrl_reg);
+			++sdio_reg_cnt1;
+			PERF_INFO_STAMP(&sdio_reg_time, &sdio_reg, 4);
+			if (ctrl_reg & HIF_CTRL_NEXT_LEN_MASK) {
+				DBG_INT_ADD(fix_miss_cnt);
+				rx = 1;
+				goto data_proc;
+			} else {
+				++sdio_reg_cnt5;
+			}
+		}
+#endif
+
+		/* 4--Rx & Tx process. */
+data_proc:
+		term = kthread_should_stop();
+		if (hw_priv->bh_error || term)
+			break;
+		/*pre-txrx*/
+		tx_bursted = 0;
+
+		rx += atomic_xchg(&hw_priv->bh_rx, 0);
+		if (rx) {
+			size_t alloc_len;
+			u8 *data;
+			u8 flags;
+
+			/* Check ctrl_reg again. */
+			if (!(ctrl_reg & HIF_CTRL_NEXT_LEN_MASK)) {
+				PERF_INFO_GETTIME(&sdio_reg_time);
+				if (SYS_WARN(xradio_bh_read_ctrl_reg(hw_priv, &ctrl_reg))) {
+					hw_priv->bh_error = __LINE__;
+					break;
+				}
+				++reg_read;
+				++sdio_reg_cnt3;
+				PERF_INFO_STAMP(&sdio_reg_time, &sdio_reg, 4);
+			}
+			PERF_INFO_STAMP(&bh_start_time, &bh_others, 0);
+
+			/* read_len=ctrl_reg*2.*/
+			read_len = (ctrl_reg & HIF_CTRL_NEXT_LEN_MASK)<<1;
+			if (!read_len) {
+				++sdio_reg_cnt6;
+				rx = 0;
+				goto tx;
+			}
+
+rx:
+			reg_read = 0;
+			flags = 0;
+			PERF_INFO_GETTIME(&rx_start_time1);
+			if (SYS_WARN((read_len < sizeof(struct wsm_hdr)) ||
+				     (read_len > EFFECTIVE_BUF_SIZE))) {
+				bh_printk(XRADIO_DBG_ERROR, "Invalid read len: %zu", read_len);
+				hw_priv->bh_error = __LINE__;
+				break;
+			}
+#if BH_PROC_RX
+			if (unlikely(atomic_read(&hw_priv->proc.rx_queued) >=
+				((ITEM_RESERVED*PROC_POOL_NUM) - XRWL_MAX_QUEUE_SZ - 1))) {
+				bh_printk(XRADIO_DBG_WARN,
+					"Too many rx packets, proc cannot handle in time!\n");
+				msleep(10);
+				goto tx; /* too many rx packets to be handled, do tx first*/
+			}
+#endif
+
+			/* Add SIZE of PIGGYBACK reg (CONTROL Reg)
+			 * to the NEXT Message length + 2 Bytes for SKB */
+			read_len = read_len + 2;
+			alloc_len = hw_priv->sbus_ops->align_size(hw_priv->sbus_priv,
+				      read_len);
+			/* Check if not exceeding XRADIO capabilities */
+			if (WARN_ON_ONCE(alloc_len > EFFECTIVE_BUF_SIZE)) {
+				bh_printk(XRADIO_DBG_ERROR,
+					"Read aligned len: %zu\n", alloc_len);
+			} else {
+				bh_printk(XRADIO_DBG_MSG,
+					"Rx len=%zu, aligned len=%zu\n",
+					read_len, alloc_len);
+			}
+
+			/* Get skb buffer. */
+			skb_rx = xradio_get_skb(hw_priv, alloc_len, &flags);
+			if (SYS_WARN(!skb_rx)) {
+				bh_printk(XRADIO_DBG_ERROR, "xradio_get_skb failed.\n");
+				hw_priv->bh_error = __LINE__;
+				break;
+			}
+			skb_trim(skb_rx, 0);
+			skb_put(skb_rx, read_len);
+			data = skb_rx->data;
+			if (SYS_WARN(!data)) {
+				bh_printk(XRADIO_DBG_ERROR, "skb data is NULL.\n");
+				hw_priv->bh_error = __LINE__;
+				break;
+			}
+			PERF_INFO_STAMP(&rx_start_time1, &prepare_rx, alloc_len);
+
+			/* Read data from device. */
+			PERF_INFO_GETTIME(&rx_start_time2);
+			if (SYS_WARN(xradio_data_read(hw_priv, data, alloc_len))) {
+				hw_priv->bh_error = __LINE__;
+				break;
+			}
+			DBG_INT_ADD(rx_total_cnt);
+
+			PERF_INFO_STAMP_UPDATE(&rx_start_time2, &sdio_read, alloc_len);
+
+			/* Piggyback */
+			ctrl_reg = __le16_to_cpu(((__le16 *)data)[(alloc_len >> 1) - 1]);
+
+			/* check wsm length. */
+			wsm = (struct wsm_hdr *)data;
+			wsm_len = __le32_to_cpu(wsm->len);
+			if (SYS_WARN(wsm_len > read_len)) {
+				bh_printk(XRADIO_DBG_ERROR, "wsm_id=0x%04x, wsm_len=%zu.\n",
+						(__le32_to_cpu(wsm->id) & 0xFFF), wsm_len);
+				hw_priv->bh_error = __LINE__;
+				break;
+			}
+
+			/* dump rx data. */
+#if defined(CONFIG_XRADIO_DEBUG)
+			if (unlikely(hw_priv->wsm_enable_wsm_dumps)) {
+				u16 msgid, ifid;
+				u16 *p = (u16 *) data;
+				msgid = (*(p + 1)) & WSM_MSG_ID_MASK;
+				ifid = (*(p + 1)) >> 6;
+				ifid &= 0xF;
+				bh_printk(XRADIO_DBG_ALWY,
+					  "[DUMP] msgid 0x%.4X ifid %d len %d\n",
+					  msgid, ifid, *p);
+				print_hex_dump_bytes("<-- ", DUMP_PREFIX_NONE, data,
+				   min(wsm_len, (size_t)hw_priv->wsm_dump_max_size));
+			}
+#endif /* CONFIG_XRADIO_DEBUG */
+
+			/* extract wsm id and seq. */
+			wsm_id = __le32_to_cpu(wsm->id) & 0xFFF;
+			wsm_seq = (__le32_to_cpu(wsm->id) >> 13) & 7;
+			/* for multi-rx indication, there two case.*/
+			if (ROUND4(wsm_len) < read_len - 2)
+				skb_trim(skb_rx, read_len - 2);
+			else
+				skb_trim(skb_rx, wsm_len);
+
+			/* process exceptions. */
+			if (unlikely(wsm_id == 0x0800)) {
+				bh_printk(XRADIO_DBG_ERROR, "firmware exception!\n");
+				wsm_handle_exception(hw_priv, &data[sizeof(*wsm)],
+						     wsm_len - sizeof(*wsm));
+				hw_priv->bh_error = __LINE__;
+				break;
+			} else if (likely(!rx_resync)) {
+				if (SYS_WARN(wsm_seq != hw_priv->wsm_rx_seq)) {
+					bh_printk(XRADIO_DBG_ERROR, "wsm_seq=%d.\n", wsm_seq);
+					hw_priv->bh_error = __LINE__;
+					break;
+				}
+			}
+			hw_priv->wsm_rx_seq = (wsm_seq + 1) & 7;
+			rx_resync = 0;
+#if (DGB_XRADIO_HWT)
+			rx_resync = 1;	/*0 -> 1, HWT test, should not check this.*/
+#endif
+
+			/* Process tx frames confirm. */
+			if (wsm_id & 0x0400) {
+				int rc = 0;
+				int if_id = 0;
+				u32 *cfm = (u32 *)(wsm + 1);
+				wsm_id &= ~WSM_TX_LINK_ID(WSM_TX_LINK_ID_MAX);
+				if (wsm_id == 0x041E) {
+					int cfm_cnt = *cfm;
+					struct wsm_tx_confirm *tx_cfm =
+						(struct wsm_tx_confirm *)(cfm + 1);
+					bh_printk(XRADIO_DBG_NIY, "multi-cfm %d.\n", cfm_cnt);
+
+					rc = wsm_release_tx_buffer(hw_priv, cfm_cnt);
+					do {
+						if_id = xradio_queue_get_if_id(tx_cfm->packetID);
+						wsm_release_vif_tx_buffer(hw_priv, if_id, 1);
+						tx_cfm = (struct wsm_tx_confirm *)((u8 *)tx_cfm +
+							offsetof(struct wsm_tx_confirm, link_id));
+					} while (--cfm_cnt);
+				} else {
+					rc = wsm_release_tx_buffer(hw_priv, 1);
+					if (wsm_id == 0x0404) {
+						if_id = xradio_queue_get_if_id(*cfm);
+						wsm_release_vif_tx_buffer(hw_priv, if_id, 1);
+					} else {
+#if BH_PROC_RX
+						flags |= ITEM_F_CMDCFM;
+#endif
+					}
+					bh_printk(XRADIO_DBG_NIY, "cfm id=0x%04x.\n", wsm_id);
+				}
+				if (SYS_WARN(rc < 0)) {
+					bh_printk(XRADIO_DBG_ERROR, "tx buffer < 0.\n");
+					hw_priv->bh_error = __LINE__;
+					break;
+				} else if (rc > 0) {
+					tx = 1;
+					xradio_proc_wakeup(hw_priv);
+				}
+			}
+
+			/* WSM processing frames. */
+#if BH_PROC_RX
+			if (SYS_WARN(xradio_bh_put(hw_priv, &skb_rx, flags))) {
+				bh_printk(XRADIO_DBG_ERROR, "xradio_bh_put failed.\n");
+				hw_priv->bh_error = __LINE__;
+				break;
+			}
+#else
+			if (SYS_WARN(wsm_handle_rx(hw_priv, flags, &skb_rx))) {
+				bh_printk(XRADIO_DBG_ERROR, "wsm_handle_rx failed.\n");
+				hw_priv->bh_error = __LINE__;
+				break;
+			}
+			/* Reclaim the SKB buffer */
+			if (skb_rx) {
+				if (xradio_put_resv_skb(hw_priv, skb_rx, flags))
+					xradio_put_skb(hw_priv, skb_rx);
+				skb_rx = NULL;
+			}
+#endif
+			PERF_INFO_STAMP(&rx_start_time2, &handle_rx, wsm_len);
+			PERF_INFO_STAMP(&rx_start_time1, &data_rx, wsm_len);
+
+			/* Check if rx burst */
+			read_len = (ctrl_reg & HIF_CTRL_NEXT_LEN_MASK)<<1;
+			if (!read_len) {
+				rx = 0;
+				rx_burst = 0;
+				goto tx;
+			} else if (rx_burst) {
+				xradio_debug_rx_burst(hw_priv);
+				--rx_burst;
+				goto rx;
+			}
+		} else {
+			PERF_INFO_STAMP(&bh_start_time, &bh_others, 0);
+		}
+
+tx:
+		SYS_BUG(hw_priv->hw_bufs_used > hw_priv->wsm_caps.numInpChBufs);
+		tx += pending_tx + atomic_xchg(&hw_priv->bh_tx, 0);
+#if BH_PROC_TX
+		tx += atomic_read(&hw_priv->proc.tx_queued);
+#endif
+		pending_tx = 0;
+		tx_burst = hw_priv->wsm_caps.numInpChBufs - hw_priv->hw_bufs_used;
+		tx_allowed = tx_burst > 0;
+		if (tx && tx_allowed) {
+			int ret;
+			u8 *data;
+			size_t tx_len;
+#if 0
+			int  num = 0, i;
+#endif
+
+			PERF_INFO_GETTIME(&tx_start_time1);
+			/* Wake up the devices */
+			if (hw_priv->device_can_sleep) {
+				ret = xradio_device_wakeup(hw_priv, &ctrl_reg);
+				if (SYS_WARN(ret < 0)) {
+					hw_priv->bh_error = __LINE__;
+					break;
+				} else if (ret == 1) {
+					hw_priv->device_can_sleep = false;
+				} else if (ret > 1) {
+					rx = 1;
+					ctrl_reg = (ret & HIF_CTRL_NEXT_LEN_MASK);
+					goto data_proc;
+				} else {	/* Wait for "awake" interrupt */
+					pending_tx = tx;
+					continue;
+				}
+			}
+			/* Increase Tx buffer */
+			wsm_alloc_tx_buffer(hw_priv);
+
+#if (DGB_XRADIO_HWT)
+			/*hardware test.*/
+			ret = get_hwt_hif_tx(hw_priv, &data, &tx_len,
+					     &tx_burst, &vif_selected);
+			if (ret <= 0)
+#endif /*DGB_XRADIO_HWT*/
+
+#if BH_PROC_TX
+				/* Get data to send and send it. */
+				ret = xradio_bh_get(hw_priv, &data, &tx_len, &tx_burst,
+						 &vif_selected);
+#else
+				/* Get data to send and send it. */
+				ret = wsm_get_tx(hw_priv, &data, &tx_len, &tx_burst,
+						 &vif_selected);
+#endif
+			if (ret <= 0) {
+				if (hw_priv->hw_bufs_used >= hw_priv->wsm_caps.numInpChBufs)
+					++tx_limit_cnt3;
+#if BH_PROC_TX
+				if (list_empty(&hw_priv->proc.bh_tx))
+					++tx_limit_cnt4;
+#endif
+				wsm_release_tx_buffer(hw_priv, 1);
+				if (SYS_WARN(ret < 0)) {
+					bh_printk(XRADIO_DBG_ERROR, "get tx packet=%d.\n", ret);
+					hw_priv->bh_error = __LINE__;
+					break;
+				}
+				tx = 0;
+				DBG_INT_ADD(tx_limit);
+				PERF_INFO_STAMP(&tx_start_time1, &prepare_tx, 0);
+			} else {
+				wsm = (struct wsm_hdr *)data;
+				SYS_BUG(tx_len < sizeof(*wsm));
+				if (SYS_BUG(__le32_to_cpu(wsm->len) != tx_len)) {
+					bh_printk(XRADIO_DBG_ERROR, "%s wsmlen=%u, tx_len=%zu.\n",
+						__func__, __le32_to_cpu(wsm->len), tx_len);
+				}
+
+				/* Continue to send next data if have any. */
+				atomic_add(1, &hw_priv->bh_tx);
+
+				if (tx_len <= 8)
+					tx_len = 16;
+				/* Align tx length and check it. */
+				/* HACK!!! Platform limitation.
+				 * It is also supported by upper layer:
+				 * there is always enough space at the end of the buffer. */
+				tx_len = hw_priv->sbus_ops->align_size(hw_priv->sbus_priv,
+								       tx_len);
+				/* Check if not exceeding XRADIO capabilities */
+				if (tx_len > EFFECTIVE_BUF_SIZE) {
+					bh_printk(XRADIO_DBG_WARN,
+						  "Write aligned len: %zu\n", tx_len);
+				} else {
+					bh_printk(XRADIO_DBG_MSG,
+						"Tx len=%d, aligned len=%zu\n",
+						wsm->len, tx_len);
+				}
+
+				/* Make sequence number. */
+				wsm->id &= __cpu_to_le32(~WSM_TX_SEQ(WSM_TX_SEQ_MAX));
+				wsm->id |= cpu_to_le32(WSM_TX_SEQ(hw_priv->wsm_tx_seq));
+
+				if ((wsm->id & WSM_MSG_ID_MASK) != 0x0004)
+					hw_priv->wsm_cmd.seq = cpu_to_le32(WSM_TX_SEQ(hw_priv->wsm_tx_seq));
+
+				PERF_INFO_STAMP(&tx_start_time1, &prepare_tx, tx_len);
+				PERF_INFO_GETTIME(&tx_start_time2);
+				/* Send the data to devices. */
+				if (SYS_WARN(xradio_data_write(hw_priv, data, tx_len))) {
+					wsm_release_tx_buffer(hw_priv, 1);
+					bh_printk(XRADIO_DBG_ERROR, "xradio_data_write failed\n");
+					hw_priv->bh_error = __LINE__;
+					break;
+				}
+				DBG_INT_ADD(tx_total_cnt);
+				PERF_INFO_STAMP(&tx_start_time2, &sdio_write, tx_len);
+
+#if defined(CONFIG_XRADIO_DEBUG)
+				if (unlikely(hw_priv->wsm_enable_wsm_dumps)) {
+					u16 msgid, ifid;
+					u16 *p = (u16 *) data;
+					msgid = (*(p + 1)) & 0x3F;
+					ifid = (*(p + 1)) >> 6;
+					ifid &= 0xF;
+					if (msgid == 0x0006) {
+						bh_printk(XRADIO_DBG_ALWY,
+							  "[DUMP] >>> msgid 0x%.4X ifid %d" \
+							  "len %d MIB 0x%.4X\n",
+							  msgid, ifid, *p, *(p + 2));
+					} else {
+						bh_printk(XRADIO_DBG_ALWY,
+							  "[DUMP] >>> msgid 0x%.4X ifid %d " \
+							  "len %d\n", msgid, ifid, *p);
+					}
+					print_hex_dump_bytes("--> ", DUMP_PREFIX_NONE, data,
+							     min(__le32_to_cpu(wsm->len),
+							     hw_priv->wsm_dump_max_size));
+				}
+#endif /* CONFIG_XRADIO_DEBUG */
+
+				/* Process after data have sent. */
+				if (vif_selected != -1) {
+					hw_priv->hw_bufs_used_vif[vif_selected]++;
+				}
+				wsm_txed(hw_priv, data);
+				hw_priv->wsm_tx_seq = (hw_priv->wsm_tx_seq + 1) & WSM_TX_SEQ_MAX;
+
+				PERF_INFO_STAMP(&tx_start_time1, &data_tx, wsm->len);
+
+				/* Check for burst. */
+#if !BH_PROC_TX
+				/*if not proc tx, just look to burst limit.*/
+				tx_burst = 2;
+#endif
+				if (tx_burst > 1 && tx_bursted < tx_burst_limit &&
+					(hw_priv->wsm_caps.numInpChBufs -
+					hw_priv->hw_bufs_used) > 1) {
+					xradio_debug_tx_burst(hw_priv);
+					if (rx_burst < tx_burst_limit)
+						++rx_burst;
+					++tx_bursted;
+					goto tx;
+				} else {
+					if (tx_bursted >= tx_burst_limit)
+						++tx_limit_cnt5;
+					if (tx_burst <= 1)
+						++tx_limit_cnt6;
+				}
+			}
+		} else {
+			/*no tx or not allow to tx, pending it.*/
+			pending_tx = tx;
+			if (!tx)
+				++tx_limit_cnt1;
+			if (!tx_allowed)
+				++tx_limit_cnt2;
+		}
+
+		PERF_INFO_GETTIME(&bh_start_time);
+		/*Check if there are frames to be rx. */
+		if (ctrl_reg & HIF_CTRL_NEXT_LEN_MASK) {
+			DBG_INT_ADD(next_rx_cnt);
+			rx = 1;
+			goto data_proc;
+		}
+		/*if no rx, we check tx again.*/
+		if (tx + atomic_xchg(&hw_priv->bh_tx, 0)) {
+			if (hw_priv->hw_bufs_used < (hw_priv->wsm_caps.numInpChBufs - 1)) {
+				tx = 1;
+				goto data_proc;
+			} else { /*if no tx buffer, we check rx reg.*/
+				PERF_INFO_GETTIME(&sdio_reg_time);
+				atomic_xchg(&hw_priv->bh_rx, 0);
+				xradio_bh_read_ctrl_reg(hw_priv, &ctrl_reg);
+				++reg_read;
+				++sdio_reg_cnt1;
+				PERF_INFO_STAMP(&sdio_reg_time, &sdio_reg, 4);
+				if (ctrl_reg & HIF_CTRL_NEXT_LEN_MASK) {
+					DBG_INT_ADD(fix_miss_cnt);
+					rx = 1;
+					goto data_proc;
+				} else {
+					++sdio_reg_cnt5;
+				}
+			}
+			if (hw_priv->hw_bufs_used < hw_priv->wsm_caps.numInpChBufs) {
+				tx = 1;
+				goto data_proc;
+			}
+		}
+
+
+#if 0
+		/*One more to check rx if reg has not be read. */
+		if (!reg_read && hw_priv->hw_bufs_used >=
+			(hw_priv->wsm_caps.numInpChBufs - 1)) {
+			atomic_xchg(&hw_priv->bh_rx, 0);
+			PERF_INFO_GETTIME(&sdio_reg_time);
+			xradio_bh_read_ctrl_reg(hw_priv, &ctrl_reg);
+			++reg_read;
+			++sdio_reg_cnt4;
+			PERF_INFO_STAMP(&sdio_reg_time, &sdio_reg, 4);
+			if (ctrl_reg & HIF_CTRL_NEXT_LEN_MASK) {
+				DBG_INT_ADD(fix_miss_cnt);
+				rx = 1;
+				goto data_proc;
+			} else {
+				++sdio_reg_cnt5;
+				rx = 0;
+			}
+		}
+#endif
+		DBG_INT_ADD(tx_rx_idle);
+		PERF_INFO_STAMP(&bh_start_time, &bh_others, 0);
+
+#if 0
+		if (hw_priv->wsm_caps.numInpChBufs - hw_priv->hw_bufs_used > 1 &&
+		    atomic_read(&hw_priv->bh_tx) == 0 && pending_tx == 0 &&
+			!tx && atomic_read(&hw_priv->tx_lock) == 0) {
+			int i = 0;
+			for (i = 0; i < 4; ++i) {
+				if (hw_priv->tx_queue[i].num_queued - hw_priv->tx_queue[i].num_pending) {
+					bh_printk(XRADIO_DBG_NIY, "queued=%d, pending=%d, buf=%d.\n",
+					hw_priv->tx_queue[i].num_queued,
+					hw_priv->tx_queue[i].num_pending,
+					hw_priv->wsm_caps.numInpChBufs - hw_priv->hw_bufs_used);
+					tx = 1;
+					xradio_proc_wakeup(hw_priv);
+					goto data_proc;
+				}
+			}
+		}
+#endif
+	}			/* for (;;) */
+
+	/* Free the SKB buffer when exit. */
+	if (skb_rx) {
+		dev_kfree_skb(skb_rx);
+		skb_rx = NULL;
+	}
+
+	/* If BH Error, handle it. */
+	if (!term) {
+		bh_printk(XRADIO_DBG_ERROR, "Fatal error, exitting code=%d.\n",
+			  hw_priv->bh_error);
+
+#ifdef SUPPORT_FW_DBG_INF
+		xradio_fw_dbg_dump_in_direct_mode(hw_priv);
+#endif
+
+#ifdef HW_ERROR_WIFI_RESET
+		/* notify upper layer to restart wifi.
+		 * don't do it in debug version. */
+#ifdef CONFIG_XRADIO_ETF
+		/* we should restart manually in etf mode.*/
+		if (!etf_is_connect() &&
+			XRADIO_BH_RESUMED == atomic_read(&hw_priv->bh_suspend)) {
+			wsm_upper_restart(hw_priv);
+		}
+#else
+		if (XRADIO_BH_RESUMED == atomic_read(&hw_priv->bh_suspend))
+			wsm_upper_restart(hw_priv);
+#endif
+#endif
+		/* TODO: schedule_work(recovery) */
+#ifndef HAS_PUT_TASK_STRUCT
+		/* The only reason of having this stupid code here is
+		 * that __put_task_struct is not exported by kernel. */
+		for (;;) {
+#ifdef BH_USE_SEMAPHORE
+			status = down_timeout(&hw_priv->bh_sem, HZ/10);
+			term = kthread_should_stop();
+			status = 0;
+#else
+			int status = wait_event_interruptible(hw_priv->bh_wq, ({
+				     term = kthread_should_stop();
+				     (term); }));
+#endif
+			if (status || term)
+				break;
+		}
+#endif
+	}
+	atomic_add(1, &hw_priv->bh_term);	/*debug info, show bh status.*/
+	return 0;
+}
diff -Naurp a/drivers/net/wireless/xr829/wlan/bh.h b/drivers/net/wireless/xr829/wlan/bh.h
--- a/drivers/net/wireless/xr829/wlan/bh.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/bh.h	2022-08-27 01:22:42.962539893 +0300
@@ -0,0 +1,100 @@
+/*
+ * Data Transmission thread for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef XRADIO_BH_H
+#define XRADIO_BH_H
+
+#define XRADIO_BH_THREAD   "xradio_bh"
+#define XRADIO_PROC_THREAD "xradio_proc"
+
+/* extern */ struct xradio_common;
+
+#define ITEM_F_RESERVE  0x80  /* use reserved skb */
+#define ITEM_F_CMDCFM   0x40  /* cmd confirm packets */
+#define ITEM_F_TXCFM    0x20  /* tx confirm packets */
+
+#if BH_PROC_TX
+#define BH_WAITING_RX_THRESHOLD  8
+#endif
+
+#ifdef BH_PROC_THREAD
+struct bh_items {
+	struct list_head  head;
+	u8                *data;
+	u16               datalen;
+	u8                if_id;
+	u8                flags;
+};
+
+#if BH_PROC_DPA
+struct thread_dpa {
+	int policy;
+	int priority;
+};
+extern u32 proc_dpa_cnt;
+extern u32 proc_up_cnt;
+extern u32 proc_down_cnt;
+#endif
+#define ITEM_RESERVED   256
+#define PROC_POOL_NUM   8
+#define PROC_POOL_SIZE  (sizeof(struct bh_items)*ITEM_RESERVED)
+struct bh_proc {
+	struct bh_items    *bh_pool[PROC_POOL_NUM];
+	struct list_head    bh_free;
+	struct list_head    bh_tx;
+	struct list_head    bh_rx;
+	atomic_t            tx_queued;
+	atomic_t            rx_queued;
+	atomic_t            proc_tx;
+	spinlock_t          lock;
+	size_t              txed_num;
+	size_t              rxed_num;
+	struct task_struct *proc_thread;
+	int                 proc_state;
+	wait_queue_head_t   proc_wq;
+#if BH_PROC_DPA
+	s8                  proc_prio;
+	s8                  prio_cnt;
+#endif
+};
+int bh_proc_init(struct xradio_common *hw_priv);
+void bh_proc_deinit(struct xradio_common *hw_priv);
+int bh_proc_reinit(struct xradio_common *hw_priv);
+int bh_proc_flush_queue(struct xradio_common *hw_priv);
+int bh_proc_flush_txqueue(struct xradio_common *hw_priv, int if_id);
+#endif /*BH_PROC_THREAD*/
+
+int xradio_register_bh(struct xradio_common *hw_priv);
+void xradio_unregister_bh(struct xradio_common *hw_priv);
+void xradio_irq_handler(void *priv);
+void xradio_bh_wakeup(struct xradio_common *hw_priv);
+int xradio_bh_suspend(struct xradio_common *hw_priv);
+int xradio_bh_resume(struct xradio_common *hw_priv);
+/* Must be called from BH thread. */
+void xradio_enable_powersave(struct xradio_vif *priv, bool enable);
+int wsm_release_tx_buffer(struct xradio_common *hw_priv, int count);
+int wsm_release_vif_tx_buffer(struct xradio_common *hw_priv, int if_id,
+			      int count);
+int xradio_init_resv_skb(struct xradio_common *hw_priv);
+void xradio_deinit_resv_skb(struct xradio_common *hw_priv);
+int xradio_realloc_resv_skb(struct xradio_common *hw_priv,
+							struct sk_buff *skb, u8 flags);
+
+#ifdef BH_PROC_THREAD
+void xradio_proc_wakeup(struct xradio_common *hw_priv);
+#else
+static inline void xradio_proc_wakeup(struct xradio_common *hw_priv)
+{
+	xradio_bh_wakeup(hw_priv);
+}
+#endif
+
+#endif /* XRADIO_BH_H */
diff -Naurp a/drivers/net/wireless/xr829/wlan/common.h b/drivers/net/wireless/xr829/wlan/common.h
--- a/drivers/net/wireless/xr829/wlan/common.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/common.h	2022-08-27 01:22:42.962539893 +0300
@@ -0,0 +1,171 @@
+/*
+ * Common interfaces for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef XRADIO_COMMON_H
+#define XRADIO_COMMON_H
+
+#include <linux/version.h>
+
+/*******************************************************
+ interfaces for parse frame protocol info.
+********************************************************/
+#define LLC_LEN       8
+#define LLC_TYPE_OFF  6		/*Ether type offset*/
+#define IP_PROTO_OFF  9		/*protocol offset*/
+#define IP_S_ADD_OFF  12
+#define IP_D_ADD_OFF  16
+#define UDP_LEN       8
+/*DHCP*/
+#define DHCP_BOOTP_C  68
+#define DHCP_BOOTP_S  67
+#define UDP_BOOTP_LEN 236	/*exclude "Options:64"*/
+#define BOOTP_OPS_LEN 64
+#define DHCP_MAGIC    0x63825363
+#define DHCP_DISCOVER 0x01
+#define DHCP_OFFER    0x02
+#define DHCP_REQUEST  0x03
+#define DHCP_DECLINE  0x04
+#define DHCP_ACK      0x05
+#define DHCP_NACK     0x06
+#define DHCP_RELEASE  0x07
+/*ARP*/
+#define ARP_REQUEST   0x0001
+#define ARP_RESPONSE   0x0002
+#define ARP_TYPE_OFFSET 6
+
+/*LLC layer.*/
+static inline bool is_SNAP(u8 *llc_data)
+{
+	/* 0xAA, 0xAA, 0x03. */
+	return (bool)(*(u16 *)(llc_data) == 0xAAAA && llc_data[2] == 0x03);
+}
+
+static inline bool is_STP(u8 *llc_data)
+{
+	/* 0x42, 0x42, 0x03.*/
+	return (bool)(*(u16 *)(llc_data) == 0x4242 && llc_data[2] == 0x03);
+}
+
+/*IP/IPV6/ARP layer...*/
+static inline bool is_ip(u8 *llc_data)
+{
+	/* 0x0800 */
+	return (bool)(*(u16 *)(llc_data+LLC_TYPE_OFF) == cpu_to_be16(ETH_P_IP));
+}
+
+static inline bool is_ipv6(u8 *llc_data)
+{
+	/* 0x08dd */
+	return (bool)(*(u16 *)(llc_data+LLC_TYPE_OFF) == cpu_to_be16(ETH_P_IPV6));
+}
+
+static inline bool is_arp(u8 *llc_data)
+{
+	/* 0x0806 */
+	return (bool)(*(u16 *)(llc_data+LLC_TYPE_OFF) == cpu_to_be16(ETH_P_ARP));
+}
+
+static inline bool is_8021x(u8 *llc_data)
+{
+	/* 0x888E */
+	return (bool)(*(u16 *)(llc_data+LLC_TYPE_OFF) == cpu_to_be16(ETH_P_PAE));
+}
+
+/*TCP/UDP layer...*/
+static inline bool is_tcp(u8 *llc_data)
+{
+	return (bool) (llc_data[LLC_LEN + IP_PROTO_OFF] == IPPROTO_TCP);
+}
+
+static inline bool is_udp(u8 *llc_data)
+{
+	return (bool)(llc_data[LLC_LEN+IP_PROTO_OFF] == IPPROTO_UDP);
+}
+
+static inline bool is_icmp(u8 *llc_data)
+{
+	return (bool) (llc_data[LLC_LEN + IP_PROTO_OFF] == IPPROTO_ICMP);
+}
+
+static inline bool is_igmp(u8 *llc_data)
+{
+	return (bool) (llc_data[LLC_LEN + IP_PROTO_OFF] == IPPROTO_IGMP);
+}
+
+static inline bool is_dhcp(u8 *llc_data)
+{
+	u8 *ip_hdr = llc_data + LLC_LEN;
+	if (!is_ip(llc_data))
+		return (bool) 0;
+	if (ip_hdr[IP_PROTO_OFF] == IPPROTO_UDP) {
+		u8 *udp_hdr = ip_hdr + ((ip_hdr[0] & 0xf) << 2);	/*ihl:words*/
+		/* DHCP client or DHCP server*/
+		return (bool)((((udp_hdr[0]<<8)|udp_hdr[1]) == DHCP_BOOTP_C) ||
+			      (((udp_hdr[0]<<8)|udp_hdr[1]) == DHCP_BOOTP_S));
+	}
+	return (bool)0;
+}
+
+static inline struct sk_buff *xr_alloc_skb(unsigned int len)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	gfp_t flags = (in_atomic()) ? GFP_ATOMIC : GFP_KERNEL;
+	return __dev_alloc_skb(len, flags);
+#else
+	return dev_alloc_skb(len);
+#endif
+}
+
+static inline struct sk_buff *xr_alloc_skb_pf(unsigned int len)
+{
+	struct sk_buff *skb = __dev_alloc_skb(len, GFP_ATOMIC);
+	if (!skb)
+		return xr_alloc_skb(len);
+	return skb;
+}
+
+static inline void *xr_kmalloc(unsigned int len, bool isDMA)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	gfp_t flags = (in_atomic()) ? GFP_ATOMIC : GFP_KERNEL;
+#else
+	gfp_t flags = GFP_ATOMIC;
+#endif
+	flags = isDMA ? (flags | GFP_DMA) : flags;
+	return kmalloc(len, flags);
+}
+
+static inline void *xr_kzalloc(unsigned int len, bool isDMA)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	gfp_t flags = (in_atomic()) ? GFP_ATOMIC : GFP_KERNEL;
+#else
+	gfp_t flags = GFP_ATOMIC;
+#endif
+	flags = isDMA ? (flags | GFP_DMA) : flags;
+	return kzalloc(len, flags);
+}
+
+
+static inline void *xr_krealloc(void *buf, unsigned int len, bool isDMA)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	gfp_t flags = (in_atomic()) ? GFP_ATOMIC : GFP_KERNEL;
+#else
+	gfp_t flags = GFP_ATOMIC;
+#endif
+	flags = isDMA ? (flags | GFP_DMA) : flags;
+	return krealloc(buf, len, flags);
+}
+
+#define ROUND4(a)  ((a + 3) & (~0x3))
+
+#endif /*XRADIO_COMMON_H*/
diff -Naurp a/drivers/net/wireless/xr829/wlan/debug.c b/drivers/net/wireless/xr829/wlan/debug.c
--- a/drivers/net/wireless/xr829/wlan/debug.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/debug.c	2022-08-27 01:22:42.966539908 +0300
@@ -0,0 +1,4664 @@
+/*
+ * Debug code for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*Linux version 3.4.0 compilation*/
+/*#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))*/
+#include<linux/module.h>
+/*#endif*/
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/rtc.h>
+#include <linux/time.h>
+
+#include "xradio.h"
+#include "hwio.h"
+#include "bh.h"
+#include "debug.h"
+#ifdef SUPPORT_FW_DBG_INF
+#include "fw_dbg_inf.h"
+#endif
+
+/*for host debuglevel*/
+#define XRADIO_DBG_DEFAULT (XRADIO_DBG_ALWY|XRADIO_DBG_ERROR|XRADIO_DBG_WARN)
+u8 dbg_common  = XRADIO_DBG_DEFAULT;
+u8 dbg_sbus    = XRADIO_DBG_DEFAULT;
+u8 dbg_bh      = XRADIO_DBG_DEFAULT;
+u8 dbg_txrx    = XRADIO_DBG_DEFAULT;
+u8 dbg_wsm     = XRADIO_DBG_DEFAULT;
+u8 dbg_sta     = XRADIO_DBG_DEFAULT;
+u8 dbg_scan    = XRADIO_DBG_DEFAULT;
+u8 dbg_ap      = XRADIO_DBG_DEFAULT;
+u8 dbg_pm      = XRADIO_DBG_DEFAULT;
+u8 dbg_itp     = XRADIO_DBG_DEFAULT;
+u8 dbg_etf     = XRADIO_DBG_DEFAULT;
+u8 dbg_logfile = XRADIO_DBG_ERROR;
+
+#ifdef ERROR_HANG_DRIVER
+u8 error_hang_driver;
+#endif
+
+
+#if (DBG_XRADIO_HIF)
+u16 hif_test_rw; /*0: nothing to do; 1: write only; 2: write and read*/
+u16 hif_test_data_mode; /* hif test data mode, such as 0x55, 0xff etc*/
+u16 hif_test_data_len; /* hif test data len, every data len pre round*/
+u16 hif_test_data_round;
+u16 hif_test_oper_delta; /* hif test operation delta time, give more time to analyze data tranx*/
+#endif
+
+#ifdef CONFIG_XRADIO_DEBUGFS
+/* join_status */
+static const char *const xradio_debug_join_status[] = {
+	"passive",
+	"monitor",
+	"station",
+	"access point",
+};
+
+/* WSM_JOIN_PREAMBLE_... */
+static const char *const xradio_debug_preamble[] = {
+	"long",
+	"short",
+	"long on 1 and 2 Mbps",
+};
+
+static const char *const xradio_debug_fw_types[] = {
+	"ETF",
+	"WFM",
+	"WSM",
+	"HI test",
+	"Platform test",
+};
+
+static const char *const xradio_debug_link_id[] = {
+	"OFF",
+	"REQ",
+	"SOFT",
+	"HARD",
+};
+
+static const char *xradio_debug_mode(int mode)
+{
+	switch (mode) {
+	case NL80211_IFTYPE_UNSPECIFIED:
+		return "unspecified";
+	case NL80211_IFTYPE_MONITOR:
+		return "monitor";
+	case NL80211_IFTYPE_STATION:
+		return "station";
+	case NL80211_IFTYPE_ADHOC:
+		return "ad-hok";
+	case NL80211_IFTYPE_MESH_POINT:
+		return "mesh point";
+	case NL80211_IFTYPE_AP:
+		return "access point";
+	case NL80211_IFTYPE_P2P_CLIENT:
+		return "p2p client";
+	case NL80211_IFTYPE_P2P_GO:
+		return "p2p go";
+	default:
+		return "unsupported";
+	}
+}
+
+static void xradio_queue_status_show(struct seq_file *seq,
+				     struct xradio_queue *q)
+{
+	int i, if_id;
+	seq_printf(seq, "Queue       %d:\n", q->queue_id);
+	seq_printf(seq, "  capacity: %zu\n", q->capacity);
+	seq_printf(seq, "  queued:   %zu\n", q->num_queued);
+	seq_printf(seq, "  pending:  %zu\n", q->num_pending);
+	seq_printf(seq, "  sent:     %zu\n", q->num_sent);
+	seq_printf(seq, "  locked:   %s\n", q->tx_locked_cnt ? "yes" : "no");
+	seq_printf(seq, "  overfull: %s\n", q->overfull ? "yes" : "no");
+	seq_puts(seq, "  link map: 0-> ");
+	for (if_id = 0; if_id < XRWL_MAX_VIFS; if_id++) {
+		for (i = 0; i < q->stats->map_capacity; ++i)
+			seq_printf(seq, "%.2d ", q->link_map_cache[if_id][i]);
+		seq_printf(seq, "<-%zu\n", q->stats->map_capacity);
+	}
+}
+
+static void xradio_debug_print_map(struct seq_file *seq,
+				   struct xradio_vif *priv,
+				   const char *label, u32 map)
+{
+	int i;
+	seq_printf(seq, "%s0-> ", label);
+	for (i = 0; i < priv->hw_priv->tx_queue_stats.map_capacity; ++i)
+		seq_printf(seq, "%s ", (map & BIT(i)) ? "**" : "..");
+	seq_printf(seq, "<-%zu\n",
+		   priv->hw_priv->tx_queue_stats.map_capacity - 1);
+}
+
+static int xradio_version_show(struct seq_file *seq, void *v)
+{
+	struct xradio_common *hw_priv = seq->private;
+	seq_printf(seq, "Driver Label:%s  %s\n", DRV_VERSION, DRV_BUILDTIME);
+	seq_printf(seq, "Firmware Label:%s\n", &hw_priv->wsm_caps.fw_label[0]);
+	return 0;
+}
+
+static int xradio_version_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, &xradio_version_show, inode->i_private);
+}
+
+static const struct file_operations fops_version = {
+	.open = xradio_version_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.owner = THIS_MODULE,
+};
+
+#if (DGB_XRADIO_QC)
+static int xradio_hwinfo_show(struct seq_file *seq, void *v)
+{
+	struct xradio_common *hw_priv = seq->private;
+	u32 hw_arry[8] = { 0 };
+
+	wsm_read_mib(hw_priv, WSM_MIB_ID_HW_INFO, (void *)&hw_arry,
+		     sizeof(hw_arry), 4);
+
+	/*
+	get_random_bytes((u8 *)&hw_arry[0], 8*sizeof(u32));
+	hw_arry[0] = 0x0B140D4;
+	hw_arry[1] &= ~0xF803FFFF;
+	hw_arry[2] &= ~0xC0001FFF;
+	hw_arry[5] &= ~0xFFFFF000;
+	hw_arry[7] &= ~0xFFFC07C0;
+	*/
+
+	seq_printf(seq, "0x%08x, 0x%08x, 0x%08x, 0x%08x, "
+			"0x%08x, 0x%08x, 0x%08x, 0x%08x\n",
+			hw_arry[0], hw_arry[1], hw_arry[2], hw_arry[3],
+			hw_arry[4], hw_arry[5], hw_arry[6], hw_arry[7]);
+	return 0;
+}
+
+static int xradio_hwinfo_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, &xradio_hwinfo_show, inode->i_private);
+}
+
+static const struct file_operations fops_hwinfo = {
+	.open = xradio_hwinfo_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.owner = THIS_MODULE,
+};
+
+
+static int xradio_temperature_show(struct seq_file *seq, void *v)
+{
+	struct xradio_common *hw_priv = seq->private;
+	s32 s32tempQ4;
+
+	wsm_read_mib(hw_priv, WSM_MIB_ID_GET_TEMPERATURE, (void *)&s32tempQ4,
+		     sizeof(s32tempQ4), 4);
+	seq_printf(seq, "%d\n", (s32tempQ4 >> 4));
+	return 0;
+}
+
+static int xradio_temperature_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, &xradio_temperature_show, inode->i_private);
+}
+
+static const struct file_operations fops_temperature = {
+	.open = xradio_temperature_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.owner = THIS_MODULE,
+};
+#endif
+
+static int xradio_status_show_common(struct seq_file *seq, void *v)
+{
+	int i;
+	struct list_head *item;
+	struct xradio_common *hw_priv = seq->private;
+	struct xradio_debug_common *d = hw_priv->debug;
+	int ba_cnt, ba_acc, ba_cnt_rx, ba_acc_rx, ba_avg = 0, ba_avg_rx = 0;
+	bool ba_ena;
+
+	spin_lock_bh(&hw_priv->ba_lock);
+	ba_cnt = hw_priv->debug->ba_cnt;
+	ba_acc = hw_priv->debug->ba_acc;
+	ba_cnt_rx = hw_priv->debug->ba_cnt_rx;
+	ba_acc_rx = hw_priv->debug->ba_acc_rx;
+	ba_ena = hw_priv->ba_ena;
+	if (ba_cnt)
+		ba_avg = ba_acc / ba_cnt;
+	if (ba_cnt_rx)
+		ba_avg_rx = ba_acc_rx / ba_cnt_rx;
+	spin_unlock_bh(&hw_priv->ba_lock);
+
+	seq_puts(seq,   "XRADIO Wireless LAN driver status\n");
+	seq_printf(seq, "Hardware:   %d.%d\n",
+		hw_priv->wsm_caps.hardwareId,
+		hw_priv->wsm_caps.hardwareSubId);
+	seq_printf(seq, "Firmware:   %s %d.%d\n",
+		xradio_debug_fw_types[hw_priv->wsm_caps.firmwareType],
+		hw_priv->wsm_caps.firmwareVersion,
+		hw_priv->wsm_caps.firmwareBuildNumber);
+	seq_printf(seq, "FW API:     %d\n",
+		hw_priv->wsm_caps.firmwareApiVer);
+	seq_printf(seq, "FW caps:    0x%.4X\n",
+		hw_priv->wsm_caps.firmwareCap);
+	if (hw_priv->channel) {
+		seq_printf(seq, "Channel:    %d%s\n",
+			hw_priv->channel->hw_value,
+			hw_priv->channel_switch_in_progress ?
+			" (switching)" : "");
+
+		seq_printf(seq, "  flags:    0x%08x\n",
+			hw_priv->channel->flags);
+	}
+	seq_printf(seq, "HT:         %s\n",
+		xradio_is_ht(&hw_priv->ht_info) ? "on" : "off");
+	if (xradio_is_ht(&hw_priv->ht_info)) {
+
+#ifdef SUPPORT_HT40
+
+		seq_printf(seq, "2040BSS:    %s\n",
+			xradio_is_2040BSS(&hw_priv->ht_info) ? "yes" : "no");
+
+		if (xradio_is_2040BSS(&hw_priv->ht_info)) {
+			switch (hw_priv->ht_info.channel_type) {
+			case NL80211_CHAN_HT40MINUS:
+				seq_printf(seq, "Second Chan:Below\n");
+				break;
+			case NL80211_CHAN_HT40PLUS:
+				seq_printf(seq, "Second Chan:Above\n");
+				break;
+			default:
+				break;
+			}
+		}
+
+		seq_printf(seq, "ShortGI:    %s\n",
+			xradio_ht_ShortGI(&hw_priv->ht_info) ? "yes" : "no");
+
+#endif
+
+		seq_printf(seq, "Greenfield: %s\n",
+			xradio_ht_greenfield(&hw_priv->ht_info) ? "yes" : "no");
+		seq_printf(seq, "AMPDU dens: %d\n",
+			xradio_ht_ampdu_density(&hw_priv->ht_info));
+	}
+	spin_lock_bh(&hw_priv->tx_policy_cache.lock);
+	i = 0;
+	list_for_each(item, &hw_priv->tx_policy_cache.used)
+		++i;
+	spin_unlock_bh(&hw_priv->tx_policy_cache.lock);
+	seq_printf(seq, "RC in use:  %d\n", i);
+	seq_printf(seq, "BA stat:    %d, %d (%d)\n",
+		ba_cnt, ba_acc, ba_avg);
+	seq_printf(seq, "BA RX stat:    %d, %d (%d)\n",
+		ba_cnt_rx, ba_acc_rx, ba_avg_rx);
+	seq_printf(seq, "Block ACK:  %s\n", ba_ena ? "on" : "off");
+
+	seq_puts(seq, "\n");
+	for (i = 0; i < 4; ++i) {
+		xradio_queue_status_show(seq, &hw_priv->tx_queue[i]);
+		seq_puts(seq, "\n");
+	}
+	seq_printf(seq, "TX burst:   %d\n",
+		d->tx_burst);
+	seq_printf(seq, "RX burst:   %d\n",
+		d->rx_burst);
+	seq_printf(seq, "TX miss:    %d\n",
+		d->tx_cache_miss);
+	seq_printf(seq, "Long retr:  %d\n",
+		hw_priv->long_frame_max_tx_count);
+	seq_printf(seq, "Short retr: %d\n",
+		hw_priv->short_frame_max_tx_count);
+
+	seq_printf(seq, "BH status: %s, errcode=%d\n",
+		   atomic_read(&hw_priv->bh_term) ? "terminated" : "alive",
+		   hw_priv->bh_error);
+	seq_printf(seq, "Pending RX: %d\n",
+		atomic_read(&hw_priv->bh_rx));
+	seq_printf(seq, "Pending TX: %d\n",
+		atomic_read(&hw_priv->bh_tx));
+
+	seq_printf(seq, "TX bufs:    %d x %d bytes\n",
+		hw_priv->wsm_caps.numInpChBufs,
+		hw_priv->wsm_caps.sizeInpChBuf);
+	seq_printf(seq, "Used bufs:  %d\n",
+		hw_priv->hw_bufs_used);
+#ifdef BH_PROC_THREAD
+	seq_printf(seq, "tx_queued:  %d\n",
+		atomic_read(&hw_priv->proc.tx_queued));
+	seq_printf(seq, "rx_queued:  %d\n",
+		atomic_read(&hw_priv->proc.rx_queued));
+#endif
+	seq_printf(seq, "Powersavemode:%s\n",
+		hw_priv->powersave_enabled ? "enable" : "disable");
+	seq_printf(seq, "Device:     %s\n",
+		hw_priv->device_can_sleep ? "alseep" : "awake");
+
+	spin_lock(&hw_priv->wsm_cmd.lock);
+	seq_printf(seq, "WSM status: %s\n",
+		hw_priv->wsm_cmd.done ? "idle" : "active");
+	seq_printf(seq, "WSM cmd:    0x%.4X (%zu bytes)\n",
+		hw_priv->wsm_cmd.cmd, hw_priv->wsm_cmd.len);
+	seq_printf(seq, "WSM retval: %d\n",
+		hw_priv->wsm_cmd.ret);
+	spin_unlock(&hw_priv->wsm_cmd.lock);
+
+	seq_printf(seq, "Datapath:   %s\n",
+		atomic_read(&hw_priv->tx_lock) ? "locked" : "unlocked");
+	if (atomic_read(&hw_priv->tx_lock))
+		seq_printf(seq, "TXlock cnt: %d\n",
+			atomic_read(&hw_priv->tx_lock));
+
+	seq_printf(seq, "Scan:       %s\n",
+		atomic_read(&hw_priv->scan.in_progress) ? "active" : "idle");
+	seq_printf(seq, "Led state:  0x%.2X\n",
+		hw_priv->softled_state);
+
+	return 0;
+}
+
+static int xradio_status_open_common(struct inode *inode, struct file *file)
+{
+	return single_open(file, &xradio_status_show_common,
+		inode->i_private);
+}
+
+static const struct file_operations fops_status_common = {
+	.open = xradio_status_open_common,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.owner = THIS_MODULE,
+};
+
+static int xradio_counters_show(struct seq_file *seq, void *v)
+{
+	int ret;
+	struct xradio_common *hw_priv = seq->private;
+	struct wsm_counters_table counters;
+
+	ret = wsm_get_counters_table(hw_priv, &counters);
+	if (ret)
+		return ret;
+
+#define CAT_STR(x, y) x ## y
+#define PUT_COUNTER(tab, name) \
+	seq_printf(seq, "%s:" tab "%d\n", #name, \
+		__le32_to_cpu(counters.CAT_STR(count, name)))
+
+	PUT_COUNTER("\t\t\t\t", PlcpErrors);
+	PUT_COUNTER("\t\t\t\t", FcsErrors);
+	PUT_COUNTER("\t\t\t\t", TxPackets);
+	PUT_COUNTER("\t\t\t\t", RxPackets);
+	PUT_COUNTER("\t\t\t",   RxPacketErrors);
+	PUT_COUNTER("\t\t\t\t", RtsSuccess);
+	PUT_COUNTER("\t\t\t", RtsFailures);
+	PUT_COUNTER("\t\t",   RxFramesSuccess);
+	PUT_COUNTER("\t",     RxDecryptionFailures);
+	PUT_COUNTER("\t\t\t", RxMicFailures);
+	PUT_COUNTER("\t\t",   RxNoKeyFailures);
+	PUT_COUNTER("\t\t",   TxMulticastFrames);
+	PUT_COUNTER("\t\t",   TxFramesSuccess);
+	PUT_COUNTER("\t\t",   TxFrameFailures);
+	PUT_COUNTER("\t\t",   TxFramesRetried);
+	PUT_COUNTER("\t",     TxFramesMultiRetried);
+	PUT_COUNTER("\t\t",   RxFrameDuplicates);
+	PUT_COUNTER("\t\t\t", AckFailures);
+	PUT_COUNTER("\t\t",   RxMulticastFrames);
+	PUT_COUNTER("\t\t",   RxCMACICVErrors);
+	PUT_COUNTER("\t\t\t", RxCMACReplays);
+	PUT_COUNTER("\t\t",   RxMgmtCCMPReplays);
+	PUT_COUNTER("\t\t\t", RxBIPMICErrors);
+
+	PUT_COUNTER("\t\t\t", AllBeacons);
+	PUT_COUNTER("\t\t\t", ScanBeacons);
+	PUT_COUNTER("\t\t\t", ScanProbeRsps);
+	PUT_COUNTER("\t\t\t", OutChanBeacons);
+	PUT_COUNTER("\t\t",   OutChanProbeRsps);
+	PUT_COUNTER("\t\t\t", BssBeacons);
+	PUT_COUNTER("\t\t\t", HostBeacons);
+	PUT_COUNTER("\t\t\t", MissBeacons);
+	PUT_COUNTER("\t\t\t", DTIMBeacons);
+
+
+#undef PUT_COUNTER
+#undef CAT_STR
+
+	return 0;
+}
+
+static int xradio_counters_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, &xradio_counters_show,
+		inode->i_private);
+}
+
+static const struct file_operations fops_counters = {
+	.open = xradio_counters_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.owner = THIS_MODULE,
+};
+
+static int xradio_backoff_show(struct seq_file *seq, void *v)
+{
+	int ret;
+	struct xradio_common *hw_priv = seq->private;
+	struct wsm_backoff_counter counters;
+
+	ret = wsm_get_backoff_dbg(hw_priv, &counters);
+	if (ret)
+		return ret;
+
+#define CAT_STR(x, y) x ## y
+#define PUT_COUNTER(tab, name) \
+	seq_printf(seq, tab"%s:\t%d\n", #name, \
+		(__le32_to_cpu(counters.CAT_STR(count, name))&0xffff))
+
+	PUT_COUNTER("backoff_max ", 0);
+	PUT_COUNTER("[0, 7]       ", 1);
+	PUT_COUNTER("[~, 15]      ", 2);
+	PUT_COUNTER("[~, 31]      ", 3);
+	PUT_COUNTER("[~, 63]      ", 4);
+	PUT_COUNTER("[~, 127]     ", 5);
+	PUT_COUNTER("[~, 255]     ", 6);
+	PUT_COUNTER("[~, 511]     ", 7);
+	PUT_COUNTER("[~, 1023]    ", 8);
+
+
+#undef PUT_COUNTER
+#undef CAT_STR
+
+	return 0;
+}
+
+static int xradio_backoff_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, &xradio_backoff_show,
+		inode->i_private);
+}
+
+static const struct file_operations fops_backoff = {
+	.open = xradio_backoff_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.owner = THIS_MODULE,
+};
+
+#ifdef SUPPORT_HT40
+
+static int xradio_ratemap_show(struct seq_file *seq, void *v)
+{
+	/* int ret; */
+	/* struct xradio_common *hw_priv = seq->private; */
+
+#define PUT_TXRATE_COUNT(idx, bdsss, aofdm) do { \
+	seq_printf(seq, "MCS%d:"  "[%8d][%8d] [%8d][%8d] %4s:" \
+		"[%8d] %3s:[%8d]\n", idx, \
+		__le32_to_cpu(TxedHtofdmRateMap[0][idx]), \
+		__le32_to_cpu(TxedHtofdmRateMap[1][idx]), \
+		__le32_to_cpu(TxedHtofdmRateMap[2][idx]), \
+		__le32_to_cpu(TxedHtofdmRateMap[3][idx]), \
+		#bdsss, __le32_to_cpu(TxedLegacyRateMap[0][idx]), \
+		#aofdm, __le32_to_cpu(TxedLegacyRateMap[1][idx]));\
+		TxedHtofdmRateMap[0][idx] = 0;\
+		TxedHtofdmRateMap[1][idx] = 0;\
+		TxedHtofdmRateMap[2][idx] = 0;\
+		TxedHtofdmRateMap[3][idx] = 0;\
+		TxedLegacyRateMap[0][idx] = 0;\
+		TxedLegacyRateMap[1][idx] = 0;\
+} while (0)
+
+	seq_printf(seq, "\nTxRateMap:\n");
+	seq_printf(seq, "     " "[20SGI TX][20LGI TX] " \
+				"[40SGI TX][40LGI TX] " \
+				"     [DSSS  TX] " \
+				"    [OFDM  TX]\n");
+
+	PUT_TXRATE_COUNT(7, 11MS, 54M);
+	PUT_TXRATE_COUNT(6, 11ML, 48M);
+	PUT_TXRATE_COUNT(5, 5M5S, 36M);
+	PUT_TXRATE_COUNT(4, 5M5L, 24M);
+	PUT_TXRATE_COUNT(3,  2MS, 18M);
+	PUT_TXRATE_COUNT(2,  2ML, 12M);
+	PUT_TXRATE_COUNT(1, ----,  9M);
+	PUT_TXRATE_COUNT(0,  1ML,  6M);
+
+#undef PUT_TXRATE_COUNT
+
+#define PUT_RXRATE_COUNT(idx, bdsss, aofdm) do { \
+	seq_printf(seq, "MCS%d:"  "[%8d][%8d] [%8d][%8d] %4s:" \
+		"[%8d] %3s:[%8d]\n", idx, \
+		__le32_to_cpu(RxedHtofdmRateMap[0][idx]), \
+		__le32_to_cpu(RxedHtofdmRateMap[1][idx]), \
+		__le32_to_cpu(RxedHtofdmRateMap[2][idx]), \
+		__le32_to_cpu(RxedHtofdmRateMap[3][idx]), \
+		#bdsss, __le32_to_cpu(RxedLegacyRateMap[0][idx]), \
+		#aofdm, __le32_to_cpu(RxedLegacyRateMap[1][idx]));\
+		RxedHtofdmRateMap[0][idx] = 0;\
+		RxedHtofdmRateMap[1][idx] = 0;\
+		RxedHtofdmRateMap[2][idx] = 0;\
+		RxedHtofdmRateMap[3][idx] = 0;\
+		RxedLegacyRateMap[0][idx] = 0;\
+		RxedLegacyRateMap[1][idx] = 0;\
+} while (0)
+
+	seq_printf(seq, "\nRxRateMap:\n");
+	seq_printf(seq, "     " "[20SGI RX][20LGI RX] " \
+				"[40SGI RX][40LGI RX] " \
+				"     [DSSS  RX] " \
+				"    [OFDM  RX]\n");
+
+	PUT_RXRATE_COUNT(7, 11MS, 54M);
+	PUT_RXRATE_COUNT(6, 11ML, 48M);
+	PUT_RXRATE_COUNT(5, 5M5S, 36M);
+	PUT_RXRATE_COUNT(4, 5M5L, 24M);
+	PUT_RXRATE_COUNT(3,  2MS, 18M);
+	PUT_RXRATE_COUNT(2,  2ML, 12M);
+	PUT_RXRATE_COUNT(1, ----,  9M);
+	PUT_RXRATE_COUNT(0,  1ML,  6M);
+
+#undef PUT_RXRATE_COUNT
+
+	return 0;
+}
+
+#else
+
+static int xradio_ratemap_show(struct seq_file *seq, void *v)
+{
+	/* int ret; */
+	/* struct xradio_common *hw_priv = seq->private; */
+
+	seq_printf(seq, "\nRateMap for Tx & RX:\n");
+#define PUT_RATE_COUNT(name, idx) do { \
+	seq_printf(seq, "%s\t"  "%d,  %d\n", #name, \
+		__le32_to_cpu(TxedRateIdx_Map[idx]), \
+		__le32_to_cpu(RxedRateIdx_Map[idx])); \
+	TxedRateIdx_Map[idx] = 0; \
+	RxedRateIdx_Map[idx] = 0; \
+} while (0)
+
+	PUT_RATE_COUNT("65   Mbps:", 21);
+	PUT_RATE_COUNT("58.5 Mbps:", 20);
+	PUT_RATE_COUNT("52   Mbps:", 19);
+	PUT_RATE_COUNT("39   Mbps:", 18);
+	PUT_RATE_COUNT("26   Mbps:", 17);
+	PUT_RATE_COUNT("19.5 Mbps:", 16);
+	PUT_RATE_COUNT("13   Mbps:", 15);
+	PUT_RATE_COUNT("6.5  Mbps:", 14);
+
+	PUT_RATE_COUNT("54   Mbps:", 13);
+	PUT_RATE_COUNT("48   Mbps:", 12);
+	PUT_RATE_COUNT("36   Mbps:", 11);
+	PUT_RATE_COUNT("24   Mbps:", 10);
+	PUT_RATE_COUNT("18   Mbps:",  9);
+	PUT_RATE_COUNT("12   Mbps:",  8);
+	PUT_RATE_COUNT("9    Mbps:", 7);
+	PUT_RATE_COUNT("6    Mbps:",  6);
+
+	PUT_RATE_COUNT("11   Mbps:", 3);
+	PUT_RATE_COUNT("5.5  Mbps:", 2);
+	PUT_RATE_COUNT("2    Mbps:", 1);
+	PUT_RATE_COUNT("1    Mbps:", 0);
+
+#undef PUT_RATE_COUNT
+
+	return 0;
+}
+
+#endif
+
+static int xradio_ratemap_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, &xradio_ratemap_show,
+		inode->i_private);
+}
+
+static const struct file_operations fops_ratemap = {
+	.open = xradio_ratemap_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.owner = THIS_MODULE,
+};
+
+static int xradio_ampducounters_show(struct seq_file *seq, void *v)
+{
+	int ret;
+	struct xradio_common *hw_priv = seq->private;
+	struct wsm_ampducounters_table counters;
+
+	ret = wsm_get_ampducounters_table(hw_priv, &counters);
+	if (ret)
+		return ret;
+
+#define CAT_STR(x, y) x ## y
+#define PUT_COUNTER(tab, name) \
+	seq_printf(seq, "%s:" tab "%d\n", #name, \
+		__le32_to_cpu(counters.CAT_STR(count, name)))
+
+	PUT_COUNTER("\t\t\t",	TxAMPDUs);
+	PUT_COUNTER("\t\t",	TxMPDUsInAMPDUs);
+	PUT_COUNTER("\t\t",	TxOctetsInAMPDUs_l32);
+	PUT_COUNTER("\t\t",	TxOctetsInAMPDUs_h32);
+	PUT_COUNTER("\t\t\t",	RxAMPDUs);
+	PUT_COUNTER("\t\t",	RxMPDUsInAMPDUs);
+	PUT_COUNTER("\t\t",	RxOctetsInAMPDUs_l32);
+	PUT_COUNTER("\t\t",	RxOctetsInAMPDUs_h32);
+	PUT_COUNTER("\t",	RxDelimeterCRCErrorCount);
+	PUT_COUNTER("\t\t",	ImplictBARFailures);
+	PUT_COUNTER("\t\t",	ExplictBARFailures);
+
+
+
+#undef PUT_COUNTER
+#undef CAT_STR
+
+	return 0;
+}
+
+static int xradio_ampducounters_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, &xradio_ampducounters_show,
+		inode->i_private);
+}
+
+static const struct file_operations fops_ampducounters = {
+	.open = xradio_ampducounters_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.owner = THIS_MODULE,
+};
+
+static int xradio_txpipe_show(struct seq_file *seq, void *v)
+{
+	int ret;
+	struct xradio_common *hw_priv = seq->private;
+	struct wsm_txpipe_counter counters;
+
+	ret = wsm_get_txpipe_table(hw_priv, &counters);
+	if (ret)
+		return ret;
+
+#define CAT_STR(x, y) x ## y
+#define PUT_COUNTER(tab, name) \
+	seq_printf(seq, tab":\t%d\n", \
+		__le32_to_cpu(counters.CAT_STR(count, name)))
+
+	PUT_COUNTER("tx-aggr       ", 1);
+	PUT_COUNTER("retx-aggr     ", 2);
+	PUT_COUNTER("retry_type1   ", 3);
+	PUT_COUNTER("retry_type2   ", 4);
+	PUT_COUNTER("retry_type3   ", 5);
+	PUT_COUNTER("rx-aggr-event ", 6);
+	PUT_COUNTER("rx-aggr-end   ", 7);
+	PUT_COUNTER("rx-ba         ", 8);
+	PUT_COUNTER("tx_ampdu_len  ", 9);
+	PUT_COUNTER("fail_by_rts   ", a);
+
+
+#undef PUT_COUNTER
+#undef CAT_STR
+
+	return 0;
+}
+
+static int xradio_txpipe_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, &xradio_txpipe_show,
+		inode->i_private);
+}
+
+static const struct file_operations fops_txpipe = {
+	.open = xradio_txpipe_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.owner = THIS_MODULE,
+};
+
+#if (SUPPORT_EPTA)
+
+u32 epta_stat_dbg_ctrl = 0x484;
+char *med_state_str[4] = {
+	"bt inactive",
+	"with bt and wlan not waiting",
+	"with wlan",
+	"with bt and wlan waiting"
+};
+char *req_type_str[11] = {
+	"rx_recovery", "rx_mcast", "rx_bcn", "tx_bcn", "tx_cts", "tx_high", "tx_uapsd", "fastps",
+	"scan", "pspoll", "tx_low"
+};
+
+static int xradio_epta_stat_show(struct seq_file *seq, void *v)
+{
+	int ret, i;
+	struct xradio_epta_stat epta_stat;
+	struct xradio_common *hw_priv = seq->private;
+
+//	memset(&epta_stat, 0, sizeof(epta_stat));
+	ret = wsm_get_epta_statistics(hw_priv, &epta_stat);
+#if 0
+	seq_printf(seq, "\n================\n");
+	for (i = 0; i < sizeof(epta_stat); i++) {
+		if (i % 4 == 0)
+			seq_printf(seq, "%d:\t ", i);
+		seq_printf(seq, "%2x ", *((u8 *)&epta_stat+i));
+		if ((i+1) % 4 == 0)
+			seq_printf(seq, "\n");
+	}
+	seq_printf(seq, "\n================\n");
+#endif
+	if (ret)
+		return ret;
+
+	seq_printf(seq, "\n[epta statistics]\n");
+	seq_printf(seq, "medium state: %s\n", med_state_str[epta_stat.medium_state]);
+	if (epta_stat.medium_state == 0)
+		return 0;
+	if (epta_stat.wlan_req_ongoing) {
+		//req got into epta from lmc_epta but not granted or aborted yet
+	}
+	if (epta_stat.medium_state == 2) {
+		seq_printf(seq, "current req :[type:%s][prio_sw:%u][prio_hw:%u][req dur:%u]\n", req_type_str[epta_stat.wlan_req_type],
+				epta_stat.wlan_req_priority & 0xf, (epta_stat.wlan_req_priority >> 4) & 0xf,  __le32_to_cpu(epta_stat.wlan_req_request_dur));
+	//	seq_printf(seq, "current req granted time: \t %u\n", __le32_to_cpu(epta_stat.grant_or_wait_time));
+	} else if (epta_stat.medium_state == 3) {
+		seq_printf(seq, "current req :[type:%s][prio_sw:%u][prio_hw:%u][req dur:%u]\n", req_type_str[epta_stat.wlan_req_type],
+				epta_stat.wlan_req_priority & 0xf, (epta_stat.wlan_req_priority >> 4) & 0xf, __le32_to_cpu(epta_stat.wlan_req_request_dur));
+	//	seq_printf(seq, "wlan is waiting for bt: \t\t %u\n", __le32_to_cpu(epta_stat.grant_or_wait_time));
+	} else {
+		seq_printf(seq, "current req :\n");
+	}
+
+	seq_printf(seq, "=========================wlan req info========================\n");
+
+	seq_printf(seq, "                   %10s ", "all");
+	for (i = 0; i < 11; i++)
+		if (epta_stat_dbg_ctrl & (1<<i))
+			seq_printf(seq, "%10s ", req_type_str[i]);
+	seq_printf(seq, "\n");
+	seq_printf(seq, "req win cnt:       %10u %10u %10u %10u\n", __le32_to_cpu(epta_stat.wl_req_info[0].cnt_win), __le32_to_cpu(epta_stat.wl_req_info[1].cnt_win),
+			__le32_to_cpu(epta_stat.wl_req_info[2].cnt_win), __le32_to_cpu(epta_stat.wl_req_info[3].cnt_win));
+	seq_printf(seq, "req lose cnt:      %10u %10u %10u %10u\n", __le32_to_cpu(epta_stat.wl_req_info[0].cnt_lose), __le32_to_cpu(epta_stat.wl_req_info[1].cnt_lose),
+			__le32_to_cpu(epta_stat.wl_req_info[2].cnt_lose), __le32_to_cpu(epta_stat.wl_req_info[3].cnt_lose));
+
+	seq_printf(seq, "grant med ret cnt: %10u %10u %10u %10u\n", __le16_to_cpu(epta_stat.wl_req_info[0].cnt_grant_med_ret), __le16_to_cpu(epta_stat.wl_req_info[1].cnt_grant_med_ret),
+			__le16_to_cpu(epta_stat.wl_req_info[2].cnt_grant_med_ret), __le16_to_cpu(epta_stat.wl_req_info[3].cnt_grant_med_ret));
+	seq_printf(seq, "grant timeout cnt: %10u %10u %10u %10u\n", __le16_to_cpu(epta_stat.wl_req_info[0].cnt_grant_timeout), __le16_to_cpu(epta_stat.wl_req_info[1].cnt_grant_timeout),
+			__le16_to_cpu(epta_stat.wl_req_info[2].cnt_grant_timeout), __le16_to_cpu(epta_stat.wl_req_info[3].cnt_grant_timeout));
+	seq_printf(seq, "abort misss rx cnt:%10u %10u %10u %10u\n", __le16_to_cpu(epta_stat.wl_req_info[0].cnt_abort_miss_rx), __le16_to_cpu(epta_stat.wl_req_info[1].cnt_abort_miss_rx),
+			__le16_to_cpu(epta_stat.wl_req_info[2].cnt_abort_miss_rx), __le16_to_cpu(epta_stat.wl_req_info[3].cnt_abort_miss_rx));
+	seq_printf(seq, "abort expired cnt: %10u %10u %10u %10u\n", __le16_to_cpu(epta_stat.wl_req_info[0].cnt_abort_expired), __le16_to_cpu(epta_stat.wl_req_info[1].cnt_abort_expired),
+			__le16_to_cpu(epta_stat.wl_req_info[2].cnt_abort_expired), __le16_to_cpu(epta_stat.wl_req_info[3].cnt_abort_expired));
+
+	seq_printf(seq, "granted time:      %10u %10u %10u %10u\n", __le32_to_cpu(epta_stat.wl_req_info[0].granted_time), __le32_to_cpu(epta_stat.wl_req_info[1].granted_time),
+			__le32_to_cpu(epta_stat.wl_req_info[2].granted_time), __le32_to_cpu(epta_stat.wl_req_info[3].granted_time));
+	seq_printf(seq, "granted used time: %10u %10u %10u %10u\n", __le32_to_cpu(epta_stat.wl_req_info[0].gr_used_time), __le32_to_cpu(epta_stat.wl_req_info[1].gr_used_time),
+			__le32_to_cpu(epta_stat.wl_req_info[2].gr_used_time), __le32_to_cpu(epta_stat.wl_req_info[3].gr_used_time));
+
+	seq_printf(seq, "\n");
+	seq_printf(seq, "%25s %17s %18s\n", "[req ext cnt] grant_uapsd", "abort_rx_bcn", "abort_pspoll");
+	seq_printf(seq, "%25u %17u %18u\n", __le16_to_cpu(epta_stat.cnt_ex_grant_uapsd),
+			__le16_to_cpu(epta_stat.cnt_ex_abort_rx_bcn), __le16_to_cpu(epta_stat.cnt_ex_abort_pspoll));
+
+	seq_printf(seq, "%25s %17s %18s\n", "[bt abort cnt]      total", "abort_tx", "abort_tx_fix");
+	seq_printf(seq, "%25u %17u %18u\n", __le16_to_cpu(epta_stat.cnt_bt_abort),
+			__le16_to_cpu(epta_stat.cnt_bt_abort_tx), __le16_to_cpu(epta_stat.cnt_bt_abort_tx_fix));
+
+	seq_printf(seq, "========================bt tx req type========================\n");
+	seq_printf(seq, "%4s %13s %13s %14s %14s\n", "poll", "dm1", "br", "edr", "sco");
+	seq_printf(seq, "%4u %13u %13u %14u %14u\n", __le16_to_cpu(epta_stat.cnt_bt_tx_poll_pkt_req),
+			__le16_to_cpu(epta_stat.cnt_bt_tx_dm1_pkt_req), __le16_to_cpu(epta_stat.cnt_bt_tx_br_pkt_req),
+			__le16_to_cpu(epta_stat.cnt_bt_tx_edr_pkt_req), __le16_to_cpu(epta_stat.cnt_bt_tx_sco_pkt_req));
+
+	seq_printf(seq, "=======================wlan/bt nrt info=======================\n");
+	seq_printf(seq, "%13s %14s %7s %10s %14s\n", "wl_quota_used", " bt_quota_used", "bt_req", "gr_bt_req", "gr_bt_max_gap");
+	seq_printf(seq, "%13u %14u %7u %10u %14u\n", __le32_to_cpu(epta_stat.nrt_wlan_quota_used), __le32_to_cpu(epta_stat.nrt_bt_quota_used),
+			__le32_to_cpu(epta_stat.nrt_bt_requests), __le32_to_cpu(epta_stat.nrt_bt_granted_requestd), __le32_to_cpu(epta_stat.nrt_bt_granted_req_max_gap));
+	seq_printf(seq, "\n");
+
+	for (i = 0; i < epta_stat.num_active_rt_bt_links; i++) {
+		struct xradio_epta_bt_link_info *bt_link_info = &epta_stat.bt_link_info[i];
+		seq_printf(seq, "=======================rt bt link idx %u=======================\n", i);
+		seq_printf(seq, "%6s: %-3u %12s: %-2u %13s: %-3u %9s: %-1u\n", "linkid", bt_link_info->link_id, "type  ", bt_link_info->traffic_type,
+				"master", bt_link_info->master_or_slave, "prio_sw    ", bt_link_info->traffic_priority);
+		seq_printf(seq, "%6s: %7u %8s: %7u %8s: %-3u %9s: %-1u\n", "rt_si ", __le32_to_cpu(bt_link_info->rt_si), "rt_sw ", __le32_to_cpu(bt_link_info->rt_sw),
+				"req   ", __le32_to_cpu(bt_link_info->requests), "prio_hw_rt ", ((__le32_to_cpu(bt_link_info->time_diff_req_start)) >> 4) & 0xf);
+		seq_printf(seq, "%6s: %7u %8s: %7u %8s: %-3u %9s: %-1u\n", "msg_si", __le32_to_cpu(bt_link_info->msg_si), "msg_sw", __le32_to_cpu(bt_link_info->msg_sw),
+				"gr_req", __le32_to_cpu(bt_link_info->granted_requests), "prio_hw_nrt",  (__le32_to_cpu(bt_link_info->time_diff_req_start)) & 0xf);
+
+		seq_printf(seq, "%6s: %-3u %14s: %-3u\n", "caton ",  __le32_to_cpu(bt_link_info->bt_caton_num), "tx_retry", __le32_to_cpu(bt_link_info->bt_tx_retry_num));
+
+		/*if (bt_link_info->curr_req_ongoing)
+			seq_printf(seq, "time_from_cur_req_start : %7d\n", __le32_to_cpu(bt_link_info->time_diff_req_start));
+		else
+			seq_printf(seq, "time_to_next_req_start  : %7d\n", __le32_to_cpu(bt_link_info->time_diff_req_start)); //unuse */
+	}
+
+	return 0;
+}
+
+static int xradio_epta_stat_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, &xradio_epta_stat_show,
+		inode->i_private);
+}
+
+static const struct file_operations fops_epta_stat = {
+	.open = xradio_epta_stat_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.owner = THIS_MODULE,
+};
+
+static ssize_t xradio_epta_stat_dbg_write(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *hw_priv = file->private_data;
+	char buf[12] = {0};
+	char *endptr = NULL;
+	u32 dbg_val = 0;
+
+	count = (count > 11 ? 11 : count);
+
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+	dbg_val = simple_strtoul(buf, &endptr, 16);
+	if (count_ones(dbg_val) > 3 || dbg_val > 0x7ff) {
+		SYS_WARN(1);
+		return count;
+	}
+	epta_stat_dbg_ctrl = dbg_val;
+	xradio_dbg(XRADIO_DBG_ALWY, "epta_stat_dbg_ctrl = 0x%x\n", epta_stat_dbg_ctrl);
+	SYS_WARN(wsm_set_epta_stat_dbg_ctrl(hw_priv, epta_stat_dbg_ctrl));
+
+	return count;
+}
+
+static ssize_t xradio_epta_stat_dbg_read(struct file *file,
+	char __user *user_buf, size_t count, loff_t *ppos)
+{
+	/* struct xradio_common *hw_priv = file->private_data; */
+	char buf[50];
+	size_t size = 0;
+
+	sprintf(buf, "epta_stat_dbg_ctrl = 0x%x\n", epta_stat_dbg_ctrl);
+	size = strlen(buf);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, size);
+}
+#endif
+
+static int count_idx;
+
+#ifdef SUPPORT_HT40
+
+static int xradio_dbgstats_show(struct seq_file *seq, void *v)
+{
+	int ret;
+	int avg_ampdu_len = 0;
+	int FrameFail_ratio = 0;
+	int FailByRts_ratio = 0;
+	int FrameRetry_ratio = 0;
+	int AMPDURetry_ratio = 0;
+	int Retry1_ratio = 0;
+	int Retry2_ratio = 0;
+	int Retry3_ratio = 0;
+	struct xradio_common *hw_priv = seq->private;
+	struct wsm_counters_table counters;
+	struct wsm_ampducounters_table ampdu_counters;
+	struct wsm_txpipe_counter txpipe;
+
+	ret = wsm_get_counters_table(hw_priv, &counters);
+	if (ret)
+		return ret;
+
+	ret = wsm_get_txpipe_table(hw_priv, &txpipe);
+	if (ret)
+		return ret;
+
+	ret = wsm_get_ampducounters_table(hw_priv, &ampdu_counters);
+	if (ret)
+		return ret;
+
+#define CAT_STR(x, y) x ## y
+
+#define PUT_COUNTER(tab, name) \
+	seq_printf(seq, tab "%d\n", \
+		__le32_to_cpu(counters.CAT_STR(count, name)))
+
+#define PUT_AMPDU_COUNTER(tab, name) \
+	seq_printf(seq, tab "%d\n", \
+		__le32_to_cpu(ampdu_counters.CAT_STR(count, name)))
+
+#define PUT_TXPIPE(tab, name) \
+	seq_printf(seq, tab "%d\n", \
+		__le32_to_cpu(txpipe.CAT_STR(count, name)))
+
+	if (ampdu_counters.countTxAMPDUs) {
+		avg_ampdu_len = (int)((ampdu_counters.countTxMPDUsInAMPDUs + \
+				      (ampdu_counters.countTxAMPDUs>>1)) \
+				      /ampdu_counters.countTxAMPDUs);
+		AMPDURetry_ratio = (int)(ampdu_counters.countImplictBARFailures * \
+					 100/ampdu_counters.countTxAMPDUs);
+	}
+	if (counters.countAckFailures) {
+		Retry1_ratio = (int)(txpipe.count3*100/counters.countAckFailures);
+		Retry2_ratio = (int)(txpipe.count4*100/counters.countAckFailures);
+		Retry3_ratio = (int)(txpipe.count5*100/counters.countAckFailures);
+	}
+	if (ampdu_counters.countTxMPDUsInAMPDUs) {
+		FrameFail_ratio = (int)(counters.countTxFrameFailures * \
+				       1000/ampdu_counters.countTxMPDUsInAMPDUs);
+		FrameRetry_ratio = (int)(counters.countAckFailures * \
+				       100/ampdu_counters.countTxMPDUsInAMPDUs);
+	}
+
+	if (counters.countTxFrameFailures)
+		FailByRts_ratio = (int)(txpipe.counta * \
+					100/counters.countTxFrameFailures);
+
+	seq_printf(seq, "===========================================\n");
+	seq_printf(seq, "                   %02d\n", count_idx);
+	seq_printf(seq, "===========================================\n");
+	count_idx++;
+	count_idx = count_idx % 100;
+	PUT_COUNTER("RtsSuccess:        ", RtsSuccess);
+	PUT_COUNTER("RtsFailures:       ", RtsFailures);
+	seq_printf(seq, "Avg_AMPDU_Len:     %d\n", __le32_to_cpu(avg_ampdu_len));
+	PUT_AMPDU_COUNTER("TxAMPDUs:          ", TxAMPDUs);
+	PUT_AMPDU_COUNTER("TxMPDUsInAMPDUs:   ", TxMPDUsInAMPDUs);
+	/* PUT_COUNTER      ("TxFrameRetries:    ", AckFailures); */
+	/* PUT_COUNTER      ("TxFrameFailures:   ", TxFrameFailures); */
+	PUT_TXPIPE("Failure_By_Rts:    ", a);
+	/* PUT_AMPDU_COUNTER("BA-RX-Fails    ", ImplictBARFailures);
+	PUT_AMPDU_COUNTER("TxAMPDUs       ", TxAMPDUs);
+	PUT_TXPIPE       ("ReTx-AMPDUs    ", 2);
+	PUT_TXPIPE       ("Retry_type1    ", 3);
+	PUT_TXPIPE       ("Retry_type2    ", 4);
+	PUT_TXPIPE       ("Retry_type3    ", 5); */
+	seq_printf(seq, "==============\n");
+	seq_printf(seq, "FrameFail_ratio:   %d%%%%\n",
+		   __le32_to_cpu(FrameFail_ratio));
+	seq_printf(seq, "FailByRts_ratio:   %d%%\n",
+		   __le32_to_cpu(FailByRts_ratio));
+	seq_printf(seq, "FrameRetry_ratio:  %d%%\n",
+		   __le32_to_cpu(FrameRetry_ratio));
+	seq_printf(seq, "AMPDURetry_ratio:  %d%%\n",
+		   __le32_to_cpu(AMPDURetry_ratio));
+	seq_printf(seq, "Retry1_ratio:      %d%%\n",
+		   __le32_to_cpu(Retry1_ratio));
+	seq_printf(seq, "Retry2_ratio:      %d%%\n",
+		   __le32_to_cpu(Retry2_ratio));
+	seq_printf(seq, "Retry3_ratio:      %d%%\n",
+		   __le32_to_cpu(Retry3_ratio));
+
+	seq_printf(seq, "==============\n");
+
+
+
+#define PUT_TXRATE_COUNT(idx, bdsss, aofdm) do { \
+		seq_printf(seq, "MCS%d:"  "[%8d][%8d] [%8d][%8d] %4s:" \
+			"[%8d] %3s:[%8d]\n", idx, \
+			__le32_to_cpu(TxedHtofdmRateMap[0][idx]), \
+			__le32_to_cpu(TxedHtofdmRateMap[1][idx]), \
+			__le32_to_cpu(TxedHtofdmRateMap[2][idx]), \
+			__le32_to_cpu(TxedHtofdmRateMap[3][idx]), \
+		#bdsss, __le32_to_cpu(TxedLegacyRateMap[0][idx]), \
+		#aofdm, __le32_to_cpu(TxedLegacyRateMap[1][idx]));\
+			TxedHtofdmRateMap[0][idx] = 0;\
+			TxedHtofdmRateMap[1][idx] = 0;\
+			TxedHtofdmRateMap[2][idx] = 0;\
+			TxedHtofdmRateMap[3][idx] = 0;\
+			TxedLegacyRateMap[0][idx] = 0;\
+			TxedLegacyRateMap[1][idx] = 0;\
+	} while (0)
+
+		seq_printf(seq, "\nTxRateMap:\n");
+		seq_printf(seq, "     " "[20SGI TX][20LGI TX] " \
+					"[40SGI TX][40LGI TX] " \
+					"     [DSSS  TX] " \
+					"    [OFDM  TX]\n");
+
+		PUT_TXRATE_COUNT(7, 11MS, 54M);
+		PUT_TXRATE_COUNT(6, 11ML, 48M);
+		PUT_TXRATE_COUNT(5, 5M5S, 36M);
+		PUT_TXRATE_COUNT(4, 5M5L, 24M);
+		PUT_TXRATE_COUNT(3,  2MS, 18M);
+		PUT_TXRATE_COUNT(2,  2ML, 12M);
+		PUT_TXRATE_COUNT(1, ----,  9M);
+		PUT_TXRATE_COUNT(0,  1ML,  6M);
+
+#undef PUT_TXRATE_COUNT
+
+#define PUT_RXRATE_COUNT(idx, bdsss, aofdm) do { \
+		seq_printf(seq, "MCS%d:"  "[%8d][%8d] [%8d][%8d] %4s:" \
+			"[%8d] %3s:[%8d]\n", idx, \
+			__le32_to_cpu(RxedHtofdmRateMap[0][idx]), \
+			__le32_to_cpu(RxedHtofdmRateMap[1][idx]), \
+			__le32_to_cpu(RxedHtofdmRateMap[2][idx]), \
+			__le32_to_cpu(RxedHtofdmRateMap[3][idx]), \
+		#bdsss, __le32_to_cpu(RxedLegacyRateMap[0][idx]), \
+		#aofdm, __le32_to_cpu(RxedLegacyRateMap[1][idx]));\
+			RxedHtofdmRateMap[0][idx] = 0;\
+			RxedHtofdmRateMap[1][idx] = 0;\
+			RxedHtofdmRateMap[2][idx] = 0;\
+			RxedHtofdmRateMap[3][idx] = 0;\
+			RxedLegacyRateMap[0][idx] = 0;\
+			RxedLegacyRateMap[1][idx] = 0;\
+	} while (0)
+
+		seq_printf(seq, "\nRxRateMap:\n");
+		seq_printf(seq, "     " "[20SGI RX][20LGI RX] " \
+					"[40SGI RX][40LGI RX] " \
+					"     [DSSS  RX] " \
+					"    [OFDM  RX]\n");
+
+		PUT_RXRATE_COUNT(7, 11MS, 54M);
+		PUT_RXRATE_COUNT(6, 11ML, 48M);
+		PUT_RXRATE_COUNT(5, 5M5S, 36M);
+		PUT_RXRATE_COUNT(4, 5M5L, 24M);
+		PUT_RXRATE_COUNT(3,  2MS, 18M);
+		PUT_RXRATE_COUNT(2,  2ML, 12M);
+		PUT_RXRATE_COUNT(1, ----,  9M);
+		PUT_RXRATE_COUNT(0,  1ML,  6M);
+
+#undef PUT_RXRATE_COUNT
+
+#undef PUT_COUNTER
+#undef PUT_AMPDU_COUNTER
+#undef PUT_TXPIPE
+#undef CAT_STR
+
+	return 0;
+}
+
+#else
+
+static int xradio_dbgstats_show(struct seq_file *seq, void *v)
+{
+	int ret;
+	int avg_ampdu_len = 0;
+	int FrameFail_ratio = 0;
+	int FailByRts_ratio = 0;
+	int FrameRetry_ratio = 0;
+	int AMPDURetry_ratio = 0;
+	int Retry1_ratio = 0;
+	int Retry2_ratio = 0;
+	int Retry3_ratio = 0;
+	struct xradio_common *hw_priv = seq->private;
+	struct wsm_counters_table counters;
+	struct wsm_ampducounters_table ampdu_counters;
+	struct wsm_txpipe_counter txpipe;
+
+	ret = wsm_get_counters_table(hw_priv, &counters);
+	if (ret)
+		return ret;
+
+	ret = wsm_get_txpipe_table(hw_priv, &txpipe);
+	if (ret)
+		return ret;
+
+	ret = wsm_get_ampducounters_table(hw_priv, &ampdu_counters);
+	if (ret)
+		return ret;
+
+#define CAT_STR(x, y) x ## y
+
+#define PUT_COUNTER(tab, name) \
+	seq_printf(seq, tab "%d\n", \
+		__le32_to_cpu(counters.CAT_STR(count, name)))
+
+#define PUT_AMPDU_COUNTER(tab, name) \
+	seq_printf(seq, tab "%d\n", \
+		__le32_to_cpu(ampdu_counters.CAT_STR(count, name)))
+
+#define PUT_TXPIPE(tab, name) \
+	seq_printf(seq, tab "%d\n", \
+		__le32_to_cpu(txpipe.CAT_STR(count, name)))
+
+#define PUT_RATE_COUNT(name, idx) do { \
+	seq_printf(seq, "%s\t%d\n", #name, \
+		__le32_to_cpu(TxedRateIdx_Map[idx])); \
+	TxedRateIdx_Map[idx] = 0; \
+	} while (0)
+
+	if (ampdu_counters.countTxAMPDUs) {
+		avg_ampdu_len = (int)((ampdu_counters.countTxMPDUsInAMPDUs + \
+				      (ampdu_counters.countTxAMPDUs>>1)) \
+				      /ampdu_counters.countTxAMPDUs);
+		AMPDURetry_ratio = (int)(ampdu_counters.countImplictBARFailures * \
+					 100/ampdu_counters.countTxAMPDUs);
+	}
+	if (counters.countAckFailures) {
+		Retry1_ratio = (int)(txpipe.count3*100/counters.countAckFailures);
+		Retry2_ratio = (int)(txpipe.count4*100/counters.countAckFailures);
+		Retry3_ratio = (int)(txpipe.count5*100/counters.countAckFailures);
+	}
+	if (ampdu_counters.countTxMPDUsInAMPDUs) {
+		FrameFail_ratio = (int)(counters.countTxFrameFailures * \
+				       1000/ampdu_counters.countTxMPDUsInAMPDUs);
+		FrameRetry_ratio = (int)(counters.countAckFailures * \
+				       100/ampdu_counters.countTxMPDUsInAMPDUs);
+	}
+
+	if (counters.countTxFrameFailures)
+		FailByRts_ratio = (int)(txpipe.counta * \
+					100/counters.countTxFrameFailures);
+
+	seq_printf(seq, "===========================================\n");
+	seq_printf(seq, "                   %02d\n", count_idx);
+	seq_printf(seq, "===========================================\n");
+	count_idx++;
+	count_idx = count_idx%100;
+	PUT_COUNTER      ("RtsSuccess:        ", RtsSuccess);
+	PUT_COUNTER      ("RtsFailures:       ", RtsFailures);
+	seq_printf(seq, "Avg_AMPDU_Len:     %d\n", __le32_to_cpu(avg_ampdu_len));
+	PUT_AMPDU_COUNTER("TxAMPDUs:          ", TxAMPDUs);
+	PUT_AMPDU_COUNTER("TxMPDUsInAMPDUs:   ", TxMPDUsInAMPDUs);
+	/* PUT_COUNTER      ("TxFrameRetries:    ", AckFailures); */
+	/* PUT_COUNTER      ("TxFrameFailures:   ", TxFrameFailures); */
+	PUT_TXPIPE       ("Failure_By_Rts:    ", a);
+	/* PUT_AMPDU_COUNTER("BA-RX-Fails    ", ImplictBARFailures);
+	PUT_AMPDU_COUNTER("TxAMPDUs       ", TxAMPDUs);
+	PUT_TXPIPE       ("ReTx-AMPDUs    ", 2);
+	PUT_TXPIPE       ("Retry_type1    ", 3);
+	PUT_TXPIPE       ("Retry_type2    ", 4);
+	PUT_TXPIPE       ("Retry_type3    ", 5); */
+	seq_printf(seq, "==============\n");
+	seq_printf(seq, "FrameFail_ratio:   %d%%%%\n",
+		   __le32_to_cpu(FrameFail_ratio));
+	seq_printf(seq, "FailByRts_ratio:   %d%%\n",
+		   __le32_to_cpu(FailByRts_ratio));
+	seq_printf(seq, "FrameRetry_ratio:  %d%%\n",
+		   __le32_to_cpu(FrameRetry_ratio));
+	seq_printf(seq, "AMPDURetry_ratio:  %d%%\n",
+		   __le32_to_cpu(AMPDURetry_ratio));
+	seq_printf(seq, "Retry1_ratio:      %d%%\n",
+		   __le32_to_cpu(Retry1_ratio));
+	seq_printf(seq, "Retry2_ratio:      %d%%\n",
+		   __le32_to_cpu(Retry2_ratio));
+	seq_printf(seq, "Retry3_ratio:      %d%%\n",
+		   __le32_to_cpu(Retry3_ratio));
+
+	seq_printf(seq, "==============\n");
+	PUT_RATE_COUNT("65   Mbps:", 21);
+	PUT_RATE_COUNT("58.5 Mbps:", 20);
+	PUT_RATE_COUNT("52   Mbps:", 19);
+	PUT_RATE_COUNT("39   Mbps:", 18);
+	PUT_RATE_COUNT("26   Mbps:", 17);
+	PUT_RATE_COUNT("19.5 Mbps:", 16);
+	PUT_RATE_COUNT("13   Mbps:", 15);
+	PUT_RATE_COUNT("6.5  Mbps:", 14);
+
+#undef PUT_COUNTER
+#undef PUT_AMPDU_COUNTER
+#undef PUT_TXPIPE
+#undef PUT_RATE_COUNT
+#undef CAT_STR
+
+	return 0;
+}
+
+#endif
+
+static int xradio_dbgstats_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, &xradio_dbgstats_show, inode->i_private);
+}
+
+static const struct file_operations fops_dbgstats = {
+	.open = xradio_dbgstats_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.owner = THIS_MODULE,
+};
+
+static int xradio_generic_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+static ssize_t xradio_11n_read(struct file *file,
+	char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *hw_priv = file->private_data;
+	struct ieee80211_supported_band *band =
+		hw_priv->hw->wiphy->bands[NL80211_BAND_2GHZ];
+	return simple_read_from_buffer(user_buf, count, ppos,
+		    band->ht_cap.ht_supported ? "1\n" : "0\n", 2);
+}
+
+static ssize_t xradio_11n_write(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *hw_priv = file->private_data;
+	struct ieee80211_supported_band *band[2] = {
+		hw_priv->hw->wiphy->bands[NL80211_BAND_2GHZ],
+		hw_priv->hw->wiphy->bands[NL80211_BAND_5GHZ],
+	};
+	char buf[1];
+	int ena = 0;
+
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, 1))
+		return -EFAULT;
+	if (buf[0] == 1)
+		ena = 1;
+
+	band[0]->ht_cap.ht_supported = ena;
+#ifdef CONFIG_XRADIO_5GHZ_SUPPORT
+	band[1]->ht_cap.ht_supported = ena;
+#endif /* CONFIG_XRADIO_5GHZ_SUPPORT */
+
+	return count;
+}
+
+static const struct file_operations fops_11n = {
+	.open = xradio_generic_open,
+	.read = xradio_11n_read,
+	.write = xradio_11n_write,
+	.llseek = default_llseek,
+};
+
+
+static u32 fwdbg_ctrl;
+
+static ssize_t xradio_fwdbg_write(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *hw_priv = file->private_data;
+	char buf[12] = {0};
+	char *endptr = NULL;
+
+	count = (count > 11 ? 11 : count);
+
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+	fwdbg_ctrl = simple_strtoul(buf, &endptr, 16);
+	xradio_dbg(XRADIO_DBG_ALWY, "fwdbg_ctrl = %d\n", fwdbg_ctrl);
+	SYS_WARN(wsm_set_fw_debug_control(hw_priv, fwdbg_ctrl, 0));
+
+	return count;
+}
+
+static ssize_t xradio_fwdbg_read(struct file *file,
+	char __user *user_buf, size_t count, loff_t *ppos)
+{
+	/* struct xradio_common *hw_priv = file->private_data; */
+	char buf[50];
+	size_t size = 0;
+
+	sprintf(buf, "fwdbg_ctrl = %u\n", fwdbg_ctrl);
+	size = strlen(buf);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, size);
+}
+static const struct file_operations fops_fwdbg = {
+	.open = xradio_generic_open,
+	.write = xradio_fwdbg_write,
+	.read = xradio_fwdbg_read,
+	.llseek = default_llseek,
+};
+
+/* read/write fw registers */
+static ssize_t xradio_fwreg_rw(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *hw_priv = file->private_data;
+	char  buf[256] = {0};
+	u16   buf_size = (count > 255 ? 255 : count);
+	char *startptr = &buf[0];
+	char *endptr   = NULL;
+	u16   flag     = 0;
+	int   i, end   = 16;
+
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+
+	flag  = simple_strtoul(startptr, &endptr, 16);
+	startptr = endptr+1;
+	if (flag & WSM_REG_RW_F) {  /* write */
+		WSM_REG_W reg_w;
+		reg_w.flag = flag;
+		reg_w.data_size = 0;
+		if (flag & WSM_REG_BK_F)
+			end = 2;
+
+		for (i = 0; (i < end) && ((buf + buf_size - 12) > endptr); i++) {
+			reg_w.arg[i].reg_addr = simple_strtoul(startptr, &endptr, 16);
+			startptr = endptr + 1;
+			reg_w.arg[i].reg_val  = simple_strtoul(startptr, &endptr, 16);
+			startptr = endptr + 1;
+		}
+		if (i)
+			reg_w.data_size = 4 + i * 8;
+		xradio_dbg(XRADIO_DBG_ALWY, "W:flag=0x%x, size=%d\n",
+			   reg_w.flag, reg_w.data_size);
+		wsm_write_mib(hw_priv, WSM_MIB_ID_RW_FW_REG,
+			      (void *)&reg_w, reg_w.data_size, 0);
+
+	} else {  /* read */
+		WSM_REG_R reg_r;
+		reg_r.flag = flag;
+		reg_r.data_size = 0;
+		if (flag & WSM_REG_BK_F)
+			end = 2;
+
+		for (i = 0; (i < end) && ((buf + buf_size - 6) > endptr); i++) {
+			reg_r.arg[i] = simple_strtoul(startptr, &endptr, 16);
+			startptr = endptr + 1;
+		}
+		if (i)
+			reg_r.data_size = 4 + i * 4;
+
+		wsm_read_mib(hw_priv, WSM_MIB_ID_RW_FW_REG, (void *)&reg_r,
+			     sizeof(WSM_REG_R), reg_r.data_size);
+
+		xradio_dbg(XRADIO_DBG_ALWY, "R:flag=0x%x, size=%d\n",
+			   reg_r.flag, reg_r.data_size);
+
+		end = (reg_r.data_size >> 2) - 1;
+		if (!end || !(reg_r.flag & WSM_REG_RET_F))
+			return count;
+
+		for (i = 0; i < end; i++) {
+			xradio_dbg(XRADIO_DBG_ALWY, "0x%08x ", reg_r.arg[i]);
+			if ((i & 3) == 3)
+				xradio_dbg(XRADIO_DBG_ALWY, "\n");
+		}
+		xradio_dbg(XRADIO_DBG_ALWY, "\n");
+	}
+	return count;
+}
+
+static const struct file_operations fops_rw_fwreg = {
+	.open = xradio_generic_open,
+	.write = xradio_fwreg_rw,
+	.llseek = default_llseek,
+};
+
+/* This ops only used in bh error occured already.
+ * It can be dangerous to use it in normal status. */
+static ssize_t xradio_fwreg_rw_direct(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	/* for H64 HIF test */
+	struct xradio_common *hw_priv = file->private_data;
+	char buf[256] = { 0 };
+	u16 buf_size = (count > 255 ? 255 : count);
+	char *startptr = &buf[0];
+	char *endptr = NULL;
+	u16 flag = 0;
+	int i, end = 16;
+
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+
+	flag = simple_strtoul(startptr, &endptr, 16);
+	startptr = endptr + 1;
+	if (flag & WSM_REG_RW_F) {  /* write */
+		int ret = 0;
+		u32 val32 = 0;
+		WSM_REG_W reg_w;
+		reg_w.flag = flag;
+		reg_w.data_size = 0;
+		if (flag & WSM_REG_BK_F)
+			end = 2;
+
+		for (i = 0; (i < end) && ((buf + buf_size - 12) > endptr); i++) {
+			reg_w.arg[i].reg_addr = simple_strtoul(startptr, &endptr, 16);
+			startptr = endptr + 1;
+			reg_w.arg[i].reg_val  = simple_strtoul(startptr, &endptr, 16);
+			startptr = endptr + 1;
+		}
+
+		if (!(reg_w.arg[0].reg_addr & 0xffff0000)) { /* means write register */
+			ret = xradio_reg_write_32(hw_priv,
+				reg_w.arg[0].reg_addr, reg_w.arg[0].reg_val);
+			if (ret < 0) {
+				xradio_dbg(XRADIO_DBG_ERROR, "%s:test HIF R/W [register]-- " \
+					   "write CONFIG err, ret is %d! \n",
+					   __func__, ret);
+			} else {
+				xradio_dbg(XRADIO_DBG_ALWY, "%s:test HIF R/W [register]]-- " \
+					   "write  register @0x%x, val is 0x%x\n",
+					   __func__, reg_w.arg[0].reg_addr,
+					   reg_w.arg[0].reg_val);
+			}
+		} else { /* means write memory */
+			/* change to direct mode */
+			ret = xradio_reg_read_32(hw_priv, HIF_CONFIG_REG_ID, &val32);
+			if (ret < 0) {
+				xradio_dbg(XRADIO_DBG_ERROR, "%s:test HIF R/W -- " \
+					   "reading CONFIG err, ret is %d! \n", __func__, ret);
+			}
+			ret = xradio_reg_write_32(hw_priv, HIF_CONFIG_REG_ID,
+						  val32 | HIF_CONFIG_ACCESS_MODE_BIT);
+			if (ret < 0) {
+				xradio_dbg(XRADIO_DBG_ERROR, "%s:test HIF R/W -- " \
+					   "setting direct mode err, ret is %d! \n",
+					   __func__, ret);
+			}
+
+			ret = xradio_ahb_write_32(hw_priv, reg_w.arg[0].reg_addr,
+						  reg_w.arg[0].reg_val);
+			if (ret < 0) {
+				xradio_dbg(XRADIO_DBG_ERROR,
+					   "%s:AHB write test, val of addr %x is %x! \n",
+					   __func__, reg_w.arg[0].reg_addr, reg_w.arg[0].reg_val);
+			}
+
+			/* return to queue mode */
+			ret = xradio_reg_write_32(hw_priv, HIF_CONFIG_REG_ID,
+						  val32 & ~HIF_CONFIG_ACCESS_MODE_BIT);
+			if (ret < 0) {
+				xradio_dbg(XRADIO_DBG_ERROR, "%s:test HIF R/W -- " \
+					   "setting queue mode err, ret is %d! \n", __func__, ret);
+			}
+		}
+	} else {  /* read */
+		WSM_REG_R reg_r;
+		u32 val32 = 0;
+		u32 mem_val = 0;
+		int ret = 0;
+		reg_r.flag = flag;
+		reg_r.data_size = 0;
+		if (flag & WSM_REG_BK_F)
+			end = 2;
+
+		for (i = 0; (i < end) && ((buf + buf_size - 6) > endptr); i++) {
+			reg_r.arg[i] = simple_strtoul(startptr, &endptr, 16);
+			startptr = endptr + 1;
+		}
+		/* if (i) reg_r.data_size = 4+i*4; */
+		if (!(reg_r.arg[0] & 0xffff0000)) { /* means read register */
+			ret = xradio_reg_read_32(hw_priv, (u16)reg_r.arg[0], &val32);
+			if (ret < 0) {
+				xradio_dbg(XRADIO_DBG_ERROR, "%s:test HIF R/W [register]-- " \
+					   "reading CONFIG err, ret is %d! \n",
+					   __func__, ret);
+			}
+			xradio_dbg(XRADIO_DBG_ALWY, "%s:test HIF R/W [register]]-- " \
+				   "reading  register @0x%x, val is 0x%x\n",
+				   __func__, reg_r.arg[0], val32);
+		} else { /* means read memory */
+
+			/* change to direct mode */
+			ret = xradio_reg_read_32(hw_priv, HIF_CONFIG_REG_ID, &val32);
+			if (ret < 0) {
+				xradio_dbg(XRADIO_DBG_ERROR, "%s:test HIF R/W -- " \
+					   "reading CONFIG err, ret is %d! \n",
+					   __func__, ret);
+			}
+			ret = xradio_reg_write_32(hw_priv, HIF_CONFIG_REG_ID,
+						   val32 | HIF_CONFIG_ACCESS_MODE_BIT);
+			if (ret < 0) {
+				xradio_dbg(XRADIO_DBG_ERROR, "%s:test HIF R/W -- " \
+					   "setting direct mode err, ret is %d! \n",
+					    __func__, ret);
+			}
+
+			if (reg_r.arg[0] & 0x08000000) {
+				ret = xradio_ahb_read_32(hw_priv, reg_r.arg[0], &mem_val);
+				if (ret < 0) {
+					xradio_dbg(XRADIO_DBG_ERROR, "%s:AHB read test err, " \
+						   "val of addr %08x is %08x \n",
+						   __func__, reg_r.arg[0], mem_val);
+				}
+				xradio_dbg(XRADIO_DBG_ALWY, "[%08x] = 0x%08x\n",
+					   reg_r.arg[0], mem_val);
+			} else if (reg_r.arg[0] & 0x09000000) {
+				ret = xradio_apb_read_32(hw_priv, reg_r.arg[0], &mem_val);
+				if (ret < 0) {
+					xradio_dbg(XRADIO_DBG_ERROR, "%s:APB read test err, " \
+						   "val of addr %08x is %08x \n",
+						   __func__, reg_r.arg[0], mem_val);
+				}
+				xradio_dbg(XRADIO_DBG_ALWY, "[%08x] = 0x%08x\n",
+					   reg_r.arg[0], mem_val);
+			}
+
+			/* return to queue mode */
+			ret = xradio_reg_write_32(hw_priv, HIF_CONFIG_REG_ID,
+						  val32 & ~HIF_CONFIG_ACCESS_MODE_BIT);
+			if (ret < 0) {
+				xradio_dbg(XRADIO_DBG_ERROR, "%s:test HIF R/W -- " \
+					   "setting queue mode err, ret is %d! \n",
+					   __func__, ret);
+			}
+		}
+	}
+	return count;
+}
+static const struct file_operations fops_rw_fwreg_direct = {
+	.open = xradio_generic_open,
+	.write = xradio_fwreg_rw_direct,
+	.llseek = default_llseek,
+};
+/* setting ampdu_len */
+u16 ampdu_len[2] = {16, 16};
+static ssize_t xradio_ampdu_len_write(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *hw_priv = file->private_data;
+	char buf[12] = { 0 };
+	char *endptr = NULL;
+	u8 if_id = 0;
+
+	count = (count > 11 ? 11 : count);
+
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+	if_id = simple_strtoul(buf, &endptr, 10);
+	ampdu_len[if_id] = simple_strtoul(endptr + 1, NULL, 10);
+
+	xradio_dbg(XRADIO_DBG_ALWY, "vif=%d, ampdu_len = %d\n",
+		   if_id, ampdu_len[if_id]);
+	wsm_write_mib(hw_priv, WSM_MIB_ID_SET_AMPDU_NUM,
+		      &ampdu_len[if_id], sizeof(u16), if_id);
+
+	return count;
+}
+
+static ssize_t xradio_ampdu_len_read(struct file *file,
+	char __user *user_buf, size_t count, loff_t *ppos)
+{
+	/* struct xradio_common *hw_priv = file->private_data; */
+	char buf[100];
+	size_t size = 0;
+
+	sprintf(buf, "ampdu_len(0)=%d, (1)=%d\n", ampdu_len[0], ampdu_len[1]);
+	size = strlen(buf);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, size);
+}
+
+static const struct file_operations fops_ampdu_len = {
+	.open = xradio_generic_open,
+	.write = xradio_ampdu_len_write,
+	.read = xradio_ampdu_len_read,
+	.llseek = default_llseek,
+};
+
+
+/* setting rts threshold. */
+u32 rts_threshold[2] = {3000, 3000};
+static ssize_t xradio_rts_threshold_get(struct file *file,
+	char __user *user_buf, size_t count, loff_t *ppos)
+{
+	/* struct xradio_common *hw_priv = file->private_data; */
+	char buf[100];
+	size_t size = 0;
+
+	sprintf(buf, "rts_threshold(0)=%d, (1)=%d\n",
+		rts_threshold[0], rts_threshold[1]);
+	size = strlen(buf);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, size);
+}
+
+static ssize_t xradio_rts_threshold_set(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *hw_priv = file->private_data;
+	char buf[12] = { 0 };
+	char *endptr = NULL;
+	u8 if_id = 0;
+
+	count = (count > 11 ? 11 : count);
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+	if_id = simple_strtoul(buf, &endptr, 10);
+	rts_threshold[if_id] = simple_strtoul(endptr + 1, NULL, 10);
+
+	xradio_dbg(XRADIO_DBG_ALWY, "vif=%d, rts_threshold = %d\n",
+		   if_id, rts_threshold[if_id]);
+	wsm_write_mib(hw_priv, WSM_MIB_ID_DOT11_RTS_THRESHOLD,
+		      &rts_threshold[if_id], sizeof(u32), if_id);
+
+	return count;
+}
+
+static const struct file_operations fops_rts_threshold = {
+	.open = xradio_generic_open,
+	.write = xradio_rts_threshold_set,
+	.read = xradio_rts_threshold_get,
+	.llseek = default_llseek,
+};
+
+/* disable low power mode. */
+u8 low_pwr_disable;
+static ssize_t xradio_low_pwr_get(struct file *file,
+	char __user *user_buf, size_t count, loff_t *ppos)
+{
+	/* struct xradio_common *hw_priv = file->private_data; */
+	char buf[100];
+	size_t size = 0;
+
+	sprintf(buf, "low_pwr_disable=%d\n", low_pwr_disable);
+	size = strlen(buf);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, size);
+}
+
+static ssize_t xradio_low_pwr_set(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *hw_priv = file->private_data;
+	char buf[12] = { 0 };
+	char *endptr = NULL;
+	int if_id = 0;
+	u32 val = wsm_power_mode_quiescent;
+
+	count = (count > 11 ? 11 : count);
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+	low_pwr_disable = simple_strtoul(buf, &endptr, 16);
+	xradio_dbg(XRADIO_DBG_ALWY, "low_pwr_disable=%d\n", low_pwr_disable);
+
+	if (low_pwr_disable)
+		val = wsm_power_mode_active;
+
+	val |= BIT(4);   /* disableMoreFlagUsage */
+
+	for (if_id = 0; if_id < xrwl_get_nr_hw_ifaces(hw_priv); if_id++)
+		wsm_write_mib(hw_priv, WSM_MIB_ID_OPERATIONAL_POWER_MODE, &val,
+				sizeof(val), if_id);
+
+	return count;
+}
+
+static const struct file_operations fops_low_pwr = {
+	.open = xradio_generic_open,
+	.write = xradio_low_pwr_set,
+	.read = xradio_low_pwr_get,
+	.llseek = default_llseek,
+};
+
+/* disable ps mode(80211 protol). */
+static ssize_t xradio_ps_get(struct file *file,
+	char __user *user_buf, size_t count, loff_t *ppos)
+{
+	/* struct xradio_common *hw_priv = file->private_data; */
+	char buf[100];
+	size_t size = 0;
+
+	sprintf(buf, "ps_disable=%d, idleperiod=%d, changeperiod=%d\n",
+		ps_disable, ps_idleperiod, ps_changeperiod);
+	size = strlen(buf);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, size);
+}
+
+static ssize_t xradio_ps_set(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *hw_priv = file->private_data;
+	char buf[20] = { 0 };
+	char *start = &buf[0];
+	char *endptr = NULL;
+	struct wsm_set_pm ps = {
+		.pmMode = WSM_PSM_FAST_PS,
+		.fastPsmIdlePeriod = 0xC8  /* defaut 100ms */
+	};
+
+	count = (count > 19 ? 19 : count);
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	ps_disable = simple_strtoul(start, &endptr, 10);
+	start = endptr + 1;
+	if (start < buf + count)
+		ps_idleperiod = simple_strtoul(start, &endptr, 10) & 0xff;
+	start = endptr + 1;
+	if (start < buf + count)
+		ps_changeperiod = simple_strtoul(start, &endptr, 10) & 0xff;
+
+	xradio_dbg(XRADIO_DBG_ALWY,
+		   "ps_disable=%d, idleperiod=%d, changeperiod=%d\n",
+		   ps_disable, ps_idleperiod, ps_changeperiod);
+
+	/* set pm for debug */
+	if (ps_disable)
+		ps.pmMode = WSM_PSM_ACTIVE;
+	if (ps_idleperiod)
+		ps.fastPsmIdlePeriod = ps_idleperiod << 1;
+	if (ps_changeperiod)
+		ps.apPsmChangePeriod = ps_changeperiod << 1;
+
+	wsm_set_pm(hw_priv, &ps, 0);
+	if (hw_priv->vif_list[1])
+		wsm_set_pm(hw_priv, &ps, 1);
+
+	return count;
+}
+
+static const struct file_operations fops_ps_ctrl = {
+	.open = xradio_generic_open,
+	.write = xradio_ps_set,
+	.read = xradio_ps_get,
+	.llseek = default_llseek,
+};
+
+/* for retry debug. */
+u8 retry_dbg;
+u8 tx_short;   /* save orgin value. */
+u8 tx_long;    /* save orgin value. */
+
+static ssize_t xradio_retry_get(struct file *file,
+	char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *hw_priv = file->private_data;
+	char buf[100];
+	size_t size = 0;
+
+	sprintf(buf, "retry_dbg=%d, short=%d, long=%d\n", retry_dbg,
+		hw_priv->short_frame_max_tx_count,
+		hw_priv->long_frame_max_tx_count);
+	size = strlen(buf);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, size);
+}
+
+static ssize_t xradio_retry_set(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *hw_priv = file->private_data;
+	char buf[20] = { 0 };
+	char *start = &buf[0];
+	char *endptr = NULL;
+
+	count = (count > 19 ? 19 : count);
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+	retry_dbg = (simple_strtoul(start, &endptr, 10) & 0x1);
+	if (retry_dbg) { /* change retry.*/
+		if (!tx_short)
+			tx_short = hw_priv->short_frame_max_tx_count;
+		if (!tx_long)
+			tx_long = hw_priv->long_frame_max_tx_count;
+		start = endptr + 1;
+		if (start < buf + count) {
+			hw_priv->short_frame_max_tx_count =
+			    simple_strtoul(start, &endptr, 10) & 0xf;
+			start = endptr + 1;
+			if (start < buf + count)
+				hw_priv->long_frame_max_tx_count =
+				    simple_strtoul(start, &endptr, 10) & 0xf;
+		}
+		xradio_dbg(XRADIO_DBG_ALWY, "retry_dbg on, s=%d, l=%d\n",
+			  hw_priv->short_frame_max_tx_count,
+			  hw_priv->long_frame_max_tx_count);
+	} else {  /* restore retry. */
+		if (tx_short) {
+			hw_priv->short_frame_max_tx_count = tx_short;
+			tx_short = 0;
+		}
+		if (tx_long) {
+			hw_priv->long_frame_max_tx_count = tx_long;
+			tx_long = 0;
+		}
+		xradio_dbg(XRADIO_DBG_ALWY, "retry_dbg off, s=%d, l=%d\n",
+			  hw_priv->short_frame_max_tx_count,
+			  hw_priv->long_frame_max_tx_count);
+	}
+	retry_dbg |= 0x2;
+	return count;
+}
+
+static const struct file_operations fops_retry_ctrl = {
+	.open = xradio_generic_open,
+	.write = xradio_retry_set,
+	.read = xradio_retry_get,
+	.llseek = default_llseek,
+};
+
+/* for rates debug. */
+
+#ifdef SUPPORT_HT40
+
+u8  rates_dbg_en;
+u16 rates_debug[6] = {0x0};
+u8  Ratecnt_dbg;
+
+static ssize_t xradio_rates_get(struct file *file,
+	char __user *user_buf, size_t count, loff_t *ppos)
+{
+	/* struct xradio_common *hw_priv = file->private_data; */
+	char buf[200];
+	size_t size = 0;
+	sprintf(buf, "rates_dbg_en=%d, [0]=0x%04x, [1]=0x%04x, [2]=0x%04x " \
+		"[3]=0x%04x, [4]=0x%04x, [5]=0x%04x\n", (rates_dbg_en & 0x1),
+		rates_debug[0], rates_debug[1], rates_debug[2],
+		rates_debug[3], rates_debug[4], rates_debug[5]);
+	size = strlen(buf);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, size);
+}
+
+static ssize_t xradio_rates_set(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	/* struct xradio_common *hw_priv = file->private_data; */
+	char buf[50] = {0};
+	char *start  = &buf[0];
+	char *endptr = NULL;
+	int i = 0;
+	count = (count > 49 ? 49 : count);
+
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	rates_dbg_en &= ~0x1;
+	if (simple_strtoul(start, &endptr, 10)) {
+		for (i = 0; i < 6; i++) {
+			start = endptr+1;
+			if (start < buf+count)
+				rates_debug[i] = simple_strtoul(start, &endptr, 16);
+			else
+				break;
+		}
+
+		Ratecnt_dbg  = i;
+		rates_dbg_en = 0x1;
+
+		if (Ratecnt_dbg)
+			xradio_dbg(XRADIO_DBG_ERROR, "rates_dbg on, entry_cnt=%d!\n", Ratecnt_dbg);
+		else
+			xradio_dbg(XRADIO_DBG_ERROR, "rates_dbg fail, invaid params!\n");
+
+	} else {
+		xradio_dbg(XRADIO_DBG_ERROR, "rates_dbg off\n");
+	}
+	return count;
+}
+
+#else
+
+u8 rates_dbg_en;
+u32 rates_debug[3];
+u8  maxRate_dbg;
+
+static ssize_t xradio_rates_get(struct file *file,
+	char __user *user_buf, size_t count, loff_t *ppos)
+{
+	/* struct xradio_common *hw_priv = file->private_data; */
+	char buf[100];
+	size_t size = 0;
+	sprintf(buf, "rates_dbg_en=%d, [0]=0x%08x, [1]=0x%08x, [2]=0x%08x\n",
+		(rates_dbg_en & 0x1), rates_debug[2],
+		 rates_debug[1], rates_debug[0]);
+	size = strlen(buf);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, size);
+}
+
+static ssize_t xradio_rates_set(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	/* struct xradio_common *hw_priv = file->private_data; */
+	char buf[50] = { 0 };
+	char *start = &buf[0];
+	char *endptr = NULL;
+	int i = 0;
+	count = (count > 49 ? 49 : count);
+
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	rates_dbg_en &= ~0x1;
+	if (simple_strtoul(start, &endptr, 10)) {
+		start = endptr + 1;
+		if (start < buf + count)
+			rates_debug[2] = simple_strtoul(start, &endptr, 16);
+
+		start = endptr + 1;
+		if (start < buf + count)
+			rates_debug[1] = simple_strtoul(start, &endptr, 16);
+
+		start = endptr + 1;
+		if (start < buf + count)
+			rates_debug[0] = simple_strtoul(start, &endptr, 16);
+
+		for (i = 21; i >= 0; i--) {
+			if ((rates_debug[i >> 3] >> ((i & 0x7) << 2)) & 0xf) {
+				maxRate_dbg = i;
+				rates_dbg_en |= 0x1;
+				break;
+			}
+		}
+		if (rates_dbg_en & 0x1) {
+			xradio_dbg(XRADIO_DBG_ALWY,
+				   "rates_dbg on, maxrate=%d!\n", maxRate_dbg);
+		} else {
+			xradio_dbg(XRADIO_DBG_ALWY, "rates_dbg fail, invaid params!\n");
+		}
+	} else {
+		xradio_dbg(XRADIO_DBG_ALWY, "rates_dbg off\n");
+	}
+	return count;
+}
+
+#endif
+
+static const struct file_operations fops_rates_ctrl = {
+	.open = xradio_generic_open,
+	.write = xradio_rates_set,
+	.read = xradio_rates_get,
+	.llseek = default_llseek,
+};
+
+
+/* for backoff setting. */
+struct wsm_backoff_ctrl backoff_ctrl;
+
+static ssize_t xradio_backoff_ctrl_get(struct file *file,
+	char __user *user_buf, size_t count, loff_t *ppos)
+{
+	/* struct xradio_common *hw_priv = file->private_data; */
+	char buf[100];
+	size_t size = 0;
+	sprintf(buf, "backoff_ctrl_en=%d, min=%d, max=%d\n",
+		backoff_ctrl.enable,
+		backoff_ctrl.min,
+		backoff_ctrl.max);
+	size = strlen(buf);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, size);
+}
+
+static ssize_t xradio_backoff_ctrl_set(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *hw_priv = file->private_data;
+	char buf[20] = { 0 };
+	char *start = &buf[0];
+	char *endptr = NULL;
+	count = (count > 19 ? 19 : count);
+
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+	backoff_ctrl.enable = simple_strtoul(start, &endptr, 10);
+	if (backoff_ctrl.enable) {
+		start = endptr + 1;
+		if (start < buf + count)
+			backoff_ctrl.min = simple_strtoul(start, &endptr, 10);
+		start = endptr + 1;
+		if (start < buf + count)
+			backoff_ctrl.max = simple_strtoul(start, &endptr, 10);
+
+		xradio_dbg(XRADIO_DBG_ALWY, "backoff_ctrl on\n");
+	} else {
+		xradio_dbg(XRADIO_DBG_ALWY, "backoff_ctrl off\n");
+	}
+	wsm_set_backoff_ctrl(hw_priv, &backoff_ctrl);
+	return count;
+}
+
+static const struct file_operations fops_backoff_ctrl = {
+	.open = xradio_generic_open,
+	.write = xradio_backoff_ctrl_set,
+	.read = xradio_backoff_ctrl_get,
+	.llseek = default_llseek,
+};
+
+/* for TALA(Tx-Ampdu-Len-Adaption) setting. */
+struct wsm_tala_para tala_para;
+static ssize_t xradio_tala_get(struct file *file,
+	char __user *user_buf, size_t count, loff_t *ppos)
+{
+	/* struct xradio_common *hw_priv = file->private_data; */
+	char buf[100];
+	size_t size = 0;
+	sprintf(buf, "tala_para=0x%08x, tala_thresh=0x%08x\n",
+		tala_para.para, tala_para.thresh);
+	size = strlen(buf);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, size);
+}
+
+static ssize_t xradio_tala_set(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *hw_priv = file->private_data;
+	char buf[30] = { 0 };
+	char *start = &buf[0];
+	char *endptr = NULL;
+	count = (count > 29 ? 29 : count);
+
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	if (start < buf + count)
+		tala_para.para = simple_strtoul(start, &endptr, 16);
+	start = endptr + 1;
+	if (start < buf + count)
+		tala_para.thresh = simple_strtoul(start, &endptr, 16);
+
+	wsm_set_tala(hw_priv, &tala_para);
+	return count;
+}
+
+static const struct file_operations fops_tala_ctrl = {
+	.open = xradio_generic_open,
+	.write = xradio_tala_set,
+	.read = xradio_tala_get,
+	.llseek = default_llseek,
+};
+
+/* Tx power debug */
+char buf_show[1024] = { 0 };
+
+typedef struct _PWR_INFO_TBL {
+	u8 Index;
+	u8 u8Complete;
+	s16 s16TargetPwr;
+	s16 s16AdjustedPower;
+	s16 s16SmthErrTerm;
+	u32 u32Count;
+	u16 u16PpaVal;
+	u16 u16DigVal;
+} PWR_CTRL_TBL;
+struct _TX_PWR_SHOW {
+	u8 InfoID;
+	u8 Status;
+	u16 reserved;
+	PWR_CTRL_TBL table[16];
+} pwr_ctrl;
+static ssize_t xradio_tx_pwr_show(struct file *file,
+	char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *hw_priv = file->private_data;
+
+	int pos = 0, i = 0;
+	pwr_ctrl.InfoID = 0x1;
+	wsm_read_mib(hw_priv, WSM_MIB_ID_TX_POWER_INFO,
+		     (void *)&pwr_ctrl, sizeof(pwr_ctrl), 4);
+
+	if (pwr_ctrl.Status) {
+		pos += sprintf(&buf_show[pos],
+			       "read TX_POWER_INFO error=%x\n",
+				pwr_ctrl.Status);
+	} else {
+		for (i = 0; i < 16; i++) {
+			pos += sprintf(&buf_show[pos], "M%d:%d, ALG=%d, DIG=%d\n", i,
+				       pwr_ctrl.table[i].s16AdjustedPower,
+				       pwr_ctrl.table[i].u16PpaVal,
+				       pwr_ctrl.table[i].u16DigVal);
+		}
+	}
+	return simple_read_from_buffer(user_buf, count, ppos, buf_show, pos);
+}
+
+static ssize_t xradio_tx_pwr_set(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	/* struct xradio_common *hw_priv = file->private_data; */
+	return count;
+}
+
+static const struct file_operations fops_tx_pwr_ctrl = {
+	.open = xradio_generic_open,
+	.write = xradio_tx_pwr_set,
+	.read = xradio_tx_pwr_show,
+	.llseek = default_llseek,
+};
+
+/* TPA debug */
+#define CASE_NUM   9
+#define MAX_POINTS 4
+#define PWR_LEVEL_NUM 40
+#define MODULN_NUM 11
+typedef struct tag_pwr_modulation {
+	u8      def_pwr_idx;  /* default power index of modulation.*/
+	u8      max_pwr_idx;  /* max power index of modulation.*/
+	u8      mid_pwr_idx;  /* power index of middle point.*/
+	u8      cur_point;    /* current sample point.*/
+
+	u8      max_point;   /* the point has max q value.*/
+	u8      max_stable;  /* counter of stable max of the same point.*/
+	u8      exception;   /* the counter of exception case.*/
+	u8      listen_def;  /* whether to listen to default point.*/
+
+	u16     mod_smp_cnt;   /* total sample of the modulation.*/
+	u16     update_cnt;    /* counter of power update.*/
+	u32     update_time;   /* last time of power update.*/
+	u16     smp_points[MAX_POINTS*2];
+
+	u8      reserved;
+	u8      last_rate;
+	u16     last_max_Q;
+} PWR_MODULN;
+
+typedef struct tag_tpa_debug {
+	u32     update_total[MODULN_NUM];
+	u32     power_sum[MODULN_NUM];
+
+	u16     smp_case[CASE_NUM]; /* counter of every case.*/
+	u16     reserved0;
+	u16     smp_move_cnt[MAX_POINTS];    /* counter of movement of update power.*/
+	u16     max_point_cnt[MAX_POINTS];   /* counter of max point.*/
+
+	u16     smp_thresh_q_cnt;
+	u16     smp_timeout;
+	u16     smp_listdef_cnt;
+	u16     smp_excep_cnt;
+	u16     smp_stable_cnt;
+
+	u8      reserved2;
+	u8      smp_last_moduln;
+	u16     point_last_smp[MAX_POINTS*2];  /* Q value of point last update.*/
+} TPA_DEBUG_INFO;
+
+typedef struct tag_tpa_control {
+	u8      tpa_enable;
+	u8      tpa_initialized;
+	u8      point_interval;
+	u8      point_step;
+
+	u16     thresh_q;
+	u16     thresh_time;
+	u16     thresh_update;
+	u8      thresh_def_lstn;
+	u8      thresh_stable;
+	u8      pwr_level[PWR_LEVEL_NUM];
+} TPA_CONTROL;
+
+struct _TPA_INFO {
+	u8  InfoID;
+	u8  Status;
+	u8  node;
+	u8  reserved;
+	union {
+		TPA_DEBUG_INFO debug;
+		TPA_CONTROL    ctrl;
+		PWR_MODULN moduln[MODULN_NUM];
+	} u;
+} tpa_info;
+static ssize_t xradio_tpa_ctrl_get(struct file *file,
+	char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *hw_priv = file->private_data;
+	int pos = 0, i = 0;
+	memset(&tpa_info, 0, sizeof(tpa_info));
+	tpa_info.InfoID = 0x03;
+	tpa_info.node   = 0;
+	wsm_read_mib(hw_priv, WSM_MIB_ID_TPA_DEBUG_INFO,
+		     (void *)&tpa_info, sizeof(tpa_info), 4);
+
+	if (tpa_info.Status && tpa_info.InfoID != 0x43) {
+		pos += sprintf(&buf_show[pos],
+			       "read TPA_DEBUG_INFO error=%x\n",
+			       tpa_info.Status);
+	} else {
+		u8  *pwr = &tpa_info.u.ctrl.pwr_level[0];
+
+		pos += sprintf(&buf_show[pos],
+			       "en=%d, init=%d, intvl=%d, step=%d\n",
+			       tpa_info.u.ctrl.tpa_enable,
+			       tpa_info.u.ctrl.tpa_initialized,
+			       tpa_info.u.ctrl.point_interval,
+			       tpa_info.u.ctrl.point_step);
+		pos += sprintf(&buf_show[pos], "th_q=%d, th_tm=%d, th_updt=%d, " \
+			       "th_def_lstn=%d, th_stbl=%d\n",
+			       tpa_info.u.ctrl.thresh_q,
+			       tpa_info.u.ctrl.thresh_time,
+			       tpa_info.u.ctrl.thresh_update,
+			       tpa_info.u.ctrl.thresh_def_lstn,
+			       tpa_info.u.ctrl.thresh_stable);
+	  for (i = 0; i < 4; i++) {
+			pos += sprintf(&buf_show[pos],
+				       "pwr lvl=%d.%d, %d.%d, %d.%d, %d.%d\n",
+				       pwr[0]>>3, ((pwr[0]%8)*100)>>3,
+				       pwr[1]>>3, ((pwr[1]%8)*100)>>3,
+				       pwr[2]>>3, ((pwr[2]%8)*100)>>3,
+				       pwr[3]>>3, ((pwr[3]%8)*100)>>3);
+			pwr += 4;
+		}
+	}
+	return simple_read_from_buffer(user_buf, count, ppos, buf_show, pos);
+}
+
+struct TPA_CONTROL_SET {
+	u8      tpa_enable;
+	u8      reserved;
+	u8      point_interval;
+	u8      point_step;
+
+	u16     thresh_q;
+	u16     thresh_time;
+	u16     thresh_update;
+	u8      thresh_def_lstn;
+	u8      thresh_stable;
+} tpa_ctrl_set;
+static ssize_t xradio_tpa_ctrl_set(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *hw_priv = file->private_data;
+	char buffer[256] = { 0 };
+	char *buf = &buffer[0];
+	u16 buf_size = (count > 255 ? 255 : count);
+	char *startptr = &buffer[0];
+	char *endptr = NULL;
+
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+
+
+	if ((buf + buf_size) > endptr) {
+		tpa_ctrl_set.tpa_enable = simple_strtoul(startptr, &endptr, 10);
+		startptr = endptr + 1;
+	}
+	if ((buf + buf_size) > endptr) {
+		tpa_ctrl_set.point_interval = simple_strtoul(startptr, &endptr, 10);
+		startptr = endptr + 1;
+	}
+	if ((buf + buf_size) > endptr) {
+		tpa_ctrl_set.point_step = simple_strtoul(startptr, &endptr, 10);
+		startptr = endptr + 1;
+	}
+
+	if ((buf + buf_size) > endptr) {
+		tpa_ctrl_set.thresh_q = simple_strtoul(startptr, &endptr, 10);
+		startptr = endptr + 1;
+	}
+	if ((buf + buf_size) > endptr) {
+		tpa_ctrl_set.thresh_time = simple_strtoul(startptr, &endptr, 10);
+		startptr = endptr + 1;
+	}
+	if ((buf + buf_size) > endptr) {
+		tpa_ctrl_set.thresh_update = simple_strtoul(startptr, &endptr, 10);
+		startptr = endptr + 1;
+	}
+	if ((buf + buf_size) > endptr) {
+		tpa_ctrl_set.thresh_def_lstn = simple_strtoul(startptr, &endptr, 10);
+		startptr = endptr + 1;
+	}
+	if ((buf + buf_size) > endptr) {
+		tpa_ctrl_set.thresh_stable = simple_strtoul(startptr, &endptr, 10);
+		startptr = endptr + 1;
+	}
+	wsm_write_mib(hw_priv, WSM_MIB_ID_SET_TPA_PARAM,
+		      (void *)&tpa_ctrl_set, sizeof(tpa_ctrl_set), 0);
+
+	return count;
+}
+
+static const struct file_operations fops_tpa_ctrl = {
+	.open = xradio_generic_open,
+	.write = xradio_tpa_ctrl_set,
+	.read = xradio_tpa_ctrl_get,
+	.llseek = default_llseek,
+};
+
+u8 tpa_node_dbg;
+static int xradio_tpa_debug(struct seq_file *seq, void *v)
+{
+	int ret, i;
+	struct xradio_common *hw_priv = seq->private;
+
+#define PUT_TPA_MODULN(tab, name) \
+	seq_printf(seq, tab":\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n", \
+		   __le32_to_cpu(tpa_info.u.moduln[0].name), \
+		   __le32_to_cpu(tpa_info.u.moduln[1].name), \
+		   __le32_to_cpu(tpa_info.u.moduln[2].name), \
+		   __le32_to_cpu(tpa_info.u.moduln[3].name), \
+		   __le32_to_cpu(tpa_info.u.moduln[4].name), \
+		   __le32_to_cpu(tpa_info.u.moduln[5].name), \
+		   __le32_to_cpu(tpa_info.u.moduln[6].name), \
+		   __le32_to_cpu(tpa_info.u.moduln[7].name), \
+		   __le32_to_cpu(tpa_info.u.moduln[8].name), \
+		   __le32_to_cpu(tpa_info.u.moduln[9].name), \
+		   __le32_to_cpu(tpa_info.u.moduln[10].name))
+
+	tpa_info.InfoID = 0x01;
+	tpa_info.node = tpa_node_dbg;
+	ret = wsm_read_mib(hw_priv, WSM_MIB_ID_TPA_DEBUG_INFO,
+			   (void *)&tpa_info, sizeof(tpa_info), 4);
+
+	if (tpa_info.Status && tpa_info.InfoID != 0x41) {
+		seq_printf(seq, "read TPA_DEBUG_INFO error=%x\n", tpa_info.Status);
+	} else {
+		seq_printf(seq, "\t\tm0\tm1\tm2\tm3\tm4\tm5\tm6\tm7\tm8\tm9\tm10\t\n");
+
+		PUT_TPA_MODULN("max_idx", max_pwr_idx);
+		PUT_TPA_MODULN("def_idx", def_pwr_idx);
+		PUT_TPA_MODULN("mid_idx", mid_pwr_idx);
+		PUT_TPA_MODULN("cur_pt ", cur_point);
+		PUT_TPA_MODULN("max_pt ", max_point);
+		PUT_TPA_MODULN("stable ", max_stable);
+		PUT_TPA_MODULN("exceptn", exception);
+		PUT_TPA_MODULN("listen ", listen_def);
+		PUT_TPA_MODULN("smp_cnt", mod_smp_cnt);
+		PUT_TPA_MODULN("update ", update_cnt);
+
+		PUT_TPA_MODULN("pt[0]  ", smp_points[0]);
+		PUT_TPA_MODULN("pt[0]  ", smp_points[1]);
+		PUT_TPA_MODULN("pt[1]  ", smp_points[2]);
+		PUT_TPA_MODULN("pt[1]  ", smp_points[3]);
+		PUT_TPA_MODULN("pt[2]  ", smp_points[4]);
+		PUT_TPA_MODULN("pt[2]  ", smp_points[5]);
+		PUT_TPA_MODULN("pt[3]  ", smp_points[6]);
+		PUT_TPA_MODULN("pt[3]  ", smp_points[7]);
+
+		PUT_TPA_MODULN("rate   ", last_rate);
+		PUT_TPA_MODULN("Max Q  ", last_max_Q);
+	}
+#undef PUT_TPA_MODULN
+
+#define SMP_CASE(i)    __le32_to_cpu(tpa_info.u.debug.smp_case[i])
+#define PWR_LVL_S(n)  (tpa_info.u.debug.power_sum[n]>>3)
+
+
+	tpa_info.InfoID = 0x02;
+	tpa_info.node = tpa_node_dbg;
+	ret = wsm_read_mib(hw_priv, WSM_MIB_ID_TPA_DEBUG_INFO,
+			   (void *)&tpa_info, sizeof(tpa_info), 4);
+
+	if (tpa_info.Status && tpa_info.InfoID != 0x42) {
+		seq_printf(seq, "read TPA_DEBUG_INFO error=%x\n", tpa_info.Status);
+	} else {
+		for (i = 0; i < MODULN_NUM; i++) {
+			if (tpa_info.u.debug.update_total[i])
+				tpa_info.u.debug.power_sum[i] /=
+				    tpa_info.u.debug.update_total[i];
+			else
+				tpa_info.u.debug.power_sum[i] = 0;
+		}
+		seq_printf(seq, "\nupdate_total:\t%d\t%d\t%d\t%d\t" \
+			   "%d\t%d\t%d\t%d\t%d\t%d\t%d\n", \
+			   __le32_to_cpu(tpa_info.u.debug.update_total[0]), \
+			   __le32_to_cpu(tpa_info.u.debug.update_total[1]), \
+			   __le32_to_cpu(tpa_info.u.debug.update_total[2]), \
+			   __le32_to_cpu(tpa_info.u.debug.update_total[3]), \
+			   __le32_to_cpu(tpa_info.u.debug.update_total[4]), \
+			   __le32_to_cpu(tpa_info.u.debug.update_total[5]), \
+			   __le32_to_cpu(tpa_info.u.debug.update_total[6]), \
+			   __le32_to_cpu(tpa_info.u.debug.update_total[7]), \
+			   __le32_to_cpu(tpa_info.u.debug.update_total[8]), \
+			   __le32_to_cpu(tpa_info.u.debug.update_total[9]), \
+			   __le32_to_cpu(tpa_info.u.debug.update_total[10]));
+
+		seq_printf(seq, "pwr_avrg:\t%d\t%d\t%d\t%d\t%d\t%d\t"
+				"%d\t%d\t%d\t%d\t%d\n", \
+			   PWR_LVL_S(0), \
+			   PWR_LVL_S(1), \
+			   PWR_LVL_S(2), \
+			   PWR_LVL_S(3), \
+			   PWR_LVL_S(4), \
+			   PWR_LVL_S(5), \
+			   PWR_LVL_S(6), \
+			   PWR_LVL_S(7), \
+			   PWR_LVL_S(8), \
+			   PWR_LVL_S(9), \
+			   PWR_LVL_S(10));
+
+		seq_printf(seq, "SMP_CASE: %d, %d, %d, %d(E), " \
+			   "%d, %d, %d(E), %d(E), %d\n",
+			   SMP_CASE(0), SMP_CASE(1), SMP_CASE(2), SMP_CASE(3),
+			   SMP_CASE(4), SMP_CASE(5), SMP_CASE(6), SMP_CASE(7),
+			   SMP_CASE(8));
+		seq_printf(seq, "MAX: M=%d, L=%d, R=%d, D=%d\n",
+			   tpa_info.u.debug.max_point_cnt[0],
+			   tpa_info.u.debug.max_point_cnt[1],
+			   tpa_info.u.debug.max_point_cnt[2],
+			   tpa_info.u.debug.max_point_cnt[3]);
+		seq_printf(seq, "MOVE: M=%d, L=%d, R=%d, D=%d\n",
+			   tpa_info.u.debug.smp_move_cnt[0],
+			   tpa_info.u.debug.smp_move_cnt[1],
+			   tpa_info.u.debug.smp_move_cnt[2],
+			   tpa_info.u.debug.smp_move_cnt[3]);
+		seq_printf(seq, "listen=%d, timeout=%d, thresh_q=%d, " \
+			   "excep=%d, stable=%d\n",
+			   tpa_info.u.debug.smp_listdef_cnt,
+			   tpa_info.u.debug.smp_timeout,
+			   tpa_info.u.debug.smp_thresh_q_cnt,
+			   tpa_info.u.debug.smp_excep_cnt,
+			   tpa_info.u.debug.smp_stable_cnt);
+
+		seq_printf(seq, "lsat Moduln=%d, M=%d, %d; " \
+			   "L=%d, %d; R=%d, %d; D=%d, %d\n",
+			   tpa_info.u.debug.smp_last_moduln,
+			   tpa_info.u.debug.point_last_smp[0],
+			   tpa_info.u.debug.point_last_smp[1],
+			   tpa_info.u.debug.point_last_smp[2],
+			   tpa_info.u.debug.point_last_smp[3],
+			   tpa_info.u.debug.point_last_smp[4],
+			   tpa_info.u.debug.point_last_smp[5],
+			   tpa_info.u.debug.point_last_smp[6],
+			   tpa_info.u.debug.point_last_smp[7]);
+	}
+
+#undef PWR_LVL_S
+#undef SMP_CASE
+
+	return 0;
+}
+
+static int xradio_tpa_debug_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, &xradio_tpa_debug,
+		inode->i_private);
+}
+
+static const struct file_operations fops_tpa_debug = {
+	.open = xradio_tpa_debug_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.owner = THIS_MODULE,
+};
+
+/* policy_info */
+u32 tx_retrylimit;
+u32 tx_lower_limit;
+u32 tx_over_limit;
+int retry_mis;
+u32 policy_upload;
+u32 policy_num;
+
+static ssize_t xradio_policy_info(struct file *file,
+	char __user *user_buf, size_t count, loff_t *ppos)
+{
+	/* struct xradio_common *hw_priv = file->private_data; */
+	char buf[256];
+	size_t size = 0;
+	sprintf(buf, "tx_retrylimit=%d, tx_lower_limit=%d, " \
+		"tx_over_limit=%d, retry_mis=%d\n" \
+		"policy_upload=%d, policy_num=%d\n",
+		tx_retrylimit, tx_lower_limit, tx_over_limit, retry_mis,
+		policy_upload, policy_num);
+	size = strlen(buf);
+
+	/* clear counters */
+	tx_retrylimit  = 0;
+	tx_lower_limit = 0;
+	tx_over_limit  = 0;
+	retry_mis      = 0;
+	policy_upload  = 0;
+	policy_num     = 0;
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, size);
+}
+
+static const struct file_operations fops_policy_info = {
+	.open   = xradio_generic_open,
+	.read   = xradio_policy_info,
+	.llseek = default_llseek,
+};
+
+/* info of interruption */
+u32 irq_count;
+u32 int_miss_cnt;
+u32 fix_miss_cnt;
+u32 next_rx_cnt;
+u32 rx_total_cnt;
+u32 tx_total_cnt;
+u32 tx_buf_limit;
+u32 tx_limit;
+u32 tx_rx_idle;
+u32 bh_idle;
+u32 queue_lock_cnt;
+u32 overfull_lock_cnt;
+u32 policy_lock_cnt;
+
+static ssize_t xradio_bh_statistic(struct file *file,
+	char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *hw_priv = file->private_data;
+	char buf[512];
+	size_t size = 0;
+	sprintf(buf, "irq_count=%u, rx_total=%u, rx_miss=%u, "
+		"rx_fix=%u, rx_next=%u, rx_burst=%d, irq/rx=%u%%\n"
+		"tx_total=%u, tx_burst=%d, tx_limit=%u, tx_buf_limit=%u, "
+		"limit/tx=%u%%, buf_limit/limit=%u%%, tx_rx_idle=%u, bh_idle=%u\n"
+		"queue_lock_cnt=%u, overfull_lock_cnt=%u, policy_lock_cnt=%u\n",
+		irq_count, rx_total_cnt, int_miss_cnt, fix_miss_cnt,
+		next_rx_cnt, hw_priv->debug->rx_burst,
+		(rx_total_cnt ? irq_count*100/rx_total_cnt : 0),
+		tx_total_cnt, hw_priv->debug->tx_burst, tx_limit, tx_buf_limit,
+		(tx_total_cnt ? tx_limit*100/tx_total_cnt : 0),
+		(tx_limit ? tx_buf_limit*100/tx_limit : 0),
+		tx_rx_idle, bh_idle, queue_lock_cnt, overfull_lock_cnt,
+		policy_lock_cnt);
+	size = strlen(buf);
+
+	/*clear counters*/
+	irq_count    = 0;
+	int_miss_cnt = 0;
+	fix_miss_cnt = 0;
+	next_rx_cnt  = 0;
+	rx_total_cnt = 0;
+	tx_total_cnt = 0;
+	tx_buf_limit = 0;
+	tx_limit     = 0;
+	tx_rx_idle   = 0;
+	bh_idle      = 0;
+	queue_lock_cnt = 0;
+	overfull_lock_cnt = 0;
+	policy_lock_cnt = 0;
+	hw_priv->debug->rx_burst = 0;
+	hw_priv->debug->tx_burst = 0;
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, size);
+}
+
+static const struct file_operations fops_bh_stat = {
+	.open = xradio_generic_open,
+	.read = xradio_bh_statistic,
+	.llseek = default_llseek,
+};
+
+/* time info of bh tx and rx */
+#if PERF_INFO_TEST
+static inline void perf_info_reset(struct perf_info *info)
+{
+	memset(info, 0, sizeof(struct perf_info));
+	info->min_time = (u32)-1;
+}
+struct perf_info data_tx;
+struct perf_info data_rx;
+struct perf_info bh_others;
+struct perf_info bh_wait;
+struct perf_info sdio_reg;
+struct perf_info prepare_tx;
+struct perf_info sdio_write;
+struct perf_info dev_wake;
+struct perf_info prepare_rx;
+struct perf_info sdio_read;
+struct perf_info handle_rx;
+
+#ifdef BH_PROC_THREAD
+struct perf_info get_item;
+struct perf_info wake_proc;
+struct perf_info proc_rx;
+struct perf_info proc_tx;
+struct perf_info proc_wait;
+#endif
+struct perf_info ind_rx;
+struct perf_info mac_rx;
+struct perf_info mac_tx;
+
+#if TEST_GETTIME
+struct perf_info get_time;
+#endif
+
+struct timeval last_showtime;
+static inline u32 xradio_show_intv(struct timeval *showtime)
+{
+	u32 time_int;
+	struct timeval time_now;
+	xr_do_gettimeofday(&time_now);
+	time_int = (time_now.tv_sec - showtime->tv_sec) * 100000 + \
+			    (time_now.tv_usec - showtime->tv_usec) / 10;
+	xr_do_gettimeofday(showtime);
+	return time_int; /*10us*/
+}
+/*mac(26) + IV(8) + LLC(8) + IP(20) + TCP(20) or UDP(8)*/
+#define TX_OVERHEAD (sizeof(struct wsm_tx)+26+8+20+20)
+#define RX_OVERHEAD (12+26+8+20+20)
+static int xradio_perf_info(struct seq_file *seq, void *v)
+{
+	/* struct xradio_common *hw_priv = seq->private; */
+	u32 time_int = xradio_show_intv(&last_showtime);
+	u32 txrx_time = data_tx.totaltime + data_rx.totaltime;
+	u32 real_tx = (data_tx.totalsize<<3)/107*10;
+	u32 real_rx = (data_rx.totalsize<<3)/106*10;
+	if (bh_others.totaltime > bh_wait.totaltime)
+		txrx_time += (bh_others.totaltime - bh_wait.totaltime);
+	else
+		txrx_time += sdio_reg.totaltime;
+
+
+#define PUT_PERF_INFO(tab, name) \
+	seq_printf(seq, "%s" tab "%d\t%d\t%d\t%d\t%d\t%d\t%d.%d\t%d.%02d%%\n", #name, \
+	name.count, name.totaltime, (name.totalsize>>3), name.min_time, name.max_time, \
+	name.count ? (name.totaltime/name.count) : 0, \
+	name.totaltime ? ((name.totalsize<<3)/name.totaltime) : 0, \
+	name.totaltime ? (((name.totalsize<<3)%name.totaltime)*10/name.totaltime) : 0, \
+	time_int ? (name.totaltime*10/time_int) : 0, \
+	time_int ? (((name.totaltime*10)%time_int)*100/time_int) : 0)
+
+	seq_printf(seq, "\nTime_int=%d, Tx=%d.%02dMbps, Rx=%d.%02dMbps, "
+		"RealTx=%d.%02dMbps, RealRx=%d.%02dMbps\n", time_int*10,
+		txrx_time ? ((data_tx.totalsize<<3)/txrx_time) : 0,
+		txrx_time ? ((data_tx.totalsize<<3)%txrx_time)*100/txrx_time : 0,
+		txrx_time ? ((data_rx.totalsize<<3)/txrx_time) : 0,
+		txrx_time ? ((data_rx.totalsize<<3)%txrx_time)*100/txrx_time : 0,
+		time_int ? (real_tx/time_int) : 0,
+		time_int ? (real_tx%time_int)*100/time_int : 0,
+		time_int ? (real_rx/time_int) : 0,
+		time_int ? (real_rx%time_int)*100/time_int : 0);
+	seq_printf(seq, "Items\t\tcnt\ttime\tsize(8)\tmin\tmax\tavg\tperf(M)\tduty\n");
+	PUT_PERF_INFO("\t\t", data_tx);
+	PUT_PERF_INFO("\t\t", data_rx);
+	PUT_PERF_INFO("\t\t", bh_wait);
+	PUT_PERF_INFO("\t",   sdio_reg);
+	PUT_PERF_INFO("\t",   prepare_tx);
+	PUT_PERF_INFO("\t",   sdio_write);
+	PUT_PERF_INFO("\t",   dev_wake);
+	PUT_PERF_INFO("\t",   prepare_rx);
+	PUT_PERF_INFO("\t",   sdio_read);
+	PUT_PERF_INFO("\t",   handle_rx);
+#ifdef BH_PROC_THREAD
+	PUT_PERF_INFO("\t",   get_item);
+	PUT_PERF_INFO("\t",   wake_proc);
+	PUT_PERF_INFO("\t\t", proc_rx);
+	PUT_PERF_INFO("\t\t", proc_tx);
+	PUT_PERF_INFO("\t",   proc_wait);
+#endif
+	PUT_PERF_INFO("\t\t", ind_rx);
+	PUT_PERF_INFO("\t\t", mac_rx);
+	PUT_PERF_INFO("\t\t", mac_tx);
+	PUT_PERF_INFO("\t",   bh_others);
+
+#if TEST_GETTIME
+	PUT_PERF_INFO("\t", get_time);
+#endif
+
+	seq_printf(seq, "reg_cnt1=%d, reg_cnt2=%d, reg_cnt3=%d, reg_cnt4=%d, "
+		"reg_fail1=%d, reg_fail2=%d\n",
+		sdio_reg_cnt1, sdio_reg_cnt2, sdio_reg_cnt3, sdio_reg_cnt4,
+		sdio_reg_cnt5, sdio_reg_cnt6);
+	seq_printf(seq, "limit_cnt1=%d, limit_cnt2=%d, "
+		"limit_cnt3=%d, limit_cnt4=%d, limit_cnt5=%d, limit_cnt6=%d\n",
+		tx_limit_cnt1, tx_limit_cnt2, tx_limit_cnt3,
+		tx_limit_cnt4, tx_limit_cnt5, tx_limit_cnt6);
+
+#if BH_PROC_DPA
+	seq_printf(seq, "proc_dpa_cnt=%d, proc_up_cnt=%d, proc_down_cnt=%d, prio=%d\n",
+			proc_dpa_cnt, proc_up_cnt, proc_down_cnt, hw_priv->proc.proc_prio);
+	proc_dpa_cnt = 0;
+	proc_up_cnt  = 0;
+	proc_down_cnt = 0;
+#endif
+
+	sdio_reg_cnt1 = 0;
+	sdio_reg_cnt2 = 0;
+	sdio_reg_cnt3 = 0;
+	sdio_reg_cnt4 = 0;
+	sdio_reg_cnt5 = 0;
+	sdio_reg_cnt6 = 0;
+
+	tx_limit_cnt1 = 0;
+	tx_limit_cnt2 = 0;
+	tx_limit_cnt3 = 0;
+	tx_limit_cnt4 = 0;
+	tx_limit_cnt5 = 0;
+	tx_limit_cnt6 = 0;
+
+
+#undef PUT_PERF_INFO
+
+	perf_info_reset(&data_tx);
+	perf_info_reset(&data_rx);
+	perf_info_reset(&bh_wait);
+	perf_info_reset(&sdio_reg);
+	perf_info_reset(&prepare_tx);
+	perf_info_reset(&sdio_write);
+	perf_info_reset(&dev_wake);
+	perf_info_reset(&prepare_rx);
+	perf_info_reset(&sdio_read);
+	perf_info_reset(&handle_rx);
+#ifdef BH_PROC_THREAD
+	perf_info_reset(&get_item);
+	perf_info_reset(&wake_proc);
+	perf_info_reset(&proc_rx);
+	perf_info_reset(&proc_tx);
+	perf_info_reset(&proc_wait);
+#endif
+	perf_info_reset(&ind_rx);
+	perf_info_reset(&mac_rx);
+	perf_info_reset(&mac_tx);
+	perf_info_reset(&bh_others);
+
+#if TEST_GETTIME
+	if (get_time.count > 10000)
+		perf_info_reset(&get_time);
+#endif
+
+	return 0;
+}
+
+static int xradio_perf_info_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, &xradio_perf_info, inode->i_private);
+}
+
+static const struct file_operations fops_perf_info = {
+	.open = xradio_perf_info_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.owner = THIS_MODULE,
+};
+#endif /* #if PERF_INFO_TEST */
+
+
+u32 dbg_txconfirm[32];
+static int xradio_txconfirm_show(struct seq_file *seq, void *v)
+{
+	int i;
+
+	for (i = 0; i < 8; i++) {
+		seq_printf(seq, "Txcfm%d:%d\t", i+1, dbg_txconfirm[i]);
+		seq_printf(seq, "Txcfm%d:%d\t", i+1+8, dbg_txconfirm[i+8]);
+		seq_printf(seq, "Txcfm%d:%d\t", i+1+16, dbg_txconfirm[i+16]);
+		seq_printf(seq, "Txcfm%d:%d\t\n", i+1+24, dbg_txconfirm[i+24]);
+		dbg_txconfirm[i]    = 0;
+		dbg_txconfirm[i+8]  = 0;
+		dbg_txconfirm[i+16] = 0;
+		dbg_txconfirm[i+24] = 0;
+	}
+	return 0;
+}
+
+static int xradio_txconfirm_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, &xradio_txconfirm_show,
+		inode->i_private);
+}
+
+static const struct file_operations fops_txconfirm = {
+	.open = xradio_txconfirm_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.owner = THIS_MODULE,
+};
+
+u32 dbg_tx_delay_min = 0xffffffff;
+u32 dbg_tx_delay_max;
+u32 dbg_tx_media_delay[16];
+void xradio_debug_tx_delay(u32 media_delay, u32 queue_delay)
+{
+	if (media_delay < dbg_tx_delay_min)
+		dbg_tx_delay_min = media_delay;
+	if (media_delay > dbg_tx_delay_max)
+		dbg_tx_delay_max = media_delay;
+	if (media_delay <= 500)
+		dbg_tx_media_delay[0]++;
+	else if (media_delay <= 1000)
+		dbg_tx_media_delay[1]++;
+	else if (media_delay <= 10000)
+		dbg_tx_media_delay[2]++;
+	else if (media_delay <= 20000)
+		dbg_tx_media_delay[3]++;
+	else if (media_delay <= 30000)
+		dbg_tx_media_delay[4]++;
+	else if (media_delay <= 40000)
+		dbg_tx_media_delay[5]++;
+	else if (media_delay <= 50000)
+		dbg_tx_media_delay[6]++;
+	else if (media_delay <= 100000)
+		dbg_tx_media_delay[7]++;
+	else if (media_delay <= 150000)
+		dbg_tx_media_delay[8]++;
+	else if (media_delay <= 200000)
+		dbg_tx_media_delay[9]++;
+	else if (media_delay <= 300000)
+		dbg_tx_media_delay[10]++;
+	else if (media_delay <= 500000)
+		dbg_tx_media_delay[11]++;
+	else if (media_delay <= 1000000)
+		dbg_tx_media_delay[12]++;
+	else if (media_delay <= 3000000)
+		dbg_tx_media_delay[13]++;
+	else if (media_delay <= 15000000)
+		dbg_tx_media_delay[14]++;
+	else
+		xradio_dbg(XRADIO_DBG_WARN, "media_delay=%d, queue_delay=%d\n",
+		   media_delay, queue_delay);
+	if (media_delay >= 30000)
+		xradio_dbg(XRADIO_DBG_NIY, "media_delay=%d, queue_delay=%d\n",
+		   media_delay, queue_delay);
+}
+static int xradio_tx_delay_show(struct seq_file *seq, void *v)
+{
+	seq_printf(seq, "MinDelay %dus, MaxDelay=%dus\n", dbg_tx_delay_min, dbg_tx_delay_max);
+	seq_printf(seq, "Delay (0~0.5ms]   :%d\n", dbg_tx_media_delay[0]);
+	seq_printf(seq, "Delay (0.5~1ms]   :%d\n", dbg_tx_media_delay[1]);
+	seq_printf(seq, "Delay (1~10ms]    :%d\n", dbg_tx_media_delay[2]);
+	seq_printf(seq, "Delay (10~20ms]   :%d\n", dbg_tx_media_delay[3]);
+	seq_printf(seq, "Delay (20~30ms]   :%d\n", dbg_tx_media_delay[4]);
+	seq_printf(seq, "Delay (30~40ms]   :%d\n", dbg_tx_media_delay[5]);
+	seq_printf(seq, "Delay (40~50ms]   :%d\n", dbg_tx_media_delay[6]);
+	seq_printf(seq, "Delay (50~100ms]  :%d\n", dbg_tx_media_delay[7]);
+	seq_printf(seq, "Delay (100~150ms] :%d\n", dbg_tx_media_delay[8]);
+	seq_printf(seq, "Delay (150~200ms] :%d\n", dbg_tx_media_delay[9]);
+	seq_printf(seq, "Delay (200~300ms] :%d\n", dbg_tx_media_delay[10]);
+	seq_printf(seq, "Delay (300~500ms] :%d\n", dbg_tx_media_delay[11]);
+	seq_printf(seq, "Delay (500~1000ms]:%d\n", dbg_tx_media_delay[12]);
+	seq_printf(seq, "Delay (1~3s]      :%d\n", dbg_tx_media_delay[13]);
+	seq_printf(seq, "Delay (3~15s]     :%d\n", dbg_tx_media_delay[14]);
+
+	dbg_tx_delay_min = 0xffffffff;
+	dbg_tx_delay_max = 0;
+	memset(dbg_tx_media_delay, 0, sizeof(dbg_tx_media_delay));
+	return 0;
+}
+
+static int xradio_tx_delay_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, &xradio_tx_delay_show,
+		inode->i_private);
+}
+
+static const struct file_operations fops_txdelay = {
+	.open = xradio_tx_delay_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.owner = THIS_MODULE,
+};
+
+/*for disable low power mode.*/
+extern u16 txparse_flags;
+extern u16 rxparse_flags;
+static ssize_t xradio_parse_flags_get(struct file *file,
+	char __user *user_buf, size_t count, loff_t *ppos)
+{
+	/*struct xradio_common *hw_priv = file->private_data;*/
+	char buf[100];
+	size_t size = 0;
+
+	sprintf(buf, "txparse=0x%04x, rxparse=0x%04x\n",
+		txparse_flags, rxparse_flags);
+	size = strlen(buf);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, size);
+}
+
+static ssize_t xradio_parse_flags_set(struct file *file,
+				      const char __user *user_buf,
+				      size_t count, loff_t *ppos)
+{
+	/*struct xradio_common *hw_priv = file->private_data;*/
+	char buf[30] = { 0 };
+	char *start = &buf[0];
+	char *endptr = NULL;
+
+	count = (count > 29 ? 29 : count);
+
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	txparse_flags = simple_strtoul(buf, &endptr, 16);
+	start = endptr + 1;
+	if (start < buf + count)
+		rxparse_flags = simple_strtoul(start, &endptr, 16);
+
+	txparse_flags &= 0x7fff;
+	rxparse_flags &= 0x7fff;
+
+	xradio_dbg(XRADIO_DBG_ALWY, "txparse=0x%04x, rxparse=0x%04x\n",
+		   txparse_flags, rxparse_flags);
+	return count;
+}
+
+static const struct file_operations fops_parse_flags = {
+	.open = xradio_generic_open,
+	.write = xradio_parse_flags_set,
+	.read = xradio_parse_flags_get,
+	.llseek = default_llseek,
+};
+
+#if (DGB_XRADIO_HWT)
+u8 hwt_testing;
+/*HIF TX test*/
+u8 hwt_tx_en;
+u8 hwt_tx_cfm;	/*confirm interval*/
+u16 hwt_tx_len;
+u16 hwt_tx_num;
+struct timeval hwt_start_time = { 0 };
+struct timeval hwt_end_time = { 0 };
+
+int wsm_hwt_cmd(struct xradio_common *hw_priv, void *arg,
+		size_t arg_size);
+
+static ssize_t xradio_hwt_hif_tx(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *hw_priv = file->private_data;
+	char buf[100] = { 0 };
+	char *start = &buf[0];
+	char *endptr = NULL;
+
+	if (hwt_testing) {
+		xradio_dbg(XRADIO_DBG_ALWY, "cmd refuse, hwt is testing!\n");
+		return count;
+	}
+
+	count = (count > 99 ? 99 : count);
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	if (simple_strtoul(start, &endptr, 10)) {
+		start = endptr + 1;
+		if (start < buf + count)
+			hwt_tx_len = simple_strtoul(start, &endptr, 10);
+		start = endptr + 1;
+		if (start < buf + count)
+			hwt_tx_num = simple_strtoul(start, &endptr, 10);
+		start = endptr + 1;
+		if (start < buf + count)
+			hwt_tx_cfm = simple_strtoul(start, &endptr, 10);
+		hwt_tx_en = 1;
+		hwt_testing = 1;
+	} else {
+		hwt_tx_en = 0;
+	}
+	xradio_dbg(XRADIO_DBG_ALWY,
+		   "hwt_tx_en=%d, hwt_tx_len=%d, hwt_tx_num=%d, hwt_tx_cfm=%d\n",
+		   hwt_tx_en, hwt_tx_len, hwt_tx_num, hwt_tx_cfm);
+
+	if (!hw_priv->bh_error &&
+		  atomic_add_return(1, &hw_priv->bh_tx) == 1)
+		wake_up(&hw_priv->bh_wq);
+	return count;
+}
+
+static const struct file_operations fops_hwt_hif_tx = {
+	.open = xradio_generic_open,
+	.write = xradio_hwt_hif_tx,
+	.llseek = default_llseek,
+};
+
+/*HIF RX test*/
+u8 hwt_rx_en;
+u16 hwt_rx_len;
+u16 hwt_rx_num;
+static ssize_t xradio_hwt_hif_rx(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *hw_priv = file->private_data;
+	char buf[100] = { 0 };
+	char *start = &buf[0];
+	char *endptr = NULL;
+
+	if (hwt_testing) {
+		xradio_dbg(XRADIO_DBG_ALWY, "cmd refuse, hwt is testing!\n");
+		return count;
+	}
+
+	count = (count > 99 ? 99 : count);
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	if (simple_strtoul(start, &endptr, 10)) {
+		start = endptr + 1;
+		if (start < buf + count)
+			hwt_rx_len = simple_strtoul(start, &endptr, 10);
+		start = endptr + 1;
+		if (start < buf + count)
+			hwt_rx_num = simple_strtoul(start, &endptr, 10);
+
+		hwt_rx_en = 1;
+	} else {
+		hwt_rx_en = 0;
+	}
+	xradio_dbg(XRADIO_DBG_ALWY,
+		   "hwt_rx_en=%d, hwt_rx_len=%d, hwt_rx_num=%d\n", hwt_rx_en,
+		   hwt_rx_len, hwt_rx_num);
+
+	/*check the parameters.*/
+	if (hwt_rx_len < 100 || hwt_rx_len > 1500)
+		hwt_rx_len = 1500;
+	if (hwt_rx_en && hwt_rx_num) {
+		HWT_PARAMETERS hwt_hdr = {
+			.TestID = 0x0002,
+			.Params = hwt_rx_num,
+			.Data = hwt_rx_len
+		};
+		hwt_testing = 1;
+		wsm_hwt_cmd(hw_priv, (void *)&hwt_hdr.TestID, sizeof(hwt_hdr)-4);
+		xr_do_gettimeofday(&hwt_start_time);
+	}
+
+	return count;
+}
+
+static const struct file_operations fops_hwt_hif_rx = {
+	.open = xradio_generic_open,
+	.write = xradio_hwt_hif_rx,
+	.llseek = default_llseek,
+};
+
+/*ENC test*/
+u8 hwt_enc_type;
+u8 hwt_key_len;
+u16 hwt_enc_len;
+u16 hwt_enc_cnt;
+static ssize_t xradio_hwt_enc(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *hw_priv = file->private_data;
+	char buf[100] = { 0 };
+	char *start = &buf[0];
+	char *endptr = NULL;
+
+	if (hwt_testing) {
+		xradio_dbg(XRADIO_DBG_ALWY, "cmd refuse, hwt is testing!\n");
+		return count;
+	}
+
+	count = (count > 99 ? 99 : count);
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	hwt_enc_type = simple_strtoul(start, &endptr, 10);
+	start = endptr + 1;
+	if (start < buf + count)
+		hwt_key_len = simple_strtoul(start, &endptr, 10);
+	start = endptr + 1;
+	if (start < buf + count)
+		hwt_enc_len = simple_strtoul(start, &endptr, 10);
+	start = endptr + 1;
+	if (start < buf + count)
+		hwt_enc_cnt = simple_strtoul(start, &endptr, 10);
+
+	xradio_dbg(XRADIO_DBG_ALWY,
+		   "enc_type=%d, key_len=%d, enc_len=%d, enc_cnt=%d\n",
+		   hwt_enc_type, hwt_key_len, hwt_enc_len, hwt_enc_cnt);
+
+	/*check the parameters.*/
+	if (hwt_enc_type < 10 && hwt_key_len <= 16 &&
+		hwt_enc_len <= 1500 && hwt_enc_cnt > 0) {
+		HWT_PARAMETERS hwt_hdr = {
+			.TestID  = 0x0003,
+			.Params  = (hwt_key_len<<8) | hwt_enc_type,
+			.Datalen = hwt_enc_len,
+			.Data    = hwt_enc_cnt
+		};
+		hwt_testing = 1;
+		wsm_hwt_cmd(hw_priv, (void *)&hwt_hdr.TestID, sizeof(hwt_hdr)-4);
+	}
+
+	return count;
+}
+
+static const struct file_operations fops_hwt_enc = {
+	.open = xradio_generic_open,
+	.write = xradio_hwt_enc,
+	.llseek = default_llseek,
+};
+
+/*MIC test*/
+u16 hwt_mic_len;
+u16 hwt_mic_cnt;
+static ssize_t xradio_hwt_mic(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *hw_priv = file->private_data;
+	char buf[100] = { 0 };
+	char *start = &buf[0];
+	char *endptr = NULL;
+
+	if (hwt_testing) {
+		xradio_dbg(XRADIO_DBG_ALWY, "cmd refuse, hwt is testing!\n");
+		return count;
+	}
+
+	count = (count > 99 ? 99 : count);
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	hwt_mic_len = simple_strtoul(start, &endptr, 10);
+	start = endptr + 1;
+	if (start < buf + count)
+		hwt_mic_cnt = simple_strtoul(start, &endptr, 10);
+
+	xradio_dbg(XRADIO_DBG_ALWY, "mic_len=%d, mic_cnt=%d\n",
+		   hwt_mic_len, hwt_mic_cnt);
+
+	/*check the parameters.*/
+	if (hwt_mic_len <= 1500 && hwt_mic_cnt > 0) {
+		HWT_PARAMETERS hwt_hdr = {
+			.TestID = 0x0004,
+			.Params = 0,
+			.Datalen = hwt_mic_len,
+			.Data = hwt_mic_cnt
+		};
+		hwt_testing = 1;
+		wsm_hwt_cmd(hw_priv, (void *)&hwt_hdr.TestID, sizeof(hwt_hdr)-4);
+	}
+
+	return count;
+}
+
+static const struct file_operations fops_hwt_mic = {
+	.open = xradio_generic_open,
+	.write = xradio_hwt_mic,
+	.llseek = default_llseek,
+};
+
+static ssize_t xradio_hwt_hif_rx_burn(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *hw_priv = file->private_data;
+	char buf[100] = { 0 };
+	char *start = &buf[0];
+	char *endptr = NULL;
+
+	u16 hw_inf_cmd = 0;
+
+	HWT_PARAMETERS hwt_hdr = {
+		.TestID = 0x0005,
+		.Params = hw_inf_cmd,
+		.Data = 10000
+	};
+
+
+	count = (count > 99 ? 99 : count);
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+
+	hw_inf_cmd = simple_strtoul(start, &endptr, 10);
+
+	xradio_dbg(XRADIO_DBG_ALWY, "hw_inf_cmd=%d\n", hw_inf_cmd);
+
+	hwt_hdr.Params = hw_inf_cmd;
+
+	wsm_hwt_cmd(hw_priv, (void *)&hwt_hdr.TestID, sizeof(hwt_hdr)-4);
+
+	return count;
+}
+
+static const struct file_operations fops_hwt_hif_rx_burn = {
+	.open = xradio_generic_open,
+	.write = xradio_hwt_hif_rx_burn,
+	.llseek = default_llseek,
+};
+
+#endif /*DGB_XRADIO_HWT*/
+
+static u32 measure_type;
+
+static ssize_t xradio_measure_type_write(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *hw_priv = file->private_data;
+	char buf[12] = { 0 };
+	char *endptr = NULL;
+	count = (count > 11 ? 11 : count);
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+	measure_type = simple_strtoul(buf, &endptr, 16);
+
+	xradio_dbg(XRADIO_DBG_ALWY, "measure_type = %08x\n", measure_type);
+	SYS_WARN(wsm_11k_measure_requset(hw_priv, (measure_type & 0xff),
+					 ((measure_type & 0xff00) >> 8),
+					 ((measure_type & 0xffff0000) >> 16)));
+	return count;
+}
+
+static ssize_t xradio_measure_type_read(struct file *file,
+	char __user *user_buf, size_t count, loff_t *ppos)
+{
+	/*struct xradio_common *hw_priv = file->private_data;*/
+	char buf[20];
+	size_t size = 0;
+
+	sprintf(buf, "measure_type = %u\n", measure_type);
+	size = strlen(buf);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, size);
+}
+
+static const struct file_operations fops_11k = {
+	.open = xradio_generic_open,
+	.write = xradio_measure_type_write,
+	.read = xradio_measure_type_read,
+	.llseek = default_llseek,
+};
+
+static ssize_t xradio_wsm_dumps(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *hw_priv = file->private_data;
+	char buf[1];
+
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, 1))
+		return -EFAULT;
+
+	if (buf[0] == '1')
+		hw_priv->wsm_enable_wsm_dumps = 1;
+	else
+		hw_priv->wsm_enable_wsm_dumps = 0;
+
+	return count;
+}
+
+static const struct file_operations fops_wsm_dumps = {
+	.open = xradio_generic_open,
+	.write = xradio_wsm_dumps,
+	.llseek = default_llseek,
+};
+
+static ssize_t xradio_short_dump_read(struct file *file,
+	char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *hw_priv = file->private_data;
+	char buf[20];
+	size_t size = 0;
+
+	sprintf(buf, "Size: %u\n", hw_priv->wsm_dump_max_size);
+	size = strlen(buf);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, size);
+}
+
+static ssize_t xradio_short_dump_write(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *priv = file->private_data;
+	char buf[20];
+	unsigned long dump_size = 0;
+
+	if (!count || count > 20)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	if (kstrtoul(buf, 10, &dump_size))
+		return -EINVAL;
+	xradio_dbg(XRADIO_DBG_ALWY, "%s get %lu\n", __func__, dump_size);
+
+	priv->wsm_dump_max_size = dump_size;
+
+	return count;
+}
+
+static const struct file_operations fops_short_dump = {
+	.open = xradio_generic_open,
+	.write = xradio_short_dump_write,
+	.read = xradio_short_dump_read,
+	.llseek = default_llseek,
+};
+
+#ifdef SUPPORT_HT40
+
+static int xradio_status_show_priv(struct seq_file *seq, void *v)
+{
+	int i;
+	struct xradio_vif *priv = seq->private;
+	struct xradio_debug_priv *d = priv->debug;
+
+	seq_printf(seq, "Mode:       %s%s\n",
+		xradio_debug_mode(priv->mode),
+		priv->listening ? " (listening)" : "");
+	seq_printf(seq, "Assoc:      %s\n",
+		xradio_debug_join_status[priv->join_status]);
+	if (priv->rx_filter.promiscuous)
+		seq_puts(seq, "Filter:     promisc\n");
+	else if (priv->rx_filter.fcs)
+		seq_puts(seq, "Filter:     fcs\n");
+	if (priv->rx_filter.bssid)
+		seq_puts(seq, "Filter:     bssid\n");
+	if (priv->bf_control.bcn_count)
+		seq_puts(seq, "Filter:     beacons\n");
+
+	if (priv->enable_beacon ||
+	    priv->mode == NL80211_IFTYPE_AP ||
+	    priv->mode == NL80211_IFTYPE_ADHOC ||
+	    priv->mode == NL80211_IFTYPE_MESH_POINT ||
+	    priv->mode == NL80211_IFTYPE_P2P_GO)
+		seq_printf(seq, "Beaconing:  %s\n",
+			   priv->enable_beacon ? "enabled" : "disabled");
+	if (priv->ssid_length ||
+	    priv->mode == NL80211_IFTYPE_AP ||
+	    priv->mode == NL80211_IFTYPE_ADHOC ||
+	    priv->mode == NL80211_IFTYPE_MESH_POINT ||
+	    priv->mode == NL80211_IFTYPE_P2P_GO)
+		seq_printf(seq, "SSID:       %.*s\n",
+			   (int)priv->ssid_length, priv->ssid);
+
+	for (i = 0; i < 4; ++i) {
+		seq_printf(seq, "EDCA(%d):    %d, %d, %d, %d, %d\n", i,
+			   priv->edca.params[i].cwMin,
+			   priv->edca.params[i].cwMax,
+			   priv->edca.params[i].aifns,
+			   priv->edca.params[i].txOpLimit,
+			   priv->edca.params[i].maxReceiveLifetime);
+	}
+	if (priv->join_status == XRADIO_JOIN_STATUS_STA) {
+		static const char *pmMode = "unknown";
+		switch (priv->powersave_mode.pmMode) {
+		case WSM_PSM_ACTIVE:
+			pmMode = "off";
+			break;
+		case WSM_PSM_PS:
+			pmMode = "on";
+			break;
+		case WSM_PSM_FAST_PS:
+			pmMode = "dynamic";
+			break;
+		}
+		seq_printf(seq, "Preamble:   %s\n",
+			xradio_debug_preamble[
+			priv->association_mode.PhyModeCfg.PreambleCfg]);
+		seq_printf(seq, "AMPDU spcn: %d\n",
+			priv->association_mode.mpduStartSpacing);
+		seq_printf(seq, "Basic rate: 0x%.8X\n",
+			le32_to_cpu(priv->association_mode.basicRateSet));
+		seq_printf(seq, "Bss lost:   %d beacons\n",
+			priv->bss_params.beaconLostCount);
+		seq_printf(seq, "AID:        %d\n",
+			priv->bss_params.aid);
+		seq_printf(seq, "Rates:      0x%.8X\n",
+			priv->bss_params.operationalRateSet);
+		seq_printf(seq, "Powersave:  %s\n", pmMode);
+	}
+	seq_printf(seq, "RSSI thold: %d\n",
+		priv->cqm_rssi_thold);
+	seq_printf(seq, "RSSI hyst:  %d\n",
+		priv->cqm_rssi_hyst);
+	seq_printf(seq, "TXFL thold: %d\n",
+		priv->cqm_tx_failure_thold);
+	seq_printf(seq, "Linkloss:   %d\n",
+		priv->cqm_link_loss_count);
+	seq_printf(seq, "Bcnloss:    %d\n",
+		priv->cqm_beacon_loss_count);
+
+	xradio_debug_print_map(seq, priv, "Link map:   ",
+		priv->link_id_map);
+	xradio_debug_print_map(seq, priv, "Asleep map: ",
+		priv->sta_asleep_mask);
+	xradio_debug_print_map(seq, priv, "PSPOLL map: ",
+		priv->pspoll_mask);
+
+	seq_puts(seq, "\n");
+
+	for (i = 0; i < MAX_STA_IN_AP_MODE; ++i) {
+		if (priv->link_id_db[i].status) {
+			seq_printf(seq, "Link %d:     %s, %pM\n",
+				i + 1, xradio_debug_link_id[
+				priv->link_id_db[i].status],
+				priv->link_id_db[i].mac);
+		}
+	}
+
+	seq_puts(seq, "\n");
+
+	seq_printf(seq, "Powermgmt:  %s\n",
+		priv->powersave_enabled ? "on" : "off");
+
+	seq_printf(seq, "TXed:       %d\n",
+		d->tx);
+	seq_printf(seq, "AGG TXed:   %d\n",
+		d->tx_agg);
+	seq_printf(seq, "MULTI TXed: %d (%d)\n",
+		d->tx_multi, d->tx_multi_frames);
+	seq_printf(seq, "RXed:       %d\n",
+		d->rx);
+	seq_printf(seq, "AGG RXed:   %d\n",
+		d->rx_agg);
+	seq_printf(seq, "TX align:   %d\n",
+		d->tx_align);
+	seq_printf(seq, "TX TTL:     %d\n",
+		d->tx_ttl);
+	return 0;
+}
+
+#else
+
+static int xradio_status_show_priv(struct seq_file *seq, void *v)
+{
+	int i;
+	struct xradio_vif *priv = seq->private;
+	struct xradio_debug_priv *d = priv->debug;
+
+	seq_printf(seq, "Mode:       %s%s\n",
+		xradio_debug_mode(priv->mode),
+		priv->listening ? " (listening)" : "");
+	seq_printf(seq, "Assoc:      %s\n",
+		xradio_debug_join_status[priv->join_status]);
+	if (priv->rx_filter.promiscuous)
+		seq_puts(seq, "Filter:     promisc\n");
+	else if (priv->rx_filter.fcs)
+		seq_puts(seq, "Filter:     fcs\n");
+	if (priv->rx_filter.bssid)
+		seq_puts(seq, "Filter:     bssid\n");
+	if (priv->bf_control.bcn_count)
+		seq_puts(seq, "Filter:     beacons\n");
+
+	if (priv->enable_beacon ||
+	    priv->mode == NL80211_IFTYPE_AP ||
+	    priv->mode == NL80211_IFTYPE_ADHOC ||
+	    priv->mode == NL80211_IFTYPE_MESH_POINT ||
+	    priv->mode == NL80211_IFTYPE_P2P_GO)
+		seq_printf(seq, "Beaconing:  %s\n",
+			   priv->enable_beacon ? "enabled" : "disabled");
+	if (priv->ssid_length ||
+	    priv->mode == NL80211_IFTYPE_AP ||
+	    priv->mode == NL80211_IFTYPE_ADHOC ||
+	    priv->mode == NL80211_IFTYPE_MESH_POINT ||
+	    priv->mode == NL80211_IFTYPE_P2P_GO)
+		seq_printf(seq, "SSID:       %.*s\n",
+			   (int)priv->ssid_length, priv->ssid);
+
+	for (i = 0; i < 4; ++i) {
+		seq_printf(seq, "EDCA(%d):    %d, %d, %d, %d, %d\n", i,
+			   priv->edca.params[i].cwMin,
+			   priv->edca.params[i].cwMax,
+			   priv->edca.params[i].aifns,
+			   priv->edca.params[i].txOpLimit,
+			   priv->edca.params[i].maxReceiveLifetime);
+	}
+	if (priv->join_status == XRADIO_JOIN_STATUS_STA) {
+		static const char *pmMode = "unknown";
+		switch (priv->powersave_mode.pmMode) {
+		case WSM_PSM_ACTIVE:
+			pmMode = "off";
+			break;
+		case WSM_PSM_PS:
+			pmMode = "on";
+			break;
+		case WSM_PSM_FAST_PS:
+			pmMode = "dynamic";
+			break;
+		}
+		seq_printf(seq, "Preamble:   %s\n",
+			xradio_debug_preamble[
+			priv->association_mode.preambleType]);
+		seq_printf(seq, "AMPDU spcn: %d\n",
+			   priv->association_mode.mpduStartSpacing);
+		seq_printf(seq, "Basic rate: 0x%.8X\n",
+			   le32_to_cpu(priv->association_mode.basicRateSet));
+		seq_printf(seq, "Bss lost:   %d beacons\n",
+			   priv->bss_params.beaconLostCount);
+		seq_printf(seq, "AID:        %d\n", priv->bss_params.aid);
+		seq_printf(seq, "Rates:      0x%.8X\n",
+			   priv->bss_params.operationalRateSet);
+		seq_printf(seq, "Powersave:  %s\n", pmMode);
+	}
+	seq_printf(seq, "RSSI thold: %d\n", priv->cqm_rssi_thold);
+	seq_printf(seq, "RSSI hyst:  %d\n", priv->cqm_rssi_hyst);
+	seq_printf(seq, "TXFL thold: %d\n", priv->cqm_tx_failure_thold);
+	seq_printf(seq, "Linkloss:   %d\n", priv->cqm_link_loss_count);
+	seq_printf(seq, "Bcnloss:    %d\n", priv->cqm_beacon_loss_count);
+
+	xradio_debug_print_map(seq, priv, "Link map:   ", priv->link_id_map);
+	xradio_debug_print_map(seq, priv, "Asleep map: ",
+			       priv->sta_asleep_mask);
+	xradio_debug_print_map(seq, priv, "PSPOLL map: ", priv->pspoll_mask);
+
+	seq_puts(seq, "\n");
+
+	for (i = 0; i < MAX_STA_IN_AP_MODE; ++i) {
+		if (priv->link_id_db[i].status) {
+			seq_printf(seq, "Link %d:     %s, %pM\n",
+				i + 1, xradio_debug_link_id[
+				priv->link_id_db[i].status],
+				priv->link_id_db[i].mac);
+		}
+	}
+
+	seq_puts(seq, "\n");
+
+	seq_printf(seq, "Powermgmt:  %s\n",
+		priv->powersave_enabled ? "on" : "off");
+
+	seq_printf(seq, "TXed:       %d\n", d->tx);
+	seq_printf(seq, "AGG TXed:   %d\n", d->tx_agg);
+	seq_printf(seq, "MULTI TXed: %d (%d)\n",
+		   d->tx_multi, d->tx_multi_frames);
+	seq_printf(seq, "RXed:       %d\n", d->rx);
+	seq_printf(seq, "AGG RXed:   %d\n", d->rx_agg);
+	seq_printf(seq, "TX align:   %d\n", d->tx_align);
+	seq_printf(seq, "TX TTL:     %d\n", d->tx_ttl);
+	return 0;
+}
+
+#endif
+
+static int xradio_status_open_priv(struct inode *inode,
+			struct file *file)
+{
+	return single_open(file, &xradio_status_show_priv, inode->i_private);
+}
+
+static const struct file_operations fops_status_priv = {
+	.open = xradio_status_open_priv,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.owner = THIS_MODULE,
+};
+
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+
+static ssize_t xradio_hang_write(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_vif *priv = file->private_data;
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	char buf[1];
+
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, 1))
+		return -EFAULT;
+
+	if (priv->vif) {
+#ifdef CONFIG_PM
+		xradio_pm_stay_awake(&hw_priv->pm_state, 3 * HZ);
+#endif
+
+		wsm_send_deauth_to_self(hw_priv, priv);
+
+		/* ieee80211_driver_hang_notify(priv->vif, GFP_KERNEL); */
+	} else
+		return -ENODEV;
+
+	return count;
+}
+
+static const struct file_operations fops_hang = {
+	.open = xradio_generic_open,
+	.write = xradio_hang_write,
+	.llseek = default_llseek,
+};
+#endif
+
+#ifdef AP_HT_COMPAT_FIX
+extern u8 ap_compat_bssid[ETH_ALEN];
+static ssize_t xradio_ht_compat_show(struct file *file,
+	char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_vif *priv = file->private_data;
+	char buf[100];
+	size_t size = 0;
+	sprintf(buf, "ht_compat_det=0x%x, BSSID=%02x:%02x:%02x:%02x:%02x:%02x\n",
+		priv->ht_compat_det,
+		ap_compat_bssid[0], ap_compat_bssid[1],
+		ap_compat_bssid[2], ap_compat_bssid[3],
+		ap_compat_bssid[4], ap_compat_bssid[5]);
+	size = strlen(buf);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, size);
+}
+
+static ssize_t xradio_ht_compat_disalbe(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_vif *priv = file->private_data;
+	char buf[2];
+	char *endptr = NULL;
+
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, 2))
+		return -EFAULT;
+
+	if (simple_strtoul(buf, &endptr, 10))
+		priv->ht_compat_det |= 0x10;
+	else
+		priv->ht_compat_det &= ~0x10;
+	return count;
+}
+
+static const struct file_operations fops_ht_compat_dis = {
+	.open = xradio_generic_open,
+	.read = xradio_ht_compat_show,
+	.write = xradio_ht_compat_disalbe,
+	.llseek = default_llseek,
+};
+#endif
+
+#define VIF_DEBUGFS_NAME_S 10
+int xradio_debug_init_priv(struct xradio_common *hw_priv,
+			   struct xradio_vif *priv)
+{
+	int ret = -ENOMEM;
+	struct xradio_debug_priv *d;
+	char name[VIF_DEBUGFS_NAME_S];
+	xradio_dbg(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (SYS_WARN(!hw_priv))
+		return ret;
+
+	if (SYS_WARN(!hw_priv->debug))
+		return ret;
+
+	d = xr_kzalloc(sizeof(struct xradio_debug_priv), false);
+	priv->debug = d;
+	if (SYS_WARN(!d))
+		return ret;
+
+	memset(name, 0, VIF_DEBUGFS_NAME_S);
+	ret = snprintf(name, VIF_DEBUGFS_NAME_S, "vif_%d", priv->if_id);
+	if (SYS_WARN(ret < 0))
+		goto err;
+
+	d->debugfs_phy = debugfs_create_dir(name,
+					    hw_priv->debug->debugfs_phy);
+	if (SYS_WARN(!d->debugfs_phy))
+		goto err;
+
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+	if (SYS_WARN(!debugfs_create_file("hang", S_IWUSR, d->debugfs_phy,
+			priv, &fops_hang)))
+		goto err;
+#endif
+
+#if defined(AP_HT_COMPAT_FIX)
+	if (SYS_WARN(!debugfs_create_file("htcompat_disable",
+			 S_IWUSR, d->debugfs_phy, priv, &fops_ht_compat_dis)))
+		goto err;
+#endif
+
+	if (!debugfs_create_file("status", S_IRUSR, d->debugfs_phy,
+			priv, &fops_status_priv))
+		goto err;
+
+	return 0;
+err:
+	priv->debug = NULL;
+	debugfs_remove_recursive(d->debugfs_phy);
+	kfree(d);
+	return ret;
+
+}
+
+void xradio_debug_release_priv(struct xradio_vif *priv)
+{
+	struct xradio_debug_priv *d = priv->debug;
+	xradio_dbg(XRADIO_DBG_TRC, "%s\n", __func__);
+	if (d) {
+		priv->debug = NULL;
+		debugfs_remove_recursive(d->debugfs_phy);
+		kfree(d);
+	}
+}
+
+int xradio_print_fw_version(struct xradio_common *hw_priv,
+				u8 *buf, size_t len)
+{
+	return snprintf(buf, len, "%s %d.%d",
+			xradio_debug_fw_types[hw_priv->wsm_caps.firmwareType],
+			hw_priv->wsm_caps.firmwareVersion,
+			hw_priv->wsm_caps.firmwareBuildNumber);
+}
+#if (SUPPORT_EPTA)
+static const struct file_operations fops_epta_stat_dbg_ctrl = {
+	.open = xradio_generic_open,
+	.write = xradio_epta_stat_dbg_write,
+	.read = xradio_epta_stat_dbg_read,
+	.llseek = default_llseek,
+};
+#endif
+
+#if (DBG_XRADIO_HIF)
+
+static ssize_t xradio_hif_test_write(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char buf[50] = {0};
+	char *start = &buf[0];
+	char *endptr = NULL;
+
+	count = (count > 50 ? 50 : count);
+
+	printk(KERN_ERR"set value\n");
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+	hif_test_rw = simple_strtoul(start, &endptr, 16);
+	start = endptr + 1;
+
+	if (start < buf + count)
+		hif_test_data_mode = simple_strtoul(start, &endptr, 16);
+
+	start = endptr + 1;
+	if (start < buf + count)
+		hif_test_data_len = simple_strtoul(start, &endptr, 16);
+
+	start = endptr + 1;
+	if (start < buf + count)
+		hif_test_data_round = simple_strtoul(start, &endptr, 16);
+
+	start = endptr + 1;
+	if (start < buf + count)
+		hif_test_oper_delta = simple_strtoul(start, &endptr, 16);
+
+	xradio_dbg(XRADIO_DBG_ALWY, "[HIF test] configuration %s, val is 0x%x, "
+		"round is %u, data size is %u per round delay %u ms per round\n",
+		hif_test_rw ? (hif_test_rw > 1 ? "R & W" : "W") : "Not Test",
+		hif_test_data_round,
+		hif_test_data_mode,
+		hif_test_data_len*4,
+		hif_test_oper_delta);
+	return count;
+}
+
+static ssize_t xradio_hif_test_read(struct file *file,
+	char __user *user_buf, size_t count, loff_t *ppos)
+{
+	/* struct xradio_common *hw_priv = file->private_data;
+	char buf[50];
+	size_t size = 0;
+
+	sprintf(buf, "fwdbg_ctrl = %u\n", fwdbg_ctrl);
+	size = strlen(buf);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, size);
+	 */
+	return 0;
+}
+static const struct file_operations fops_hif_test = {
+	.open = xradio_generic_open,
+	.write = xradio_hif_test_write,
+	.read = xradio_hif_test_read,
+	.llseek = default_llseek,
+};
+
+#endif
+
+#ifdef ERROR_HANG_DRIVER
+void xradio_hang_driver_for_debug(struct xradio_common *hw_priv, int error)
+{
+	int cnt = 0;
+	if (!error_hang_driver || !error)
+		return ; /*do nothing.*/
+
+	if (!hw_priv->debug) { /*have not setup debugfs yet, just do it.*/
+		xradio_debug_init_common(hw_priv);
+	}
+	while (error_hang_driver) {
+		msleep(5000);
+		cnt++;
+		xradio_dbg(XRADIO_DBG_ALWY, "err=%d, hang driver for %ds.\n",
+			error, cnt*5);
+	}
+	xradio_debug_release_common(hw_priv);
+	xradio_dbg(XRADIO_DBG_ALWY, "%s exit.\n", __func__);
+}
+#endif
+
+/*for host debuglevel*/
+struct dentry *debugfs_host;
+#if (DGB_XRADIO_QC)
+struct dentry *debugfs_hwinfo;
+#endif
+int xradio_host_dbg_init(void)
+{
+	int line = 0;
+	xradio_dbg(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (!debugfs_initialized()) {
+		xradio_dbg(XRADIO_DBG_ERROR, "debugfs isnot initialized\n");
+		return 0;
+	}
+#define ERR_LINE  do { line = __LINE__; goto err; } while (0)
+
+	debugfs_host = debugfs_create_dir("xradio_host_dbg", NULL);
+	if (!debugfs_host)
+		ERR_LINE;
+
+	if (!debugfs_create_x8("dbg_common", S_IRUSR | S_IWUSR,
+				   debugfs_host, &dbg_common))
+		ERR_LINE;
+
+	if (!debugfs_create_x8("dbg_sbus", S_IRUSR | S_IWUSR,
+				   debugfs_host, &dbg_sbus))
+		ERR_LINE;
+
+	if (!debugfs_create_x8("dbg_ap", S_IRUSR | S_IWUSR,
+				   debugfs_host, &dbg_ap))
+		ERR_LINE;
+
+	if (!debugfs_create_x8("dbg_sta", S_IRUSR | S_IWUSR,
+				   debugfs_host, &dbg_sta))
+		ERR_LINE;
+
+	if (!debugfs_create_x8("dbg_scan", S_IRUSR | S_IWUSR,
+				   debugfs_host, &dbg_scan))
+		ERR_LINE;
+
+	if (!debugfs_create_x8("dbg_bh", S_IRUSR | S_IWUSR,
+				   debugfs_host, &dbg_bh))
+		ERR_LINE;
+
+	if (!debugfs_create_x8("dbg_txrx", S_IRUSR | S_IWUSR,
+				   debugfs_host, &dbg_txrx))
+		ERR_LINE;
+
+	if (!debugfs_create_x8("dbg_wsm", S_IRUSR | S_IWUSR,
+				   debugfs_host, &dbg_wsm))
+		ERR_LINE;
+
+	if (!debugfs_create_x8("dbg_pm", S_IRUSR | S_IWUSR,
+				   debugfs_host, &dbg_pm))
+		ERR_LINE;
+
+#ifdef CONFIG_XRADIO_ITP
+	if (!debugfs_create_x8("dbg_itp", S_IRUSR | S_IWUSR,
+				   debugfs_host, &dbg_itp))
+		ERR_LINE;
+#endif
+
+#ifdef CONFIG_XRADIO_ETF
+	if (!debugfs_create_x8("dbg_etf", S_IRUSR | S_IWUSR,
+				   debugfs_host, &dbg_etf))
+		ERR_LINE;
+#endif
+
+	if (!debugfs_create_x8("dbg_logfile", S_IRUSR | S_IWUSR,
+				   debugfs_host, &dbg_logfile))
+		ERR_LINE;
+
+	if (!debugfs_create_x8("dbg_tpa_node", S_IRUSR | S_IWUSR,
+				   debugfs_host, &tpa_node_dbg))
+		ERR_LINE;
+
+	if (!debugfs_create_u32("set_sdio_clk", S_IRUSR | S_IWUSR,
+				   debugfs_host, &dbg_sdio_clk))
+		ERR_LINE;
+
+	if (!debugfs_create_u32("tx_burst_limit", S_IRUSR | S_IWUSR,
+				   debugfs_host, &tx_burst_limit))
+		ERR_LINE;
+
+#ifdef ERROR_HANG_DRIVER
+	if (!debugfs_create_u8("error_hang_driver", S_IRUSR | S_IWUSR,
+				   debugfs_host, &error_hang_driver))
+		ERR_LINE;
+#endif
+
+	return 0;
+
+#undef ERR_LINE
+err:
+	xradio_dbg(XRADIO_DBG_ERROR, "xradio_host_dbg_init failed=%d\n", line);
+	if (debugfs_host)
+		debugfs_remove_recursive(debugfs_host);
+#if (DGB_XRADIO_QC)
+	debugfs_hwinfo = NULL;
+#endif
+	debugfs_host = NULL;
+	return 0;
+}
+
+void xradio_host_dbg_deinit(void)
+{
+	xradio_dbg(XRADIO_DBG_TRC, "%s\n", __func__);
+	if (debugfs_host)
+		debugfs_remove_recursive(debugfs_host);
+#if (DGB_XRADIO_QC)
+	debugfs_hwinfo = NULL;
+#endif
+	debugfs_host = NULL;
+}
+
+int xradio_debug_init_common(struct xradio_common *hw_priv)
+{
+	int ret = -ENOMEM;
+	int line = 0;
+	struct xradio_debug_common *d = NULL;
+	xradio_dbg(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	/*init some debug variables here.*/
+	retry_dbg    = 0;
+	tpa_node_dbg = 0;
+
+#define ERR_LINE  do { line = __LINE__; goto err; } while (0)
+
+	d = xr_kzalloc(sizeof(struct xradio_debug_common), false);
+	hw_priv->debug = d;
+	if (!d) {
+		xradio_dbg(XRADIO_DBG_ERROR, "%s, xr_kzalloc failed!\n", __func__);
+		return ret;
+	}
+
+#ifdef ERROR_HANG_DRIVER
+	d->debugfs_phy = debugfs_create_dir("xradio", NULL);
+#else
+	d->debugfs_phy = debugfs_create_dir("xradio",
+			    hw_priv->hw->wiphy->debugfsdir);
+#endif
+
+	if (!d->debugfs_phy)
+		ERR_LINE;
+
+	if (!debugfs_create_file("version", S_IRUSR, d->debugfs_phy,
+			hw_priv, &fops_version))
+		ERR_LINE;
+
+	if (!debugfs_create_file("status", S_IRUSR, d->debugfs_phy,
+			hw_priv, &fops_status_common))
+		ERR_LINE;
+
+	if (!debugfs_create_file("counters", S_IRUSR, d->debugfs_phy,
+			hw_priv, &fops_counters))
+		ERR_LINE;
+
+	if (!debugfs_create_file("backoff", S_IRUSR, d->debugfs_phy,
+			hw_priv, &fops_backoff))
+		ERR_LINE;
+
+	if (!debugfs_create_file("txpipe", S_IRUSR, d->debugfs_phy,
+			hw_priv, &fops_txpipe))
+		ERR_LINE;
+
+	if (!debugfs_create_file("ampdu", S_IRUSR, d->debugfs_phy,
+			hw_priv, &fops_ampducounters))
+		ERR_LINE;
+
+	if (!debugfs_create_file("ratemap", S_IRUSR, d->debugfs_phy,
+			hw_priv, &fops_ratemap))
+		ERR_LINE;
+
+	if (!debugfs_create_file("dbgstats", S_IRUSR, d->debugfs_phy,
+			hw_priv, &fops_dbgstats))
+		ERR_LINE;
+
+	if (!debugfs_create_file("11n", S_IRUSR | S_IWUSR,
+			d->debugfs_phy, hw_priv, &fops_11n))
+		ERR_LINE;
+
+	if (!debugfs_create_file("wsm_dumps", S_IWUSR, d->debugfs_phy,
+			hw_priv, &fops_wsm_dumps))
+		ERR_LINE;
+
+	if (!debugfs_create_file("set_fwdbg", S_IRUSR | S_IWUSR, d->debugfs_phy,
+			hw_priv, &fops_fwdbg))
+		ERR_LINE;
+
+	if (!debugfs_create_file("rw_fwreg", S_IWUSR, d->debugfs_phy, hw_priv,
+		  &fops_rw_fwreg))
+		ERR_LINE;
+
+	if (!debugfs_create_file("rw_fwreg_direct", S_IWUSR, d->debugfs_phy,
+		  hw_priv, &fops_rw_fwreg_direct))
+		ERR_LINE;
+
+	if (!debugfs_create_file("set_ampdu_len", S_IRUSR | S_IWUSR,
+		  d->debugfs_phy, hw_priv, &fops_ampdu_len))
+		ERR_LINE;
+
+	if (!debugfs_create_file("set_rts_threshold", S_IRUSR | S_IWUSR,
+		  d->debugfs_phy, hw_priv, &fops_rts_threshold))
+		ERR_LINE;
+
+	if (!debugfs_create_file("low_pwr_disable", S_IRUSR | S_IWUSR,
+		  d->debugfs_phy, hw_priv, &fops_low_pwr))
+		ERR_LINE;
+
+	if (!debugfs_create_file("ps_disable", S_IRUSR | S_IWUSR, d->debugfs_phy,
+		  hw_priv, &fops_ps_ctrl))
+		ERR_LINE;
+
+	if (!debugfs_create_file("retry_ctrl", S_IRUSR | S_IWUSR, d->debugfs_phy,
+		  hw_priv, &fops_retry_ctrl))
+		ERR_LINE;
+
+	if (!debugfs_create_file("rates_ctrl", S_IRUSR | S_IWUSR, d->debugfs_phy,
+		  hw_priv, &fops_rates_ctrl))
+		ERR_LINE;
+
+	if (!debugfs_create_file("backoff_ctrl", S_IRUSR | S_IWUSR, d->debugfs_phy,
+		  hw_priv, &fops_backoff_ctrl))
+		ERR_LINE;
+
+	if (!debugfs_create_file("tala_ctrl", S_IRUSR | S_IWUSR, d->debugfs_phy,
+		  hw_priv, &fops_tala_ctrl))
+		ERR_LINE;
+
+	if (!debugfs_create_file("tx_pwr_ctrl", S_IRUSR | S_IWUSR, d->debugfs_phy,
+		  hw_priv, &fops_tx_pwr_ctrl))
+		ERR_LINE;
+
+	if (!debugfs_create_file("tpa_ctrl", S_IRUSR | S_IWUSR, d->debugfs_phy,
+		  hw_priv, &fops_tpa_ctrl))
+		ERR_LINE;
+
+	if (!debugfs_create_file("tpa_debug", S_IRUSR, d->debugfs_phy,
+		  hw_priv, &fops_tpa_debug))
+		ERR_LINE;
+
+	if (!debugfs_create_file("policy_info", S_IRUSR, d->debugfs_phy,
+		  hw_priv, &fops_policy_info))
+		ERR_LINE;
+
+	if (!debugfs_create_file("bh_stat", S_IRUSR, d->debugfs_phy,
+		  hw_priv, &fops_bh_stat))
+		ERR_LINE;
+
+#if PERF_INFO_TEST
+	if (!debugfs_create_file("perf_info", S_IRUSR, d->debugfs_phy,
+		  hw_priv, &fops_perf_info))
+		ERR_LINE;
+#endif
+
+	if (!debugfs_create_file("txconfirm", S_IRUSR, d->debugfs_phy,
+		  hw_priv, &fops_txconfirm))
+		ERR_LINE;
+
+	if (!debugfs_create_file("tx_delay", S_IRUSR, d->debugfs_phy,
+		  hw_priv, &fops_txdelay))
+		ERR_LINE;
+
+	if (!debugfs_create_file("parse_flags", S_IRUSR | S_IWUSR,
+		  d->debugfs_phy, hw_priv, &fops_parse_flags))
+		ERR_LINE;
+
+	if (!debugfs_create_file("set_measure_type", S_IRUSR | S_IWUSR,
+		 d->debugfs_phy, hw_priv, &fops_11k))
+		ERR_LINE;
+
+	if (!debugfs_create_file("wsm_dump_size", S_IRUSR | S_IWUSR,
+		d->debugfs_phy, hw_priv, &fops_short_dump))
+		ERR_LINE;
+
+#if (SUPPORT_EPTA)
+	if (!debugfs_create_file("epta_stat", S_IRUSR, d->debugfs_phy,
+			hw_priv, &fops_epta_stat))
+		ERR_LINE;
+
+	if (!debugfs_create_file("epta_stat_ctrl", S_IRUSR | S_IWUSR, d->debugfs_phy,
+			hw_priv, &fops_epta_stat_dbg_ctrl))
+		ERR_LINE;
+#endif
+
+#if (DGB_XRADIO_HWT)
+	/*hardware test*/
+	if (!debugfs_create_file("hwt_hif_tx", S_IWUSR, d->debugfs_phy,
+		  hw_priv, &fops_hwt_hif_tx))
+		ERR_LINE;
+
+	if (!debugfs_create_file("hwt_hif_rx", S_IWUSR, d->debugfs_phy,
+		  hw_priv, &fops_hwt_hif_rx))
+		ERR_LINE;
+
+	if (!debugfs_create_file("hwt_enc", S_IWUSR, d->debugfs_phy,
+		  hw_priv, &fops_hwt_enc))
+		ERR_LINE;
+
+	if (!debugfs_create_file("hwt_mic", S_IWUSR, d->debugfs_phy,
+		  hw_priv, &fops_hwt_mic))
+		ERR_LINE;
+
+	if (!debugfs_create_file("hwt_hif_rx_burn", S_IWUSR, d->debugfs_phy,
+		hw_priv, &fops_hwt_hif_rx_burn))
+	ERR_LINE;
+
+#endif /*DGB_XRADIO_HWT*/
+
+#if (DGB_XRADIO_QC)
+	/*for QC apk read.*/
+	if (debugfs_host && !debugfs_hwinfo) {
+		debugfs_hwinfo = debugfs_create_file("hwinfo", S_IRUSR | S_IWUSR,
+				debugfs_host, hw_priv, &fops_hwinfo);
+		if (!debugfs_hwinfo)
+			ERR_LINE;
+	}
+
+	if (!debugfs_create_file("temperature", S_IRUSR, d->debugfs_phy,
+		hw_priv, &fops_temperature))
+	ERR_LINE;
+#endif
+	ret = xradio_itp_init(hw_priv);
+	if (ret)
+		ERR_LINE;
+
+#ifdef SUPPORT_FW_DBG_INF
+	xradio_fw_dbg_init(hw_priv);
+#endif
+
+	return 0;
+
+#undef ERR_LINE
+
+err:
+	xradio_dbg(XRADIO_DBG_ERROR,
+		   "xradio_debug_init_common failed=%d\n", line);
+	hw_priv->debug = NULL;
+	debugfs_remove_recursive(d->debugfs_phy);
+	kfree(d);
+	return ret;
+}
+
+void xradio_debug_release_common(struct xradio_common *hw_priv)
+{
+	struct xradio_debug_common *d = hw_priv->debug;
+	xradio_dbg(XRADIO_DBG_TRC, "%s\n", __func__);
+
+#if (DGB_XRADIO_QC)
+	if (debugfs_hwinfo) {
+		debugfs_remove(debugfs_hwinfo);
+		debugfs_hwinfo = NULL;
+	}
+#endif
+	if (d) {
+#ifdef SUPPORT_FW_DBG_INF
+		xradio_fw_dbg_deinit();
+#endif
+		xradio_itp_release(hw_priv);
+		hw_priv->debug = NULL;
+
+#ifdef ERROR_HANG_DRIVER
+		debugfs_remove_recursive(d->debugfs_phy);
+#else
+		/* removed by mac80211, don't remove it again,
+		 * fixed wifi on/off.*/
+		/*
+		 debugfs_remove_recursive(d->debugfs_phy);
+		 */
+#endif
+		kfree(d);
+	}
+}
+
+#define FRAME_TYPE(xx) ieee80211_is_ ## xx(fctl)
+#define FT_MSG_PUT(f, ...) do { \
+	if (flags&f)	\
+		frame_msg += sprintf(frame_msg, __VA_ARGS__); \
+	} while (0)
+
+#define PT_MSG_PUT(f, ...) do { \
+	if (flags&f)	\
+		proto_msg += sprintf(proto_msg, __VA_ARGS__); \
+	} while (0)
+
+#define FRAME_PARSE(f, name) do { \
+	if (FRAME_TYPE(name)) { \
+		FT_MSG_PUT(f, "%s", #name); goto outprint; } \
+	} while (0)
+
+#define IS_FRAME_PRINT (frame_msg != (char *)&framebuf[0])
+#define IS_PROTO_PRINT (proto_msg != (char *)&protobuf[0])
+
+
+char framebuf[512] = { 0 };
+char protobuf[512] = { 0 };
+
+char *p2p_frame_type[] = {
+	"GO Negotiation Request",
+	"GO Negotiation Response",
+	"GO Negotiation Confirmation",
+	"P2P Invitation Request",
+	"P2P Invitation Response",
+	"Device Discoverability Request",
+	"Device Discoverability Response",
+	"Provision Discovery Request",
+	"Provision Discovery Response",
+	"Reserved"
+};
+
+void xradio_parse_frame(u8 *mac_data, u8 iv_len, u16 flags, u8 if_id)
+{
+	char *frame_msg = &framebuf[0];
+	char *proto_msg = &protobuf[0];
+	struct ieee80211_hdr *frame = (struct ieee80211_hdr *)mac_data;
+	u16 fctl = frame->frame_control;
+
+	memset(frame_msg, 0, sizeof(framebuf));
+	memset(proto_msg, 0, sizeof(protobuf));
+
+	if (ieee80211_is_data(fctl)) {
+		u8 machdrlen = ieee80211_hdrlen(fctl);
+		u8 *llc_data = mac_data + machdrlen + iv_len;
+
+		if (ieee80211_is_qos_nullfunc(fctl) ||
+		    ieee80211_is_data_qos(fctl))
+			FT_MSG_PUT(PF_DATA, "QoS");
+		if (ieee80211_is_nullfunc(fctl)) {
+			FT_MSG_PUT(PF_DATA, "NULL(ps=%d)", !!(fctl&IEEE80211_FCTL_PM));
+			goto outprint;
+		}
+		FT_MSG_PUT(PF_DATA, "data(TDFD=%d%d, R=%d, P=%d)",
+			   !!(fctl & IEEE80211_FCTL_TODS),
+			   !!(fctl & IEEE80211_FCTL_FROMDS),
+			   !!(fctl & IEEE80211_FCTL_RETRY),
+			   !!(fctl & IEEE80211_FCTL_PROTECTED));
+
+		if (is_SNAP(llc_data)) {
+			if (is_ip(llc_data)) {
+				u8 *ip_hdr = llc_data + LLC_LEN;
+				u8 *ipaddr_s = ip_hdr + IP_S_ADD_OFF;
+				u8 *ipaddr_d = ip_hdr + IP_D_ADD_OFF;
+				u8 *proto_hdr = ip_hdr + ((ip_hdr[0] & 0xf) << 2);	/*ihl:words*/
+
+				if (is_tcp(llc_data)) {
+					PT_MSG_PUT(PF_TCP,
+						   "TCP%s%s, src=%d, dest=%d, seq=0x%08x, ack=0x%08x",
+					    (proto_hdr[13]&0x01) ? "(S)" : "",
+					    (proto_hdr[13]&0x02) ? "(F)" : "",
+					    (proto_hdr[0]<<8)  | proto_hdr[1],
+					    (proto_hdr[2]<<8)  | proto_hdr[3],
+					    (proto_hdr[4]<<24) | (proto_hdr[5]<<16) |
+					    (proto_hdr[6]<<8)  | proto_hdr[7],
+					    (proto_hdr[8]<<24) | (proto_hdr[9]<<16) |
+					    (proto_hdr[10]<<8) | proto_hdr[11]);
+
+				} else if (is_udp(llc_data)) {
+					if (is_dhcp(llc_data)) {
+						u8 Options_len = BOOTP_OPS_LEN;
+						u32 dhcp_magic  = cpu_to_be32(DHCP_MAGIC);
+						u8 *dhcphdr = proto_hdr + UDP_LEN+UDP_BOOTP_LEN;
+						while (Options_len) {
+							if (*(u32 *)dhcphdr == dhcp_magic)
+								break;
+							dhcphdr++;
+							Options_len--;
+						}
+						PT_MSG_PUT(PF_DHCP, "DHCP, Opt=%d, MsgType=%d",
+							   *(dhcphdr+4), *(dhcphdr+6));
+					} else {
+						PT_MSG_PUT(PF_UDP, "UDP, source=%d, dest=%d",
+							  (proto_hdr[0]<<8) | proto_hdr[1],
+							  (proto_hdr[2]<<8) | proto_hdr[3]);
+					}
+				} else if (is_icmp(llc_data)) {
+					PT_MSG_PUT(PF_ICMP, "ICMP%s%s, Seq=%d",
+						   (8 == proto_hdr[0]) ? "(ping)"  : "",
+						   (0 == proto_hdr[0]) ? "(reply)" : "",
+							(proto_hdr[6]<<8) | proto_hdr[7]);
+				} else if (is_igmp(llc_data)) {
+					PT_MSG_PUT(PF_UNKNWN, "IGMP, type=0x%x", proto_hdr[0]);
+				} else {
+					PT_MSG_PUT(PF_UNKNWN, "unknown IP type=%d",
+						   *(ip_hdr + IP_PROTO_OFF));
+				}
+				if (IS_PROTO_PRINT) {
+					PT_MSG_PUT(PF_IPADDR, "-%d.%d.%d.%d(s)", \
+						   ipaddr_s[0], ipaddr_s[1],
+						   ipaddr_s[2], ipaddr_s[3]);
+					PT_MSG_PUT(PF_IPADDR, "-%d.%d.%d.%d(d)", \
+						   ipaddr_d[0], ipaddr_d[1],
+						   ipaddr_d[2], ipaddr_d[3]);
+				}
+
+			} else if (is_8021x(llc_data)) {
+				PT_MSG_PUT(PF_8021X, "8021X");
+			} else {	/*other protol, no detail.*/
+				switch (cpu_to_be16(*(u16 *)(llc_data+LLC_TYPE_OFF))) {
+				case ETH_P_IPV6:	/*0x08dd*/
+					PT_MSG_PUT(PF_UNKNWN, "IPv6");
+					break;
+				case ETH_P_ARP:	/*0x0806*/
+					PT_MSG_PUT(PF_UNKNWN, "ARP");
+					break;
+				case ETH_P_RARP:	/*0x8035*/
+					PT_MSG_PUT(PF_UNKNWN, "RARP");
+					break;
+				case ETH_P_DNA_RC:	/*0x6002*/
+					PT_MSG_PUT(PF_UNKNWN, "DNA Remote Console");
+					break;
+				case ETH_P_DNA_RT:	/*0x6003*/
+					PT_MSG_PUT(PF_UNKNWN, "DNA Routing");
+					break;
+				case ETH_P_8021Q:	/*0x8100*/
+					PT_MSG_PUT(PF_UNKNWN, "802.1Q VLAN");
+					break;
+				case ETH_P_LINK_CTL:	/*0x886c*/
+					PT_MSG_PUT(PF_UNKNWN, "wlan link local tunnel(HPNA)");
+					break;
+				case ETH_P_PPP_DISC:	/*0x8863*/
+					PT_MSG_PUT(PF_UNKNWN, "PPPoE discovery");
+					break;
+				case ETH_P_PPP_SES:	/*0x8864*/
+					PT_MSG_PUT(PF_UNKNWN, "PPPoE session");
+					break;
+				case ETH_P_MPLS_UC:	/*0x8847*/
+					PT_MSG_PUT(PF_UNKNWN, "MPLS Unicast");
+					break;
+				case ETH_P_MPLS_MC:	/*0x8848*/
+					PT_MSG_PUT(PF_UNKNWN, "MPLS Multicast");
+					break;
+				default:
+					PT_MSG_PUT(PF_UNKNWN, "unknown Ethernet type=0x%04x",
+						   cpu_to_be16(*(u16 *)(llc_data+LLC_TYPE_OFF)));
+					break;
+				}
+			}
+		} else if (is_STP(llc_data)) {
+			/*spanning tree proto.*/
+			PT_MSG_PUT(PF_UNKNWN, "spanning tree");
+		} else {
+			PT_MSG_PUT(PF_UNKNWN, "unknown LLC type=0x%08x, 0x%08x",
+				   *(u32 *)(llc_data), *((u32 *)(llc_data)+1));
+		}
+
+	} else if (ieee80211_is_mgmt(fctl) && (PF_MGMT & flags)) {
+
+		FRAME_PARSE(PF_MGMT, auth);
+		FRAME_PARSE(PF_MGMT, deauth);
+		FRAME_PARSE(PF_MGMT, assoc_req);
+		FRAME_PARSE(PF_MGMT, assoc_resp);
+		FRAME_PARSE(PF_MGMT, reassoc_req);
+		FRAME_PARSE(PF_MGMT, reassoc_resp);
+		FRAME_PARSE(PF_MGMT, disassoc);
+		FRAME_PARSE(PF_MGMT, atim);
+
+		/*for more information about action frames.*/
+		if (FRAME_TYPE(action)) {
+			u8* encrypt_frame = NULL;
+			struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)frame;
+			if (frame->frame_control & __cpu_to_le32(IEEE80211_FCTL_PROTECTED) && (flags & PF_RX))
+			{
+				encrypt_frame = (u8*)frame + IEEE80211_CCMP_256_HDR_LEN;
+				mgmt = (struct ieee80211_mgmt *)encrypt_frame;
+			}
+			FT_MSG_PUT(PF_MGMT, "%s", "action");
+
+			if (mgmt->u.action.category == WLAN_CATEGORY_PUBLIC) {
+				u8 *action = (u8 *) &mgmt->u.action.category;
+				u32 oui = *(u32 *) &action[2];
+				u8 oui_subtype = action[6] > 8 ? 9 : action[6];
+				if (action[1] == 0x09 && oui == 0x099A6F50)
+					FT_MSG_PUT(PF_MGMT, "(%s)", p2p_frame_type[oui_subtype]);
+			} else if (mgmt->u.action.category == WLAN_CATEGORY_BACK &&
+				mgmt->u.action.u.addba_req.action_code ==
+				WLAN_ACTION_ADDBA_REQ) {
+				FT_MSG_PUT(PF_MGMT, "(ADDBA_REQ-%d)",
+					   mgmt->u.action.u.addba_req.start_seq_num);
+			} else if (mgmt->u.action.category == WLAN_CATEGORY_BACK &&
+				mgmt->u.action.u.addba_req.action_code ==
+				WLAN_ACTION_ADDBA_RESP) {
+				FT_MSG_PUT(PF_MGMT, "(ADDBA_RESP-%d)",
+					   mgmt->u.action.u.addba_resp.status);
+			} else if (mgmt->u.action.category == WLAN_CATEGORY_SA_QUERY &&
+				mgmt->u.action.u.sa_query.action ==
+				WLAN_ACTION_SA_QUERY_REQUEST) {
+				FT_MSG_PUT(PF_MGMT, "(SA_Query_Req)");
+			} else if (mgmt->u.action.category == WLAN_CATEGORY_SA_QUERY &&
+				mgmt->u.action.u.sa_query.action ==
+				WLAN_ACTION_SA_QUERY_RESPONSE) {
+				FT_MSG_PUT(PF_MGMT, "(SA_Query_Resp)");
+			} else {
+				FT_MSG_PUT(PF_MGMT, "(%d)", mgmt->u.action.category);
+			}
+			goto outprint;
+		}
+		/*too much scan results, don't print if no need.*/
+		FRAME_PARSE(PF_SCAN, probe_req);
+		FRAME_PARSE(PF_SCAN, probe_resp);
+		FRAME_PARSE(PF_SCAN, beacon);
+		/*must be last.*/
+		FT_MSG_PUT(PF_UNKNWN, "unknown mgmt");
+
+	} else if (ieee80211_is_ctl(fctl) && (PF_CTRL & flags)) {
+
+		flags &= (~PF_MAC_SN);	/*no seq ctrl in ctrl frames.*/
+		FRAME_PARSE(PF_CTRL, back);
+		FRAME_PARSE(PF_CTRL, back_req);
+		FRAME_PARSE(PF_CTRL, ack);
+		FRAME_PARSE(PF_CTRL, rts);
+		FRAME_PARSE(PF_CTRL, cts);
+		FRAME_PARSE(PF_CTRL, pspoll);
+		/*must be last.*/
+		FT_MSG_PUT(PF_UNKNWN, "unknown ctrl");
+	} else {
+		FT_MSG_PUT(PF_UNKNWN, "unknown mac frame, fctl=0x%04x\n", fctl);
+	}
+
+outprint:
+
+	FT_MSG_PUT(PF_MAC_SN, "-SN=%d(%d)",
+		   (frame->seq_ctrl>>4), (frame->seq_ctrl&0xf));
+
+	/*output all msg.*/
+	if (IS_FRAME_PRINT || IS_PROTO_PRINT) {
+		u8 *related = NULL;
+		u8 *own = NULL;
+		char *r_type = NULL;
+		char *o_type = NULL;
+		u8 machdrlen = ieee80211_hdrlen(fctl);
+		u8 *sa = ieee80211_get_SA(frame);
+		u8 *da = ieee80211_get_DA(frame);
+
+		if (flags & PF_RX) {
+			related = frame->addr2;
+			own = frame->addr1;
+			r_type = "TA";
+			o_type = "RA";
+		} else {
+			related = frame->addr1;
+			own = frame->addr2;
+			r_type = "RA";
+			o_type = "TA";
+		}
+
+		if (machdrlen >= 16) {	/*if ACK or BA, don't print.*/
+			FT_MSG_PUT(PF_MACADDR, "-%02x:%02x:%02x:%02x:%02x:%02x(%s)",
+				   related[0], related[1], related[2],
+				   related[3], related[4], related[5],
+				   r_type);
+			FT_MSG_PUT(PF_OWNMAC, "-%02x:%02x:%02x:%02x:%02x:%02x(%s)",
+				   own[0], own[1], own[2], own[3], own[4], own[5],
+				   o_type);
+			FT_MSG_PUT(PF_SA_DA, "-%02x:%02x:%02x:%02x:%02x:%02x(DA)",
+				   da[0], da[1], da[2], da[3], da[4], da[5]);
+			FT_MSG_PUT(PF_SA_DA, "-%02x:%02x:%02x:%02x:%02x:%02x(SA)",
+				   sa[0], sa[1], sa[2], sa[3], sa[4], sa[5]);
+		}
+
+		xradio_dbg(XRADIO_DBG_ALWY, "if%d-%s%s--%s\n", if_id,
+			   (PF_RX & flags) ? "RX-" : "TX-", framebuf, protobuf);
+	}
+}
+
+#undef FT_MSG_PUT
+#undef PT_MSG_PUT
+#undef FRAME_PARSE
+#undef FRAME_TYPE
+
+#if DGB_LOG_FILE
+u8 log_buffer[DGB_LOG_BUF_LEN];
+u16 log_pos;
+struct file *fp_log;
+atomic_t file_ref = { 0 };
+
+#define T_LABEL_LEN  32
+char last_time_label[T_LABEL_LEN] = { 0 };
+
+int xradio_logfile(char *buffer, int buf_len, u8 b_time)
+{
+	int ret = -1;
+	int size = buf_len;
+	mm_segment_t old_fs = get_fs();
+
+	if (!buffer)
+		return ret;
+
+	if (buf_len < 0)
+		size = strlen(buffer);
+	if (!size)
+		return ret;
+
+	if (atomic_add_return(1, &file_ref) == 1) {
+		fp_log = filp_open(DGB_LOG_PATH0, O_CREAT | O_WRONLY, 0666);
+		if (IS_ERR(fp_log)) {
+			printk(KERN_ERR "[XRADIO] ERR, can't open %s(%d).\n",
+			       DGB_LOG_PATH0, (int)fp_log);
+			goto exit;
+		}
+	}
+	/*printk(KERN_ERR "[XRADIO] file_ref=%d\n", atomic_read(&file_ref));*/
+
+	if (fp_log->f_op->write == NULL) {
+		printk(KERN_ERR "[XRADIO] ERR, %s:File is not allow to write!\n",
+		       __func__);
+		goto exit;
+	} else {
+		set_fs(KERNEL_DS);
+		if (fp_log->f_op->llseek != NULL) {
+			vfs_llseek(fp_log, 0, SEEK_END);
+		} else {
+			fp_log->f_pos = 0;
+		}
+		set_fs(old_fs);
+		if (b_time) {
+			struct timeval time_now = { 0 };
+			struct rtc_time tm;
+			char time_label[T_LABEL_LEN] = { 0 };
+			xr_do_gettimeofday(&time_now);
+			time_now.tv_sec -= sys_tz.tz_minuteswest * 60;
+			rtc_time_to_tm(time_now.tv_sec, &tm);
+			sprintf(time_label, "\n%d-%02d-%02d_%02d-%02d-%02d\n",
+				tm.tm_year+1900, tm.tm_mon+1, tm.tm_mday,
+				tm.tm_hour, tm.tm_min, tm.tm_sec);
+			if (memcmp(last_time_label, time_label, T_LABEL_LEN)) {
+				memcpy(last_time_label, time_label, T_LABEL_LEN);
+				ret = kernel_write(fp_log, time_label, strlen(time_label),
+						&fp_log->f_pos);
+			}
+		}
+		ret = kernel_write(fp_log, buffer, size, &fp_log->f_pos);
+	}
+
+exit:
+	if (atomic_read(&file_ref) == 1) {
+		if (!IS_ERR(fp_log)) {
+			filp_close(fp_log, NULL);
+			fp_log = (struct file *)-ENOENT;
+		}
+	}
+	atomic_sub(1, &file_ref);
+	return ret;
+}
+#endif
+
+#if (DGB_XRADIO_HWT)
+/***************************for HWT********************************/
+struct sk_buff *hwt_skb;
+int sent_num;
+int get_hwt_hif_tx(struct xradio_common *hw_priv, u8 **data,
+		   size_t *tx_len, int *burst, int *vif_selected)
+{
+
+	HWT_PARAMETERS *hwt_tx_hdr = NULL;
+	if (!hwt_tx_en || !hwt_tx_len || !hwt_tx_num ||
+		  sent_num >= hwt_tx_num) {
+		if (hwt_skb) {
+			dev_kfree_skb(hwt_skb);
+			hwt_skb = NULL;
+		}
+		return 0;
+	}
+
+	if (!hwt_skb) {
+		hwt_skb = xr_alloc_skb(1504);
+		if (!hwt_skb) {
+			xradio_dbg(XRADIO_DBG_ERROR, "%s:skb is NULL!\n", __func__);
+			return 0;
+		}
+		if ((unsigned long)hwt_skb->data & 3) {
+			u8 align = 4 - ((unsigned long)hwt_skb->data & 3);
+			skb_reserve(hwt_skb, align);
+		}
+		skb_put(hwt_skb, 1500);
+	}
+	/*fill the header info*/
+	if (hwt_tx_len < sizeof(HWT_PARAMETERS))
+		hwt_tx_len = sizeof(HWT_PARAMETERS);
+	if (hwt_tx_len > 1500)
+		hwt_tx_len = 1500;
+	hwt_tx_hdr = (HWT_PARAMETERS *)hwt_skb->data;
+	hwt_tx_hdr->MsgID = 0x0004;
+	hwt_tx_hdr->Msglen = hwt_tx_len;
+	hwt_tx_hdr->TestID = 0x0001;
+	hwt_tx_hdr->Data = 0x1234;
+
+	/*send the packet*/
+	*data = hwt_skb->data;
+	*tx_len = hwt_tx_hdr->Msglen;
+	*vif_selected = 0;
+	*burst = 2;		/*burst > 1 for continuous tx.*/
+	sent_num++;
+
+	/*first packet.*/
+	if (sent_num == 1) {
+		xr_do_gettimeofday(&hwt_start_time);
+	}
+	/*set confirm*/
+	hwt_tx_hdr->Params = 0;
+	if (sent_num >= hwt_tx_num) {
+		hwt_tx_hdr->Params = 0x101;	/*last packet*/
+		hwt_tx_en = 0;	/*disable hwt_tx_en*/
+		xradio_dbg(XRADIO_DBG_ALWY, "%s:sent last packet!\n", __func__);
+	} else if (hwt_tx_cfm) {
+		hwt_tx_hdr->Params = !(sent_num % hwt_tx_cfm);
+	}
+
+	return 1;
+}
+#endif
+
+#endif /* CONFIG_XRADIO_DEBUGFS */
diff -Naurp a/drivers/net/wireless/xr829/wlan/debug.h b/drivers/net/wireless/xr829/wlan/debug.h
--- a/drivers/net/wireless/xr829/wlan/debug.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/debug.h	2022-08-27 01:22:42.966539908 +0300
@@ -0,0 +1,704 @@
+/*
+ * DebugFS code for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef XRADIO_DEBUG_H_INCLUDED
+#define XRADIO_DEBUG_H_INCLUDED
+
+#include "itp.h"
+#include "xradio.h"
+
+/* Message always need to be present even in release version. */
+#define XRADIO_DBG_ALWY   0x01
+
+/* Error message to report an error, it can hardly works. */
+#define XRADIO_DBG_ERROR  0x02
+
+/* Warning message to inform us of something unnormal or
+* something very important, but it still work. */
+#define XRADIO_DBG_WARN   0x04
+
+/* Important message we need to know in unstable version. */
+#define XRADIO_DBG_NIY    0x08
+
+/* Normal message just for debug in developing stage. */
+#define XRADIO_DBG_MSG    0x10
+
+/* Trace of functions, for sequence of functions called. Normally,
+* don't set this level because there are too more print. */
+#define XRADIO_DBG_TRC    0x20
+
+#define XRADIO_DBG_LEVEL	0xFF
+
+/* for host debuglevel*/
+extern u8 dbg_common ;
+extern u8 dbg_sbus   ;
+extern u8 dbg_bh     ;
+extern u8 dbg_txrx   ;
+extern u8 dbg_wsm    ;
+extern u8 dbg_sta    ;
+extern u8 dbg_scan   ;
+extern u8 dbg_ap     ;
+extern u8 dbg_pm     ;
+extern u8 dbg_itp    ;
+extern u8 dbg_etf    ;
+extern u8 dbg_logfile;
+
+/*for sdio clk debug*/
+extern u32 dbg_sdio_clk;
+
+/*hang driver for debug when error occurs.*/
+#ifdef ERROR_HANG_DRIVER
+extern u8 error_hang_driver;
+#endif
+
+/* for ps debug */
+extern u8  ps_disable;
+extern u8  ps_idleperiod;
+extern u8  ps_changeperiod;
+/* info of bh thread*/
+extern u32 irq_count;
+extern u32 int_miss_cnt;
+extern u32 fix_miss_cnt;
+extern u32 next_rx_cnt;
+extern u32 rx_total_cnt;
+extern u32 tx_total_cnt;
+extern u32 tx_buf_limit;
+extern u32 tx_limit;
+extern u32 tx_rx_idle;
+extern u32 bh_idle;
+extern u32 queue_lock_cnt;
+extern u32 overfull_lock_cnt;
+extern u32 policy_lock_cnt;
+extern u32 dbg_txconfirm[32];
+extern int tx_burst_limit;
+extern u32 dbg_tx_delay_min;
+extern u32 dbg_tx_delay_max;
+extern u32 dbg_tx_media_delay[16];
+
+extern u32  sdio_reg_cnt1;
+extern u32  sdio_reg_cnt2;
+extern u32  sdio_reg_cnt3;
+extern u32  sdio_reg_cnt4;
+extern u32  sdio_reg_cnt5;
+extern u32  sdio_reg_cnt6;
+extern u32  tx_limit_cnt1;
+extern u32  tx_limit_cnt2;
+extern u32  tx_limit_cnt3;
+extern u32  tx_limit_cnt4;
+extern u32  tx_limit_cnt5;
+extern u32  tx_limit_cnt6;
+
+/* time info of bh tx and rx */
+#define PERF_INFO_TEST   0
+#if PERF_INFO_TEST
+#define TEST_GETTIME 0
+struct perf_info {
+	u32  count;
+	u32  totaltime;
+	u32  totalsize;
+	u32  min_time;
+	u32  max_time;
+};
+extern struct perf_info data_tx;
+extern struct perf_info data_rx;
+extern struct perf_info bh_others;
+extern struct perf_info bh_wait;
+extern struct perf_info sdio_reg;
+extern struct perf_info prepare_tx;
+extern struct perf_info sdio_write;
+extern struct perf_info dev_wake;
+extern struct perf_info prepare_rx;
+extern struct perf_info sdio_read;
+extern struct perf_info handle_rx;
+#ifdef BH_PROC_THREAD
+extern struct perf_info get_item;
+extern struct perf_info wake_proc;
+extern struct perf_info proc_rx;
+extern struct perf_info proc_tx;
+extern struct perf_info proc_wait;
+#endif
+extern struct perf_info ind_rx;
+extern struct perf_info mac_rx;
+extern struct perf_info mac_tx;
+
+#if TEST_GETTIME
+extern struct perf_info get_time;
+#define  PERF_INFO_GETTIME(t) do { \
+	xr_do_gettimeofday(t); \
+	perf_info_stamp(t, &get_time, 0, NULL); \
+} while (0)
+#else
+#define  PERF_INFO_GETTIME(t) xr_do_gettimeofday(t)
+#endif
+#define  PERF_INFO_STAMP(t, p, s) perf_info_stamp(t, p, s, NULL)
+#define  PERF_INFO_STAMP_GET(t, p, s, g) perf_info_stamp(t, p, s, g)
+#define  PERF_INFO_STAMP_UPDATE(t, p, s) perf_info_stamp(t, p, s, t)
+
+#include <linux/rtc.h>
+#include <linux/time.h>
+static inline void perf_info_stamp(struct timeval *oldtime,
+	struct perf_info *info, u32 size, struct timeval *gettime)
+{
+	u32 time_int;
+	struct timeval newtime;
+	xr_do_gettimeofday(&newtime);
+	time_int = (newtime.tv_sec - oldtime->tv_sec) * 1000000 + \
+			   (long)(newtime.tv_usec - oldtime->tv_usec);
+	if (time_int <= info->min_time)
+		info->min_time = time_int;
+	if (time_int > info->max_time)
+		info->max_time = time_int;
+	info->totalsize += size;
+	info->totaltime += time_int;
+	info->count++;  /*do_gettimeofday consume 0.5us*/
+	if (gettime != NULL) {
+		memcpy(gettime, &newtime, sizeof(newtime));
+	}
+}
+
+#else /* #if PERF_INFO_TEST */
+
+#define  PERF_INFO_GETTIME(t)
+#define  PERF_INFO_STAMP(t, p, s)
+#define  PERF_INFO_STAMP_GET(t, p, s, g)
+#define  PERF_INFO_STAMP_UPDATE(t, p, s)
+#endif /* #if PERF_INFO_TEST */
+
+#ifdef SUPPORT_HT40
+
+extern u32 TxedHtofdmRateMap[4][8];
+extern u32 TxedLegacyRateMap[2][8];
+
+extern u32 RxedHtofdmRateMap[4][8];
+extern u32 RxedLegacyRateMap[2][8];
+
+#else
+
+extern u32 TxedRateIdx_Map[24];
+extern u32 RxedRateIdx_Map[24];
+
+#endif
+
+#ifdef CONFIG_XRADIO_DEBUGFS
+#if (SUPPORT_EPTA)
+extern u32 epta_stat_dbg_ctrl;
+#endif
+#endif
+
+#define WSM_DUMP_MAX_SIZE 20
+
+#if defined(CONFIG_XRADIO_DEBUG)
+#define DGB_LOG_FILE    0  /*Don't log more than 500byte once.*/
+#define DGB_XRADIO_QC   1  /*Enable this only in QC test.*/
+#define DGB_XRADIO_HWT  0  /*Only in hardware test with special fw.*/
+#define DBG_XRADIO_HIF  1
+#define DBG_READ_HWINFO	0
+#else
+#define DGB_LOG_FILE    0  /*Don't log more than 500byte once.*/
+#define DGB_XRADIO_QC   0  /*Enable this only in QC test.*/
+#define DGB_XRADIO_HWT  0  /*Only in hardware test with special fw.*/
+#define DBG_XRADIO_HIF  0
+#define DBG_READ_HWINFO	0
+#endif
+
+#if (DBG_XRADIO_HIF)
+
+#define WRITE_READ_MAX_LEN 0x1000
+#define PAS_RAM_START_ADDR 0x09010000
+#define PAS_RAM_END_ADDR 0X09017fff
+
+#endif
+
+#if DGB_LOG_FILE
+#define DGB_LOG_BUF_LEN 1500
+#define DGB_LOG_PATH0    "/data/xradio_err.log"
+
+extern u8 log_buffer[DGB_LOG_BUF_LEN];
+extern u16 log_pos;
+int xradio_logfile(char *buffer, int buf_len, u8 b_time);
+
+#define LOG_FILE(b_time, msg) xradio_logfile(msg, -1, b_time)
+#define LOG_FILE_VARS(b_time, ...)  do {    \
+	if (!log_pos)   \
+		memset(log_buffer, 0, DGB_LOG_BUF_LEN); \
+	if (log_pos <= 1000)  \
+		log_pos += sprintf((char *)(log_buffer+log_pos), __VA_ARGS__); \
+	if (xradio_logfile(log_buffer, log_pos, b_time) >= 0)   \
+		log_pos = 0; \
+} while (0)
+
+#else /*DGB_LOG_FILE disable*/
+
+#define LOG_FILE(b_time, msg)
+#define LOG_FILE_VARS(b_time, ...)
+#endif
+
+#if (defined(CONFIG_XRADIO_DEBUG))
+/****************************** debug version *******************************/
+#if (defined(CONFIG_XRADIO_DUMP_ON_ERROR))
+#define SYS_BUG(c)     BUG_ON(c)
+#define SYS_WARN(c)    WARN_ON(c)
+#else
+#define SYS_BUG(c)     WARN_ON(c)
+#define SYS_WARN(c)    WARN_ON(c)
+#endif
+
+#define xradio_dbg(level, ...)           \
+	do {                                 \
+		if ((level) & dbg_common & XRADIO_DBG_ERROR)      \
+			printk(KERN_ERR "[XRADIO_ERR] " __VA_ARGS__); \
+		else if ((level) & dbg_common & XRADIO_DBG_WARN)  \
+			printk(KERN_ERR "[XRADIO_WRN] " __VA_ARGS__); \
+		else if ((level) & dbg_common)                    \
+			printk(KERN_ERR "[XRADIO] " __VA_ARGS__);     \
+		if ((level) & dbg_logfile)                        \
+			LOG_FILE_VARS(((level)&XRADIO_DBG_ERROR),     \
+				       "[XRADIO_ERR] " __VA_ARGS__);  \
+	} while (0)
+
+#define sbus_printk(level, ...)     \
+	do {                              \
+		if ((level) & dbg_sbus & XRADIO_DBG_ERROR)       \
+			printk(KERN_ERR "[SBUS_ERR] " __VA_ARGS__);  \
+		else if ((level) & dbg_sbus & XRADIO_DBG_WARN)   \
+			printk(KERN_ERR "[SBUS_WRN] " __VA_ARGS__);  \
+		else if ((level) & dbg_sbus)                     \
+			printk(KERN_ERR "[SBUS] " __VA_ARGS__);      \
+		if ((level) & dbg_logfile)         \
+			LOG_FILE_VARS(((level)&XRADIO_DBG_ERROR),    \
+				      "[SBUS_ERR] " __VA_ARGS__);    \
+	} while (0)
+
+#define txrx_printk(level, ...)     \
+	do {                              \
+		if ((level) & dbg_txrx & XRADIO_DBG_ERROR)       \
+			printk(KERN_ERR "[TXRX_ERR] " __VA_ARGS__);  \
+		else if ((level) & dbg_txrx & XRADIO_DBG_WARN)   \
+			printk(KERN_ERR "[TXRX_WRN] " __VA_ARGS__);  \
+		else if ((level) & dbg_txrx)                     \
+			printk(KERN_ERR "[TXRX] " __VA_ARGS__);      \
+		if ((level) & dbg_logfile)         \
+			LOG_FILE_VARS(((level)&XRADIO_DBG_ERROR),  \
+				      "[TXRX_ERR] " __VA_ARGS__);  \
+	} while (0)
+
+#define bh_printk(level, ...)       \
+	do {                              \
+		if ((level) & dbg_bh & XRADIO_DBG_ERROR)       \
+			printk(KERN_ERR "[BH_ERR] " __VA_ARGS__);  \
+		else if ((level) & dbg_bh & XRADIO_DBG_WARN)   \
+			printk(KERN_ERR "[BH_WRN] " __VA_ARGS__);  \
+		else if ((level) & dbg_bh)                     \
+			printk(KERN_ERR "[BH] " __VA_ARGS__);      \
+		if ((level) & dbg_logfile)         \
+			LOG_FILE_VARS(((level)&XRADIO_DBG_ERROR), \
+				      "[BH_ERR] " __VA_ARGS__);   \
+	} while (0)
+
+#define wsm_printk(level, ...)      \
+	do {                              \
+		if ((level) & dbg_wsm & XRADIO_DBG_ERROR)       \
+			printk(KERN_ERR "[WSM_ERR] " __VA_ARGS__);  \
+		else if ((level) & dbg_wsm & XRADIO_DBG_WARN)   \
+			printk(KERN_ERR "[WSM_WRN] " __VA_ARGS__);  \
+		else if ((level) & dbg_wsm)          \
+			printk(KERN_ERR "[WSM] " __VA_ARGS__); \
+		if ((level) & dbg_logfile)         \
+			LOG_FILE_VARS(((level)&XRADIO_DBG_ERROR), \
+				      "[WSM_ERR] " __VA_ARGS__);      \
+	} while (0)
+
+#define sta_printk(level, ...)      \
+	do {                              \
+		if ((level) & dbg_sta & XRADIO_DBG_ERROR)       \
+			printk(KERN_ERR "[STA_ERR] " __VA_ARGS__);  \
+		else if ((level) & dbg_sta & XRADIO_DBG_WARN)   \
+			printk(KERN_ERR "[STA_WRN] " __VA_ARGS__);  \
+		else if ((level) & dbg_sta)          \
+			printk(KERN_ERR "[STA] " __VA_ARGS__); \
+		if ((level) & dbg_logfile)         \
+			LOG_FILE_VARS(((level)&XRADIO_DBG_ERROR),  \
+				      "[STA_ERR] " __VA_ARGS__);   \
+	} while (0)
+
+#define scan_printk(level, ...)      \
+	do {                              \
+		if ((level) & dbg_scan & XRADIO_DBG_ERROR)       \
+			printk(KERN_ERR "[SCAN_ERR] " __VA_ARGS__);  \
+		else if ((level) & dbg_scan & XRADIO_DBG_WARN)   \
+			printk(KERN_ERR "[SCAN_WRN] " __VA_ARGS__);  \
+		else if ((level) & dbg_scan)                 \
+			printk(KERN_ERR "[SCAN] " __VA_ARGS__);  \
+		if ((level) & dbg_logfile)         \
+			LOG_FILE_VARS(((level)&XRADIO_DBG_ERROR), \
+				      "[SCAN_ERR] " __VA_ARGS__); \
+	} while (0)
+
+#define ap_printk(level, ...)       \
+	do {                              \
+		if ((level) & dbg_ap & XRADIO_DBG_ERROR)       \
+			printk(KERN_ERR "[AP_ERR] " __VA_ARGS__);  \
+		else if ((level) & dbg_ap & XRADIO_DBG_WARN)   \
+			printk(KERN_ERR "[AP_WRN] " __VA_ARGS__);  \
+		else if ((level) & dbg_ap)                \
+			printk(KERN_ERR "[AP] " __VA_ARGS__); \
+		if ((level) & dbg_logfile)         \
+			LOG_FILE_VARS(((level)&XRADIO_DBG_ERROR), \
+				      "[AP_ERR] " __VA_ARGS__);   \
+	} while (0)
+
+#define pm_printk(level, ...)       \
+	do {                              \
+		if ((level) & dbg_pm & XRADIO_DBG_ERROR)       \
+			printk(KERN_ERR "[PM_ERR] " __VA_ARGS__);  \
+		else if ((level) & dbg_pm & XRADIO_DBG_WARN)   \
+			printk(KERN_ERR "[PM_WRN] " __VA_ARGS__);  \
+		else if ((level) & dbg_pm)           \
+			printk(KERN_ERR "[PM] " __VA_ARGS__); \
+		if ((level) & dbg_logfile)         \
+			LOG_FILE_VARS(((level)&XRADIO_DBG_ERROR), \
+				      "[PM_ERR] " __VA_ARGS__);   \
+	} while (0)
+
+#define itp_printk(level, ...)      \
+	do {                              \
+		if ((level) & dbg_itp & XRADIO_DBG_ERROR)       \
+			printk(KERN_ERR "[ITP_ERR] " __VA_ARGS__);  \
+		else if ((level) & dbg_itp & XRADIO_DBG_WARN)   \
+			printk(KERN_ERR "[ITP_WRN] " __VA_ARGS__);  \
+		else if ((level) & dbg_itp)          \
+			printk(KERN_ERR "[ITP] " __VA_ARGS__); \
+		if ((level) & dbg_logfile)         \
+			LOG_FILE_VARS(((level)&XRADIO_DBG_ERROR), \
+				      "[ITP_ERR] " __VA_ARGS__);  \
+	} while (0)
+
+#define etf_printk(level, ...)      \
+	do {                              \
+		if ((level) & dbg_etf & XRADIO_DBG_ERROR)       \
+			printk(KERN_ERR "[ETF_ERR] " __VA_ARGS__);  \
+		else if ((level) & dbg_etf & XRADIO_DBG_WARN)   \
+			printk(KERN_ERR "[ETF_WRN] " __VA_ARGS__);  \
+		else if ((level) & dbg_etf)          \
+			printk(KERN_ERR "[ETF] " __VA_ARGS__); \
+		if ((level) & dbg_logfile)         \
+			LOG_FILE_VARS(((level)&XRADIO_DBG_ERROR), \
+				      "[ETF_ERR] " __VA_ARGS__);  \
+	} while (0)
+
+
+#define DBG_FUN_LINE   printk(KERN_ERR "%s, line=%d", __func__, __LINE__)
+#define PARAM_CHECK_FALSE(p) \
+	do {                      \
+		if (!p) \
+			DBG_FUN_LINE; \
+	} while (0)
+
+#define PARAM_CHECK_TRUE(p) \
+	do { \
+		if (p) \
+			DBG_FUN_LINE; \
+	} while (0)
+
+
+/*interfaces to debug packet's information.*/
+/*for802.11*/
+#define PF_CTRL     0x0001
+#define PF_MGMT     0x0002
+#define PF_DATA     0x0004
+#define PF_SCAN     0x0008
+
+/*for ip data*/
+#define PF_TCP      0x0010
+#define PF_UDP      0x0020
+#define PF_DHCP     0x0040
+#define PF_ICMP     0x0080
+
+/*for special frames or info.*/
+#define PF_8021X    0x0100    /*action frames*/
+#define PF_MAC_SN   0x0200    /*mac seq*/
+#define PF_OWNMAC   0x0400    /*TA in Tx, RA in Rx.*/
+#define PF_SA_DA    0x0800    /*SA, DA for Ethernet.*/
+
+#define PF_MACADDR  0x1000    /*RA in Tx, TA in Rx.*/
+#define PF_IPADDR   0x2000    /*ip address of ip packets.*/
+#define PF_UNKNWN   0x4000    /*print frames of unknown flag.*/
+#define PF_RX       0x8000    /*0:TX, 1:RX. So, need to add PF_RX in Rx path.*/
+void xradio_parse_frame(u8 *mac_data, u8 iv_len, u16 flags, u8 if_id);
+
+#if (DGB_XRADIO_HWT)  /*hardware test*/
+typedef struct HWT_PARAMETERS_S {
+	u16 Msglen;
+	u16 MsgID;
+	u16 TestID;
+	u16 Params;
+	u16 Datalen;
+	u16 Data;
+} HWT_PARAMETERS;
+int get_hwt_hif_tx(struct xradio_common *hw_priv, u8 **data,
+		   size_t *tx_len, int *burst, int *vif_selected);
+#endif  /*DGB_XRADIO_HWT*/
+
+#else
+/****************************** release version *******************************/
+#define SYS_BUG(c)  WARN_ON(c)
+#define SYS_WARN(c) WARN_ON(c)
+
+#define xradio_dbg(level, ...)
+#define sbus_printk(level, ...)
+#define txrx_printk(level, ...)
+#define bh_printk(level, ...)
+#define wsm_printk(level, ...)
+#define sta_printk(level, ...)
+#define scan_printk(level, ...)
+#define ap_printk(level, ...)
+#define pm_printk(level, ...)
+#define itp_printk(level, ...)
+
+#define DBG_FUN_LINE
+#define PARAM_CHECK_FALSE
+#define PARAM_CHECK_TRUE
+
+static inline void xradio_parse_frame(u8 *mac_data, u8 iv_len,
+									  u16 flags, u8 if_id)
+{
+}
+#endif  /*CONFIG_XRADIO_DEBUG*/
+
+#ifdef CONFIG_XRADIO_DEBUGFS
+/************************* debugfs version *****************************/
+struct xradio_debug_common {
+	struct dentry *debugfs_phy;
+	int tx_cache_miss;
+	int tx_burst;
+	int rx_burst;
+	int ba_cnt;
+	int ba_acc;
+	int ba_cnt_rx;
+	int ba_acc_rx;
+#ifdef CONFIG_XRADIO_ITP
+	struct xradio_itp itp;
+#endif /* CONFIG_XRADIO_ITP */
+};
+
+struct xradio_debug_priv {
+	struct dentry *debugfs_phy;
+	int tx;
+	int tx_agg;
+	int rx;
+	int rx_agg;
+	int tx_multi;
+	int tx_multi_frames;
+	int tx_align;
+	int tx_ttl;
+};
+
+
+#define DBG_INT_ADD(count)   (++count)
+#define DBG_ARRY_ADD(a, i)    (++a[i])
+
+#ifdef ERROR_HANG_DRIVER
+void xradio_hang_driver_for_debug(struct xradio_common *hw_priv, int error);
+#endif
+int xradio_debug_init_common(struct xradio_common *hw_priv);
+int xradio_debug_init_priv(struct xradio_common *hw_priv,
+			   struct xradio_vif *priv);
+void xradio_debug_release_common(struct xradio_common *hw_priv);
+void xradio_debug_release_priv(struct xradio_vif *priv);
+
+void xradio_debug_tx_delay(u32 media_delay, u32 queue_delay);
+
+static inline void xradio_debug_txed(struct xradio_vif *priv)
+{
+	if (!priv->debug)
+		return;
+	++priv->debug->tx;
+}
+
+static inline void xradio_debug_txed_agg(struct xradio_vif *priv)
+{
+	if (!priv->debug)
+		return;
+	++priv->debug->tx_agg;
+}
+
+static inline void xradio_debug_txed_multi(struct xradio_vif *priv,
+					   int count)
+{
+	if (!priv->debug)
+		return;
+	++priv->debug->tx_multi;
+	priv->debug->tx_multi_frames += count;
+}
+
+static inline void xradio_debug_rxed(struct xradio_vif *priv)
+{
+	if (!priv->debug)
+		return;
+	++priv->debug->rx;
+}
+
+static inline void xradio_debug_rxed_agg(struct xradio_vif *priv)
+{
+	if (!priv->debug)
+		return;
+	++priv->debug->rx_agg;
+}
+
+static inline void xradio_debug_tx_cache_miss(struct xradio_common *hw_priv)
+{
+	if (!hw_priv->debug)
+		return;
+	++hw_priv->debug->tx_cache_miss;
+}
+
+static inline void xradio_debug_tx_align(struct xradio_vif *priv)
+{
+	if (!priv->debug)
+		return;
+	++priv->debug->tx_align;
+}
+
+static inline void xradio_debug_tx_ttl(struct xradio_vif *priv)
+{
+	if (!priv->debug)
+		return;
+	++priv->debug->tx_ttl;
+}
+
+static inline void xradio_debug_tx_burst(struct xradio_common *hw_priv)
+{
+	if (!hw_priv->debug)
+		return;
+	++hw_priv->debug->tx_burst;
+}
+
+static inline void xradio_debug_rx_burst(struct xradio_common *hw_priv)
+{
+	if (!hw_priv->debug)
+		return;
+	++hw_priv->debug->rx_burst;
+}
+
+static inline void xradio_debug_ba(struct xradio_common *hw_priv,
+				   int ba_cnt, int ba_acc, int ba_cnt_rx,
+				   int ba_acc_rx)
+{
+	if (!hw_priv->debug)
+		return;
+	hw_priv->debug->ba_cnt = ba_cnt;
+	hw_priv->debug->ba_acc = ba_acc;
+	hw_priv->debug->ba_cnt_rx = ba_cnt_rx;
+	hw_priv->debug->ba_acc_rx = ba_acc_rx;
+}
+
+int xradio_print_fw_version(struct xradio_common *hw_priv,
+							u8 *buf, size_t len);
+
+int   xradio_host_dbg_init(void);
+void  xradio_host_dbg_deinit(void);
+
+#else /* CONFIG_XRADIO_DEBUGFS */
+/************************ no debugfs version **************************/
+#define DBG_INT_ADD(count)
+#define DBG_ARRY_ADD(a, i)
+
+static inline int xradio_debug_init_common(struct xradio_common *hw_priv)
+{
+	return 0;
+}
+
+static inline int xradio_debug_init_priv(struct xradio_common *hw_priv,
+			   struct xradio_vif *priv)
+{
+	return 0;
+}
+
+static inline void xradio_debug_release_common(struct xradio_common *hw_priv)
+{
+}
+
+static inline void xradio_debug_release_priv(struct xradio_vif *priv)
+{
+}
+
+static inline void xradio_debug_txed(struct xradio_vif *priv)
+{
+}
+
+static inline void xradio_debug_txed_agg(struct xradio_vif *priv)
+{
+}
+
+static inline void xradio_debug_txed_multi(struct xradio_vif *priv,
+					   int count)
+{
+}
+
+static inline void xradio_debug_rxed(struct xradio_vif *priv)
+{
+}
+
+static inline void xradio_debug_rxed_agg(struct xradio_vif *priv)
+{
+}
+
+static inline void xradio_debug_tx_cache_miss(struct xradio_common *hw_priv)
+{
+}
+
+static inline void xradio_debug_tx_align(struct xradio_vif *priv)
+{
+}
+
+static inline void xradio_debug_tx_ttl(struct xradio_vif *priv)
+{
+}
+
+static inline void xradio_debug_tx_burst(struct xradio_common *hw_priv)
+{
+}
+
+static inline void xradio_debug_rx_burst(struct xradio_common *hw_priv)
+{
+}
+
+static inline void xradio_debug_ba(struct xradio_common *hw_priv,
+				   int ba_cnt, int ba_acc, int ba_cnt_rx,
+				   int ba_acc_rx)
+{
+}
+
+static inline void xradio_debug_tx_delay(u32 media_delay, u32 queue_delay)
+{
+}
+
+static inline int xradio_print_fw_version(struct xradio_vif *priv,
+									u8 *buf, size_t len)
+{
+	return 0;
+}
+
+static inline void xradio_hang_driver_for_debug(struct xradio_common *hw_priv, int error)
+{
+
+}
+
+static inline int   xradio_host_dbg_init(void)
+{
+	return 0;
+}
+
+static inline void  xradio_host_dbg_deinit(void)
+{
+}
+#endif /* CONFIG_XRADIO_DEBUGFS */
+
+#endif /* XRADIO_DEBUG_H_INCLUDED */
diff -Naurp a/drivers/net/wireless/xr829/wlan/etf.c b/drivers/net/wireless/xr829/wlan/etf.c
--- a/drivers/net/wireless/xr829/wlan/etf.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/etf.c	2022-08-27 01:22:42.966539908 +0300
@@ -0,0 +1,1114 @@
+/*
+ * ETF interfaces for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef XRADIO_ETF_C
+#define XRADIO_ETF_C
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/vmalloc.h>
+#include <linux/netlink.h>
+#include <net/sock.h>
+#include <linux/kthread.h>
+#include <linux/wait.h>
+#include <linux/firmware.h>
+#include <uapi/linux/sched/types.h>
+
+
+#include "etf.h"
+#include "xradio.h"
+#include "sbus.h"
+#include "debug.h"
+
+/********************* interfaces of adapter layer **********************/
+static struct xradio_adapter adapter_priv;
+
+#if (ETF_QUEUEMODE)
+static void adapter_rec_handler(struct sk_buff *__skb)
+{
+	int i = 0;
+	struct adapter_item *item;
+	etf_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	do {
+		spin_lock_bh(&adapter_priv.recv_lock);
+		if (likely(!list_empty(&adapter_priv.rx_pool))) {
+			item = list_first_entry(&adapter_priv.rx_pool, struct adapter_item, head);
+			item->skb = (void *)skb_get(__skb);
+			list_move_tail(&item->head, &adapter_priv.rx_queue);
+			spin_unlock_bh(&adapter_priv.recv_lock);
+			etf_printk(XRADIO_DBG_NIY, "%s recv msg to rx_queue!\n", __func__);
+			break;
+		} else if (++i > ETF_QUEUE_TIMEOUT) { /* about 2s.*/
+			spin_unlock_bh(&adapter_priv.recv_lock);
+			etf_printk(XRADIO_DBG_ERROR,
+				"%s driver is process timeout, drop msg!\n", __func__);
+			return;
+		} else {
+			etf_printk(XRADIO_DBG_NIY,
+				"%s rx_pool is empty, wait %d!ms\n", __func__, i);
+		}
+		spin_unlock_bh(&adapter_priv.recv_lock);
+		msleep(i);
+	} while (1);
+
+	if (atomic_add_return(1, &adapter_priv.rx_cnt) == 1)
+		up(&adapter_priv.proc_sem);
+	return;
+}
+#else
+static void adapter_rec_handler(struct sk_buff *skb)
+{
+	struct nlmsghdr *nlhdr = (struct nlmsghdr *)skb->data;
+	etf_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (nlhdr->nlmsg_len < sizeof(struct nlmsghdr)) {
+		etf_printk(XRADIO_DBG_ERROR, "Corrupt netlink msg!\n");
+	} else {
+		int len = nlhdr->nlmsg_len - NLMSG_LENGTH(0);
+		adapter_priv.send_pid = nlhdr->nlmsg_pid;
+		adapter_priv.msg_len  = min(ADAPTER_RX_BUF_LEN, len);
+		memcpy(adapter_priv.msg_buf, NLMSG_DATA(nlhdr), adapter_priv.msg_len);
+		if (len != adapter_priv.msg_len)
+			etf_printk(XRADIO_DBG_WARN, "%s recv len(%d), proc len=%d!\n",
+					__func__, len, adapter_priv.msg_len);
+		else
+			etf_printk(XRADIO_DBG_NIY, "%s recv msg len(%d)!\n",
+					__func__, adapter_priv.msg_len);
+		if (adapter_priv.handler)
+			adapter_priv.handler(adapter_priv.msg_buf, adapter_priv.msg_len);
+
+	}
+}
+#endif
+
+static int adapter_init_msgbuf(void)
+{
+#if (ETF_QUEUEMODE)
+	int i = 0;
+#endif
+	etf_printk(XRADIO_DBG_NIY, "%s\n", __func__);
+	if (adapter_priv.msg_buf) {
+		etf_printk(XRADIO_DBG_ERROR, "%s msgbuf already init!\n", __func__);
+		return -1;
+	}
+
+#if (ETF_QUEUEMODE)
+	atomic_set(&adapter_priv.rx_cnt, 0);
+	INIT_LIST_HEAD(&adapter_priv.rx_queue);
+	INIT_LIST_HEAD(&adapter_priv.rx_pool);
+	for (i = 0; i < ADAPTER_ITEM_MAX; i++)
+		list_add_tail(&adapter_priv.rx_items[i].head, &adapter_priv.rx_pool);
+#endif
+
+	adapter_priv.msg_buf  = xr_kzalloc(ADAPTER_RX_BUF_LEN, false);
+	if (!adapter_priv.msg_buf)
+		return -ENOMEM;
+	return 0;
+}
+
+static void adapter_deinit_msgbuf(void)
+{
+#if (ETF_QUEUEMODE)
+	struct  adapter_item *item;
+#endif
+	etf_printk(XRADIO_DBG_NIY, "%s\n", __func__);
+	if (adapter_priv.msg_buf) {
+		kfree(adapter_priv.msg_buf);
+		adapter_priv.msg_buf = NULL;
+	}
+#if (ETF_QUEUEMODE)
+	spin_lock_bh(&adapter_priv.recv_lock);
+	list_for_each_entry(item, &adapter_priv.rx_queue, head) {
+		if (item->skb) {
+			dev_kfree_skb((struct sk_buff *)item->skb);
+			item->skb = NULL;
+		}
+	}
+	spin_unlock_bh(&adapter_priv.recv_lock);
+#endif
+}
+
+#if (ETF_QUEUEMODE)
+static int adapter_handle_rx_queue(void)
+{
+	int len = 0;
+	struct nlmsghdr *nlhdr = NULL;
+	struct adapter_item *item;
+	bool bHandler = false;
+	while (1) {
+		spin_lock_bh(&adapter_priv.recv_lock);
+		if (!list_empty(&adapter_priv.rx_queue)) {
+			item = list_first_entry(&adapter_priv.rx_queue, struct adapter_item, head);
+			if (item->skb) {
+				struct sk_buff *skb = (struct sk_buff *)(item->skb);
+				nlhdr = (struct nlmsghdr *)skb->data;
+				if (nlhdr->nlmsg_len < sizeof(struct nlmsghdr)) {
+					etf_printk(XRADIO_DBG_ERROR, "Corrupt netlink msg!\n");
+				} else {
+					len = nlhdr->nlmsg_len - NLMSG_LENGTH(0);
+					adapter_priv.send_pid = nlhdr->nlmsg_pid;
+					adapter_priv.msg_len  = min(ADAPTER_RX_BUF_LEN, len);
+					memcpy(adapter_priv.msg_buf, NLMSG_DATA(nlhdr), len);
+					bHandler = true;
+					if (len != adapter_priv.msg_len)
+						etf_printk(XRADIO_DBG_WARN, "%s recv len(%d), proc len=%d!\n",
+								__func__, len, adapter_priv.msg_len);
+					else
+						etf_printk(XRADIO_DBG_NIY, "%s recv msg len(%d)!\n",
+								__func__, adapter_priv.msg_len);
+				}
+				dev_kfree_skb(skb);
+				item->skb = NULL;
+				list_move_tail(&item->head, &adapter_priv.rx_pool);
+			} else {
+				etf_printk(XRADIO_DBG_ERROR, "%s skb is NULL!\n", __func__);
+			}
+		} else {
+			spin_unlock_bh(&adapter_priv.recv_lock);
+			break;
+		}
+		spin_unlock_bh(&adapter_priv.recv_lock);
+		if (bHandler && adapter_priv.handler) {
+			adapter_priv.handler(adapter_priv.msg_buf, adapter_priv.msg_len);
+			bHandler = false;
+		}
+	}
+	return 0;
+}
+
+static int adapter_proc(void *param)
+{
+	int ret  = 0;
+	int term = 0;
+	int recv = 0;
+	etf_printk(XRADIO_DBG_NIY, "%s\n", __func__);
+	for (;;) {
+		ret = down_interruptible(&adapter_priv.proc_sem);
+		recv = atomic_xchg(&adapter_priv.rx_cnt, 0);
+		term = kthread_should_stop();
+		etf_printk(XRADIO_DBG_NIY, "%s term=%d!\n", __func__, term);
+		if (term || adapter_priv.exit || ret < 0) {
+			break;
+		}
+		if (recv) {
+			adapter_handle_rx_queue();
+		}
+	}
+	etf_printk(XRADIO_DBG_NIY, "%s: exit!\n", __func__);
+	return 0;
+}
+static int adapter_start_thread(void)
+{
+	int ret = 0;
+	struct sched_param param = {.sched_priority = 100 };
+	etf_printk(XRADIO_DBG_NIY, "%s\n", __func__);
+	adapter_priv.thread_tsk = NULL;
+	adapter_priv.exit = 0;
+	adapter_priv.thread_tsk = kthread_create(&adapter_proc, NULL, XRADIO_ADAPTER);
+	if (IS_ERR(adapter_priv.thread_tsk)) {
+		ret = PTR_ERR(adapter_priv.thread_tsk);
+		adapter_priv.thread_tsk = NULL;
+	} else {
+		sched_setscheduler(adapter_priv.thread_tsk, SCHED_NORMAL, &param);
+		wake_up_process(adapter_priv.thread_tsk);
+	}
+	return ret;
+}
+static void adapter_stop_thread(void)
+{
+	etf_printk(XRADIO_DBG_NIY, "%s\n", __func__);
+	if (adapter_priv.thread_tsk != NULL) {
+		adapter_priv.exit = 1;
+		up(&adapter_priv.proc_sem);
+		kthread_stop(adapter_priv.thread_tsk);
+		adapter_priv.thread_tsk = NULL;
+	} else {
+		etf_printk(XRADIO_DBG_WARN, "%s: thread_tsk is NULL!\n", __func__);
+	}
+}
+#endif /* ETF_QUEUEMODE */
+
+static int xradio_adapter_send(void *data, int len)
+{
+	int ret = 0;
+	struct sk_buff  *skb = NULL;
+	struct nlmsghdr *nlhdr = NULL;
+	u8  *payload  = NULL;
+	if (0 == len || NULL == data)
+		return -EINVAL;
+
+	skb = xr_alloc_skb(NLMSG_SPACE(len + 1));
+	if (!skb) {
+		etf_printk(XRADIO_DBG_WARN, "%s:xr_alloc_skb failed!\n", __func__);
+		return -ENOMEM;
+	}
+	/* '\0' safe for strcpy, compat for old etf apk, may be removed in furture.*/
+	nlhdr = nlmsg_put(skb, 0, 0, 0, len + 1, 0); /* (len+1) is payload */
+	payload = (u8 *)NLMSG_DATA(nlhdr);
+	memcpy(payload, data, len);
+	payload[len] = '\0';
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0)
+	NETLINK_CB(skb).pid = 0;
+#else
+	NETLINK_CB(skb).portid = 0;
+#endif
+	NETLINK_CB(skb).dst_group = 0;
+
+	down(&adapter_priv.send_lock);
+	ret = netlink_unicast(adapter_priv.sock, skb, adapter_priv.send_pid, 0);
+	if (ret < 0)
+		etf_printk(XRADIO_DBG_ERROR, "%s:netlink_unicast failed(%d), pid=%d!\n",
+					__func__, ret, adapter_priv.send_pid);
+	else
+		etf_printk(XRADIO_DBG_NIY, "%s:netlink_unicast len(%d), pid=%d!\n",
+					__func__, ret, adapter_priv.send_pid);
+	up(&adapter_priv.send_lock);
+
+	return ret;
+}
+
+static int xradio_adapter_send_pkg(void *data1, int len1, void *data2, int len2)
+{
+	int ret = 0;
+	struct sk_buff  *skb = NULL;
+	struct nlmsghdr *nlhdr = NULL;
+	u8  *payload  = NULL;
+	int total_len = len1 + len2;
+	if (len1 <= 0 || len2 < 0 || NULL == data1)
+		return -EINVAL;
+
+	skb = xr_alloc_skb(NLMSG_SPACE(total_len + 1));
+	if (!skb) {
+		etf_printk(XRADIO_DBG_WARN, "%s:xr_alloc_skb failed!\n", __func__);
+		return -ENOMEM;
+	}
+	/* '\0' safe for strcpy, compat for old etf apk, may be removed in furture.*/
+	nlhdr = nlmsg_put(skb, 0, 0, 0, total_len + 1, 0);
+	payload = (u8 *)NLMSG_DATA(nlhdr);
+	memcpy(payload, data1, len1);
+	if (data2 && len2)
+		memcpy((payload + len1), data2, len2);
+	payload[total_len] = '\0';
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0)
+	NETLINK_CB(skb).pid = 0;
+#else
+	NETLINK_CB(skb).portid = 0;
+#endif
+	NETLINK_CB(skb).dst_group = 0;
+
+	down(&adapter_priv.send_lock);
+	ret = netlink_unicast(adapter_priv.sock, skb, adapter_priv.send_pid, 0);
+	if (ret < 0)
+		etf_printk(XRADIO_DBG_ERROR, "%s:netlink_unicast failed(%d), pid=%d!\n",
+					__func__, ret, adapter_priv.send_pid);
+	else
+		etf_printk(XRADIO_DBG_NIY, "%s:netlink_unicast len(%d), pid=%d!\n",
+					__func__, ret, adapter_priv.send_pid);
+	up(&adapter_priv.send_lock);
+
+	return ret;
+}
+
+struct xradio_adapter *xradio_adapter_init(msg_proc func)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
+	struct netlink_kernel_cfg cfg = {
+		.input	= adapter_rec_handler,
+	};
+#endif
+	if (func == NULL) {
+		etf_printk(XRADIO_DBG_ERROR, "%s msg_proc is NULL\n", __func__);
+		return NULL;
+	}
+	adapter_priv.handler = func;
+	sema_init(&adapter_priv.send_lock, 1);
+	if (adapter_init_msgbuf()) {
+		etf_printk(XRADIO_DBG_ERROR, "%s adapter_init_msgbuf failed\n", __func__);
+		return NULL;
+	}
+
+#if (ETF_QUEUEMODE)
+	sema_init(&adapter_priv.proc_sem, 0);
+	if (adapter_start_thread()) {
+		adapter_deinit_msgbuf();
+		etf_printk(XRADIO_DBG_ERROR, "%s adapter_start_thread failed\n", __func__);
+		return NULL;
+	}
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0))
+	adapter_priv.sock = netlink_kernel_create(&init_net, NL_FOR_XRADIO, 0,
+			adapter_rec_handler, NULL, THIS_MODULE);
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0))
+	adapter_priv.sock = netlink_kernel_create(&init_net, NL_FOR_XRADIO,
+			THIS_MODULE, &cfg);
+#else
+	adapter_priv.sock = netlink_kernel_create(&init_net, NL_FOR_XRADIO, &cfg);
+#endif
+
+	if (adapter_priv.sock == NULL) {
+#if (ETF_QUEUEMODE)
+		adapter_stop_thread();
+#endif
+		adapter_deinit_msgbuf();
+		etf_printk(XRADIO_DBG_ERROR, "%s netlink_kernel_create failed\n", __func__);
+		return NULL;
+	}
+
+	return &adapter_priv;
+}
+
+void xradio_adapter_deinit(void)
+{
+	if (adapter_priv.sock != NULL) {
+		netlink_kernel_release(adapter_priv.sock);
+		adapter_priv.sock = NULL;
+	}
+#if (ETF_QUEUEMODE)
+	adapter_stop_thread();
+#endif
+	adapter_deinit_msgbuf();
+}
+
+
+/********************* interfaces of etf core **********************/
+static struct xradio_etf etf_priv;
+static struct etf_api_context context_save;
+
+int wsm_etf_cmd(struct xradio_common *hw_priv, struct wsm_hdr *arg);
+int xradio_bh_suspend(struct xradio_common *hw_priv);
+int xradio_bh_resume(struct xradio_common *hw_priv);
+
+void etf_adapter_version_init(struct xradio_etf *priv)
+{
+	priv->version = 0;
+	priv->version |= ADAPTER_MAIN_VER << 24;
+	priv->version |= ADAPTER_SUB_VER  << 16;
+	priv->version |= ADAPTER_REV_VER  << 0;
+}
+
+static int  etf_check_version(u32 ver)
+{
+	u16 rev_ver  = (u16)((ver >> 0)  & 0xffff);
+	u8  sub_ver  = (u8)((ver >> 16) & 0xff);
+	u8  main_ver = (u8)((ver >> 24) & 0xff);
+
+	etf_printk(XRADIO_DBG_NIY, "[%s] version: %d.%d.%d\n",
+				    __func__, main_ver, sub_ver, rev_ver);
+	if (main_ver >= 128 || sub_ver >= 200 || rev_ver >= 512)
+		goto out;
+
+	if (main_ver > REF_ETF_MAIN_VER) {
+		return 1;
+	} else if (main_ver == REF_ETF_MAIN_VER && sub_ver > REF_ETF_SUB_VER) {
+		return 1;
+	} else if (main_ver == REF_ETF_MAIN_VER && sub_ver >= REF_ETF_SUB_VER &&
+				    rev_ver >= REF_ETF_REV_VER) {
+		return 1;
+	}
+
+out:
+	etf_printk(XRADIO_DBG_WARN, "*************************************\n");
+	etf_printk(XRADIO_DBG_WARN, "     etf cli version is too low\n");
+	etf_printk(XRADIO_DBG_WARN, "    %d.%d.%d or above is recommended.\n",
+			    REF_ETF_MAIN_VER, REF_ETF_SUB_VER, REF_ETF_REV_VER);
+	etf_printk(XRADIO_DBG_WARN, "*************************************\n");
+
+	return 0;
+}
+
+static int etf_alloc_cli_buffer(u32 req_len, struct xradio_etf *priv)
+{
+	int ret = 0;
+
+	if (req_len && req_len > priv->cli_data_len) {
+		if (priv->cli_data) {
+			kfree(priv->cli_data);
+			priv->cli_data = NULL;
+		}
+
+		priv->cli_data = kmalloc(req_len, GFP_KERNEL);
+		if (!priv->cli_data) {
+			ret = EBUSY;
+			etf_printk(XRADIO_DBG_ERROR,
+			    "%s: can't allocate cli_data buffer!\n", __func__);
+		}
+		memset(priv->cli_data, 0, req_len);
+		priv->cli_data_len = req_len;
+		ret = 0;
+	} else {
+		if (req_len && req_len <= priv->cli_data_len)
+			etf_printk(XRADIO_DBG_ALWY,
+				"%s: cli_data buffer is ready.\n", __func__);
+		else
+			etf_printk(XRADIO_DBG_WARN,
+				"%s: req_len = %d, priv->cli_data_len = %d.\n",
+				__func__, req_len, priv->cli_data_len);
+	}
+
+	return ret;
+}
+
+static void etf_free_cli_buffer(struct xradio_etf *priv)
+{
+	if (priv->cli_data) {
+		kfree(priv->cli_data);
+		priv->cli_data = NULL;
+		priv->cli_data_len = 0;
+	}
+}
+
+bool etf_is_connect(void)
+{
+	return (bool)(etf_priv.etf_state != ETF_STAT_NULL);
+}
+
+void etf_set_core(void *core_priv)
+{
+	etf_priv.core_priv = core_priv;
+}
+
+const char *etf_get_fwpath(void)
+{
+	return (const char *)etf_priv.fw_path;
+}
+
+const char *etf_get_sddpath(void)
+{
+	return (const char *)etf_priv.sdd_path;
+}
+
+void etf_set_fwpath(const char *fw_path)
+{
+	etf_priv.fw_path = fw_path;
+}
+
+void etf_set_sddpath(const char *sdd_path)
+{
+	etf_priv.sdd_path = sdd_path;
+}
+
+
+static int etf_get_sdd_param(u8 *sdd, int sdd_len, u8 ies, void **data)
+{
+	int ie_len = 0;
+	int parsedLength = 0;
+	struct xradio_sdd *pElement = NULL;
+	etf_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	/*parse SDD config.*/
+	pElement = (struct xradio_sdd *)sdd;
+
+	while (parsedLength < sdd_len) {
+		if (pElement->id == ies) {
+			*data = (void *)pElement->data;
+			ie_len = pElement->length;
+		}
+		parsedLength += (FIELD_OFFSET(struct xradio_sdd, data) + \
+						pElement->length);
+		pElement = FIND_NEXT_ELT(pElement);
+	}
+
+	xradio_dbg(XRADIO_DBG_MSG, "parse len=%d, ie_len=%d.\n",
+				parsedLength, ie_len);
+	return ie_len;
+}
+
+static int etf_driver_resp(int state, int result)
+{
+	struct drv_resp drv_ret;
+	drv_ret.len    = sizeof(drv_ret);
+	drv_ret.id     = ETF_DRIVER_IND_ID;
+	drv_ret.state  = state;
+	drv_ret.result = result;
+	return xradio_adapter_send(&drv_ret, drv_ret.len);
+}
+
+static int xradio_etf_connect(void)
+{
+	int ret = BOOT_SUCCESS;
+	etf_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (etf_priv.etf_state == ETF_STAT_NULL) {
+		etf_priv.etf_state = ETF_STAT_CONNECTING;
+		ret = xradio_core_init();
+		if (ret) {
+			etf_printk(XRADIO_DBG_ERROR, "%s:xradio_core_init failed(%d).\n",
+						__func__, ret);
+			goto err;
+		}
+		etf_priv.etf_state = ETF_STAT_CONNECTED;
+	} else {
+		etf_printk(XRADIO_DBG_WARN, "%s etf is already connect.\n", __func__);
+		return ETF_ERR_CONNECTED;
+	}
+	etf_printk(XRADIO_DBG_ALWY, "%s:ETF connect success.\n", __func__);
+	return 0;
+
+err:
+	etf_priv.etf_state = ETF_STAT_NULL;
+	return ret;
+}
+
+static void xradio_etf_disconnect(void)
+{
+	etf_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	if (etf_priv.etf_state != ETF_STAT_NULL) {
+		xradio_core_deinit();
+		etf_priv.etf_state = ETF_STAT_NULL;
+	}
+	etf_printk(XRADIO_DBG_ALWY, "%s end.\n", __func__);
+}
+
+
+#if DGB_XRADIO_HWT
+//HWT
+extern u8  hwt_testing;
+extern u8 hwt_tx_en;
+extern u8 hwt_tx_cfm;	/*confirm interval*/
+extern u16 hwt_tx_len;
+extern u16 hwt_tx_num;
+
+extern u8 hwt_rx_en;
+extern u16 hwt_rx_len;
+extern u16 hwt_rx_num;
+extern struct timeval hwt_start_time;
+
+typedef struct HWT_PARAM_ENC_S {
+	u16 Msglen;
+	u16 MsgID;
+	u16 TestID;
+	u16 Params;
+	u16 Datalen;
+	u16 Data[2];
+} HWT_PARAMENC;
+
+int wsm_hwt_cmd(struct xradio_common *hw_priv, void *arg,	size_t arg_size);
+int HWT_Tx_handle(HWT_PARAMETERS *cmd)
+{
+	etf_printk(XRADIO_DBG_TRC, "%s: MsgID=0x%04X, MsgLen=%d, TestID=%d, params=%d, datalen=%d\n", __func__,
+			cmd->MsgID, cmd->Msglen, cmd->TestID, cmd->Params, cmd->Data);
+	if (hwt_testing) {
+		xradio_dbg(XRADIO_DBG_ALWY, "cmd refuse, hwt is testing!\n");
+		return 0;
+	}
+	if (cmd->TestID == 0x1) {
+		hwt_tx_len = cmd->Data;
+		hwt_tx_num = cmd->Params;
+		hwt_tx_cfm = 1;//16;   Be sure about the firmware has been using 16 buf when this value is set to 16
+		hwt_tx_en = 1;
+		hwt_testing = 1;
+
+		xradio_dbg(XRADIO_DBG_ALWY,
+			   "hwt_tx_en=%d, hwt_tx_len=%d, hwt_tx_num=%d, hwt_tx_cfm=%d\n",
+			   hwt_tx_en, hwt_tx_len, hwt_tx_num, hwt_tx_cfm);
+
+		if (!((struct xradio_common *)etf_priv.core_priv)->bh_error &&
+			  atomic_add_return(1, &((struct xradio_common *)etf_priv.core_priv)->bh_tx) == 1)
+			wake_up(&((struct xradio_common *)etf_priv.core_priv)->bh_wq);
+	} else if (cmd->TestID == 0x2) {
+		hwt_rx_len = cmd->Data;
+		hwt_rx_num = cmd->Params;
+		hwt_rx_en = 1;
+		hwt_testing = 1;
+
+		xradio_dbg(XRADIO_DBG_ALWY,
+			   "hwt_rx_en=%d, hwt_rx_len=%d, hwt_rx_num=%d\n", hwt_rx_en,
+			   hwt_rx_len, hwt_rx_num);
+
+		wsm_hwt_cmd((struct xradio_common *)etf_priv.core_priv, (void *)&cmd->TestID, sizeof(HWT_PARAMETERS));
+		xr_do_gettimeofday(&hwt_start_time);
+
+	} else if (cmd->TestID == 0x3) {
+		xradio_dbg(XRADIO_DBG_ALWY, "pkt_num=%d, pkt_len=%d, enc_data=0x%04X\n",
+			   cmd->Params, ((HWT_PARAMENC *)cmd)->Data[0], ((HWT_PARAMENC *)cmd)->Data[1]);
+		hwt_testing = 1;
+		wsm_hwt_cmd((struct xradio_common *)etf_priv.core_priv, (void *)&cmd->TestID, sizeof(HWT_PARAMETERS)+2);
+	} else if (cmd->TestID == 0x4) {
+		hwt_testing = 1;
+		wsm_hwt_cmd((struct xradio_common *)etf_priv.core_priv, (void *)&cmd->TestID, sizeof(HWT_PARAMETERS));
+	} else {
+	}
+	return 0;
+}
+#endif
+static int xradio_etf_proc(void *data, int len)
+{
+	int ret = BOOT_SUCCESS;
+	struct wsm_hdr *hdr_rev = (struct wsm_hdr *)data;
+	struct drv_download *download;
+	int    datalen;
+	etf_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	down(&etf_priv.etf_lock);
+	/* Don't process ETF cmd in wlan mode */
+	if (etf_priv.is_wlan) {
+		etf_printk(XRADIO_DBG_WARN, "%s is in wlan mode.\n", __func__);
+		ret = ETF_ERR_WLAN_MODE;
+		etf_driver_resp(BOOT_STATE_NULL, ret);
+		goto out;
+	}
+
+	/* Process msg from ETF API */
+	switch (MSG_ID(hdr_rev->id)) {
+	case ETF_SOFT_RESET_REQ_ID:
+		etf_printk(XRADIO_DBG_ALWY, "SOFT_RESET\n");
+		xradio_etf_disconnect();
+		etf_priv.fw_path   = NULL;
+		etf_priv.sdd_path  = NULL;
+		etf_priv.seq_send  = 0;
+		etf_priv.seq_recv  = 0;
+		memset(&context_save, 0, sizeof(context_save));
+		etf_driver_resp(BOOT_STATE_NULL, BOOT_SUCCESS);
+		break;
+	case ETF_GET_API_CONTEXT_ID: /* for ETF tools which cannot save context*/
+		{
+			struct etf_api_context_result *ctxt_ret = NULL;
+			struct xradio_common *hw_priv = etf_priv.core_priv;
+			ctxt_ret = (struct etf_api_context_result *)hdr_rev;
+			if (hw_priv) {
+				ctxt_ret->is_etf_fw_run = hw_priv->wsm_caps.firmwareReady;
+				memcpy(ctxt_ret->fw_label, hw_priv->wsm_caps.fw_label,
+					min(HI_SW_LABEL_MAX, WSM_FW_LABEL));
+				ctxt_ret->fw_api_ver = hw_priv->wsm_caps.firmwareApiVer;
+				ctxt_ret->mib_baseaddr = context_save.config[1];
+			} else {
+				ctxt_ret->is_etf_fw_run = 0;
+				memset(ctxt_ret->fw_label, 0, HI_SW_LABEL_MAX);
+			}
+			ctxt_ret->len = sizeof(*ctxt_ret);
+			ctxt_ret->id |= ETF_CNF_BASE;
+			ctxt_ret->result = 0;
+			xradio_adapter_send(ctxt_ret, sizeof(*ctxt_ret));
+		}
+		break;
+	case ETF_DOWNLOAD_ID:
+		etf_printk(XRADIO_DBG_NIY, "DOWNLOAD_FW, size=%d\n", hdr_rev->len);
+		download = (struct drv_download *)(hdr_rev + 1);
+		datalen = hdr_rev->len - sizeof(*download) - sizeof(*hdr_rev);
+		if (datalen <= 0) {
+			/*it means old version APK, TODO:remove it in future */
+			if (hdr_rev->len <= sizeof(*hdr_rev)) {
+				etf_driver_resp(BOOT_COMPLETE, BOOT_SUCCESS);
+				ret = xradio_etf_connect();
+				if (ret)
+					etf_driver_resp(BOOT_STATE_NULL, ret);
+			}
+			break;
+		}
+		if (download->flags & DOWNLOAD_F_PATH_ONLY) {
+			etf_printk(XRADIO_DBG_WARN, "fw path=%s\n", (char *)(download+1));
+			/*TODO: set etf_priv.fw_path*/
+
+		} else if (download->flags & DOWNLOAD_F_START) {
+			etf_printk(XRADIO_DBG_NIY, "fw first block\n");
+			/*TODO: open a tmp file to save firmware */
+		}
+
+		/*TODO: put data into a tmp file */
+
+		/*TODO: put data into a tmp file */
+		if ((download->flags & DOWNLOAD_F_END)) {
+			etf_printk(XRADIO_DBG_NIY, "fw last block\n");
+			etf_driver_resp(BOOT_COMPLETE, BOOT_SUCCESS);
+			/*TODO: save data tmp file and update etf_priv.fw_path*/
+			ret = xradio_etf_connect();
+			if (ret)
+				etf_driver_resp(BOOT_STATE_NULL, ret);
+		}
+		break;
+	case ETF_DOWNLOAD_SDD_ID:
+		etf_printk(XRADIO_DBG_NIY, "DOWNLOAD_SDD, size=%d\n", hdr_rev->len);
+		download = (struct drv_download *)(hdr_rev + 1);
+		datalen = hdr_rev->len - sizeof(*download) - sizeof(*hdr_rev);
+		if (datalen <= 0) {
+			/*it means old version APK, TODO:remove it in future */
+			if (hdr_rev->len <= sizeof(*hdr_rev)) {
+				etf_driver_resp(BOOT_SDD_COMPLETE, BOOT_SUCCESS);
+			}
+			break;
+		}
+
+		if (download->flags & DOWNLOAD_F_PATH_ONLY) {
+			etf_printk(XRADIO_DBG_WARN, "sdd path=%s\n", (char *)(download+1));
+			/*TODO: set etf_priv.fw_path*/
+
+		} else if ((download->flags & DOWNLOAD_F_START)) {
+			etf_printk(XRADIO_DBG_NIY, "sdd first block\n");
+			/*TODO: open a tmp file to save firmware */
+		}
+
+		/*TODO: put data into a tmp file */
+
+		if ((download->flags & DOWNLOAD_F_END)) {
+			etf_printk(XRADIO_DBG_NIY, "sdd last block\n");
+			etf_driver_resp(BOOT_SDD_COMPLETE, BOOT_SUCCESS);
+			/*TODO: save data tmp file and update etf_priv.sdd_path*/
+		}
+		break;
+	case ETF_CONNECT_ID:
+		{
+			ETF_CONNECT_REQ_T *connect_req = (ETF_CONNECT_REQ_T *)hdr_rev;
+
+			etf_printk(XRADIO_DBG_ALWY, "ETF_CONNECT_ID!\n");
+			etf_driver_resp(BOOT_COMPLETE, BOOT_SUCCESS);
+			ret = xradio_etf_connect();
+			if (ret)
+				etf_driver_resp(BOOT_STATE_NULL, ret);
+
+			if (etf_check_version(connect_req->version)) {
+				ret = etf_alloc_cli_buffer(connect_req->data_len, &etf_priv);
+				if (ret)
+					etf_driver_resp(BOOT_STATE_NULL, ret);
+			}
+		}
+		break;
+	case ETF_DISCONNECT_ID:
+		etf_printk(XRADIO_DBG_ALWY, "ETF_DISCONNECT_ID!\n");
+		xradio_etf_disconnect();
+		etf_free_cli_buffer(&etf_priv);
+		etf_driver_resp(BOOT_STATE_NULL, BOOT_SUCCESS);
+		break;
+	case ETF_RECONNECT_ID:
+		{
+			ETF_CONNECT_REQ_T *reconnect_req = (ETF_CONNECT_REQ_T *)hdr_rev;
+
+			etf_printk(XRADIO_DBG_ALWY, "ETF_RECONNECT_ID!\n");
+			xradio_etf_disconnect();
+			etf_driver_resp(BOOT_COMPLETE, BOOT_SUCCESS);
+			ret = xradio_etf_connect();
+			if (ret)
+				etf_driver_resp(BOOT_STATE_NULL, ret);
+
+			if (etf_check_version(reconnect_req->version)) {
+				ret = etf_alloc_cli_buffer(reconnect_req->data_len, &etf_priv);
+				if (ret)
+					etf_driver_resp(BOOT_STATE_NULL, ret);
+			}
+		}
+		break;
+	case ETF_GET_SDD_POWER_DEFT:  /* get default tx power */
+		{
+			const struct firmware *sdd = NULL;
+			etf_printk(XRADIO_DBG_NIY, "%s ETF_GET_SDD_POWER_DEFT!\n", __func__);
+
+			ret = request_firmware(&sdd, etf_get_sddpath(), NULL);
+			/* get sdd data */
+			if (likely(sdd) && likely(sdd->data)) {
+				int i;
+				u16  *outpower = (u16 *)(hdr_rev + 1);
+				void *ie_data = NULL;
+				int ie_len = etf_get_sdd_param((u8 *)sdd->data, sdd->size,
+								SDD_MAX_OUTPUT_POWER_2G4_ELT_ID, &ie_data);
+				if (ie_len > 0 && ie_data &&
+				   ie_len < (ADAPTER_RX_BUF_LEN - sizeof(*hdr_rev))) {
+					memcpy(outpower, ie_data, ie_len);
+					for (i = 0; i < (ie_len>>1); i++)
+						outpower[i] -= 48; /*default pwr = max power - 48*/
+				}
+				hdr_rev->len = sizeof(*hdr_rev) + ie_len;
+				xradio_adapter_send(hdr_rev, hdr_rev->len);
+				release_firmware(sdd);
+			} else {
+				etf_printk(XRADIO_DBG_ERROR, "%s: can't load sdd file %s.\n",
+							__func__, etf_get_sddpath());
+				ret = -ENOENT;
+				hdr_rev->len = sizeof(*hdr_rev);
+				xradio_adapter_send(hdr_rev, sizeof(*hdr_rev));
+			}
+		}
+		break;
+	case ETF_GET_SDD_PARAM_ID:
+		{
+			struct xradio_common *hw_priv = etf_priv.core_priv;
+			struct get_sdd_param_req *sddreq = (struct get_sdd_param_req *)hdr_rev;
+			struct get_sdd_result *sddret = (struct get_sdd_result *)sddreq;
+			void *ie_data = NULL;
+			int ie_len = 0;
+			const struct firmware *sdd = NULL;
+			etf_printk(XRADIO_DBG_NIY, "%s ETF_GET_SDD_PARAM_ID!\n", __func__);
+
+			if (hw_priv && hw_priv->sdd) {
+				etf_printk(XRADIO_DBG_NIY, "%s use xradio_common sdd!\n", __func__);
+				sdd = hw_priv->sdd;
+			} else {
+				ret = request_firmware(&sdd, etf_get_sddpath(), NULL);
+			}
+
+			hdr_rev->id  = hdr_rev->id + ETF_CNF_BASE;
+			if (likely(sdd) && likely(sdd->data)) {
+				if (sddreq->flags & FLAG_GET_SDD_ALL) {
+					sddret->result  = 0;
+					sddret->length  = sdd->size;
+					xradio_adapter_send_pkg(sddret, sizeof(*sddret), (u8 *)sdd->data,
+							sddret->length);
+				} else {
+					ie_len = etf_get_sdd_param((u8 *)sdd->data, sdd->size,
+								sddreq->ies, &ie_data);
+					if (ie_data && ie_len > 0) {
+						sddret->result  = 0;
+						sddret->length  = ie_len;
+						hdr_rev->len = sizeof(*sddret) + sddret->length;
+						xradio_adapter_send_pkg(sddret, sizeof(*sddret), ie_data,
+								sddret->length);
+					} else {
+						sddret->result = -ENOMSG;
+						sddret->length = 0;
+						hdr_rev->len = sizeof(*sddret) + sddret->length;
+						xradio_adapter_send(sddret, sizeof(*sddret));
+					}
+				}
+				if (hw_priv && hw_priv->sdd) {
+					sdd = NULL;
+				} else {
+					release_firmware(sdd);
+				}
+			} else {
+				etf_printk(XRADIO_DBG_ERROR, "%s: can't load sdd file %s.\n",
+							__func__, etf_get_sddpath());
+				sddret->result = -ENOENT;
+				sddret->length = 0;
+				hdr_rev->len = sizeof(*sddret) + sddret->length;
+				xradio_adapter_send(sddret, sizeof(*sddret));
+			}
+		}
+		break;
+	case ETF_SET_CLI_PAR_DEFT:
+		{
+			CLI_PARAM_SAVE_T *hdr_data = (CLI_PARAM_SAVE_T *)hdr_rev;
+			ETF_PARAM0 hdr_ret;
+
+			etf_printk(XRADIO_DBG_NIY, "%s ETF_SET_CLI_PAR_DEFT!\n", __func__);
+			hdr_ret.MsgId = hdr_rev->id + ETF_CNF_BASE;
+			hdr_ret.MsgLen = sizeof(ETF_PARAM0);
+
+			if (etf_check_version(hdr_data->version)) {
+				if (etf_priv.cli_data && hdr_data->data_len == etf_priv.cli_data_len) {
+					memset(etf_priv.cli_data, 0, hdr_data->data_len);
+					memcpy(etf_priv.cli_data,
+						    hdr_data->data, hdr_data->data_len);
+					hdr_ret.result = BOOT_SUCCESS;
+				} else {
+					etf_printk(XRADIO_DBG_ALWY,
+						"%s support_len = %d req_len = %d\n",
+						__func__, etf_priv.cli_data_len, hdr_data->data_len);
+					hdr_ret.result = BOOT_ERR_BAD_OP;
+				}
+			} else {
+					hdr_ret.result = ETF_ERR_CHECK_VERSION;
+			}
+
+			xradio_adapter_send(&hdr_ret, hdr_ret.MsgLen);
+		}
+		break;
+	case ETF_GET_CLI_PAR_DEFT:
+		{
+			struct get_cli_data_s *hdr_data;
+
+			hdr_data = (struct get_cli_data_s *)hdr_rev;
+			etf_printk(XRADIO_DBG_NIY, "%s ETF_GET_CLI_PAR_DEFT!\n", __func__);
+			hdr_rev->id  = hdr_rev->id + ETF_CNF_BASE;
+			if (etf_check_version(hdr_data->version)) {
+				hdr_data->result   = BOOT_SUCCESS;
+				hdr_data->data_len = etf_priv.cli_data_len;
+				hdr_data->version  = etf_priv.version;
+				hdr_data->msg_len  = sizeof(struct get_cli_data_s) + hdr_data->data_len;
+				xradio_adapter_send_pkg(hdr_data, sizeof(struct get_cli_data_s),
+						(void *)etf_priv.cli_data, hdr_data->data_len);
+			} else {
+				hdr_data->result = ETF_ERR_CHECK_VERSION;
+				hdr_data->data_len = 0;
+				hdr_data->version  = etf_priv.version;
+				hdr_data->msg_len  = sizeof(struct get_cli_data_s);
+				xradio_adapter_send(hdr_data, hdr_data->msg_len);
+			}
+		}
+		break;
+	case ETF_GET_SDD_PATH_ID:
+		{
+			struct get_sdd_patch_req *param_req;
+			struct get_sdd_patch_ret *param_ret;
+			const char *sdd_path = etf_get_sddpath();
+
+			param_req = (struct get_sdd_patch_req *)hdr_rev;
+			param_ret = (struct get_sdd_patch_ret *)param_req;
+			etf_printk(XRADIO_DBG_NIY, "%s ETF_GET_SDD_PATH_ID!\n", __func__);
+
+			hdr_rev->id  = hdr_rev->id + ETF_CNF_BASE;
+			param_ret->result = BOOT_SUCCESS;
+			param_ret->length = strlen(sdd_path);
+			hdr_rev->len = sizeof(*param_ret) + param_ret->length;
+			xradio_adapter_send_pkg(param_ret, sizeof(*param_ret),
+					(void *)sdd_path, param_ret->length);
+		}
+		break;
+	default:
+		etf_printk(XRADIO_DBG_NIY, "%s: passed cmd=0x%04x, len=%d",
+					__func__, MSG_ID(hdr_rev->id), hdr_rev->len);
+		if (etf_priv.etf_state != ETF_STAT_CONNECTED) {
+			etf_printk(XRADIO_DBG_WARN, "%s etf Not connect.\n", __func__);
+			ret = ETF_ERR_NOT_CONNECT;
+			etf_driver_resp(BOOT_STATE_NULL, ret);
+			goto out;
+		}
+		if (SEQ_MASK(etf_priv.seq_send) != MSG_SEQ(hdr_rev->id)) {
+			etf_printk(XRADIO_DBG_NIY, "%s:seq err, drv_seq=%d, seq=%d\n",
+						__func__, etf_priv.seq_send, MSG_SEQ(hdr_rev->id));
+			etf_priv.seq_send = MSG_SEQ(hdr_rev->id);
+		}
+		etf_priv.seq_send++;
+		if (ETF_HWT_REQ == MSG_ID(hdr_rev->id)) {
+			/*TODO: HW test*/
+#if DGB_XRADIO_HWT
+			HWT_Tx_handle((HWT_PARAMETERS *)data);
+#else
+			etf_printk(XRADIO_DBG_ERROR, "%s HW test unsupport\n", __func__);
+#endif
+		} else if (etf_priv.core_priv) {
+			if (ETF_DOWNLOAD_SDD == MSG_ID(hdr_rev->id) &&
+			    hdr_rev->len <= sizeof(struct etf_sdd_req)) {
+				struct xradio_common *hw_priv = etf_priv.core_priv;
+				struct etf_sdd_req *sdd_req = (struct etf_sdd_req *)hdr_rev;
+				u32 sdd_cmd = sdd_req->sdd_cmd;
+
+				etf_printk(XRADIO_DBG_NIY, "%s add sdd data, cmd=0x%08x!\n",
+							__func__, sdd_cmd);
+				if (hw_priv->sdd) {
+					u8 *sdd_data = (u8 *)(hdr_rev + 1);
+					int sdd_len  = hw_priv->sdd->size;
+					if (sdd_len + sizeof(*hdr_rev) + 4 < ADAPTER_RX_BUF_LEN) {
+						memcpy(sdd_data, hw_priv->sdd->data, sdd_len);
+						memcpy(sdd_data + sdd_len, &sdd_cmd, 4);
+						hdr_rev->len += sdd_len;
+					} else {
+						etf_printk(XRADIO_DBG_ERROR,
+									"ADAPTER_RX_BUF_LEN=%d, sdd_len=%d\n",
+									 ADAPTER_RX_BUF_LEN, sdd_len);
+					}
+				} else
+					etf_printk(XRADIO_DBG_ERROR, "%s core_priv sdd is NULL\n",
+							__func__);
+			}
+			/* send to device*/
+			ret = wsm_etf_cmd(etf_priv.core_priv, (struct wsm_hdr *)data);
+			if (ret < 0) {
+				etf_driver_resp(BOOT_STATE_NULL, ret);
+				etf_printk(XRADIO_DBG_ERROR, "%s wsm_etf_cmd failed(%d)\n",
+							__func__, ret);
+			}
+		} else {
+			etf_printk(XRADIO_DBG_ERROR, "%s core_priv is NULL\n",
+						__func__);
+		}
+		break;
+	}
+	up(&etf_priv.etf_lock);
+	etf_printk(XRADIO_DBG_NIY, "%s success\n", __func__);
+	return 0;
+
+out:
+	up(&etf_priv.etf_lock);
+	if (ret)
+		etf_printk(XRADIO_DBG_ERROR, "%s proc failed(%d)\n", __func__, ret);
+	return ret;
+}
+
+int xradio_etf_from_device(struct sk_buff **skb)
+{
+	int ret = 0;
+	struct wsm_hdr *wsm = (struct wsm_hdr *)((*skb)->data);
+	etf_printk(XRADIO_DBG_NIY, "%s MsgId=0x%04x, len=%d\n", __func__,
+			   wsm->id, wsm->len);
+	ret = xradio_adapter_send((void *)wsm, wsm->len);
+	if (ret < 0) {
+		etf_printk(XRADIO_DBG_ERROR, "%s xradio_adapter_send failed(%d).\n",
+					__func__, ret);
+	} else {
+		etf_priv.seq_recv++;
+	}
+	return 0;
+}
+
+void xradio_etf_save_context(void *buf, int len)
+{
+	etf_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	if (len == sizeof(context_save)) {
+		etf_printk(XRADIO_DBG_NIY, "%s, len=%d\n", __func__, len);
+		memcpy(&context_save, buf, sizeof(context_save));
+	} else if (len > sizeof(context_save)) {
+		etf_printk(XRADIO_DBG_WARN, "%s, len=%d\n", __func__, len);
+		memcpy(&context_save, buf, sizeof(context_save));
+	} else {
+		etf_printk(XRADIO_DBG_ERROR, "%s, len too short=%d\n", __func__, len);
+	}
+}
+
+void xradio_etf_to_wlan(u32 change)
+{
+	down(&etf_priv.etf_lock);
+	etf_priv.is_wlan = change;
+	if (change && etf_is_connect()) {
+		etf_printk(XRADIO_DBG_NIY, "%s change to wlan.\n", __func__);
+		xradio_etf_disconnect();
+	}
+	up(&etf_priv.etf_lock);
+}
+
+int xradio_etf_suspend(void)
+{
+	etf_printk(XRADIO_DBG_NIY, "%s\n", __func__);
+	if (down_trylock(&etf_priv.etf_lock)) {
+		etf_printk(XRADIO_DBG_WARN,
+			"%s etf_lock is locked\n", __func__);
+		return -EBUSY; /*etf is locked.*/
+	}
+	if (etf_is_connect()) {
+		etf_printk(XRADIO_DBG_WARN,
+			"%s etf is running, don't suspend!\n", __func__);
+		up(&etf_priv.etf_lock);
+		return -EBUSY; /*etf is running*/
+	}
+	up(&etf_priv.etf_lock);
+	return 0;
+}
+
+int xradio_etf_resume(void)
+{
+	etf_printk(XRADIO_DBG_NIY, "%s\n", __func__);
+	return 0;
+}
+
+int xradio_etf_init(void)
+{
+	int ret = 0;
+	etf_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	sema_init(&etf_priv.etf_lock, 1);
+	etf_priv.etf_state = ETF_STAT_NULL;
+	etf_priv.fw_path  = NULL;
+	etf_priv.sdd_path = NULL;
+	etf_priv.adapter = xradio_adapter_init(&xradio_etf_proc);
+	etf_adapter_version_init(&etf_priv);
+	return ret;
+}
+
+void xradio_etf_deinit(void)
+{
+	etf_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	/*ensure in disconnect state when etf deinit*/
+	xradio_etf_to_wlan(1);
+	etf_free_cli_buffer(&etf_priv);
+	xradio_adapter_deinit();
+	memset(&etf_priv, 0, sizeof(etf_priv));
+}
+
+#endif /*XRADIO_ETF_C*/
diff -Naurp a/drivers/net/wireless/xr829/wlan/etf.h b/drivers/net/wireless/xr829/wlan/etf.h
--- a/drivers/net/wireless/xr829/wlan/etf.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/etf.h	2022-08-27 01:22:42.966539908 +0300
@@ -0,0 +1,273 @@
+/*
+ * Common interfaces for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef XRADIO_ETF_H
+#define XRADIO_ETF_H
+#include <linux/version.h>
+
+/* ETF Adapter layer */
+#define  NL_FOR_XRADIO  30
+/*
+ * When queue mode is enable, user space operate is non-block if items in rx_pool,
+ * but it may sleep and will drop msg when rx_pool is empty for a long time.
+ * When queue mode is disable, user space operate is block and user packet
+ * will not be drop, but driver can be panic if etf cli be kill during operate.
+ * So, for more safe in driver, enable this by default.
+ */
+#define  ETF_QUEUEMODE  1
+#define  ETF_QUEUE_TIMEOUT 50 /* about 2s.*/
+
+#define  ADAPTER_RX_BUF_LEN  (528*3) /* pay respect for SDIO_BLOCK_SIZE*/
+#if (ETF_QUEUEMODE)
+#define  ADAPTER_ITEM_MAX    (32)
+#define  XRADIO_ADAPTER  ("xradio_etf")
+struct  adapter_item {
+	struct list_head head;
+	void   *skb;
+};
+#endif
+
+typedef int (*msg_proc)(void *data, int len);
+struct xradio_adapter {
+	struct sock *sock;
+	msg_proc  handler;
+	void     *msg_buf;
+	int       msg_len;
+#if (ETF_QUEUEMODE)
+	struct adapter_item rx_items[ADAPTER_ITEM_MAX];
+	struct list_head rx_queue;
+	struct list_head rx_pool;
+	spinlock_t  recv_lock;
+	atomic_t    rx_cnt;
+	struct semaphore proc_sem;
+	struct task_struct *thread_tsk;
+	int    exit;
+#endif
+	int       send_pid;
+	struct    semaphore send_lock;
+};
+
+/* ETF internal connect state*/
+#define ETF_STAT_NULL        0
+#define ETF_STAT_CONNECTING  1
+#define ETF_STAT_CONNECTED   2
+
+#define ADAPTER_MAIN_VER 1
+#define ADAPTER_SUB_VER  1
+#define ADAPTER_REV_VER  2
+
+#define REF_ETF_MAIN_VER 2
+#define REF_ETF_SUB_VER  0
+#define REF_ETF_REV_VER  5
+
+struct xradio_etf {
+	int    etf_state;
+	int    is_wlan;
+	void  *core_priv;
+	struct semaphore etf_lock;
+	struct xradio_adapter *adapter;
+	int    seq_send;
+	int    seq_recv;
+	const u8    *fw_path;
+	const u8    *sdd_path;
+	u8 *cli_data;
+	u8 cli_data_len;
+	u32 version;
+};
+
+/* ETF fw cmd defines*/
+#define  ETF_REQ_BASE               0x0000
+#define  ETF_CNF_BASE               0x0400
+#define  ETF_IND_BASE               0x0800
+#define  ETF_MSG_STARTUP_IND_ID     0x0801
+#define  ETF_DOWNLOAD_SDD          (0x20 + 22)
+#define  ETF_HWT_REQ                0x0004
+struct etf_sdd_req {
+	u16    len;
+	u16    id;
+	u32    sdd_cmd;
+};
+
+typedef enum {
+    ETF_CHANNEL_BANDWIDTH_20MHz,
+    ETF_CHANNEL_BANDWIDTH_10MHz,
+    ETF_CHANNEL_BANDWIDTH_40MHz
+} ETF_CHANNEL_BANDWIDTH_T;
+
+typedef enum {
+    ETF_SUB_CHANNEL_UPPER,
+    ETF_SUB_CHANNEL_LOWER
+} ETF_SUB_CHANNEL_T;
+
+typedef struct ETF_CONNECT_REQ {
+	u16 MsgLen;
+	u16 MsgId;
+	u32 version;
+	u32 data_len;
+} ETF_CONNECT_REQ_T;
+
+typedef struct CLI_PARAM_SAVE_REQ {
+	u16 Msglen;
+	u16 MsgID;
+	u32 result;
+	u32 data_len;
+	u32 version;
+	u8  data[1];
+} CLI_PARAM_SAVE_T;
+
+/* ETF driver cmd defines */
+#define  ETF_DRIVER_CMD_START_ID  (ETF_REQ_BASE + 0x03F0)
+#define  ETF_GET_API_CONTEXT_ID   (ETF_REQ_BASE + 0x03F8)
+#define  ETF_GET_SDD_PARAM_ID     (ETF_REQ_BASE + 0x03F9)
+#define  ETF_CONNECT_ID           (ETF_REQ_BASE + 0x03FA)
+#define  ETF_DISCONNECT_ID        (ETF_REQ_BASE + 0x03FB)
+#define  ETF_RECONNECT_ID         (ETF_REQ_BASE + 0x03FC)
+#define  ETF_DOWNLOAD_SDD_ID      (ETF_REQ_BASE + 0x03FD)
+#define  ETF_DOWNLOAD_ID          (ETF_REQ_BASE + 0x03FE)
+#define  ETF_SOFT_RESET_REQ_ID    (ETF_REQ_BASE + 0x03FF)
+#define  ETF_DRIVER_IND_ID        (ETF_IND_BASE + 0x03FF)
+#define  ETF_GET_SDD_POWER_DEFT   (ETF_REQ_BASE + 0x1FFF)
+#define  ETF_SET_CLI_PAR_DEFT     (ETF_REQ_BASE + 0x03E2)
+#define  ETF_GET_CLI_PAR_DEFT     (ETF_REQ_BASE + 0x03E1)
+#define  ETF_GET_SDD_PATH_ID      (ETF_REQ_BASE + 0x03E3)
+
+#define  FLAG_GET_SDD_ALL         0x1
+
+typedef struct {
+    u16 MsgLen;
+    u16 MsgId;
+    u32 result;
+} ETF_PARAM0;
+
+struct get_sdd_patch_req {
+	u16    len;
+	u16    id;
+	u32    result;
+};
+struct get_sdd_patch_ret {
+	u16    len;
+	u16    id;
+	u32    result;
+	u32    length;
+	/* sdd patch follow */
+};
+struct get_sdd_param_req {
+	u16    len;
+	u16    id;
+	u8     flags;
+	u8     ies;
+};
+struct get_sdd_result {
+	u16    len;
+	u16    id;
+	u32    result;
+	u32    length;
+	/* sdd data follow */
+};
+
+struct get_cli_data_req {
+	u16    len;
+	u16    id;
+	u32    result;
+	u32    version;
+};
+
+struct get_cli_data_s {
+	u16          msg_len;
+	u16          id;
+	u32          result;
+	u32          data_len;
+	u32          version;
+};
+
+struct etf_api_context_req {
+	u16    len;
+	u16    id;
+	u32    param;
+};
+
+#define HI_SW_LABEL_MAX	     128
+struct etf_api_context_result {
+	u16    len;
+	u16    id;
+	u32    result;
+	u8     is_etf_fw_run;
+	u8     reversed[3];
+	u32    mib_baseaddr;
+	u8     fw_label[HI_SW_LABEL_MAX];
+	u16    fw_api_ver;
+};
+
+#define ETF_CONTEXT_OFFSET  (20 + HI_SW_LABEL_MAX)
+#define HI_MAX_CONFIG_TABLES	4
+struct etf_api_context {
+	u32    config[HI_MAX_CONFIG_TABLES];
+};
+
+/* boot State, for download file from GUI */
+#define BOOT_STATE_NULL              0
+#define BOOT_WAITING_DOWNLOAD        1
+#define BOOT_IN_PROGRESS             2
+#define BOOT_COMPLETE                3
+#define BOOT_SDD_COMPLETE            4
+
+/* Driver Result code */
+#define BOOT_SUCCESS                 (0)
+#define BOOT_ERR_DECODE              (1)
+#define BOOT_ERR_CHECKSUM            (2)
+#define BOOT_ERR_FILE_SIZE           (3)
+#define BOOT_ERR_BAD_OP              (4)
+#define ETF_ERR_CONNECTED            (5)
+#define ETF_ERR_WLAN_MODE            (6)
+#define ETF_ERR_NOT_CONNECT          (7)
+#define ETF_ERR_IO_FAILED            (8)
+#define ETF_ERR_DRIVER_HANG          (9)
+#define ETF_ERR_CHECK_VERSION        (10)
+
+struct drv_resp {
+	u16    len;
+	u16    id;
+	u32    state;
+	u32    result;
+};
+
+#define  MSG_ID(x)     ((u16)((x)&0x1fff))
+#define  MSG_SEQ(x)    (((x)>>13)&0x0007)
+#define  SEQ_MASK(x)   ((x) & 0x0007)
+
+#define DOWNLOAD_F_START          0x01
+#define DOWNLOAD_F_END            0x02
+#define DOWNLOAD_F_PATH_ONLY      0x04
+struct drv_download {
+	u32   offset;
+	u32   flags;
+	/* data followed, max size is HI_MEM_BLK_BYTES */
+};
+
+/* ETF interfaces called by WLAN core */
+int xradio_etf_init(void);
+void xradio_etf_deinit(void);
+const char *etf_get_fwpath(void);
+const char *etf_get_sddpath(void);
+void etf_set_fwpath(const char *fw_path);
+void etf_set_sddpath(const char *sdd_path);
+bool etf_is_connect(void);
+void etf_set_core(void *core_priv);
+int xradio_etf_from_device(struct sk_buff **skb);
+void xradio_etf_save_context(void *buf, int len);
+int xradio_etf_suspend(void);
+int xradio_etf_resume(void);
+
+/* External interfaces called by etf */
+extern int  xradio_core_init(void);
+extern void xradio_core_deinit(void);
+
+#endif /*XRADIO_ETF_H*/
diff -Naurp a/drivers/net/wireless/xr829/wlan/fwio.c b/drivers/net/wireless/xr829/wlan/fwio.c
--- a/drivers/net/wireless/xr829/wlan/fwio.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/fwio.c	2022-08-27 01:22:42.966539908 +0300
@@ -0,0 +1,794 @@
+/*
+ * Firmware I/O implementation for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/vmalloc.h>
+#include <linux/sched.h>
+#include <linux/firmware.h>
+#include <linux/time.h>
+
+#include "xradio.h"
+#include "fwio.h"
+#include "hwio.h"
+#include "sbus.h"
+#include "bh.h"
+
+/* Macroses are local. */
+#define APB_WRITE(reg, val) \
+	do { \
+		ret = xradio_apb_write_32(hw_priv, APB_ADDR(reg), (val)); \
+		if (ret < 0) { \
+			xradio_dbg(XRADIO_DBG_ERROR, \
+				"%s: can't write %s at line %d.\n", \
+				__func__, #reg, __LINE__); \
+			goto error; \
+		} \
+	} while (0)
+#define APB_READ(reg, val) \
+	do { \
+		ret = xradio_apb_read_32(hw_priv, APB_ADDR(reg), &(val)); \
+		if (ret < 0) { \
+			xradio_dbg(XRADIO_DBG_ERROR, \
+				"%s: can't read %s at line %d.\n", \
+				__func__, #reg, __LINE__); \
+			goto error; \
+		} \
+	} while (0)
+#define REG_WRITE(reg, val) \
+	do { \
+		ret = xradio_reg_write_32(hw_priv, (reg), (val)); \
+		if (ret < 0) { \
+			xradio_dbg(XRADIO_DBG_ERROR, \
+				"%s: can't write %s at line %d.\n", \
+				__func__, #reg, __LINE__); \
+			goto error; \
+		} \
+	} while (0)
+#define REG_READ(reg, val) \
+	do { \
+		ret = xradio_reg_read_32(hw_priv, (reg), &(val)); \
+		if (ret < 0) { \
+			xradio_dbg(XRADIO_DBG_ERROR, \
+				"%s: can't read %s at line %d.\n", \
+				__func__, #reg, __LINE__); \
+			goto error; \
+		} \
+	} while (0)
+
+static int xradio_get_hw_type(u32 config_reg_val, int *major_revision)
+{
+	int hw_type = -1;
+	u32 hif_type = (config_reg_val >> 24) & 0x4;
+	/*u32 hif_vers = (config_reg_val >> 31) & 0x1;*/
+
+	/* Check if we have XRADIO */
+	if (hif_type == 0x4) {
+		*major_revision = 0x4;
+		hw_type = HIF_HW_TYPE_XRADIO;
+	} else {
+		/*hw type unknown.*/
+		*major_revision = 0x0;
+	}
+	return hw_type;
+}
+
+/*
+ * This function is called to Parse the SDD file
+ * to extract some informations
+ */
+static int xradio_parse_sdd(struct xradio_common *hw_priv, u32 *dpll)
+{
+	int ret = 0;
+	const char *sdd_path = NULL;
+	struct xradio_sdd *pElement = NULL;
+	int parsedLength = 0;
+
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	SYS_BUG(hw_priv->sdd != NULL);
+
+	/* select and load sdd file depend on hardware version. */
+	switch (hw_priv->hw_revision) {
+	case XR829_HW_REV0:
+		sdd_path = XR829_SDD_FILE;
+		break;
+	default:
+		xradio_dbg(XRADIO_DBG_ERROR,
+			   "%s: unknown hardware version.\n", __func__);
+		return ret;
+	}
+
+#ifdef CONFIG_XRADIO_ETF
+	if (etf_is_connect()) {
+		const char *etf_sdd = etf_get_sddpath();
+		if (etf_sdd != NULL)
+			sdd_path = etf_sdd;
+		else
+			etf_set_sddpath(sdd_path);
+	}
+#endif
+	ret = request_firmware(&hw_priv->sdd, sdd_path, hw_priv->pdev);
+	if (unlikely(ret)) {
+		xradio_dbg(XRADIO_DBG_ERROR, "%s: can't load sdd file %s.\n",
+			   __func__, sdd_path);
+		return ret;
+	}
+
+	/*parse SDD config.*/
+	hw_priv->is_BT_Present = false;
+	pElement = (struct xradio_sdd *)hw_priv->sdd->data;
+	parsedLength += (FIELD_OFFSET(struct xradio_sdd, data) + \
+			 pElement->length);
+	pElement = FIND_NEXT_ELT(pElement);
+
+	while (parsedLength < hw_priv->sdd->size) {
+		switch (pElement->id) {
+		case SDD_PTA_CFG_ELT_ID:
+			hw_priv->conf_listen_interval =
+			    (*((u16 *) pElement->data + 1) >> 7) & 0x1F;
+			hw_priv->is_BT_Present = true;
+			xradio_dbg(XRADIO_DBG_NIY,
+				   "PTA element found.Listen Interval %d\n",
+				   hw_priv->conf_listen_interval);
+			break;
+		case SDD_REFERENCE_FREQUENCY_ELT_ID:
+			switch (*((uint16_t *) pElement->data)) {
+			case 0x32C8:
+				*dpll = 0x1D89D241;
+				break;
+			case 0x3E80:
+				*dpll = 0x1E1;
+				break;
+			case 0x41A0:
+				*dpll = 0x124931C1;
+				break;
+			case 0x4B00:
+				*dpll = 0x191;
+				break;
+			case 0x5DC0:
+				*dpll = 0x141;
+				break;
+			case 0x6590:
+				*dpll = 0x0EC4F121;
+				break;
+			case 0x8340:
+				*dpll = 0x92490E1;
+				break;
+			case 0x9600:
+				*dpll = 0x100010C1;
+				break;
+			case 0x9C40:
+				*dpll = 0xC1;
+				break;
+			case 0xBB80:
+				*dpll = 0xA1;
+				break;
+			case 0xCB20:
+				*dpll = 0x7627091;
+				break;
+			default:
+				*dpll = DPLL_INIT_VAL_XRADIO;
+				xradio_dbg(XRADIO_DBG_WARN,
+					   "Unknown Reference clock frequency."
+					   "Use default DPLL value=0x%08x.",
+					    DPLL_INIT_VAL_XRADIO);
+				break;
+			}
+			xradio_dbg(XRADIO_DBG_NIY,
+					"Reference clock=%uKHz, DPLL value=0x%08x.\n",
+					*((uint16_t *) pElement->data), *dpll);
+		default:
+			break;
+		}
+		parsedLength += (FIELD_OFFSET(struct xradio_sdd, data) + \
+				 pElement->length);
+		pElement = FIND_NEXT_ELT(pElement);
+	}
+
+	xradio_dbg(XRADIO_DBG_MSG, "sdd size=%zu parse len=%d.\n",
+		   hw_priv->sdd->size, parsedLength);
+
+
+	if (hw_priv->is_BT_Present == false) {
+		hw_priv->conf_listen_interval = 0;
+		xradio_dbg(XRADIO_DBG_NIY, "PTA element NOT found.\n");
+	}
+	return ret;
+}
+
+int xradio_update_dpllctrl(struct xradio_common *hw_priv, u32 dpll_update)
+{
+	int ret   = 0;
+	u32 val32 = 0;
+	u32 dpll_read = 0;
+	int i = 0;
+
+	xradio_ahb_read_32(hw_priv, PWRCTRL_WLAN_START_CFG, &val32);
+	do {
+		ret = xradio_ahb_read_32(hw_priv, PWRCTRL_WLAN_COMMON_CFG, &val32);
+		/*Check DPLL, return success if sync finish*/
+		if (val32 & PWRCTRL_COMMON_REG_DONE) {
+			xradio_ahb_read_32(hw_priv, PWRCTRL_WLAN_DPLL_CTRL, &dpll_read);
+			if (dpll_update == dpll_read) {
+				xradio_dbg(XRADIO_DBG_NIY, "%s: dpll sync ok=0x%08x.\n",
+					__func__, dpll_read);
+				break;
+			} else {
+				xradio_dbg(XRADIO_DBG_ERROR, "%s: dpll is incorrect, " \
+						"dpll_read=0x%08x, dpll_update=0x%08x.\n",
+					__func__, dpll_read, dpll_update);
+				/*dpll_ctrl need to be corrected it by follow procedure.*/
+			}
+		}
+
+		/*correct dpll_ctrl if wlan is accessible.*/
+		if ((val32 & PWRCTRL_COMMON_REG_ARBT) && /*wait for arbit end.*/
+			!(val32 & PWRCTRL_COMMON_REG_BT)) { /*wlan is accessible.*/
+			xradio_ahb_read_32(hw_priv, PWRCTRL_WLAN_DPLL_CTRL, &dpll_read);
+			if (dpll_update != dpll_read) {
+				xradio_dbg(XRADIO_DBG_WARN,
+					"%s:dpll_read=0x%08x, new dpll_ctrl=0x%08x.\n",
+					__func__, dpll_read, dpll_update);
+				xradio_ahb_write_32(hw_priv,
+					PWRCTRL_WLAN_DPLL_CTRL, (dpll_update|0x1));
+				msleep(5); /*wait for it stable after change DPLL config. */
+			} else {
+				xradio_dbg(XRADIO_DBG_ALWY, "%s: DPLL_CTRL Sync=0x%08x.\n",
+					__func__, dpll_read);
+			}
+			xradio_ahb_write_32(hw_priv, PWRCTRL_WLAN_COMMON_CFG,
+					PWRCTRL_COMMON_REG_DONE); /*set done*/
+			break;
+		} else if (i < 100) {
+			xradio_dbg(XRADIO_DBG_WARN, "%s: COMMON_REG=0x%08x.\n",
+					__func__, val32);
+			msleep(i);
+			++i;
+		} else {
+			xradio_dbg(XRADIO_DBG_ERROR, "%s:DPLL access timeout=0x%08x.\n",
+					__func__, val32);
+			ret = -ETIMEDOUT;
+			break;
+		}
+	} while (!ret);
+	xradio_ahb_write_32(hw_priv, PWRCTRL_WLAN_START_CFG, 0);
+	return ret;
+}
+
+static int xradio_firmware(struct xradio_common *hw_priv)
+{
+	int ret, block, num_blocks;
+	unsigned i;
+	u32 val32;
+	u32 put = 0, get = 0;
+	u8 *buf = NULL;
+	const char *fw_path;
+	const struct firmware *firmware = NULL;
+	xradio_dbg(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	switch (hw_priv->hw_revision) {
+	case XR829_HW_REV0:
+		fw_path = XR829_FIRMWARE;
+#ifdef CONFIG_XRADIO_ETF
+		if (etf_is_connect()) {
+			const char *etf_fw = etf_get_fwpath();
+			if (etf_fw != NULL)
+				fw_path = etf_fw;
+			else {
+				fw_path = XR829_ETF_FIRMWARE;
+				etf_set_fwpath(fw_path);
+			}
+		}
+#endif
+		break;
+	default:
+		xradio_dbg(XRADIO_DBG_ERROR, "%s: invalid silicon revision %d.\n",
+			   __func__, hw_priv->hw_revision);
+		return -EINVAL;
+	}
+
+	/* Initialize common registers */
+	APB_WRITE(DOWNLOAD_IMAGE_SIZE_REG, DOWNLOAD_ARE_YOU_HERE);
+	APB_WRITE(DOWNLOAD_PUT_REG, 0);
+	APB_WRITE(DOWNLOAD_GET_REG, 0);
+	APB_WRITE(DOWNLOAD_STATUS_REG, DOWNLOAD_PENDING);
+	APB_WRITE(DOWNLOAD_FLAGS_REG, 0);
+
+	/* Release CPU from RESET */
+	xradio_reg_bit_operate(hw_priv, HIF_CONFIG_REG_ID,
+						0, HIF_CONFIG_CPU_RESET_BIT);
+	/* Enable Clock */
+	xradio_reg_bit_operate(hw_priv, HIF_CONFIG_REG_ID,
+						0, HIF_CONFIG_CPU_CLK_DIS_BIT);
+
+	/* Load a firmware file */
+	ret = request_firmware(&firmware, fw_path, hw_priv->pdev);
+	if (ret) {
+		xradio_dbg(XRADIO_DBG_ERROR, "%s: can't load firmware file %s.\n",
+			   __func__, fw_path);
+		goto error;
+	}
+	SYS_BUG(!firmware->data);
+
+	buf = xr_kmalloc(DOWNLOAD_BLOCK_SIZE, true);
+	if (!buf) {
+		xradio_dbg(XRADIO_DBG_ERROR,
+			   "%s: can't allocate firmware buffer.\n", __func__);
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	/* Check if the bootloader is ready */
+	for (i = 0; i < 100; i++ /*= 1 + i / 2*/) {
+		APB_READ(DOWNLOAD_IMAGE_SIZE_REG, val32);
+		if (val32 == DOWNLOAD_I_AM_HERE)
+			break;
+		mdelay(10);
+	}			/* End of for loop */
+	if (val32 != DOWNLOAD_I_AM_HERE) {
+		xradio_dbg(XRADIO_DBG_ERROR, "%s: bootloader is not ready.\n",
+			   __func__);
+#ifdef BOOT_NOT_READY_FIX
+		hw_priv->boot_not_ready_cnt++;
+		hw_priv->boot_not_ready = 1;
+#endif
+		ret = -ETIMEDOUT;
+		goto error;
+	}
+
+	/* Calculcate number of download blocks */
+	num_blocks = (firmware->size - 1) / DOWNLOAD_BLOCK_SIZE + 1;
+
+	/* Updating the length in Download Ctrl Area */
+	val32 = firmware->size; /* Explicit cast from size_t to u32 */
+	APB_WRITE(DOWNLOAD_IMAGE_SIZE_REG, val32);
+
+	/*
+	 * DOWNLOAD_BLOCK_SIZE must be divided exactly by sdio blocksize,
+	 * otherwise it may cause bootloader error.
+	 */
+	val32 = hw_priv->sbus_ops->get_block_size(hw_priv->sbus_priv);
+	if (val32 > DOWNLOAD_BLOCK_SIZE || DOWNLOAD_BLOCK_SIZE%val32) {
+		xradio_dbg(XRADIO_DBG_WARN,
+			"%s:change blocksize(%d->%d) during download fw.\n",
+			__func__, val32, DOWNLOAD_BLOCK_SIZE>>1);
+		hw_priv->sbus_ops->lock(hw_priv->sbus_priv);
+		ret = hw_priv->sbus_ops->set_block_size(hw_priv->sbus_priv,
+			DOWNLOAD_BLOCK_SIZE>>1);
+		if (ret)
+			xradio_dbg(XRADIO_DBG_ERROR,
+				"%s: set blocksize error(%d).\n", __func__, ret);
+		hw_priv->sbus_ops->unlock(hw_priv->sbus_priv);
+	}
+
+	/* Firmware downloading loop */
+	for (block = 0; block < num_blocks; block++) {
+		size_t tx_size;
+		size_t block_size;
+
+		/* check the download status */
+		APB_READ(DOWNLOAD_STATUS_REG, val32);
+		if (val32 != DOWNLOAD_PENDING) {
+			xradio_dbg(XRADIO_DBG_ERROR,
+				   "%s: bootloader reported error %d.\n",
+				   __func__, val32);
+			ret = -EIO;
+			goto error;
+		}
+
+		/* calculate the block size */
+		tx_size = block_size = min((size_t)(firmware->size - put),
+					   (size_t)DOWNLOAD_BLOCK_SIZE);
+		memcpy(buf, &firmware->data[put], block_size);
+		if (block_size < DOWNLOAD_BLOCK_SIZE) {
+			memset(&buf[block_size], 0, DOWNLOAD_BLOCK_SIZE - block_size);
+			tx_size = DOWNLOAD_BLOCK_SIZE;
+		}
+
+		/* loop until put - get <= 24K */
+		for (i = 0; i < 100; i++) {
+			APB_READ(DOWNLOAD_GET_REG, get);
+			if ((put - get) <= (DOWNLOAD_FIFO_SIZE - DOWNLOAD_BLOCK_SIZE))
+				break;
+			mdelay(i);
+		}
+
+		if ((put - get) > (DOWNLOAD_FIFO_SIZE - DOWNLOAD_BLOCK_SIZE)) {
+			xradio_dbg(XRADIO_DBG_ERROR, "%s: Timeout waiting for FIFO.\n",
+				   __func__);
+			ret = -ETIMEDOUT;
+			goto error;
+		}
+
+		/* send the block to sram */
+		ret = xradio_apb_write(hw_priv, APB_ADDR(DOWNLOAD_FIFO_OFFSET + \
+				       (put & (DOWNLOAD_FIFO_SIZE - 1))),
+				       buf, tx_size);
+		if (ret < 0) {
+			xradio_dbg(XRADIO_DBG_ERROR,
+				   "%s: can't write block at line %d.\n",
+				   __func__, __LINE__);
+			goto error;
+		}
+
+		/* update the put register */
+		put += block_size;
+		APB_WRITE(DOWNLOAD_PUT_REG, put);
+	} /* End of firmware download loop */
+
+	/* Wait for the download completion */
+	for (i = 0; i < 300; i += 1 + i / 2) {
+		APB_READ(DOWNLOAD_STATUS_REG, val32);
+		if (val32 != DOWNLOAD_PENDING)
+			break;
+		mdelay(i);
+	}
+	if (val32 != DOWNLOAD_SUCCESS) {
+		xradio_dbg(XRADIO_DBG_ERROR,
+			   "%s: wait for download completion failed. " \
+			   "Read: 0x%.8X\n", __func__, val32);
+		ret = -ETIMEDOUT;
+		goto error;
+	} else {
+		xradio_dbg(XRADIO_DBG_ALWY, "Firmware completed.\n");
+		ret = 0;
+	}
+
+error:
+	if (buf)
+		kfree(buf);
+	if (firmware) {
+		release_firmware(firmware);
+	}
+	return ret;
+}
+
+static int xradio_bootloader(struct xradio_common *hw_priv)
+{
+	int ret = -1;
+	u32 i = 0;
+	const char *bl_path = XR829_BOOTLOADER;
+	u32 addr = AHB_MEMORY_ADDRESS;
+	u32 *data = NULL;
+	const struct firmware *bootloader = NULL;
+	xradio_dbg(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	/* Load a bootloader file */
+	ret = request_firmware(&bootloader, bl_path, hw_priv->pdev);
+	if (ret) {
+		xradio_dbg(XRADIO_DBG_ERROR,
+			   "%s: can't load bootloader file %s.\n",
+			   __func__, bl_path);
+		goto error;
+	}
+
+	xradio_dbg(XRADIO_DBG_NIY, "%s: bootloader size = %zu, loopcount = %zu\n",
+		   __func__, bootloader->size, (bootloader->size) / 4);
+
+	/* Down bootloader. */
+	data = (u32 *)bootloader->data;
+	for (i = 0; i < (bootloader->size)/4; i++) {
+	ret = xradio_ahb_write_32(hw_priv, addr, data[i]);
+	if (ret < 0) {
+		sbus_printk(XRADIO_DBG_ERROR, "%s: xradio_ahb_write failed.\n", __func__);
+		goto error;
+	}
+	if (i == 100 || i == 200 || i == 300 || i == 400 || i == 500 || i == 600)
+		xradio_dbg(XRADIO_DBG_NIY, "%s: addr = 0x%x, data = 0x%x\n", __func__, addr, data[i]);
+		addr += 4;
+	}
+	xradio_dbg(XRADIO_DBG_ALWY, "Bootloader complete\n");
+
+error:
+	if (bootloader) {
+		release_firmware(bootloader);
+	}
+	return ret;
+}
+
+#if (DBG_XRADIO_HIF)
+
+extern u16 	hif_test_rw; /*0: nothing to do; 1: write only; 2: write and read*/
+extern u16 	hif_test_data_mode; /* hif test data mode, such as 0x55, 0xff etc*/
+extern u16 	hif_test_data_len; /* hif test data len, every data len pre round*/
+extern u16	hif_test_data_round;
+extern u16 	hif_test_oper_delta; /* hif test operation delta time, give more time to analyze data tranx*/
+int HIF_R_W_TEST(struct xradio_common *hw_priv)
+{
+	int time;
+	int i;
+	struct timeval start;   //linux5.4 commit 33e26418193f58d1895f2f968e1953b1caf8deb7
+	struct timeval end;
+	unsigned int addr;
+	char *write_buf;
+	char *read_buf;
+	write_buf = kmalloc(hif_test_data_len * 4, GFP_KERNEL);
+	if (!write_buf)
+		return 0xff;
+	read_buf = kmalloc(hif_test_data_len * 4, GFP_KERNEL);
+	if (!read_buf) {
+		kfree(write_buf);
+		return 0xff;
+	}
+
+	xr_do_gettimeofday(&start);
+	printk(KERN_ERR"[HIF test] --- <write> --- begin~~\n");
+	addr = PAS_RAM_START_ADDR;
+	memset(write_buf, hif_test_data_mode, hif_test_data_len * 4);
+	i = 0;
+	while (i < hif_test_data_round) {
+		xradio_apb_write(hw_priv, addr, write_buf, hif_test_data_len * 4);
+		msleep(hif_test_oper_delta);
+		i++;
+		if (0 == hif_test_rw)
+			goto err;
+	}
+
+	if (1 == hif_test_rw) { // means write only
+		kfree(write_buf);
+		kfree(read_buf);
+		printk(KERN_ERR"[HIF test] --- <write> --- end and return~~\n");
+		return 0;
+	}
+
+	msleep(hif_test_oper_delta * 5);
+	printk(KERN_ERR"[HIF test] --- <read> --- begin~~\n");
+
+	addr = PAS_RAM_START_ADDR;
+	memset(write_buf, hif_test_data_mode, hif_test_data_len * 4);
+	i = 0;
+	while (i < hif_test_data_round) {
+		xradio_apb_read(hw_priv, addr, read_buf, hif_test_data_len * 4);
+		msleep(hif_test_oper_delta);
+		i++;
+		if (0 == hif_test_rw)
+			goto err;
+	}
+
+	printk(KERN_ERR"[HIF test] --- <read> --- end~~\n");
+	xr_do_gettimeofday(&end);
+	time = 1000 * (end.tv_sec - start.tv_sec) + (end.tv_usec - start.tv_usec) / 1000;
+	kfree(write_buf);
+	kfree(read_buf);
+	return 0;
+err:
+	kfree(write_buf);
+	kfree(read_buf);
+	return 1;
+}
+
+#endif
+
+int xradio_load_firmware(struct xradio_common *hw_priv)
+{
+	int ret;
+	int i;
+	u32 val32 = 0;
+	u16 val16 = 0;
+	u32 dpll = 0;
+	int major_revision;
+
+	xradio_dbg(XRADIO_DBG_TRC, "%s\n", __func__);
+	SYS_BUG(!hw_priv);
+	/* Read CONFIG Register Value - We will read 32 bits */
+
+	ret = xradio_reg_read_32(hw_priv, HIF_CONFIG_REG_ID, &val32);
+	if (ret < 0) {
+		xradio_dbg(XRADIO_DBG_ERROR,
+			   "%s: can't read config register, err=%d.\n",
+			   __func__, ret);
+		return ret;
+	}
+
+	/*check hardware type and revision.*/
+	hw_priv->hw_type = xradio_get_hw_type(val32, &major_revision);
+	switch (hw_priv->hw_type) {
+	case HIF_HW_TYPE_XRADIO:
+		xradio_dbg(XRADIO_DBG_NIY, "%s: HW_TYPE_XRADIO detected.\n",
+			   __func__);
+		break;
+	default:
+		xradio_dbg(XRADIO_DBG_ERROR, "%s: Unknown hardware: %d.\n",
+			   __func__, hw_priv->hw_type);
+		return -ENOTSUPP;
+	}
+	if (major_revision == 4) {
+		hw_priv->hw_revision = XR829_HW_REV0;
+		xradio_dbg(XRADIO_DBG_ALWY, "XRADIO_HW_REV 1.0 detected.\n");
+	} else {
+		xradio_dbg(XRADIO_DBG_ERROR, "%s: Unsupported major revision %d.\n",
+			   __func__, major_revision);
+		return -ENOTSUPP;
+	}
+
+	/*load sdd file, and get config from it.*/
+	ret = xradio_parse_sdd(hw_priv, &dpll);
+	if (ret < 0) {
+		return ret;
+	}
+
+	/*set dpll initial value and check.*/
+	ret = xradio_reg_write_32(hw_priv, HIF_TSET_GEN_R_W_REG_ID, dpll);
+	if (ret < 0) {
+		xradio_dbg(XRADIO_DBG_ERROR, "%s: can't write DPLL register.\n",
+			   __func__);
+		goto out;
+	}
+	msleep(5);
+	ret = xradio_reg_read_32(hw_priv, HIF_TSET_GEN_R_W_REG_ID, &val32);
+	if (ret < 0) {
+		xradio_dbg(XRADIO_DBG_ERROR, "%s: can't read DPLL register.\n",
+			   __func__);
+		goto out;
+	}
+	if (val32 != dpll) {
+		xradio_dbg(XRADIO_DBG_ERROR, "%s: unable to initialise " \
+			   "DPLL register. Wrote 0x%.8X, read 0x%.8X.\n",
+			   __func__, dpll, val32);
+		ret = -EIO;
+		goto out;
+	}
+
+	/* Set wakeup bit in device */
+	ret = xradio_reg_bit_operate(hw_priv, HIF_CONTROL_REG_ID, HIF_CTRL_WUP_BIT, 0);
+	if (ret < 0) {
+		xradio_dbg(XRADIO_DBG_ERROR, "%s: device wake up failed.\n", __func__);
+		goto out;
+	}
+
+	/* Wait for wakeup */
+	for (i = 0 ; i < 300 ; i += 1 + i / 2) {
+		ret = xradio_reg_read_16(hw_priv, HIF_CONTROL_REG_ID, &val16);
+		if (ret < 0) {
+			xradio_dbg(XRADIO_DBG_ERROR, "%s: Wait_for_wakeup: "
+				   "can't read control register.\n", __func__);
+			goto out;
+		}
+		if (val16 & HIF_CTRL_RDY_BIT) {
+			break;
+		}
+		msleep(i);
+	}
+	if ((val16 & HIF_CTRL_RDY_BIT) == 0) {
+		xradio_dbg(XRADIO_DBG_ERROR, "%s: Wait for wakeup:"
+			   "device is not responding.\n", __func__);
+#ifdef BOOT_NOT_READY_FIX
+		hw_priv->boot_not_ready_cnt++;
+		hw_priv->boot_not_ready = 1;
+		xradio_dbg(XRADIO_DBG_ERROR, "Device will restart at %d times!\n",
+			hw_priv->boot_not_ready_cnt);
+	#ifdef ERROR_HANG_DRIVER
+		if (hw_priv->boot_not_ready_cnt >= 6) {
+			xradio_dbg(XRADIO_DBG_ERROR, "Boot not ready and device restart \
+				more than 6, hang the driver.\n");
+			error_hang_driver = 1;
+		}
+	#endif
+#endif
+		ret = -ETIMEDOUT;
+		goto out;
+	} else {
+		xradio_dbg(XRADIO_DBG_NIY, "WLAN device is ready.\n");
+	}
+
+	/* Checking for access mode and download firmware. */
+	ret = xradio_reg_bit_operate(hw_priv, HIF_CONFIG_REG_ID,
+								HIF_CONFIG_ACCESS_MODE_BIT, 0);
+	if (ret < 0) {
+		xradio_dbg(XRADIO_DBG_ERROR, "%s: check_access_mode: "
+			   "can't read config register.\n", __func__);
+		goto out;
+	}
+
+#ifdef SUPPORT_DPLL_CHECK
+	/*Checking DPLL value and correct it if need.*/
+	xradio_update_dpllctrl(hw_priv, xradio_dllctrl_convert(dpll));
+#else
+	xradio_dbg(XRADIO_DBG_ALWY, "%s: not need check dpll.\n", __func__);
+#endif
+
+#if (DBG_XRADIO_HIF)
+
+	if (hif_test_rw) {
+		ret = HIF_R_W_TEST(hw_priv);
+		if (0 == ret) {
+			printk(KERN_ERR "HIF Test OK!\n");
+		} else if (1 == ret) {
+			printk(KERN_ERR "HIF Test faied!\n");
+		} else {
+			printk(KERN_ERR "Unkmow error!\n");
+		}
+	}
+
+#endif
+
+	/* Down bootloader. */
+	ret = xradio_bootloader(hw_priv);
+	if (ret < 0) {
+		xradio_dbg(XRADIO_DBG_ERROR, "%s: can't download bootloader.\n", __func__);
+		goto out;
+	}
+	/* Down firmware. */
+	ret = xradio_firmware(hw_priv);
+	if (ret < 0) {
+		xradio_dbg(XRADIO_DBG_ERROR, "%s: can't download firmware.\n", __func__);
+		goto out;
+	}
+
+	/* Register Interrupt Handler */
+	ret = hw_priv->sbus_ops->irq_subscribe(hw_priv->sbus_priv,
+					      (sbus_irq_handler)xradio_irq_handler,
+					       hw_priv);
+	if (ret < 0) {
+		xradio_dbg(XRADIO_DBG_ERROR, "%s: can't register IRQ handler.\n",
+			   __func__);
+		goto out;
+	}
+
+	if (HIF_HW_TYPE_XRADIO == hw_priv->hw_type) {
+		/* If device is XRADIO the IRQ enable/disable bits
+		 * are in CONFIG register */
+		ret = xradio_reg_bit_operate(hw_priv, HIF_CONFIG_REG_ID,
+									HIF_CONF_IRQ_RDY_ENABLE, 0);
+		if (ret < 0) {
+			xradio_dbg(XRADIO_DBG_ERROR, "%s: enable_irq: can't read " \
+				   "config register.\n", __func__);
+			goto unsubscribe;
+		}
+	} else {
+		/* Enable device interrupts - Both DATA_RDY and WLAN_RDY */
+		ret = xradio_reg_bit_operate(hw_priv, HIF_CONTROL_REG_ID,
+									HIF_CTRL_IRQ_RDY_ENABLE, 0);
+		if (ret < 0) {
+			xradio_dbg(XRADIO_DBG_ERROR, "%s: enable_irq: can't read " \
+				   "control register.\n", __func__);
+			goto unsubscribe;
+		}
+	}
+
+	/* Configure device for MESSSAGE MODE */
+	ret = xradio_reg_bit_operate(hw_priv, HIF_CONFIG_REG_ID,
+								0, HIF_CONFIG_ACCESS_MODE_BIT);
+	if (ret < 0) {
+		xradio_dbg(XRADIO_DBG_ERROR, "%s: set_mode: can't read config register.\n",
+					__func__);
+		goto unsubscribe;
+	}
+
+	/* Unless we read the CONFIG Register we are
+	 * not able to get an interrupt */
+	mdelay(10);
+	xradio_reg_read_32(hw_priv, HIF_CONFIG_REG_ID, &val32);
+	return 0;
+
+unsubscribe:
+	hw_priv->sbus_ops->irq_unsubscribe(hw_priv->sbus_priv);
+out:
+	if (hw_priv->sdd) {
+		release_firmware(hw_priv->sdd);
+		hw_priv->sdd = NULL;
+	}
+	return ret;
+}
+
+int xradio_dev_deinit(struct xradio_common *hw_priv)
+{
+	hw_priv->sbus_ops->irq_unsubscribe(hw_priv->sbus_priv);
+	if (hw_priv->sdd) {
+		release_firmware(hw_priv->sdd);
+		hw_priv->sdd = NULL;
+	}
+	return 0;
+}
+
+#undef APB_WRITE
+#undef APB_READ
+#undef REG_WRITE
+#undef REG_READ
diff -Naurp a/drivers/net/wireless/xr829/wlan/fwio.h b/drivers/net/wireless/xr829/wlan/fwio.h
--- a/drivers/net/wireless/xr829/wlan/fwio.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/fwio.h	2022-08-27 01:22:42.966539908 +0300
@@ -0,0 +1,40 @@
+/*
+ * Firmware APIs for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef FWIO_H_INCLUDED
+#define FWIO_H_INCLUDED
+
+#define XR829_HW_REV0       (8290)
+#define FIRMWARE_BASE_PATH  ""
+
+#define XR829_BOOTLOADER    (FIRMWARE_BASE_PATH "boot_xr829.bin")
+#define XR829_FIRMWARE      (FIRMWARE_BASE_PATH "fw_xr829.bin")
+#define XR829_SDD_FILE      (FIRMWARE_BASE_PATH "sdd_xr829.bin")
+#define XR829_ETF_FIRMWARE  (FIRMWARE_BASE_PATH "etf_xr829.bin")
+
+#define SDD_PTA_CFG_ELT_ID              0xEB
+#define SDD_REFERENCE_FREQUENCY_ELT_ID  0xC5
+#define SDD_MAX_OUTPUT_POWER_2G4_ELT_ID 0xE3
+#define SDD_MAX_OUTPUT_POWER_5G_ELT_ID  0xE4
+
+#define FIELD_OFFSET(type, field) ((u8 *)&((type *)0)->field - (u8 *)0)
+#define FIND_NEXT_ELT(e) (struct xradio_sdd *)((u8 *)&e->data + e->length)
+struct xradio_sdd {
+	u8 id;
+	u8 length;
+	u8 data[];
+};
+
+struct xradio_common;
+int xradio_load_firmware(struct xradio_common *hw_priv);
+int xradio_dev_deinit(struct xradio_common *hw_priv);
+int xradio_update_dpllctrl(struct xradio_common *hw_priv, u32 dpll_update);
+
+#endif
diff -Naurp a/drivers/net/wireless/xr829/wlan/ht.h b/drivers/net/wireless/xr829/wlan/ht.h
--- a/drivers/net/wireless/xr829/wlan/ht.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/ht.h	2022-08-27 01:22:42.966539908 +0300
@@ -0,0 +1,62 @@
+/*
+ * HT-related code for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef XRADIO_HT_H_INCLUDED
+#define XRADIO_HT_H_INCLUDED
+
+#include <net/mac80211.h>
+
+struct xradio_ht_info {
+	struct ieee80211_sta_ht_cap  ht_cap;
+	enum nl80211_channel_type    channel_type;
+	u16                          operation_mode;
+};
+
+static inline int xradio_is_ht(const struct xradio_ht_info *ht_info)
+{
+	return ht_info->channel_type != NL80211_CHAN_NO_HT;
+}
+
+
+#ifdef SUPPORT_HT40
+
+static inline int xradio_is_2040BSS(const struct xradio_ht_info *ht_info)
+{
+	return xradio_is_ht(ht_info) &&
+		(ht_info->ht_cap.cap&IEEE80211_HT_CAP_SUP_WIDTH_20_40);
+}
+
+
+static inline int xradio_ht_ShortGI(const struct xradio_ht_info *ht_info)
+{
+	return xradio_is_ht(ht_info)
+		&& (ht_info->ht_cap.cap
+			& (IEEE80211_HT_CAP_SGI_20
+				| IEEE80211_HT_CAP_SGI_40));
+}
+
+#endif
+
+static inline int xradio_ht_greenfield(const struct xradio_ht_info *ht_info)
+{
+	int ret = (xradio_is_ht(ht_info) &&
+		(ht_info->ht_cap.cap & IEEE80211_HT_CAP_GRN_FLD) &&
+		!(ht_info->operation_mode & IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT));
+	return ret;
+}
+
+static inline int xradio_ht_ampdu_density(const struct xradio_ht_info *ht_info)
+{
+	if (!xradio_is_ht(ht_info))
+		return 0;
+	return ht_info->ht_cap.ampdu_density;
+}
+
+#endif /* XRADIO_HT_H_INCLUDED */
diff -Naurp a/drivers/net/wireless/xr829/wlan/hwio.c b/drivers/net/wireless/xr829/wlan/hwio.c
--- a/drivers/net/wireless/xr829/wlan/hwio.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/hwio.c	2022-08-27 01:22:42.966539908 +0300
@@ -0,0 +1,359 @@
+/*
+ * Hardware I/O implementation for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/types.h>
+
+#include "xradio.h"
+#include "hwio.h"
+#include "sbus.h"
+
+
+static int __xradio_read(struct xradio_common *hw_priv, u16 addr,
+			 void *buf, size_t buf_len, int buf_id)
+{
+	u16 addr_sdio;
+	u32 sdio_reg_addr_17bit ;
+
+#if (CHECK_ADDR_LEN)
+	/* Check if buffer is aligned to 4 byte boundary */
+	if (SYS_WARN(((unsigned long)buf & 3) && (buf_len > 4))) {
+		sbus_printk(XRADIO_DBG_ERROR, "%s: buffer is not aligned.\n",
+			    __func__);
+		return -EINVAL;
+	}
+#endif
+
+	/* Convert to SDIO Register Address */
+	addr_sdio = SPI_REG_ADDR_TO_SDIO(addr);
+	sdio_reg_addr_17bit = SDIO_ADDR17BIT(buf_id, 0, 0, addr_sdio);
+	SYS_BUG(!hw_priv->sbus_ops);
+	return hw_priv->sbus_ops->sbus_data_read(hw_priv->sbus_priv,
+						 sdio_reg_addr_17bit,
+						 buf, buf_len);
+}
+
+static int __xradio_write(struct xradio_common *hw_priv, u16 addr,
+			      const void *buf, size_t buf_len, int buf_id)
+{
+	u16 addr_sdio;
+	u32 sdio_reg_addr_17bit ;
+
+#if (CHECK_ADDR_LEN)
+	/* Check if buffer is aligned to 4 byte boundary */
+	if (SYS_WARN(((unsigned long)buf & 3) && (buf_len > 4))) {
+		sbus_printk(XRADIO_DBG_ERROR, "%s: buffer is not aligned.\n",
+			    __func__);
+		return -EINVAL;
+	}
+#endif
+
+	/* Convert to SDIO Register Address */
+	addr_sdio = SPI_REG_ADDR_TO_SDIO(addr);
+	sdio_reg_addr_17bit = SDIO_ADDR17BIT(buf_id, 0, 0, addr_sdio);
+
+	SYS_BUG(!hw_priv->sbus_ops);
+	return hw_priv->sbus_ops->sbus_data_write(hw_priv->sbus_priv,
+						  sdio_reg_addr_17bit,
+						  buf, buf_len);
+}
+
+static inline int __xradio_read_reg32(struct xradio_common *hw_priv,
+				       u16 addr, u32 *val)
+{
+	int ret = 0;
+
+	*hw_priv->sbus_priv->val32_r = 0;
+	ret = __xradio_read(hw_priv, addr, hw_priv->sbus_priv->val32_r, sizeof(u32), 0);
+	*val = *hw_priv->sbus_priv->val32_r;
+
+	return ret;
+}
+
+static inline int __xradio_write_reg32(struct xradio_common *hw_priv,
+					u16 addr, u32 val)
+{
+	int ret = 0;
+
+	*hw_priv->sbus_priv->val32_w = val;
+	ret = __xradio_write(hw_priv, addr, hw_priv->sbus_priv->val32_w, sizeof(u32), 0);
+	*hw_priv->sbus_priv->val32_w = 0;
+
+	return ret;
+}
+
+int xradio_reg_read(struct xradio_common *hw_priv, u16 addr,
+		    void *buf, size_t buf_len)
+{
+	int ret;
+	SYS_BUG(!hw_priv->sbus_ops);
+	hw_priv->sbus_ops->lock(hw_priv->sbus_priv);
+	*hw_priv->sbus_priv->val32_r = 0;
+	ret = __xradio_read(hw_priv, addr, hw_priv->sbus_priv->val32_r, buf_len, 0);
+	*(u32 *)buf = *hw_priv->sbus_priv->val32_r;
+	hw_priv->sbus_ops->unlock(hw_priv->sbus_priv);
+	return ret;
+}
+
+int xradio_reg_write(struct xradio_common *hw_priv, u16 addr,
+		     const void *buf, size_t buf_len)
+{
+	int ret;
+	SYS_BUG(!hw_priv->sbus_ops);
+	hw_priv->sbus_ops->lock(hw_priv->sbus_priv);
+	*hw_priv->sbus_priv->val32_w = *(u32 *)buf;
+	ret = __xradio_write(hw_priv, addr, hw_priv->sbus_priv->val32_w, buf_len, 0);
+	*hw_priv->sbus_priv->val32_w = 0;
+	hw_priv->sbus_ops->unlock(hw_priv->sbus_priv);
+	return ret;
+}
+
+int xradio_reg_bit_operate(struct xradio_common *hw_priv, u16 addr, u32 set, u32 clr)
+{
+	int ret;
+	u32 val32;
+	SYS_BUG(!hw_priv->sbus_ops);
+	hw_priv->sbus_ops->lock(hw_priv->sbus_priv);
+	ret = __xradio_read_reg32(hw_priv, addr, &val32);
+
+	if (ret < 0 && 1 == addr) { //means control reg read failed
+		ret = __xradio_read_reg32(hw_priv, addr, &val32);
+		printk(KERN_ERR"[SDIO-DCE] read control reg agian and val is 0x%x\n", val32);
+	}
+
+	if (ret < 0) {
+		sbus_printk(XRADIO_DBG_ERROR, "%s: Can't read reg.\n", __func__);
+		goto out;
+	}
+	val32 &= ~clr;
+	val32 |= set;
+	ret = __xradio_write_reg32(hw_priv, addr, val32);
+	if (ret < 0) {
+		sbus_printk(XRADIO_DBG_ERROR, "%s: Can't write reg.\n", __func__);
+	}
+out:
+	hw_priv->sbus_ops->unlock(hw_priv->sbus_priv);
+	return ret;
+}
+
+int xradio_data_read(struct xradio_common *hw_priv, void *buf, size_t buf_len)
+{
+	int ret, retry = 1;
+	SYS_BUG(!hw_priv->sbus_ops);
+	hw_priv->sbus_ops->lock(hw_priv->sbus_priv);
+	{
+		int buf_id_rx = hw_priv->buf_id_rx;
+		while (retry <= MAX_RETRY) {
+			ret = __xradio_read(hw_priv, HIF_IN_OUT_QUEUE_REG_ID, buf,
+					    buf_len, buf_id_rx + 1);
+			if (!ret) {
+				buf_id_rx = (buf_id_rx + 1) & 3;
+				hw_priv->buf_id_rx = buf_id_rx;
+				break;
+			} else {
+				retry++;
+				mdelay(1);
+				sbus_printk(XRADIO_DBG_ERROR, "%s, error :[%d]\n",
+					    __func__, ret);
+			}
+		}
+	}
+	hw_priv->sbus_ops->unlock(hw_priv->sbus_priv);
+	return ret;
+}
+
+int xradio_data_write(struct xradio_common *hw_priv, const void *buf,
+		      size_t buf_len)
+{
+	int ret, retry = 1;
+	SYS_BUG(!hw_priv->sbus_ops);
+	hw_priv->sbus_ops->lock(hw_priv->sbus_priv);
+	{
+		int buf_id_tx = hw_priv->buf_id_tx;
+		while (retry <= MAX_RETRY) {
+			ret = __xradio_write(hw_priv, HIF_IN_OUT_QUEUE_REG_ID, buf,
+					     buf_len, buf_id_tx);
+			if (!ret) {
+				buf_id_tx = (buf_id_tx + 1) & 31;
+				hw_priv->buf_id_tx = buf_id_tx;
+				break;
+			} else {
+				retry++;
+				mdelay(1);
+				sbus_printk(XRADIO_DBG_ERROR, "%s, error :[%d]\n",
+					    __func__, ret);
+			}
+		}
+	}
+	hw_priv->sbus_ops->unlock(hw_priv->sbus_priv);
+	return ret;
+}
+
+int xradio_indirect_read(struct xradio_common *hw_priv, u32 addr, void *buf,
+			 size_t buf_len, u32 prefetch, u16 port_addr)
+{
+	u32 val32 = 0;
+	int i, ret;
+
+	if ((buf_len / 2) >= 0x1000) {
+		sbus_printk(XRADIO_DBG_ERROR,
+			    "%s: Can't read more than 0xfff words.\n",
+			    __func__);
+		return -EINVAL;
+		goto out;
+	}
+
+	hw_priv->sbus_ops->lock(hw_priv->sbus_priv);
+	/* Write address */
+	ret = __xradio_write_reg32(hw_priv, HIF_SRAM_BASE_ADDR_REG_ID, addr);
+	if (ret < 0) {
+		sbus_printk(XRADIO_DBG_ERROR,
+			    "%s: Can't write address register.\n", __func__);
+		goto out;
+	}
+
+	/* Read CONFIG Register Value - We will read 32 bits */
+	ret = __xradio_read_reg32(hw_priv, HIF_CONFIG_REG_ID, &val32);
+	if (ret < 0) {
+		sbus_printk(XRADIO_DBG_ERROR,
+			    "%s: Can't read config register.\n", __func__);
+		goto out;
+	}
+
+	/* Set PREFETCH bit */
+	ret = __xradio_write_reg32(hw_priv, HIF_CONFIG_REG_ID, val32 | prefetch);
+	if (ret < 0) {
+		sbus_printk(XRADIO_DBG_ERROR,
+			    "%s: Can't write prefetch bit.\n", __func__);
+		goto out;
+	}
+
+	/* Check for PRE-FETCH bit to be cleared */
+	for (i = 0; i < 20; i++) {
+		ret = __xradio_read_reg32(hw_priv, HIF_CONFIG_REG_ID, &val32);
+		if (ret < 0) {
+			sbus_printk(XRADIO_DBG_ERROR,
+				    "%s: Can't check prefetch bit.\n", __func__);
+			goto out;
+		}
+		if (!(val32 & prefetch))
+			break;
+		mdelay(i);
+	}
+
+	if (val32 & prefetch) {
+		sbus_printk(XRADIO_DBG_ERROR,
+			    "%s: Prefetch bit is not cleared.\n", __func__);
+		goto out;
+	}
+
+	/* Read data port */
+	if (buf_len == sizeof(u32)) {
+		*hw_priv->sbus_priv->val32_r = 0;
+		ret = __xradio_read(hw_priv, port_addr, hw_priv->sbus_priv->val32_r, buf_len, 0);
+		*(u32 *)buf = *hw_priv->sbus_priv->val32_r;
+	} else {
+		ret = __xradio_read(hw_priv, port_addr, buf, buf_len, 0);
+	}
+	if (ret < 0) {
+		sbus_printk(XRADIO_DBG_ERROR,
+			    "%s: Can't read data port.\n", __func__);
+		goto out;
+	}
+
+out:
+	hw_priv->sbus_ops->unlock(hw_priv->sbus_priv);
+	return ret;
+}
+
+int xradio_apb_write(struct xradio_common *hw_priv, u32 addr, const void *buf,
+		     size_t buf_len)
+{
+	int ret;
+
+	if ((buf_len / 2) >= 0x1000) {
+		sbus_printk(XRADIO_DBG_ERROR,
+			    "%s: Can't wrire more than 0xfff words.\n", __func__);
+		return -EINVAL;
+	}
+
+	hw_priv->sbus_ops->lock(hw_priv->sbus_priv);
+
+	/* Write address */
+	ret = __xradio_write_reg32(hw_priv, HIF_SRAM_BASE_ADDR_REG_ID, addr);
+	if (ret < 0) {
+		sbus_printk(XRADIO_DBG_ERROR,
+			    "%s: Can't write address register.\n", __func__);
+		goto out;
+	}
+
+	/* Write data port */
+	if (buf_len == sizeof(u32)) {
+		memcpy(hw_priv->sbus_priv->val32_w, buf, sizeof(u32));
+		ret = __xradio_write(hw_priv, HIF_SRAM_DPORT_REG_ID,
+				hw_priv->sbus_priv->val32_w, buf_len, 0);
+		memset(hw_priv->sbus_priv->val32_w, 0, sizeof(u32));
+	} else {
+		ret = __xradio_write(hw_priv, HIF_SRAM_DPORT_REG_ID, buf, buf_len, 0);
+	}
+
+	if (ret < 0) {
+		sbus_printk(XRADIO_DBG_ERROR, "%s: Can't write data port.\n",
+			    __func__);
+		goto out;
+	}
+
+out:
+	hw_priv->sbus_ops->unlock(hw_priv->sbus_priv);
+	return ret;
+}
+
+int xradio_ahb_write(struct xradio_common *hw_priv, u32 addr, const void *buf,
+		     size_t buf_len)
+{
+	int ret;
+
+	if ((buf_len / 2) >= 0x1000) {
+		sbus_printk(XRADIO_DBG_ERROR,
+			    "%s: Can't wrire more than 0xfff words.\n",
+			     __func__);
+		return -EINVAL;
+	}
+
+	hw_priv->sbus_ops->lock(hw_priv->sbus_priv);
+
+	/* Write address */
+	ret = __xradio_write_reg32(hw_priv, HIF_SRAM_BASE_ADDR_REG_ID, addr);
+	if (ret < 0) {
+		sbus_printk(XRADIO_DBG_ERROR,
+			    "%s: Can't write address register.\n", __func__);
+		goto out;
+	}
+
+	/* Write data port */
+	if (buf_len == sizeof(u32)) {
+		memcpy(hw_priv->sbus_priv->val32_w, buf, sizeof(u32));
+		ret = __xradio_write(hw_priv, HIF_AHB_DPORT_REG_ID,
+				hw_priv->sbus_priv->val32_w, buf_len, 0);
+		memset(hw_priv->sbus_priv->val32_w, 0, sizeof(u32));
+	} else {
+		ret = __xradio_write(hw_priv, HIF_AHB_DPORT_REG_ID, buf, buf_len, 0);
+	}
+
+	if (ret < 0) {
+		sbus_printk(XRADIO_DBG_ERROR,
+			    "%s: Can't write data port.\n", __func__);
+		goto out;
+	}
+
+out:
+	hw_priv->sbus_ops->unlock(hw_priv->sbus_priv);
+	return ret;
+}
diff -Naurp a/drivers/net/wireless/xr829/wlan/hwio.h b/drivers/net/wireless/xr829/wlan/hwio.h
--- a/drivers/net/wireless/xr829/wlan/hwio.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/hwio.h	2022-08-27 01:22:42.966539908 +0300
@@ -0,0 +1,280 @@
+/*
+ * hardware interfaces for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef XRADIO_HWIO_H_INCLUDED
+#define XRADIO_HWIO_H_INCLUDED
+
+/* extern */ struct xradio_common;
+
+/* DPLL initial values */
+#define DPLL_INIT_VAL_XRADIO      (0x0EC4F121)
+
+/* Hardware Type Definitions */
+#define HIF_HW_TYPE_XRADIO        (1)
+
+#define CHECK_ADDR_LEN  1
+
+#define NEW_VERSION 1
+
+ /* Sdio addr is 4*spi_addr */
+#define SPI_REG_ADDR_TO_SDIO(spi_reg_addr) ((spi_reg_addr) << 2)
+#define SDIO_ADDR17BIT(buf_id, mpf, rfu, reg_id_ofs) \
+				((((buf_id)    & 0x1F) << 7) \
+				| (((mpf)        & 1) << 6) \
+				| (((rfu)        & 1) << 5) \
+				| (((reg_id_ofs) & 0x1F) << 0))
+#define MAX_RETRY		3
+
+/* boot loader start address in SRAM */
+#define DOWNLOAD_BOOT_LOADER_OFFSET   (0x00000000)
+/* 32K, 0x4000 to 0xDFFF */
+#define DOWNLOAD_FIFO_OFFSET          (0x00004000)
+/* 32K */
+#define DOWNLOAD_FIFO_SIZE            (0x00008000)
+/* 128 bytes, 0xFF80 to 0xFFFF */
+#define DOWNLOAD_CTRL_OFFSET          (0x0000FF80)
+#define DOWNLOAD_CTRL_DATA_DWORDS     (32-6)
+
+/* Download control area */
+struct download_cntl_t {
+	/* size of whole firmware file (including Cheksum), host init */
+	u32 ImageSize;
+	/* downloading flags */
+	u32 Flags;
+	/* No. of bytes put into the download, init & updated by host */
+	u32 Put;
+	/* last traced program counter, last ARM reg_pc */
+	u32 TracePc;
+	/* No. of bytes read from the download, host init, device updates */
+	u32 Get;
+	/* r0, boot losader status, host init to pending, device updates */
+	u32 Status;
+	/* Extra debug info, r1 to r14 if status=r0=DOWNLOAD_EXCEPTION */
+	u32 DebugData[DOWNLOAD_CTRL_DATA_DWORDS];
+};
+
+#define	DOWNLOAD_IMAGE_SIZE_REG		\
+	(DOWNLOAD_CTRL_OFFSET + offsetof(struct download_cntl_t, ImageSize))
+#define	DOWNLOAD_FLAGS_REG		\
+	(DOWNLOAD_CTRL_OFFSET + offsetof(struct download_cntl_t, Flags))
+#define DOWNLOAD_PUT_REG		\
+	(DOWNLOAD_CTRL_OFFSET + offsetof(struct download_cntl_t, Put))
+#define DOWNLOAD_TRACE_PC_REG		\
+	(DOWNLOAD_CTRL_OFFSET + offsetof(struct download_cntl_t, TracePc))
+#define	DOWNLOAD_GET_REG		\
+	(DOWNLOAD_CTRL_OFFSET + offsetof(struct download_cntl_t, Get))
+#define	DOWNLOAD_STATUS_REG		\
+	(DOWNLOAD_CTRL_OFFSET + offsetof(struct download_cntl_t, Status))
+#define DOWNLOAD_DEBUG_DATA_REG		\
+	(DOWNLOAD_CTRL_OFFSET + offsetof(struct download_cntl_t, DebugData))
+
+#define DOWNLOAD_DEBUG_DATA_LEN   (108)
+#define DOWNLOAD_BLOCK_SIZE       (1024)
+
+/* For boot loader detection */
+#define DOWNLOAD_ARE_YOU_HERE     (0x87654321)
+#define DOWNLOAD_I_AM_HERE        (0x12345678)
+
+/* Download error code */
+#define DOWNLOAD_PENDING        (0xFFFFFFFF)
+#define DOWNLOAD_SUCCESS        (0)
+#define DOWNLOAD_EXCEPTION      (1)
+#define DOWNLOAD_ERR_MEM_1      (2)
+#define DOWNLOAD_ERR_MEM_2      (3)
+#define DOWNLOAD_ERR_SOFTWARE   (4)
+#define DOWNLOAD_ERR_FILE_SIZE  (5)
+#define DOWNLOAD_ERR_CHECKSUM   (6)
+#define DOWNLOAD_ERR_OVERFLOW   (7)
+#define DOWNLOAD_ERR_IMAGE      (8)
+#define DOWNLOAD_ERR_HOST       (9)
+#define DOWNLOAD_ERR_ABORT      (10)
+
+#define SYS_BASE_ADDR_SILICON      (0)
+#define AHB_MEMORY_ADDRESS         (SYS_BASE_ADDR_SILICON + 0x08000000)
+#define PAC_BASE_ADDRESS_SILICON   (SYS_BASE_ADDR_SILICON + 0x09000000)
+#define PAC_BASE_ADDRESS_SILICON   (SYS_BASE_ADDR_SILICON + 0x09000000)
+#define PAC_SHARED_MEMORY_SILICON  (PAC_BASE_ADDRESS_SILICON)
+#define APB_ADDR(addr)             (PAC_SHARED_MEMORY_SILICON + (addr))
+
+#if (NEW_VERSION)
+#define PWRCTRL_WLAN_ADDRESS       (SYS_BASE_ADDR_SILICON + 0x0AC80000)
+#define PWRCTRL_WLAN_START_CFG     (PWRCTRL_WLAN_ADDRESS + 0x18)
+#define PWRCTRL_WLAN_COMMON_CFG    (PWRCTRL_WLAN_ADDRESS + 0x178)
+#define PWRCTRL_COMMON_REG_DONE    (0x1)
+#define PWRCTRL_COMMON_REG_BT      (0x4)
+#define PWRCTRL_COMMON_REG_ARBT    (0x8)
+#define PWRCTRL_WLAN_DPLL_CTRL     (PWRCTRL_WLAN_ADDRESS + 0x154)
+
+#else
+#define PWRCTRL_WLAN_ADDRESS       (SYS_BASE_ADDR_SILICON + 0x0AC80000)
+#define PWRCTRL_WLAN_START_CFG     (PWRCTRL_WLAN_ADDRESS + 0x18)
+#define PWRCTRL_WLAN_COMMON_CFG    (PWRCTRL_WLAN_ADDRESS + 0x78)
+#define PWRCTRL_COMMON_REG_DONE    (0x1)
+#define PWRCTRL_COMMON_REG_BT      (0x4)
+#define PWRCTRL_COMMON_REG_ARBT    (0x8)
+#define PWRCTRL_WLAN_DPLL_CTRL     (PWRCTRL_WLAN_ADDRESS + 0x54)
+#endif
+
+
+/* ***************************************************************
+*Device register definitions
+*************************************************************** */
+/* WBF - SPI Register Addresses */
+#define HIF_ADDR_ID_BASE             (0x0000)
+/* 16/32 bits */
+#define HIF_CONFIG_REG_ID            (0x0000)
+/* 16/32 bits */
+#define HIF_CONTROL_REG_ID           (0x0001)
+/* 16 bits, Q mode W/R */
+#define HIF_IN_OUT_QUEUE_REG_ID      (0x0002)
+/* 32 bits, AHB bus R/W */
+#define HIF_AHB_DPORT_REG_ID         (0x0003)
+/* 16/32 bits */
+#define HIF_SRAM_BASE_ADDR_REG_ID    (0x0004)
+/* 32 bits, APB bus R/W */
+#define HIF_SRAM_DPORT_REG_ID        (0x0005)
+/* 32 bits, t_settle/general */
+#define HIF_TSET_GEN_R_W_REG_ID      (0x0006)
+/* 16 bits, Q mode read, no length */
+#define HIF_FRAME_OUT_REG_ID         (0x0007)
+#define HIF_ADDR_ID_MAX              (HIF_FRAME_OUT_REG_ID)
+
+/* WBF - Control register bit set */
+/* next o/p length, bit 11 to 0 */
+#define HIF_CTRL_NEXT_LEN_MASK     (0x0FFF)
+#define HIF_CTRL_WUP_BIT           (BIT(12))
+#define HIF_CTRL_RDY_BIT           (BIT(13))
+#define HIF_CTRL_IRQ_ENABLE        (BIT(14))
+#define HIF_CTRL_RDY_ENABLE        (BIT(15))
+#define HIF_CTRL_IRQ_RDY_ENABLE    (BIT(14)|BIT(15))
+
+/* SPI Config register bit set */
+#define HIF_CONFIG_FRAME_BIT       (BIT(2))
+#define HIF_CONFIG_WORD_MODE_BITS  (BIT(3)|BIT(4))
+#define HIF_CONFIG_WORD_MODE_1     (BIT(3))
+#define HIF_CONFIG_WORD_MODE_2     (BIT(4))
+#define HIF_CONFIG_ERROR_0_BIT     (BIT(5))
+#define HIF_CONFIG_ERROR_1_BIT     (BIT(6))
+#define HIF_CONFIG_ERROR_2_BIT     (BIT(7))
+/* TBD: Sure??? */
+#define HIF_CONFIG_CSN_FRAME_BIT   (BIT(7))
+#define HIF_CONFIG_ERROR_3_BIT     (BIT(8))
+#define HIF_CONFIG_ERROR_4_BIT     (BIT(9))
+/* QueueM */
+#define HIF_CONFIG_ACCESS_MODE_BIT (BIT(10))
+/* AHB bus */
+#define HIF_CONFIG_AHB_PFETCH_BIT  (BIT(11))
+#define HIF_CONFIG_CPU_CLK_DIS_BIT (BIT(12))
+/* APB bus */
+#define HIF_CONFIG_PFETCH_BIT      (BIT(13))
+/* cpu reset */
+#define HIF_CONFIG_CPU_RESET_BIT   (BIT(14))
+#define HIF_CONFIG_CLEAR_INT_BIT   (BIT(15))
+
+/* For XRADIO the IRQ Enable and Ready Bits are in CONFIG register */
+#define HIF_CONF_IRQ_RDY_ENABLE	(BIT(16)|BIT(17))
+
+int xradio_data_read(struct xradio_common *hw_priv, void *buf,
+					 size_t buf_len);
+int xradio_data_write(struct xradio_common *hw_priv, const void *buf,
+					  size_t buf_len);
+int xradio_reg_read(struct xradio_common *hw_priv, u16 addr, void *buf,
+					size_t buf_len);
+int xradio_reg_write(struct xradio_common *hw_priv, u16 addr,
+					 const void *buf, size_t buf_len);
+int xradio_reg_bit_operate(struct xradio_common *hw_priv, u16 addr, u32 set, u32 clr);
+int xradio_indirect_read(struct xradio_common *hw_priv, u32 addr, void *buf,
+						 size_t buf_len, u32 prefetch, u16 port_addr);
+int xradio_apb_write(struct xradio_common *hw_priv, u32 addr,
+					 const void *buf, size_t buf_len);
+int xradio_ahb_write(struct xradio_common *hw_priv, u32 addr,
+					 const void *buf, size_t buf_len);
+
+
+static inline int xradio_reg_read_16(struct xradio_common *hw_priv,
+				     u16 addr, u16 *val)
+{
+	int ret    = 0;
+	u32 bigVal = 0;
+	ret = xradio_reg_read(hw_priv, addr, &bigVal, sizeof(bigVal));
+	*val = (u16)bigVal;
+	return ret;
+}
+
+static inline int xradio_reg_write_16(struct xradio_common *hw_priv,
+				      u16 addr, u16 val)
+{
+	u32 bigVal = (u32)val;
+	return xradio_reg_write(hw_priv, addr, &bigVal, sizeof(bigVal));
+}
+
+static inline int xradio_reg_read_32(struct xradio_common *hw_priv,
+				      u16 addr, u32 *val)
+{
+	return xradio_reg_read(hw_priv, addr, val, sizeof(*val));
+}
+
+static inline int xradio_reg_write_32(struct xradio_common *hw_priv,
+				      u16 addr, u32 val)
+{
+	return xradio_reg_write(hw_priv, addr, &val, sizeof(val));
+}
+
+static inline int xradio_apb_read(struct xradio_common *hw_priv, u32 addr,
+				  void *buf, size_t buf_len)
+{
+	return xradio_indirect_read(hw_priv, addr, buf, buf_len,
+				    HIF_CONFIG_PFETCH_BIT,
+				    HIF_SRAM_DPORT_REG_ID);
+}
+
+static inline int xradio_ahb_read(struct xradio_common *hw_priv, u32 addr,
+				  void *buf, size_t buf_len)
+{
+	return xradio_indirect_read(hw_priv, addr, buf, buf_len,
+				    HIF_CONFIG_AHB_PFETCH_BIT,
+				    HIF_AHB_DPORT_REG_ID);
+}
+
+static inline int xradio_apb_read_32(struct xradio_common *hw_priv,
+				      u32 addr, u32 *val)
+{
+	return xradio_apb_read(hw_priv, addr, val, sizeof(*val));
+}
+
+static inline int xradio_apb_write_32(struct xradio_common *hw_priv,
+				      u32 addr, u32 val)
+{
+	return xradio_apb_write(hw_priv, addr, &val, sizeof(val));
+}
+
+static inline int xradio_ahb_read_32(struct xradio_common *hw_priv,
+				      u32 addr, u32 *val)
+{
+	return xradio_ahb_read(hw_priv, addr, val, sizeof(*val));
+}
+
+static inline int xradio_ahb_write_32(struct xradio_common *hw_priv,
+				      u32 addr, u32 val)
+{
+	return xradio_ahb_write(hw_priv, addr, &val, sizeof(val));
+}
+
+static inline u32 xradio_dllctrl_convert(u32 dpll)
+{
+	return ((((dpll>>31)&0x1) << 0) | /*config*/
+			(((dpll>>29)&0x3) << 1) | /*dither*/
+			(((dpll>>12)&0x1) << 3) | /*frac ctrl*/
+			(((dpll>>13)&0xffff) << 4) | /*frac*/
+			(((dpll>>4)&0xff) << 20)); /*divn*/
+}
+
+#endif /* XRADIO_HWIO_H_INCLUDED */
diff -Naurp a/drivers/net/wireless/xr829/wlan/itp.c b/drivers/net/wireless/xr829/wlan/itp.c
--- a/drivers/net/wireless/xr829/wlan/itp.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/itp.c	2022-08-27 01:22:42.966539908 +0300
@@ -0,0 +1,753 @@
+/*
+ * Test code implementation for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/debugfs.h>
+#include <linux/poll.h>
+#include <linux/time.h>
+#include <linux/kallsyms.h>
+#include <net/mac80211.h>
+#include "xradio.h"
+#include "itp.h"
+#include "sta.h"
+
+static int __xradio_itp_open(struct xradio_common *priv);
+static int __xradio_itp_close(struct xradio_common *priv);
+static void xradio_itp_rx_start(struct xradio_common *priv);
+static void xradio_itp_rx_stop(struct xradio_common *priv);
+static void xradio_itp_rx_stats(struct xradio_common *priv);
+static void xradio_itp_rx_reset(struct xradio_common *priv);
+static void xradio_itp_tx_stop(struct xradio_common *priv);
+static void xradio_itp_handle(struct xradio_common *priv,
+			      struct sk_buff *skb);
+static void xradio_itp_err(struct xradio_common *priv,
+			   int err,
+			   int arg);
+static void __xradio_itp_tx_stop(struct xradio_common *priv);
+
+static ssize_t xradio_itp_read(struct file *file,
+	char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *priv = file->private_data;
+	struct xradio_itp *itp = &priv->debug->itp;
+	struct sk_buff *skb;
+	int ret;
+
+	if (skb_queue_empty(&itp->log_queue))
+		return 0;
+
+	skb = skb_dequeue(&itp->log_queue);
+	ret = copy_to_user(user_buf, skb->data, skb->len);
+	*ppos += skb->len;
+	skb->data[skb->len] = 0;
+	itp_printk(XRADIO_DBG_MSG, "[ITP] >>> %s", skb->data);
+	consume_skb(skb);
+
+	return skb->len - ret;
+}
+
+static ssize_t xradio_itp_write(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct xradio_common *priv = file->private_data;
+	struct sk_buff *skb;
+
+	if (!count || count > 1024)
+		return -EINVAL;
+	skb = xr_alloc_skb(count + 1);
+	if (!skb)
+		return -ENOMEM;
+	skb_trim(skb, 0);
+	skb_put(skb, count + 1);
+	if (copy_from_user(skb->data, user_buf, count)) {
+		kfree_skb(skb);
+		return -EFAULT;
+	}
+	skb->data[count] = 0;
+
+	xradio_itp_handle(priv, skb);
+	consume_skb(skb);
+	return count;
+}
+
+static unsigned int xradio_itp_poll(struct file *file, poll_table *wait)
+{
+	struct xradio_common *priv = file->private_data;
+	struct xradio_itp *itp = &priv->debug->itp;
+	unsigned int mask = 0;
+
+	poll_wait(file, &itp->read_wait, wait);
+
+	if (!skb_queue_empty(&itp->log_queue))
+		mask |= POLLIN | POLLRDNORM;
+
+	mask |= POLLOUT | POLLWRNORM;
+
+	return mask;
+}
+
+static int xradio_itp_open(struct inode *inode, struct file *file)
+{
+	struct xradio_common *priv = inode->i_private;
+	struct xradio_itp *itp = &priv->debug->itp;
+	int ret = 0;
+
+	file->private_data = priv;
+	if (atomic_inc_return(&itp->open_count) == 1) {
+		ret = __xradio_itp_open(priv);
+		if (ret && !atomic_dec_return(&itp->open_count))
+			__xradio_itp_close(priv);
+	} else {
+		atomic_dec(&itp->open_count);
+		ret = -EBUSY;
+	}
+
+	return ret;
+}
+
+static int xradio_itp_close(struct inode *inode, struct file *file)
+{
+	struct xradio_common *priv = file->private_data;
+	struct xradio_itp *itp = &priv->debug->itp;
+	if (!atomic_dec_return(&itp->open_count)) {
+		__xradio_itp_close(priv);
+		wake_up(&itp->close_wait);
+	}
+	return 0;
+}
+
+static const struct file_operations fops_itp = {
+	.open = xradio_itp_open,
+	.read = xradio_itp_read,
+	.write = xradio_itp_write,
+	.poll = xradio_itp_poll,
+	.release = xradio_itp_close,
+	.llseek = default_llseek,
+	.owner = THIS_MODULE,
+};
+
+static void xradio_itp_fill_pattern(u8 *data, int size,
+		enum xradio_itp_data_modes mode)
+{
+	u8 *p = data;
+
+	if (size <= 0)
+		return;
+
+	switch (mode) {
+	default:
+	case ITP_DATA_ZEROS:
+		memset(data, 0x0, size);
+		break;
+	case ITP_DATA_ONES:
+		memset(data, 0xff, size);
+		break;
+	case ITP_DATA_ZERONES:
+		memset(data, 0x55, size);
+		break;
+	case ITP_DATA_RANDOM:
+		while (p < data+size-sizeof(u32)) {
+			(*(u32 *)p) = random32();
+			p += sizeof(u32);
+		}
+		while (p < data+size) {
+			(*p) = random32() & 0xFF;
+			p++;
+		}
+		break;
+	}
+	return;
+}
+
+static void xradio_itp_tx_work(struct work_struct *work)
+{
+	struct xradio_itp *itp = container_of(work, struct xradio_itp,
+		    tx_work.work);
+	struct xradio_common *priv = itp->priv;
+	atomic_set(&priv->bh_tx, 1);
+
+#ifdef BH_USE_SEMAPHORE
+	up(&priv->bh_sem);
+#else
+	wake_up(&priv->bh_wq);
+#endif
+}
+
+static void xradio_itp_tx_finish(struct work_struct *work)
+{
+	struct xradio_itp *itp = container_of(work, struct xradio_itp,
+		    tx_finish.work);
+	__xradio_itp_tx_stop(itp->priv);
+}
+
+int xradio_itp_init(struct xradio_common *priv)
+{
+	struct xradio_itp *itp = &priv->debug->itp;
+
+	itp->priv = priv;
+	atomic_set(&itp->open_count, 0);
+	atomic_set(&itp->stop_tx, 0);
+	atomic_set(&itp->awaiting_confirm, 0);
+	skb_queue_head_init(&itp->log_queue);
+	spin_lock_init(&itp->tx_lock);
+	init_waitqueue_head(&itp->read_wait);
+	init_waitqueue_head(&itp->write_wait);
+	init_waitqueue_head(&itp->close_wait);
+	INIT_DELAYED_WORK(&itp->tx_work, xradio_itp_tx_work);
+	INIT_DELAYED_WORK(&itp->tx_finish, xradio_itp_tx_finish);
+	itp->data = NULL;
+	itp->hdr_len = WSM_TX_EXTRA_HEADROOM +
+			sizeof(struct ieee80211_hdr_3addr);
+	itp->id = 0;
+
+	if (!debugfs_create_file("itp", S_IRUSR | S_IWUSR,
+			priv->debug->debugfs_phy, priv, &fops_itp))
+		return -ENOMEM;
+
+	return 0;
+}
+
+void xradio_itp_release(struct xradio_common *priv)
+{
+	struct xradio_itp *itp = &priv->debug->itp;
+
+	wait_event_interruptible(itp->close_wait,
+			!atomic_read(&itp->open_count));
+
+	SYS_WARN(atomic_read(&itp->open_count));
+
+	skb_queue_purge(&itp->log_queue);
+	xradio_itp_tx_stop(priv);
+}
+
+static int __xradio_itp_open(struct xradio_common *priv)
+{
+	struct xradio_itp *itp = &priv->debug->itp;
+
+	if (!priv->vif)
+		return -EINVAL;
+	if (priv->join_status)
+		return -EINVAL;
+	itp->saved_channel = priv->channel;
+	if (!priv->channel)
+		priv->channel = &priv->hw->
+			wiphy->bands[NL80211_BAND_2GHZ]->channels[0];
+	wsm_set_bssid_filtering(priv, false);
+	xradio_itp_rx_reset(priv);
+	return 0;
+}
+
+static int __xradio_itp_close(struct xradio_common *priv)
+{
+	struct xradio_itp *itp = &priv->debug->itp;
+	if (atomic_read(&itp->test_mode) == TEST_MODE_RX_TEST)
+		xradio_itp_rx_stop(priv);
+	xradio_itp_tx_stop(priv);
+	xradio_disable_listening(priv);
+	xradio_update_filtering(priv);
+	priv->channel = itp->saved_channel;
+	return 0;
+}
+
+bool xradio_is_itp(struct xradio_common *priv)
+{
+	struct xradio_itp *itp = &priv->debug->itp;
+	return atomic_read(&itp->open_count) != 0;
+}
+
+static void xradio_itp_rx_reset(struct xradio_common *priv)
+{
+	struct xradio_itp *itp = &priv->debug->itp;
+	itp->rx_cnt = 0;
+	itp->rx_rssi = 0;
+	itp->rx_rssi_max = -1000;
+	itp->rx_rssi_min = 1000;
+}
+
+static void xradio_itp_rx_start(struct xradio_common *priv)
+{
+	struct xradio_itp *itp = &priv->debug->itp;
+
+	itp_printk(XRADIO_DBG_MSG, "[ITP] RX start, band = %d, ch = %d\n",
+			itp->band, itp->ch);
+	atomic_set(&itp->test_mode, TEST_MODE_RX_TEST);
+	xradio_disable_listening(priv, false);
+	priv->channel = &priv->hw->
+		wiphy->bands[itp->band]->channels[itp->ch];
+	xradio_enable_listening(priv, priv->channel);
+	wsm_set_bssid_filtering(priv, false);
+}
+
+static void xradio_itp_rx_stop(struct xradio_common *priv)
+{
+	struct xradio_itp *itp = &priv->debug->itp;
+	itp_printk(XRADIO_DBG_MSG, "[ITP] RX stop\n");
+	atomic_set(&itp->test_mode, TEST_MODE_NO_TEST);
+	xradio_itp_rx_reset(priv);
+}
+
+static void xradio_itp_rx_stats(struct xradio_common *priv)
+{
+	struct xradio_itp *itp = &priv->debug->itp;
+	struct sk_buff *skb;
+	char buf[128];
+	int len, ret;
+	struct wsm_counters_table counters;
+
+	ret = wsm_get_counters_table(priv, &counters);
+
+	if (ret)
+		xradio_itp_err(priv, -EBUSY, 20);
+
+	if (!itp->rx_cnt)
+		len = snprintf(buf, sizeof(buf), "1, 0, 0, 0, 0, %d\n",
+				counters.countRxPacketErrors);
+	else
+		len = snprintf(buf, sizeof(buf), "1, %d, %ld, %d, %d, %d\n",
+			itp->rx_cnt,
+			itp->rx_cnt ? itp->rx_rssi / itp->rx_cnt : 0,
+			itp->rx_rssi_min, itp->rx_rssi_max,
+			counters.countRxPacketErrors);
+
+	if (len <= 0) {
+		xradio_itp_err(priv, -EBUSY, 21);
+		return;
+	}
+
+	skb = xr_alloc_skb(len);
+	if (!skb) {
+		xradio_itp_err(priv, -ENOMEM, 22);
+		return;
+	}
+
+	itp->rx_cnt = 0;
+	itp->rx_rssi = 0;
+	itp->rx_rssi_max = -1000;
+	itp->rx_rssi_min = 1000;
+
+	skb_trim(skb, 0);
+	skb_put(skb, len);
+
+	memcpy(skb->data, buf, len);
+	skb_queue_tail(&itp->log_queue, skb);
+	wake_up(&itp->read_wait);
+}
+
+static void xradio_itp_tx_start(struct xradio_common *priv)
+{
+	struct wsm_tx *tx;
+	struct ieee80211_hdr_3addr *hdr;
+	struct xradio_itp *itp = &priv->debug->itp;
+	struct wsm_association_mode assoc_mode = {
+		.flags = WSM_ASSOCIATION_MODE_USE_PREAMBLE_TYPE,
+		.preambleType = itp->preamble,
+	};
+	int len;
+	u8 da_addr[6] = ITP_DEFAULT_DA_ADDR;
+
+	/* Rates index 4 and 5 are not supported */
+	if (itp->rate > 3)
+		itp->rate += 2;
+
+	itp_printk(XRADIO_DBG_MSG,
+		"[ITP] TX start: band = %d, ch = %d, rate = %d, "
+			" preamble = %d, number = %d, data_mode = %d, "
+			" interval = %d, power = %d, data_len = %d\n",
+			itp->band, itp->ch, itp->rate, itp->preamble,
+			itp->number, itp->data_mode, itp->interval_us,
+			itp->power, itp->data_len);
+
+	len = itp->hdr_len + itp->data_len;
+
+	itp->data = xr_kmalloc(len, false);
+	tx = (struct wsm_tx *)itp->data;
+	tx->hdr.len = itp->data_len + itp->hdr_len;
+	tx->hdr.id = __cpu_to_le16(0x0004 | 1 << 6);
+	tx->maxTxRate = itp->rate;
+	tx->queueId = 3;
+	tx->more = 0;
+	tx->flags = 0xc;
+	tx->packetID = 0;
+	tx->reserved = 0;
+	tx->expireTime = 0;
+
+	if (itp->preamble == ITP_PREAMBLE_GREENFIELD)
+		tx->htTxParameters = WSM_HT_TX_GREENFIELD;
+	else if (itp->preamble == ITP_PREAMBLE_MIXED)
+		tx->htTxParameters = WSM_HT_TX_MIXED;
+
+	hdr = (struct ieee80211_hdr_3addr *)&itp->data[sizeof(struct wsm_tx)];
+	memset(hdr, 0, sizeof(*hdr));
+	hdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |
+			IEEE80211_FCTL_TODS);
+	memcpy(hdr->addr1, da_addr, ETH_ALEN);
+	memcpy(hdr->addr2, priv->vif->addr, ETH_ALEN);
+	memcpy(hdr->addr3, da_addr, ETH_ALEN);
+
+	xradio_itp_fill_pattern(&itp->data[itp->hdr_len],
+			itp->data_len, itp->data_mode);
+
+	xradio_disable_listening(priv);
+	priv->channel = &priv->hw->
+		wiphy->bands[itp->band]->channels[itp->ch];
+	SYS_WARN(wsm_set_output_power(priv, itp->power));
+	if (itp->preamble == ITP_PREAMBLE_SHORT ||
+			itp->preamble == ITP_PREAMBLE_LONG)
+		SYS_WARN(wsm_set_association_mode(priv,
+					&assoc_mode));
+	wsm_set_bssid_filtering(priv, false);
+	xradio_enable_listening(priv, priv->channel);
+
+	spin_lock_bh(&itp->tx_lock);
+	atomic_set(&itp->test_mode, TEST_MODE_TX_TEST);
+	atomic_set(&itp->awaiting_confirm, 0);
+	atomic_set(&itp->stop_tx, 0);
+	atomic_set(&priv->bh_tx, 1);
+	ktime_get_ts(&itp->last_sent);
+#ifdef BH_USE_SEMAPHORE
+	up(&priv->bh_sem);
+#else
+	wake_up(&priv->bh_wq);
+#endif
+	spin_unlock_bh(&itp->tx_lock);
+}
+
+void __xradio_itp_tx_stop(struct xradio_common *priv)
+{
+	struct xradio_itp *itp = &priv->debug->itp;
+	spin_lock_bh(&itp->tx_lock);
+	kfree(itp->data);
+	itp->data = NULL;
+	atomic_set(&itp->test_mode, TEST_MODE_NO_TEST);
+	spin_unlock_bh(&itp->tx_lock);
+}
+
+static void xradio_itp_tx_stop(struct xradio_common *priv)
+{
+	struct xradio_itp *itp = &priv->debug->itp;
+	itp_printk(XRADIO_DBG_MSG, "[ITP] TX stop\n");
+	atomic_set(&itp->stop_tx, 1);
+	flush_workqueue(priv->workqueue);
+	flush_workqueue(priv->spare_workqueue);
+
+	/* time for FW to confirm all tx requests */
+	msleep(500);
+
+	__xradio_itp_tx_stop(priv);
+}
+
+static void xradio_itp_get_version(struct xradio_common *priv,
+		enum xradio_itp_version_type type)
+{
+	struct xradio_itp *itp = &priv->debug->itp;
+	struct sk_buff *skb;
+	char buf[ITP_BUF_SIZE];
+	size_t size = 0;
+	int len;
+	itp_printk(XRADIO_DBG_MSG, "[ITP] print %s version\n",
+		   type == ITP_CHIP_ID ? "chip" : "firmware");
+
+	len = snprintf(buf, ITP_BUF_SIZE, "2, ");
+	if (len <= 0) {
+		xradio_itp_err(priv, -EINVAL, 40);
+		return;
+	}
+	size += len;
+
+	switch (type) {
+	case ITP_CHIP_ID:
+		len = xradio_print_fw_version(priv, buf+size,
+				ITP_BUF_SIZE - size);
+
+		if (len <= 0) {
+			xradio_itp_err(priv, -EINVAL, 41);
+			return;
+		}
+		size += len;
+		break;
+	case ITP_FW_VER:
+		len = snprintf(buf+size, ITP_BUF_SIZE - size,
+				"%d.%d", priv->wsm_caps.hardwareId,
+				priv->wsm_caps.hardwareSubId);
+		if (len <= 0) {
+			xradio_itp_err(priv, -EINVAL, 42);
+			return;
+		}
+		size += len;
+		break;
+	default:
+		xradio_itp_err(priv, -EINVAL, 43);
+		break;
+	}
+
+	len = snprintf(buf+size, ITP_BUF_SIZE-size, "\n");
+	if (len <= 0) {
+		xradio_itp_err(priv, -EINVAL, 44);
+		return;
+	}
+	size += len;
+
+	skb = xr_alloc_skb(size);
+	if (!skb) {
+		xradio_itp_err(priv, -ENOMEM, 45);
+		return;
+	}
+
+	skb_trim(skb, 0);
+	skb_put(skb, size);
+
+	memcpy(skb->data, buf, size);
+	skb_queue_tail(&itp->log_queue, skb);
+	wake_up(&itp->read_wait);
+}
+
+int xradio_itp_get_tx(struct xradio_common *priv, u8 **data,
+		size_t *tx_len, int *burst)
+{
+	struct xradio_itp *itp;
+	struct wsm_tx *tx;
+	struct timespec now;
+	int time_left_us;
+
+	if (!priv->debug)
+		return 0;
+
+	itp	= &priv->debug->itp;
+
+	if (!itp)
+		return 0;
+
+	spin_lock_bh(&itp->tx_lock);
+	if (atomic_read(&itp->test_mode) != TEST_MODE_TX_TEST)
+		goto out;
+
+	if (atomic_read(&itp->stop_tx))
+		goto out;
+
+	if (itp->number == 0) {
+		atomic_set(&itp->stop_tx, 1);
+		queue_delayed_work(priv->workqueue, &itp->tx_finish,
+				HZ/10);
+		goto out;
+	}
+
+	if (!itp->data)
+		goto out;
+
+	if (priv->hw_bufs_used >= 2) {
+		if (!atomic_read(&priv->bh_rx))
+				atomic_set(&priv->bh_rx, 1);
+		atomic_set(&priv->bh_tx, 1);
+		goto out;
+	}
+
+	ktime_get_ts(&now);
+	time_left_us = (itp->last_sent.tv_sec -
+			now.tv_sec)*1000000 +
+		(itp->last_sent.tv_nsec - now.tv_nsec)/1000
+		+ itp->interval_us;
+
+	if (time_left_us > ITP_TIME_THRES_US) {
+		queue_delayed_work(priv->workqueue, &itp->tx_work,
+				ITP_US_TO_MS(time_left_us)*HZ/1000);
+		goto out;
+	}
+
+	if (time_left_us > 50)
+		udelay(time_left_us);
+
+	if (itp->number > 0)
+		itp->number--;
+
+	*data = itp->data;
+	*tx_len = itp->data_len + itp->hdr_len;
+
+	if (itp->data_mode == ITP_DATA_RANDOM)
+		xradio_itp_fill_pattern(&itp->data[itp->hdr_len],
+				itp->data_len, itp->data_mode);
+
+	tx = (struct wsm_tx *)itp->data;
+	tx->packetID = __cpu_to_le32(itp->id++);
+	*burst = 2;
+	atomic_set(&priv->bh_tx, 1);
+	ktime_get_ts(&itp->last_sent);
+	atomic_add(1, &itp->awaiting_confirm);
+	spin_unlock_bh(&itp->tx_lock);
+	return 1;
+
+out:
+	spin_unlock_bh(&itp->tx_lock);
+	return 0;
+}
+
+bool xradio_itp_rxed(struct xradio_common *priv, struct sk_buff *skb)
+{
+	struct xradio_itp *itp = &priv->debug->itp;
+	struct ieee80211_rx_status *rx = IEEE80211_SKB_RXCB(skb);
+	int signal;
+
+	if (atomic_read(&itp->test_mode) != TEST_MODE_RX_TEST)
+		return xradio_is_itp(priv);
+	if (rx->freq != priv->channel->center_freq)
+		return true;
+
+	signal = rx->signal;
+	itp->rx_cnt++;
+	itp->rx_rssi += signal;
+	if (itp->rx_rssi_min > rx->signal)
+		itp->rx_rssi_min = rx->signal;
+	if (itp->rx_rssi_max < rx->signal)
+		itp->rx_rssi_max = rx->signal;
+
+	return true;
+}
+
+void xradio_itp_wake_up_tx(struct xradio_common *priv)
+{
+	wake_up(&priv->debug->itp.write_wait);
+}
+
+bool xradio_itp_tx_running(struct xradio_common *priv)
+{
+	if (atomic_read(&priv->debug->itp.awaiting_confirm) ||
+			atomic_read(&priv->debug->itp.test_mode) ==
+			TEST_MODE_TX_TEST) {
+		atomic_sub(1, &priv->debug->itp.awaiting_confirm);
+		return true;
+	}
+	return false;
+}
+
+static void xradio_itp_handle(struct xradio_common *priv,
+			      struct sk_buff *skb)
+{
+	struct xradio_itp *itp = &priv->debug->itp;
+	const struct wiphy *wiphy = priv->hw->wiphy;
+	int cmd;
+	int ret;
+
+	itp_printk(XRADIO_DBG_MSG, "[ITP] <<< %s", skb->data);
+	if (sscanf(skb->data, "%d", &cmd) != 1) {
+		xradio_itp_err(priv, -EINVAL, 1);
+		return;
+	}
+
+	switch (cmd) {
+	case 1: /* RX test */
+		if (atomic_read(&itp->test_mode)) {
+			xradio_itp_err(priv, -EBUSY, 0);
+			return;
+		}
+		ret = sscanf(skb->data, "%d, %u, %u",
+				&cmd, &itp->band, &itp->ch);
+		if (ret != 3) {
+			xradio_itp_err(priv, -EINVAL, ret + 1);
+			return;
+		}
+		if (itp->band >= 2)
+			xradio_itp_err(priv, -EINVAL, 2);
+		else if (!wiphy->bands[itp->band])
+			xradio_itp_err(priv, -EINVAL, 2);
+		else if (itp->ch >=
+				wiphy->bands[itp->band]->n_channels)
+			xradio_itp_err(priv, -EINVAL, 3);
+		else {
+			xradio_itp_rx_stats(priv);
+			xradio_itp_rx_start(priv);
+		}
+		break;
+	case 2: /* RX stat */
+		xradio_itp_rx_stats(priv);
+		break;
+	case 3: /* RX/TX stop */
+		if (atomic_read(&itp->test_mode) == TEST_MODE_RX_TEST) {
+			xradio_itp_rx_stats(priv);
+			xradio_itp_rx_stop(priv);
+		} else if (atomic_read(&itp->test_mode) == TEST_MODE_TX_TEST) {
+			xradio_itp_tx_stop(priv);
+		} else
+			xradio_itp_err(priv, -EBUSY, 0);
+		break;
+	case 4: /* TX start */
+		if (atomic_read(&itp->test_mode) != TEST_MODE_NO_TEST) {
+			xradio_itp_err(priv, -EBUSY, 0);
+			return;
+		}
+		ret = sscanf(skb->data, "%d, %u, %u, %u, %u, %u, %u, %d, %d, %d",
+				&cmd, &itp->band, &itp->ch, &itp->rate,
+				&itp->preamble, &itp->number, &itp->data_mode,
+				&itp->interval_us, &itp->power, &itp->data_len);
+		if (ret != 10) {
+			xradio_itp_err(priv, -EINVAL, ret + 1);
+			return;
+		}
+		if (itp->band >= 2)
+			xradio_itp_err(priv, -EINVAL, 2);
+		else if (!wiphy->bands[itp->band])
+			xradio_itp_err(priv, -EINVAL, 2);
+		else if (itp->ch >=
+				wiphy->bands[itp->band]->n_channels)
+			xradio_itp_err(priv, -EINVAL, 3);
+		else if (itp->rate >= 20)
+			xradio_itp_err(priv, -EINVAL, 4);
+		else if (itp->preamble >= ITP_PREAMBLE_MAX)
+			xradio_itp_err(priv, -EINVAL, 5);
+		else if (itp->data_mode >= ITP_DATA_MAX_MODE)
+			xradio_itp_err(priv, -EINVAL, 7);
+		else if (itp->data_len < ITP_MIN_DATA_SIZE ||
+				itp->data_len > priv->wsm_caps.sizeInpChBuf -
+				itp->hdr_len)
+			xradio_itp_err(priv, -EINVAL, 8);
+		else {
+		    xradio_itp_tx_start(priv);
+		}
+		break;
+	case 5:
+		xradio_itp_get_version(priv, ITP_CHIP_ID);
+		break;
+	case 6:
+		xradio_itp_get_version(priv, ITP_FW_VER);
+		break;
+
+	}
+}
+
+static void xradio_itp_err(struct xradio_common *priv,
+			   int err, int arg)
+{
+	struct xradio_itp *itp = &priv->debug->itp;
+	struct sk_buff *skb;
+	static char buf[255];
+	int len;
+
+	len = snprintf(buf, sizeof(buf), "%d, %d\n",
+		err, arg);
+	if (len <= 0)
+		return;
+
+	skb = xr_alloc_skb(len);
+	if (!skb)
+		return;
+
+	skb_trim(skb, 0);
+	skb_put(skb, len);
+
+	memcpy(skb->data, buf, len);
+	skb_queue_tail(&itp->log_queue, skb);
+	wake_up(&itp->read_wait);
+
+	len = sprint_symbol(buf,
+			(unsigned long)__builtin_return_address(0));
+	if (len <= 0)
+		return;
+	itp_printk(XRADIO_DBG_MSG, "[ITP] error %d, %d from %s\n",
+			err, arg, buf);
+}
diff -Naurp a/drivers/net/wireless/xr829/wlan/itp.h b/drivers/net/wireless/xr829/wlan/itp.h
--- a/drivers/net/wireless/xr829/wlan/itp.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/itp.h	2022-08-27 01:22:42.966539908 +0300
@@ -0,0 +1,150 @@
+/*
+ * ITP interfaces for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef XRADIO_ITP_H_INCLUDED
+#define XRADIO_ITP_H_INCLUDED
+
+struct wsm_tx_confirm;
+struct dentry;
+
+#ifdef CONFIG_XRADIO_ITP
+
+/*extern*/ struct ieee80211_channel;
+
+#define TEST_MODE_NO_TEST	(0)
+#define TEST_MODE_RX_TEST	(1)
+#define TEST_MODE_TX_TEST	(2)
+
+#define ITP_DEFAULT_DA_ADDR {0xff, 0xff, 0xff, 0xff, 0xff, 0xff}
+#define ITP_MIN_DATA_SIZE 6
+#define ITP_MAX_DATA_SIZE 1600
+#define ITP_TIME_THRES_US 10000
+#define ITP_US_TO_MS(x) ((x)/1000)
+#define ITP_MS_TO_US(x) ((x)*1000)
+#if ((ITP_US_TO_MS(ITP_TIME_THRES_US))*HZ/1000) < 1
+#warning not able to achieve non-busywaiting ITP_TIME_THRES_US\
+precision with current HZ value !
+#endif
+#define ITP_BUF_SIZE 255
+
+
+enum xradio_itp_data_modes {
+	ITP_DATA_ZEROS,
+	ITP_DATA_ONES,
+	ITP_DATA_ZERONES,
+	ITP_DATA_RANDOM,
+	ITP_DATA_MAX_MODE,
+};
+
+enum xradio_itp_version_type {
+	ITP_CHIP_ID,
+	ITP_FW_VER,
+};
+
+enum xradio_itp_preamble_type {
+	ITP_PREAMBLE_LONG,
+	ITP_PREAMBLE_SHORT,
+	ITP_PREAMBLE_OFDM,
+	ITP_PREAMBLE_MIXED,
+	ITP_PREAMBLE_GREENFIELD,
+	ITP_PREAMBLE_MAX,
+};
+
+
+struct xradio_itp {
+	struct xradio_common	*priv;
+	atomic_t		open_count;
+	atomic_t		awaiting_confirm;
+	struct sk_buff_head	log_queue;
+	wait_queue_head_t	read_wait;
+	wait_queue_head_t	write_wait;
+	wait_queue_head_t	close_wait;
+	struct ieee80211_channel *saved_channel;
+	atomic_t		stop_tx;
+	struct delayed_work	tx_work;
+	struct delayed_work	tx_finish;
+	spinlock_t		tx_lock;
+	struct timespec		last_sent;
+	atomic_t		test_mode;
+	int			rx_cnt;
+	long			rx_rssi;
+	int			rx_rssi_max;
+	int			rx_rssi_min;
+	unsigned		band;
+	unsigned		ch;
+	unsigned		rate;
+	unsigned		preamble;
+	unsigned int		number;
+	unsigned		data_mode;
+	int			interval_us;
+	int			power;
+	u8			*data;
+	int			hdr_len;
+	int			data_len;
+	int			id;
+};
+
+int xradio_itp_init(struct xradio_common *priv);
+void xradio_itp_release(struct xradio_common *priv);
+
+bool xradio_is_itp(struct xradio_common *priv);
+bool xradio_itp_rxed(struct xradio_common *priv, struct sk_buff *skb);
+void xradio_itp_wake_up_tx(struct xradio_common *priv);
+int xradio_itp_get_tx(struct xradio_common *priv, u8 **data,
+		size_t *tx_len, int *burst);
+bool xradio_itp_tx_running(struct xradio_common *priv);
+
+#else /* CONFIG_XRADIO_ITP */
+
+static inline int
+xradio_itp_init(struct xradio_common *priv)
+{
+	return 0;
+}
+
+static inline void xradio_itp_release(struct xradio_common *priv)
+{
+}
+
+static inline bool xradio_is_itp(struct xradio_common *priv)
+{
+	return false;
+}
+
+static inline bool xradio_itp_rxed(struct xradio_common *priv,
+		struct sk_buff *skb)
+{
+	return false;
+}
+
+
+static inline void xradio_itp_consume_txed(struct xradio_common *priv)
+{
+}
+
+static inline void xradio_itp_wake_up_tx(struct xradio_common *priv)
+{
+}
+
+static inline int xradio_itp_get_tx(struct xradio_common *priv, u8 **data,
+		size_t *tx_len, int *burst)
+{
+	return 0;
+}
+
+static inline bool xradio_itp_tx_running(struct xradio_common *priv)
+{
+	return false;
+}
+
+#endif /* CONFIG_XRADIO_ITP */
+
+#endif /* XRADIO_ITP_H_INCLUDED */
diff -Naurp a/drivers/net/wireless/xr829/wlan/main.c b/drivers/net/wireless/xr829/wlan/main.c
--- a/drivers/net/wireless/xr829/wlan/main.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/main.c	2022-08-27 01:22:42.966539908 +0300
@@ -0,0 +1,1568 @@
+/*
+ * Main code of XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*Linux version 3.4.0 compilation*/
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/firmware.h>
+#include <linux/etherdevice.h>
+#include <linux/vmalloc.h>
+#include <linux/random.h>
+#include <linux/sched.h>
+#include <net/mac80211.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/proc_fs.h>
+
+
+#include "platform.h"
+#include "xradio.h"
+#include "txrx.h"
+#include "sbus.h"
+#include "fwio.h"
+#include "hwio.h"
+#include "bh.h"
+#include "sta.h"
+#include "ap.h"
+#include "scan.h"
+#include "pm.h"
+#include "vendor.h"
+#include "xr_version.h"
+#include "debug.h"
+
+MODULE_AUTHOR("XRadioTech");
+MODULE_DESCRIPTION("XRadioTech WLAN driver core");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("xradio_core");
+
+#define XRADIO_DEV_VER  "_HT40_01.31"
+
+char *drv_version   = XRADIO_VERSION XRADIO_DEV_VER;
+//char *drv_buildtime = __DATE__" "__TIME__;
+char *drv_buildtime = " ";
+
+#define XRADIO_MAC_CHARLEN 18
+#ifdef XRADIO_MACPARAM_HEX
+/* insmod xradio_wlan.ko macaddr=0xDC, 0x44, 0x6D, 0x00, 0x00, 0x00 */
+static u8 xradio_macaddr_param[ETH_ALEN] = { 0x0 };
+
+module_param_array_named(macaddr, xradio_macaddr_param, byte, NULL, S_IRUGO);
+#else
+/* insmod xradio_wlan.ko macaddr=xx:xx:xx:xx:xx:xx */
+static char *xradio_macaddr_param;
+module_param_named(macaddr, xradio_macaddr_param, charp, S_IRUGO);
+#endif
+
+MODULE_PARM_DESC(macaddr, "First MAC address");
+
+#ifdef HW_RESTART
+void xradio_restart_work(struct work_struct *work);
+#endif
+
+static struct proc_dir_entry *hwinfo_proc_dir;
+static struct proc_dir_entry *hwinfo_proc_node;
+
+#define HWINFO_SIZE (4 * 64)
+static u8 *hwinfo_buffer;
+static DEFINE_MUTEX(hwinfo_buffer_lock);
+
+/* TODO: use rates and channels from the device */
+#define RATETAB_ENT(_rate, _rateid, _flags)		\
+	{						\
+		.bitrate  = (_rate),    \
+		.hw_value = (_rateid),  \
+		.flags    = (_flags),   \
+	}
+
+static struct ieee80211_rate xradio_rates[] = {
+	RATETAB_ENT(10,  0,   0),
+	RATETAB_ENT(20,  1,   0),
+	RATETAB_ENT(55,  2,   0),
+	RATETAB_ENT(110, 3,   0),
+	RATETAB_ENT(60,  6,  0),
+	RATETAB_ENT(90,  7,  0),
+	RATETAB_ENT(120, 8,  0),
+	RATETAB_ENT(180, 9,  0),
+	RATETAB_ENT(240, 10, 0),
+	RATETAB_ENT(360, 11, 0),
+	RATETAB_ENT(480, 12, 0),
+	RATETAB_ENT(540, 13, 0),
+};
+
+static struct ieee80211_rate xradio_mcs_rates[] = {
+	RATETAB_ENT(65,  14, IEEE80211_TX_RC_MCS),
+	RATETAB_ENT(130, 15, IEEE80211_TX_RC_MCS),
+	RATETAB_ENT(195, 16, IEEE80211_TX_RC_MCS),
+	RATETAB_ENT(260, 17, IEEE80211_TX_RC_MCS),
+	RATETAB_ENT(390, 18, IEEE80211_TX_RC_MCS),
+	RATETAB_ENT(520, 19, IEEE80211_TX_RC_MCS),
+	RATETAB_ENT(585, 20, IEEE80211_TX_RC_MCS),
+	RATETAB_ENT(650, 21, IEEE80211_TX_RC_MCS),
+};
+
+#define xradio_g_rates      (xradio_rates + 0)
+#define xradio_a_rates      (xradio_rates + 4)
+#define xradio_n_rates      (xradio_mcs_rates)
+
+#define xradio_g_rates_size (ARRAY_SIZE(xradio_rates))
+#define xradio_a_rates_size (ARRAY_SIZE(xradio_rates) - 4)
+#define xradio_n_rates_size (ARRAY_SIZE(xradio_mcs_rates))
+
+#define CHAN2G(_channel, _freq, _flags) {   \
+	.band             = NL80211_BAND_2GHZ,  \
+	.center_freq      = (_freq),              \
+	.hw_value         = (_channel),           \
+	.flags            = (_flags),             \
+	.max_antenna_gain = 0,                    \
+	.max_power        = 30,                   \
+}
+
+#define CHAN5G(_channel, _flags) {   \
+	.band             = NL80211_BAND_5GHZ,     \
+	.center_freq      = 5000 + (5 * (_channel)), \
+	.hw_value         = (_channel),              \
+	.flags            = (_flags),                \
+	.max_antenna_gain = 0,                       \
+	.max_power        = 30,                      \
+}
+
+static struct ieee80211_channel xradio_2ghz_chantable[] = {
+	CHAN2G(1, 2412, 0),
+	CHAN2G(2, 2417, 0),
+	CHAN2G(3, 2422, 0),
+	CHAN2G(4, 2427, 0),
+	CHAN2G(5, 2432, 0),
+	CHAN2G(6, 2437, 0),
+	CHAN2G(7, 2442, 0),
+	CHAN2G(8, 2447, 0),
+	CHAN2G(9, 2452, 0),
+	CHAN2G(10, 2457, 0),
+	CHAN2G(11, 2462, 0),
+	CHAN2G(12, 2467, 0),
+	CHAN2G(13, 2472, 0),
+	CHAN2G(14, 2484, 0),
+};
+
+#ifdef CONFIG_XRADIO_5GHZ_SUPPORT
+static struct ieee80211_channel xradio_5ghz_chantable[] = {
+	CHAN5G(34, 0),		CHAN5G(36, 0),
+	CHAN5G(38, 0),		CHAN5G(40, 0),
+	CHAN5G(42, 0),		CHAN5G(44, 0),
+	CHAN5G(46, 0),		CHAN5G(48, 0),
+	CHAN5G(52, 0),		CHAN5G(56, 0),
+	CHAN5G(60, 0),		CHAN5G(64, 0),
+	CHAN5G(100, 0),		CHAN5G(104, 0),
+	CHAN5G(108, 0),		CHAN5G(112, 0),
+	CHAN5G(116, 0),		CHAN5G(120, 0),
+	CHAN5G(124, 0),		CHAN5G(128, 0),
+	CHAN5G(132, 0),		CHAN5G(136, 0),
+	CHAN5G(140, 0),		CHAN5G(149, 0),
+	CHAN5G(153, 0),		CHAN5G(157, 0),
+	CHAN5G(161, 0),		CHAN5G(165, 0),
+	CHAN5G(184, 0),		CHAN5G(188, 0),
+	CHAN5G(192, 0),		CHAN5G(196, 0),
+	CHAN5G(200, 0),		CHAN5G(204, 0),
+	CHAN5G(208, 0),		CHAN5G(212, 0),
+	CHAN5G(216, 0),
+};
+#endif /* CONFIG_XRADIO_5GHZ_SUPPORT */
+
+static struct ieee80211_supported_band xradio_band_2ghz = {
+	.channels = xradio_2ghz_chantable,
+	.n_channels = ARRAY_SIZE(xradio_2ghz_chantable),
+	.bitrates = xradio_g_rates,
+	.n_bitrates = xradio_g_rates_size,
+	.ht_cap = {
+		.cap = IEEE80211_HT_CAP_GRN_FLD
+
+#ifdef SUPPORT_HT40
+
+#ifndef SUPPORT_NON_HT40_CHIP
+			| IEEE80211_HT_CAP_SUP_WIDTH_20_40
+			| IEEE80211_HT_CAP_SGI_20
+			| IEEE80211_HT_CAP_SGI_40
+#endif
+
+#endif
+
+			| (1 << IEEE80211_HT_CAP_RX_STBC_SHIFT),
+		.ht_supported  = 1,
+		.ampdu_factor  = IEEE80211_HT_MAX_AMPDU_32K,
+		.ampdu_density = IEEE80211_HT_MPDU_DENSITY_NONE,
+		.mcs = {
+			.rx_mask[0] = 0xFF,
+
+#ifdef SUPPORT_HT40
+
+			.rx_highest = __cpu_to_le16(0x0),
+
+#else
+
+			.rx_highest = __cpu_to_le16(0x41),
+
+#endif
+
+			.tx_params  = IEEE80211_HT_MCS_TX_DEFINED,
+		},
+	},
+};
+
+#ifdef CONFIG_XRADIO_5GHZ_SUPPORT
+static struct ieee80211_supported_band xradio_band_5ghz = {
+	.channels   = xradio_5ghz_chantable,
+	.n_channels = ARRAY_SIZE(xradio_5ghz_chantable),
+	.bitrates   = xradio_a_rates,
+	.n_bitrates = xradio_a_rates_size,
+	.ht_cap = {
+		.cap = IEEE80211_HT_CAP_GRN_FLD
+
+#ifdef SUPPORT_HT40
+
+#ifndef SUPPORT_NON_HT40_CHIP
+
+			| IEEE80211_HT_CAP_SUP_WIDTH_20_40
+			| IEEE80211_HT_CAP_SGI_20
+			| IEEE80211_HT_CAP_SGI_40
+#endif
+
+#endif
+
+			| (1 << IEEE80211_HT_CAP_RX_STBC_SHIFT),
+		.ht_supported  = 1,
+		.ampdu_factor  = IEEE80211_HT_MAX_AMPDU_8K,
+		.ampdu_density = IEEE80211_HT_MPDU_DENSITY_NONE,
+		.mcs = {
+			.rx_mask[0] = 0xFF,
+
+#ifdef SUPPORT_HT40
+
+			.rx_highest = __cpu_to_le16(0x0),
+
+#else
+
+			.rx_highest = __cpu_to_le16(0x41),
+
+#endif
+
+			.tx_params  = IEEE80211_HT_MCS_TX_DEFINED,
+		},
+	},
+};
+#endif /* CONFIG_XRADIO_5GHZ_SUPPORT */
+
+static const unsigned long xradio_ttl[] = {
+	1 * HZ,	/* VO */
+	2 * HZ,	/* VI */
+	5 * HZ, /* BE */
+	10 * HZ	/* BK */
+};
+
+static const struct ieee80211_ops xradio_ops = {
+	.start             = xradio_start,
+	.stop              = xradio_stop,
+	.add_interface     = xradio_add_interface,
+	.remove_interface  = xradio_remove_interface,
+	.change_interface  = xradio_change_interface,
+	.tx                = xradio_tx,
+	.hw_scan           = xradio_hw_scan,
+#ifdef ROAM_OFFLOAD
+	.sched_scan_start  = xradio_hw_sched_scan_start,
+	.sched_scan_stop   = xradio_hw_sched_scan_stop,
+#endif /*ROAM_OFFLOAD*/
+	.set_tim           = xradio_set_tim,
+	.sta_notify        = xradio_sta_notify,
+	.sta_add           = xradio_sta_add,
+	.sta_remove        = xradio_sta_remove,
+	.set_key           = xradio_set_key,
+	.set_rts_threshold = xradio_set_rts_threshold,
+	.config            = xradio_config,
+	.bss_info_changed  = xradio_bss_info_changed,
+	.prepare_multicast = xradio_prepare_multicast,
+	.configure_filter  = xradio_configure_filter,
+	.conf_tx           = xradio_conf_tx,
+	.get_stats         = xradio_get_stats,
+	.ampdu_action      = xradio_ampdu_action,
+	.flush             = xradio_flush,
+#ifdef CONFIG_PM
+	.suspend           = xradio_wow_suspend,
+	.resume            = xradio_wow_resume,
+#endif /* CONFIG_PM */
+	/* Intentionally not offloaded:					*/
+	/*.channel_switch	 = xradio_channel_switch,		*/
+	.remain_on_channel = xradio_remain_on_channel,
+	.cancel_remain_on_channel = xradio_cancel_remain_on_channel,
+#ifdef IPV6_FILTERING
+	.set_data_filter   = xradio_set_data_filter,
+#endif /*IPV6_FILTERING*/
+#ifdef CONFIG_XRADIO_TESTMODE
+	.testmode_cmd      = xradio_testmode_cmd,
+#endif /* CONFIG_XRADIO_TESTMODE */
+	.change_mac        = xradio_change_mac,
+};
+
+struct xradio_common *g_hw_priv;
+
+#ifdef CONFIG_PM
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
+static const struct wiphy_wowlan_support xradio_wowlan = {
+	.flags = WIPHY_WOWLAN_ANY | WIPHY_WOWLAN_DISCONNECT,
+};
+#endif
+#endif
+/**************************** functions **********************************/
+void xradio_version_show(void)
+{
+/* Show XRADIO version and compile time */
+	xradio_dbg(XRADIO_DBG_ALWY, "Driver Label:%s  %s\n",
+		   DRV_VERSION, DRV_BUILDTIME);
+
+/************* Linux Kernel config *************/
+#ifdef CONFIG_XRADIO_NON_POWER_OF_TWO_BLOCKSIZES
+	xradio_dbg(XRADIO_DBG_NIY,
+		  "[CONFIG_XRADIO_NON_POWER_OF_TWO_BLOCKSIZES]\n");
+#endif
+
+#ifdef CONFIG_XRADIO_USE_GPIO_IRQ
+	xradio_dbg(XRADIO_DBG_NIY, "[CONFIG_XRADIO_USE_GPIO_IRQ]\n");
+#endif
+
+#ifdef CONFIG_XRADIO_5GHZ_SUPPORT
+	xradio_dbg(XRADIO_DBG_NIY, "[CONFIG_XRADIO_5GHZ_SUPPORT]\n");
+#endif
+
+#ifdef CONFIG_XRADIO_WAPI_SUPPORT
+	xradio_dbg(XRADIO_DBG_NIY, "[CONFIG_XRADIO_WAPI_SUPPORT]\n");
+#endif
+
+#ifdef CONFIG_XRADIO_USE_EXTENSIONS
+	xradio_dbg(XRADIO_DBG_NIY, "[CONFIG_XRADIO_USE_EXTENSIONS]\n");
+#endif
+
+#ifdef CONFIG_PM
+	xradio_dbg(XRADIO_DBG_NIY, "[CONFIG_PM]\n");
+#endif
+
+#ifdef CONFIG_XRADIO_SDIO
+	xradio_dbg(XRADIO_DBG_NIY, "[CONFIG_XRADIO_SDIO]\n");
+#endif
+
+#ifdef CONFIG_XRADIO_DUMP_ON_ERROR
+	xradio_dbg(XRADIO_DBG_NIY, "[CONFIG_XRADIO_DUMP_ON_ERROR]\n");
+#endif
+
+#ifdef CONFIG_XRADIO_DEBUGFS
+	xradio_dbg(XRADIO_DBG_NIY, "[CONFIG_XRADIO_DEBUGFS]\n");
+#endif
+
+#ifdef CONFIG_XRADIO_ITP
+	xradio_dbg(XRADIO_DBG_NIY, "[CONFIG_XRADIO_ITP]\n");
+#endif
+
+#ifdef CONFIG_XRADIO_TESTMODE
+	xradio_dbg(XRADIO_DBG_NIY, "[CONFIG_XRADIO_TESTMODE]\n");
+#endif
+
+/************ XRADIO Make File config ************/
+#ifdef P2P_MULTIVIF
+	xradio_dbg(XRADIO_DBG_NIY, "[P2P_MULTIVIF]\n");
+#endif
+
+#ifdef MCAST_FWDING
+	xradio_dbg(XRADIO_DBG_NIY, "[MCAST_FWDING]\n");
+#endif
+
+#ifdef XRADIO_SUSPEND_RESUME_FILTER_ENABLE
+	xradio_dbg(XRADIO_DBG_NIY, "[XRADIO_SUSPEND_RESUME_FILTER_ENABLE]\n");
+#endif
+
+#ifdef AP_AGGREGATE_FW_FIX
+	xradio_dbg(XRADIO_DBG_NIY, "[AP_AGGREGATE_FW_FIX]\n");
+#endif
+
+#ifdef AP_HT_CAP_UPDATE
+	xradio_dbg(XRADIO_DBG_NIY, "[AP_HT_CAP_UPDATE]\n");
+#endif
+
+#ifdef PROBE_RESP_EXTRA_IE
+	xradio_dbg(XRADIO_DBG_NIY, "[PROBE_RESP_EXTRA_IE]\n");
+#endif
+
+#ifdef IPV6_FILTERING
+	xradio_dbg(XRADIO_DBG_NIY, "[IPV6_FILTERING]\n");
+#endif
+
+#ifdef ROAM_OFFLOAD
+	xradio_dbg(XRADIO_DBG_NIY, "[ROAM_OFFLOAD]\n");
+#endif
+
+#ifdef TES_P2P_0002_ROC_RESTART
+	xradio_dbg(XRADIO_DBG_NIY, "[TES_P2P_0002_ROC_RESTART]\n");
+#endif
+
+#ifdef TES_P2P_000B_EXTEND_INACTIVITY_CNT
+	xradio_dbg(XRADIO_DBG_NIY, "[TES_P2P_000B_EXTEND_INACTIVITY_CNT]\n");
+#endif
+
+#ifdef TES_P2P_000B_DISABLE_EAPOL_FILTER
+	xradio_dbg(XRADIO_DBG_NIY, "[TES_P2P_000B_DISABLE_EAPOL_FILTER]\n");
+#endif
+
+#ifdef HAS_PUT_TASK_STRUCT
+	xradio_dbg(XRADIO_DBG_NIY, "[HAS_PUT_TASK_STRUCT]\n");
+#endif
+
+/************* XRADIO.h config *************/
+#ifdef HIDDEN_SSID
+	xradio_dbg(XRADIO_DBG_NIY, "[HIDDEN_SSID]\n");
+#endif
+
+#ifdef ROC_DEBUG
+	xradio_dbg(XRADIO_DBG_NIY, "[ROC_DEBUG]\n");
+#endif
+
+#ifdef XRADIO_RRM
+	xradio_dbg(XRADIO_DBG_NIY, "[XRADIO_RRM]\n");
+#endif
+}
+
+/* return 0: failed*/
+static inline int xradio_macaddr_val2char(char *c_mac, const u8 *v_mac)
+{
+	SYS_BUG(!v_mac || !c_mac);
+	return sprintf(c_mac, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+		       v_mac[0], v_mac[1], v_mac[2],
+		       v_mac[3], v_mac[4], v_mac[5]);
+}
+
+#ifndef XRADIO_MACPARAM_HEX
+static int xradio_macaddr_char2val(u8 *v_mac, const char *c_mac)
+{
+	int i = 0;
+	const char *tmp_char = c_mac;
+	SYS_BUG(!v_mac || !c_mac);
+
+	for (i = 0; i < ETH_ALEN; i++) {
+		if (*tmp_char != 0) {
+			v_mac[i] = simple_strtoul(tmp_char, (char **)&tmp_char, 16);
+		} else {
+			xradio_dbg(XRADIO_DBG_ERROR, "%s, Len Error\n", __func__);
+			return -1;
+		}
+		if (i < ETH_ALEN - 1 && *tmp_char != ':') {
+			xradio_dbg(XRADIO_DBG_ERROR, "%s, Format or Len Error\n",
+				   __func__);
+			return -1;
+		}
+		tmp_char++;
+	}
+	return 0;
+}
+#endif
+
+/*bit0: 1=multicast, 0=unicast*/
+/*bit1: 1=locally, 0=universally(vendor use)*/
+#define MACADDR_VAILID(a) ( \
+(a[0] != 0 || a[1] != 0 ||  \
+ a[2] != 0 || a[3] != 0 ||  \
+ a[4] != 0 || a[5] != 0) && \
+ !(a[0] & 0x3))
+
+extern int get_custom_mac_address(int fmt, char *name, char *addr);
+
+static void xradio_get_mac_addrs(u8 *macaddr)
+{
+	int ret = 0;
+	SYS_BUG(!macaddr);
+	/* Check mac addrs param, if exsist, use it first.*/
+#ifdef XRADIO_MACPARAM_HEX
+	memcpy(macaddr, xradio_macaddr_param, ETH_ALEN);
+#else
+	if (xradio_macaddr_param) {
+		ret = xradio_macaddr_char2val(macaddr, xradio_macaddr_param);
+	}
+#endif
+
+	if (ret < 0 || !MACADDR_VAILID(macaddr)) {
+		ret = get_custom_mac_address(1, "wifi", macaddr);
+	}
+
+	/* Use random value to set mac addr */
+	if (ret < 0 || !MACADDR_VAILID(macaddr)) {
+		xradio_dbg(XRADIO_DBG_NIY, "Use random Mac addr!\n");
+		get_random_bytes(macaddr, 6);
+		macaddr[0] = 0xDC;
+		macaddr[1] = 0x44;
+		macaddr[2] = 0x6D;
+	}
+	xradio_dbg(XRADIO_DBG_NIY, "MACADDR=%02x:%02x:%02x:%02x:%02x:%02x\n",
+		   macaddr[0], macaddr[1], macaddr[2],
+		   macaddr[3], macaddr[4], macaddr[5]);
+}
+
+static void xradio_set_ifce_comb(struct xradio_common *hw_priv,
+				 struct ieee80211_hw *hw)
+{
+	xradio_dbg(XRADIO_DBG_TRC, "%s\n", __func__);
+#ifdef P2P_MULTIVIF
+	hw_priv->if_limits1[0].max = 2;
+#else
+	hw_priv->if_limits1[0].max = 1;
+#endif
+
+	hw_priv->if_limits1[0].types = BIT(NL80211_IFTYPE_STATION);
+	hw_priv->if_limits1[1].max = 1;
+	hw_priv->if_limits1[1].types = BIT(NL80211_IFTYPE_AP);
+
+#ifdef P2P_MULTIVIF
+	hw_priv->if_limits2[0].max = 3;
+#else
+	hw_priv->if_limits2[0].max = 2;
+#endif
+	hw_priv->if_limits2[0].types = BIT(NL80211_IFTYPE_STATION);
+
+#ifdef P2P_MULTIVIF
+	hw_priv->if_limits3[0].max = 2;
+#else
+	hw_priv->if_limits3[0].max = 1;
+#endif
+
+	hw_priv->if_limits3[0].types = BIT(NL80211_IFTYPE_STATION);
+	hw_priv->if_limits3[1].max = 1;
+	hw_priv->if_limits3[1].types = BIT(NL80211_IFTYPE_P2P_CLIENT) |
+				      BIT(NL80211_IFTYPE_P2P_GO);
+
+	/* TODO:COMBO: mac80211 doesn't yet support more than 1
+	 * different channel */
+	hw_priv->if_combs[0].num_different_channels = 1;
+#ifdef P2P_MULTIVIF
+	hw_priv->if_combs[0].max_interfaces = 3;
+#else
+	hw_priv->if_combs[0].max_interfaces = 2;
+#endif
+	hw_priv->if_combs[0].limits = hw_priv->if_limits1;
+	hw_priv->if_combs[0].n_limits = 2;
+
+	hw_priv->if_combs[1].num_different_channels = 1;
+
+#ifdef P2P_MULTIVIF
+	hw_priv->if_combs[1].max_interfaces = 3;
+#else
+	hw_priv->if_combs[1].max_interfaces = 2;
+#endif
+	hw_priv->if_combs[1].limits = hw_priv->if_limits2;
+	hw_priv->if_combs[1].n_limits = 1;
+
+	hw_priv->if_combs[2].num_different_channels = 1;
+#ifdef P2P_MULTIVIF
+	hw_priv->if_combs[2].max_interfaces = 3;
+#else
+	hw_priv->if_combs[2].max_interfaces = 2;
+#endif
+	hw_priv->if_combs[2].limits = hw_priv->if_limits3;
+	hw_priv->if_combs[2].n_limits = 2;
+
+	hw->wiphy->iface_combinations = &hw_priv->if_combs[0];
+	hw->wiphy->n_iface_combinations = 3;
+}
+
+static int xradio_device_init(struct xradio_common *hw_priv)
+{
+	int ret = 0;
+	SYS_BUG(!hw_priv);
+	/* Add pm device. */
+	hw_priv->plat_device = platform_device_alloc(XRADIO_PLAT_DEVICE, 0);
+	if (!hw_priv->plat_device) {
+		xradio_dbg(XRADIO_DBG_ERROR, "%s:platform_device_alloc failed!\n",
+				__func__);
+		return -ENOMEM;
+	}
+	hw_priv->plat_device->dev.platform_data = hw_priv;
+	ret = platform_device_add(hw_priv->plat_device);
+	if (ret) {
+		xradio_dbg(XRADIO_DBG_ERROR, "%s:platform_device_add failed(%d)!\n",
+				__func__, ret);
+		kfree(hw_priv->plat_device);
+		hw_priv->plat_device = NULL;
+		return ret;
+	}
+
+	return 0;
+
+}
+
+static void xradio_device_deinit(struct xradio_common *hw_priv)
+{
+	if (hw_priv->plat_device) {
+		hw_priv->plat_device->dev.platform_data = NULL;
+		/* kfree is already do in platform_device_unregister.*/
+		platform_device_unregister(hw_priv->plat_device);
+		hw_priv->plat_device = NULL;
+		hw_priv->pdev = NULL;
+	} else {
+		xradio_dbg(XRADIO_DBG_WARN, "%s:hw_priv->plat_device is NULL!\n",
+				__func__);
+	}
+}
+
+struct ieee80211_hw *xradio_init_common(size_t hw_priv_data_len)
+{
+	int i;
+	struct ieee80211_hw *hw;
+	struct xradio_common *hw_priv;
+	struct ieee80211_supported_band *sband;
+	int band;
+
+	xradio_dbg(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	/* Alloc ieee_802.11 hw and xradio_common struct. */
+	hw = mac80211_alloc_hw(hw_priv_data_len, &xradio_ops);
+	if (!hw)
+		return NULL;
+	hw_priv = hw->priv;
+	xradio_dbg(XRADIO_DBG_ALWY, "Allocated hw_priv @ %p\n", hw_priv);
+	xradio_dbg(XRADIO_DBG_MSG, "xradio_common_size=%zu, vif_data_size=%zu\n",
+			sizeof(struct xradio_common), sizeof(struct xradio_vif));
+	memset(hw_priv, 0, sizeof(*hw_priv));
+
+	/* Get MAC address. */
+	xradio_get_mac_addrs((u8 *)&hw_priv->addresses[0]);
+	memcpy(hw_priv->addresses[1].addr, hw_priv->addresses[0].addr, ETH_ALEN);
+	hw_priv->addresses[1].addr[5] += 0x01;
+#ifdef P2P_MULTIVIF
+	memcpy(hw_priv->addresses[2].addr, hw_priv->addresses[1].addr, ETH_ALEN);
+	hw_priv->addresses[2].addr[4] ^= 0x80;
+#endif
+
+	/* Initialize members of hw_priv. */
+	hw_priv->hw = hw;
+	hw_priv->if_id_slot = 0;
+	hw_priv->roc_if_id = -1;
+	atomic_set(&hw_priv->num_vifs, 0);
+	/* initial rates and channels TODO: fetch from FW */
+	hw_priv->rates = xradio_rates;
+	hw_priv->mcs_rates = xradio_n_rates;
+#ifdef ROAM_OFFLOAD
+	hw_priv->auto_scanning = 0;
+	hw_priv->frame_rcvd = 0;
+	hw_priv->num_scanchannels = 0;
+	hw_priv->num_2g_channels = 0;
+	hw_priv->num_5g_channels = 0;
+#endif /*ROAM_OFFLOAD*/
+#ifdef AP_AGGREGATE_FW_FIX
+	/* Enable block ACK for 4 TID (BE, VI, VI, VO). */
+	hw_priv->ba_tid_mask = 0xB1;  /*due to HW limitations*/
+#else
+	/* Enable block ACK for every TID but voice. */
+	hw_priv->ba_tid_mask = 0x3F;
+#endif
+	hw_priv->noise = -94;
+	/* hw_priv->beacon_req_id = cpu_to_le32(0); */
+
+	/* Initialize members of ieee80211_hw, it works in UMAC. */
+	hw->sta_data_size = sizeof(struct xradio_sta_priv);
+	hw->vif_data_size = sizeof(struct xradio_vif);
+
+	hw->flags = IEEE80211_HW_SIGNAL_DBM            |
+		    IEEE80211_HW_SUPPORTS_PS           |
+		    IEEE80211_HW_SUPPORTS_DYNAMIC_PS   |
+		    IEEE80211_HW_REPORTS_TX_ACK_STATUS |
+		    IEEE80211_HW_SUPPORTS_UAPSD        |
+		    IEEE80211_HW_CONNECTION_MONITOR    |
+		    IEEE80211_HW_SUPPORTS_CQM_RSSI     |
+		    IEEE80211_HW_MFP_CAPABLE		   |
+		    /* Aggregation is fully controlled by firmware.
+		     * Do not need any support from the mac80211 stack */
+		    /* IEEE80211_HW_AMPDU_AGGREGATION  | */
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+		    IEEE80211_HW_SUPPORTS_P2P_PS          |
+		    IEEE80211_HW_SUPPORTS_CQM_BEACON_MISS |
+		    IEEE80211_HW_SUPPORTS_CQM_TX_FAIL     |
+#endif /* CONFIG_XRADIO_USE_EXTENSIONS */
+		    IEEE80211_HW_BEACON_FILTER;
+
+	hw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION)    |
+				     BIT(NL80211_IFTYPE_ADHOC)      |
+				     BIT(NL80211_IFTYPE_AP)         |
+				     BIT(NL80211_IFTYPE_MESH_POINT) |
+				     BIT(NL80211_IFTYPE_P2P_CLIENT) |
+				     BIT(NL80211_IFTYPE_P2P_GO)		|
+					 BIT(NL80211_IFTYPE_P2P_DEVICE);
+
+	/* Support only for limited wowlan functionalities */
+#ifdef CONFIG_PM
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
+	hw->wiphy->wowlan = &xradio_wowlan;
+#else
+	hw->wiphy->wowlan.flags = WIPHY_WOWLAN_ANY | WIPHY_WOWLAN_DISCONNECT;
+	hw->wiphy->wowlan.n_patterns = 0;
+#endif
+#endif
+
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+	hw->wiphy->flags |= WIPHY_FLAG_AP_UAPSD;
+#endif /* CONFIG_XRADIO_USE_EXTENSIONS */
+
+#if defined(CONFIG_XRADIO_DISABLE_BEACON_HINTS)
+	hw->wiphy->flags |= WIPHY_FLAG_DISABLE_BEACON_HINTS;
+#endif
+	hw->wiphy->n_addresses = XRWL_MAX_VIFS;
+	hw->wiphy->addresses   = hw_priv->addresses;
+	/*
+	 * max_remain_on_channel_duration will bigger than 500 in
+	 * wpa_supplicant v2.3, change to 2500 and default value=5000 in umac.
+	 */
+	hw->wiphy->max_remain_on_channel_duration = 2500;
+	hw->channel_change_time = 500;	/* TODO: find actual value */
+	hw->extra_tx_headroom = WSM_TX_EXTRA_HEADROOM +
+				8  /* TKIP IV */      +
+				12 /* TKIP ICV and MIC */;
+	hw->wiphy->bands[NL80211_BAND_2GHZ] = &xradio_band_2ghz;
+#ifdef CONFIG_XRADIO_5GHZ_SUPPORT
+	hw->wiphy->bands[NL80211_BAND_5GHZ] = &xradio_band_5ghz;
+#endif /* CONFIG_XRADIO_5GHZ_SUPPORT */
+	hw->queues         = AC_QUEUE_NUM;
+	hw->max_rates      = MAX_RATES_STAGE;
+	hw->max_rate_tries = MAX_RATES_RETRY;
+	/* Channel params have to be cleared before registering wiphy again */
+	for (band = 0; band < NUM_NL80211_BANDS; band++) {
+		sband = hw->wiphy->bands[band];
+		if (!sband)
+			continue;
+		for (i = 0; i < sband->n_channels; i++) {
+			sband->channels[i].flags = 0;
+			sband->channels[i].max_antenna_gain = 0;
+			sband->channels[i].max_power = 30;
+		}
+	}
+	/*
+	 * hw_priv->channel init value is the local->oper_channel init value;
+	 *  when transplanting, take care.
+	 */
+	for (band = 0; band < NUM_NL80211_BANDS; band++) {
+		sband = hw->wiphy->bands[band];
+		if (!sband)
+			continue;
+		if (!hw_priv->channel) {
+			hw_priv->channel = &sband->channels[2];
+		}
+	}
+	hw->wiphy->max_scan_ssids = WSM_SCAN_MAX_NUM_OF_SSIDS;
+	hw->wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;
+	SET_IEEE80211_PERM_ADDR(hw, hw_priv->addresses[0].addr);
+
+	xradio_vendor_init(hw->wiphy);
+
+	/* Initialize locks. */
+	spin_lock_init(&hw_priv->vif_list_lock);
+	sema_init(&hw_priv->wsm_cmd_sema, 1);
+	sema_init(&hw_priv->conf_lock, 1);
+	sema_init(&hw_priv->wsm_oper_lock, 1);
+	atomic_set(&hw_priv->tx_lock, 0);
+	sema_init(&hw_priv->tx_lock_sem, 1);
+	sema_init(&hw_priv->dtor_lock, 1);
+
+	hw_priv->workqueue = create_singlethread_workqueue(XRADIO_WORKQUEUE);
+	hw_priv->spare_workqueue = create_singlethread_workqueue(XRADIO_SPARE_WORKQUEUE);
+	sema_init(&hw_priv->scan.lock, 1);
+	sema_init(&hw_priv->scan.status_lock, 1);
+	INIT_WORK(&hw_priv->scan.work, xradio_scan_work);
+#ifdef ROAM_OFFLOAD
+	INIT_WORK(&hw_priv->scan.swork, xradio_sched_scan_work);
+#endif /*ROAM_OFFLOAD*/
+	INIT_DELAYED_WORK(&hw_priv->scan.probe_work, xradio_probe_work);
+	INIT_DELAYED_WORK(&hw_priv->scan.timeout, xradio_scan_timeout);
+	hw_priv->scan.scan_failed_cnt = 0;
+	INIT_DELAYED_WORK(&hw_priv->rem_chan_timeout, xradio_rem_chan_timeout);
+	INIT_WORK(&hw_priv->tx_policy_upload_work, tx_policy_upload_work);
+	atomic_set(&hw_priv->upload_count, 0);
+	for (i = 0; i < (XRWL_MAX_VIFS-1); ++i) {
+		hw_priv->scan_delay_status[i] = XRADIO_SCAN_ALLOW;
+		hw_priv->scan_delay_time[i] = 0;
+	}
+
+	spin_lock_init(&hw_priv->event_queue_lock);
+	INIT_LIST_HEAD(&hw_priv->event_queue);
+	INIT_WORK(&hw_priv->event_handler, xradio_event_handler);
+	INIT_WORK(&hw_priv->ba_work, xradio_ba_work);
+	spin_lock_init(&hw_priv->ba_lock);
+	timer_setup(&hw_priv->ba_timer, xradio_ba_timer, 0);
+	timer_setup(&hw_priv->BT_timer, xradio_bt_timer, 0);
+
+	if (unlikely(xradio_queue_stats_init(&hw_priv->tx_queue_stats,
+			WLAN_LINK_ID_MAX, xradio_skb_dtor, hw_priv))) {
+		mac80211_free_hw(hw);
+		return NULL;
+	}
+	for (i = 0; i < AC_QUEUE_NUM; ++i) {
+		if (unlikely(xradio_queue_init(&hw_priv->tx_queue[i],
+				     &hw_priv->tx_queue_stats, i,
+				     XRWL_MAX_QUEUE_SZ, xradio_ttl[i]))) {
+			for (; i > 0; i--)
+				xradio_queue_deinit(&hw_priv->tx_queue[i - 1]);
+			xradio_queue_stats_deinit(&hw_priv->tx_queue_stats);
+			mac80211_free_hw(hw);
+			return NULL;
+		}
+	}
+
+	init_waitqueue_head(&hw_priv->channel_switch_done);
+	init_waitqueue_head(&hw_priv->wsm_cmd_wq);
+	init_waitqueue_head(&hw_priv->wsm_wakeup_done);
+	init_waitqueue_head(&hw_priv->wsm_startup_done);
+	init_waitqueue_head(&hw_priv->offchannel_wq);
+	hw_priv->wsm_caps.firmwareReady = 0;
+	hw_priv->driver_ready = 0;
+	hw_priv->offchannel_done = 0;
+	wsm_buf_init(&hw_priv->wsm_cmd_buf, xr_sdio_blksize_align(1024));
+	spin_lock_init(&hw_priv->wsm_cmd.lock);
+	tx_policy_init(hw_priv);
+	xradio_init_resv_skb(hw_priv);
+
+	for (i = 0; i < XRWL_MAX_VIFS; i++)
+		hw_priv->hw_bufs_used_vif[i] = 0;
+
+#ifdef MCAST_FWDING
+	wsm_init_release_buffer_request(hw_priv);
+	hw_priv->buf_released = 0;
+#endif
+	hw_priv->vif0_throttle = XRWL_HOST_VIF0_11BG_THROTTLE;
+	hw_priv->vif1_throttle = XRWL_HOST_VIF1_11BG_THROTTLE;
+
+#if defined(CONFIG_XRADIO_DEBUG)
+	hw_priv->wsm_enable_wsm_dumps = 0;
+	hw_priv->wsm_dump_max_size = WSM_DUMP_MAX_SIZE;
+#endif /* CONFIG_XRADIO_DEBUG */
+	hw_priv->query_packetID = 0;
+	atomic_set(&hw_priv->query_cnt, 0);
+	INIT_WORK(&hw_priv->query_work, wsm_query_work);
+	atomic_set(&hw_priv->suspend_state, XRADIO_RESUME);
+	atomic_set(&hw_priv->suspend_lock_state, XRADIO_SUSPEND_LOCK_IDEL);
+
+#ifdef HW_RESTART
+	hw_priv->exit_sync  = false;
+	hw_priv->hw_restart = false;
+	INIT_WORK(&hw_priv->hw_restart_work, xradio_restart_work);
+#endif
+
+#ifdef CONFIG_XRADIO_TESTMODE
+	hw_priv->test_frame.data = NULL;
+	hw_priv->test_frame.len = 0;
+	spin_lock_init(&hw_priv->tsm_lock);
+	INIT_DELAYED_WORK(&hw_priv->advance_scan_timeout,
+			  xradio_advance_scan_timeout);
+#endif /*CONFIG_XRADIO_TESTMODE*/
+
+	xradio_set_ifce_comb(hw_priv, hw_priv->hw);
+#ifdef MONITOR_MODE
+	hw_priv->monitor_if_id = -1;
+	hw_priv->monitor_running = false;
+#endif
+#ifdef BOOT_NOT_READY_FIX
+	hw_priv->boot_not_ready_cnt = 0;
+	hw_priv->boot_not_ready = 0;
+#endif
+	hw_priv->join_chan = 1;
+
+	if (!g_hw_priv) {
+		g_hw_priv = hw_priv;
+		return hw;
+	} else {		/*error:didn't release hw_priv last time. */
+		mac80211_free_hw(hw);
+		xradio_dbg(XRADIO_DBG_ERROR, "g_hw_priv is not NULL @ %p!\n", g_hw_priv);
+		return NULL;
+	}
+}
+
+void xradio_free_common(struct ieee80211_hw *dev)
+{
+	int i;
+	struct xradio_common *hw_priv = dev->priv;
+	xradio_dbg(XRADIO_DBG_TRC, "%s\n", __func__);
+
+#ifdef CONFIG_XRADIO_TESTMODE
+	kfree(hw_priv->test_frame.data);
+#endif /* CONFIG_XRADIO_TESTMODE */
+
+	cancel_work_sync(&hw_priv->query_work);
+	del_timer_sync(&hw_priv->ba_timer);
+	del_timer_sync(&hw_priv->BT_timer);
+	wsm_buf_deinit(&hw_priv->wsm_cmd_buf);
+	flush_workqueue(hw_priv->workqueue);
+	destroy_workqueue(hw_priv->workqueue);
+	hw_priv->workqueue = NULL;
+	flush_workqueue(hw_priv->spare_workqueue);
+	destroy_workqueue(hw_priv->spare_workqueue);
+	hw_priv->spare_workqueue = NULL;
+
+	xradio_deinit_resv_skb(hw_priv);
+	if (hw_priv->skb_cache) {
+		dev_kfree_skb(hw_priv->skb_cache);
+		hw_priv->skb_cache = NULL;
+	}
+
+	for (i = 0; i < 4; ++i)
+		xradio_queue_deinit(&hw_priv->tx_queue[i]);
+	xradio_queue_stats_deinit(&hw_priv->tx_queue_stats);
+
+#ifdef CONFIG_XRADIO_DEBUG
+	for (i = 0; i < XRWL_MAX_VIFS; i++) {
+		if (hw_priv->vif_list[i])
+			xradio_dbg(XRADIO_DBG_ERROR,
+			"vif_list[%d]is not NULL @ %p!\n", i, hw_priv->vif_list[i]);
+	}
+#endif
+
+#ifdef MCAST_FWDING
+	wsm_deinit_release_buffer(hw_priv);
+#endif
+	/* unsigned int i; */
+	mac80211_free_hw(dev);
+	g_hw_priv = NULL;
+}
+
+int xradio_register_common(struct ieee80211_hw *dev)
+{
+	int err = 0;
+	struct xradio_common *hw_priv = dev->priv;
+	xradio_dbg(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	SET_IEEE80211_DEV(dev, hw_priv->pdev);
+	err = mac80211_register_hw(dev);
+	if (err) {
+		xradio_dbg(XRADIO_DBG_ERROR, "Cannot register device (%d).\n", err);
+		return err;
+	}
+	xradio_dbg(XRADIO_DBG_MSG, "is registered as '%s'\n",
+		   wiphy_name(dev->wiphy));
+	xradio_debug_init_common(hw_priv);
+
+#ifdef CONFIG_XRADIO_DEBUGFS
+#if (SUPPORT_EPTA)
+	SYS_WARN(wsm_set_epta_stat_dbg_ctrl(hw_priv, epta_stat_dbg_ctrl));
+#endif
+#endif
+
+	hw_priv->driver_ready = 1;
+	wake_up(&hw_priv->wsm_startup_done);
+	return 0;
+}
+
+void xradio_unregister_common(struct ieee80211_hw *dev)
+{
+	struct xradio_common *hw_priv = dev->priv;
+	xradio_dbg(XRADIO_DBG_TRC, "%s\n", __func__);
+#ifdef CONFIG_XRADIO_ETF
+	if (etf_is_connect()) {
+		return ;
+	}
+#endif
+
+	if (wiphy_dev(dev->wiphy)) {
+		mac80211_unregister_hw(dev);
+		SET_IEEE80211_DEV(dev, NULL);
+		xradio_debug_release_common(hw_priv);
+	}
+	hw_priv->driver_ready = 0;
+}
+
+#ifdef HW_RESTART
+static int xradio_find_rfkill(struct device *dev, void *data)
+{
+	if (dev_name(dev)[0] == 'r' && dev_name(dev)[1] == 'f')
+		return true;
+	return false;
+}
+
+int xradio_core_reinit(struct xradio_common *hw_priv)
+{
+	int ret = 0;
+	u16 ctrl_reg;
+	int i = 0;
+	struct device *rfkill;
+	struct xradio_vif *priv = NULL;
+	struct wsm_operational_mode mode = {
+		.power_mode = wsm_power_mode_quiescent,
+		.disableMoreFlagUsage = true,
+	};
+
+	if (!hw_priv) {
+		xradio_dbg(XRADIO_DBG_ERROR, "%s hw_priv is NULL!\n", __func__);
+		return -1;
+	}
+
+	/* Need some time for restart hardware, don't suspend again.*/
+#ifdef CONFIG_PM
+	xradio_pm_lock_awake(&hw_priv->pm_state);
+#endif
+
+	xradio_dbg(XRADIO_DBG_ALWY, "%s %d!\n", __func__, __LINE__);
+
+	/* Disconnect with AP or STAs. */
+	xradio_for_each_vif(hw_priv, priv, i) {
+		if (!priv)
+			continue;
+		if (priv->join_status == XRADIO_JOIN_STATUS_STA) {
+			mac80211_connection_loss(priv->vif);
+			msleep(200);
+		} else if (priv->join_status == XRADIO_JOIN_STATUS_AP) {
+			wsm_send_disassoc_to_self(hw_priv, priv);
+			msleep(200);
+		}
+		xradio_remove_interface(hw_priv->hw, priv->vif);
+	}
+	xradio_stop(hw_priv->hw);
+	/* lock queue of network. */
+	xradio_tx_queues_lock(hw_priv);
+
+#ifdef BH_PROC_THREAD
+	/* restart proc thread. */
+	bh_proc_reinit(hw_priv);
+#endif
+
+	/*deinit dev */
+	xradio_dev_deinit(hw_priv);
+
+	/*reinit status refer to hif. */
+	hw_priv->powersave_enabled = false;
+	hw_priv->wsm_caps.firmwareReady = 0;
+	atomic_set(&hw_priv->bh_rx, 0);
+	atomic_set(&hw_priv->bh_tx, 0);
+	atomic_set(&hw_priv->bh_term, 0);
+	hw_priv->buf_id_tx = 0;
+	hw_priv->buf_id_rx = 0;
+	hw_priv->wsm_rx_seq = 0;
+	hw_priv->wsm_tx_seq = 0;
+	hw_priv->device_can_sleep = 0;
+	hw_priv->hw_bufs_used = 0;
+#ifdef BOOT_NOT_READY_FIX
+	hw_priv->boot_not_ready_cnt = 0;
+	hw_priv->boot_not_ready = 0;
+#endif
+	memset(&hw_priv->hw_bufs_used_vif, 0, sizeof(hw_priv->hw_bufs_used_vif));
+	for (i = 0; i < (XRWL_MAX_VIFS-1); ++i) {
+		hw_priv->scan_delay_status[i] = XRADIO_SCAN_ALLOW;
+		hw_priv->scan_delay_time[i] = 0;
+	}
+	atomic_set(&hw_priv->query_cnt, 0);
+	hw_priv->query_packetID = 0;
+	tx_policy_init(hw_priv);
+
+#ifdef BOOT_NOT_READY_FIX
+restart:
+#endif
+
+	/*move parent to plat_device*/
+	ret = device_move(&hw_priv->hw->wiphy->dev,
+			&hw_priv->plat_device->dev, 0);
+	if (ret < 0) {
+		xradio_dbg(XRADIO_DBG_ERROR,
+			"%s:device move parent"
+			"to plat_device failed\n", __func__);
+		goto exit;
+	}
+	ret = mac80211_ifdev_move(hw_priv->hw,
+			&hw_priv->plat_device->dev, 0);
+	if (ret < 0) {
+		xradio_dbg(XRADIO_DBG_ERROR,
+			"%s:net_device move parent"
+			"to plat_device failed\n", __func__);
+		goto exit;
+	}
+
+	/*reinit sdio sbus. */
+	sbus_sdio_deinit();
+	hw_priv->pdev = sbus_sdio_init((struct sbus_ops **)&hw_priv->sbus_ops,
+				       &hw_priv->sbus_priv);
+	if (!hw_priv->pdev) {
+		xradio_dbg(XRADIO_DBG_ERROR, "%s:sbus_sdio_init failed\n", __func__);
+		ret = -ETIMEDOUT;
+		goto exit;
+	}
+
+	/*move parent to sdio device*/
+	ret = device_move(&hw_priv->hw->wiphy->dev, hw_priv->pdev, 1);
+	if (ret < 0) {
+		xradio_dbg(XRADIO_DBG_ERROR,
+			"%s:device move parent to sdio failed\n", __func__);
+		goto exit;
+	}
+	SET_IEEE80211_DEV(hw_priv->hw, hw_priv->pdev);
+	ret = mac80211_ifdev_move(hw_priv->hw, hw_priv->pdev, 1);
+	if (ret < 0) {
+		xradio_dbg(XRADIO_DBG_ERROR,
+			"%s:net_device move parent to sdio failed\n", __func__);
+		goto exit;
+	}
+
+	rfkill = device_find_child(&hw_priv->hw->wiphy->dev, NULL, xradio_find_rfkill);
+	device_move(rfkill, &hw_priv->hw->wiphy->dev, 1);
+	put_device(rfkill);
+
+	/*wake up bh thread. */
+	if (hw_priv->bh_thread == NULL) {
+		hw_priv->bh_error = 0;
+		atomic_set(&hw_priv->tx_lock, 0);
+		xradio_register_bh(hw_priv);
+	} else {
+#ifdef CONFIG_XRADIO_SUSPEND_POWER_OFF
+		WARN_ON(xradio_bh_resume(hw_priv));
+#endif
+	}
+
+	/* Load firmware and register Interrupt Handler */
+	ret = xradio_load_firmware(hw_priv);
+#ifdef BOOT_NOT_READY_FIX
+	if (ret && hw_priv->boot_not_ready && (hw_priv->boot_not_ready_cnt < 6)) {
+		ret = 0;
+		hw_priv->boot_not_ready = 0;
+		if (hw_priv->bh_thread != NULL)
+			xradio_unregister_bh(hw_priv);
+		goto restart;
+	}
+#endif
+	if (ret) {
+		xradio_dbg(XRADIO_DBG_ERROR, "%s:xradio_load_firmware failed(%d).\n",
+			   __func__, ret);
+		goto exit;
+	}
+
+	/* Set sdio blocksize. */
+	hw_priv->sbus_ops->lock(hw_priv->sbus_priv);
+	SYS_WARN(hw_priv->sbus_ops->set_block_size(hw_priv->sbus_priv,
+		 SDIO_BLOCK_SIZE));
+	hw_priv->sbus_ops->unlock(hw_priv->sbus_priv);
+	if (wait_event_interruptible_timeout(hw_priv->wsm_startup_done,
+				hw_priv->wsm_caps.firmwareReady, 3*HZ) <= 0) {
+
+		/* TODO: Needs to find how to reset device */
+		/*       in QUEUE mode properly.           */
+		xradio_dbg(XRADIO_DBG_ERROR, "%s:Firmware Startup Timeout!\n",
+			   __func__);
+		ret = -ETIMEDOUT;
+		goto exit;
+	}
+	xradio_dbg(XRADIO_DBG_ALWY, "%s:Firmware Startup Done.\n", __func__);
+
+	/* Keep device wake up. */
+	ret = xradio_reg_write_16(hw_priv, HIF_CONTROL_REG_ID, HIF_CTRL_WUP_BIT);
+	if (xradio_reg_read_16(hw_priv, HIF_CONTROL_REG_ID, &ctrl_reg))
+		ret = xradio_reg_read_16(hw_priv, HIF_CONTROL_REG_ID, &ctrl_reg);
+	SYS_WARN(!(ctrl_reg & HIF_CTRL_RDY_BIT));
+
+	/*
+	 * We finish device restart here.
+	 */
+	hw_priv->hw_restart = false;
+	atomic_set(&hw_priv->suspend_state, XRADIO_RESUME);
+	wake_up(&hw_priv->wsm_wakeup_done);
+
+	/* Set device mode parameter. */
+	for (i = 0; i < xrwl_get_nr_hw_ifaces(hw_priv); i++) {
+		/* Set low-power mode. */
+		ret = wsm_set_operational_mode(hw_priv, &mode, i);
+		/* Enable multi-TX confirmation */
+		ret = wsm_use_multi_tx_conf(hw_priv, true, i);
+	}
+
+#ifdef CONFIG_XRADIO_DEBUGFS
+#if (SUPPORT_EPTA)
+	SYS_WARN(wsm_set_epta_stat_dbg_ctrl(hw_priv, epta_stat_dbg_ctrl));
+#endif
+#endif
+
+#if 0
+	/*
+	 * IF USE xradio_register_common TO REINIT, U SHOULD ENABLE THIS.
+	 * fix super standby hang in scan interface.
+	 * Since resume from super standby, mac system will register ieee80211_hw to
+	 * subsystem, and the wiphy->max_scan_ie_len will decrease 47 every round whose
+	 * initial value is IEEE80211_MAX_DATA_LEN, after about 40~50 round, this value will
+	 * under 143. and the 143 is the default scan ie length from supplicant, this will return
+	 * -22 in nl80211.c
+	 * if (n_ssids > wiphy->max_scan_ssids) {
+	 * 	return -EINVAL;
+	 * }
+	 * we need to reinit this value in super standby recovery.
+	 */
+	hw_priv->hw->wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;
+#endif
+	/*
+	 * Restart umac, use mac80211_restart_hw.
+	 * Use xradio_register_common may cause umac scan sync problems.
+	 */
+	if (!ret) {
+		mac80211_restart_hw(hw_priv->hw);
+	}
+
+	/*
+	 * Unlock queue of network. regardless of xradio_tx_queues_lock,
+	 * this must be here to make sure all queue is unlock.
+	 */
+	for (i = 0; i < 4; ++i) {
+		struct xradio_queue *queue = &hw_priv->tx_queue[i];
+		spin_lock_bh(&queue->lock);
+		if (queue->tx_locked_cnt > 0) {
+			queue->tx_locked_cnt = 0;
+			mac80211_wake_queue(hw_priv->hw, queue->queue_id);
+		}
+		spin_unlock_bh(&queue->lock);
+	}
+
+exit:
+#ifdef CONFIG_PM
+	xradio_pm_unlock_awake(&hw_priv->pm_state);
+#endif
+	xradio_dbg(XRADIO_DBG_ALWY, "%s end!\n", __func__);
+
+	return ret;
+}
+void xradio_restart_work(struct work_struct *work)
+{
+	struct xradio_common *hw_priv =
+		container_of(work, struct xradio_common, hw_restart_work);
+	xradio_dbg(XRADIO_DBG_ALWY, "%s\n", __func__);
+
+	hw_priv->hw_restart_work_running = 1;
+	if (hw_priv->bh_error) {
+		xradio_unregister_bh(hw_priv);
+	}
+	if (unlikely(xradio_core_reinit(hw_priv))) {
+		xradio_dbg(XRADIO_DBG_ALWY, "%s again!\n", __func__);
+		down(&hw_priv->wsm_cmd_sema);
+		hw_priv->hw_restart = true;
+		up(&hw_priv->wsm_cmd_sema);
+		if (hw_priv->bh_thread != NULL)
+			xradio_unregister_bh(hw_priv);
+#ifdef ERROR_HANG_DRIVER
+		if (error_hang_driver) {
+			/*it will arrive here if error occurs in poweroff resume.*/
+			hw_priv->bh_error = 0x80000000; /*make it different from real bh error.*/
+			wsm_printk(XRADIO_DBG_ERROR, "%s error_hang_driver\n", __func__);
+			hw_priv->hw_restart_work_running = 0;
+			return ;
+		}
+#endif
+		xradio_core_reinit(hw_priv);
+	}
+	hw_priv->hw_restart_work_running = 0;
+}
+#endif
+
+int xradio_core_init(void)
+{
+	int err = -ENOMEM;
+	u16 ctrl_reg;
+	int if_id;
+	struct ieee80211_hw *dev;
+	struct xradio_common *hw_priv;
+	struct wsm_operational_mode mode = {
+		.power_mode = wsm_power_mode_quiescent,
+		.disableMoreFlagUsage = true,
+	};
+	xradio_version_show();
+
+	/*init xradio_common */
+	dev = xradio_init_common(sizeof(struct xradio_common));
+	if (!dev) {
+		xradio_dbg(XRADIO_DBG_ERROR, "xradio_init_common failed\n");
+		return err;
+	}
+	hw_priv = dev->priv;
+	if (xradio_device_init(hw_priv)) {
+		xradio_free_common(dev);
+		xradio_dbg(XRADIO_DBG_ERROR, "xradio_device_init failed\n");
+		return err;
+	}
+
+#ifdef BH_PROC_THREAD
+	err = bh_proc_init(hw_priv);
+	if (err) {
+		bh_printk(XRADIO_DBG_ERROR,
+			"%s bh_proc_init err=%d\n", __func__, err);
+		return err;
+	}
+#endif
+
+#ifdef BOOT_NOT_READY_FIX
+start:
+#endif
+	/*init sdio sbus */
+	hw_priv->pdev = sbus_sdio_init((struct sbus_ops **)&hw_priv->sbus_ops,
+				&hw_priv->sbus_priv);
+	if (!hw_priv->pdev) {
+		err = -ETIMEDOUT;
+		xradio_dbg(XRADIO_DBG_ERROR, "sbus_sdio_init failed\n");
+		goto err1;
+	}
+
+	/* WSM callbacks. */
+	hw_priv->wsm_cbc.scan_complete = xradio_scan_complete_cb;
+	hw_priv->wsm_cbc.tx_confirm = xradio_tx_confirm_cb;
+	hw_priv->wsm_cbc.rx = xradio_rx_cb;
+	hw_priv->wsm_cbc.suspend_resume = xradio_suspend_resume;
+	/* hw_priv->wsm_cbc.set_pm_complete = xradio_set_pm_complete_cb; */
+	hw_priv->wsm_cbc.channel_switch = xradio_channel_switch_cb;
+
+	/*init pm and wakelock. */
+#ifdef CONFIG_PM
+	err = xradio_pm_init(&hw_priv->pm_state, hw_priv);
+	if (err) {
+		xradio_dbg(XRADIO_DBG_ERROR, "xradio_pm_init failed(%d).\n", err);
+		goto err2;
+	}
+#endif
+	/* Register bh thread*/
+	err = xradio_register_bh(hw_priv);
+	if (err) {
+		xradio_dbg(XRADIO_DBG_ERROR, "xradio_register_bh failed(%d).\n",
+			   err);
+		goto err3;
+	}
+
+	/* Load firmware and register Interrupt Handler */
+	err = xradio_load_firmware(hw_priv);
+#ifdef BOOT_NOT_READY_FIX
+	if (err && hw_priv->boot_not_ready && (hw_priv->boot_not_ready_cnt < 6)) {/*workaround that */
+		hw_priv->boot_not_ready = 0;
+		err = 0;
+		xradio_unregister_bh(hw_priv);
+#ifdef CONFIG_PM
+		xradio_pm_deinit(&hw_priv->pm_state);
+#endif
+		sbus_sdio_deinit();
+		goto start;
+	}
+#endif
+	if (err) {
+		xradio_dbg(XRADIO_DBG_ERROR, "xradio_load_firmware failed(%d).\n",
+			   err);
+		goto err4;
+	}
+
+	/* Set sdio blocksize. */
+	hw_priv->sbus_ops->lock(hw_priv->sbus_priv);
+	SYS_WARN(hw_priv->sbus_ops->set_block_size(hw_priv->sbus_priv,
+			SDIO_BLOCK_SIZE));
+	hw_priv->sbus_ops->unlock(hw_priv->sbus_priv);
+
+	if (wait_event_interruptible_timeout(hw_priv->wsm_startup_done,
+				hw_priv->wsm_caps.firmwareReady, 3*HZ) <= 0) {
+
+		/* TODO: Needs to find how to reset device */
+		/*       in QUEUE mode properly.           */
+		xradio_dbg(XRADIO_DBG_ERROR, "Firmware Startup Timeout!\n");
+		err = -ETIMEDOUT;
+		goto err5;
+	}
+	xradio_dbg(XRADIO_DBG_ALWY, "Firmware Startup Done.\n");
+
+	/* Keep device wake up. */
+	err = xradio_reg_bit_operate(hw_priv, HIF_CONTROL_REG_ID, HIF_CTRL_WUP_BIT, 0);
+	if (err) {
+		xradio_dbg(XRADIO_DBG_ERROR, "device wake up failed(%d)!\n", err);
+		goto err5;
+	}
+	SYS_WARN(xradio_reg_read_16(hw_priv, HIF_CONTROL_REG_ID, &ctrl_reg));
+	SYS_WARN(!(ctrl_reg & HIF_CTRL_RDY_BIT));
+
+	/* ETF mode don't need following steps, just return here*/
+#ifdef CONFIG_XRADIO_ETF
+	if (etf_is_connect()) {
+		etf_set_core(hw_priv);
+		xradio_dbg(XRADIO_DBG_ALWY, "%s Enter ETF mode!\n", __func__);
+		return 0;
+	}
+#endif
+
+	/* Set device mode parameter. */
+	for (if_id = 0; if_id < xrwl_get_nr_hw_ifaces(hw_priv); if_id++) {
+		u32 multi_enabled = __cpu_to_le32(BIT(0));
+		/* Set low-power mode. */
+		SYS_WARN(wsm_set_operational_mode(hw_priv, &mode, if_id));
+		if (hw_priv->wsm_caps.firmwareCap & 0x8000) {
+			multi_enabled |= __cpu_to_le32(BIT(2));
+			xradio_dbg(XRADIO_DBG_WARN, "enable Multi-Rx!\n");
+		}
+		/* Enable multi-TX confirmation */
+		SYS_WARN(wsm_use_multi_tx_conf(hw_priv, multi_enabled, if_id));
+	}
+
+	/* Register wireless net device. */
+	err = xradio_register_common(dev);
+	if (err) {
+		xradio_dbg(XRADIO_DBG_ERROR,
+			   "xradio_register_common failed(%d)!\n", err);
+		goto err5;
+	}
+	return err;
+
+err5:
+	xradio_dev_deinit(hw_priv);
+err4:
+	xradio_unregister_bh(hw_priv);
+err3:
+#ifdef CONFIG_PM
+	xradio_pm_deinit(&hw_priv->pm_state);
+err2:
+#endif
+#ifdef ERROR_HANG_DRIVER
+	/*we want to use sdio in hang driver.*/
+	if (!error_hang_driver) {
+		sbus_sdio_deinit();
+	}
+#else
+	sbus_sdio_deinit();
+#endif
+err1:
+#ifdef ERROR_HANG_DRIVER
+	xradio_hang_driver_for_debug(hw_priv, err);
+#endif
+	xradio_device_deinit(hw_priv);
+	xradio_free_common(dev);
+	return err;
+}
+
+void xradio_core_deinit(void)
+{
+	xradio_dbg(XRADIO_DBG_TRC, "%s\n", __func__);
+	if (g_hw_priv) {
+#ifdef HW_RESTART
+		down(&g_hw_priv->wsm_cmd_sema);
+		g_hw_priv->exit_sync = true;
+		up(&g_hw_priv->wsm_cmd_sema);
+		cancel_work_sync(&g_hw_priv->hw_restart_work);
+#endif
+		xradio_vendor_close_mkeep_alive();
+#ifdef ERROR_HANG_DRIVER
+		/*we hang driver here before unregister.*/
+		xradio_hang_driver_for_debug(g_hw_priv, g_hw_priv->bh_error);
+#endif
+
+#ifdef CONFIG_XRADIO_ETF
+		if (etf_is_connect()) {
+			etf_set_core(NULL);
+			xradio_dbg(XRADIO_DBG_ALWY, "%s Exit ETF mode!\n", __func__);
+		} else
+			xradio_unregister_common(g_hw_priv->hw);
+#else
+		xradio_unregister_common(g_hw_priv->hw);
+#endif
+
+#ifdef BH_PROC_THREAD
+		bh_proc_deinit(g_hw_priv);
+#endif
+		xradio_dev_deinit(g_hw_priv);
+		xradio_unregister_bh(g_hw_priv);
+#ifdef CONFIG_PM
+		xradio_pm_deinit(&g_hw_priv->pm_state);
+#endif
+		xradio_device_deinit(g_hw_priv);
+		xradio_free_common(g_hw_priv->hw);
+		sbus_sdio_deinit();
+	}
+	return;
+}
+
+static int hwinfo_proc_show(struct seq_file *m, void *v)
+{
+	char *buf;
+	size_t hwinfo_size = HWINFO_SIZE;
+	size_t size;
+
+	if (hwinfo_buffer == NULL)
+		return 0;
+
+	size = seq_get_buf(m, &buf);
+
+	/* single_ can only show once */
+	if (unlikely(hwinfo_size >= size)) {
+		/* if buffer is not enough, seq will double it and try again */
+		xradio_dbg(XRADIO_DBG_WARN,
+				   "hwinfo file size is over than seq buffer, try expand and try again\n");
+		/* set seq overflowed like seq_set_overflow() */
+		seq_commit(m, size);
+		goto out;
+	}
+
+	mutex_lock(&hwinfo_buffer_lock);
+	memcpy(buf, hwinfo_buffer, hwinfo_size);
+	mutex_unlock(&hwinfo_buffer_lock);
+	seq_commit(m, hwinfo_size);
+
+out:
+	return 0;
+}
+
+int hwinfo_proc_open(struct inode *p_inode, struct file *p_file)
+{
+	return single_open(p_file, hwinfo_proc_show, NULL);
+}
+
+static struct proc_ops hwinfo_proc_op = {
+//	.owner			= THIS_MODULE,
+	.proc_open		= hwinfo_proc_open,
+	.proc_read		= seq_read,
+	.proc_lseek		= seq_lseek,
+	.proc_release	= single_release,
+};
+
+/* Init Module function -> Called by insmod */
+int __init xradio_core_entry(void)
+{
+	int ret = 0;
+	xradio_dbg(XRADIO_DBG_TRC, "%s\n", __func__);
+	ret = xradio_plat_init();
+	if (ret) {
+		xradio_dbg(XRADIO_DBG_ERROR, "xradio_plat_init failed(%d)!\n", ret);
+		return ret;
+	}
+	ret = xradio_host_dbg_init();
+	if (ret) {
+		xradio_dbg(XRADIO_DBG_ERROR, "%s dbg init failed(%d)!\n", __func__, ret);
+		xradio_plat_deinit();
+		return ret;
+	}
+#ifdef CONFIG_XRADIO_ETF
+	ret = xradio_etf_init();
+	if (ret) {
+		xradio_dbg(XRADIO_DBG_ERROR, "%s ETF init failed(%d)!\n", __func__, ret);
+		xradio_host_dbg_deinit();
+		xradio_plat_deinit();
+		return ret;
+	}
+#endif
+
+	hwinfo_proc_dir = proc_mkdir("xradio", NULL);
+	hwinfo_proc_node = proc_create("hwinfo", 0644, hwinfo_proc_dir, &hwinfo_proc_op);
+
+	return 0;
+}
+
+/* Called at Driver Unloading */
+void xradio_core_exit(void)
+{
+	remove_proc_entry("hwinfo", hwinfo_proc_dir);
+	remove_proc_entry("xradio", NULL);
+
+	if (hwinfo_buffer) {
+		kfree(hwinfo_buffer);
+		hwinfo_buffer = NULL;
+	}
+
+#ifdef CONFIG_XRADIO_ETF
+	xradio_etf_deinit();
+#endif
+	xradio_host_dbg_deinit();
+	xradio_plat_deinit();
+	xradio_dbg(XRADIO_DBG_TRC, "%s\n", __func__);
+}
+
diff -Naurp a/drivers/net/wireless/xr829/wlan/nl80211_testmode_msg_copy.h b/drivers/net/wireless/xr829/wlan/nl80211_testmode_msg_copy.h
--- a/drivers/net/wireless/xr829/wlan/nl80211_testmode_msg_copy.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/nl80211_testmode_msg_copy.h	2022-08-27 01:22:42.966539908 +0300
@@ -0,0 +1,157 @@
+/*
+ * test mode interfaces for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef XR_NL80211_TESTMODE_MSG_COPY_H
+#define XR_NL80211_TESTMODE_MSG_COPY_H
+
+/* example command structure for test purposes */
+struct xr_msg_test_t {
+	int dummy;
+};
+
+/* example reply structure for test purposes */
+struct xr_reply_test_t {
+	int dummy;
+};
+
+/* example event structure for test purposes */
+struct xr_event_test_t {
+	int dummy;
+};
+
+enum xr_msg_id {
+	XR_MSG_TEST = 0,	/* for test purposes */
+	XR_MSG_EVENT_TEST,	/* for test purposes */
+	XR_MSG_SET_SNAP_FRAME,
+	XR_MSG_EVENT_FRAME_DATA,
+#ifdef CONFIG_XRADIO_TESTMODE
+	XR_MSG_GET_TX_POWER_LEVEL,
+	XR_MSG_GET_TX_POWER_RANGE,
+	XR_MSG_SET_ADVANCE_SCAN_ELEMS,
+	XR_MSG_SET_TX_QUEUE_PARAMS,
+	XR_MSG_START_STOP_TSM,
+	XR_MSG_GET_TSM_PARAMS,
+	XR_MSG_GET_ROAM_DELAY,
+#endif /*CONFIG_XRADIO_TESTMODE*/
+	XR_MSG_SET_POWER_SAVE,
+	/* Add new IDs here */
+
+	XR_MSG_ID_MAX,
+};
+
+enum xr_nl80211_testmode_data_attributes {
+	XR_TM_MSG_ID = 0x0001,	/* u32 type containing the XR message ID */
+	XR_TM_MSG_DATA,	/* message payload */
+
+	/* Max indicator so module test may add its own attributes */
+	XR_TM_MSG_ATTR_MAX,
+};
+
+/**
+ * xr_msg_set_snap_frame - set SNAP frame format
+ * @len: length of SNAP frame, if 0 SNAP frame disabled
+ * @frame: SNAP frame format
+ *
+ * In this structure is difference between user space because
+ * format and length have to be hidden
+ *
+ */
+struct xr_msg_set_snap_frame {
+	u8 len;
+	u8 frame[0];
+};
+
+#ifdef CONFIG_XRADIO_TESTMODE
+/**
+ * xr_msg_set_txqueue_params - store Tx queue params
+ * @user_priority: User priority for which TSPEC negotiated
+ * @medium_time: Allowed medium time
+ * @expiry_time: The expiry time of MSDU
+ *
+ */
+struct xr_msg_set_txqueue_params {
+	u8 user_priority;
+	u16 medium_time;
+	u16 expiry_time;
+};
+
+/**
+ * xr_tsm_stats - To retrieve the Transmit Stream Measurement stats
+ * @actual_msrmt_start_time: The TSF at the time at which the measurement
+ * started
+ * @msrmt_duration: Duration for measurement
+ * @peer_sta_addr: Peer STA address
+ * @tid: TID for which measurements were made
+ * @reporting_reason: Reason for report sent
+ * @txed_msdu_count: The number of MSDUs transmitted for the specified TID
+ * @msdu_discarded_count: The number of discarded MSDUs for the specified TID
+ * @msdu_failed_count: The number of failed MSDUs for the specified TID
+ * @multi_retry_count: The number of MSDUs which were retried
+ * @qos_cfpolls_lost_count: The number of QOS CF polls frames lost
+ * @avg_q_delay: Average queue delay
+ * @avg_transmit_delay: Average transmit delay
+ * @bin0_range: Delay range of the first bin (Bin 0)
+ * @bin0: bin0 transmit delay histogram
+ * @bin1: bin1 transmit delay histogram
+ * @bin2: bin2 transmit delay histogram
+ * @bin3: bin3 transmit delay histogram
+ * @bin4: bin4 transmit delay histogram
+ * @bin5: bin5 transmit delay histogram
+ *
+ */
+struct xr_tsm_stats {
+	u64 actual_msrmt_start_time;
+	u16 msrmt_duration;
+	u8 peer_sta_addr[6];
+	u8 tid;
+	u8 reporting_reason;
+	u32 txed_msdu_count;
+	u32 msdu_discarded_count;
+	u32 msdu_failed_count;
+	u32 multi_retry_count;
+	u32 qos_cfpolls_lost_count;
+	u32 avg_q_delay;
+	u32 avg_transmit_delay;
+	u8 bin0_range;
+	u32 bin0;
+	u32 bin1;
+	u32 bin2;
+	u32 bin3;
+	u32 bin4;
+	u32 bin5;
+} __packed;
+
+
+/**
+ * xr_msg_set_start_stop_tsm - To start or stop collecting TSM metrics in
+ * xradio driver
+ * @start: To start or stop collecting TSM metrics
+ * @up: up for which metrics to be collected
+ * @packetization_delay: Packetization period for this TID
+ *
+ */
+struct xr_msg_start_stop_tsm {
+	u8 start;	/*1: To start, 0: To stop*/
+	u8 up;
+	u16 packetization_delay;
+};
+
+/**
+ * power_save_elems - To enable/disable legacy power Save
+ */
+struct power_save_elems {
+	int powerSave;
+};
+#endif /*CONFIG_XRADIO_TESTMODE*/
+
+#define XR_TM_MAX_ATTRIB_SIZE 1024
+
+#endif /* XR_NL80211_TESTMODE_MSG_COPY_H*/
diff -Naurp a/drivers/net/wireless/xr829/wlan/platform.c b/drivers/net/wireless/xr829/wlan/platform.c
--- a/drivers/net/wireless/xr829/wlan/platform.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/platform.c	2022-08-27 01:22:42.966539908 +0300
@@ -0,0 +1,140 @@
+/*
+ * platform interfaces for XRadio drivers
+ *
+ * Copyright (c) 2013, XRadio
+ * Author: XRadio
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+#include <linux/ioport.h>
+#include <linux/regulator/consumer.h>
+//#include <asm/mach-types.h>
+//#include <mach/sys_config.h>
+#include "xradio.h"
+#include "platform.h"
+#include "sbus.h"
+#include <linux/sunxi-gpio.h>
+#include <linux/gpio.h>
+#include <linux/types.h>
+//#include <linux/power/scenelock.h>
+//#include <linux/power/aw_pm.h>
+#include <linux/pm_wakeirq.h>
+
+MODULE_AUTHOR("XRadioTech");
+MODULE_DESCRIPTION("XRadioTech WLAN driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("xradio_wlan");
+
+extern void sunxi_wlan_set_power(bool on);
+extern int sunxi_wlan_get_bus_index(void);
+extern int sunxi_wlan_get_oob_irq(int *, int *);
+
+static int wlan_bus_id;
+static u32 gpio_irq_handle;
+static int irq_flags, wakeup_enable;
+
+int xradio_get_syscfg(void)
+{
+	int wlan_bus_index = 0;
+	wlan_bus_index = sunxi_wlan_get_bus_index();
+	if (wlan_bus_index < 0)
+		return wlan_bus_index;
+	else
+		wlan_bus_id = wlan_bus_index;
+	gpio_irq_handle = sunxi_wlan_get_oob_irq(&irq_flags, &wakeup_enable);
+	return wlan_bus_index;
+}
+/*********************Interfaces called by xradio core. *********************/
+int  xradio_plat_init(void)
+{
+  return 0;
+}
+
+void xradio_plat_deinit(void)
+{
+;
+}
+
+int xradio_wlan_power(int on)
+{
+	int ret = 0;
+	if (on) {
+	    ret = xradio_get_syscfg();
+		if (ret < 0)
+			return ret;
+	}
+	sunxi_wlan_set_power(on);
+	mdelay(100);
+	return ret;
+}
+
+void xradio_sdio_detect(int enable)
+{
+	MCI_RESCAN_CARD(wlan_bus_id);
+	xradio_dbg(XRADIO_DBG_ALWY, "%s SDIO card %d\n",
+				enable?"Detect":"Remove", wlan_bus_id);
+	mdelay(10);
+}
+
+static irqreturn_t xradio_gpio_irq_handler(int irq, void *sbus_priv)
+{
+	struct sbus_priv *self = (struct sbus_priv *)sbus_priv;
+	unsigned long flags;
+
+	SYS_BUG(!self);
+	spin_lock_irqsave(&self->lock, flags);
+	if (self->irq_handler)
+		self->irq_handler(self->irq_priv);
+	spin_unlock_irqrestore(&self->lock, flags);
+	return IRQ_HANDLED;
+}
+
+int xradio_request_gpio_irq(struct device *dev, void *sbus_priv)
+{
+	int ret = -1;
+
+	ret = devm_request_irq(dev, gpio_irq_handle,
+					(irq_handler_t)xradio_gpio_irq_handler,
+					irq_flags, "xradio_irq", sbus_priv);
+	if (ret < 0) {
+			gpio_irq_handle = 0;
+			xradio_dbg(XRADIO_DBG_ERROR, "%s: request_irq FAIL!ret=%d\n",
+					__func__, ret);
+	}
+
+	if (wakeup_enable) {
+		ret = device_init_wakeup(dev, true);
+		if (ret < 0) {
+			xradio_dbg(XRADIO_DBG_ERROR, "device init wakeup failed!\n");
+			return ret;
+		}
+
+		ret = dev_pm_set_wake_irq(dev, gpio_irq_handle);
+		if (ret < 0) {
+			xradio_dbg(XRADIO_DBG_ERROR, "can't enable wakeup src!\n");
+			return ret;
+		}
+	}
+
+	return ret;
+}
+
+void xradio_free_gpio_irq(struct device *dev, void *sbus_priv)
+{
+	struct sbus_priv *self = (struct sbus_priv *)sbus_priv;
+	if (wakeup_enable) {
+		device_init_wakeup(dev, false);
+		dev_pm_clear_wake_irq(dev);
+	}
+	devm_free_irq(dev, gpio_irq_handle, self);
+	gpio_irq_handle = 0;
+}
diff -Naurp a/drivers/net/wireless/xr829/wlan/platform.h b/drivers/net/wireless/xr829/wlan/platform.h
--- a/drivers/net/wireless/xr829/wlan/platform.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/platform.h	2022-08-27 01:22:42.966539908 +0300
@@ -0,0 +1,56 @@
+/*
+ * platform interfaces for XRadio drivers
+ *
+ * Copyright (c) 2013, XRadio
+ * Author: XRadio
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#ifndef XRADIO_PLAT_H_INCLUDED
+#define XRADIO_PLAT_H_INCLUDED
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/mmc/host.h>
+
+/* Select hardware platform.*/
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
+
+extern void sunxi_mmc_rescan_card(unsigned ids);
+extern int sunxi_mmc_check_r1_ready(struct mmc_host *mmc, unsigned ms);
+
+#define MCI_RESCAN_CARD(id)  sunxi_mmc_rescan_card(id)
+#define MCI_CHECK_READY(h, t)     sunxi_mmc_check_r1_ready(h, t)
+
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
+#define PLAT_ALLWINNER_SUNXI
+#define MCI_RESCAN_CARD(id, ins)  sunxi_mci_rescan_card(id, ins)
+#define MCI_CHECK_READY(h, t)     sunxi_mci_check_r1_ready(h, t)
+
+extern void sunxi_mci_rescan_card(unsigned id, unsigned insert);
+extern int sunxi_mci_check_r1_ready(struct mmc_host *mmc, unsigned ms);
+
+#else
+#define PLAT_ALLWINNER_SUN6I
+#define MCI_RESCAN_CARD(id, ins)  sw_mci_rescan_card(id, ins)
+#define MCI_CHECK_READY(h, t)     sw_mci_check_r1_ready(h, t)
+
+extern void sw_mci_rescan_card(unsigned id, unsigned insert);
+extern int sw_mci_check_r1_ready(struct mmc_host *mmc, unsigned ms);
+#endif
+
+int xradio_get_syscfg(void);
+
+/* platform interfaces */
+int  xradio_plat_init(void);
+void xradio_plat_deinit(void);
+void  xradio_sdio_detect(int enable);
+int  xradio_request_gpio_irq(struct device *dev, void *sbus_priv);
+void xradio_free_gpio_irq(struct device *dev, void *sbus_priv);
+int  xradio_wlan_power(int on);
+
+#endif /* XRADIO_PLAT_H_INCLUDED */
diff -Naurp a/drivers/net/wireless/xr829/wlan/pm.c b/drivers/net/wireless/xr829/wlan/pm.c
--- a/drivers/net/wireless/xr829/wlan/pm.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/pm.c	2022-08-27 01:22:42.970539923 +0300
@@ -0,0 +1,986 @@
+/*
+ * PM implementation for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/if_ether.h>
+#include "xradio.h"
+#include "pm.h"
+#include "sta.h"
+#include "bh.h"
+#include "sbus.h"
+#include "platform.h"
+#ifdef CONFIG_XRADIO_EXTEND_SUSPEND
+#include <linux/power/scenelock.h>
+#endif
+
+#ifdef CONFIG_XRADIO_NOMAL_SUSPEND_FORCE
+#include <linux/power/scenelock.h>
+struct scene_lock  wifi_lock;
+#endif
+
+#define XRADIO_BEACON_SKIPPING_MULTIPLIER 3
+
+struct xradio_udp_port_filter {
+	struct wsm_udp_port_filter_hdr hdr;
+	struct wsm_udp_port_filter dhcp;
+	struct wsm_udp_port_filter upnp;
+} __packed;
+
+struct xradio_ether_type_filter {
+	struct wsm_ether_type_filter_hdr hdr;
+	struct wsm_ether_type_filter ip;
+	struct wsm_ether_type_filter pae;
+	struct wsm_ether_type_filter wapi;
+} __packed;
+
+static struct xradio_udp_port_filter xradio_udp_port_filter_on = {
+	.hdr.nrFilters = 2,
+	.dhcp = {
+		.filterAction = WSM_FILTER_ACTION_FILTER_OUT,
+		.portType = WSM_FILTER_PORT_TYPE_DST,
+		.udpPort = __cpu_to_le16(67),
+	},
+	.upnp = {
+		.filterAction = WSM_FILTER_ACTION_FILTER_OUT,
+		.portType = WSM_FILTER_PORT_TYPE_DST,
+		.udpPort = __cpu_to_le16(1900),
+	},
+	/* Please add other known ports to be filtered out here and
+	 * update nrFilters field in the header.
+	 * Up to 4 filters are allowed. */
+};
+
+static struct wsm_udp_port_filter_hdr xradio_udp_port_filter_off = {
+	.nrFilters = 0,
+};
+
+#ifndef ETH_P_WAPI
+#define ETH_P_WAPI     0x88B4
+#endif
+
+#ifdef TES_P2P_000B_DISABLE_EAPOL_FILTER
+/* TES_P2P_000B WorkAround:
+ * when the link keep 10min more or less(i am not sure),
+ * wpa_s session maybe expired, and want to update group key.
+ * it will use eapol frame(802.1x, 0x888E).
+ * if driver suspend, and discard eapol frame, then session end.
+ * i don't know why original code discards eapol frame in suspend.
+ * but now make this filter disable as WorkAround.*/
+static struct xradio_ether_type_filter xradio_ether_type_filter_on = {
+	.hdr.nrFilters = 1,
+/*	.ip = {
+		.filterAction = WSM_FILTER_ACTION_FILTER_IN,
+		.etherType = __cpu_to_le16(ETH_P_IP),
+	}, */
+/*	.pae = {
+		.filterAction = WSM_FILTER_ACTION_FILTER_IN,
+		.etherType = __cpu_to_le16(ETH_P_PAE),
+	}, */
+	.wapi = {
+		.filterAction = WSM_FILTER_ACTION_FILTER_IN,
+		.etherType = __cpu_to_le16(ETH_P_WAPI),
+	},
+	/* Please add other known ether types to be filtered out here and
+	 * update nrFilters field in the header.
+	 * Up to 4 filters are allowed. */
+};
+#else
+static struct xradio_ether_type_filter xradio_ether_type_filter_on = {
+	.hdr.nrFilters = 2,
+/*	.ip = {
+		.filterAction = WSM_FILTER_ACTION_FILTER_IN,
+		.etherType = __cpu_to_le16(ETH_P_IP),
+	}, */
+	.pae = {
+		.filterAction = WSM_FILTER_ACTION_FILTER_IN,
+		.etherType = __cpu_to_le16(ETH_P_PAE),
+	},
+	.wapi = {
+		.filterAction = WSM_FILTER_ACTION_FILTER_IN,
+		.etherType = __cpu_to_le16(ETH_P_WAPI),
+	},
+	/* Please add other known ether types to be filtered out here and
+	 * update nrFilters field in the header.
+	 * Up to 4 filters are allowed. */
+};
+#endif
+
+static struct wsm_ether_type_filter_hdr xradio_ether_type_filter_off = {
+	.nrFilters = 0,
+};
+
+static int xradio_suspend_late(struct device *dev);
+static void xradio_pm_release(struct device *dev);
+static int xradio_pm_probe(struct platform_device *pdev);
+static int __xradio_wow_suspend(struct xradio_vif *priv,
+				struct cfg80211_wowlan *wowlan);
+static int __xradio_wow_resume(struct xradio_vif *priv);
+#ifdef CONFIG_XRADIO_SUSPEND_POWER_OFF
+static int xradio_poweroff_suspend(struct xradio_common *hw_priv);
+static int xradio_poweroff_resume(struct xradio_common *hw_priv);
+#endif
+
+
+/* private */
+struct xradio_suspend_state {
+	unsigned long bss_loss_tmo;
+	unsigned long connection_loss_tmo;
+	unsigned long join_tmo;
+	unsigned long direct_probe;
+	unsigned long link_id_gc;
+	bool beacon_skipping;
+};
+
+static const struct dev_pm_ops xradio_pm_ops = {
+	.suspend_noirq = xradio_suspend_late,
+};
+
+static struct platform_driver xradio_power_driver = {
+	.probe = xradio_pm_probe,
+	.driver = {
+		.name = XRADIO_PLAT_DEVICE,
+		.pm = &xradio_pm_ops,
+	},
+};
+
+#ifdef CONFIG_XRADIO_DEBUG
+struct timeval suspend_time;
+struct timeval resume_time;
+u32 xradio_realtime_interval(struct timeval *oldtime, struct timeval *newtime)
+{
+	u32 time_int;
+	xr_do_gettimeofday(newtime);
+	time_int = (newtime->tv_sec - oldtime->tv_sec) * 1000 + \
+			    (newtime->tv_usec - oldtime->tv_usec) / 1000;
+	return time_int;
+}
+#endif
+
+static int xradio_pm_init_common(struct xradio_pm_state *pm,
+				  struct xradio_common *hw_priv)
+{
+	int ret;
+	pm_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+#ifdef CONFIG_XRADIO_DEBUG
+	xr_do_gettimeofday(&resume_time);
+#endif
+
+	spin_lock_init(&pm->lock);
+	/* Register pm driver. */
+	ret = platform_driver_register(&xradio_power_driver);
+	if (ret) {
+		pm_printk(XRADIO_DBG_ERROR,
+			  "%s:platform_driver_register failed(%d)!\n",
+			  __func__, ret);
+	}
+
+#ifdef CONFIG_XRADIO_NOMAL_SUSPEND_FORCE
+	scene_lock_init(&wifi_lock, SCENE_NORMAL_STANDBY, "wifinormal_standby");
+	scene_lock(&wifi_lock);
+	if (!check_scene_locked(SCENE_NORMAL_STANDBY))
+		pm_printk(XRADIO_DBG_NIY, "normal standby lock success!\n");
+	else
+		pm_printk(XRADIO_DBG_ERROR, "normal standby lock failed!\n");
+#endif
+
+	return ret;
+}
+
+static void xradio_pm_deinit_common(struct xradio_pm_state *pm)
+{
+	pm_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	platform_driver_unregister(&xradio_power_driver);
+#ifdef CONFIG_XRADIO_NOMAL_SUSPEND_FORCE
+	scene_unlock(&wifi_lock);
+	if (!check_scene_locked(SCENE_NORMAL_STANDBY))
+		pm_printk(XRADIO_DBG_ERROR, "normal standby unlock failed!\n");
+	else
+		pm_printk(XRADIO_DBG_NIY, "normal standby unlock success!\n");
+#endif
+}
+
+#ifdef CONFIG_WAKELOCK
+
+int xradio_pm_init(struct xradio_pm_state *pm,
+		   struct xradio_common *hw_priv)
+{
+	int ret = 0;
+	pm_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	ret = xradio_pm_init_common(pm, hw_priv);
+	if (!ret)
+		wake_lock_init(&pm->wakelock, WAKE_LOCK_SUSPEND, XRADIO_WAKE_LOCK);
+	else
+		pm_printk(XRADIO_DBG_ERROR, "xradio_pm_init_common failed!\n");
+	return ret;
+}
+
+void xradio_pm_deinit(struct xradio_pm_state *pm)
+{
+	pm_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	if (wake_lock_active(&pm->wakelock))
+		wake_unlock(&pm->wakelock);
+	wake_lock_destroy(&pm->wakelock);
+	xradio_pm_deinit_common(pm);
+}
+
+void xradio_pm_stay_awake(struct xradio_pm_state *pm,
+			  unsigned long tmo)
+{
+	long cur_tmo;
+	pm_printk(XRADIO_DBG_MSG, "%s\n", __func__);
+
+	spin_lock_bh(&pm->lock);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
+	cur_tmo = pm->wakelock.ws.timer.expires - jiffies;
+#else
+	cur_tmo = pm->wakelock.expires - jiffies;
+#endif
+	if (!wake_lock_active(&pm->wakelock) || cur_tmo < (long)tmo)
+		wake_lock_timeout(&pm->wakelock, tmo);
+	spin_unlock_bh(&pm->lock);
+}
+void xradio_pm_lock_awake(struct xradio_pm_state *pm)
+{
+	pm_printk(XRADIO_DBG_NIY, "%s\n", __func__);
+	spin_lock_bh(&pm->lock);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
+	pm->expires_save = pm->wakelock.ws.timer.expires;
+#else
+	pm->expires_save = pm->wakelock.expires;
+#endif
+	if (!wake_lock_active(&pm->wakelock) ||
+		time_before((unsigned long)pm->expires_save, jiffies)) {
+		pm->expires_save = 0;
+	}
+	wake_lock(&pm->wakelock);
+	spin_unlock_bh(&pm->lock);
+}
+void xradio_pm_unlock_awake(struct xradio_pm_state *pm)
+{
+	pm_printk(XRADIO_DBG_NIY, "%s\n", __func__);
+	spin_lock_bh(&pm->lock);
+	if (wake_lock_active(&pm->wakelock)) {
+		wake_unlock(&pm->wakelock);
+		if (pm->expires_save &&
+			time_before(jiffies, (unsigned long)pm->expires_save)) {
+			pm->expires_save -= jiffies;
+			wake_lock_timeout(&pm->wakelock, pm->expires_save);
+		}
+	}
+	pm->expires_save = 0;
+	spin_unlock_bh(&pm->lock);
+}
+
+#else /* CONFIG_WAKELOCK */
+
+static void xradio_pm_stay_awake_tmo(struct timer_list *t)
+{
+	struct xradio_pm_state *pm = from_timer(pm, t, stay_awake);
+
+	atomic_set(&pm->status, XRADIO_PM_STATE_ALLOW_SUSPEND);
+}
+
+int xradio_pm_init(struct xradio_pm_state *pm,
+		   struct xradio_common *hw_priv)
+{
+	int ret = 0;
+	pm_printk(XRADIO_DBG_MSG, "%s\n", __func__);
+
+	ret = xradio_pm_init_common(pm, hw_priv);
+	if (!ret) {
+		timer_setup(&pm->stay_awake, xradio_pm_stay_awake_tmo, 0);
+		atomic_set(&pm->status, XRADIO_PM_STATE_ALLOW_SUSPEND);
+	} else
+		pm_printk(XRADIO_DBG_ERROR, "xradio_pm_init_common failed!\n");
+	return ret;
+}
+
+void xradio_pm_deinit(struct xradio_pm_state *pm)
+{
+	pm_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	del_timer_sync(&pm->stay_awake);
+	xradio_pm_deinit_common(pm);
+}
+
+void xradio_pm_stay_awake(struct xradio_pm_state *pm,
+			  unsigned long tmo)
+{
+	long cur_tmo;
+	pm_printk(XRADIO_DBG_MSG, "%s\n", __func__);
+
+	spin_lock_bh(&pm->lock);
+	atomic_set(&pm->status, XRADIO_PM_STATE_KEEP_WAKE);
+	cur_tmo = pm->stay_awake.expires - jiffies;
+	if (!timer_pending(&pm->stay_awake) || cur_tmo < (long)tmo)
+		mod_timer(&pm->stay_awake, jiffies + tmo);
+	spin_unlock_bh(&pm->lock);
+}
+void xradio_pm_lock_awake(struct xradio_pm_state *pm)
+{
+	pm_printk(XRADIO_DBG_NIY, "%s\n", __func__);
+	spin_lock_bh(&pm->lock);
+	if (timer_pending(&pm->stay_awake))
+		pm->expires_save = pm->stay_awake.expires;
+	else
+		pm->expires_save = jiffies;
+	mod_timer(&pm->stay_awake, jiffies + LONG_MAX);
+	spin_unlock_bh(&pm->lock);
+}
+void xradio_pm_unlock_awake(struct xradio_pm_state *pm)
+{
+	pm_printk(XRADIO_DBG_NIY, "%s\n", __func__);
+	spin_lock_bh(&pm->lock);
+	if (time_before(jiffies, (unsigned long)pm->expires_save))
+		mod_timer(&pm->stay_awake, pm->expires_save);
+	else
+		mod_timer(&pm->stay_awake, jiffies + 5);
+	spin_unlock_bh(&pm->lock);
+}
+#endif /* CONFIG_WAKELOCK */
+
+static long xradio_suspend_work(struct delayed_work *work)
+{
+	int ret = cancel_delayed_work(work);
+	long tmo;
+	pm_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (ret > 0) {
+		/* Timer is pending */
+		tmo = work->timer.expires - jiffies;
+		if (tmo < 0)
+			tmo = 0;
+	} else {
+		tmo = -1;
+	}
+	return tmo;
+}
+
+static int xradio_resume_work(struct xradio_common *hw_priv,
+			       struct delayed_work *work,
+			       unsigned long tmo)
+{
+	pm_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	if ((long)tmo < 0)
+		return 1;
+
+	return queue_delayed_work(hw_priv->workqueue, work, tmo);
+}
+
+static int xradio_suspend_late(struct device *dev)
+{
+	struct xradio_common *hw_priv = dev->platform_data;
+	pm_printk(XRADIO_DBG_NIY, "%s\n", __func__);
+#ifdef CONFIG_XRADIO_SUSPEND_POWER_OFF
+	if (XRADIO_POWEROFF_SUSP == atomic_read(&hw_priv->suspend_state)) {
+		return 0; /* we don't rx data when power down wifi.*/
+	}
+#endif
+
+	if (atomic_read(&hw_priv->bh_rx)) {
+		pm_printk(XRADIO_DBG_WARN, "%s: Suspend interrupted.\n", __func__);
+		return -EAGAIN;
+	}
+	return 0;
+}
+
+static void xradio_pm_release(struct device *dev)
+{
+	pm_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+}
+
+static int xradio_pm_probe(struct platform_device *pdev)
+{
+	pm_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	pdev->dev.release = xradio_pm_release;
+	return 0;
+}
+
+int xradio_wow_suspend(struct ieee80211_hw *hw,
+			       struct cfg80211_wowlan *wowlan)
+{
+	struct xradio_common *hw_priv = hw->priv;
+	struct xradio_vif *priv;
+	int i, ret = 0;
+	int suspend_lock_state;
+	pm_printk(XRADIO_DBG_NIY, "%s, Activetime=%dms\n", __func__,
+			  xradio_realtime_interval(&resume_time, &suspend_time));
+
+	if (hw_priv->bh_error) {
+		pm_printk(XRADIO_DBG_WARN, "Don't suspend "
+			   "because of bh_error occurs.\n");
+		return -EBUSY;
+	}
+	if (!atomic_read(&hw_priv->num_vifs))
+		pm_printk(XRADIO_DBG_WARN, "%s num_vifs=0\n", __func__);
+
+#ifdef HW_RESTART
+	if (hw_priv->hw_restart == true) {
+		pm_printk(XRADIO_DBG_WARN, "Don't suspend "
+			   "because of hw_restart is working.\n");
+		return -EBUSY;
+	}
+
+	if (work_pending(&hw_priv->hw_restart_work)) {
+		pm_printk(XRADIO_DBG_WARN, "Don't suspend "
+				"because of hw_restart_work prepare to worked.\n");
+		return -EBUSY;
+	}
+
+	if (hw_priv->hw_restart_work_running == true) {
+		pm_printk(XRADIO_DBG_WARN, "Don't suspend "
+				"because of hw_restart_work is working.\n");
+		return -EBUSY;
+	}
+#endif
+
+#ifndef CONFIG_WAKELOCK
+	if (atomic_read(&hw_priv->pm_state.status) == XRADIO_PM_STATE_KEEP_WAKE) {
+		pm_printk(XRADIO_DBG_WARN, "Don't suspend "
+			"because of pm_state need keep awake.\n");
+		return -EBUSY;
+	}
+#endif
+
+	if (work_pending(&hw_priv->query_work)) {
+		pm_printk(XRADIO_DBG_WARN, "Don't suspend "
+				"because of query_work is working.\n");
+		return -EBUSY;
+	}
+
+#ifdef ROAM_OFFLOAD
+	xradio_for_each_vif(hw_priv, priv, i) {
+#ifdef P2P_MULTIVIF
+		if ((i == (XRWL_MAX_VIFS - 1)) || !priv)
+#else
+		if (!priv)
+#endif
+			continue;
+		if ((priv->vif->type == NL80211_IFTYPE_STATION)
+		&& (priv->join_status == XRADIO_JOIN_STATUS_STA)) {
+			down(&hw_priv->scan.lock);
+			hw_priv->scan.if_id = priv->if_id;
+			xradio_sched_scan_work(&hw_priv->scan.swork);
+		}
+	}
+#endif /*ROAM_OFFLOAD*/
+
+	/* Do not suspend when datapath is not idle */
+	if (hw_priv->tx_queue_stats.num_queued[0] +
+		  hw_priv->tx_queue_stats.num_queued[1]) {
+		pm_printk(XRADIO_DBG_WARN, "Don't suspend "
+			   "because of tx_queue is not empty.\n");
+		return -EBUSY;
+	}
+
+#ifdef BH_PROC_THREAD
+	if (atomic_read(&hw_priv->proc.rx_queued) +
+		atomic_read(&hw_priv->proc.tx_queued)) {
+		pm_printk(XRADIO_DBG_WARN, "Don't suspend "
+			   "because of proc_queue is not empty.\n");
+		return -EBUSY;
+	}
+#endif
+	suspend_lock_state = atomic_cmpxchg(&hw_priv->suspend_lock_state,
+									XRADIO_SUSPEND_LOCK_IDEL, XRADIO_SUSPEND_LOCK_SUSPEND);
+	if (suspend_lock_state == XRADIO_SUSPEND_LOCK_OTHERS) {
+		pm_printk(XRADIO_DBG_WARN, "Don't suspend "
+			   "because others are waiting for lock.\n");
+		goto revertm1;
+	}
+
+	/* Make sure there is no configuration requests in progress. */
+	if (down_trylock(&hw_priv->conf_lock)) {
+		pm_printk(XRADIO_DBG_WARN, "Don't suspend "
+			   "because of configuration requests.\n");
+		goto revertm1;
+	}
+
+	/* Make sure there is no wsm_oper_lock in progress. */
+	if (down_trylock(&hw_priv->wsm_oper_lock)) {
+		pm_printk(XRADIO_DBG_WARN, "Don't suspend "
+			   "because of wsm_oper_lock.\n");
+		goto revert0;
+	}
+
+	/* Do not suspend when scanning or ROC*/
+	if (down_trylock(&hw_priv->scan.lock)) {
+		pm_printk(XRADIO_DBG_WARN, "Don't suspend "
+			   "because of scan requests.\n");
+		goto revert1;
+	}
+
+	if (delayed_work_pending(&hw_priv->scan.probe_work)) {
+		pm_printk(XRADIO_DBG_WARN, "Don't suspend "
+			   "because of probe frames tx in progress.\n");
+		goto revert2;
+	}
+
+	/* Lock TX. */
+	wsm_lock_tx_async(hw_priv);
+
+	/* Wait to avoid possible race with bh code.
+	 * But do not wait too long... */
+	if (wait_event_timeout(hw_priv->bh_evt_wq,
+			       !hw_priv->hw_bufs_used, HZ / 10) <= 0) {
+		pm_printk(XRADIO_DBG_WARN, "Don't suspend "
+			   "because of there are frames not confirm.\n");
+		goto revert3;
+	}
+
+#ifdef CONFIG_XRADIO_SUSPEND_POWER_OFF
+#ifdef CONFIG_XRADIO_EXTEND_SUSPEND
+	if (check_scene_locked(SCENE_SUPER_STANDBY) == 0) {
+		if (xradio_poweroff_suspend(hw_priv)) {
+			pm_printk(XRADIO_DBG_WARN, "Don't suspend "	\
+				"because of xradio_poweroff_suspend failed.\n");
+			goto revert3;
+		}
+		return 0;
+	}
+
+#else
+	if (xradio_poweroff_suspend(hw_priv)) {
+		pm_printk(XRADIO_DBG_WARN, "Don't suspend "	\
+			"because of xradio_poweroff_suspend failed.\n");
+		goto revert3;
+	}
+	return 0;
+
+#endif
+#endif
+
+	xradio_for_each_vif(hw_priv, priv, i) {
+#ifdef P2P_MULTIVIF
+		if ((i == (XRWL_MAX_VIFS - 1)) || !priv)
+#else
+		if (!priv)
+#endif
+			continue;
+
+		ret = __xradio_wow_suspend(priv, wowlan);
+		if (ret) {
+			for (; i >= 0; i--) {
+				if (!hw_priv->vif_list[i])
+					continue;
+				priv = (struct xradio_vif *)hw_priv->vif_list[i]->drv_priv;
+				__xradio_wow_resume(priv);
+			}
+			pm_printk(XRADIO_DBG_WARN, "Don't suspend "
+				   "because of __xradio_wow_suspend failed!\n");
+			goto revert3;
+		}
+	}
+
+	/* Stop serving thread */
+	if (xradio_bh_suspend(hw_priv)) {
+		pm_printk(XRADIO_DBG_WARN, "Don't suspend "
+			   "because of xradio_bh_suspend failed!\n");
+		goto revert4;
+	}
+
+	/* Enable IRQ wake */
+	ret = hw_priv->sbus_ops->power_mgmt(hw_priv->sbus_priv, true);
+	if (ret) {
+		pm_printk(XRADIO_DBG_WARN, "Don't suspend sbus pm failed\n");
+		goto revert5;
+	}
+
+	/* Force resume if event is coming from the device. */
+	if (atomic_read(&hw_priv->bh_rx)) {
+		pm_printk(XRADIO_DBG_WARN, "Don't suspend "
+			   "because of recieved rx event!\n");
+		goto revert6;
+	}
+	atomic_set(&hw_priv->suspend_state, XRADIO_CONNECT_SUSP);
+	return 0;
+
+revert6:
+	hw_priv->sbus_ops->power_mgmt(hw_priv->sbus_priv, false);
+revert5:
+	xradio_bh_resume(hw_priv);
+revert4:
+	xradio_for_each_vif(hw_priv, priv, i) {
+#ifdef P2P_MULTIVIF
+		if ((i == (XRWL_MAX_VIFS - 1)) || !priv)
+#else
+		if (!priv)
+#endif
+			continue;
+		ret = __xradio_wow_resume(priv);
+		if (ret) {
+			pm_printk(XRADIO_DBG_ERROR,
+				  "%s:__xradio_wow_resume failed!\n", __func__);
+			break;
+		}
+	}
+revert3:
+	wsm_unlock_tx(hw_priv);
+revert2:
+	up(&hw_priv->scan.lock);
+revert1:
+	up(&hw_priv->wsm_oper_lock);
+revert0:
+	up(&hw_priv->conf_lock);
+revertm1:
+	return -EBUSY;
+}
+
+static int __xradio_wow_suspend(struct xradio_vif *priv,
+				struct cfg80211_wowlan *wowlan)
+{
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	struct xradio_pm_state_vif *pm_state_vif = &priv->pm_state_vif;
+	struct xradio_suspend_state *state;
+	int ret;
+#ifdef MCAST_FWDING
+	struct wsm_forwarding_offload fwdoffload = {
+		.fwenable = 0x1,
+		.flags    = 0x1,
+	};
+#endif
+	pm_printk(XRADIO_DBG_NIY, "%s\n", __func__);
+
+	/* Do not suspend when join work is scheduled */
+	if (work_pending(&priv->join_work)) {
+		pm_printk(XRADIO_DBG_WARN, "%s:Do not suspend "
+			   "when join work is scheduled\n", __func__);
+		goto revert1;
+	}
+
+	/* Set UDP filter */
+	wsm_set_udp_port_filter(hw_priv, &xradio_udp_port_filter_on.hdr,
+				priv->if_id);
+
+	/* Set ethernet frame type filter */
+	wsm_set_ether_type_filter(hw_priv, &xradio_ether_type_filter_on.hdr,
+				  priv->if_id);
+
+	/* Set IP multicast filter */
+    wsm_set_host_sleep(hw_priv, 1, priv->if_id);
+
+	if (priv->join_status == XRADIO_JOIN_STATUS_AP)
+		WARN_ON(wsm_set_keepalive_filter(priv, true));
+
+#ifdef XRADIO_SUSPEND_RESUME_FILTER_ENABLE
+	/* Set Multicast Address Filter */
+	if (priv->multicast_filter.numOfAddresses) {
+		priv->multicast_filter.enable = 1;
+		wsm_set_multicast_filter(hw_priv, &priv->multicast_filter,
+					 priv->if_id);
+	}
+
+	/* Set Enable Broadcast Address Filter */
+	priv->broadcast_filter.action_mode = 1;
+	if (priv->join_status == XRADIO_JOIN_STATUS_AP)
+		priv->broadcast_filter.address_mode = 3;
+
+	xradio_set_macaddrfilter(hw_priv, priv, (u8 *)&priv->broadcast_filter);
+#endif
+
+#ifdef MCAST_FWDING
+	if (priv->join_status == XRADIO_JOIN_STATUS_AP)
+		WARN_ON(wsm_set_forwarding_offlad(hw_priv, &fwdoffload, priv->if_id));
+#endif
+
+	/* Allocate state */
+	state = xr_kzalloc(sizeof(struct xradio_suspend_state), false);
+	if (!state) {
+		pm_printk(XRADIO_DBG_WARN, "%s:Do not suspend "
+			   "alloc xradio_suspend_state failed.\n", __func__);
+		goto revert2;
+	}
+	/* Store delayed work states. */
+	state->bss_loss_tmo        = xradio_suspend_work(&priv->bss_loss_work);
+	state->connection_loss_tmo = xradio_suspend_work(&priv->connection_loss_work);
+	state->join_tmo   = xradio_suspend_work(&priv->join_timeout);
+	state->link_id_gc = xradio_suspend_work(&priv->link_id_gc_work);
+
+#ifndef XRADIO_USE_LONG_DTIM_PERIOD
+	/* Enable beacon skipping */
+	if (priv->join_status == XRADIO_JOIN_STATUS_STA &&
+		priv->join_dtim_period < 3) {
+		/* priv->join_dtim_period &&  !priv->has_multicast_subscription) { */
+		state->beacon_skipping = true;
+		wsm_set_beacon_wakeup_period(hw_priv,
+			priv->join_dtim_period * XRADIO_BEACON_SKIPPING_MULTIPLIER,
+			0, priv->if_id);
+		pm_printk(XRADIO_DBG_NIY, "%s:Skip Beacons period(%d).\n", __func__,
+				priv->join_dtim_period*XRADIO_BEACON_SKIPPING_MULTIPLIER);
+	} else {
+		pm_printk(XRADIO_DBG_NIY, "%s:Do not Skip Beacons(DTIM=%d).\n",
+				__func__, priv->join_dtim_period);
+	}
+#endif
+
+	ret = timer_pending(&priv->mcast_timeout);
+	if (ret) {
+		pm_printk(XRADIO_DBG_WARN, "%s:Do not suspend "
+			   "mcast timeout timer_pending failed.\n", __func__);
+		goto revert3;
+	}
+
+	/* Store suspend state */
+	pm_state_vif->suspend_state = state;
+
+	return 0;
+
+revert3:
+	xradio_resume_work(hw_priv, &priv->bss_loss_work, state->bss_loss_tmo);
+	xradio_resume_work(hw_priv, &priv->connection_loss_work,
+			   state->connection_loss_tmo);
+	xradio_resume_work(hw_priv, &priv->join_timeout, state->join_tmo);
+	xradio_resume_work(hw_priv, &priv->link_id_gc_work, state->link_id_gc);
+	kfree(state);
+
+revert2:
+	wsm_set_udp_port_filter(hw_priv, &xradio_udp_port_filter_off,
+				priv->if_id);
+	wsm_set_ether_type_filter(hw_priv, &xradio_ether_type_filter_off,
+				  priv->if_id);
+    wsm_set_host_sleep(hw_priv, 0, priv->if_id);
+
+	if (priv->join_status == XRADIO_JOIN_STATUS_AP)
+		WARN_ON(wsm_set_keepalive_filter(priv, false));
+
+#ifdef XRADIO_SUSPEND_RESUME_FILTER_ENABLE
+	/* Set Multicast Address Filter */
+	if (priv->multicast_filter.numOfAddresses) {
+		priv->multicast_filter.enable = 0;
+		wsm_set_multicast_filter(hw_priv, &priv->multicast_filter,
+					 priv->if_id);
+	}
+
+	/* Set Enable Broadcast Address Filter */
+	priv->broadcast_filter.action_mode = 0;
+	if (priv->join_status == XRADIO_JOIN_STATUS_AP)
+		priv->broadcast_filter.address_mode = 0;
+	xradio_set_macaddrfilter(hw_priv, priv, (u8 *)&priv->broadcast_filter);
+#endif
+
+#ifdef MCAST_FWDING
+	fwdoffload.flags = 0x0;
+	if (priv->join_status == XRADIO_JOIN_STATUS_AP)
+		WARN_ON(wsm_set_forwarding_offlad(hw_priv, &fwdoffload, priv->if_id));
+#endif
+
+revert1:
+	/* up(&hw_priv->conf_lock); */
+	return -EBUSY;
+}
+
+int xradio_wow_resume(struct ieee80211_hw *hw)
+{
+
+	struct xradio_common *hw_priv = hw->priv;
+	struct xradio_vif *priv;
+	int i, ret = 0;
+
+	pm_printk(XRADIO_DBG_NIY, "%s, Sleeptime=%dms\n", __func__,
+			  xradio_realtime_interval(&suspend_time, &resume_time));
+
+	if (!atomic_read(&hw_priv->num_vifs))
+		pm_printk(XRADIO_DBG_WARN, "%s num_vifs=0\n", __func__);
+
+	if (hw_priv->bh_error) {
+		pm_printk(XRADIO_DBG_ERROR, "%s bh_error(%d) occurs already.\n",
+				__func__, hw_priv->bh_error);
+	}
+
+	if (atomic_read(&hw_priv->suspend_state) < XRADIO_CONNECT_SUSP) {
+		pm_printk(XRADIO_DBG_WARN, "%s not in suspend(%d).\n",
+				__func__, atomic_read(&hw_priv->suspend_state));
+		/*
+		 * xradio_wow_suspend failed last time, and xradio_wow_resume is called
+		 * by mac80211_reconfig in umac. return 1 to do hw restart.
+		 */
+		return 1;
+	}
+
+	atomic_set(&hw_priv->suspend_lock_state, XRADIO_SUSPEND_LOCK_IDEL);
+
+#ifdef CONFIG_XRADIO_SUSPEND_POWER_OFF
+	if (XRADIO_POWEROFF_SUSP == atomic_read(&hw_priv->suspend_state)) {
+		return xradio_poweroff_resume(hw_priv);
+	}
+#endif
+
+	/* Disable IRQ wake */
+	hw_priv->sbus_ops->power_mgmt(hw_priv->sbus_priv, false);
+
+	up(&hw_priv->scan.lock);
+
+	/* Resume BH thread */
+	WARN_ON(xradio_bh_resume(hw_priv));
+
+	xradio_for_each_vif(hw_priv, priv, i) {
+#ifdef P2P_MULTIVIF
+		if ((i == (XRWL_MAX_VIFS - 1)) || !priv)
+#else
+		if (!priv)
+#endif
+			continue;
+		ret = __xradio_wow_resume(priv);
+		if (ret) {
+			pm_printk(XRADIO_DBG_ERROR,
+				  "%s:__xradio_wow_resume failed!\n", __func__);
+			break;
+		}
+	}
+
+	wsm_unlock_tx(hw_priv);
+
+	/* we always return to XRADIO_RESUME no matter errors occurs.*/
+	atomic_set(&hw_priv->suspend_state, XRADIO_RESUME);
+
+	/* Unlock configuration mutex */
+	up(&hw_priv->wsm_oper_lock);
+	up(&hw_priv->conf_lock);
+	return 0;
+}
+
+static int __xradio_wow_resume(struct xradio_vif *priv)
+{
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	struct xradio_pm_state_vif *pm_state_vif = &priv->pm_state_vif;
+	struct xradio_suspend_state *state;
+#ifdef MCAST_FWDING
+	struct wsm_forwarding_offload fwdoffload = {
+		.fwenable = 0x1,
+		.flags = 0x0,
+	};
+#endif
+	pm_printk(XRADIO_DBG_NIY, "%s\n", __func__);
+
+	/* Restore suspend state */
+	state = pm_state_vif->suspend_state;
+	pm_state_vif->suspend_state = NULL;
+
+#ifdef ROAM_OFFLOAD
+	if ((priv->vif->type == NL80211_IFTYPE_STATION)
+	&& (priv->join_status == XRADIO_JOIN_STATUS_STA))
+		xradio_hw_sched_scan_stop(hw_priv);
+#endif /*ROAM_OFFLOAD*/
+
+	if (state->beacon_skipping) {
+#ifdef XRADIO_USE_LONG_DTIM_PERIOD
+		int join_dtim_period_extend;
+		if (priv->join_dtim_period <= 3) {
+			join_dtim_period_extend = priv->join_dtim_period * 3;
+		} else if (priv->join_dtim_period <= 5) {
+			join_dtim_period_extend = priv->join_dtim_period * 2;
+		} else {
+			join_dtim_period_extend = priv->join_dtim_period;
+		}
+		wsm_set_beacon_wakeup_period(hw_priv,
+			((priv->beacon_int * join_dtim_period_extend) >
+			 MAX_BEACON_SKIP_TIME_MS ?
+			 1 : join_dtim_period_extend), 0, priv->if_id);
+#else
+		wsm_set_beacon_wakeup_period(hw_priv,
+			(priv->beacon_int * priv->join_dtim_period >
+			 MAX_BEACON_SKIP_TIME_MS) ? 1 : priv->join_dtim_period,
+			 0, priv->if_id);
+#endif
+		state->beacon_skipping = false;
+	}
+
+	if (priv->join_status == XRADIO_JOIN_STATUS_AP)
+		WARN_ON(wsm_set_keepalive_filter(priv, false));
+
+#ifdef XRADIO_SUSPEND_RESUME_FILTER_ENABLE
+	/* Set Multicast Address Filter */
+	if (priv->multicast_filter.numOfAddresses) {
+		priv->multicast_filter.enable = 0;
+		wsm_set_multicast_filter(hw_priv, &priv->multicast_filter,
+					 priv->if_id);
+	}
+	/* Set Enable Broadcast Address Filter */
+	priv->broadcast_filter.action_mode = 0;
+	if (priv->join_status == XRADIO_JOIN_STATUS_AP)
+		priv->broadcast_filter.address_mode = 0;
+	xradio_set_macaddrfilter(hw_priv, priv, (u8 *)&priv->broadcast_filter);
+#endif
+
+#ifdef MCAST_FWDING
+	if (priv->join_status == XRADIO_JOIN_STATUS_AP)
+		WARN_ON(wsm_set_forwarding_offlad(hw_priv, &fwdoffload, priv->if_id));
+#endif
+
+	/* Resume delayed work */
+	xradio_resume_work(hw_priv, &priv->bss_loss_work, state->bss_loss_tmo);
+	xradio_resume_work(hw_priv, &priv->connection_loss_work,
+			   state->connection_loss_tmo);
+	xradio_resume_work(hw_priv, &priv->join_timeout, state->join_tmo);
+	xradio_resume_work(hw_priv, &priv->link_id_gc_work, state->link_id_gc);
+
+	/* Remove UDP port filter */
+	wsm_set_udp_port_filter(hw_priv, &xradio_udp_port_filter_off,
+				priv->if_id);
+
+	/* Remove ethernet frame type filter */
+	wsm_set_ether_type_filter(hw_priv, &xradio_ether_type_filter_off,
+				  priv->if_id);
+
+	/* Remove IP multicast filter */
+    wsm_set_host_sleep(hw_priv, 0, priv->if_id);
+	/* Free memory */
+	kfree(state);
+
+	return 0;
+}
+
+#ifdef CONFIG_XRADIO_SUSPEND_POWER_OFF
+static int xradio_poweroff_suspend(struct xradio_common *hw_priv)
+{
+	pm_printk(XRADIO_DBG_NIY, "%s\n", __func__);
+	/* Flush all works. */
+	cancel_work_sync(&hw_priv->query_work);
+	flush_workqueue(hw_priv->workqueue);
+	flush_workqueue(hw_priv->spare_workqueue);
+
+	/* Stop serving thread */
+	if (xradio_bh_suspend(hw_priv)) {
+		pm_printk(XRADIO_DBG_WARN, "%s, xradio_bh_suspend failed!\n",
+			  __func__);
+		return -EBUSY;
+	}
+
+	/* Schedule hardware restart, ensure no cmds in progress.*/
+	down(&hw_priv->wsm_cmd_sema);
+	atomic_set(&hw_priv->suspend_state, XRADIO_POWEROFF_SUSP);
+	hw_priv->hw_restart = true;
+	up(&hw_priv->wsm_cmd_sema);
+
+	/* Going to sleep with wifi power down. */
+	xradio_wlan_power(0);
+	return 0;
+}
+
+static int xradio_poweroff_resume(struct xradio_common *hw_priv)
+{
+	pm_printk(XRADIO_DBG_NIY, "%s\n", __func__);
+	/* Revert locks */
+	wsm_unlock_tx(hw_priv);
+	up(&hw_priv->scan.lock);
+	up(&hw_priv->conf_lock);
+	up(&hw_priv->wsm_oper_lock);
+
+	down(&hw_priv->wsm_cmd_sema);
+	if (!hw_priv->exit_sync)
+		if (schedule_work(&hw_priv->hw_restart_work) <= 0)
+			pm_printk(XRADIO_DBG_ERROR, "%s restart_work failed!\n", __func__);
+	up(&hw_priv->wsm_cmd_sema);
+	return 0;
+}
+
+
+#endif
diff -Naurp a/drivers/net/wireless/xr829/wlan/pm.h b/drivers/net/wireless/xr829/wlan/pm.h
--- a/drivers/net/wireless/xr829/wlan/pm.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/pm.h	2022-08-27 01:22:42.970539923 +0300
@@ -0,0 +1,77 @@
+/*
+ * power management interfaces for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#ifndef PM_H_INCLUDED
+#define PM_H_INCLUDED
+
+#ifdef CONFIG_WAKELOCK
+#include <linux/wakelock.h>
+#endif
+
+/* ******************************************************************** */
+/* mac80211 API */
+
+#ifdef CONFIG_PM
+#define XRADIO_WAKE_LOCK   "xradio_wlan"
+
+/* extern */   struct xradio_common;
+ /* private */ struct xradio_suspend_state;
+
+#ifndef CONFIG_WAKELOCK
+enum xradio_pm_keep_wake_state {
+	XRADIO_PM_STATE_ALLOW_SUSPEND,
+	XRADIO_PM_STATE_KEEP_WAKE,
+};
+#endif
+
+struct xradio_pm_state {
+#ifdef CONFIG_WAKELOCK
+	struct wake_lock wakelock;
+#else
+	struct timer_list stay_awake;
+	atomic_t status;
+#endif
+	spinlock_t lock;
+	long expires_save;
+};
+
+struct xradio_pm_state_vif {
+	struct xradio_suspend_state *suspend_state;
+};
+
+enum suspend_state {
+	XRADIO_RESUME = 0,
+	XRADIO_CONNECT_SUSP,
+	XRADIO_DISCONNECT_SUSP,
+#ifdef CONFIG_XRADIO_SUSPEND_POWER_OFF
+	XRADIO_POWEROFF_SUSP
+#endif
+};
+
+enum suspend_lock_state {
+	XRADIO_SUSPEND_LOCK_IDEL = 0,
+	XRADIO_SUSPEND_LOCK_SUSPEND,
+	XRADIO_SUSPEND_LOCK_OTHERS,
+};
+
+int xradio_pm_init(struct xradio_pm_state *pm, struct xradio_common *priv);
+void xradio_pm_deinit(struct xradio_pm_state *pm);
+void xradio_pm_stay_awake(struct xradio_pm_state *pm, unsigned long tmo);
+void xradio_pm_lock_awake(struct xradio_pm_state *pm);
+void xradio_pm_unlock_awake(struct xradio_pm_state *pm);
+int xradio_wow_suspend(struct ieee80211_hw *hw,
+			       struct cfg80211_wowlan *wowlan);
+int xradio_wow_resume(struct ieee80211_hw *hw);
+
+#endif /* CONFIG_PM */
+
+#endif
diff -Naurp a/drivers/net/wireless/xr829/wlan/queue.c b/drivers/net/wireless/xr829/wlan/queue.c
--- a/drivers/net/wireless/xr829/wlan/queue.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/queue.c	2022-08-27 01:22:42.970539923 +0300
@@ -0,0 +1,970 @@
+/*
+ * Queue implementation for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <net/mac80211.h>
+#include <linux/sched.h>
+#include <linux/list.h>
+#include "xradio.h"
+#include "queue.h"
+#ifdef CONFIG_XRADIO_TESTMODE
+#include <linux/time.h>
+#endif /*CONFIG_XRADIO_TESTMODE*/
+
+static inline void __xradio_queue_lock(struct xradio_queue *queue)
+{
+	struct xradio_queue_stats *stats = queue->stats;
+	if (queue->tx_locked_cnt++ == 0) {
+		txrx_printk(XRADIO_DBG_MSG, "[TX] Queue %d is locked.\n",
+				queue->queue_id);
+		mac80211_stop_queue(stats->hw_priv->hw, queue->queue_id);
+		DBG_INT_ADD(queue_lock_cnt);
+	}
+}
+
+static inline void __xradio_queue_unlock(struct xradio_queue *queue)
+{
+	struct xradio_queue_stats *stats = queue->stats;
+	SYS_BUG(!queue->tx_locked_cnt);
+	if (--queue->tx_locked_cnt == 0) {
+		txrx_printk(XRADIO_DBG_MSG, "[TX] Queue %d is unlocked.\n",
+				queue->queue_id);
+		mac80211_wake_queue(stats->hw_priv->hw, queue->queue_id);
+	}
+}
+
+static inline void xradio_queue_parse_id(u32 packetID, u8 *queue_generation,
+						u8 *queue_id,
+						u8 *item_generation,
+						u8 *item_id,
+						u8 *if_id,
+						u8 *link_id)
+{
+	*item_id		= (packetID >>  0) & 0xFF;
+	*item_generation	= (packetID >>  8) & 0xFF;
+	*queue_id		= (packetID >> 16) & 0xF;
+	*if_id			= (packetID >> 20) & 0xF;
+	*link_id		= (packetID >> 24) & 0xF;
+	*queue_generation	= (packetID >> 28) & 0xF;
+}
+
+static inline u32 xradio_queue_make_packet_id(u8 queue_generation,
+						u8 queue_id,
+						u8 item_generation, u8 item_id,
+						u8 if_id, u8 link_id)
+{
+	/*TODO:COMBO: Add interfaceID to the packetID */
+	return ((u32)item_id << 0) |
+		((u32)item_generation << 8) |
+		((u32)queue_id << 16) |
+		((u32)if_id << 20) |
+		((u32)link_id << 24) |
+		((u32)queue_generation << 28);
+}
+
+static void xradio_queue_post_gc(struct xradio_queue_stats *stats)
+{
+	struct xradio_queue_item *item;
+
+	while (!list_empty(&stats->gc_list)) {
+		spin_lock_bh(&stats->lock);
+		item = list_first_entry(
+			&stats->gc_list, struct xradio_queue_item, head);
+		list_del(&item->head);
+		spin_unlock_bh(&stats->lock);
+		stats->skb_dtor(stats->hw_priv, item->skb, &item->txpriv);
+		kfree(item);
+	}
+}
+
+static void xradio_queue_register_post_gc(struct xradio_queue_stats *stats,
+				     struct xradio_queue_item *item)
+{
+	struct xradio_queue_item *gc_item;
+	gc_item = xr_kmalloc(sizeof(struct xradio_queue_item), false);
+	SYS_BUG(!gc_item);
+	memcpy(gc_item, item, sizeof(struct xradio_queue_item));
+	spin_lock_bh(&stats->lock);
+	list_add_tail(&gc_item->head, &stats->gc_list);
+	spin_unlock_bh(&stats->lock);
+}
+
+static void __xradio_queue_gc(struct xradio_queue *queue,
+			      bool unlock)
+{
+	struct xradio_queue_stats *stats = queue->stats;
+	struct xradio_queue_item *item = NULL;
+	/* struct xradio_vif *priv; */
+	int if_id;
+	bool wakeup_stats = false;
+
+	while (!list_empty(&queue->queue)) {
+		struct xradio_txpriv *txpriv;
+		item = list_first_entry(
+			&queue->queue, struct xradio_queue_item, head);
+		if (time_before(jiffies, item->queue_timestamp+queue->ttl))
+			break;
+
+		txpriv = &item->txpriv;
+		if_id = txpriv->if_id;
+		--queue->num_queued;
+		--queue->num_queued_vif[if_id];
+		--queue->link_map_cache[if_id][txpriv->link_id];
+		spin_lock_bh(&stats->lock);
+		--stats->num_queued[if_id];
+		if (!--stats->link_map_cache[if_id][txpriv->link_id])
+			wakeup_stats = true;
+		spin_unlock_bh(&stats->lock);
+		/*
+		priv = xrwl_hwpriv_to_vifpriv(stats->hw_priv, if_id);
+		if (priv) {
+			xradio_debug_tx_ttl(priv);
+			spin_unlock(&priv->vif_lock);
+		} */
+		xradio_queue_register_post_gc(stats, item);
+		item->skb = NULL;
+		list_move_tail(&item->head, &queue->free_pool);
+	}
+
+	if (wakeup_stats)
+		wake_up(&stats->wait_link_id_empty);
+
+	if (queue->overfull) {
+		if (queue->num_queued <= ((stats->hw_priv->vif0_throttle +
+						stats->hw_priv->vif1_throttle+2)>>1)) {
+			queue->overfull = false;
+			if (unlock) {
+				__xradio_queue_unlock(queue);
+			}
+		} else if (item) {
+			unsigned long tmo = item->queue_timestamp + queue->ttl;
+			mod_timer(&queue->gc, tmo);
+#ifdef CONFIG_PM
+			xradio_pm_stay_awake(&stats->hw_priv->pm_state,
+					tmo - jiffies);
+#endif
+		}
+	}
+}
+
+static void xradio_queue_gc(struct timer_list *t)
+{
+	struct xradio_queue *queue = from_timer(queue, t, gc);
+
+	spin_lock_bh(&queue->lock);
+	__xradio_queue_gc(queue, true);
+	spin_unlock_bh(&queue->lock);
+	if (!list_empty(&queue->stats->gc_list))
+		queue_work(queue->stats->hw_priv->workqueue, &queue->stats->gc_work);
+}
+
+void xradio_skb_post_gc(struct xradio_common *hw_priv,
+		     struct sk_buff *skb,
+		     const struct xradio_txpriv *txpriv)
+{
+	struct xradio_queue_item skb_drop;
+	skb_drop.skb = skb;
+	skb_drop.txpriv = *txpriv;
+	xradio_queue_register_post_gc(&hw_priv->tx_queue_stats, &skb_drop);
+	queue_work(hw_priv->workqueue, &hw_priv->tx_queue_stats.gc_work);
+}
+
+
+void xradio_queue_gc_work(struct work_struct *work)
+{
+	struct xradio_queue_stats *stats =
+		container_of(work, struct xradio_queue_stats, gc_work);
+
+	xradio_queue_post_gc(stats);
+}
+
+int xradio_queue_stats_init(struct xradio_queue_stats *stats,
+			    size_t map_capacity,
+			    xradio_queue_skb_dtor_t skb_dtor,
+			    struct xradio_common *hw_priv)
+{
+	int i;
+
+	memset(stats, 0, sizeof(*stats));
+	stats->map_capacity = map_capacity;
+	stats->skb_dtor = skb_dtor;
+	stats->hw_priv = hw_priv;
+	spin_lock_init(&stats->lock);
+	init_waitqueue_head(&stats->wait_link_id_empty);
+	INIT_WORK(&stats->gc_work, xradio_queue_gc_work);
+	INIT_LIST_HEAD(&stats->gc_list);
+	for (i = 0; i < XRWL_MAX_VIFS; i++) {
+		stats->link_map_cache[i] = (int *)xr_kzalloc(sizeof(int) * map_capacity, false);
+		if (!stats->link_map_cache[i]) {
+			for (i--; i >= 0; i--)
+				kfree(stats->link_map_cache[i]);
+			return -ENOMEM;
+		}
+	}
+
+	return 0;
+}
+
+int xradio_queue_init(struct xradio_queue *queue,
+		      struct xradio_queue_stats *stats,
+		      u8 queue_id,
+		      size_t capacity,
+		      unsigned long ttl)
+{
+	int i;
+
+	memset(queue, 0, sizeof(*queue));
+	queue->stats = stats;
+	queue->capacity = capacity;
+	queue->queue_id = queue_id;
+	queue->ttl = ttl;
+	INIT_LIST_HEAD(&queue->queue);
+	INIT_LIST_HEAD(&queue->pending);
+	INIT_LIST_HEAD(&queue->free_pool);
+	spin_lock_init(&queue->lock);
+	/*init_timer(&queue->gc);
+	queue->gc.data = (unsigned long)queue;
+	queue->gc.function = xradio_queue_gc;*/
+	timer_setup(&queue->gc, xradio_queue_gc, 0);
+
+	queue->pool = xr_kzalloc(sizeof(struct xradio_queue_item) * capacity,
+					false);
+	if (!queue->pool)
+		return -ENOMEM;
+
+	for (i = 0; i < XRWL_MAX_VIFS; i++) {
+		queue->link_map_cache[i] =
+			(int *)xr_kzalloc(sizeof(int) * stats->map_capacity, false);
+		if (!queue->link_map_cache[i]) {
+			for (i--; i >= 0; i--)
+				kfree(queue->link_map_cache[i]);
+			kfree(queue->pool);
+			queue->pool = NULL;
+			return -ENOMEM;
+		}
+	}
+
+	for (i = 0; i < capacity; ++i)
+		list_add_tail(&queue->pool[i].head, &queue->free_pool);
+
+	return 0;
+}
+
+/* TODO:COMBO: Flush only a particular interface specific parts */
+int xradio_queue_clear(struct xradio_queue *queue, int if_id)
+{
+	int i, cnt, iter;
+	struct xradio_queue_stats *stats = queue->stats;
+	struct xradio_queue_item *item = NULL, *tmp = NULL;
+
+#if BH_PROC_TX
+	bh_proc_flush_txqueue(stats->hw_priv, if_id);
+#endif
+
+	cnt = 0;
+	spin_lock_bh(&queue->lock);
+	queue->generation++;
+	queue->generation &= 0xf;
+	//list_splice_tail_init(&queue->queue, &queue->pending);
+	list_for_each_entry_safe(item, tmp, &queue->queue, head) {
+		SYS_WARN(!item->skb);
+		if (XRWL_ALL_IFS == if_id || item->txpriv.if_id == if_id) {
+			xradio_queue_register_post_gc(stats, item);
+			item->skb = NULL;
+			list_move_tail(&item->head, &queue->free_pool);
+			--queue->num_queued;
+		}
+	}
+	list_for_each_entry_safe(item, tmp, &queue->pending, head) {
+		SYS_WARN(!item->skb);
+		if (XRWL_ALL_IFS == if_id || item->txpriv.if_id == if_id) {
+			xradio_queue_register_post_gc(stats, item);
+			item->skb = NULL;
+			list_move_tail(&item->head, &queue->free_pool);
+			--queue->num_pending;
+			--queue->num_queued;
+		}
+	}
+	if (XRWL_ALL_IFS != if_id) {
+		queue->num_queued_vif[if_id] = 0;
+		queue->num_pending_vif[if_id] = 0;
+	} else {
+		queue->num_queued = 0;
+		queue->num_pending = 0;
+		for (iter = 0; iter < XRWL_MAX_VIFS; iter++) {
+			queue->num_queued_vif[iter] = 0;
+			queue->num_pending_vif[iter] = 0;
+		}
+	}
+	spin_lock_bh(&stats->lock);
+	if (XRWL_ALL_IFS != if_id) {
+		for (i = 0; i < stats->map_capacity; ++i) {
+			stats->num_queued[if_id] -=
+				queue->link_map_cache[if_id][i];
+			stats->link_map_cache[if_id][i] -=
+				queue->link_map_cache[if_id][i];
+			queue->link_map_cache[if_id][i] = 0;
+		}
+	} else {
+		for (iter = 0; iter < XRWL_MAX_VIFS; iter++) {
+			for (i = 0; i < stats->map_capacity; ++i) {
+				stats->num_queued[iter] -=
+					queue->link_map_cache[iter][i];
+				stats->link_map_cache[iter][i] -=
+					queue->link_map_cache[iter][i];
+				queue->link_map_cache[iter][i] = 0;
+			}
+		}
+	}
+	spin_unlock_bh(&stats->lock);
+	if (unlikely(queue->overfull)) {
+		if (queue->num_queued <= ((stats->hw_priv->vif0_throttle +
+			stats->hw_priv->vif1_throttle+2)>>1)) {
+			queue->overfull = false;
+			__xradio_queue_unlock(queue);
+		}
+	}
+	spin_unlock_bh(&queue->lock);
+	wake_up(&stats->wait_link_id_empty);
+	if (!list_empty(&stats->gc_list))
+		xradio_queue_post_gc(stats);
+	return 0;
+}
+
+void xradio_queue_stats_deinit(struct xradio_queue_stats *stats)
+{
+	int i;
+
+	for (i = 0; i < XRWL_MAX_VIFS ; i++) {
+		kfree(stats->link_map_cache[i]);
+		stats->link_map_cache[i] = NULL;
+	}
+}
+
+void xradio_queue_deinit(struct xradio_queue *queue)
+{
+	int i;
+
+	xradio_queue_clear(queue, XRWL_ALL_IFS);
+	del_timer_sync(&queue->gc);
+	INIT_LIST_HEAD(&queue->free_pool);
+	kfree(queue->pool);
+	for (i = 0; i < XRWL_MAX_VIFS; i++) {
+		kfree(queue->link_map_cache[i]);
+		queue->link_map_cache[i] = NULL;
+	}
+	queue->pool = NULL;
+	queue->capacity = 0;
+}
+
+size_t xradio_queue_get_num_queued(struct xradio_vif *priv,
+				   struct xradio_queue *queue,
+				   u32 link_id_map)
+{
+	size_t ret;
+	int i, bit;
+	size_t map_capacity = queue->stats->map_capacity;
+
+	if (!link_id_map)
+		return 0;
+
+	spin_lock_bh(&queue->lock);
+	if (likely(link_id_map == (u32) -1)) {
+		ret = queue->num_queued_vif[priv->if_id] -
+			queue->num_pending_vif[priv->if_id];
+	} else {
+		ret = 0;
+		for (i = 0, bit = 1; i < map_capacity; ++i, bit <<= 1) {
+			if (link_id_map & bit)
+				ret +=
+				queue->link_map_cache[priv->if_id][i];
+		}
+	}
+	spin_unlock_bh(&queue->lock);
+	return ret;
+}
+
+int xradio_queue_put(struct xradio_queue *queue, struct sk_buff *skb,
+		     struct xradio_txpriv *txpriv)
+{
+	int ret = 0;
+#ifdef CONFIG_XRADIO_TESTMODE
+	struct timeval tmval;
+#endif /*CONFIG_XRADIO_TESTMODE*/
+	LIST_HEAD(gc_list);
+	struct xradio_queue_stats *stats = queue->stats;
+	/* TODO:COMBO: Add interface ID info to queue item */
+
+	if (txpriv->link_id >= queue->stats->map_capacity)
+		return -EINVAL;
+
+	spin_lock_bh(&queue->lock);
+	if (!SYS_WARN(list_empty(&queue->free_pool))) {
+		struct xradio_queue_item *item = list_first_entry(
+			&queue->free_pool, struct xradio_queue_item, head);
+		SYS_BUG(item->skb);
+
+		list_move_tail(&item->head, &queue->queue);
+		item->skb = skb;
+		item->txpriv = *txpriv;
+		item->generation  = 1; /* avoid packet ID is 0.*/
+		item->pack_stk_wr = 0;
+		item->packetID = xradio_queue_make_packet_id(
+			queue->generation, queue->queue_id,
+			item->generation, item - queue->pool,
+			txpriv->if_id, txpriv->raw_link_id);
+		item->queue_timestamp = jiffies;
+#ifdef CONFIG_XRADIO_TESTMODE
+		xr_do_gettimeofday(&tmval);
+		item->qdelay_timestamp = tmval.tv_usec;
+#endif /*CONFIG_XRADIO_TESTMODE*/
+
+#ifdef TES_P2P_0002_ROC_RESTART
+		if (TES_P2P_0002_state == TES_P2P_0002_STATE_SEND_RESP) {
+			TES_P2P_0002_packet_id = item->packetID;
+			TES_P2P_0002_state = TES_P2P_0002_STATE_GET_PKTID;
+			txrx_printk(XRADIO_DBG_WARN, "[ROC_RESTART_STATE_GET_PKTID]\n");
+		}
+#endif
+
+		++queue->num_queued;
+		++queue->num_queued_vif[txpriv->if_id];
+		++queue->link_map_cache[txpriv->if_id][txpriv->link_id];
+
+		spin_lock_bh(&stats->lock);
+		++stats->num_queued[txpriv->if_id];
+		++stats->link_map_cache[txpriv->if_id][txpriv->link_id];
+		spin_unlock_bh(&stats->lock);
+
+		/*
+		 * TX may happen in parallel sometimes.
+		 * Leave extra queue slots so we don't overflow.
+		 */
+		if (queue->overfull == false &&
+				queue->num_queued >=
+		((stats->hw_priv->vif0_throttle + stats->hw_priv->vif1_throttle)
+				- (num_present_cpus() - 1))) {
+			DBG_INT_ADD(overfull_lock_cnt);
+			queue->overfull = true;
+			__xradio_queue_lock(queue);
+			mod_timer(&queue->gc, jiffies);
+			txrx_printk(XRADIO_DBG_NIY, "!lock queue\n");
+		}
+	} else {
+		ret = -ENOENT;
+	}
+#if 0
+	txrx_printk(XRADIO_DBG_ERROR, "queue_put queue %d, %d, %d\n",
+		queue->num_queued,
+		queue->link_map_cache[txpriv->if_id][txpriv->link_id],
+		queue->num_pending);
+	txrx_printk(XRADIO_DBG_ERROR, "queue_put stats %d, %d\n", stats->num_queued,
+		stats->link_map_cache[txpriv->if_id][txpriv->link_id]);
+#endif
+	spin_unlock_bh(&queue->lock);
+	return ret;
+}
+
+#if BH_PROC_TX
+int xradio_queue_get(struct xradio_queue *queue,
+			int if_id,
+		     u32 link_id_map,
+		     struct wsm_tx **tx,
+		     struct ieee80211_tx_info **tx_info,
+		     struct xradio_txpriv **txpriv, u8 **data)
+#else
+int xradio_queue_get(struct xradio_queue *queue,
+			int if_id,
+		     u32 link_id_map,
+		     struct wsm_tx **tx,
+		     struct ieee80211_tx_info **tx_info,
+		     struct xradio_txpriv **txpriv)
+#endif
+{
+	int ret = -ENOENT;
+	struct xradio_queue_item *item;
+	struct xradio_queue_stats *stats = queue->stats;
+	bool wakeup_stats = false;
+#ifdef CONFIG_XRADIO_TESTMODE
+	struct timeval tmval;
+#endif /*CONFIG_XRADIO_TESTMODE*/
+
+	spin_lock_bh(&queue->lock);
+	list_for_each_entry(item, &queue->queue, head) {
+		if ((item->txpriv.if_id == if_id) &&
+			(link_id_map & BIT(item->txpriv.link_id))) {
+			ret = 0;
+			break;
+		}
+	}
+
+	if (!SYS_WARN(ret)) {
+		*tx = (struct wsm_tx *)item->skb->data;
+		*tx_info = IEEE80211_SKB_CB(item->skb);
+		*txpriv = &item->txpriv;
+		(*tx)->packetID = __cpu_to_le32(item->packetID);
+		list_move_tail(&item->head, &queue->pending);
+		++queue->num_pending;
+		++queue->num_pending_vif[item->txpriv.if_id];
+		--queue->link_map_cache[item->txpriv.if_id]
+				[item->txpriv.link_id];
+		item->xmit_timestamp = jiffies;
+#if BH_PROC_TX
+		item->xmit_to_fw = 0;
+		*data = (u8 *)item;
+#endif
+
+#ifdef CONFIG_XRADIO_TESTMODE
+		xr_do_gettimeofday(&tmval);
+		item->mdelay_timestamp = tmval.tv_usec;
+#endif /*CONFIG_XRADIO_TESTMODE*/
+
+		spin_lock_bh(&stats->lock);
+		--stats->num_queued[item->txpriv.if_id];
+		if (!--stats->link_map_cache[item->txpriv.if_id]
+					[item->txpriv.link_id])
+			wakeup_stats = true;
+
+		spin_unlock_bh(&stats->lock);
+#if 0
+		txrx_printk(XRADIO_DBG_ERROR, "queue_get queue %d, %d, %d\n",
+		queue->num_queued,
+		queue->link_map_cache[item->txpriv.if_id][item->txpriv.link_id],
+		queue->num_pending);
+		txrx_printk(XRADIO_DBG_ERROR, "queue_get stats %d, %d\n",
+			    stats->num_queued,
+		stats->link_map_cache[item->txpriv.if_id]
+		[item->txpriv.link_id]);
+#endif
+	} else {/*add debug info for warning*/
+		struct xradio_queue_item *item_tmp;
+		txrx_printk(XRADIO_DBG_WARN,
+			"%s, if_id=%d, link_id_map=%08x, queued=%zu, pending=%zu\n",
+			__func__, if_id, link_id_map, queue->num_queued_vif[if_id],
+			queue->num_pending_vif[if_id]);
+		list_for_each_entry(item_tmp, &queue->queue, head) {
+			txrx_printk(XRADIO_DBG_WARN, "%s, item_if_id=%d, item_link_id=%d\n",
+				__func__, item_tmp->txpriv.if_id, item_tmp->txpriv.link_id);
+		}
+	}
+	spin_unlock_bh(&queue->lock);
+	if (wakeup_stats)
+		wake_up(&stats->wait_link_id_empty);
+
+	return ret;
+}
+
+#ifdef CONFIG_XRADIO_TESTMODE
+int xradio_queue_requeue(struct xradio_common *hw_priv,
+	struct xradio_queue *queue, u32 packetID, bool check)
+#else
+int xradio_queue_requeue(struct xradio_queue *queue, u32 packetID, bool check)
+#endif
+{
+	int ret = 0;
+	u8 queue_generation, queue_id, item_generation, item_id, if_id, link_id;
+	struct xradio_queue_item *item;
+	struct xradio_queue_stats *stats = queue->stats;
+
+	xradio_queue_parse_id(packetID, &queue_generation, &queue_id,
+				&item_generation, &item_id, &if_id, &link_id);
+
+	item = &queue->pool[item_id];
+#ifdef P2P_MULTIVIF
+	if (check && item->txpriv.if_id == XRWL_GENERIC_IF_ID) {
+#else
+	if (check && item->txpriv.offchannel_if_id == XRWL_GENERIC_IF_ID) {
+#endif
+		txrx_printk(XRADIO_DBG_MSG, "Requeued frame dropped for "
+						"generic interface id.\n");
+#ifdef CONFIG_XRADIO_TESTMODE
+		xradio_queue_remove(hw_priv, queue, packetID);
+#else
+		xradio_queue_remove(queue, packetID);
+#endif
+		return 0;
+	}
+
+#ifndef P2P_MULTIVIF
+	if (!check)
+		item->txpriv.offchannel_if_id = XRWL_GENERIC_IF_ID;
+#endif
+
+	/*if_id = item->txpriv.if_id;*/
+
+	spin_lock_bh(&queue->lock);
+	SYS_BUG(queue_id != queue->queue_id);
+	if (unlikely(queue_generation != queue->generation)) {
+		ret = -ENOENT;
+	} else if (unlikely(item_id >= (unsigned) queue->capacity)) {
+		SYS_WARN(1);
+		ret = -EINVAL;
+	} else if (unlikely(item->generation != item_generation)) {
+		SYS_WARN(1);
+		ret = -ENOENT;
+	} else {
+		--queue->num_pending;
+		--queue->num_pending_vif[if_id];
+		++queue->link_map_cache[if_id][item->txpriv.link_id];
+
+		spin_lock_bh(&stats->lock);
+		++stats->num_queued[item->txpriv.if_id];
+		++stats->link_map_cache[if_id][item->txpriv.link_id];
+		spin_unlock_bh(&stats->lock);
+
+		item->generation = ++item_generation;
+		item->packetID = xradio_queue_make_packet_id(
+			queue_generation, queue_id, item_generation, item_id,
+			if_id, link_id);
+		list_move(&item->head, &queue->queue);
+#if 0
+		txrx_printk(XRADIO_DBG_ERROR, "queue_requeue queue %d, %d, %d\n",
+		queue->num_queued,
+		queue->link_map_cache[if_id][item->txpriv.link_id],
+		queue->num_pending);
+		txrx_printk(XRADIO_DBG_ERROR, "queue_requeue stats %d, %d\n",
+		stats->num_queued,
+		stats->link_map_cache[if_id][item->txpriv.link_id]);
+#endif
+	}
+	spin_unlock_bh(&queue->lock);
+	return ret;
+}
+
+int xradio_queue_requeue_all(struct xradio_queue *queue)
+{
+	struct xradio_queue_stats *stats = queue->stats;
+	spin_lock_bh(&queue->lock);
+	while (!list_empty(&queue->pending)) {
+		struct xradio_queue_item *item = list_entry(
+			queue->pending.prev, struct xradio_queue_item, head);
+
+		--queue->num_pending;
+		--queue->num_pending_vif[item->txpriv.if_id];
+		++queue->link_map_cache[item->txpriv.if_id]
+				[item->txpriv.link_id];
+
+		spin_lock_bh(&stats->lock);
+		++stats->num_queued[item->txpriv.if_id];
+		++stats->link_map_cache[item->txpriv.if_id]
+				[item->txpriv.link_id];
+		spin_unlock_bh(&stats->lock);
+
+		++item->generation;
+		item->packetID = xradio_queue_make_packet_id(
+			queue->generation, queue->queue_id,
+			item->generation, item - queue->pool,
+			item->txpriv.if_id, item->txpriv.raw_link_id);
+		list_move(&item->head, &queue->queue);
+	}
+	spin_unlock_bh(&queue->lock);
+
+	return 0;
+}
+#ifdef CONFIG_XRADIO_TESTMODE
+int xradio_queue_remove(struct xradio_common *hw_priv,
+				struct xradio_queue *queue, u32 packetID)
+#else
+int xradio_queue_remove(struct xradio_queue *queue, u32 packetID)
+#endif /*CONFIG_XRADIO_TESTMODE*/
+{
+	int ret = 0;
+	u8 queue_generation, queue_id, item_generation, item_id, if_id, link_id;
+	struct xradio_queue_item *item;
+	struct xradio_queue_stats *stats = queue->stats;
+	struct sk_buff *gc_skb = NULL;
+	struct xradio_txpriv gc_txpriv;
+
+	xradio_queue_parse_id(packetID, &queue_generation, &queue_id,
+				&item_generation, &item_id, &if_id, &link_id);
+
+	item = &queue->pool[item_id];
+
+	spin_lock_bh(&queue->lock);
+	SYS_BUG(queue_id != queue->queue_id);
+	/*TODO:COMBO:Add check for interface ID also */
+	if (unlikely(queue_generation != queue->generation)) {
+		ret = -ENOENT;
+	} else if (unlikely(item_id >= (unsigned) queue->capacity)) {
+		SYS_WARN(1);
+		ret = -EINVAL;
+	} else if (unlikely(item->generation != item_generation)) {
+		SYS_WARN(1);
+		ret = -ENOENT;
+	} else {
+		gc_txpriv = item->txpriv;
+		gc_skb = item->skb;
+		item->skb = NULL;
+		--queue->num_pending;
+		--queue->num_pending_vif[if_id];
+		--queue->num_queued;
+		--queue->num_queued_vif[if_id];
+		++queue->num_sent;
+		++item->generation;
+#ifdef CONFIG_XRADIO_TESTMODE
+		spin_lock_bh(&hw_priv->tsm_lock);
+		if (hw_priv->start_stop_tsm.start) {
+			if (queue_id == hw_priv->tsm_info.ac) {
+				struct timeval tmval;
+				unsigned long queue_delay;
+				unsigned long media_delay;
+				xr_do_gettimeofday(&tmval);
+
+				if (tmval.tv_usec > item->qdelay_timestamp)
+					queue_delay = tmval.tv_usec -
+						item->qdelay_timestamp;
+				else
+					queue_delay = tmval.tv_usec +
+					1000000 - item->qdelay_timestamp;
+
+				if (tmval.tv_usec > item->mdelay_timestamp)
+					media_delay = tmval.tv_usec -
+						item->mdelay_timestamp;
+				else
+					media_delay = tmval.tv_usec +
+					1000000 - item->mdelay_timestamp;
+				hw_priv->tsm_info.sum_media_delay +=
+							media_delay;
+				hw_priv->tsm_info.sum_pkt_q_delay += queue_delay;
+				if (queue_delay <= 10000)
+					hw_priv->tsm_stats.bin0++;
+				else if (queue_delay <= 20000)
+					hw_priv->tsm_stats.bin1++;
+				else if (queue_delay <= 40000)
+					hw_priv->tsm_stats.bin2++;
+				else
+					hw_priv->tsm_stats.bin3++;
+			}
+		}
+		spin_unlock_bh(&hw_priv->tsm_lock);
+#endif /*CONFIG_XRADIO_TESTMODE*/
+		/* Do not use list_move_tail here, but list_move:
+		 * try to utilize cache row.
+		 */
+		list_move(&item->head, &queue->free_pool);
+
+		if (unlikely(queue->overfull) &&
+		    (queue->num_queued <= ((stats->hw_priv->vif0_throttle +
+		     stats->hw_priv->vif1_throttle + 2)>>1))) {
+			queue->overfull = false;
+			__xradio_queue_unlock(queue);
+		}
+	}
+	spin_unlock_bh(&queue->lock);
+
+#if 0
+	txrx_printk(XRADIO_DBG_ERROR, "queue_drop queue %d, %d, %d\n",
+		queue->num_queued, queue->link_map_cache[if_id][0],
+		queue->num_pending);
+	txrx_printk(XRADIO_DBG_ERROR, "queue_drop stats %d, %d\n",
+		    stats->num_queued, stats->link_map_cache[if_id][0]);
+#endif
+	if (gc_skb)
+		stats->skb_dtor(stats->hw_priv, gc_skb, &gc_txpriv);
+
+	return ret;
+}
+
+int xradio_queue_get_skb(struct xradio_queue *queue, u32 packetID,
+			 struct sk_buff **skb,
+			 const struct xradio_txpriv **txpriv)
+{
+	int ret = 0;
+	u8 queue_generation, queue_id, item_generation, item_id, if_id, link_id;
+	struct xradio_queue_item *item;
+
+	xradio_queue_parse_id(packetID, &queue_generation, &queue_id,
+				&item_generation, &item_id, &if_id, &link_id);
+
+	item = &queue->pool[item_id];
+
+	spin_lock_bh(&queue->lock);
+	SYS_BUG(queue_id != queue->queue_id);
+	/* TODO:COMBO: Add check for interface ID here */
+	if (unlikely(queue_generation != queue->generation)) {
+		txrx_printk(XRADIO_DBG_WARN, "%s, queue generation match failed!\n",
+				__func__);
+		ret = -ENOENT;
+	} else if (unlikely(item_id >= (unsigned) queue->capacity)) {
+		txrx_printk(XRADIO_DBG_WARN, "%s, invalid item_id!\n", __func__);
+		ret = -EINVAL;
+	} else if (unlikely(item->generation != item_generation)) {
+		txrx_printk(XRADIO_DBG_WARN, "%s, item generation match failed!\n",
+				__func__);
+		ret = -ENOENT;
+	} else {
+		*skb = item->skb;
+		*txpriv = &item->txpriv;
+	}
+	spin_unlock_bh(&queue->lock);
+	return ret;
+}
+
+void xradio_queue_lock(struct xradio_queue *queue)
+{
+	spin_lock_bh(&queue->lock);
+	__xradio_queue_lock(queue);
+	spin_unlock_bh(&queue->lock);
+}
+
+void xradio_queue_unlock(struct xradio_queue *queue)
+{
+	spin_lock_bh(&queue->lock);
+	__xradio_queue_unlock(queue);
+	spin_unlock_bh(&queue->lock);
+}
+
+bool xradio_queue_get_xmit_timestamp(struct xradio_queue *queue,
+				     unsigned long *timestamp, int if_id,
+				     u32 pending_frameID, u32 *Old_frame_ID)
+{
+	struct xradio_queue_item *item;
+	bool ret;
+
+	spin_lock_bh(&queue->lock);
+	ret = !list_empty(&queue->pending);
+	if (ret) {
+		list_for_each_entry(item, &queue->pending, head) {
+			if (((if_id == XRWL_GENERIC_IF_ID) ||
+				(if_id == XRWL_ALL_IFS) ||
+					(item->txpriv.if_id == if_id)) &&
+					(item->packetID != pending_frameID)) {
+				if (time_before(item->xmit_timestamp,
+							*timestamp)) {
+					*timestamp = item->xmit_timestamp;
+					*Old_frame_ID = item->packetID;
+				}
+			}
+		}
+	}
+	spin_unlock_bh(&queue->lock);
+	return ret;
+}
+
+bool xradio_queue_stats_is_empty(struct xradio_queue_stats *stats,
+				 u32 link_id_map, int if_id)
+{
+	bool empty = true;
+
+	spin_lock_bh(&stats->lock);
+	if (link_id_map == (u32)-1)
+		empty = stats->num_queued[if_id] == 0;
+	else {
+		int i, if_id;
+		for (if_id = 0; if_id < XRWL_MAX_VIFS; if_id++) {
+			for (i = 0; i < stats->map_capacity; ++i) {
+				if (link_id_map & BIT(i)) {
+					if (stats->link_map_cache[if_id][i]) {
+						empty = false;
+						break;
+					}
+				}
+			}
+		}
+	}
+	spin_unlock_bh(&stats->lock);
+
+	return empty;
+}
+
+bool xradio_query_txpkt_timeout(struct xradio_common *hw_priv, int if_id,
+				u32 pending_pkt_id, long *timeout)
+{
+	int i;
+	bool pending = false;
+	unsigned long timestamp = jiffies;
+	struct xradio_queue      *queue = NULL;
+	struct xradio_queue_item *item  = NULL;
+	struct xradio_queue      *old_queue = NULL;
+	struct xradio_queue_item *old_item  = NULL;
+	u8 pack_stk_wr = 0;
+
+	/* Get oldest frame.*/
+	for (i = 0; i < AC_QUEUE_NUM; ++i) {
+		queue = &hw_priv->tx_queue[i];
+		spin_lock_bh(&queue->lock);
+		if (!list_empty(&queue->pending)) {
+			list_for_each_entry(item, &queue->pending, head) {
+#if BH_PROC_TX
+				if (!item->xmit_to_fw)
+					continue;
+#endif
+				if (((if_id == XRWL_GENERIC_IF_ID) ||
+					 (if_id == XRWL_ALL_IFS) ||
+					 (item->txpriv.if_id == if_id)) &&
+					 (item->packetID != pending_pkt_id)) {
+					if (time_before(item->xmit_timestamp, timestamp)) {
+						timestamp   = item->xmit_timestamp;
+						pack_stk_wr = item->pack_stk_wr;
+						old_queue   = queue;
+						old_item    = item;
+					}
+					pending = true;
+				}
+			}
+		}
+		spin_unlock_bh(&queue->lock);
+	}
+	if (!pending)
+		return false;
+
+	/* Check if frame transmission is timed out.
+	 * add (WSM_CMD_LAST_CHANCE_TIMEOUT>>1) for stuck workaround.*/
+	*timeout = timestamp + WSM_CMD_LAST_CHANCE_TIMEOUT - jiffies;
+	if (hw_priv->BT_active) {
+		*timeout += msecs_to_jiffies((BT_MAX_BLOCK_TIME>>1));
+	}
+	if (unlikely(*timeout < 0) && !pack_stk_wr) {
+		struct ieee80211_hdr *frame = NULL;
+		const struct xradio_txpriv *txpriv = NULL;
+		u16 fctl = 0x0;
+		u32 len  = 0x0;
+		u8 if_id = 0, link_id = 0, tid = 0;
+
+		/* query the timeout frame. */
+		spin_lock_bh(&old_queue->lock);
+		if (likely(old_item->skb && !hw_priv->query_packetID)) {
+			hw_priv->query_packetID = old_item->packetID;
+			old_item->pack_stk_wr = 1;
+			atomic_add(1, &hw_priv->query_cnt);
+
+			/* Info of stuck frames for debug.*/
+			txpriv = &old_item->txpriv;
+			frame  = (struct ieee80211_hdr *)(&old_item->skb->data[txpriv->offset]);
+			fctl   = frame->frame_control;
+			len    = old_item->skb->len;
+			if_id  = txpriv->if_id;
+			link_id = txpriv->link_id;
+			tid = txpriv->tid;
+		}
+		spin_unlock_bh(&old_queue->lock);
+		/* Dump Info of stuck frames. */
+		if (frame) {
+			txrx_printk(XRADIO_DBG_ERROR, "TX confirm timeout(%ds).\n",
+				    WSM_CMD_LAST_CHANCE_TIMEOUT/HZ);
+			txrx_printk(XRADIO_DBG_ALWY, "if=%d, linkid=%d, tid=%d, " \
+				    "old_packetID=0x%08x, fctl=0x%04x, len=%d, wr=%d\n",
+				    if_id, link_id, tid,
+				    hw_priv->query_packetID, fctl, len,
+				    pack_stk_wr);
+		}
+		/* Return half of timeout for query packet. */
+		*timeout = (WSM_CMD_LAST_CHANCE_TIMEOUT>>1);
+	} else if (unlikely(pack_stk_wr)) {
+		*timeout = *timeout + (WSM_CMD_LAST_CHANCE_TIMEOUT>>1);
+		if (*timeout < 0)
+			txrx_printk(XRADIO_DBG_ERROR, "%s, wr and timeout, packetID=0x%08x\n",
+					__func__, old_item->packetID);
+		else
+			txrx_printk(XRADIO_DBG_MSG, "%s, wr and timeout=%ld\n",
+					__func__, *timeout);
+	}
+	return pending;
+}
diff -Naurp a/drivers/net/wireless/xr829/wlan/queue.h b/drivers/net/wireless/xr829/wlan/queue.h
--- a/drivers/net/wireless/xr829/wlan/queue.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/queue.h	2022-08-27 01:22:42.970539923 +0300
@@ -0,0 +1,186 @@
+/*
+ * queue operations for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#ifndef XRADIO_QUEUE_H_INCLUDED
+#define XRADIO_QUEUE_H_INCLUDED
+
+
+/* extern */ struct sk_buff;
+/* extern */ struct wsm_tx;
+/* extern */ struct xradio_common;
+/* extern */ struct xradio_vif;
+/* extern */ struct ieee80211_tx_queue_stats;
+
+/* forward */ struct xradio_queue_stats;
+
+struct xradio_txpriv {
+	u8 link_id;
+	u8 raw_link_id;
+	u8 tid;
+	u8 rate_id;
+	u8 offset;
+	u8 if_id;
+#ifndef P2P_MULTIVIF
+	u8 offchannel_if_id;
+#else
+	u8 raw_if_id;
+#endif
+	u8 use_bg_rate;
+#ifdef AP_ARP_COMPAT_FIX
+	u8 iv_len;
+#endif
+};
+
+struct xradio_queue_item {
+	struct list_head	head;
+	struct sk_buff		*skb;
+	u32			packetID;
+	unsigned long		queue_timestamp;
+	unsigned long		xmit_timestamp;
+#ifdef CONFIG_XRADIO_TESTMODE
+	unsigned long		mdelay_timestamp;
+	unsigned long		qdelay_timestamp;
+#endif /*CONFIG_XRADIO_TESTMODE*/
+	struct xradio_txpriv	txpriv;
+	u8			generation;
+	u8			pack_stk_wr;
+#if BH_PROC_TX
+	u8			xmit_to_fw;
+#endif
+};
+
+typedef void (*xradio_queue_skb_dtor_t)(struct xradio_common *priv,
+					struct sk_buff *skb,
+					const struct xradio_txpriv *txpriv);
+
+struct xradio_queue {
+	struct                    xradio_queue_stats *stats;
+	size_t                    capacity;
+	size_t                    num_queued;
+	size_t                    num_queued_vif[XRWL_MAX_VIFS];
+	size_t                    num_pending;
+	size_t                    num_pending_vif[XRWL_MAX_VIFS];
+	size_t                    num_sent;
+	struct xradio_queue_item *pool;
+	struct list_head          queue;
+	struct list_head          free_pool;
+	struct list_head          pending;
+	int                       tx_locked_cnt;
+	int                      *link_map_cache[XRWL_MAX_VIFS];
+	bool                      overfull;
+	spinlock_t                lock;
+	u8                        queue_id;
+	u8                        generation;
+	struct timer_list	        gc;
+	unsigned long             ttl;
+};
+
+struct xradio_queue_stats {
+	spinlock_t              lock;
+	int                    *link_map_cache[XRWL_MAX_VIFS];
+	int                     num_queued[XRWL_MAX_VIFS];
+	size_t                  map_capacity;
+	wait_queue_head_t       wait_link_id_empty;
+	struct list_head        gc_list;
+	struct work_struct      gc_work;
+	xradio_queue_skb_dtor_t skb_dtor;
+	struct xradio_common   *hw_priv;
+};
+
+int xradio_queue_stats_init(struct xradio_queue_stats *stats,
+			    size_t map_capacity,
+			    xradio_queue_skb_dtor_t skb_dtor,
+			    struct xradio_common *priv);
+int xradio_queue_init(struct xradio_queue *queue,
+		      struct xradio_queue_stats *stats,
+		      u8 queue_id,
+		      size_t capacity,
+		      unsigned long ttl);
+int xradio_queue_clear(struct xradio_queue *queue, int if_id);
+void xradio_queue_stats_deinit(struct xradio_queue_stats *stats);
+void xradio_queue_deinit(struct xradio_queue *queue);
+
+size_t xradio_queue_get_num_queued(struct xradio_vif *priv,
+				   struct xradio_queue *queue,
+				   u32 link_id_map);
+int xradio_queue_put(struct xradio_queue *queue,
+		     struct sk_buff *skb, struct xradio_txpriv *txpriv);
+void xradio_skb_post_gc(struct xradio_common *hw_priv,
+		     struct sk_buff *skb,
+		     const struct xradio_txpriv *txpriv);
+
+#if BH_PROC_TX
+int xradio_queue_get(struct xradio_queue *queue,
+		     int if_id, u32 link_id_map,
+		     struct wsm_tx **tx,
+		     struct ieee80211_tx_info **tx_info,
+		     struct xradio_txpriv **txpriv, u8 **data);
+#else
+int xradio_queue_get(struct xradio_queue *queue,
+		     int if_id, u32 link_id_map,
+		     struct wsm_tx **tx,
+		     struct ieee80211_tx_info **tx_info,
+		     struct xradio_txpriv **txpriv);
+#endif
+
+#ifdef CONFIG_XRADIO_TESTMODE
+int xradio_queue_requeue(struct xradio_common *hw_priv,
+			 struct xradio_queue *queue,
+			 u32 packetID, bool check);
+#else
+int xradio_queue_requeue(struct xradio_queue *queue, u32 packetID, bool check);
+#endif
+int xradio_queue_requeue_all(struct xradio_queue *queue);
+#ifdef CONFIG_XRADIO_TESTMODE
+int xradio_queue_remove(struct xradio_common *hw_priv,
+			struct xradio_queue *queue,
+			u32 packetID);
+#else
+int xradio_queue_remove(struct xradio_queue *queue,
+			u32 packetID);
+#endif /*CONFIG_XRADIO_TESTMODE*/
+int xradio_queue_get_skb(struct xradio_queue *queue, u32 packetID,
+			 struct sk_buff **skb,
+			 const struct xradio_txpriv **txpriv);
+void xradio_queue_lock(struct xradio_queue *queue);
+void xradio_queue_unlock(struct xradio_queue *queue);
+bool xradio_queue_get_xmit_timestamp(struct xradio_queue *queue,
+				     unsigned long *timestamp, int if_id,
+				     u32 pending_frameID, u32 *Old_frame_ID);
+bool xradio_query_txpkt_timeout(struct xradio_common *hw_priv, int if_id,
+				u32 pending_pkt_id, long *timeout);
+
+
+bool xradio_queue_stats_is_empty(struct xradio_queue_stats *stats,
+				 u32 link_id_map, int if_id);
+
+static inline u8 xradio_queue_get_queue_id(u32 packetID)
+{
+	return (packetID >> 16) & 0xF;
+}
+
+static inline u8 xradio_queue_get_if_id(u32 packetID)
+{
+	return (packetID >> 20) & 0xF;
+}
+
+static inline u8 xradio_queue_get_link_id(u32 packetID)
+{
+	return (packetID >> 24) & 0xF;
+}
+
+static inline u8 xradio_queue_get_generation(u32 packetID)
+{
+	return (packetID >>  8) & 0xFF;
+}
+
+#endif /* XRADIO_QUEUE_H_INCLUDED */
diff -Naurp a/drivers/net/wireless/xr829/wlan/sbus.h b/drivers/net/wireless/xr829/wlan/sbus.h
--- a/drivers/net/wireless/xr829/wlan/sbus.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/sbus.h	2022-08-27 01:22:42.970539923 +0300
@@ -0,0 +1,100 @@
+/*
+ * Sbus interfaces for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#ifndef __SBUS_H
+#define __SBUS_H
+
+#include <linux/version.h>
+#include <linux/module.h>
+/*
+ * sbus priv forward definition.
+ * Implemented and instantiated in particular modules.
+ */
+
+struct xradio_common;
+/*sdio bus private struct*/
+#define SDIO_UNLOAD   0
+#define SDIO_LOAD     1
+
+#ifdef CONFIG_XRADIO_NON_POWER_OF_TWO_BLOCKSIZES
+
+#define SDIO_BLOCK_SIZE (264)  /*264 = 528/2*/
+#if (SDIO_BLOCK_SIZE & 0x3)
+#error "SDIO_BLOCK_SIZE is not aligned of 4 byte"
+#endif
+
+#else
+
+#define SDIO_BLOCK_SIZE (256)
+#if ((SDIO_BLOCK_SIZE-1) & SDIO_BLOCK_SIZE)
+#error "SDIO_BLOCK_SIZE is not power of 2"
+#endif
+
+#endif
+
+
+typedef void (*sbus_irq_handler)(void *priv);
+struct sbus_priv {
+	struct sdio_func     *func;
+	spinlock_t            lock;
+	sbus_irq_handler      irq_handler;
+	void                 *irq_priv;
+	wait_queue_head_t     init_wq;
+	int                   load_state;
+	u32                  *val32_r;
+	u32                  *val32_w;
+};
+
+struct sbus_ops {
+	int (*sbus_data_read)(struct sbus_priv *self, unsigned int addr,
+					void *dst, int count);
+	int (*sbus_data_write)(struct sbus_priv *self, unsigned int addr,
+					const void *src, int count);
+	void (*lock)(struct sbus_priv *self);
+	void (*unlock)(struct sbus_priv *self);
+	size_t (*align_size)(struct sbus_priv *self, size_t size);
+	int (*set_block_size)(struct sbus_priv *self, size_t size);
+	size_t (*get_block_size)(struct sbus_priv *self);
+	int (*irq_subscribe)(struct sbus_priv *self,
+	      sbus_irq_handler handler, void *priv);
+	int (*irq_unsubscribe)(struct sbus_priv *self);
+	int (*power_mgmt)(struct sbus_priv *self, bool suspend);
+	int (*reset)(struct sbus_priv *self);
+};
+
+#ifdef CONFIG_XRADIO_NON_POWER_OF_TWO_BLOCKSIZES
+static inline unsigned xr_sdio_blksize_align(unsigned size)
+{
+	unsigned align_size = size%SDIO_BLOCK_SIZE;
+	return align_size ? (size + SDIO_BLOCK_SIZE - align_size) : size;
+}
+#else
+static inline unsigned xr_sdio_blksize_align(unsigned size)
+{
+	return (size + (SDIO_BLOCK_SIZE - 1)) &
+			(~(SDIO_BLOCK_SIZE - 1));
+}
+#endif
+
+static inline unsigned xr_sdio_align_broken_byte512(unsigned size)
+{
+	unsigned align_size = (size + 0x3) & 0x3;
+	return (align_size < 512 ?
+			align_size : xr_sdio_blksize_align(align_size));
+}
+
+/*sbus init functions*/
+struct device *sbus_sdio_init(struct sbus_ops  **sdio_ops,
+			       struct sbus_priv **sdio_priv);
+void  sbus_sdio_deinit(void);
+
+#endif /* __SBUS_H */
diff -Naurp a/drivers/net/wireless/xr829/wlan/scan.c b/drivers/net/wireless/xr829/wlan/scan.c
--- a/drivers/net/wireless/xr829/wlan/scan.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/scan.c	2022-08-27 01:22:42.970539923 +0300
@@ -0,0 +1,1377 @@
+/*
+ * Scan implementation for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/sched.h>
+#include "xradio.h"
+#include "scan.h"
+#include "sta.h"
+#include "pm.h"
+
+static void xradio_scan_restart_delayed(struct xradio_vif *priv);
+
+#ifdef CONFIG_XRADIO_TESTMODE
+static int xradio_advance_scan_start(struct xradio_common *hw_priv)
+{
+	int tmo = 0;
+	scan_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	tmo += hw_priv->advanceScanElems.duration;
+#ifdef CONFIG_PM
+	xradio_pm_stay_awake(&hw_priv->pm_state, tmo * HZ / 1000);
+#endif
+	/* Invoke Advance Scan Duration Timeout Handler */
+	queue_delayed_work(hw_priv->workqueue,
+		&hw_priv->advance_scan_timeout, tmo * HZ / 1000);
+	return 0;
+}
+#endif
+
+static void xradio_remove_wps_p2p_ie(struct wsm_template_frame *frame)
+{
+	u8 *ies;
+	u32 ies_len;
+	u32 ie_len;
+	u32 p2p_ie_len = 0;
+	u32 wps_ie_len = 0;
+	scan_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	ies = &frame->skb->data[sizeof(struct ieee80211_hdr_3addr)];
+	ies_len = frame->skb->len - sizeof(struct ieee80211_hdr_3addr);
+	while (ies_len >= 6) {
+		ie_len = ies[1] + 2;
+		ies_len -= ie_len;
+		if ((ies[0] == WLAN_EID_VENDOR_SPECIFIC) &&
+			  (ies[2] == 0x00 && ies[3] == 0x50 &&
+			   ies[4] == 0xf2 && ies[5] == 0x04)) {
+			wps_ie_len = ie_len;
+			memmove(ies, ies + ie_len, ies_len);
+		} else if ((ies[0] == WLAN_EID_VENDOR_SPECIFIC) &&
+			   (ies[2] == 0x50 && ies[3] == 0x6f &&
+			    ies[4] == 0x9a && ies[5] == 0x09)) {
+			p2p_ie_len = ie_len;
+			memmove(ies, ies + ie_len, ies_len);
+		} else {
+			ies += ie_len;
+		}
+	}
+
+	if (p2p_ie_len || wps_ie_len) {
+		skb_trim(frame->skb, frame->skb->len - (p2p_ie_len + wps_ie_len));
+	}
+}
+
+#ifdef CONFIG_XRADIO_TESTMODE
+static int xradio_disable_filtering(struct xradio_vif *priv)
+{
+	int ret = 0;
+	bool bssid_filtering = 0;
+	struct wsm_rx_filter rx_filter;
+	struct wsm_beacon_filter_control bf_control;
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	scan_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	/* RX Filter Disable */
+	rx_filter.promiscuous = 0;
+	rx_filter.bssid = 0;
+	rx_filter.fcs = 0;
+	ret = wsm_set_rx_filter(hw_priv, &rx_filter, priv->if_id);
+
+	/* Beacon Filter Disable */
+	bf_control.enabled = 0;
+	bf_control.bcn_count = 1;
+	if (!ret)
+		ret = wsm_beacon_filter_control(hw_priv, &bf_control, priv->if_id);
+
+	/* BSSID Filter Disable */
+	if (!ret)
+		ret = wsm_set_bssid_filtering(hw_priv, bssid_filtering, priv->if_id);
+
+	return ret;
+}
+#endif
+
+static int xradio_scan_start(struct xradio_vif *priv, struct wsm_scan *scan)
+{
+	int ret, i;
+#ifdef FPGA_SETUP
+	int tmo = SCAN_DEFAULT_TIMEOUT;
+#else
+	int tmo = SCAN_DEFAULT_TIMEOUT;
+#endif
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	scan_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	for (i = 0; i < scan->numOfChannels; ++i)
+		tmo += scan->ch[i].maxChannelTime + 10;
+
+	atomic_set(&hw_priv->scan.in_progress, 1);
+	atomic_set(&hw_priv->recent_scan, 1);
+#ifdef CONFIG_PM
+	xradio_pm_stay_awake(&hw_priv->pm_state, tmo * HZ / 1000);
+#endif
+	schedule_delayed_work(&hw_priv->scan.timeout, tmo * HZ / 1000);
+#ifdef SCAN_FAILED_WORKAROUND_OF_FW_EXCEPTION
+	hw_priv->scan.scan_failed_timestamp = jiffies;
+#endif
+#ifdef P2P_MULTIVIF
+	ret = wsm_scan(hw_priv, scan, priv->if_id ? 1 : 0);
+#else
+	ret = wsm_scan(hw_priv, scan, priv->if_id);
+#endif
+	if (unlikely(ret)) {
+		scan_printk(XRADIO_DBG_WARN, "%s, wsm_scan failed!\n", __func__);
+		atomic_set(&hw_priv->scan.in_progress, 0);
+		cancel_delayed_work(&hw_priv->scan.timeout);
+		xradio_scan_restart_delayed(priv);
+	}
+	return ret;
+}
+
+#ifdef ROAM_OFFLOAD
+static int xradio_sched_scan_start(struct xradio_vif *priv,
+					   struct wsm_scan *scan)
+{
+	int ret;
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	scan_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	ret = wsm_scan(hw_priv, scan, priv->if_id);
+	if (unlikely(ret)) {
+		atomic_set(&hw_priv->scan.in_progress, 0);
+		scan_printk(XRADIO_DBG_WARN, "%s, wsm_scan failed!\n", __func__);
+	}
+	return ret;
+}
+#endif /*ROAM_OFFLOAD*/
+
+int xradio_hw_scan(struct ieee80211_hw *hw,
+		   struct ieee80211_vif *vif,
+		   struct cfg80211_scan_request *req)
+{
+	struct xradio_common *hw_priv = hw->priv;
+	struct xradio_vif *priv = xrwl_get_vif_from_ieee80211(vif);
+	struct wsm_template_frame frame = {
+		.frame_type = WSM_FRAME_TYPE_PROBE_REQUEST,
+	};
+	int i;
+#ifdef CONFIG_XRADIO_TESTMODE
+	int ret = 0;
+	u16 advance_scan_req_channel;
+#endif
+	int suspend_lock_state;
+	scan_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	/* Scan when P2P_GO corrupt firmware MiniAP mode */
+	if (priv->join_status == XRADIO_JOIN_STATUS_AP) {
+		scan_printk(XRADIO_DBG_WARN, "%s, can't scan in AP mode!\n",
+			    __func__);
+		return -EOPNOTSUPP;
+	}
+
+#ifdef HW_RESTART
+	if (hw_priv->hw_restart) {
+		scan_printk(XRADIO_DBG_NIY, "Ignoring scan in hw reset!\n");
+		return -EBUSY;
+	}
+#endif
+
+	if (hw_priv->bh_error) {
+		scan_printk(XRADIO_DBG_WARN, "Ignoring scan bh error occur!\n");
+		return -EBUSY;
+	}
+
+	if (!atomic_read(&priv->enabled)) {
+		scan_printk(XRADIO_DBG_WARN, "Ignoring scan vif is not enable!\n");
+		return -EBUSY;
+	}
+
+	if (work_pending(&priv->offchannel_work) ||
+			(hw_priv->roc_if_id != -1)) {
+		scan_printk(XRADIO_DBG_WARN, "Offchannel work pending, "
+			    "ignoring scan work %d\n",  hw_priv->roc_if_id);
+		return -EBUSY;
+	}
+
+	if (req->n_ssids == 1 && !req->ssids[0].ssid_len)
+		req->n_ssids = 0;
+
+	scan_printk(XRADIO_DBG_NIY, "vif%d Scan request(%s-%dchs) for %d SSIDs.\n",
+		priv->if_id, (req->channels[0]->band == NL80211_BAND_2GHZ) ? "2.4G" : "5G",
+		req->n_channels, req->n_ssids);
+
+	if (xradio_is_bt_block(hw_priv)) {
+		scan_printk(XRADIO_DBG_WARN, "%s:BT is busy, Delay scan!\n", __func__);
+		return -EBUSY;
+	}
+
+	/*delay multiple ssids scan of vif0 for 3s when connnetting to a node*/
+	if (hw_priv->scan_delay_status[0] == XRADIO_SCAN_DELAY &&
+	    req->n_ssids == 0 && priv->if_id == 0) {
+		unsigned long timedelay = hw_priv->scan_delay_time[0] + SCAN_MAX_DELAY;
+		if (time_before(jiffies, timedelay)) {
+			scan_printk(XRADIO_DBG_NIY, "vif0 connectting, scan delay %ldms\n",
+				(long)(timedelay - jiffies)*1000/HZ);
+			return -EBUSY;
+		}
+		hw_priv->scan_delay_status[0] = XRADIO_SCAN_ALLOW;
+	}
+
+	if (req->n_ssids > hw->wiphy->max_scan_ssids) {
+		scan_printk(XRADIO_DBG_ERROR, "%s: ssids is too much(%d)\n",
+			__func__, req->n_ssids);
+		return -EINVAL;
+	}
+
+	suspend_lock_state = atomic_cmpxchg(&hw_priv->suspend_lock_state,
+								XRADIO_SUSPEND_LOCK_IDEL, XRADIO_SUSPEND_LOCK_OTHERS);
+	if (suspend_lock_state == XRADIO_SUSPEND_LOCK_SUSPEND) {
+		scan_printk(XRADIO_DBG_WARN,
+			   "%s:refuse because of suspend\n", __func__);
+		return -EBUSY;
+	}
+
+	frame.skb = mac80211_probereq_get(hw, vif, NULL, 0, req->ie, req->ie_len);
+	if (!frame.skb) {
+		scan_printk(XRADIO_DBG_ERROR, "%s: mac80211_probereq_get failed!\n",
+			__func__);
+		atomic_set(&hw_priv->suspend_lock_state, XRADIO_SUSPEND_LOCK_IDEL);
+		return -ENOMEM;
+	}
+
+#ifdef ROAM_OFFLOAD
+	if (priv->join_status != XRADIO_JOIN_STATUS_STA) {
+		if (req->channels[0]->band == NL80211_BAND_2GHZ)
+			hw_priv->num_scanchannels = 0;
+		else
+			hw_priv->num_scanchannels = hw_priv->num_2g_channels;
+
+		for (i = 0; i < req->n_channels; i++) {
+			hw_priv->scan_channels[hw_priv->num_scanchannels + i].number = \
+				req->channels[i]->hw_value;
+			if (req->channels[i]->flags & IEEE80211_CHAN_PASSIVE_SCAN) {
+				hw_priv->scan_channels[hw_priv->num_scanchannels \
+							+ i].minChannelTime = 50;
+				hw_priv->scan_channels[hw_priv->num_scanchannels \
+							+ i].maxChannelTime = 110;
+			} else {
+				hw_priv->scan_channels[hw_priv->num_scanchannels \
+						       + i].minChannelTime = 10;
+				hw_priv->scan_channels[hw_priv->num_scanchannels \
+						       + i].maxChannelTime = 40;
+				hw_priv->scan_channels[hw_priv->num_scanchannels \
+						       + i].number |= \
+					XRADIO_SCAN_TYPE_ACTIVE;
+			}
+			hw_priv->scan_channels[hw_priv->num_scanchannels \
+					       + i].txPowerLevel = \
+					       req->channels[i]->max_power;
+			if (req->channels[0]->band == NL80211_BAND_5GHZ)
+				hw_priv->scan_channels[hw_priv->num_scanchannels \
+						       + i].number |= XRADIO_SCAN_BAND_5G;
+		}
+		if (req->channels[0]->band == NL80211_BAND_2GHZ)
+			hw_priv->num_2g_channels = req->n_channels;
+		else
+			hw_priv->num_5g_channels = req->n_channels;
+	}
+	hw_priv->num_scanchannels = hw_priv->num_2g_channels + \
+				    hw_priv->num_5g_channels;
+#endif /*ROAM_OFFLOAD*/
+
+	/* will be unlocked in xradio_scan_work() */
+	down(&hw_priv->scan.lock);
+	down(&hw_priv->conf_lock);
+	atomic_set(&hw_priv->suspend_lock_state, XRADIO_SUSPEND_LOCK_IDEL);
+
+#ifdef CONFIG_XRADIO_TESTMODE
+	/* Active Scan - Serving Channel Request Handling */
+	advance_scan_req_channel = req->channels[0]->hw_value;
+	if (hw_priv->enable_advance_scan &&
+	    (hw_priv->advanceScanElems.scanMode ==
+	     XRADIO_SCAN_MEASUREMENT_ACTIVE) &&
+	    (priv->join_status == XRADIO_JOIN_STATUS_STA) &&
+	    (hw_priv->channel->hw_value == advance_scan_req_channel)) {
+		SYS_BUG(hw_priv->scan.req);
+		/* wsm_lock_tx(hw_priv); */
+		wsm_vif_lock_tx(priv);
+		hw_priv->scan.if_id = priv->if_id;
+		/* Disable Power Save */
+		if (priv->powersave_mode.pmMode & WSM_PSM_PS) {
+			struct wsm_set_pm pm = priv->powersave_mode;
+			pm.pmMode = WSM_PSM_ACTIVE;
+			wsm_set_pm(hw_priv, &pm, priv->if_id);
+		}
+		/* Disable Rx Beacon and Bssid filter */
+		ret = xradio_disable_filtering(priv);
+		if (ret)
+			scan_printk(XRADIO_DBG_ERROR,
+				    "%s: Disable BSSID or Beacon filtering "
+				    "failed: %d.\n", __func__, ret);
+		wsm_unlock_tx(hw_priv);
+		up(&hw_priv->conf_lock);
+		/* Transmit Probe Request with Broadcast SSID */
+		xradio_tx(hw, frame.skb);
+		/* Start Advance Scan Timer */
+		xradio_advance_scan_start(hw_priv);
+	} else {
+#endif /* CONFIG_XRADIO_TESTMODE */
+
+		if (frame.skb) {
+			int ret = 0;
+			if (priv->if_id == 0)
+				xradio_remove_wps_p2p_ie(&frame);
+#ifdef P2P_MULTIVIF
+			ret = wsm_set_template_frame(hw_priv, &frame, priv->if_id ? 1 : 0);
+#else
+			ret = wsm_set_template_frame(hw_priv, &frame, priv->if_id);
+#endif
+			if (ret) {
+				up(&hw_priv->conf_lock);
+				up(&hw_priv->scan.lock);
+				dev_kfree_skb(frame.skb);
+				scan_printk(XRADIO_DBG_ERROR,
+					    "%s: wsm_set_template_frame failed: %d.\n",
+					     __func__, ret);
+				return ret;
+			}
+		}
+
+		wsm_vif_lock_tx(priv);
+
+		SYS_BUG(hw_priv->scan.req);
+		hw_priv->scan.req     = req;
+		hw_priv->scan.n_ssids = 0;
+		hw_priv->scan.status  = 0;
+		hw_priv->scan.begin   = &req->channels[0];
+		hw_priv->scan.curr    = hw_priv->scan.begin;
+		hw_priv->scan.end     = &req->channels[req->n_channels];
+		hw_priv->scan.output_power = hw_priv->output_power;
+		hw_priv->scan.if_id = priv->if_id;
+		/* TODO:COMBO: Populate BIT4 in scanflags to decide on which MAC
+		 * address the SCAN request will be sent */
+
+		for (i = 0; i < req->n_ssids; ++i) {
+			struct wsm_ssid *dst = &hw_priv->scan.ssids[hw_priv->scan.n_ssids];
+			SYS_BUG(req->ssids[i].ssid_len > sizeof(dst->ssid));
+			memcpy(&dst->ssid[0], req->ssids[i].ssid, sizeof(dst->ssid));
+			dst->length = req->ssids[i].ssid_len;
+			++hw_priv->scan.n_ssids;
+		}
+
+		up(&hw_priv->conf_lock);
+
+		if (frame.skb)
+			dev_kfree_skb(frame.skb);
+		queue_work(hw_priv->workqueue, &hw_priv->scan.work);
+
+#ifdef CONFIG_XRADIO_TESTMODE
+	}
+#endif
+
+	return 0;
+}
+
+#ifdef ROAM_OFFLOAD
+int xradio_hw_sched_scan_start(struct ieee80211_hw *hw,
+		   struct ieee80211_vif *vif,
+		   struct cfg80211_sched_scan_request *req,
+		   struct ieee80211_sched_scan_ies *ies)
+{
+	struct xradio_common *hw_priv = hw->priv;
+	struct xradio_vif *priv = xrwl_get_vif_from_ieee80211(vif);
+	struct wsm_template_frame frame = {
+		.frame_type = WSM_FRAME_TYPE_PROBE_REQUEST,
+	};
+	int i;
+	scan_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	scan_printk(XRADIO_DBG_WARN, "Scheduled scan request-->.\n");
+	if (!priv->vif)
+		return -EINVAL;
+
+	/* Scan when P2P_GO corrupt firmware MiniAP mode */
+	if (priv->join_status == XRADIO_JOIN_STATUS_AP) {
+		scan_printk(XRADIO_DBG_WARN, "%s, can't scan in AP mode!\n", __func__);
+		return -EOPNOTSUPP;
+	}
+
+#ifdef HW_RESTART
+	if (hw_priv->hw_restart) {
+		scan_printk(XRADIO_DBG_NIY, "Ignoring scan in hw reset!\n");
+		return -EBUSY;
+	}
+#endif
+
+	if (hw_priv->bh_error) {
+		scan_printk(XRADIO_DBG_WARN, "Ignoring scan bh error occur!\n");
+		return -EBUSY;
+	}
+
+	if (!atomic_read(&priv->enabled)) {
+		scan_printk(XRADIO_DBG_WARN, "Ignoring scan vif is not enable!\n");
+		return -EBUSY;
+	}
+
+
+	scan_printk(XRADIO_DBG_WARN,
+		    "Scheduled scan: n_ssids %d, ssid[0].len = %d\n",
+		    req->n_ssids, req->ssids[0].ssid_len);
+	if (req->n_ssids == 1 && !req->ssids[0].ssid_len)
+		req->n_ssids = 0;
+
+	scan_printk(XRADIO_DBG_NIY, "[SCAN] Scan request for %d SSIDs.\n",
+		req->n_ssids);
+
+	if (req->n_ssids > hw->wiphy->max_scan_ssids) {
+		scan_printk(XRADIO_DBG_ERROR, "%s: ssids is too much(%d)\n",
+			__func__, req->n_ssids);
+		return -EINVAL;
+	}
+
+	frame.skb = mac80211_probereq_get(hw, priv->vif, NULL, 0,
+			ies->ie[0], ies->len[0]);
+	if (!frame.skb) {
+		scan_printk(XRADIO_DBG_ERROR, "%s: mac80211_probereq_get failed!\n",
+			__func__);
+		return -ENOMEM;
+	}
+
+	/* will be unlocked in xradio_scan_work() */
+	down(&hw_priv->scan.lock);
+	down(&hw_priv->conf_lock);
+	if (frame.skb) {
+		int ret;
+		if (priv->if_id == 0)
+			xradio_remove_wps_p2p_ie(&frame);
+		ret = wsm_set_template_frame(hw_priv, &frame, priv->if_id);
+		if (0 == ret) {
+			/* Host want to be the probe responder. */
+			ret = wsm_set_probe_responder(priv, true);
+		}
+		if (ret) {
+			up(&hw_priv->conf_lock);
+			up(&hw_priv->scan.lock);
+			dev_kfree_skb(frame.skb);
+			scan_printk(XRADIO_DBG_ERROR,
+				    "%s: wsm_set_probe_responder failed: %d.\n",
+					__func__, ret);
+			return ret;
+		}
+	}
+
+	wsm_lock_tx(hw_priv);
+	SYS_BUG(hw_priv->scan.req);
+	hw_priv->scan.sched_req = req;
+	hw_priv->scan.n_ssids = 0;
+	hw_priv->scan.status = 0;
+	hw_priv->scan.begin = &req->channels[0];
+	hw_priv->scan.curr = hw_priv->scan.begin;
+	hw_priv->scan.end = &req->channels[req->n_channels];
+	hw_priv->scan.output_power = hw_priv->output_power;
+
+	for (i = 0; i < req->n_ssids; ++i) {
+		u8 j;
+		struct wsm_ssid *dst = &hw_priv->scan.ssids[hw_priv->scan.n_ssids];
+		SYS_BUG(req->ssids[i].ssid_len > sizeof(dst->ssid));
+		memcpy(&dst->ssid[0], req->ssids[i].ssid, sizeof(dst->ssid));
+		dst->length = req->ssids[i].ssid_len;
+		++hw_priv->scan.n_ssids;
+		scan_printk(XRADIO_DBG_NIY, "SSID %d\n", i);
+		for (j = 0; j < req->ssids[i].ssid_len; j++)
+			scan_printk(XRADIO_DBG_NIY, "0x%x\n", req->ssids[i].ssid[j]);
+	}
+	up(&hw_priv->conf_lock);
+
+	if (frame.skb)
+		dev_kfree_skb(frame.skb);
+	queue_work(hw_priv->workqueue, &hw_priv->scan.swork);
+	scan_printk(XRADIO_DBG_NIY, "<-- Scheduled scan request.\n");
+	return 0;
+}
+#endif /*ROAM_OFFLOAD*/
+
+void xradio_scan_work(struct work_struct *work)
+{
+	struct xradio_common *hw_priv = container_of(work,
+						struct xradio_common,
+						scan.work);
+	struct xradio_vif *priv;
+	struct ieee80211_channel **it;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
+	struct cfg80211_scan_info info;
+#endif
+	struct wsm_scan scan = {
+
+#ifndef SUPPORT_HT40
+
+		.scanType = WSM_SCAN_TYPE_FOREGROUND,
+
+#endif
+
+		.scanFlags = 0, /* TODO:COMBO */
+		/*.scanFlags = WSM_SCAN_FLAG_SPLIT_METHOD, */
+	};
+	bool first_run;
+	int i;
+	const u32 ProbeRequestTime  = 2;
+	const u32 ChannelRemainTime = 15;
+	u32 maxChannelTime;
+#ifdef CONFIG_XRADIO_TESTMODE
+	int ret = 0;
+	u16 advance_scan_req_channel = hw_priv->scan.begin[0]->hw_value;
+#endif
+	scan_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	priv = __xrwl_hwpriv_to_vifpriv(hw_priv, hw_priv->scan.if_id);
+
+	/*TODO: COMBO: introduce locking so vif is not removed in meanwhile */
+	if (!priv) {
+		scan_printk(XRADIO_DBG_WARN, "interface removed, "
+			"ignoring scan work\n");
+		return;
+	}
+
+#ifdef SUPPORT_HT40
+
+	SET_SCAN_TYPE(&scan.scanFlags, WSM_SCAN_TYPE_FOREGROUND);
+
+#endif
+
+#ifdef SUPPORT_HT40
+
+	if (priv->if_id)
+		SET_SCAN_FLAG(&scan.scanFlags, WSM_FLAG_MAC_INSTANCE_1);
+	else
+		CLR_SCAN_FLAG(&scan.scanFlags, WSM_FLAG_MAC_INSTANCE_1);
+
+#else
+
+	if (priv->if_id)
+		scan.scanFlags |= WSM_FLAG_MAC_INSTANCE_1;
+	else
+		scan.scanFlags &= ~WSM_FLAG_MAC_INSTANCE_1;
+
+#endif
+
+	/* No need to set WSM_SCAN_FLAG_FORCE_BACKGROUND in BSS_LOSS work.*/
+	/*
+	xradio_for_each_vif(hw_priv, vif, i) {
+		if (!vif)
+			continue;
+		if (vif->bss_loss_status > XRADIO_BSS_LOSS_NONE)
+			scan.scanFlags |= WSM_SCAN_FLAG_FORCE_BACKGROUND;
+	} */
+
+	first_run = (hw_priv->scan.begin == hw_priv->scan.curr &&
+			hw_priv->scan.begin != hw_priv->scan.end);
+	if (first_run) {
+		/* Firmware gets crazy if scan request is sent
+		 * when STA is joined but not yet associated.
+		 * Force unjoin in this case. */
+		if (cancel_delayed_work_sync(&priv->join_timeout) > 0)
+			xradio_join_timeout(&priv->join_timeout.work);
+	}
+
+	down(&hw_priv->conf_lock);
+	if (first_run) {
+
+#ifdef CONFIG_XRADIO_TESTMODE
+		/* Passive Scan - Serving Channel Request Handling */
+		if (hw_priv->enable_advance_scan &&
+		   (hw_priv->advanceScanElems.scanMode ==
+		    XRADIO_SCAN_MEASUREMENT_PASSIVE) &&
+		   (priv->join_status == XRADIO_JOIN_STATUS_STA) &&
+		   (hw_priv->channel->hw_value == advance_scan_req_channel)) {
+			/* If Advance Scan Request is for Serving Channel Device
+			 * should be Active and Filtering Should be Disable */
+			if (priv->powersave_mode.pmMode & WSM_PSM_PS) {
+				struct wsm_set_pm pm = priv->powersave_mode;
+				pm.pmMode = WSM_PSM_ACTIVE;
+				wsm_set_pm(hw_priv, &pm, priv->if_id);
+			}
+			/* Disable Rx Beacon and Bssid filter */
+			ret = xradio_disable_filtering(priv);
+			if (ret)
+				scan_printk(XRADIO_DBG_ERROR, "%s: Disable BSSID or Beacon"
+					    "filtering failed: %d.\n", __func__, ret);
+		} else if (hw_priv->enable_advance_scan  &&
+			   (hw_priv->advanceScanElems.scanMode ==
+			    XRADIO_SCAN_MEASUREMENT_PASSIVE) &&
+			   (priv->join_status == XRADIO_JOIN_STATUS_STA)) {
+			if (priv->join_status == XRADIO_JOIN_STATUS_STA &&
+			    !(priv->powersave_mode.pmMode & WSM_PSM_PS)) {
+				struct wsm_set_pm pm = priv->powersave_mode;
+				pm.pmMode = WSM_PSM_PS;
+				xradio_set_pm(priv, &pm);
+			}
+		} else {
+#endif
+
+#if 0
+			if (priv->join_status == XRADIO_JOIN_STATUS_STA &&
+			    !(priv->powersave_mode.pmMode & WSM_PSM_PS)) {
+				struct wsm_set_pm pm = priv->powersave_mode;
+				pm.pmMode = WSM_PSM_PS;
+				xradio_set_pm(priv, &pm);
+			} else
+#endif
+			if (priv->join_status == XRADIO_JOIN_STATUS_MONITOR) {
+				/* FW bug: driver has to restart p2p-dev mode
+				 * after scan */
+				xradio_disable_listening(priv);
+			}
+#ifdef CONFIG_XRADIO_TESTMODE
+		}
+#endif
+	}
+
+	if (!hw_priv->scan.req || (hw_priv->scan.curr == hw_priv->scan.end)) {
+
+#ifdef CONFIG_XRADIO_TESTMODE
+		if (hw_priv->enable_advance_scan &&
+		    (hw_priv->advanceScanElems.scanMode ==
+		     XRADIO_SCAN_MEASUREMENT_PASSIVE) &&
+		    (priv->join_status == XRADIO_JOIN_STATUS_STA) &&
+		    (hw_priv->channel->hw_value == advance_scan_req_channel)) {
+			/* WSM Lock should be held here for WSM APIs */
+			wsm_vif_lock_tx(priv);
+
+			/* wsm_lock_tx(priv); */
+			/* Once Duration is Over, enable filtering
+			 * and Revert Back Power Save */
+			if (priv->powersave_mode.pmMode & WSM_PSM_PS)
+				wsm_set_pm(hw_priv, &priv->powersave_mode, priv->if_id);
+			xradio_update_filtering(priv);
+		} else if (!hw_priv->enable_advance_scan) {
+#endif
+			if (hw_priv->scan.output_power != hw_priv->output_power) {
+			/* TODO:COMBO: Change when mac80211 implementation
+			 * is available for output power also */
+#ifdef P2P_MULTIVIF
+				WARN_ON(wsm_set_output_power(hw_priv,
+							     hw_priv->output_power * 10,
+							     priv->if_id ? 1 : 0));
+#else
+				WARN_ON(wsm_set_output_power(hw_priv,
+							     hw_priv->output_power * 10,
+							     priv->if_id));
+#endif
+			}
+#ifdef CONFIG_XRADIO_TESTMODE
+		}
+#endif
+
+#if 0
+		if (priv->join_status == XRADIO_JOIN_STATUS_STA &&
+		    !(priv->powersave_mode.pmMode & WSM_PSM_PS))
+			xradio_set_pm(priv, &priv->powersave_mode);
+#endif
+
+		if (hw_priv->scan.status < 0)
+			scan_printk(XRADIO_DBG_ERROR, "Scan failed (%d).\n",
+				    hw_priv->scan.status);
+		else if (hw_priv->scan.req)
+			scan_printk(XRADIO_DBG_NIY, "Scan completed.\n");
+		else
+			scan_printk(XRADIO_DBG_NIY, "Scan canceled.\n");
+
+		hw_priv->scan.req = NULL;
+		xradio_scan_restart_delayed(priv);
+#ifdef CONFIG_XRADIO_TESTMODE
+		hw_priv->enable_advance_scan = false;
+#endif /* CONFIG_XRADIO_TESTMODE */
+		wsm_unlock_tx(hw_priv);
+		up(&hw_priv->conf_lock);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
+		memset(&info, 0, sizeof(info));
+		info.aborted = hw_priv->scan.status ? 1 : 0;
+		mac80211_scan_completed(hw_priv->hw, &info);
+#else
+		mac80211_scan_completed(hw_priv->hw, hw_priv->scan.status ? 1 : 0);
+#endif
+		up(&hw_priv->scan.lock);
+#ifdef SCAN_FAILED_WORKAROUND_OF_FW_EXCEPTION
+		/*Timeout waiting for scan complete notification all the time,
+		 * then driver restarts.*/
+		if (hw_priv->scan.scan_failed_cnt >= 5) {
+			scan_printk(XRADIO_DBG_ERROR, "%s:Too many scan timeout=%d",
+					__func__, hw_priv->scan.scan_failed_cnt);
+			hw_priv->bh_error = 1 ;
+			hw_priv->scan.scan_failed_cnt = 0;
+		}
+#endif
+		return;
+
+	} else {
+		struct ieee80211_channel *first = *hw_priv->scan.curr;
+		for (it = hw_priv->scan.curr + 1, i = 1;
+		     it != hw_priv->scan.end && i < WSM_SCAN_MAX_NUM_OF_CHANNELS;
+		     ++it, ++i) {
+			if ((*it)->band != first->band)
+				break;
+			if (((*it)->flags ^ first->flags) & (IEEE80211_CHAN_NO_IR |
+						IEEE80211_CHAN_RADAR))
+				break;
+			if (!(first->flags & (IEEE80211_CHAN_NO_IR |
+						IEEE80211_CHAN_RADAR)) &&
+			    (*it)->max_power != first->max_power)
+				break;
+		}
+		scan.band = first->band;
+
+#ifdef SUPPORT_HT40
+
+		if (hw_priv->scan.req->no_cck)
+			scan.TransmitRateEntry =
+				((RATE_MODEM_LEGACY  << MODEMTYPE_SHIFT)
+				| (RATE_BANDWIDTH_20M << BANDWIDTH_SHIFT)
+				| (WSM_TRANSMIT_RATE_6 << 4));
+		else
+			scan.TransmitRateEntry =
+				((RATE_MODEM_LEGACY  << MODEMTYPE_SHIFT)
+				| (RATE_BANDWIDTH_20M << BANDWIDTH_SHIFT)
+				| (WSM_TRANSMIT_RATE_1 << 4));
+
+#else
+
+		if (hw_priv->scan.req->no_cck)
+			scan.maxTransmitRate = WSM_TRANSMIT_RATE_6;
+		else
+			scan.maxTransmitRate = WSM_TRANSMIT_RATE_1;
+
+#endif
+
+#ifdef CONFIG_XRADIO_TESTMODE
+		if (hw_priv->enable_advance_scan) {
+			if (hw_priv->advanceScanElems.scanMode ==
+				XRADIO_SCAN_MEASUREMENT_PASSIVE)
+				scan.numOfProbeRequests = 0;
+			else
+				scan.numOfProbeRequests = 1;
+		} else {
+#endif
+			/* TODO: Is it optimal? */
+			scan.numOfProbeRequests =
+			    (first->flags & (IEEE80211_CHAN_NO_IR |
+						IEEE80211_CHAN_RADAR)) ? 0 : 4;
+#ifdef CONFIG_XRADIO_TESTMODE
+		}
+#endif /* CONFIG_XRADIO_TESTMODE */
+
+		scan.numOfSSIDs = hw_priv->scan.n_ssids;
+		scan.ssids = &hw_priv->scan.ssids[0];
+		scan.numOfChannels = it - hw_priv->scan.curr;
+		/* TODO: Is it optimal? */
+		scan.probeDelay = 200;
+
+		scan_printk(XRADIO_DBG_NIY, "Scan split ch(%d).\n", scan.numOfChannels);
+		/* It is not stated in WSM specification, however
+		 * FW team says that driver may not use FG scan
+		 * when joined. */
+		if (priv->join_status == XRADIO_JOIN_STATUS_STA) {
+
+#ifdef SUPPORT_HT40
+
+			SET_SCAN_TYPE(&scan.scanFlags, WSM_SCAN_TYPE_BACKGROUND);
+			SET_SCAN_FLAG(&scan.scanFlags, WSM_SCAN_FLAG_FORCE_BACKGROUND);
+
+#else
+
+			scan.scanType = WSM_SCAN_TYPE_BACKGROUND;
+			scan.scanFlags = WSM_SCAN_FLAG_FORCE_BACKGROUND;
+
+#endif
+		}
+		scan.ch = (struct wsm_scan_ch *)xr_kzalloc(
+				sizeof(struct wsm_scan_ch) * (it - hw_priv->scan.curr), false);
+		if (!scan.ch) {
+			hw_priv->scan.status = -ENOMEM;
+			scan_printk(XRADIO_DBG_ERROR, "xr_kzalloc wsm_scan_ch failed.\n");
+			goto fail;
+		}
+		maxChannelTime = (scan.numOfSSIDs * scan.numOfProbeRequests *
+				  ProbeRequestTime) + ChannelRemainTime;
+		maxChannelTime = (maxChannelTime < 100) ? 100 : maxChannelTime;
+		for (i = 0; i < scan.numOfChannels; ++i) {
+			scan.ch[i].number = hw_priv->scan.curr[i]->hw_value;
+
+#ifdef CONFIG_XRADIO_TESTMODE
+			if (hw_priv->enable_advance_scan) {
+				scan.ch[i].minChannelTime = hw_priv->advanceScanElems.duration;
+				scan.ch[i].maxChannelTime = hw_priv->advanceScanElems.duration;
+			} else {
+#endif
+				if (hw_priv->scan.curr[i]->flags &
+					(IEEE80211_CHAN_NO_IR |
+						IEEE80211_CHAN_RADAR)) {
+					scan.ch[i].minChannelTime = 50;
+					scan.ch[i].maxChannelTime = 110;
+				} else {
+					scan.ch[i].minChannelTime = 50;
+					scan.ch[i].maxChannelTime = maxChannelTime;
+				}
+
+#ifdef CONFIG_XRADIO_TESTMODE
+			}
+#endif
+		}
+
+#ifdef CONFIG_XRADIO_TESTMODE
+		if (!hw_priv->enable_advance_scan) {
+#endif
+			if (!(first->flags & (IEEE80211_CHAN_NO_IR |
+						IEEE80211_CHAN_RADAR)) &&
+			    hw_priv->scan.output_power != first->max_power) {
+			    hw_priv->scan.output_power = first->max_power;
+				/* TODO:COMBO: Change after mac80211 implementation
+				* complete */
+#ifdef P2P_MULTIVIF
+				WARN_ON(wsm_set_output_power(hw_priv,
+							     hw_priv->scan.output_power * 10,
+							     priv->if_id ? 1 : 0));
+#else
+				WARN_ON(wsm_set_output_power(hw_priv,
+							     hw_priv->scan.output_power * 10,
+							     priv->if_id));
+#endif
+			}
+#ifdef CONFIG_XRADIO_TESTMODE
+		}
+#endif
+
+#ifdef CONFIG_XRADIO_TESTMODE
+		if (hw_priv->enable_advance_scan &&
+			(hw_priv->advanceScanElems.scanMode ==
+				XRADIO_SCAN_MEASUREMENT_PASSIVE) &&
+			(priv->join_status == XRADIO_JOIN_STATUS_STA) &&
+			(hw_priv->channel->hw_value == advance_scan_req_channel)) {
+				/* Start Advance Scan Timer */
+				hw_priv->scan.status = xradio_advance_scan_start(hw_priv);
+				wsm_unlock_tx(hw_priv);
+		} else
+#endif
+			down(&hw_priv->scan.status_lock);
+			hw_priv->scan.status = xradio_scan_start(priv, &scan);
+
+		kfree(scan.ch);
+		if (WARN_ON(hw_priv->scan.status)) {
+			scan_printk(XRADIO_DBG_ERROR, "scan failed, status=%d.\n",
+				    hw_priv->scan.status);
+			up(&hw_priv->scan.status_lock);
+			goto fail;
+		}
+		up(&hw_priv->scan.status_lock);
+		hw_priv->scan.curr = it;
+	}
+	up(&hw_priv->conf_lock);
+	return;
+
+fail:
+	hw_priv->scan.curr = hw_priv->scan.end;
+	up(&hw_priv->conf_lock);
+	if (queue_work(hw_priv->workqueue, &hw_priv->scan.work) <= 0)
+		scan_printk(XRADIO_DBG_ERROR, "%s queue scan work failed\n", __func__);
+	return;
+}
+
+#ifdef ROAM_OFFLOAD
+void xradio_sched_scan_work(struct work_struct *work)
+{
+	struct xradio_common *hw_priv = container_of(work, struct xradio_common,
+		scan.swork);
+	struct wsm_scan scan;
+	struct wsm_ssid scan_ssid;
+	int i;
+	struct xradio_vif *priv = NULL;
+	scan_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	priv = xrwl_hwpriv_to_vifpriv(hw_priv, hw_priv->scan.if_id);
+	if (unlikely(!priv)) {
+		WARN_ON(1);
+		return;
+	}
+
+	spin_unlock(&priv->vif_lock);
+	/* Firmware gets crazy if scan request is sent
+	 * when STA is joined but not yet associated.
+	 * Force unjoin in this case. */
+	if (cancel_delayed_work_sync(&priv->join_timeout) > 0) {
+		xradio_join_timeout(&priv->join_timeout.work);
+	}
+	down(&hw_priv->conf_lock);
+	hw_priv->auto_scanning = 1;
+	scan.band = 0;
+
+#ifdef SUPPORT_HT40
+
+	if (priv->join_status == XRADIO_JOIN_STATUS_STA) /* auto background */
+		SET_SCAN_TYPE(&scan.scanFlags, WSM_SCAN_TYPE_AUTOBACKGROUND);
+	else /* auto foreground */
+		SET_SCAN_TYPE(&scan.scanFlags, WSM_SCAN_TYPE_AUTOFOREGROUND);
+
+	/* bit 0 set => forced background scan */
+	CLR_SCAN_FLAG(&scan.scanFlags, SCANFLAG_MASK);
+	SET_SCAN_FLAG(&scan.scanFlags, WSM_SCAN_FLAG_FORCE_BACKGROUND);
+
+#else
+
+	if (priv->join_status == XRADIO_JOIN_STATUS_STA)
+		scan.scanType = 3; /* auto background */
+	else
+		scan.scanType = 2; /* auto foreground */
+
+	scan.scanFlags = 0x01; /* bit 0 set => forced background scan */
+
+#endif
+
+#ifdef SUPPORT_HT40
+
+	scan.TransmitRateEntry = ((RATE_MODEM_LEGACY  << MODEMTYPE_SHIFT)
+				| (RATE_BANDWIDTH_20M << BANDWIDTH_SHIFT)
+				| (AG_RATE_INDEX << 4));
+
+#else
+
+	scan.maxTransmitRate = WSM_TRANSMIT_RATE_6;
+
+#endif
+
+	scan.autoScanInterval = (0xba << 24)|(30 * 1024); /* 30 seconds, -70 rssi */
+	scan.numOfProbeRequests = 1;
+	/*scan.numOfChannels = 11;*/
+	scan.numOfChannels = hw_priv->num_scanchannels;
+	scan.numOfSSIDs = 1;
+	scan.probeDelay = 100;
+	scan_ssid.length = priv->ssid_length;
+	memcpy(scan_ssid.ssid, priv->ssid, priv->ssid_length);
+	scan.ssids = &scan_ssid;
+
+	scan.ch = xr_kzalloc(sizeof(struct wsm_scan_ch[scan.numOfChannels]), false);
+	if (!scan.ch) {
+		scan_printk(XRADIO_DBG_ERROR, "xr_kzalloc wsm_scan_ch failed.\n");
+		hw_priv->scan.status = -ENOMEM;
+		goto fail;
+	}
+
+	for (i = 0; i < scan.numOfChannels; i++) {
+		scan.ch[i].number = hw_priv->scan_channels[i].number;
+		scan.ch[i].minChannelTime = hw_priv->scan_channels[i].minChannelTime;
+		scan.ch[i].maxChannelTime = hw_priv->scan_channels[i].maxChannelTime;
+		scan.ch[i].txPowerLevel = hw_priv->scan_channels[i].txPowerLevel;
+	}
+
+#if 0
+	for (i = 1; i <= scan.numOfChannels; i++) {
+		scan.ch[i-1].number = i;
+		scan.ch[i-1].minChannelTime = 10;
+		scan.ch[i-1].maxChannelTime = 40;
+	}
+#endif
+
+	hw_priv->scan.status = xradio_sched_scan_start(priv, &scan);
+	kfree(scan.ch);
+	if (hw_priv->scan.status) {
+		scan_printk(XRADIO_DBG_ERROR, "scan failed, status=%d.\n",
+				    hw_priv->scan.status);
+		goto fail;
+	}
+	up(&hw_priv->conf_lock);
+	return;
+
+fail:
+	up(&hw_priv->conf_lock);
+	queue_work(hw_priv->workqueue, &hw_priv->scan.swork);
+	return;
+}
+
+void xradio_hw_sched_scan_stop(struct xradio_common *hw_priv)
+{
+	struct xradio_vif *priv = NULL;
+	scan_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	priv = xrwl_hwpriv_to_vifpriv(hw_priv, hw_priv->scan.if_id);
+	if (unlikely(!priv))
+		return;
+
+	spin_unlock(&priv->vif_lock);
+	wsm_stop_scan(hw_priv, priv->if_id);
+
+	return;
+}
+#endif /*ROAM_OFFLOAD*/
+
+
+static void xradio_scan_restart_delayed(struct xradio_vif *priv)
+{
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	struct xradio_vif *tmp_vif = NULL;
+	int i = 0;
+	scan_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (priv->delayed_link_loss) {
+		int tmo = hw_priv->scan.direct_probe ? 0 : priv->cqm_beacon_loss_count;
+
+		priv->delayed_link_loss = 0;
+		/* Restart beacon loss timer and requeue
+		   BSS loss work. */
+		scan_printk(XRADIO_DBG_WARN, "[CQM] Requeue BSS loss in %d "
+			"beacons.\n", tmo);
+		cancel_delayed_work_sync(&priv->bss_loss_work);
+		queue_delayed_work(hw_priv->workqueue, &priv->bss_loss_work,
+			tmo * HZ / 10);
+
+	}
+
+	/* FW bug: driver has to restart p2p-dev mode after scan. */
+	if (priv->join_status == XRADIO_JOIN_STATUS_MONITOR) {
+		/*xradio_enable_listening(priv);*/
+		WARN_ON(1);
+		xradio_update_filtering(priv);
+		scan_printk(XRADIO_DBG_WARN, "driver has to restart "
+			"p2p-dev mode after scan");
+	}
+
+	for (i = 0; i < 2; i++) {
+		tmp_vif = __xrwl_hwpriv_to_vifpriv(hw_priv, i);
+		if (tmp_vif == NULL)
+			continue;
+		if (atomic_xchg(&tmp_vif->delayed_unjoin, 0)) {
+			if (queue_work(hw_priv->workqueue, &tmp_vif->unjoin_work) <= 0)
+				wsm_unlock_tx(hw_priv);
+		}
+	}
+}
+
+static void xradio_scan_complete(struct xradio_common *hw_priv, int if_id)
+{
+	struct xradio_vif *priv;
+	atomic_xchg(&hw_priv->recent_scan, 0);
+	scan_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (hw_priv->scan.direct_probe) {
+		down(&hw_priv->conf_lock);
+		priv = __xrwl_hwpriv_to_vifpriv(hw_priv, if_id);
+		if (priv) {
+			scan_printk(XRADIO_DBG_NIY, "Direct probe complete.\n");
+			xradio_scan_restart_delayed(priv);
+		} else {
+			scan_printk(XRADIO_DBG_WARN,
+				    "Direct probe complete without interface!\n");
+		}
+		up(&hw_priv->conf_lock);
+		hw_priv->scan.direct_probe = 0;
+		up(&hw_priv->scan.lock);
+		wsm_unlock_tx(hw_priv);
+	} else {
+		xradio_scan_work(&hw_priv->scan.work);
+	}
+}
+
+void xradio_scan_complete_cb(struct xradio_common *hw_priv,
+			struct wsm_scan_complete *arg)
+{
+	struct xradio_vif *priv = xrwl_hwpriv_to_vifpriv(hw_priv,
+					hw_priv->scan.if_id);
+	scan_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (unlikely(!priv))
+		return;
+
+#ifdef ROAM_OFFLOAD
+	if (hw_priv->auto_scanning)
+		schedule_delayed_work(&hw_priv->scan.timeout, 0);
+#endif /*ROAM_OFFLOAD*/
+
+	if (unlikely(priv->mode == NL80211_IFTYPE_UNSPECIFIED)) {
+		/* STA is stopped. */
+		spin_unlock(&priv->vif_lock);
+		scan_printk(XRADIO_DBG_WARN, "%s: priv->mode UNSPECIFIED.\n",
+			    __func__);
+		return;
+	}
+	spin_unlock(&priv->vif_lock);
+
+	down(&hw_priv->scan.status_lock);
+	if (hw_priv->scan.status == -ETIMEDOUT) {
+		up(&hw_priv->scan.status_lock);
+		scan_printk(XRADIO_DBG_WARN, "Scan timeout already occured. "
+			"Don't cancel work");
+	} else {
+		hw_priv->scan.status = 1;
+		up(&hw_priv->scan.status_lock);
+		if (cancel_delayed_work_sync(&hw_priv->scan.timeout) > 0)
+			schedule_delayed_work(&hw_priv->scan.timeout, 0);
+	}
+
+}
+
+void xradio_scan_timeout(struct work_struct *work)
+{
+	struct xradio_common *hw_priv =
+		container_of(work, struct xradio_common, scan.timeout.work);
+	scan_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (likely(atomic_xchg(&hw_priv->scan.in_progress, 0))) {
+		down(&hw_priv->scan.status_lock);
+		if (hw_priv->scan.status > 0) {
+			hw_priv->scan.status = 0;
+			up(&hw_priv->scan.status_lock);
+#ifdef SCAN_FAILED_WORKAROUND_OF_FW_EXCEPTION
+			hw_priv->scan.scan_failed_cnt = 0;
+#endif
+		} else if (!hw_priv->scan.status) {
+			scan_printk(XRADIO_DBG_WARN, "Timeout waiting for scan "
+				    "complete notification.\n");
+#ifdef SCAN_FAILED_WORKAROUND_OF_FW_EXCEPTION
+			if (time_after(jiffies, (hw_priv->scan.scan_failed_timestamp +
+						SCAN_DEFAULT_TIMEOUT*HZ/1000))) {
+				if (!hw_priv->BT_active)
+					hw_priv->scan.scan_failed_cnt += 1;
+				scan_printk(XRADIO_DBG_WARN, "%s:scan timeout cnt=%d",
+					__func__, hw_priv->scan.scan_failed_cnt);
+			}
+#endif
+			hw_priv->scan.status = -ETIMEDOUT;
+			up(&hw_priv->scan.status_lock);
+			hw_priv->scan.curr   = hw_priv->scan.end;
+			WARN_ON(wsm_stop_scan(hw_priv, hw_priv->scan.if_id ? 1 : 0));
+		}
+		xradio_scan_complete(hw_priv, hw_priv->scan.if_id);
+#ifdef ROAM_OFFLOAD
+	} else if (hw_priv->auto_scanning) {
+		hw_priv->auto_scanning = 0;
+		mac80211_sched_scan_results(hw_priv->hw);
+#endif /*ROAM_OFFLOAD*/
+	}
+}
+
+#ifdef CONFIG_XRADIO_TESTMODE
+void xradio_advance_scan_timeout(struct work_struct *work)
+{
+	struct xradio_common *hw_priv =
+		container_of(work, struct xradio_common, advance_scan_timeout.work);
+
+	struct xradio_vif *priv = xrwl_hwpriv_to_vifpriv(hw_priv,
+					hw_priv->scan.if_id);
+	scan_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (WARN_ON(!priv))
+		return;
+	spin_unlock(&priv->vif_lock);
+
+	hw_priv->scan.status = 0;
+	if (hw_priv->advanceScanElems.scanMode ==
+	    XRADIO_SCAN_MEASUREMENT_PASSIVE) {
+		/* Passive Scan on Serving Channel
+		 * Timer Expire */
+		xradio_scan_complete(hw_priv, hw_priv->scan.if_id);
+	} else {
+		/* Active Scan on Serving Channel
+		 * Timer Expire */
+		down(&hw_priv->conf_lock);
+		/*wsm_lock_tx(priv);*/
+		wsm_vif_lock_tx(priv);
+		/* Once Duration is Over, enable filtering
+		 * and Revert Back Power Save */
+		if ((priv->powersave_mode.pmMode & WSM_PSM_PS))
+			wsm_set_pm(hw_priv, &priv->powersave_mode, priv->if_id);
+		hw_priv->scan.req = NULL;
+		xradio_update_filtering(priv);
+		hw_priv->enable_advance_scan = false;
+		wsm_unlock_tx(hw_priv);
+		up(&hw_priv->conf_lock);
+		mac80211_scan_completed(hw_priv->hw,
+				 hw_priv->scan.status ? true : false);
+		up(&hw_priv->scan.lock);
+	}
+}
+#endif
+
+void xradio_probe_work(struct work_struct *work)
+{
+	struct xradio_common *hw_priv =
+		container_of(work, struct xradio_common, scan.probe_work.work);
+	struct xradio_vif *priv;
+	u8 queueId = xradio_queue_get_queue_id(hw_priv->pending_frame_id);
+	struct xradio_queue *queue = &hw_priv->tx_queue[queueId];
+	const struct xradio_txpriv *txpriv;
+	struct wsm_tx *wsm;
+	struct wsm_template_frame frame = {
+		.frame_type = WSM_FRAME_TYPE_PROBE_REQUEST,
+	};
+	struct wsm_ssid ssids[1] = {{
+		.length = 0,
+	} };
+	struct wsm_scan_ch ch[1] = {{
+		.minChannelTime = 50,
+		.maxChannelTime = 80,
+	} };
+	struct wsm_scan scan = {
+
+#ifdef SUPPORT_HT40
+
+		.scanFlags = 0,
+
+#else
+
+		.scanType = WSM_SCAN_TYPE_FOREGROUND,
+
+#endif
+
+		.numOfProbeRequests = 1,
+		.probeDelay = 0,
+		.numOfChannels = 1,
+		.ssids = ssids,
+		.ch = ch,
+	};
+	u8 *ies;
+	size_t ies_len;
+	int ret = 1;
+	scan_printk(XRADIO_DBG_NIY, "%s:Direct probe.\n", __func__);
+
+	SYS_BUG(queueId >= 4);
+	SYS_BUG(!hw_priv->channel);
+
+	down(&hw_priv->conf_lock);
+	if (unlikely(down_trylock(&hw_priv->scan.lock))) {
+		/* Scan is already in progress. Requeue self. */
+		schedule();
+		queue_delayed_work(hw_priv->workqueue, &hw_priv->scan.probe_work,
+				   HZ / 10);
+		up(&hw_priv->conf_lock);
+		return;
+	}
+
+	if (xradio_queue_get_skb(queue,	hw_priv->pending_frame_id,
+				     &frame.skb, &txpriv)) {
+		up(&hw_priv->scan.lock);
+		up(&hw_priv->conf_lock);
+		wsm_unlock_tx(hw_priv);
+		scan_printk(XRADIO_DBG_ERROR, "%s:xradio_queue_get_skb error!\n",
+			    __func__);
+		return;
+	}
+	priv = __xrwl_hwpriv_to_vifpriv(hw_priv, txpriv->if_id);
+	if (!priv) {
+		up(&hw_priv->scan.lock);
+		up(&hw_priv->conf_lock);
+		scan_printk(XRADIO_DBG_ERROR, "%s:priv error!\n", __func__);
+		return;
+	}
+	wsm = (struct wsm_tx *)frame.skb->data;
+
+#ifdef SUPPORT_HT40
+
+	scan.TransmitRateEntry = wsm->TxRateEntry;
+
+#else
+
+	scan.maxTransmitRate = wsm->maxTxRate;
+
+#endif
+
+	scan.band = (hw_priv->channel->band == NL80211_BAND_5GHZ) ?
+		     WSM_PHY_BAND_5G : WSM_PHY_BAND_2_4G;
+
+#ifdef SUPPORT_HT40
+
+	SET_SCAN_TYPE(&scan.scanFlags, WSM_SCAN_TYPE_FOREGROUND);
+	if (priv->join_status == XRADIO_JOIN_STATUS_STA) {
+		SET_SCAN_TYPE(&scan.scanFlags, WSM_SCAN_TYPE_BACKGROUND);
+		SET_SCAN_FLAG(&scan.scanFlags, WSM_SCAN_FLAG_FORCE_BACKGROUND);
+		if (priv->if_id)
+			SET_SCAN_FLAG(&scan.scanFlags, WSM_FLAG_MAC_INSTANCE_1);
+		else
+			CLR_SCAN_FLAG(&scan.scanFlags, WSM_FLAG_MAC_INSTANCE_1);
+	}
+
+#else
+
+	if (priv->join_status == XRADIO_JOIN_STATUS_STA) {
+		scan.scanType  = WSM_SCAN_TYPE_BACKGROUND;
+		scan.scanFlags = WSM_SCAN_FLAG_FORCE_BACKGROUND;
+		if (priv->if_id)
+			scan.scanFlags |= WSM_FLAG_MAC_INSTANCE_1;
+		else
+			scan.scanFlags &= ~WSM_FLAG_MAC_INSTANCE_1;
+	}
+
+#endif
+
+	/* No need to set WSM_SCAN_FLAG_FORCE_BACKGROUND in BSS_LOSS work.*/
+	 /*
+	xradio_for_each_vif(hw_priv, vif, i) {
+		if (!vif)
+			continue;
+		if (vif->bss_loss_status > XRADIO_BSS_LOSS_NONE)
+			scan.scanFlags |= WSM_SCAN_FLAG_FORCE_BACKGROUND;
+	} */
+
+	ch[0].number = hw_priv->channel->hw_value;
+	skb_pull(frame.skb, txpriv->offset);
+	ies = &frame.skb->data[sizeof(struct ieee80211_hdr_3addr)];
+	ies_len = frame.skb->len - sizeof(struct ieee80211_hdr_3addr);
+
+	if (ies_len) {
+		u8 *ssidie = (u8 *)cfg80211_find_ie(WLAN_EID_SSID, ies, ies_len);
+		if (ssidie && ssidie[1] && ssidie[1] <= sizeof(ssids[0].ssid)) {
+			u8 *nextie = &ssidie[2 + ssidie[1]];
+			/* Remove SSID from the IE list. It has to be provided
+			 * as a separate argument in xradio_scan_start call */
+
+			/* Store SSID localy */
+			ssids[0].length = ssidie[1];
+			memcpy(ssids[0].ssid, &ssidie[2], ssids[0].length);
+			scan.numOfSSIDs = 1;
+
+			/* Remove SSID from IE list */
+			ssidie[1] = 0;
+			memmove(&ssidie[2], nextie, &ies[ies_len] - nextie);
+			skb_trim(frame.skb, frame.skb->len - ssids[0].length);
+		}
+	}
+
+	if (priv->if_id == 0)
+		xradio_remove_wps_p2p_ie(&frame);
+
+	/* FW bug: driver has to restart p2p-dev mode after scan */
+	if (priv->join_status == XRADIO_JOIN_STATUS_MONITOR) {
+		WARN_ON(1);
+		/*xradio_disable_listening(priv);*/
+	}
+	ret = WARN_ON(wsm_set_template_frame(hw_priv, &frame,
+				priv->if_id));
+
+	hw_priv->scan.direct_probe = 1;
+	hw_priv->scan.if_id = priv->if_id;
+	if (!ret) {
+		wsm_flush_tx(hw_priv);
+		ret = WARN_ON(xradio_scan_start(priv, &scan));
+	}
+	up(&hw_priv->conf_lock);
+
+	skb_push(frame.skb, txpriv->offset);
+	if (!ret)
+		IEEE80211_SKB_CB(frame.skb)->flags |= IEEE80211_TX_STAT_ACK;
+#ifdef CONFIG_XRADIO_TESTMODE
+		SYS_BUG(xradio_queue_remove(hw_priv, queue,
+					    hw_priv->pending_frame_id));
+#else
+		SYS_BUG(xradio_queue_remove(queue, hw_priv->pending_frame_id));
+#endif
+
+	if (ret) {
+		hw_priv->scan.direct_probe = 0;
+		up(&hw_priv->scan.lock);
+		wsm_unlock_tx(hw_priv);
+	}
+
+	return;
+}
diff -Naurp a/drivers/net/wireless/xr829/wlan/scan.h b/drivers/net/wireless/xr829/wlan/scan.h
--- a/drivers/net/wireless/xr829/wlan/scan.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/scan.h	2022-08-27 01:22:42.970539923 +0300
@@ -0,0 +1,81 @@
+/*
+ * Scan interfaces for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#ifndef SCAN_H_INCLUDED
+#define SCAN_H_INCLUDED
+
+#include <linux/semaphore.h>
+#include "wsm.h"
+
+/* external */ struct sk_buff;
+/* external */ struct cfg80211_scan_request;
+/* external */ struct ieee80211_channel;
+/* external */ struct ieee80211_hw;
+/* external */ struct work_struct;
+
+#define SCAN_DEFAULT_TIMEOUT (5000)   /* default scan timeout(ms)*/
+#define SCAN_MAX_DELAY      (3*HZ)   /*3s delay for connect*/
+#define XRADIO_SCAN_ALLOW   0
+#define XRADIO_SCAN_DELAY   1
+
+struct xradio_scan {
+	struct semaphore lock;
+	struct work_struct work;
+#ifdef ROAM_OFFLOAD
+	struct work_struct swork; /* scheduled scan work */
+	struct cfg80211_sched_scan_request *sched_req;
+#endif /*ROAM_OFFLOAD*/
+	struct delayed_work timeout;
+	struct cfg80211_scan_request *req;
+	struct ieee80211_channel **begin;
+	struct ieee80211_channel **curr;
+	struct ieee80211_channel **end;
+	struct wsm_ssid ssids[WSM_SCAN_MAX_NUM_OF_SSIDS];
+	int output_power;
+	int n_ssids;
+	struct semaphore status_lock; /*sync scan request and result*/
+	int status;
+	atomic_t in_progress;
+	/* Direct probe requests workaround */
+	struct delayed_work probe_work;
+	int direct_probe;
+	u8 if_id;
+#ifdef SCAN_FAILED_WORKAROUND_OF_FW_EXCEPTION
+	unsigned long scan_failed_timestamp;
+	u8 scan_failed_cnt;
+#endif
+};
+
+int xradio_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		   struct cfg80211_scan_request *req);
+#ifdef ROAM_OFFLOAD
+int xradio_hw_sched_scan_start(struct ieee80211_hw *hw,
+			       struct ieee80211_vif *vif,
+			       struct cfg80211_sched_scan_request *req,
+			       struct ieee80211_sched_scan_ies *ies);
+void xradio_hw_sched_scan_stop(struct xradio_common *priv);
+void xradio_sched_scan_work(struct work_struct *work);
+#endif /*ROAM_OFFLOAD*/
+void xradio_scan_work(struct work_struct *work);
+void xradio_scan_timeout(struct work_struct *work);
+void xradio_scan_complete_cb(struct xradio_common *priv,
+			     struct wsm_scan_complete *arg);
+
+/* ******************************************************************** */
+/* Raw probe requests TX workaround					*/
+void xradio_probe_work(struct work_struct *work);
+#ifdef CONFIG_XRADIO_TESTMODE
+/* Advance Scan Timer							*/
+void xradio_advance_scan_timeout(struct work_struct *work);
+#endif
+
+#endif
diff -Naurp a/drivers/net/wireless/xr829/wlan/sdio.c b/drivers/net/wireless/xr829/wlan/sdio.c
--- a/drivers/net/wireless/xr829/wlan/sdio.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/sdio.c	2022-08-27 01:22:42.970539923 +0300
@@ -0,0 +1,485 @@
+/*
+ * SDIO driver for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <generated/uapi/linux/version.h>
+#include <linux/module.h>
+#include <linux/wait.h>
+#include <linux/gpio.h>
+#include <linux/regulator/consumer.h>
+#include <linux/delay.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/sdio.h>
+#include <linux/spinlock.h>
+#include <net/mac80211.h>
+
+#include "platform.h"
+#include "xradio.h"
+#include "sbus.h"
+
+/* sdio vendor id and device id*/
+#define SDIO_VENDOR_ID_XRADIO 0x0020
+#define SDIO_DEVICE_ID_XRADIO 0x2281
+#define SDIO_VENDOR_ID_XR829 0x0A9E
+#define SDIO_DEVICE_ID_XR829 0x2282
+
+static const struct sdio_device_id xradio_sdio_ids[] = {
+	{SDIO_DEVICE(SDIO_VENDOR_ID_XRADIO, SDIO_DEVICE_ID_XRADIO)},
+	{SDIO_DEVICE(SDIO_VENDOR_ID_XR829, SDIO_DEVICE_ID_XR829)},
+	/*{ SDIO_DEVICE(SDIO_ANY_ID, SDIO_ANY_ID) }, */
+	{ /* end: all zeroes */ },
+};
+
+/* sbus_ops implemetation */
+static int sdio_data_read(struct sbus_priv *self, unsigned int addr,
+			  void *dst, int count)
+{
+	return sdio_memcpy_fromio(self->func, dst, addr, count);
+}
+
+static int sdio_data_write(struct sbus_priv *self, unsigned int addr,
+			   const void *src, int count)
+{
+	return sdio_memcpy_toio(self->func, addr, (void *)src, count);
+}
+
+static void sdio_lock(struct sbus_priv *self)
+{
+	sdio_claim_host(self->func);
+}
+
+static void sdio_unlock(struct sbus_priv *self)
+{
+	sdio_release_host(self->func);
+}
+
+static size_t sdio_align_len(struct sbus_priv *self, size_t size)
+{
+	return sdio_align_size(self->func, size);
+}
+
+static int sdio_set_blk_size(struct sbus_priv *self, size_t size)
+{
+	sbus_printk(XRADIO_DBG_NIY, "set blocksize=%zu\n", size);
+	return sdio_set_block_size(self->func, size);
+}
+
+static size_t sdio_cur_blk_size(struct sbus_priv *self)
+{
+	return (size_t)self->func->cur_blksize;
+}
+
+#ifndef CONFIG_XRADIO_USE_GPIO_IRQ
+static void sdio_irq_handler(struct sdio_func *func)
+{
+	struct sbus_priv *self = sdio_get_drvdata(func);
+	unsigned long flags;
+	sbus_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	SYS_BUG(!self);
+	spin_lock_irqsave(&self->lock, flags);
+	if (self->irq_handler)
+		self->irq_handler(self->irq_priv);
+	spin_unlock_irqrestore(&self->lock, flags);
+}
+#endif
+
+static int sdio_irq_subscribe(struct sbus_priv *self,
+				     sbus_irq_handler handler,
+				     void *priv)
+{
+	int ret = 0;
+	unsigned long flags;
+
+
+	if (!handler)
+		return -EINVAL;
+	sbus_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	spin_lock_irqsave(&self->lock, flags);
+	self->irq_priv = priv;
+	self->irq_handler = handler;
+	spin_unlock_irqrestore(&self->lock, flags);
+
+	sdio_claim_host(self->func);
+#ifndef CONFIG_XRADIO_USE_GPIO_IRQ
+	ret = sdio_claim_irq(self->func, sdio_irq_handler);
+	if (ret) {
+		sbus_printk(XRADIO_DBG_ERROR, "%s:sdio_claim_irq failed(%d).\n",
+				__func__, ret);
+
+	} else {
+		sbus_printk(XRADIO_DBG_NIY, "%s:sdio_claim_irq success.\n", __func__);
+	}
+#else
+	ret = xradio_request_gpio_irq(&(self->func->dev), self);
+	if (!ret) {
+		/* Hack to access Fuction-0 */
+		u8 cccr;
+		int func_num = self->func->num;
+		sbus_printk(XRADIO_DBG_NIY, "%s:xradio_request_gpio_irq success.\n",
+					__func__);
+
+		self->func->num = 0;
+		cccr = sdio_readb(self->func, SDIO_CCCR_IENx, &ret);
+		cccr |= BIT(0);         /* Master interrupt enable ... */
+		cccr |= BIT(func_num);  /* ... for our function */
+		sdio_writeb(self->func, cccr, SDIO_CCCR_IENx, &ret);
+		if (ret) {
+			xradio_free_gpio_irq(&(self->func->dev), self);
+			if (MCI_CHECK_READY(self->func->card->host, 1000) != 0)
+				sbus_printk(XRADIO_DBG_ERROR,
+					    "%s:MCI_CHECK_READY timeout\n", __func__);
+		}
+		/* Restore the WLAN function number */
+		self->func->num = func_num;
+	} else {
+		sbus_printk(XRADIO_DBG_ERROR, "%s:xradio_request_gpio_irq failed(%d).\n",
+				__func__, ret);
+	}
+#endif
+	sdio_release_host(self->func);
+
+	return ret;
+}
+
+static int sdio_irq_unsubscribe(struct sbus_priv *self)
+{
+	int ret = 0;
+	unsigned long flags;
+
+	sbus_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (!self->irq_handler) {
+		sbus_printk(XRADIO_DBG_ERROR, "%s:irq_handler is NULL!\n", __func__);
+		return 0;
+	}
+
+#ifndef CONFIG_XRADIO_USE_GPIO_IRQ
+	sdio_claim_host(self->func);
+	ret = sdio_release_irq(self->func);
+	sdio_release_host(self->func);
+#else
+	xradio_free_gpio_irq(&(self->func->dev), self);
+#endif /*CONFIG_XRADIO_USE_GPIO_IRQ*/
+
+	spin_lock_irqsave(&self->lock, flags);
+	self->irq_priv = NULL;
+	self->irq_handler = NULL;
+	spin_unlock_irqrestore(&self->lock, flags);
+
+	return ret;
+}
+
+static int sdio_pm(struct sbus_priv *self, bool suspend)
+{
+	int ret = 0;
+	if (suspend) {
+		/* Notify SDIO that XRADIO will remain powered during suspend */
+		ret = sdio_set_host_pm_flags(self->func, MMC_PM_KEEP_POWER);
+		if (ret)
+			sbus_printk(XRADIO_DBG_ERROR,
+				    "Error setting SDIO pm flags: %i\n", ret);
+	}
+
+	return ret;
+}
+
+static int sdio_reset(struct sbus_priv *self)
+{
+	return 0;
+}
+
+static struct sbus_ops sdio_sbus_ops = {
+	.sbus_data_read     = sdio_data_read,
+	.sbus_data_write    = sdio_data_write,
+	.lock               = sdio_lock,
+	.unlock             = sdio_unlock,
+	.align_size         = sdio_align_len,
+	.set_block_size     = sdio_set_blk_size,
+	.get_block_size     = sdio_cur_blk_size,
+	.irq_subscribe      = sdio_irq_subscribe,
+	.irq_unsubscribe    = sdio_irq_unsubscribe,
+	.power_mgmt         = sdio_pm,
+	.reset              = sdio_reset,
+};
+static struct sbus_priv sdio_self;
+
+#if (defined(CONFIG_XRADIO_DEBUGFS))
+u32 dbg_sdio_clk;
+static int sdio_set_clk(struct sdio_func *func, u32 clk)
+{
+	if (func) {
+		/* set min to 1M */
+		if (func->card->host->ops->set_ios && clk >= 1000000) {
+			sdio_claim_host(func);
+			func->card->host->ios.clock = (clk < 50000000) ? clk : 50000000;
+			func->card->host->ops->set_ios(func->card->host,
+			     &func->card->host->ios);
+			sdio_release_host(func);
+			sbus_printk(XRADIO_DBG_ALWY, "%s:change mmc clk=%d\n", __func__,
+				    func->card->host->ios.clock);
+		} else {
+			sbus_printk(XRADIO_DBG_ALWY, "%s:fail change mmc clk=%d\n",
+				    __func__, clk);
+		}
+	}
+	return 0;
+	sbus_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+}
+#endif
+
+/* Probe Function to be called by SDIO stack when device is discovered */
+static int sdio_probe(struct sdio_func *func,
+		      const struct sdio_device_id *id)
+{
+	sbus_printk(XRADIO_DBG_ALWY, "XRadio Device:sdio clk=%d\n",
+		    func->card->host->ios.clock);
+	sbus_printk(XRADIO_DBG_NIY, "sdio func->class=%x\n", func->class);
+	sbus_printk(XRADIO_DBG_NIY, "sdio_vendor: 0x%04x\n", func->vendor);
+	sbus_printk(XRADIO_DBG_NIY, "sdio_device: 0x%04x\n", func->device);
+	sbus_printk(XRADIO_DBG_NIY, "Function#: 0x%04x\n",   func->num);
+	sbus_printk(XRADIO_DBG_NIY, "max_blksize:%u\n",   func->max_blksize);
+	sbus_printk(XRADIO_DBG_NIY, "cur_blksize:%u\n",   func->cur_blksize);
+
+#if (defined(CONFIG_XRADIO_DEBUGFS))
+	if (dbg_sdio_clk)
+		sdio_set_clk(func, dbg_sdio_clk);
+#endif
+
+#if 0				/*for odly and sdly debug.*/
+
+#ifdef __io_address
+#undef __io_address
+#endif
+
+#define __io_address(_n) (0xf0000000+(_n))
+
+{
+		u32 sdio_param = 0;
+		u32 s_dly = 7;
+
+		u32 smc_no = 0x1;
+
+		sdio_param = readl(__io_address(0x01c20088 + 0x4 * smc_no));
+
+		sbus_printk(XRADIO_DBG_ALWY, "%s[read ]: 0x01c20088=0x%08x\n",
+			__func__, sdio_param);
+
+		sdio_param &= ~(0xf << 8);
+		sdio_param |= 3 << 8;
+		sdio_param &= ~(0xf << 20);
+		sdio_param |= s_dly << 20;
+
+		writel(sdio_param, __io_address(0x01c20088 + 0x4 * smc_no));
+		sbus_printk(XRADIO_DBG_ALWY, "%s[write]: 0x01c20088=0x%08x\n",
+			__func__, sdio_param);
+
+		sdio_param = readl(__io_address(0x01c20088 + 0x4 * smc_no));
+
+		sbus_printk(XRADIO_DBG_ALWY, "%s[read2]: 0x01c20088=0x%08x\n",
+			__func__, sdio_param);
+
+}
+
+#endif
+
+	sdio_self.func = func;
+	sdio_self.func->card->quirks |= MMC_QUIRK_BROKEN_BYTE_MODE_512;
+	sdio_set_drvdata(func, &sdio_self);
+	sdio_claim_host(func);
+	sdio_enable_func(func);
+	sdio_release_host(func);
+
+	sdio_self.load_state = SDIO_LOAD;
+	wake_up(&sdio_self.init_wq);
+
+	return 0;
+}
+
+/* Disconnect Function to be called by SDIO stack when
+ * device is disconnected */
+static void sdio_remove(struct sdio_func *func)
+{
+	struct sbus_priv *self = sdio_get_drvdata(func);
+	sbus_printk(XRADIO_DBG_NIY, "%s\n", __func__);
+	sdio_claim_host(func);
+	sdio_disable_func(func);
+	sdio_release_host(func);
+	sdio_set_drvdata(func, NULL);
+	if (self) {
+		self->func = NULL;
+		self->load_state = SDIO_UNLOAD;
+		wake_up(&sdio_self.init_wq);
+	}
+}
+
+#if 0
+static int sdio_suspend(struct device *dev)
+{
+	int ret = 0;
+	sbus_printk(XRADIO_DBG_NIY, "%s\n", __func__);
+#ifdef CONFIG_XRADIO_ETF
+	ret = xradio_etf_suspend();
+	if (ret) {
+		sbus_printk(XRADIO_DBG_ERROR,
+			"xradio_etf_suspend failed(%d)\n", ret);
+	}
+#endif
+	return ret;
+}
+#endif
+
+/*
+ * wifi device need to use sdio while working, so sdio should not suspend before wifi device.
+ * However, sdio may suspend before wifi device, which is controlled by system.so we need to
+ * keep sdio working.The better way is register sdio device as the father device of wifi device,
+ * so it will suspend wifi device first
+ */
+extern struct xradio_common *g_hw_priv;
+static int sdio_suspend(struct device *dev)
+{
+	int ret = 0;
+	sbus_printk(XRADIO_DBG_NIY, "%s\n", __func__);
+
+	if (g_hw_priv && (g_hw_priv->exit_sync == true)) {
+		sbus_printk(XRADIO_DBG_WARN, "Don't suspend because xradio is exiting\n");
+		return -EBUSY;
+	}
+
+#ifdef CONFIG_XRADIO_ETF
+	ret = xradio_etf_suspend();
+	if (!ret) {
+		struct sdio_func *func = dev_to_sdio_func(dev);
+		ret = sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);
+		if (ret) {
+			xradio_etf_resume();
+			sbus_printk(XRADIO_DBG_ERROR, "set MMC_PM_KEEP_POWER error\n");
+		}
+	} else {
+		sbus_printk(XRADIO_DBG_ERROR, "xradio_etf_suspend failed\n");
+	}
+#else
+	struct sdio_func *func = dev_to_sdio_func(dev);
+	ret = sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);
+	if (ret) {
+		sbus_printk(XRADIO_DBG_ERROR, "set MMC_PM_KEEP_POWER error\n");
+	}
+#endif
+
+	return ret;
+}
+
+static int sdio_resume(struct device *dev)
+{
+	sbus_printk(XRADIO_DBG_NIY, "%s\n", __func__);
+#ifdef CONFIG_XRADIO_ETF
+	xradio_etf_resume();
+#endif
+	return 0;
+}
+
+static const struct dev_pm_ops sdio_pm_ops = {
+	.suspend = sdio_suspend,
+	.resume = sdio_resume,
+};
+
+static struct sdio_driver sdio_driver = {
+	.name     = "xradio_wlan",
+	.id_table = xradio_sdio_ids,
+	.probe    = sdio_probe,
+	.remove   = sdio_remove,
+	.drv = {
+		.pm = &sdio_pm_ops,
+	}
+};
+
+/* Init Module function -> Called by insmod */
+struct device *sbus_sdio_init(struct sbus_ops **sdio_ops,
+			      struct sbus_priv **sdio_priv)
+{
+	int ret = 0;
+	struct device *sdio_dev = NULL;
+	sbus_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	/*initialize sbus_priv.*/
+	if (sdio_self.load_state == SDIO_UNLOAD) {
+		spin_lock_init(&sdio_self.lock);
+		init_waitqueue_head(&sdio_self.init_wq);
+
+		/*module power up.*/
+		xradio_wlan_power(1);
+		mdelay(100);
+		/*detect sdio card.*/
+		xradio_sdio_detect(1);
+
+		/*setup sdio driver.*/
+		ret = sdio_register_driver(&sdio_driver);
+		if (ret) {
+			sbus_printk(XRADIO_DBG_ERROR, "sdio_register_driver failed!\n");
+			return NULL;
+		}
+
+		if (wait_event_timeout(sdio_self.init_wq,
+			sdio_self.load_state == SDIO_LOAD, 2*HZ) <= 0) {
+			sdio_unregister_driver(&sdio_driver);
+			sdio_self.load_state = SDIO_UNLOAD;
+
+			xradio_wlan_power(0);	/*power down.*/
+			xradio_sdio_detect(0);
+			sbus_printk(XRADIO_DBG_ERROR, "sdio probe timeout!\n");
+			return NULL;
+		}
+	}
+
+	sdio_self.val32_r = (u32 *)kmalloc(sizeof(u32), GFP_KERNEL);
+	sdio_self.val32_w = (u32 *)kmalloc(sizeof(u32), GFP_KERNEL);
+	if (!sdio_self.val32_r || !sdio_self.val32_w) {
+		xradio_dbg(XRADIO_DBG_ERROR,
+			"%s, val32: kmalloc error!\n",
+			__func__);
+		return NULL;
+	}
+
+	/*register sbus.*/
+	sdio_dev   = &(sdio_self.func->dev);
+	*sdio_ops  = &sdio_sbus_ops;
+	*sdio_priv = &sdio_self;
+
+	return sdio_dev;
+}
+
+/* SDIO Driver Unloading */
+void sbus_sdio_deinit(void)
+{
+	int retrycnt = 0;
+	sbus_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	if (sdio_self.load_state != SDIO_UNLOAD) {
+		xradio_wlan_power(0);	/*power down.*/
+
+retry:	xradio_sdio_detect(0);
+		if (wait_event_interruptible_timeout(sdio_self.init_wq,
+			sdio_self.load_state == SDIO_UNLOAD, 2*HZ) <= 0) {
+			sbus_printk(XRADIO_DBG_ERROR, "%s remove timeout!\n", __func__);
+
+			if (++retrycnt <= 2)
+				goto retry;
+		}
+		sdio_unregister_driver(&sdio_driver);
+		kfree(sdio_self.val32_r);
+		kfree(sdio_self.val32_w);
+		memset(&sdio_self, 0, sizeof(sdio_self));
+		msleep(5);
+	} else {
+		sbus_printk(XRADIO_DBG_ERROR, "%s sdio did not init!\n", __func__);
+	}
+}
diff -Naurp a/drivers/net/wireless/xr829/wlan/sta.c b/drivers/net/wireless/xr829/wlan/sta.c
--- a/drivers/net/wireless/xr829/wlan/sta.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/sta.c	2022-08-27 01:22:42.970539923 +0300
@@ -0,0 +1,4237 @@
+/*
+ * STA APIs for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/vmalloc.h>
+#include <linux/sched.h>
+#include <linux/firmware.h>
+#include <linux/if_arp.h>
+#include <linux/ipv6.h>
+#include <linux/icmpv6.h>
+#include <net/ndisc.h>
+
+#include "xradio.h"
+#include "sta.h"
+#include "ap.h"
+#include "fwio.h"
+#include "bh.h"
+#include "wsm.h"
+#ifdef ROAM_OFFLOAD
+#include <net/netlink.h>
+#endif /*ROAM_OFFLOAD*/
+#ifdef CONFIG_XRADIO_TESTMODE
+#include "nl80211_testmode_msg_copy.h"
+#include <net/netlink.h>
+#endif /* CONFIG_XRADIO_TESTMODE */
+
+#include "net/mac80211.h"
+
+#ifdef TES_P2P_0002_ROC_RESTART
+#include <linux/time.h>
+#endif
+
+#define WEP_ENCRYPT_HDR_SIZE    4
+#define WEP_ENCRYPT_TAIL_SIZE   4
+#define WPA_ENCRYPT_HDR_SIZE    8
+#define WPA_ENCRYPT_TAIL_SIZE   12
+#define WPA2_ENCRYPT_HDR_SIZE   8
+#define WPA2_ENCRYPT_TAIL_SIZE  8
+#define WAPI_ENCRYPT_HDR_SIZE   18
+#define WAPI_ENCRYPT_TAIL_SIZE  16
+#define MAX_ARP_REPLY_TEMPLATE_SIZE     120
+#ifdef CONFIG_XRADIO_TESTMODE
+const int xradio_1d_to_ac[8] = {
+	IEEE80211_AC_BE,
+	IEEE80211_AC_BK,
+	IEEE80211_AC_BK,
+	IEEE80211_AC_BE,
+	IEEE80211_AC_VI,
+	IEEE80211_AC_VI,
+	IEEE80211_AC_VO,
+	IEEE80211_AC_VO
+};
+
+/**
+ * enum xradio_ac_numbers - AC numbers as used in xradio
+ * @XRADIO_AC_VO: voice
+ * @XRADIO_AC_VI: video
+ * @XRADIO_AC_BE: best effort
+ * @XRADIO_AC_BK: background
+ */
+enum xradio_ac_numbers {
+	XRADIO_AC_VO = 0,
+	XRADIO_AC_VI = 1,
+	XRADIO_AC_BE = 2,
+	XRADIO_AC_BK = 3,
+};
+#endif /*CONFIG_XRADIO_TESTMODE */
+
+#ifdef IPV6_FILTERING
+#define MAX_NEIGHBOR_ADVERTISEMENT_TEMPLATE_SIZE 144
+#endif /*IPV6_FILTERING */
+
+static inline void __xradio_free_event_queue(struct list_head *list)
+{
+	while (!list_empty(list)) {
+		struct xradio_wsm_event *event =
+		    list_first_entry(list, struct xradio_wsm_event, link);
+		list_del(&event->link);
+		kfree(event);
+	}
+}
+
+#ifdef CONFIG_XRADIO_TESTMODE
+/* User priority to WSM queue mapping */
+const int xradio_priority_to_queueId[8] = {
+	WSM_QUEUE_BEST_EFFORT,
+	WSM_QUEUE_BACKGROUND,
+	WSM_QUEUE_BACKGROUND,
+	WSM_QUEUE_BEST_EFFORT,
+	WSM_QUEUE_VIDEO,
+	WSM_QUEUE_VIDEO,
+	WSM_QUEUE_VOICE,
+	WSM_QUEUE_VOICE
+};
+#endif /*CONFIG_XRADIO_TESTMODE */
+static inline void __xradio_bf_configure(struct xradio_vif *priv)
+{
+	priv->bf_table.numOfIEs = __cpu_to_le32(3);
+	priv->bf_table.entry[0].ieId = WLAN_EID_VENDOR_SPECIFIC;
+	priv->bf_table.entry[0].actionFlags =
+	    WSM_BEACON_FILTER_IE_HAS_CHANGED |
+	    WSM_BEACON_FILTER_IE_NO_LONGER_PRESENT |
+	    WSM_BEACON_FILTER_IE_HAS_APPEARED;
+
+	priv->bf_table.entry[0].oui[0] = 0x50;
+	priv->bf_table.entry[0].oui[1] = 0x6F;
+	priv->bf_table.entry[0].oui[2] = 0x9A;
+
+	priv->bf_table.entry[1].ieId = WLAN_EID_ERP_INFO;
+	priv->bf_table.entry[1].actionFlags =
+	    WSM_BEACON_FILTER_IE_HAS_CHANGED |
+	    WSM_BEACON_FILTER_IE_NO_LONGER_PRESENT |
+	    WSM_BEACON_FILTER_IE_HAS_APPEARED;
+
+	priv->bf_table.entry[2].ieId = WLAN_EID_HT_INFORMATION;
+	priv->bf_table.entry[2].actionFlags =
+	    WSM_BEACON_FILTER_IE_HAS_CHANGED |
+	    WSM_BEACON_FILTER_IE_NO_LONGER_PRESENT |
+	    WSM_BEACON_FILTER_IE_HAS_APPEARED;
+
+	priv->bf_control.enabled = WSM_BEACON_FILTER_ENABLE;
+}
+
+/* ******************************************************************** */
+/* STA API								*/
+
+int xradio_start(struct ieee80211_hw *dev)
+{
+	struct xradio_common *hw_priv = dev->priv;
+	int ret = 0;
+	int suspend_lock_state;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (wait_event_interruptible_timeout(hw_priv->wsm_startup_done,
+				hw_priv->driver_ready, 3*HZ) <= 0) {
+		sta_printk(XRADIO_DBG_ERROR,
+				   "%s:driver is not ready\n", __func__);
+		return -ETIMEDOUT;
+	}
+
+	if (wait_event_interruptible_timeout(hw_priv->wsm_wakeup_done,
+				XRADIO_RESUME == atomic_read(&hw_priv->suspend_state), 3*HZ) <= 0) {
+		sta_printk(XRADIO_DBG_ERROR,
+				   "%s:driver is suspending \n", __func__);
+		return -ETIMEDOUT;
+	}
+
+	suspend_lock_state = atomic_cmpxchg(&hw_priv->suspend_lock_state,
+								XRADIO_SUSPEND_LOCK_IDEL, XRADIO_SUSPEND_LOCK_OTHERS);
+	if (suspend_lock_state == XRADIO_SUSPEND_LOCK_SUSPEND) {
+		sta_printk(XRADIO_DBG_WARN,
+			   "%s:refuse because of suspend\n", __func__);
+		return -EBUSY;
+	}
+	down(&hw_priv->conf_lock);
+	atomic_set(&hw_priv->suspend_lock_state, XRADIO_SUSPEND_LOCK_IDEL);
+
+#ifdef CONFIG_XRADIO_TESTMODE
+	spin_lock_bh(&hw_priv->tsm_lock);
+	memset(&hw_priv->tsm_stats, 0, sizeof(struct xr_tsm_stats));
+	memset(&hw_priv->tsm_info, 0, sizeof(struct xradio_tsm_info));
+	spin_unlock_bh(&hw_priv->tsm_lock);
+#endif /*CONFIG_XRADIO_TESTMODE */
+	hw_priv->softled_state = 0;
+	memcpy(hw_priv->mac_addr, dev->wiphy->perm_addr, ETH_ALEN);
+
+	ret = xradio_setup_mac(hw_priv);
+	if (SYS_WARN(ret)) {
+		sta_printk(XRADIO_DBG_ERROR,
+			   "%s, xradio_setup_mac failed(%d)\n", __func__, ret);
+		goto out;
+	}
+
+out:
+	up(&hw_priv->conf_lock);
+	return ret;
+}
+
+void xradio_stop(struct ieee80211_hw *dev)
+{
+	struct xradio_common *hw_priv = dev->priv;
+	struct xradio_vif *priv = NULL;
+	LIST_HEAD(list);
+	int i;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	wsm_lock_tx(hw_priv);
+	while (down_trylock(&hw_priv->scan.lock)) {
+		/* Scan is in progress. Force it to stop. */
+		hw_priv->scan.req = NULL;
+		schedule();
+	}
+	up(&hw_priv->scan.lock);
+
+	cancel_delayed_work_sync(&hw_priv->scan.probe_work);
+	cancel_delayed_work_sync(&hw_priv->scan.timeout);
+#ifdef CONFIG_XRADIO_TESTMODE
+	cancel_delayed_work_sync(&hw_priv->advance_scan_timeout);
+#endif
+	flush_workqueue(hw_priv->workqueue);
+	flush_workqueue(hw_priv->spare_workqueue);
+	del_timer_sync(&hw_priv->ba_timer);
+
+	down(&hw_priv->conf_lock);
+
+	hw_priv->softled_state = 0;
+	/* xradio_set_leds(hw_priv); */
+
+	spin_lock(&hw_priv->event_queue_lock);
+	list_splice_init(&hw_priv->event_queue, &list);
+	spin_unlock(&hw_priv->event_queue_lock);
+	__xradio_free_event_queue(&list);
+
+	for (i = 0; i < 4; i++)
+		xradio_queue_clear(&hw_priv->tx_queue[i], XRWL_ALL_IFS);
+
+	/* HACK! */
+	if (atomic_xchg(&hw_priv->tx_lock, 1) != 1)
+		sta_printk(XRADIO_DBG_WARN,
+			   "TX is force-unlocked due to stop request.\n");
+
+	xradio_for_each_vif(hw_priv, priv, i) {
+		if (!priv)
+			continue;
+		priv->mode = NL80211_IFTYPE_UNSPECIFIED;
+		priv->listening = false;
+		priv->delayed_link_loss = 0;
+		priv->join_status = XRADIO_JOIN_STATUS_PASSIVE;
+		cancel_delayed_work_sync(&priv->join_timeout);
+		cancel_delayed_work_sync(&priv->bss_loss_work);
+		cancel_delayed_work_sync(&priv->connection_loss_work);
+		cancel_delayed_work_sync(&priv->link_id_gc_work);
+		del_timer_sync(&priv->mcast_timeout);
+	}
+
+	wsm_unlock_tx(hw_priv);
+
+	up(&hw_priv->conf_lock);
+}
+
+int xradio_add_interface(struct ieee80211_hw *dev, struct ieee80211_vif *vif)
+{
+	int ret;
+	struct xradio_common *hw_priv = dev->priv;
+	struct xradio_vif *priv;
+	int suspend_lock_state;
+
+#ifndef P2P_MULTIVIF
+	int i;
+#endif
+
+	if (atomic_read(&hw_priv->num_vifs) >= XRWL_MAX_VIFS) {
+		WARN_ON(1);
+		sta_printk(XRADIO_DBG_ERROR, "%s:Too many interfaces=%d\n",
+			__func__, atomic_read(&hw_priv->num_vifs));
+		return -EOPNOTSUPP;
+	}
+
+	if (wait_event_interruptible_timeout(hw_priv->wsm_startup_done,
+				hw_priv->driver_ready, 3*HZ) <= 0) {
+		sta_printk(XRADIO_DBG_ERROR,
+				   "%s:driver is not ready\n", __func__);
+		return -ETIMEDOUT;
+	}
+
+	if (hw_priv->bh_error) {
+		sta_printk(XRADIO_DBG_ERROR, "%s:bh_error occurs=%d\n",
+			__func__, hw_priv->bh_error);
+		return -EIO;
+	}
+
+#ifdef CONFIG_XRADIO_SUSPEND_POWER_OFF
+	if (XRADIO_POWEROFF_SUSP == atomic_read(&hw_priv->suspend_state)) {
+		sta_printk(XRADIO_DBG_WARN, "%s: driver has not finish resume "
+			"from poweroff standby\n", __func__);
+		/*we do nothing because mac80211_restart_hw will do it again.*/
+		return 0;
+	}
+#endif
+
+	sta_printk(XRADIO_DBG_NIY, "%s: vif_type=%d, p2p=%d, ch=%d, addr=%pM\n",
+		   __func__, vif->type, vif->p2p,
+		   vif->bss_conf.chan_conf->channel->hw_value, vif->addr);
+
+	suspend_lock_state = atomic_cmpxchg(&hw_priv->suspend_lock_state,
+								XRADIO_SUSPEND_LOCK_IDEL, XRADIO_SUSPEND_LOCK_OTHERS);
+	if (suspend_lock_state == XRADIO_SUSPEND_LOCK_SUSPEND) {
+		sta_printk(XRADIO_DBG_WARN,
+			   "%s:refuse because of suspend\n", __func__);
+		return -EBUSY;
+	}
+	down(&hw_priv->conf_lock);
+	atomic_set(&hw_priv->suspend_lock_state, XRADIO_SUSPEND_LOCK_IDEL);
+
+	priv = xrwl_get_vif_from_ieee80211(vif);
+	if (atomic_read(&priv->enabled)) {
+		sta_printk(XRADIO_DBG_ERROR,
+			 "%s:vif%d is exist(%p, new=%p, vif_list=%p), mode=%d\n",
+			__func__, priv->if_id, priv->vif, vif,
+			hw_priv->vif_list[priv->if_id], priv->mode);
+		up(&hw_priv->conf_lock);
+		return -EEXIST;
+	}
+	memset(priv, 0, sizeof(struct xradio_vif));
+
+	priv->mode = vif->type;
+	spin_lock(&hw_priv->vif_list_lock);
+	if (atomic_read(&hw_priv->num_vifs) < XRWL_MAX_VIFS) {
+#ifdef P2P_MULTIVIF
+		if (!memcmp(vif->addr, hw_priv->addresses[0].addr, ETH_ALEN)) {
+			priv->if_id = 0;
+		} else if (!memcmp(vif->addr, hw_priv->addresses[1].addr,
+			ETH_ALEN)) {
+			priv->if_id = 2;
+		} else if (!memcmp(vif->addr, hw_priv->addresses[2].addr,
+			ETH_ALEN)) {
+			priv->if_id = 1;
+		}
+		sta_printk(XRADIO_DBG_MSG, "%s: if_id %d mac %pM\n",
+			   __func__, priv->if_id, vif->addr);
+#else
+		for (i = 0; i < XRWL_MAX_VIFS; i++)
+			if (!memcmp(vif->addr, hw_priv->addresses[i].addr, ETH_ALEN))
+				break;
+		if (i == XRWL_MAX_VIFS) {
+			spin_unlock(&hw_priv->vif_list_lock);
+			up(&hw_priv->conf_lock);
+			return -EINVAL;
+		}
+		priv->if_id = i;
+#endif
+#ifdef MONITOR_MODE
+		if (priv->mode == NL80211_IFTYPE_MONITOR) {
+			priv->if_id = 0;
+			hw_priv->monitor_if_id = 0;
+		}
+#else
+		if (priv->mode == NL80211_IFTYPE_MONITOR) {
+			spin_unlock(&hw_priv->vif_list_lock);
+			up(&hw_priv->conf_lock);
+			sta_printk(XRADIO_DBG_WARN,
+				   "%s: NL80211_IFTYPE_MONITOR unsupport!\n",
+				   __func__);
+			return -EOPNOTSUPP;
+		}
+#endif
+		hw_priv->if_id_slot |= BIT(priv->if_id);
+		priv->hw_priv = hw_priv;
+		priv->hw = dev;
+		priv->vif = vif;
+		hw_priv->vif_list[priv->if_id] = vif;
+		atomic_inc(&hw_priv->num_vifs);
+	} else {
+		spin_unlock(&hw_priv->vif_list_lock);
+		up(&hw_priv->conf_lock);
+		return -EOPNOTSUPP;
+	}
+	spin_unlock(&hw_priv->vif_list_lock);
+	/* TODO:COMBO :Check if MAC address matches the one expected by FW */
+	memcpy(hw_priv->mac_addr, vif->addr, ETH_ALEN);
+
+	/* Enable auto-calibration */
+	/* Exception in subsequent channel switch; disabled.
+	SYS_WARN(wsm_write_mib(hw_priv, WSM_MIB_ID_SET_AUTO_CALIBRATION_MODE,
+		&auto_calibration_mode, sizeof(auto_calibration_mode)));
+	*/
+	sta_printk(XRADIO_DBG_MSG, "Interface ID:%d of type:%d added\n",
+		   priv->if_id, priv->mode);
+	xradio_vif_setup(priv);
+	up(&hw_priv->conf_lock);
+
+	ret = SYS_WARN(xradio_setup_mac_pvif(priv));
+
+#ifdef MONITOR_MODE
+	if (priv->mode == NL80211_IFTYPE_MONITOR) {
+		struct ieee80211_channel chan;
+		chan.band = WSM_PHY_BAND_2_4G;
+		chan.hw_value = 5;
+		xradio_enable_monitoring(priv, &chan);
+	}
+#endif
+
+	return ret;
+}
+
+void xradio_remove_interface(struct ieee80211_hw *dev,
+			     struct ieee80211_vif *vif)
+{
+	struct xradio_common *hw_priv = dev->priv;
+	struct xradio_vif *priv = xrwl_get_vif_from_ieee80211(vif);
+	struct wsm_reset reset = {
+		.reset_statistics = true,
+	};
+	int i;
+	bool is_htcapie = false;
+	struct xradio_vif *tmp_priv;
+	struct wsm_operational_mode mode = {
+		.power_mode = wsm_power_mode_quiescent,
+		.disableMoreFlagUsage = true,
+	};
+	int suspend_lock_state;
+
+	sta_printk(XRADIO_DBG_WARN, "!!! %s: vif_id=%d\n",
+		   __func__, priv->if_id);
+
+	suspend_lock_state = atomic_cmpxchg(&hw_priv->suspend_lock_state,
+								XRADIO_SUSPEND_LOCK_IDEL, XRADIO_SUSPEND_LOCK_OTHERS);
+	if (suspend_lock_state == XRADIO_SUSPEND_LOCK_SUSPEND) {
+		sta_printk(XRADIO_DBG_WARN,
+			   "%s:refuse because of suspend\n", __func__);
+		return;
+	}
+
+	down(&hw_priv->conf_lock);
+	atomic_set(&hw_priv->suspend_lock_state, XRADIO_SUSPEND_LOCK_IDEL);
+
+	if (atomic_read(&priv->enabled) == 0) {
+		sta_printk(XRADIO_DBG_WARN, "%s:vif is not enable!\n", __func__);
+		up(&hw_priv->conf_lock);
+		return ;
+	}
+	up(&hw_priv->conf_lock);
+
+	cancel_delayed_work_sync(&priv->bss_loss_work);
+	cancel_delayed_work_sync(&priv->connection_loss_work);
+	cancel_delayed_work_sync(&priv->join_timeout);
+	cancel_delayed_work_sync(&priv->set_cts_work);
+	cancel_delayed_work_sync(&priv->pending_offchanneltx_work);
+	del_timer_sync(&priv->mcast_timeout);
+
+	cancel_delayed_work_sync(&priv->unjoin_delayed_work);
+	cancel_work_sync(&priv->update_filtering_work);
+	cancel_work_sync(&priv->set_beacon_wakeup_period_work);
+	cancel_work_sync(&priv->join_work);
+	cancel_work_sync(&priv->unjoin_work);
+	cancel_work_sync(&priv->offchannel_work);
+	cancel_work_sync(&priv->wep_key_work);
+	cancel_work_sync(&priv->set_tim_work);
+	cancel_work_sync(&priv->multicast_start_work);
+	cancel_work_sync(&priv->tx_failure_work);
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+	cancel_work_sync(&priv->linkid_reset_work);
+#endif
+#ifdef AP_HT_CAP_UPDATE
+	cancel_work_sync(&priv->ht_info_update_work);
+#endif
+
+	down(&hw_priv->scan.lock);
+	if (atomic_xchg(&priv->delayed_unjoin, 0)) {
+		wsm_unlock_tx(hw_priv);
+		sta_printk(XRADIO_DBG_ERROR, "%s:delayed_unjoin exist!\n", __func__);
+	}
+	if (priv->join_status == XRADIO_JOIN_STATUS_STA) {
+		cancel_work_sync(&priv->unjoin_work);
+		wsm_lock_tx(hw_priv);
+		xradio_unjoin_work(&priv->unjoin_work);
+		sta_printk(XRADIO_DBG_NIY, "%s:do unjoin_work!\n", __func__);
+	}
+
+	down(&hw_priv->conf_lock);
+	atomic_set(&priv->enabled, 0);
+
+	cancel_work_sync(&priv->link_id_work);
+	cancel_delayed_work_sync(&priv->link_id_gc_work);
+	cancel_delayed_work_sync(&priv->link_id_gc_work);
+
+	xradio_tx_queues_lock(hw_priv);
+	wsm_lock_tx(hw_priv);
+	switch (priv->join_status) {
+	case XRADIO_JOIN_STATUS_AP:
+		for (i = 0; priv->link_id_map; ++i) {
+			if (priv->link_id_map & BIT(i)) {
+				xrwl_unmap_link(priv, i);
+				priv->link_id_map &= ~BIT(i);
+			}
+		}
+		memset(priv->link_id_db, 0,
+				sizeof(priv->link_id_db));
+		priv->sta_asleep_mask = 0;
+		priv->enable_beacon = false;
+		priv->tx_multicast = false;
+		priv->aid0_bit_set = false;
+		priv->buffered_multicasts = false;
+		priv->pspoll_mask = 0;
+		reset.link_id = 0;
+		wsm_reset(hw_priv, &reset, priv->if_id);
+		SYS_WARN(wsm_set_operational_mode(hw_priv, &mode, priv->if_id));
+		xradio_for_each_vif(hw_priv, tmp_priv, i) {
+#ifdef P2P_MULTIVIF
+			if ((i == (XRWL_MAX_VIFS - 1)) || !tmp_priv)
+#else
+			if (!tmp_priv)
+#endif
+				continue;
+			if ((tmp_priv->join_status == XRADIO_JOIN_STATUS_STA)
+				&& tmp_priv->htcap)
+				is_htcapie = true;
+		}
+
+		if (is_htcapie) {
+			hw_priv->vif0_throttle = XRWL_HOST_VIF0_11N_THROTTLE;
+			hw_priv->vif1_throttle = XRWL_HOST_VIF1_11N_THROTTLE;
+			sta_printk(XRADIO_DBG_NIY, "AP REMOVE HTCAP 11N %d\n",
+				   hw_priv->vif0_throttle);
+		} else {
+			hw_priv->vif0_throttle = XRWL_HOST_VIF0_11BG_THROTTLE;
+			hw_priv->vif1_throttle = XRWL_HOST_VIF1_11BG_THROTTLE;
+			sta_printk(XRADIO_DBG_NIY, "AP REMOVE 11BG %d\n",
+				   hw_priv->vif0_throttle);
+		}
+		break;
+	case XRADIO_JOIN_STATUS_MONITOR:
+#ifdef MONITOR_MODE
+		if (priv->mode == NL80211_IFTYPE_MONITOR)
+			xradio_disable_monitoring(priv);
+		else
+#endif
+			xradio_disable_listening(priv);
+		break;
+	default:
+		break;
+	}
+	/* TODO:COMBO: Change Queue Module */
+	__xradio_flush(hw_priv, true, priv->if_id);
+
+	/* TODO:COMBO: May be reset of these variables "delayed_link_loss and
+	 * join_status to default can be removed as dev_priv will be freed by
+	 * mac80211 */
+	priv->delayed_link_loss = 0;
+	priv->join_status = XRADIO_JOIN_STATUS_PASSIVE;
+	wsm_unlock_tx(hw_priv);
+
+	if ((priv->if_id == 1) && (priv->mode == NL80211_IFTYPE_AP
+				   || priv->mode == NL80211_IFTYPE_P2P_GO)) {
+		hw_priv->is_go_thru_go_neg = false;
+	}
+	spin_lock(&hw_priv->vif_list_lock);
+	spin_lock(&priv->vif_lock);
+	hw_priv->vif_list[priv->if_id] = NULL;
+	hw_priv->if_id_slot &= (~BIT(priv->if_id));
+	atomic_dec(&hw_priv->num_vifs);
+	if (atomic_read(&hw_priv->num_vifs) == 0) {
+		xradio_free_keys(hw_priv);
+		memset(hw_priv->mac_addr, 0, ETH_ALEN);
+	}
+	spin_unlock(&priv->vif_lock);
+	spin_unlock(&hw_priv->vif_list_lock);
+	priv->listening = false;
+
+	xradio_debug_release_priv(priv);
+
+	xradio_tx_queues_unlock(hw_priv);
+	up(&hw_priv->conf_lock);
+
+	if (atomic_read(&hw_priv->num_vifs) == 0) {
+		flush_workqueue(hw_priv->workqueue);
+		flush_workqueue(hw_priv->spare_workqueue);
+	}
+	up(&hw_priv->scan.lock);
+}
+
+int xradio_change_interface(struct ieee80211_hw *dev,
+				struct ieee80211_vif *vif,
+				enum nl80211_iftype new_type,
+				bool p2p)
+{
+	int ret = 0;
+	sta_printk(XRADIO_DBG_WARN, "%s: new type=%d(%d), p2p=%d(%d)\n",
+		   __func__, new_type, vif->type, p2p, vif->p2p);
+	if (new_type != vif->type || vif->p2p != p2p) {
+		xradio_remove_interface(dev, vif);
+		vif->type = new_type;
+		vif->p2p = p2p;
+		ret = xradio_add_interface(dev, vif);
+	}
+
+	return ret;
+}
+
+int xradio_config(struct ieee80211_hw *dev, u32 changed)
+{
+	int ret = 0;
+	struct xradio_common *hw_priv = dev->priv;
+	struct ieee80211_conf *conf = &dev->conf;
+#ifdef CONFIG_XRADIO_TESTMODE
+	int max_power_level = 0;
+	int min_power_level = 0;
+#endif
+	/* TODO:COMBO: adjust to multi vif interface
+	 * IEEE80211_CONF_CHANGE_IDLE is still handled per xradio_vif*/
+	int if_id = 0;
+	int suspend_lock_state;
+
+	/*
+	struct xradio_vif *priv;
+	*/
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (changed &
+		(IEEE80211_CONF_CHANGE_MONITOR|IEEE80211_CONF_CHANGE_IDLE)) {
+		/* TBD: It looks like it's transparent
+		 * there's a monitor interface present -- use this
+		 * to determine for example whether to calculate
+		 * timestamps for packets or not, do not use instead
+		 * of filter flags! */
+		sta_printk(XRADIO_DBG_NIY, "ignore IEEE80211_CONF_CHANGE_MONITOR (%d)"
+			   "IEEE80211_CONF_CHANGE_IDLE (%d)\n",
+			   (changed & IEEE80211_CONF_CHANGE_MONITOR) ? 1 : 0,
+			   (changed & IEEE80211_CONF_CHANGE_IDLE) ? 1 : 0);
+		return ret;
+	}
+
+	suspend_lock_state = atomic_cmpxchg(&hw_priv->suspend_lock_state,
+								XRADIO_SUSPEND_LOCK_IDEL, XRADIO_SUSPEND_LOCK_OTHERS);
+	if (suspend_lock_state == XRADIO_SUSPEND_LOCK_SUSPEND) {
+		sta_printk(XRADIO_DBG_WARN,
+			   "%s:refuse because of suspend\n", __func__);
+		return -EBUSY;
+	}
+
+	down(&hw_priv->scan.lock);
+	down(&hw_priv->conf_lock);
+	atomic_set(&hw_priv->suspend_lock_state, XRADIO_SUSPEND_LOCK_IDEL);
+	/*
+	priv = __xrwl_hwpriv_to_vifpriv(hw_priv, hw_priv->scan.if_id);
+	*/
+	/* TODO: IEEE80211_CONF_CHANGE_QOS */
+	/* TODO:COMBO:Change when support is available mac80211*/
+	if (changed & IEEE80211_CONF_CHANGE_POWER) {
+		/*hw_priv->output_power = conf->power_level;*/
+		hw_priv->output_power = 20;
+#ifdef CONFIG_XRADIO_TESTMODE
+		/* Testing if Power Level to set is out of device power range */
+		if (conf->chan_conf->channel->band == NL80211_BAND_2GHZ) {
+			max_power_level = hw_priv->txPowerRange[0].max_power_level;
+			min_power_level = hw_priv->txPowerRange[0].min_power_level;
+		} else {
+			max_power_level = hw_priv->txPowerRange[1].max_power_level;
+			min_power_level = hw_priv->txPowerRange[1].min_power_level;
+		}
+		if (hw_priv->output_power > max_power_level)
+			hw_priv->output_power = max_power_level;
+		else if (hw_priv->output_power < min_power_level)
+			hw_priv->output_power = min_power_level;
+#endif /* CONFIG_XRADIO_TESTMODE */
+
+		sta_printk(XRADIO_DBG_NIY, "Config Tx power=%d, but real=%d\n",
+			   conf->power_level, hw_priv->output_power);
+		SYS_WARN(wsm_set_output_power(hw_priv,
+					      hw_priv->output_power * 10, if_id));
+	}
+
+	if ((changed & IEEE80211_CONF_CHANGE_CHANNEL) &&
+	    (hw_priv->channel != conf->chan_conf->channel)) {
+		/* Switch Channel commented for CC Mode */
+		struct ieee80211_channel *ch = conf->chan_conf->channel;
+		sta_printk(XRADIO_DBG_WARN, "Freq %d (wsm ch: %d) prev: %d.\n",
+			   ch->center_freq, ch->hw_value,
+			   hw_priv->channel ? hw_priv->channel->hw_value : -1);
+		/* Earlier there was a call to __xradio_flush().
+		   Removed as deemed unnecessary */
+		hw_priv->channel = ch;
+		hw_priv->channel_changed = 1;
+#ifdef MONITOR_MODE
+		if (hw_priv->monitor_if_id != -1 && hw_priv->monitor_running)
+			xradio_channel_switch(hw_priv, hw_priv->channel);
+#endif
+	}
+
+	up(&hw_priv->conf_lock);
+	up(&hw_priv->scan.lock);
+	return ret;
+}
+
+void xradio_update_filtering(struct xradio_vif *priv)
+{
+	int ret;
+	bool bssid_filtering = !priv->rx_filter.bssid;
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	static struct wsm_beacon_filter_control bf_disabled = {
+		.enabled = 0,
+		.bcn_count = 1,
+	};
+	bool ap_mode = 0;
+	static struct wsm_beacon_filter_table bf_table_auto = {
+		.numOfIEs = __cpu_to_le32(2),
+		.entry[0].ieId = WLAN_EID_VENDOR_SPECIFIC,
+		.entry[0].actionFlags = WSM_BEACON_FILTER_IE_HAS_CHANGED |
+		    WSM_BEACON_FILTER_IE_NO_LONGER_PRESENT |
+		    WSM_BEACON_FILTER_IE_HAS_APPEARED,
+		.entry[0].oui[0] = 0x50,
+		.entry[0].oui[1] = 0x6F,
+		.entry[0].oui[2] = 0x9A,
+
+		.entry[1].ieId = WLAN_EID_HT_INFORMATION,
+		.entry[1].actionFlags = WSM_BEACON_FILTER_IE_HAS_CHANGED |
+		    WSM_BEACON_FILTER_IE_NO_LONGER_PRESENT |
+		    WSM_BEACON_FILTER_IE_HAS_APPEARED,
+	};
+	static struct wsm_beacon_filter_control bf_auto = {
+		.enabled = WSM_BEACON_FILTER_ENABLE |
+
+#ifdef SUPPORT_HT40
+
+			WSM_BEACON_FILTER_AUTO_ERP|
+			WSM_BEACON_FILTER_AUTO_HT,
+
+#else
+
+		    WSM_BEACON_FILTER_AUTO_ERP,
+
+#endif
+
+		.bcn_count = 1,
+	};
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	bf_auto.bcn_count = priv->bf_control.bcn_count;
+
+	if (priv->join_status == XRADIO_JOIN_STATUS_PASSIVE)
+		return;
+	else if (priv->join_status == XRADIO_JOIN_STATUS_MONITOR)
+		bssid_filtering = false;
+
+	if (priv->vif && (priv->vif->type == NL80211_IFTYPE_AP))
+		ap_mode = true;
+	/*
+	 * When acting as p2p client being connected to p2p GO, in order to
+	 * receive frames from a different p2p device, turn off bssid filter.
+	 *
+	 * WARNING: FW dependency!
+	 * This can only be used with FW WSM371 and its successors.
+	 * In that FW version even with bssid filter turned off,
+	 * device will block most of the unwanted frames.
+	 */
+	if (priv->vif && priv->vif->p2p)
+		bssid_filtering = false;
+
+	ret = wsm_set_rx_filter(hw_priv, &priv->rx_filter, priv->if_id);
+	if (!ret && !ap_mode) {
+		if (priv->vif) {
+			if (priv->vif->p2p || NL80211_IFTYPE_STATION != priv->vif->type)
+				ret = wsm_set_beacon_filter_table(hw_priv,
+						    &priv->bf_table, priv->if_id);
+			else
+				ret = wsm_set_beacon_filter_table(hw_priv,
+						    &bf_table_auto, priv->if_id);
+		} else
+			SYS_WARN(1);
+	}
+	if (!ret && !ap_mode) {
+		if (priv->disable_beacon_filter)
+			ret = wsm_beacon_filter_control(hw_priv,
+							&bf_disabled, priv->if_id);
+		else {
+			if (priv->vif) {
+				if (priv->vif->p2p ||
+					NL80211_IFTYPE_STATION != priv->vif->type)
+					ret = wsm_beacon_filter_control(hw_priv,
+									&priv->bf_control,
+									priv->if_id);
+				else
+					ret = wsm_beacon_filter_control(hw_priv,
+									&bf_auto, priv->if_id);
+			} else
+				SYS_WARN(1);
+		}
+	}
+
+	if (!ret)
+		ret = wsm_set_bssid_filtering(hw_priv, bssid_filtering, priv->if_id);
+#if 0
+	if (!ret) {
+		ret = wsm_set_multicast_filter(hw_priv, &priv->multicast_filter,
+					       priv->if_id);
+	}
+#endif
+	if (ret)
+		sta_printk(XRADIO_DBG_ERROR, "%s: Update filtering failed: %d.\n",
+			   __func__, ret);
+	return;
+}
+
+void xradio_update_filtering_work(struct work_struct *work)
+{
+	struct xradio_vif *priv =
+		container_of(work, struct xradio_vif,
+		update_filtering_work);
+
+	xradio_update_filtering(priv);
+}
+
+void xradio_set_beacon_wakeup_period_work(struct work_struct *work)
+{
+
+	struct xradio_vif *priv =
+	   container_of(work, struct xradio_vif, set_beacon_wakeup_period_work);
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+#ifdef XRADIO_USE_LONG_DTIM_PERIOD
+{
+	int join_dtim_period_extend;
+	if (priv->join_dtim_period <= 3) {
+		join_dtim_period_extend = priv->join_dtim_period * 3;
+	} else if (priv->join_dtim_period <= 5) {
+		join_dtim_period_extend = priv->join_dtim_period * 2;
+	} else {
+		join_dtim_period_extend = priv->join_dtim_period;
+	}
+	SYS_WARN(wsm_set_beacon_wakeup_period(priv->hw_priv,
+		 priv->beacon_int * join_dtim_period_extend >
+		 MAX_BEACON_SKIP_TIME_MS ? 1 : join_dtim_period_extend,
+		 0, priv->if_id));
+}
+#else
+	SYS_WARN(wsm_set_beacon_wakeup_period(priv->hw_priv,
+		 priv->beacon_int * priv->join_dtim_period >
+		 MAX_BEACON_SKIP_TIME_MS ? 1 : priv->join_dtim_period,
+		 0, priv->if_id));
+#endif
+}
+
+u64 xradio_prepare_multicast(struct ieee80211_hw *hw,
+			     struct ieee80211_vif *vif,
+			     struct netdev_hw_addr_list *mc_list)
+{
+	static u8 broadcast_ipv6[ETH_ALEN] = {
+		0x33, 0x33, 0x00, 0x00, 0x00, 0x01
+	};
+	static u8 broadcast_ipv4[ETH_ALEN] = {
+		0x01, 0x00, 0x5e, 0x00, 0x00, 0x01
+	};
+	struct netdev_hw_addr *ha;
+	int count = 0;
+	struct xradio_vif *priv = xrwl_get_vif_from_ieee80211(vif);
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	if (!atomic_read(&priv->enabled)) {
+		sta_printk(XRADIO_DBG_NIY, "%s vif(type=%d) is not enable!\n",
+				__func__, vif->type);
+		return 0;
+	}
+
+	if (SYS_WARN(!priv))
+		return netdev_hw_addr_list_count(mc_list);
+
+#ifdef P2P_MULTIVIF
+	if (priv->if_id == XRWL_GENERIC_IF_ID)
+		return 0;
+#endif
+
+	/* Disable multicast filtering */
+	priv->has_multicast_subscription = false;
+	memset(&priv->multicast_filter, 0x00, sizeof(priv->multicast_filter));
+
+	if (netdev_hw_addr_list_count(mc_list) > WSM_MAX_GRP_ADDRTABLE_ENTRIES)
+		return 0;
+
+	/* Enable if requested */
+	netdev_hw_addr_list_for_each(ha, mc_list) {
+		sta_printk(XRADIO_DBG_MSG, "multicast: %pM\n", ha->addr);
+		memcpy(&priv->multicast_filter.macAddress[count], ha->addr, ETH_ALEN);
+		if (memcmp(ha->addr, broadcast_ipv4, ETH_ALEN) &&
+		    memcmp(ha->addr, broadcast_ipv6, ETH_ALEN))
+			priv->has_multicast_subscription = true;
+		count++;
+	}
+
+	if (count) {
+		priv->multicast_filter.enable = __cpu_to_le32(1);
+		priv->multicast_filter.numOfAddresses = __cpu_to_le32(count);
+	}
+
+	return netdev_hw_addr_list_count(mc_list);
+}
+
+void xradio_configure_filter(struct ieee80211_hw *hw,
+			     struct ieee80211_vif *vif,
+			     unsigned int changed_flags,
+			     unsigned int *total_flags,
+			     u64 multicast)
+{
+	struct xradio_common *hw_priv = hw->priv;
+	struct xradio_vif *priv = xrwl_get_vif_from_ieee80211(vif);
+	int suspend_lock_state;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+#ifdef P2P_MULTIVIF
+	if (priv->if_id == XRWL_GENERIC_IF_ID) {
+		*total_flags &= ~(1 << 31);
+		return;
+	}
+#endif
+
+	suspend_lock_state = atomic_cmpxchg(&hw_priv->suspend_lock_state,
+								XRADIO_SUSPEND_LOCK_IDEL, XRADIO_SUSPEND_LOCK_OTHERS);
+	if (suspend_lock_state == XRADIO_SUSPEND_LOCK_SUSPEND) {
+		sta_printk(XRADIO_DBG_WARN,
+			   "%s:refuse because of suspend\n", __func__);
+		*total_flags &= ~(1 << 31);
+		return;
+	}
+
+#if 0
+	bool listening = !!(*total_flags &
+			     (FIF_PROMISC_IN_BSS      |
+			      FIF_OTHER_BSS           |
+			      FIF_BCN_PRBRESP_PROMISC |
+			      FIF_PROBE_REQ));
+#endif
+
+	*total_flags &= FIF_PROMISC_IN_BSS |
+			FIF_OTHER_BSS      |
+			FIF_FCSFAIL        |
+			FIF_BCN_PRBRESP_PROMISC |
+			FIF_PROBE_REQ;
+
+	down(&hw_priv->scan.lock);
+	down(&hw_priv->conf_lock);
+	atomic_set(&hw_priv->suspend_lock_state, XRADIO_SUSPEND_LOCK_IDEL);
+	if (!atomic_read(&priv->enabled)) {
+		sta_printk(XRADIO_DBG_NIY, "%s vif(type=%d) is not enable!\n",
+				__func__, vif->type);
+		*total_flags &= ~(1 << 31);
+		up(&hw_priv->conf_lock);
+		up(&hw_priv->scan.lock);
+		return ;
+	}
+
+	priv->rx_filter.promiscuous = (*total_flags & FIF_PROMISC_IN_BSS) ? 1 : 0;
+	priv->rx_filter.bssid = (*total_flags &
+				 (FIF_OTHER_BSS | FIF_PROBE_REQ)) ? 1 : 0;
+	priv->rx_filter.fcs = (*total_flags & FIF_FCSFAIL) ? 1 : 0;
+	priv->bf_control.bcn_count = (*total_flags &
+				      (FIF_BCN_PRBRESP_PROMISC |
+				       FIF_PROMISC_IN_BSS |
+				       FIF_PROBE_REQ)) ? 1 : 0;
+
+#if 0
+	if (priv->listening ^ listening) {
+		priv->listening = listening;
+		wsm_lock_tx(hw_priv);
+		xradio_update_listening(priv, listening);
+		wsm_unlock_tx(hw_priv);
+	}
+#endif
+	xradio_update_filtering(priv);
+	up(&hw_priv->conf_lock);
+	up(&hw_priv->scan.lock);
+}
+
+int xradio_conf_tx(struct ieee80211_hw *dev, struct ieee80211_vif *vif,
+		   u16 queue, const struct ieee80211_tx_queue_params *params)
+{
+	struct xradio_common *hw_priv = dev->priv;
+	struct xradio_vif *priv = xrwl_get_vif_from_ieee80211(vif);
+	int ret = 0;
+	int suspend_lock_state;
+	/* To prevent re-applying PM request OID again and again */
+	bool old_uapsdFlags;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (SYS_WARN(!priv))
+		return -EOPNOTSUPP;
+
+#ifdef P2P_MULTIVIF
+	if (priv->if_id == XRWL_GENERIC_IF_ID)
+		return 0;
+#endif
+
+	suspend_lock_state = atomic_cmpxchg(&hw_priv->suspend_lock_state,
+								XRADIO_SUSPEND_LOCK_IDEL, XRADIO_SUSPEND_LOCK_OTHERS);
+	if (suspend_lock_state == XRADIO_SUSPEND_LOCK_SUSPEND) {
+		sta_printk(XRADIO_DBG_WARN,
+			   "%s:refuse because of suspend\n", __func__);
+		return 0;
+	}
+
+	down(&hw_priv->conf_lock);
+	atomic_set(&hw_priv->suspend_lock_state, XRADIO_SUSPEND_LOCK_IDEL);
+	if (!atomic_read(&priv->enabled)) {
+		sta_printk(XRADIO_DBG_NIY, "%s vif(type=%d) is not enable!\n",
+				__func__, vif->type);
+		up(&hw_priv->conf_lock);
+		return 0;
+	}
+
+	if (queue < dev->queues) {
+		old_uapsdFlags = priv->uapsd_info.uapsdFlags;
+
+		WSM_TX_QUEUE_SET(&priv->tx_queue_params, queue, 0, 0, 0);
+		ret = wsm_set_tx_queue_params(hw_priv,
+					      &priv->tx_queue_params.params[queue],
+					      queue, priv->if_id);
+		if (ret) {
+			sta_printk(XRADIO_DBG_ERROR,
+				   "%s:wsm_set_tx_queue_params failed!\n", __func__);
+			ret = -EINVAL;
+			goto out;
+		}
+
+		WSM_EDCA_SET(&priv->edca, queue, params->aifs,
+			      params->cw_min, params->cw_max,
+			      params->txop, 0xc8, params->uapsd);
+		ret = wsm_set_edca_params(hw_priv, &priv->edca, priv->if_id);
+		if (ret) {
+			sta_printk(XRADIO_DBG_ERROR,
+				   "%s:wsm_set_edca_params failed!\n", __func__);
+			ret = -EINVAL;
+			goto out;
+		}
+
+		if (priv->mode == NL80211_IFTYPE_STATION ||
+			priv->mode == NL80211_IFTYPE_P2P_DEVICE) {
+			ret = xradio_set_uapsd_param(priv, &priv->edca);
+			if (!ret && priv->setbssparams_done &&
+			    (priv->join_status == XRADIO_JOIN_STATUS_STA) &&
+			    (old_uapsdFlags != priv->uapsd_info.uapsdFlags))
+				xradio_set_pm(priv, &priv->powersave_mode);
+		}
+	} else {
+		sta_printk(XRADIO_DBG_ERROR, "%s:queue is to large!\n", __func__);
+		ret = -EINVAL;
+	}
+
+out:
+	up(&hw_priv->conf_lock);
+	return ret;
+}
+
+int xradio_get_stats(struct ieee80211_hw *dev,
+		     struct ieee80211_low_level_stats *stats)
+{
+	struct xradio_common *hw_priv = dev->priv;
+
+	memcpy(stats, &hw_priv->stats, sizeof(*stats));
+	return 0;
+}
+
+/*
+int xradio_get_tx_stats(struct ieee80211_hw *dev,
+			struct ieee80211_tx_queue_stats *stats)
+{
+	int i;
+	struct xradio_common *priv = dev->priv;
+
+	for (i = 0; i < dev->queues; ++i)
+		xradio_queue_get_stats(&priv->tx_queue[i], &stats[i]);
+
+	return 0;
+}
+*/
+
+/* for ps debug */
+#ifdef CONFIG_XRADIO_DEBUGFS
+u8 ps_disable;
+u8 ps_idleperiod;
+u8 ps_changeperiod;
+#endif
+
+int xradio_set_pm(struct xradio_vif *priv, const struct wsm_set_pm *arg)
+{
+	struct wsm_set_pm pm = *arg;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+#ifdef CONFIG_XRADIO_DEBUGFS
+	if (ps_disable)
+		pm.pmMode = WSM_PSM_ACTIVE;
+	if (ps_idleperiod) {
+		pm.fastPsmIdlePeriod = ps_idleperiod << 1;
+		pm.apPsmChangePeriod = ps_changeperiod << 1;
+	}
+#endif
+
+	if (priv->uapsd_info.uapsdFlags != 0)
+		pm.pmMode &= ~WSM_PSM_FAST_PS_FLAG;
+
+	if (memcmp(&pm, &priv->firmware_ps_mode, sizeof(struct wsm_set_pm))) {
+		priv->firmware_ps_mode = pm;
+		sta_printk(XRADIO_DBG_NIY, "%s, mode=0x%x, Idle=%d, Change=%d\n",
+					__func__, pm.pmMode, pm.fastPsmIdlePeriod,
+					pm.apPsmChangePeriod);
+		return wsm_set_pm(priv->hw_priv, &pm, priv->if_id);
+	} else {
+		return 0;
+	}
+}
+
+int xradio_set_key(struct ieee80211_hw *dev, enum set_key_cmd cmd,
+		   struct ieee80211_vif *vif, struct ieee80211_sta *sta,
+		   struct ieee80211_key_conf *key)
+{
+	int ret = -EOPNOTSUPP;
+	struct xradio_common *hw_priv = dev->priv;
+	struct xradio_vif *priv = xrwl_get_vif_from_ieee80211(vif);
+	struct wsm_protected_mgmt_policy mgmt_policy;
+	int suspend_lock_state;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+#ifdef P2P_MULTIVIF
+	SYS_WARN(priv->if_id == XRWL_GENERIC_IF_ID);
+#endif
+	suspend_lock_state = atomic_cmpxchg(&hw_priv->suspend_lock_state,
+								XRADIO_SUSPEND_LOCK_IDEL, XRADIO_SUSPEND_LOCK_OTHERS);
+	if (suspend_lock_state == XRADIO_SUSPEND_LOCK_SUSPEND) {
+		sta_printk(XRADIO_DBG_WARN,
+			   "%s:refuse because of suspend\n", __func__);
+		return -EBUSY;
+	}
+
+	down(&hw_priv->conf_lock);
+	atomic_set(&hw_priv->suspend_lock_state, XRADIO_SUSPEND_LOCK_IDEL);
+	if (!atomic_read(&priv->enabled)) {
+		sta_printk(XRADIO_DBG_NIY, "%s vif(type=%d) is not enable!\n",
+				__func__, vif->type);
+		up(&hw_priv->conf_lock);
+		return 0;
+	}
+
+	if (cmd == SET_KEY) {
+		u8 *peer_addr = NULL;
+		int pairwise = (key->flags & IEEE80211_KEY_FLAG_PAIRWISE) ? 1 : 0;
+		int idx = xradio_alloc_key(hw_priv);
+		struct wsm_add_key *wsm_key = &hw_priv->keys[idx];
+
+		if (idx < 0) {
+			sta_printk(XRADIO_DBG_ERROR, "%s:xradio_alloc_key failed!\n",
+				   __func__);
+			ret = -EINVAL;
+			goto finally;
+		}
+
+		SYS_BUG(pairwise && !sta);
+		if (sta)
+			peer_addr = sta->addr;
+
+		switch (key->cipher) {
+		case WLAN_CIPHER_SUITE_WEP40:
+		case WLAN_CIPHER_SUITE_WEP104:
+			if (key->keylen > 16) {
+				xradio_free_key(hw_priv, idx);
+				sta_printk(XRADIO_DBG_ERROR, "%s: keylen too long=%d!\n",
+				       __func__, key->keylen);
+				ret = -EINVAL;
+				goto finally;
+			}
+
+			if (pairwise) {
+				wsm_key->type = WSM_KEY_TYPE_WEP_PAIRWISE;
+				memcpy(wsm_key->wepPairwiseKey.peerAddress,
+				       peer_addr, ETH_ALEN);
+				memcpy(wsm_key->wepPairwiseKey.keyData, &key->key[0],
+				       key->keylen);
+				wsm_key->wepPairwiseKey.keyLength = key->keylen;
+				sta_printk(XRADIO_DBG_NIY, "%s: WEP_PAIRWISE keylen=%d!\n",
+				       __func__, key->keylen);
+			} else {
+				wsm_key->type = WSM_KEY_TYPE_WEP_DEFAULT;
+				memcpy(wsm_key->wepGroupKey.keyData, &key->key[0],
+				       key->keylen);
+				wsm_key->wepGroupKey.keyLength = key->keylen;
+				wsm_key->wepGroupKey.keyId     = key->keyidx;
+				sta_printk(XRADIO_DBG_NIY, "%s: WEP_GROUP keylen=%d!\n",
+				       __func__, key->keylen);
+			}
+			break;
+		case WLAN_CIPHER_SUITE_TKIP:
+			if (pairwise) {
+				wsm_key->type = WSM_KEY_TYPE_TKIP_PAIRWISE;
+				memcpy(wsm_key->tkipPairwiseKey.peerAddress,
+				       peer_addr, ETH_ALEN);
+				memcpy(wsm_key->tkipPairwiseKey.tkipKeyData,
+				       &key->key[0], 16);
+				memcpy(wsm_key->tkipPairwiseKey.txMicKey, &key->key[16], 8);
+				memcpy(wsm_key->tkipPairwiseKey.rxMicKey, &key->key[24], 8);
+				sta_printk(XRADIO_DBG_NIY, "%s: TKIP_PAIRWISE keylen=%d!\n",
+				       __func__, key->keylen);
+			} else {
+				size_t mic_offset =
+					    (priv->mode == NL80211_IFTYPE_AP) ? 16 : 24;
+				wsm_key->type = WSM_KEY_TYPE_TKIP_GROUP;
+				memcpy(wsm_key->tkipGroupKey.tkipKeyData, &key->key[0], 16);
+				memcpy(wsm_key->tkipGroupKey.rxMicKey,
+				       &key->key[mic_offset], 8);
+
+				/* TODO: Where can I find TKIP SEQ? */
+				memset(wsm_key->tkipGroupKey.rxSeqCounter, 0, 8);
+				wsm_key->tkipGroupKey.keyId = key->keyidx;
+				sta_printk(XRADIO_DBG_NIY, "%s: TKIP_GROUP keylen=%d!\n",
+				       __func__, key->keylen);
+			}
+			break;
+		case WLAN_CIPHER_SUITE_CCMP:
+			if (pairwise) {
+				wsm_key->type = WSM_KEY_TYPE_AES_PAIRWISE;
+				memcpy(wsm_key->aesPairwiseKey.peerAddress,
+				       peer_addr, ETH_ALEN);
+				memcpy(wsm_key->aesPairwiseKey.aesKeyData, &key->key[0], 16);
+				sta_printk(XRADIO_DBG_NIY, "%s: CCMP_PAIRWISE keylen=%d!\n",
+				       __func__, key->keylen);
+			} else {
+				wsm_key->type = WSM_KEY_TYPE_AES_GROUP;
+				memcpy(wsm_key->aesGroupKey.aesKeyData, &key->key[0], 16);
+				/* TODO: Where can I find AES SEQ? */
+				memset(wsm_key->aesGroupKey.rxSeqCounter, 0, 8);
+				wsm_key->aesGroupKey.keyId = key->keyidx;
+				sta_printk(XRADIO_DBG_NIY, "%s: CCMP_GROUP keylen=%d!\n",
+				       __func__, key->keylen);
+			}
+			break;
+#ifdef CONFIG_XRADIO_WAPI_SUPPORT
+		case WLAN_CIPHER_SUITE_SMS4:
+			if (pairwise) {
+				wsm_key->type = WSM_KEY_TYPE_WAPI_PAIRWISE;
+				memcpy(wsm_key->wapiPairwiseKey.peerAddress,
+				       peer_addr, ETH_ALEN);
+				memcpy(wsm_key->wapiPairwiseKey.wapiKeyData,
+				       &key->key[0],  16);
+				memcpy(wsm_key->wapiPairwiseKey.micKeyData,
+				       &key->key[16], 16);
+				wsm_key->wapiPairwiseKey.keyId = key->keyidx;
+				sta_printk(XRADIO_DBG_NIY, "%s: WAPI_PAIRWISE keylen=%d!\n",
+				       __func__, key->keylen);
+			} else {
+				wsm_key->type = WSM_KEY_TYPE_WAPI_GROUP;
+				memcpy(wsm_key->wapiGroupKey.wapiKeyData, &key->key[0],  16);
+				memcpy(wsm_key->wapiGroupKey.micKeyData,  &key->key[16], 16);
+				wsm_key->wapiGroupKey.keyId = key->keyidx;
+				sta_printk(XRADIO_DBG_NIY, "%s: WAPI_GROUP keylen=%d!\n",
+				       __func__, key->keylen);
+			}
+			break;
+#endif /* CONFIG_XRADIO_WAPI_SUPPORT */
+		case WLAN_CIPHER_SUITE_AES_CMAC:
+			if (pairwise){
+				sta_printk(XRADIO_DBG_ERROR, "%s: WLAN_CIPHER_SUITE_AES_CMAC but pairwise %d\n",
+					__func__, pairwise);
+				ret = -EINVAL;
+				goto finally;
+			} else {
+				wsm_key->type = WSM_KEY_TYPE_IGTK_GROUP;
+				memcpy(wsm_key->igtkGroupKey.igtkKeyData, &key->key[0], 16);
+				wsm_key->igtkGroupKey.keyId = key->keyidx;
+				memset(wsm_key->igtkGroupKey.ipn, 0, 8);
+				memcpy(wsm_key->igtkGroupKey.ipn, &key->tx_pn, 6);
+				sta_printk(XRADIO_DBG_NIY, "%s: IGTK_GROUP keylen=%d!\n",
+				       __func__, key->keylen);
+
+				mgmt_policy.protectedMgmtEnable = 1;
+				mgmt_policy.unprotectedMgmtFramesAllowed = 1;
+				mgmt_policy.encryptionForAuthFrame = 1;
+				wsm_set_protected_mgmt_policy(hw_priv, &mgmt_policy, priv->if_id);
+
+				if (priv->join_status == XRADIO_JOIN_STATUS_STA) {
+					priv->is_mfp_connect = true;
+				}
+			}
+			break;
+		default:
+			sta_printk(XRADIO_DBG_ERROR, "%s: key->cipher unknown(%d)!\n",
+				   __func__, key->cipher);
+			xradio_free_key(hw_priv, idx);
+			ret = -EOPNOTSUPP;
+			goto finally;
+		}
+		ret = SYS_WARN(wsm_add_key(hw_priv, wsm_key, priv->if_id));
+		if (!ret)
+			key->hw_key_idx = idx;
+		else
+			xradio_free_key(hw_priv, idx);
+
+		if (!ret && (pairwise || wsm_key->type == WSM_KEY_TYPE_WEP_DEFAULT)) {
+				priv->unicast_cipher_type = key->cipher;
+		}
+
+		if (!ret && (pairwise || wsm_key->type == WSM_KEY_TYPE_WEP_DEFAULT)
+		    && (priv->filter4.enable & 0x2))
+			xradio_set_arpreply(dev, vif);
+#ifdef IPV6_FILTERING
+		if (!ret && (pairwise || wsm_key->type == WSM_KEY_TYPE_WEP_DEFAULT)
+		    && (priv->filter6.enable & 0x2))
+			xradio_set_na(dev, vif);
+#endif /*IPV6_FILTERING*/
+
+	} else if (cmd == DISABLE_KEY) {
+		struct wsm_remove_key wsm_key = {
+			.entryIndex = key->hw_key_idx,
+		};
+
+		if (wsm_key.entryIndex > WSM_KEY_MAX_IDX) {
+			ret = -EINVAL;
+			goto finally;
+		}
+
+		xradio_free_key(hw_priv, wsm_key.entryIndex);
+		ret = wsm_remove_key(hw_priv, &wsm_key, priv->if_id);
+	} else {
+		sta_printk(XRADIO_DBG_ERROR, "%s: Unsupported command", __func__);
+	}
+
+finally:
+	up(&hw_priv->conf_lock);
+	return ret;
+}
+
+void xradio_wep_key_work(struct work_struct *work)
+{
+	struct xradio_vif *priv =
+		container_of(work, struct xradio_vif, wep_key_work);
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	u8 queueId = xradio_queue_get_queue_id(hw_priv->pending_frame_id);
+	struct xradio_queue *queue = &hw_priv->tx_queue[queueId];
+	__le32 wep_default_key_id = __cpu_to_le32(priv->wep_default_key_id);
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	SYS_BUG(queueId >= 4);
+
+	sta_printk(XRADIO_DBG_MSG, "Setting default WEP key: %d\n",
+		   priv->wep_default_key_id);
+
+	wsm_flush_tx(hw_priv);
+	SYS_WARN(wsm_write_mib(hw_priv, WSM_MIB_ID_DOT11_WEP_DEFAULT_KEY_ID,
+			       &wep_default_key_id, sizeof(wep_default_key_id),
+			       priv->if_id));
+
+#ifdef CONFIG_XRADIO_TESTMODE
+	xradio_queue_requeue(hw_priv, queue, hw_priv->pending_frame_id, true);
+#else
+	xradio_queue_requeue(queue, hw_priv->pending_frame_id, true);
+#endif
+	wsm_unlock_tx(hw_priv);
+}
+
+int xradio_set_rts_threshold(struct ieee80211_hw *hw,
+		struct ieee80211_vif *vif, u32 value)
+{
+	struct xradio_common *hw_priv = hw->priv;
+	int ret;
+	__le32 val32;
+	struct xradio_vif *priv = xrwl_get_vif_from_ieee80211(vif);
+	int if_id = priv->if_id;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	if (!atomic_read(&priv->enabled)) {
+		sta_printk(XRADIO_DBG_NIY, "%s vif(type=%d) is not enable!\n",
+				__func__, vif->type);
+		return 0;
+	}
+
+#ifdef P2P_MULTIVIF
+	SYS_WARN(priv->if_id == XRWL_GENERIC_IF_ID);
+#endif
+
+	if (value != (u32)-1)
+		val32 = __cpu_to_le32(value);
+	else
+		val32 = 0;	/* disabled */
+
+	sta_printk(XRADIO_DBG_WARN, "%s if=%d, value=%d\n",
+				__func__, if_id, val32);
+	/* mutex_lock(&priv->conf_mutex); */
+	ret = SYS_WARN(wsm_write_mib(hw_priv, WSM_MIB_ID_DOT11_RTS_THRESHOLD,
+		&val32, sizeof(val32), if_id));
+	/* mutex_unlock(&priv->conf_mutex); */
+	return ret;
+}
+
+/* TODO: COMBO: Flush only a particular interface specific parts */
+int __xradio_flush(struct xradio_common *hw_priv, bool drop, int if_id)
+{
+	int i, ret;
+	struct xradio_vif *priv =
+		__xrwl_hwpriv_to_vifpriv(hw_priv, if_id);
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (!priv) {
+		SYS_WARN(1);
+		return -ENOMEM;
+	}
+
+	for (;;) {
+		/* TODO: correct flush handling is required when dev_stop.
+		 * Temporary workaround: 2s
+		 */
+		if (drop) {
+			for (i = 0; i < 4; ++i)
+				xradio_queue_clear(&hw_priv->tx_queue[i], if_id);
+		} else if (!hw_priv->bh_error) {
+			ret = wait_event_timeout(
+				hw_priv->tx_queue_stats.wait_link_id_empty,
+				xradio_queue_stats_is_empty(&hw_priv->tx_queue_stats,
+							    -1, if_id),
+				2 * HZ);
+		} else { /* don't wait when bh error */
+			sta_printk(XRADIO_DBG_ERROR, " %s:bh_error occur.\n", __func__);
+			ret = -1;
+			break;
+		}
+
+		if (!drop && unlikely(ret <= 0)) {
+			sta_printk(XRADIO_DBG_ERROR, " %s: timeout...\n", __func__);
+			ret = -ETIMEDOUT;
+			break;
+		} else {
+			ret = 0;
+		}
+
+		wsm_vif_lock_tx(priv);
+		if (unlikely(!xradio_queue_stats_is_empty(&hw_priv->tx_queue_stats,
+				  -1, if_id))) {
+			/* Highly unlekely: WSM requeued frames. */
+			wsm_unlock_tx(hw_priv);
+			continue;
+		}
+		wsm_unlock_tx(hw_priv);
+		break;
+	}
+	return ret;
+}
+
+void xradio_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			  bool drop)
+{
+	struct xradio_common *hw_priv = hw->priv;
+	struct xradio_vif *priv = xrwl_get_vif_from_ieee80211(vif);
+	int suspend_lock_state;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	suspend_lock_state = atomic_cmpxchg(&hw_priv->suspend_lock_state,
+								XRADIO_SUSPEND_LOCK_IDEL, XRADIO_SUSPEND_LOCK_OTHERS);
+	if (suspend_lock_state == XRADIO_SUSPEND_LOCK_SUSPEND) {
+		sta_printk(XRADIO_DBG_WARN,
+			   "%s:refuse because of suspend\n", __func__);
+		return;
+	}
+
+	down(&hw_priv->conf_lock);
+	atomic_set(&hw_priv->suspend_lock_state, XRADIO_SUSPEND_LOCK_IDEL);
+	/*TODO:COMBO: reenable this part of code when flush callback
+	 * is implemented per vif */
+	/*switch (hw_priv->mode) {
+	case NL80211_IFTYPE_MONITOR:
+		drop = true;
+		break;
+	case NL80211_IFTYPE_AP:
+		if (!hw_priv->enable_beacon)
+			drop = true;
+		break;
+	}*/
+
+	if (!(hw_priv->if_id_slot & BIT(priv->if_id)))
+		goto exit;
+	if (!atomic_read(&priv->enabled)) {
+		sta_printk(XRADIO_DBG_NIY, "%s vif(type=%d) is not enable!\n",
+				__func__, vif->type);
+		goto exit;
+	}
+	up(&hw_priv->conf_lock);
+	__xradio_flush(hw_priv, drop, priv->if_id);
+	return;
+
+exit:
+	up(&hw_priv->conf_lock);
+	return;
+}
+
+#ifdef MONITOR_MODE
+int xradio_enable_monitoring(struct xradio_vif *priv,
+				     struct ieee80211_channel *chan)
+{
+
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+
+#ifdef SUPPORT_HT40
+
+	struct wsm_start start = {
+		.mode = WSM_START_MODE_MONITOR,
+		.PhyModeCfg.BandCfg = chan->band,
+		.channelNumber = chan->hw_value,
+	};
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+#else
+
+	struct wsm_start start = {
+		.mode = WSM_START_MODE_MONITOR,
+		.band = (chan->band == NL80211_BAND_5GHZ) ?
+				WSM_PHY_BAND_5G : WSM_PHY_BAND_2_4G,
+		.channelNumber = chan->hw_value,
+	};
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+#endif
+
+	SYS_WARN(hw_priv->monitor_if_id < 0);
+	SYS_WARN(priv->join_status > XRADIO_JOIN_STATUS_MONITOR);
+	priv->join_status = XRADIO_JOIN_STATUS_MONITOR;
+	hw_priv->monitor_running = true;
+
+	return wsm_start(hw_priv, &start, hw_priv->monitor_if_id);
+}
+
+int xradio_disable_monitoring(struct xradio_vif *priv)
+{
+	int ret;
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	struct wsm_reset reset = {
+		.reset_statistics = true,
+	};
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	SYS_WARN(priv->join_status != XRADIO_JOIN_STATUS_MONITOR);
+	SYS_WARN(hw_priv->monitor_if_id < 0);
+	priv->join_status = XRADIO_JOIN_STATUS_PASSIVE;
+	hw_priv->monitor_if_id = -1;
+	hw_priv->monitor_running = false;
+
+	ret = wsm_reset(hw_priv, &reset, hw_priv->monitor_if_id);
+	return ret;
+}
+
+void xradio_channel_switch(struct xradio_common *hw_priv,
+			   struct ieee80211_channel *chan)
+{
+	struct wsm_switch_channel switch_arg = {
+		.channelMode = 1,
+		.channelSwitchCount = 0,
+		.newChannelNumber = chan->hw_value,
+	};
+
+	WARN_ON(hw_priv->monitor_if_id == -1);
+	wsm_switch_channel(hw_priv, &switch_arg, hw_priv->monitor_if_id);
+
+}
+#endif
+int xradio_remain_on_channel(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif,
+			     struct ieee80211_channel *chan,
+			     enum nl80211_channel_type channel_type,
+			     int duration, u64 cookie)
+{
+	int ret;
+	struct xradio_common *hw_priv = hw->priv;
+	struct xradio_vif *priv = xrwl_get_vif_from_ieee80211(vif);
+	int if_id = priv->if_id;
+	int suspend_lock_state;
+#ifdef	TES_P2P_0002_ROC_RESTART
+	struct timeval TES_P2P_0002_tmval;
+#endif
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+#ifdef	TES_P2P_0002_ROC_RESTART
+	xr_do_gettimeofday(&TES_P2P_0002_tmval);
+	TES_P2P_0002_roc_dur = (s32) duration;
+	TES_P2P_0002_roc_sec = (s32) TES_P2P_0002_tmval.tv_sec;
+	TES_P2P_0002_roc_usec = (s32) TES_P2P_0002_tmval.tv_usec;
+#endif
+
+	suspend_lock_state = atomic_cmpxchg(&hw_priv->suspend_lock_state,
+								XRADIO_SUSPEND_LOCK_IDEL, XRADIO_SUSPEND_LOCK_OTHERS);
+	if (suspend_lock_state == XRADIO_SUSPEND_LOCK_SUSPEND) {
+		sta_printk(XRADIO_DBG_WARN,
+			   "%s:refuse because of suspend\n", __func__);
+		return -EBUSY;
+	}
+
+	down(&hw_priv->scan.lock);
+	atomic_set(&hw_priv->suspend_lock_state, XRADIO_SUSPEND_LOCK_IDEL);
+	if (!atomic_read(&priv->enabled)) {
+		sta_printk(XRADIO_DBG_NIY, "%s vif(type=%d) is not enable!\n",
+				__func__, vif->type);
+		up(&hw_priv->scan.lock);
+		return 0;
+	}
+
+#ifdef ROC_DEBUG
+	sta_printk(XRADIO_DBG_WARN, "ROC IN %d ch %d\n",
+		   priv->if_id, chan->hw_value);
+#endif
+	ret = SYS_WARN(__xradio_flush(hw_priv, false, if_id));
+	down(&hw_priv->conf_lock);
+	hw_priv->roc_if_id = priv->if_id;
+	xradio_enable_listening(priv, chan);
+
+	if (!ret) {
+		atomic_set(&hw_priv->remain_on_channel, 1);
+		queue_delayed_work(hw_priv->spare_workqueue, &hw_priv->rem_chan_timeout,
+				   duration * HZ / 1000);
+		priv->join_status = XRADIO_JOIN_STATUS_MONITOR;
+		mac80211_ready_on_channel(hw);
+	} else {
+		hw_priv->roc_if_id = -1;
+		up(&hw_priv->scan.lock);
+	}
+
+#ifdef ROC_DEBUG
+	sta_printk(XRADIO_DBG_WARN, "ROC OUT %d\n", priv->if_id);
+#endif
+	/* set the channel to supplied ieee80211_channel pointer, if it
+	   is not set. This is to remove the crash while sending a probe res
+	   in listen state. Later channel will updated on
+	   IEEE80211_CONF_CHANGE_CHANNEL event */
+	if (!hw_priv->channel) {
+		hw_priv->channel = chan;
+	}
+	hw_priv->roc_cookie = cookie;
+	up(&hw_priv->conf_lock);
+	return ret;
+}
+
+int xradio_cancel_remain_on_channel(struct ieee80211_hw *hw)
+{
+	struct xradio_common *hw_priv = hw->priv;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	sta_printk(XRADIO_DBG_NIY, "Cancel remain on channel\n");
+#ifdef TES_P2P_0002_ROC_RESTART
+	if (TES_P2P_0002_state == TES_P2P_0002_STATE_GET_PKTID) {
+		TES_P2P_0002_state = TES_P2P_0002_STATE_IDLE;
+		sta_printk(XRADIO_DBG_WARN, "[ROC_RESTART_STATE_IDLE][Cancel ROC]\n");
+	}
+#endif
+
+	if (atomic_read(&hw_priv->remain_on_channel))
+		cancel_delayed_work_sync(&hw_priv->rem_chan_timeout);
+
+	if (atomic_read(&hw_priv->remain_on_channel))
+		xradio_rem_chan_timeout(&hw_priv->rem_chan_timeout.work);
+
+	return 0;
+}
+
+/* ******************************************************************** */
+/* WSM callbacks							*/
+
+void xradio_channel_switch_cb(struct xradio_common *hw_priv)
+{
+/*   wsm_unlock_tx(hw_priv);*/
+}
+
+void xradio_free_event_queue(struct xradio_common *hw_priv)
+{
+	LIST_HEAD(list);
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	spin_lock(&hw_priv->event_queue_lock);
+	list_splice_init(&hw_priv->event_queue, &list);
+	spin_unlock(&hw_priv->event_queue_lock);
+
+	__xradio_free_event_queue(&list);
+}
+
+void xradio_event_handler(struct work_struct *work)
+{
+	struct xradio_common *hw_priv =
+	    container_of(work, struct xradio_common, event_handler);
+	struct xradio_vif *priv;
+	struct xradio_wsm_event *event;
+	LIST_HEAD(list);
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	spin_lock(&hw_priv->event_queue_lock);
+	list_splice_init(&hw_priv->event_queue, &list);
+	spin_unlock(&hw_priv->event_queue_lock);
+
+	down(&hw_priv->conf_lock);
+	list_for_each_entry(event, &list, link) {
+		priv = __xrwl_hwpriv_to_vifpriv(hw_priv, event->if_id);
+		if (!priv) {
+			sta_printk(XRADIO_DBG_WARN, "[CQM] Event for non existing "
+				   "interface, ignoring.\n");
+			continue;
+		}
+		switch (event->evt.eventId) {
+		case WSM_EVENT_ERROR:
+			/* I even don't know what is it about.. */
+			sta_printk(XRADIO_DBG_ERROR, "%s FW error=0x%x\n",
+					__func__, event->evt.eventData);
+			break;
+		case WSM_EVENT_BSS_LOST:
+			{
+				spin_lock(&priv->bss_loss_lock);
+				if (priv->bss_loss_status > XRADIO_BSS_LOSS_NONE) {
+					spin_unlock(&priv->bss_loss_lock);
+					break;
+				}
+				priv->bss_loss_status = XRADIO_BSS_LOSS_CHECKING;
+				spin_unlock(&priv->bss_loss_lock);
+				sta_printk(XRADIO_DBG_WARN,
+					   "[CQM] BSS lost, Beacon miss=%d, event=%x.\n",
+					   (event->evt.eventData >> 8) & 0xff,
+					   event->evt.eventData & 0xff);
+
+				cancel_delayed_work_sync(&priv->bss_loss_work);
+				cancel_delayed_work_sync(&priv->connection_loss_work);
+				if (!down_trylock(&hw_priv->scan.lock)) {
+					up(&hw_priv->scan.lock);
+					priv->delayed_link_loss = 0;
+					queue_delayed_work(hw_priv->workqueue,
+							&priv->bss_loss_work, HZ/10); /* 100ms */
+				} else {
+					/* Scan is in progress. Delay reporting. */
+					/* Scan complete will trigger bss_loss_work */
+					priv->delayed_link_loss = 1;
+					/* Also we're starting watchdog. */
+					queue_delayed_work(hw_priv->workqueue,
+							&priv->bss_loss_work, 10 * HZ);
+				}
+				break;
+			}
+		case WSM_EVENT_BSS_REGAINED:
+			{
+				sta_printk(XRADIO_DBG_WARN, "[CQM] BSS regained.\n");
+				priv->delayed_link_loss = 0;
+				spin_lock(&priv->bss_loss_lock);
+				priv->bss_loss_status = XRADIO_BSS_LOSS_NONE;
+				spin_unlock(&priv->bss_loss_lock);
+				cancel_delayed_work_sync(&priv->bss_loss_work);
+				cancel_delayed_work_sync(&priv->connection_loss_work);
+				break;
+			}
+		case WSM_EVENT_RADAR_DETECTED:
+			sta_printk(XRADIO_DBG_WARN,
+				"%s WSM_EVENT_RADAR_DETECTED\n", __func__);
+			/*STUB();*/
+			break;
+		case WSM_EVENT_RCPI_RSSI:
+			{
+				/* RSSI: signed Q8.0, RCPI: unsigned Q7.1
+				 * RSSI = RCPI / 2 - 110 */
+				int rcpiRssi = (int)(event->evt.eventData & 0xFF);
+				int cqm_evt;
+
+				if (priv->cqm_use_rssi)
+					rcpiRssi = (s8)rcpiRssi;
+				else
+					rcpiRssi =  rcpiRssi / 2 - 110;
+
+				cqm_evt = (rcpiRssi <= priv->cqm_rssi_thold) ?
+					NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW :
+					NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH;
+				sta_printk(XRADIO_DBG_NIY, "[CQM] RSSI event: %d", rcpiRssi);
+				mac80211_cqm_rssi_notify(priv->vif, cqm_evt, rcpiRssi, GFP_KERNEL);
+				break;
+			}
+		case WSM_EVENT_BT_INACTIVE:
+			if (hw_priv->is_BT_Present) {
+				u8 bt_link_type = ((event->evt.eventData>>16) & 0xff);
+				bool is_bt_block = xradio_is_bt_block(hw_priv);
+				hw_priv->BT_active &= ~xradio_bt_active_bit(bt_link_type);
+				if (is_bt_block && !xradio_is_bt_block(hw_priv)) {
+					xradio_proc_wakeup(hw_priv);
+				}
+				sta_printk(XRADIO_DBG_NIY,
+					"%s WSM_EVENT_BT_INACTIVE, type=%u\n",
+					__func__, bt_link_type);
+			} else {
+				sta_printk(XRADIO_DBG_WARN,
+					"%s WSM_EVENT_BT_INACTIVE, but BT is NOT Present!\n",
+					__func__);
+			}
+			/*STUB();*/
+			break;
+		case WSM_EVENT_BT_ACTIVE:
+			if (hw_priv->is_BT_Present) {
+				u8 bt_link_type = ((event->evt.eventData>>16) & 0xff);
+				u16 bt_duration = (event->evt.eventData & 0xffff);
+				del_timer_sync(&hw_priv->BT_timer);
+				if (xradio_bt_block_type(bt_link_type)) {
+					unsigned long new_time = 0;
+					if (bt_duration > BT_MAX_BLOCK_TIME) {
+						sta_printk(XRADIO_DBG_WARN,
+						"%s WSM_EVENT_BT_ACTIVE, type=%u, Duration=%u\n",
+						__func__, bt_link_type, bt_duration);
+						bt_duration = BT_MAX_BLOCK_TIME;
+					}
+					new_time = jiffies + msecs_to_jiffies(bt_duration);
+					if (!xradio_is_bt_block(hw_priv)) {
+						hw_priv->BT_duration = new_time;  /* init */
+					} else if (time_before(hw_priv->BT_duration, new_time)) {
+						hw_priv->BT_duration = new_time;  /* updata */
+					}
+				}
+				hw_priv->BT_active |= xradio_bt_active_bit(bt_link_type);
+				if (xradio_is_bt_block(hw_priv)) {
+					if (time_before(jiffies, hw_priv->BT_duration))
+						mod_timer(&hw_priv->BT_timer, hw_priv->BT_duration);
+					else
+						mod_timer(&hw_priv->BT_timer, jiffies + 1);
+				}
+				sta_printk(XRADIO_DBG_NIY,
+					"%s WSM_EVENT_BT_ACTIVE, type=%u, Duration=%ums, time=%ld\n",
+					__func__, bt_link_type, bt_duration, hw_priv->BT_duration);
+			} else {
+				sta_printk(XRADIO_DBG_WARN,
+					"%s WSM_EVENT_BT_ACTIVE, but BT is NOT Present!\n",
+					__func__);
+			}
+			/*STUB();*/
+			break;
+		case WSM_EVENT_PAS_EVENT:
+			sta_printk(XRADIO_DBG_WARN,
+				"%s WSM_EVENT_PAS_EVENT\n", __func__);
+			break;
+		case WSM_EVENT_INACTIVITY:
+			{
+				int link_id = ffs((u32)(event->evt.eventData)) - 1;
+				struct sk_buff *skb;
+				struct ieee80211_mgmt *deauth;
+				struct xradio_link_entry *entry = NULL;
+
+				sta_printk(XRADIO_DBG_WARN, "Inactivity Event Recieved for "
+						"link_id %d\n", link_id);
+				skb = xr_alloc_skb(sizeof(struct ieee80211_mgmt) + 64);
+				if (!skb)
+					break;
+				skb_reserve(skb, 64);
+				xrwl_unmap_link(priv, link_id);
+
+				deauth = (struct ieee80211_mgmt *)skb_put(skb, sizeof(struct ieee80211_mgmt));
+				SYS_WARN(!deauth);
+				entry = &priv->link_id_db[link_id - 1];
+				deauth->duration = 0;
+				memcpy(deauth->da, priv->vif->addr, ETH_ALEN);
+				memcpy(deauth->sa, entry->mac/*priv->link_id_db[i].mac*/, ETH_ALEN);
+				memcpy(deauth->bssid, priv->vif->addr, ETH_ALEN);
+				deauth->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+								    IEEE80211_STYPE_DEAUTH);
+				deauth->u.deauth.reason_code = WLAN_REASON_DEAUTH_LEAVING;
+				deauth->seq_ctrl = 0;
+				mac80211_rx_irqsafe(priv->hw, skb);
+				sta_printk(XRADIO_DBG_WARN, "Inactivity Deauth Frame sent" \
+					   " for MAC SA %pM and DA %pM\n",
+					   deauth->sa, deauth->da);
+				queue_work(priv->hw_priv->workqueue, &priv->set_tim_work);
+				break;
+			}
+		case WSM_EVENT_PS_MODE_ERROR:
+			sta_printk(XRADIO_DBG_WARN, "%s EVENT_PS_MODE_ERROR\n", __func__);
+#if 0
+			{
+				if (!priv->uapsd_info.uapsdFlags &&
+					(priv->user_pm_mode != WSM_PSM_PS)) {
+					struct wsm_set_pm pm = priv->powersave_mode;
+					int ret = 0;
+
+					priv->powersave_mode.pmMode = WSM_PSM_ACTIVE;
+					ret = xradio_set_pm (priv, &priv->powersave_mode);
+					if (ret)
+						priv->powersave_mode = pm;
+				}
+				break;
+			}
+#else
+			break;
+#endif
+		}
+	}
+	up(&hw_priv->conf_lock);
+	__xradio_free_event_queue(&list);
+}
+
+void xradio_bss_loss_work(struct work_struct *work)
+{
+	struct xradio_vif *priv =
+	    container_of(work, struct xradio_vif, bss_loss_work.work);
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	int timeout;		/* in beacons */
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	timeout = priv->cqm_link_loss_count - priv->cqm_beacon_loss_count;
+	/* Skip the confimration procedure in P2P case */
+	if (priv->vif->p2p)
+		goto report;
+
+	spin_lock(&priv->bss_loss_lock);
+	if (priv->bss_loss_status == XRADIO_BSS_LOSS_CONFIRMING) {
+		/*do loss report next time.*/
+		priv->bss_loss_status = XRADIO_BSS_LOSS_CONFIRMED;
+		spin_unlock(&priv->bss_loss_lock);
+		/*wait for more 1s to loss confirm.*/
+		queue_delayed_work(hw_priv->workqueue, &priv->bss_loss_work, 1 * HZ);
+		return;
+	} else if (priv->bss_loss_status == XRADIO_BSS_LOSS_NONE) {
+		spin_unlock(&priv->bss_loss_lock);
+		/*link is alive.*/
+		cancel_delayed_work_sync(&priv->connection_loss_work);
+		return;
+	} else if (priv->bss_loss_status == XRADIO_BSS_LOSS_CHECKING) {
+		/* it mean no confirming packets, just report loss. */
+	}
+	spin_unlock(&priv->bss_loss_lock);
+
+report:
+	if (priv->cqm_beacon_loss_count) {
+		sta_printk(XRADIO_DBG_WARN, "[CQM] Beacon loss.\n");
+		if (timeout <= 0)
+			timeout = 0;
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+		/*ieee80211_cqm_beacon_miss_notify(priv->vif, GFP_KERNEL);*/
+#endif /* CONFIG_XRADIO_USE_EXTENSIONS */
+	} else {
+		timeout = 0;
+	}
+
+	cancel_delayed_work_sync(&priv->connection_loss_work);
+	queue_delayed_work(hw_priv->workqueue, &priv->connection_loss_work,
+			   timeout * HZ / 10);
+
+	spin_lock(&priv->bss_loss_lock);
+	priv->bss_loss_status = XRADIO_BSS_LOSS_NONE;
+	spin_unlock(&priv->bss_loss_lock);
+}
+
+void xradio_connection_loss_work(struct work_struct *work)
+{
+	struct xradio_vif *priv =
+	  container_of(work, struct xradio_vif, connection_loss_work.work);
+	sta_printk(XRADIO_DBG_ERROR, "[CQM] if%d Reporting connection loss.\n",
+		   priv->if_id);
+	mac80211_connection_loss(priv->vif);
+}
+
+void xradio_tx_failure_work(struct work_struct *work)
+{
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+	/*
+	struct xradio_vif *priv =
+		container_of(work, struct xradio_vif, tx_failure_work);
+	sta_printk(XRADIO_DBG_WARN, "[CQM] Reporting TX failure.\n");
+	ieee80211_cqm_tx_fail_notify(priv->vif, GFP_KERNEL);
+	*/
+#endif /* CONFIG_XRADIO_USE_EXTENSIONS */
+}
+
+#ifdef CONFIG_XRADIO_TESTMODE
+/**
+ * xradio_device_power_calc- Device power calculation
+ * from values fetch from SDD File.
+ *
+ * @priv: the private structure
+ * @Max_output_power: Power fetch from SDD
+ * @fe_cor: front-end loss correction
+ * @band: Either 2GHz or 5GHz
+ *
+ */
+void xradio_device_power_calc(struct xradio_common *hw_priv,
+		s16 max_output_power, s16 fe_cor, u32 band)
+{
+	s16 power_calc;
+
+	power_calc = max_output_power - fe_cor;
+	if ((power_calc % 16) != 0)
+		power_calc += 16;
+
+	hw_priv->txPowerRange[band].max_power_level = power_calc/16;
+	/*
+	 * 12dBm is control range supported by firmware.
+	 * This means absolute min power is
+	 * max_power_level - 12.
+	 */
+	hw_priv->txPowerRange[band].min_power_level =
+		hw_priv->txPowerRange[band].max_power_level - 12;
+	hw_priv->txPowerRange[band].stepping = 1;
+
+}
+#endif
+/* ******************************************************************** */
+#ifdef CONFIG_XRADIO_TESTMODE
+#define SDD_MAX_OUTPUT_POWER_2G4_ELT_ID 0xE3
+#define SDD_MAX_OUTPUT_POWER_5G_ELT_ID  0xE4
+#define SDD_FE_COR_2G4_ELT_ID   0x30
+#define SDD_FE_COR_5G_ELT_ID    0x31
+#define MIN(x, y, z) (x < y ? (x < z ? x : z) : (y < z ? y : z))
+static int xradio_test_pwrlevel(struct xradio_common *hw_priv)
+{
+	int ret = -1;
+	int parsedLength = 0;
+	struct xradio_sdd *pElement = (struct xradio_sdd *)hw_priv->sdd->data;
+
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	parsedLength += (FIELD_OFFSET(struct xradio_sdd, data) + pElement->length);
+	pElement = FIND_NEXT_ELT(pElement);
+
+	while (parsedLength <= hw_priv->sdd->size) {
+		switch (pElement->id) {
+		case SDD_MAX_OUTPUT_POWER_2G4_ELT_ID:
+			max_output_power_2G = *((s16 *)pElement->data);
+			break;
+		case SDD_FE_COR_2G4_ELT_ID:
+			fe_cor_2G = *((s16 *)pElement->data);
+			break;
+		case SDD_MAX_OUTPUT_POWER_5G_ELT_ID:
+			max_output_power_5G = *((s16 *)(pElement->data + 4));
+			break;
+		case SDD_FE_COR_5G_ELT_ID:
+			fe_cor_5G = MIN(*((s16 *)pElement->data),
+					*((s16 *)(pElement->data + 2)),
+					*((s16 *)(pElement->data + 4)));
+			fe_cor_5G = MIN(fe_cor_5G,
+					*((s16 *)(pElement->data + 6)),
+					*((s16 *)(pElement->data + 8)));
+			break;
+		default:
+			break;
+		}
+		parsedLength += (FIELD_OFFSET(struct xradio_sdd, data) +
+				 pElement->length);
+		pElement = FIND_NEXT_ELT(pElement);
+	}
+
+	/* Max/Min Power Calculation for 2.4G */
+	xradio_device_power_calc(hw_priv, max_output_power_2G, fe_cor_2G,
+				 NL80211_BAND_2GHZ);
+	/* Max/Min Power Calculation for 5G */
+	xradio_device_power_calc(hw_priv, max_output_power_5G, fe_cor_5G,
+				 NL80211_BAND_5GHZ);
+	for (i = 0; i < 2; ++i) {
+		sta_printk(XRADIO_DBG_MSG, "Power Values Read from SDD %s:"
+			   "min_power_level[%d]: %d max_power_level[%d]:"
+			   "%d stepping[%d]: %d\n", __func__, i,
+			   hw_priv->txPowerRange[i].min_power_level, i,
+			   hw_priv->txPowerRange[i].max_power_level, i,
+			   hw_priv->txPowerRange[i].stepping);
+	}
+	return 0;
+}
+#endif
+
+/* Internal API								*/
+int xradio_setup_mac(struct xradio_common *hw_priv)
+{
+	int ret = 0, if_id;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (hw_priv->sdd) {
+		struct wsm_configuration cfg = {
+			.dot11StationId = &hw_priv->mac_addr[0],
+			.dpdData = hw_priv->sdd->data,
+			.dpdData_size = hw_priv->sdd->size,
+		};
+		for (if_id = 0; if_id < xrwl_get_nr_hw_ifaces(hw_priv);
+		     if_id++) {
+			/* Set low-power mode. */
+			ret |= SYS_WARN(wsm_configuration(hw_priv, &cfg,
+				       if_id));
+		}
+#ifdef CONFIG_XRADIO_TESTMODE
+		/* Parse SDD file for power level test */
+		xradio_test_pwrlevel(hw_priv);
+#endif
+		/* wsm_configuration only once, so release it */
+		release_firmware(hw_priv->sdd);
+		hw_priv->sdd = NULL;
+	}
+
+	/*
+	 * It will be different after reinit. So we reset it.
+	 * Cause only mac_address of if0 will be changed, we reset it only.
+	 */
+	if (compare_ether_addr(hw_priv->mac_addr, hw_priv->addresses[0].addr) != 0)
+		wsm_write_mib(hw_priv, WSM_MIB_ID_CHANGE_MAC,
+			hw_priv->addresses[0].addr, ETH_ALEN, 0);
+
+	/* BUG:TX output power is not set untill config_xradio is called.
+	 * This would lead to 0 power set in fw and would effect scan & p2p-find
+	 * Setting to default value here from sdd which would be overwritten when
+	 * we make connection to AP.This value is used only during scan & p2p-ops
+	 * untill AP connection is made */
+	/*BUG:TX output power: Hardcoding to 20dbm if CCX is not enabled*/
+	/*TODO: This might change*/
+	if (!hw_priv->output_power)
+		hw_priv->output_power = 20;
+	sta_printk(XRADIO_DBG_MSG, "%s output power %d\n",
+		   __func__, hw_priv->output_power);
+
+	return ret;
+}
+
+void xradio_pending_offchanneltx_work(struct work_struct *work)
+{
+	struct xradio_vif *priv =
+	container_of(work, struct xradio_vif, pending_offchanneltx_work.work);
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	down(&hw_priv->conf_lock);
+#ifdef ROC_DEBUG
+	sta_printk(XRADIO_DBG_WARN, "OFFCHAN PEND IN\n");
+#endif
+	xradio_disable_listening(priv);
+	hw_priv->roc_if_id = -1;
+#ifdef ROC_DEBUG
+	sta_printk(XRADIO_DBG_WARN, "OFFCHAN PEND OUT\n");
+#endif
+	up(&hw_priv->scan.lock);
+	up(&hw_priv->conf_lock);
+}
+
+void xradio_offchannel_work(struct work_struct *work)
+{
+	struct xradio_vif *priv =
+		container_of(work, struct xradio_vif, offchannel_work);
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	u8 queueId = xradio_queue_get_queue_id(hw_priv->pending_frame_id);
+	struct xradio_queue *queue = &hw_priv->tx_queue[queueId];
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	SYS_BUG(queueId >= 4);
+	SYS_BUG(!hw_priv->channel);
+
+	if (unlikely(down_trylock(&hw_priv->scan.lock))) {
+		int ret = 0;
+		sta_printk(XRADIO_DBG_ERROR,
+			   "xradio_offchannel_work***** drop frame\n");
+#ifdef CONFIG_XRADIO_TESTMODE
+		xradio_queue_remove(hw_priv, queue,
+				hw_priv->pending_frame_id);
+#else
+		ret = xradio_queue_remove(queue, hw_priv->pending_frame_id);
+#endif
+		if (ret)
+			sta_printk(XRADIO_DBG_ERROR, "xradio_offchannel_work: "
+				       "queue_remove failed %d\n", ret);
+		wsm_unlock_tx(hw_priv);
+		LOG_FILE(1, "xradio_offchannel_work error\n");
+		/*up(&hw_priv->scan.lock);*/
+		mac80211_connection_loss(priv->vif);
+		sta_printk(XRADIO_DBG_ERROR, "lock %d\n", hw_priv->scan.lock.count);
+
+		return;
+	}
+	down(&hw_priv->conf_lock);
+#ifdef ROC_DEBUG
+	sta_printk(XRADIO_DBG_WARN, "OFFCHAN WORK IN %d\n", priv->if_id);
+#endif
+	/*hw_priv->roc_if_id = priv->if_id;*/
+	if (likely(!priv->join_status) && (2 == priv->if_id)) {
+		wsm_vif_flush_tx(priv);
+		xradio_enable_listening(priv, hw_priv->channel);
+		/* xradio_update_filtering(priv); */
+	}
+	if (unlikely(!priv->join_status))
+#ifdef CONFIG_XRADIO_TESTMODE
+		xradio_queue_remove(hw_priv, queue,
+				hw_priv->pending_frame_id);
+#else
+		xradio_queue_remove(queue, hw_priv->pending_frame_id);
+#endif /*CONFIG_XRADIO_TESTMODE*/
+	else
+#ifdef CONFIG_XRADIO_TESTMODE
+		xradio_queue_requeue(hw_priv, queue,
+			hw_priv->pending_frame_id, false);
+#else
+		xradio_queue_requeue(queue, hw_priv->pending_frame_id, false);
+#endif
+
+	if (likely(priv->join_status) && (2 == priv->if_id)) {
+		hw_priv->roc_if_id = priv->if_id;
+		queue_delayed_work(hw_priv->workqueue,
+				&priv->pending_offchanneltx_work, 204 * HZ/1000);
+	} else {
+		up(&hw_priv->scan.lock);
+	}
+#ifdef ROC_DEBUG
+	sta_printk(XRADIO_DBG_WARN, "OFFCHAN WORK OUT %d\n", priv->if_id);
+#endif
+	up(&hw_priv->conf_lock);
+	wsm_unlock_tx(hw_priv);
+}
+
+void xradio_join_work(struct work_struct *work)
+{
+	struct xradio_vif *priv =
+		container_of(work, struct xradio_vif, join_work);
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	u8 queueId = xradio_queue_get_queue_id(hw_priv->pending_frame_id);
+	struct xradio_queue *queue = &hw_priv->tx_queue[queueId];
+	const struct xradio_txpriv *txpriv = NULL;
+	struct sk_buff *skb = NULL;
+	const struct wsm_tx *wsm;
+	const struct ieee80211_hdr *frame;
+	const u8 *bssid;
+	struct cfg80211_bss *bss;
+	const u8 *ssidie;
+	const u8 *dtimie;
+	const struct ieee80211_tim_ie *tim = NULL;
+	struct wsm_protected_mgmt_policy mgmt_policy;
+	struct wsm_operational_mode mode = {
+		.power_mode = wsm_power_mode_quiescent,
+		.disableMoreFlagUsage = true,
+	};
+	/*
+	struct wsm_reset reset = {
+		.reset_statistics = true,
+	}; */
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	SYS_BUG(queueId >= 4);
+	if (xradio_queue_get_skb(queue,	hw_priv->pending_frame_id,
+			&skb, &txpriv)) {
+		wsm_unlock_tx(hw_priv);
+		return;
+	}
+	wsm = (struct wsm_tx *)&skb->data[0];
+	frame = (struct ieee80211_hdr *)&skb->data[txpriv->offset];
+	bssid = &frame->addr1[0]; /* AP SSID in a 802.11 frame */
+
+	SYS_BUG(!wsm);
+	SYS_BUG(!hw_priv->channel);
+
+	cancel_delayed_work_sync(&priv->join_timeout);
+	if (unlikely(priv->join_status)) {
+		sta_printk(XRADIO_DBG_WARN, "%s, pre join_status=%d.\n",
+			  __func__, priv->join_status);
+		wsm_lock_tx(hw_priv);
+		xradio_unjoin_work(&priv->unjoin_work);
+	}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	bss = cfg80211_get_bss(hw_priv->hw->wiphy, hw_priv->channel,
+			bssid, NULL, 0, IEEE80211_BSS_TYPE_ANY, IEEE80211_PRIVACY_ANY);
+#else
+	bss = cfg80211_get_bss(hw_priv->hw->wiphy, hw_priv->channel,
+			bssid, NULL, 0, 0, 0);
+#endif
+	if (!bss) {
+#ifdef CONFIG_XRADIO_TESTMODE
+		xradio_queue_remove(hw_priv, queue, hw_priv->pending_frame_id);
+#else
+		xradio_queue_remove(queue, hw_priv->pending_frame_id);
+#endif /*CONFIG_XRADIO_TESTMODE*/
+		wsm_unlock_tx(hw_priv);
+		return;
+	}
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
+	ssidie = ieee80211_bss_get_ie(bss, WLAN_EID_SSID);
+	dtimie = ieee80211_bss_get_ie(bss, WLAN_EID_TIM);
+#else
+	ssidie = cfg80211_find_ie(WLAN_EID_SSID,
+		bss->information_elements,
+		bss->len_information_elements);
+	dtimie = cfg80211_find_ie(WLAN_EID_TIM,
+		bss->information_elements,
+		bss->len_information_elements);
+#endif
+	if (dtimie)
+		tim = (struct ieee80211_tim_ie *)&dtimie[2];
+
+	down(&hw_priv->conf_lock);
+	{
+
+#ifdef SUPPORT_HT40
+
+		const u8 *bss_ht_info_ie;
+
+		struct wsm_join join = {
+			.mode = (bss->capability & WLAN_CAPABILITY_IBSS) ?
+				WSM_JOIN_MODE_IBSS : WSM_JOIN_MODE_BSS,
+			.probeForJoin = 1,
+			/* dtimPeriod will be updated after association */
+			.dtimPeriod = 1,
+			.beaconInterval = bss->beacon_interval,
+		};
+
+		join.PhyModeCfg.BandCfg     = hw_priv->channel->band;
+		join.PhyModeCfg.ModemFlags  = (hw_priv->channel->band ==
+			NL80211_BAND_5GHZ) ? (MODEM_F_A_OFDM|MODEM_F_N_OFDM) :
+				(MODEM_F_B_DSSS|MODEM_F_A_OFDM|MODEM_F_N_OFDM);
+		join.PhyModeCfg.PreambleCfg = PREAMBLE_L;
+		join.PhyModeCfg.ChWidthCfg  = CHAN_WIDTH_20MHz;
+		join.PhyModeCfg.PriChCfg    = PRIMARY_CH_1ST;
+		join.PhyModeCfg.SGI_Enable  = false;
+		join.PhyModeCfg.STBC_Enable = false;
+		join.PhyModeCfg.GF_Enable   = false;
+		join.PhyModeCfg.Reserved    = 0;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
+			bss_ht_info_ie = ieee80211_bss_get_ie(bss, WLAN_EID_HT_INFORMATION);
+#else
+			bss_ht_info_ie = cfg80211_find_ie(WLAN_EID_HT_INFORMATION,
+			bss->information_elements,
+			bss->len_information_elements);
+#endif
+
+		if (bss_ht_info_ie != NULL) {
+
+			struct ieee80211_ht_operation *bss_ht_info;
+			struct ieee80211_supported_band *sband;
+
+			bss_ht_info = (struct ieee80211_ht_operation *)(bss_ht_info_ie + 2);
+
+			sband = priv->hw->wiphy->bands[hw_priv->channel->band];
+
+			sta_printk(XRADIO_DBG_WARN, "[HT40][%s]"\
+				"[bss_ht_info]:\n"\
+				"[primary_chan  :0x%08x]\n"\
+				"[ht_param      :0x%08x]\n"\
+				"[operation_mode:0x%08x]\n"\
+				"[stbc_param    :0x%08x]\n"\
+				"[basic_set[0]  :0x%08x]\n",
+				__func__,
+				bss_ht_info->primary_chan,
+				bss_ht_info->ht_param,
+				bss_ht_info->operation_mode,
+				bss_ht_info->stbc_param,
+				bss_ht_info->basic_set[0]);
+
+			if (sband->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40) {
+				switch (bss_ht_info->ht_param &
+					IEEE80211_HT_PARAM_CHA_SEC_OFFSET) {
+				case IEEE80211_HT_PARAM_CHA_SEC_ABOVE:
+					join.PhyModeCfg.ChWidthCfg = CHAN_WIDTH_40MHz;
+					join.PhyModeCfg.PriChCfg = PRIMARY_CH_2ND;
+					break;
+				case IEEE80211_HT_PARAM_CHA_SEC_BELOW:
+					join.PhyModeCfg.ChWidthCfg = CHAN_WIDTH_40MHz;
+					join.PhyModeCfg.PriChCfg = PRIMARY_CH_1ST;
+					break;
+				}
+
+			} else {
+				sta_printk(XRADIO_DBG_WARN, "[HT40][%s]"\
+						"[ONLY_USE_HT20]\n", __func__);
+			}
+		} else {
+			sta_printk(XRADIO_DBG_WARN, "[HT40][%s]"\
+				"[bss_ht_info]: [Not HT]\n", __func__);
+		}
+
+		sta_printk(XRADIO_DBG_WARN, "[HT40][%s][PhyModeCfg:0x%04x]\n"
+			"[ModemFlags    :0x%08x]\n"
+			"[ChWidthCfg    :0x%08x]\n"
+			"[PriChCfg      :0x%08x]\n"
+			"[BandCfg       :0x%08x]\n"
+			"[STBC_Enable   :0x%08x]\n"
+			"[PreambleCfg   :0x%08x]\n"
+			"[SGI_Enable    :0x%08x]\n"
+			"GF_Enable      :0x%08x]\n",
+			__func__, *(u16 *)&join.PhyModeCfg,
+			join.PhyModeCfg.ModemFlags,
+			join.PhyModeCfg.ChWidthCfg,
+			join.PhyModeCfg.PriChCfg,
+			join.PhyModeCfg.BandCfg,
+			join.PhyModeCfg.STBC_Enable,
+			join.PhyModeCfg.PreambleCfg,
+			join.PhyModeCfg.SGI_Enable,
+			join.PhyModeCfg.GF_Enable
+			);
+
+#else
+
+		struct wsm_join join = {
+			.mode = (bss->capability & WLAN_CAPABILITY_IBSS) ?
+				WSM_JOIN_MODE_IBSS : WSM_JOIN_MODE_BSS,
+			/* default changed to LONG, by HuangLu, fix 2/5.5/11m tx fail*/
+			.preambleType = WSM_JOIN_PREAMBLE_LONG,
+			.probeForJoin = 1,
+			/* dtimPeriod will be updated after association */
+			.dtimPeriod = 1,
+			.beaconInterval = bss->beacon_interval,
+		};
+
+#endif
+
+		if (priv->if_id)
+			join.flags |= WSM_FLAG_MAC_INSTANCE_1;
+		else
+			join.flags &= ~WSM_FLAG_MAC_INSTANCE_1;
+
+		/* BT Coex related changes */
+		if (hw_priv->is_BT_Present) {
+			if (((hw_priv->conf_listen_interval * 100) %
+					bss->beacon_interval) == 0)
+				priv->listen_interval =
+					((hw_priv->conf_listen_interval * 100) /
+					bss->beacon_interval);
+			else
+				priv->listen_interval =
+					((hw_priv->conf_listen_interval * 100) /
+					bss->beacon_interval + 1);
+		}
+
+		if (tim && tim->dtim_period > 1) {
+			join.dtimPeriod = tim->dtim_period;
+			priv->join_dtim_period = tim->dtim_period;
+		}
+		priv->beacon_int = bss->beacon_interval;
+		sta_printk(XRADIO_DBG_NIY, "Join DTIM: %d, interval: %d\n",
+				join.dtimPeriod, priv->beacon_int);
+
+		hw_priv->is_go_thru_go_neg = false;
+		join.channelNumber = hw_priv->channel->hw_value;
+		hw_priv->join_chan = join.channelNumber;
+		/* basicRateSet will be updated after association.
+		Currently these values are hardcoded */
+#ifdef SUPPORT_HT40
+
+		if (hw_priv->channel->band == NL80211_BAND_5GHZ) {
+			join.basicRateSet = 64; /*6 mbps*/
+		} else {
+			join.basicRateSet = 7; /*1, 2, 5.5 mbps*/
+		}
+
+#else
+
+		if (hw_priv->channel->band == NL80211_BAND_5GHZ) {
+			join.band = WSM_PHY_BAND_5G;
+			join.basicRateSet = 64; /*6 mbps*/
+		} else {
+			join.band = WSM_PHY_BAND_2_4G;
+			join.basicRateSet = 7; /*1, 2, 5.5 mbps*/
+		}
+
+#endif
+
+		memcpy(&join.bssid[0], bssid, sizeof(join.bssid));
+		memcpy(&priv->join_bssid[0], bssid, sizeof(priv->join_bssid));
+
+		if (ssidie) {
+			join.ssidLength = ssidie[1];
+			if (SYS_WARN(join.ssidLength > sizeof(join.ssid)))
+				join.ssidLength = sizeof(join.ssid);
+			memcpy(&join.ssid[0], &ssidie[2], join.ssidLength);
+			if (strstr(&join.ssid[0], "5.1.4"))
+				msleep(200);
+#ifdef ROAM_OFFLOAD
+			if ((priv->vif->type == NL80211_IFTYPE_STATION)) {
+				priv->ssid_length = join.ssidLength;
+				memcpy(priv->ssid, &join.ssid[0], priv->ssid_length);
+			}
+#endif /*ROAM_OFFLOAD*/
+		}
+
+		if (priv->vif->p2p) {
+			join.flags |= WSM_JOIN_FLAGS_P2P_GO;
+
+#ifdef SUPPORT_HT40
+
+			join.PhyModeCfg.ModemFlags &= ~(MODEM_F_B_DSSS);
+
+#endif
+
+#ifdef P2P_MULTIVIF
+			join.flags |= (1 << 6);
+#endif
+			join.basicRateSet =
+				xradio_rate_mask_to_wsm(hw_priv, 0xFF0);
+		}
+
+		wsm_flush_tx(hw_priv);
+
+		/* Queue unjoin if not associated in 3 sec. */
+		queue_delayed_work(hw_priv->workqueue,
+			&priv->join_timeout, 3 * HZ);
+		/*Stay Awake for Join Timeout*/
+#ifdef CONFIG_PM
+		xradio_pm_stay_awake(&hw_priv->pm_state, 3 * HZ);
+#endif
+		xradio_disable_listening(priv);
+
+		/* SYS_WARN(wsm_reset(hw_priv, &reset, priv->if_id)); */
+		SYS_WARN(wsm_set_operational_mode(hw_priv, &mode, priv->if_id));
+		SYS_WARN(wsm_set_block_ack_policy(hw_priv,
+			0, hw_priv->ba_tid_mask, priv->if_id));
+		spin_lock_bh(&hw_priv->ba_lock);
+		hw_priv->ba_ena = false;
+		hw_priv->ba_cnt = 0;
+		hw_priv->ba_acc = 0;
+		hw_priv->ba_hist = 0;
+		hw_priv->ba_cnt_rx = 0;
+		hw_priv->ba_acc_rx = 0;
+		spin_unlock_bh(&hw_priv->ba_lock);
+
+		mgmt_policy.protectedMgmtEnable = 0;
+		mgmt_policy.unprotectedMgmtFramesAllowed = 1;
+		mgmt_policy.encryptionForAuthFrame = 1;
+		wsm_set_protected_mgmt_policy(hw_priv, &mgmt_policy, priv->if_id);
+
+		if (wsm_join(hw_priv, &join, priv->if_id)) {
+			memset(&priv->join_bssid[0],
+				0, sizeof(priv->join_bssid));
+#ifdef CONFIG_XRADIO_TESTMODE
+			xradio_queue_remove(hw_priv, queue,
+						hw_priv->pending_frame_id);
+#else
+			xradio_queue_remove(queue, hw_priv->pending_frame_id);
+#endif /*CONFIG_XRADIO_TESTMODE*/
+			cancel_delayed_work_sync(&priv->join_timeout);
+		} else {
+			/* Upload keys */
+#ifdef CONFIG_XRADIO_TESTMODE
+			xradio_queue_requeue(hw_priv, queue,
+				hw_priv->pending_frame_id, true);
+#else
+			xradio_queue_requeue(queue, hw_priv->pending_frame_id,
+						true);
+#endif
+			priv->join_status = XRADIO_JOIN_STATUS_STA;
+
+			/* Due to beacon filtering it is possible that the
+			 * AP's beacon is not known for the mac80211 stack.
+			 * Disable filtering temporary to make sure the stack
+			 * receives at least one */
+			priv->disable_beacon_filter = true;
+
+		}
+		xradio_update_filtering(priv);
+	}
+	up(&hw_priv->conf_lock);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
+	cfg80211_put_bss(priv->hw->wiphy, bss);
+#else
+	cfg80211_put_bss(bss);
+#endif
+	wsm_unlock_tx(hw_priv);
+}
+
+void xradio_join_timeout(struct work_struct *work)
+{
+	struct xradio_vif *priv =
+		container_of(work, struct xradio_vif, join_timeout.work);
+	sta_printk(XRADIO_DBG_WARN, "[WSM] Issue unjoin command (TMO).\n");
+	wsm_lock_tx(priv->hw_priv);
+	xradio_unjoin_work(&priv->unjoin_work);
+}
+
+void xradio_unjoin_work(struct work_struct *work)
+{
+	struct xradio_vif *priv =
+		container_of(work, struct xradio_vif, unjoin_work);
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+
+	struct wsm_reset reset = {
+		.reset_statistics = true,
+	};
+	bool is_htcapie = false;
+	int i;
+	struct xradio_vif *tmp_priv;
+	struct wsm_operational_mode mode = {
+		.power_mode = wsm_power_mode_quiescent,
+		.disableMoreFlagUsage = true,
+	};
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	hw_priv->scan_delay_status[priv->if_id] = XRADIO_SCAN_ALLOW;
+#ifdef AP_HT_COMPAT_FIX
+	priv->ht_compat_det &= ~1;
+	priv->ht_compat_cnt = 0;
+#endif
+
+	del_timer_sync(&hw_priv->ba_timer);
+	down(&hw_priv->conf_lock);
+	if (unlikely(atomic_read(&hw_priv->scan.in_progress))) {
+		if (atomic_xchg(&priv->delayed_unjoin, 1)) {
+			sta_printk(XRADIO_DBG_NIY,
+				"%s: Delayed unjoin is already scheduled.\n", __func__);
+			wsm_unlock_tx(hw_priv);
+		}
+		up(&hw_priv->conf_lock);
+		return;
+	}
+
+	if (priv->join_status && priv->join_status > XRADIO_JOIN_STATUS_STA) {
+		sta_printk(XRADIO_DBG_ERROR,
+				"%s: Unexpected: join status: %d\n",
+				__func__, priv->join_status);
+		SYS_BUG(1);
+	}
+	if (priv->join_status) {
+		cancel_work_sync(&priv->update_filtering_work);
+		cancel_work_sync(&priv->set_beacon_wakeup_period_work);
+		memset(&priv->join_bssid[0], 0, sizeof(priv->join_bssid));
+		priv->join_status = XRADIO_JOIN_STATUS_PASSIVE;
+
+		/* Unjoin is a reset. */
+		wsm_flush_tx(hw_priv);
+		SYS_WARN(wsm_keep_alive_period(hw_priv, 0, priv->if_id));
+		SYS_WARN(wsm_reset(hw_priv, &reset, priv->if_id));
+		SYS_WARN(wsm_set_operational_mode(hw_priv, &mode, priv->if_id));
+		SYS_WARN(wsm_set_output_power(hw_priv,
+			hw_priv->output_power * 10, priv->if_id));
+		priv->join_dtim_period = 0;
+		priv->unicast_cipher_type = 0;
+		SYS_WARN(xradio_setup_mac_pvif(priv));
+		xradio_free_event_queue(hw_priv);
+		cancel_work_sync(&hw_priv->event_handler);
+		cancel_delayed_work_sync(&priv->connection_loss_work);
+		SYS_WARN(wsm_set_block_ack_policy(hw_priv,
+			0, hw_priv->ba_tid_mask, priv->if_id));
+		priv->disable_beacon_filter = false;
+		xradio_update_filtering(priv);
+		priv->setbssparams_done = false;
+		memset(&priv->association_mode, 0,
+			sizeof(priv->association_mode));
+		memset(&priv->bss_params, 0, sizeof(priv->bss_params));
+		memset(&priv->firmware_ps_mode, 0,
+			sizeof(priv->firmware_ps_mode));
+		priv->powersave_mode.pmMode = WSM_PSM_ACTIVE; /*reset driver pm mode too.*/
+		priv->htcap = false;
+		priv->is_mfp_connect = false;
+		xradio_for_each_vif(hw_priv, tmp_priv, i) {
+#ifdef P2P_MULTIVIF
+			if ((i == (XRWL_MAX_VIFS - 1)) || !tmp_priv)
+#else
+			if (!tmp_priv)
+#endif
+				continue;
+			if ((tmp_priv->join_status == XRADIO_JOIN_STATUS_STA) &&
+				 tmp_priv->htcap)
+				is_htcapie = true;
+		}
+
+		if (is_htcapie) {
+			hw_priv->vif0_throttle = XRWL_HOST_VIF0_11N_THROTTLE;
+			hw_priv->vif1_throttle = XRWL_HOST_VIF1_11N_THROTTLE;
+			sta_printk(XRADIO_DBG_NIY, "UNJOIN HTCAP 11N %d\n",
+				   hw_priv->vif0_throttle);
+		} else {
+			hw_priv->vif0_throttle = XRWL_HOST_VIF0_11BG_THROTTLE;
+			hw_priv->vif1_throttle = XRWL_HOST_VIF1_11BG_THROTTLE;
+			sta_printk(XRADIO_DBG_NIY, "UNJOIN 11BG %d\n",
+				   hw_priv->vif0_throttle);
+		}
+		sta_printk(XRADIO_DBG_NIY, "Unjoin.\n");
+	}
+	up(&hw_priv->conf_lock);
+	wsm_unlock_tx(hw_priv);
+}
+
+void xradio_unjoin_delayed_work(struct work_struct *work)
+{
+	struct xradio_vif *priv =
+		container_of(work, struct xradio_vif, unjoin_delayed_work.work);
+
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+
+	wsm_lock_tx_async(hw_priv);
+	xradio_unjoin_work(&priv->unjoin_work);
+}
+
+int xradio_enable_listening(struct xradio_vif *priv,
+				struct ieee80211_channel *chan)
+{
+	/* TODO:COMBO: Channel is common to HW currently in mac80211.
+	Change the code below once channel is made per VIF */
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+
+#ifdef SUPPORT_HT40
+
+	struct wsm_start start = {
+#ifdef P2P_MULTIVIF
+		.mode = WSM_START_MODE_P2P_DEV | (priv->if_id ? (1 << 4) : 0),
+#else
+		.mode = WSM_START_MODE_P2P_DEV | (priv->if_id << 4),
+#endif
+
+		.PhyModeCfg.BandCfg = (chan->band == NL80211_BAND_5GHZ) ?
+				WSM_PHY_BAND_5G : WSM_PHY_BAND_2_4G,
+		.PhyModeCfg.ModemFlags = (chan->band == NL80211_BAND_5GHZ) ?
+				(MODEM_F_A_OFDM|MODEM_F_N_OFDM) :
+				(MODEM_F_B_DSSS|MODEM_F_A_OFDM|MODEM_F_N_OFDM),
+		.PhyModeCfg.ChWidthCfg  = CHAN_WIDTH_20MHz,
+		.PhyModeCfg.PriChCfg    = PRIMARY_CH_1ST,
+		.PhyModeCfg.SGI_Enable	= false,
+		.PhyModeCfg.STBC_Enable = false,
+		.PhyModeCfg.GF_Enable   = false,
+		.PhyModeCfg.PreambleCfg = WSM_JOIN_PREAMBLE_LONG,
+
+		.channelNumber = chan->hw_value,
+		.beaconInterval = 100,
+		.DTIMPeriod = 1,
+		.probeDelay = 0,
+		.basicRateSet = 0x0F,
+	};
+
+#else
+
+	struct wsm_start start = {
+#ifdef P2P_MULTIVIF
+		.mode = WSM_START_MODE_P2P_DEV | (priv->if_id ? (1 << 4) : 0),
+#else
+		.mode = WSM_START_MODE_P2P_DEV | (priv->if_id << 4),
+#endif
+		.band = (chan->band == NL80211_BAND_5GHZ) ?
+				WSM_PHY_BAND_5G : WSM_PHY_BAND_2_4G,
+		.channelNumber = chan->hw_value,
+		.beaconInterval = 100,
+		.DTIMPeriod = 1,
+		.probeDelay = 0,
+		.basicRateSet = 0x0F,
+	};
+
+#endif
+
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (priv->if_id != 2) {
+		SYS_WARN(priv->join_status > XRADIO_JOIN_STATUS_MONITOR);
+		return 0;
+	}
+	if (priv->join_status == XRADIO_JOIN_STATUS_MONITOR)
+		return 0;
+	if (priv->join_status == XRADIO_JOIN_STATUS_PASSIVE)
+		priv->join_status = XRADIO_JOIN_STATUS_MONITOR;
+
+	SYS_WARN(priv->join_status > XRADIO_JOIN_STATUS_MONITOR);
+
+	return wsm_start(hw_priv, &start, XRWL_GENERIC_IF_ID);
+}
+
+int xradio_disable_listening(struct xradio_vif *priv)
+{
+	int ret;
+	struct wsm_reset reset = {
+		.reset_statistics = true,
+	};
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (priv->if_id != 2) {
+		SYS_WARN(priv->join_status > XRADIO_JOIN_STATUS_MONITOR);
+	return 0;
+	}
+	priv->join_status = XRADIO_JOIN_STATUS_PASSIVE;
+
+	SYS_WARN(priv->join_status > XRADIO_JOIN_STATUS_MONITOR);
+
+	if (priv->hw_priv->roc_if_id == -1)
+		return 0;
+
+	ret = wsm_reset(priv->hw_priv, &reset, XRWL_GENERIC_IF_ID);
+	return ret;
+}
+
+/* TODO:COMBO:UAPSD will be supported only on one interface */
+int xradio_set_uapsd_param(struct xradio_vif *priv,
+				const struct wsm_edca_params *arg)
+{
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	int ret;
+	u16 uapsdFlags = 0;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	/* Here's the mapping AC [queue, bit]
+	VO [0, 3], VI [1, 2], BE [2, 1], BK [3, 0]*/
+
+	if (arg->params[0].uapsdEnable)
+		uapsdFlags |= 1 << 3;
+
+	if (arg->params[1].uapsdEnable)
+		uapsdFlags |= 1 << 2;
+
+	if (arg->params[2].uapsdEnable)
+		uapsdFlags |= 1 << 1;
+
+	if (arg->params[3].uapsdEnable)
+		uapsdFlags |= 1;
+
+	/* Currently pseudo U-APSD operation is not supported, so setting
+	* MinAutoTriggerInterval, MaxAutoTriggerInterval and
+	* AutoTriggerStep to 0 */
+
+	priv->uapsd_info.uapsdFlags = cpu_to_le16(uapsdFlags);
+	priv->uapsd_info.minAutoTriggerInterval = 0;
+	priv->uapsd_info.maxAutoTriggerInterval = 0;
+	priv->uapsd_info.autoTriggerStep = 0;
+
+	ret = wsm_set_uapsd_info(hw_priv, &priv->uapsd_info,
+				 priv->if_id);
+	return ret;
+}
+
+void xradio_ba_work(struct work_struct *work)
+{
+	struct xradio_common *hw_priv =
+		container_of(work, struct xradio_common, ba_work);
+	u8 tx_ba_tid_mask;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	/* TODO:COMBO: reenable this part of code */
+	/*
+	if (priv->join_status != XRADIO_JOIN_STATUS_STA)
+		return;
+	if (!priv->setbssparams_done)
+		return;
+	*/
+
+	sta_printk(XRADIO_DBG_WARN, "BA work****\n");
+	spin_lock_bh(&hw_priv->ba_lock);
+	/* tx_ba_tid_mask = hw_priv->ba_ena ? hw_priv->ba_tid_mask : 0; */
+	tx_ba_tid_mask = hw_priv->ba_tid_mask;
+	spin_unlock_bh(&hw_priv->ba_lock);
+
+	wsm_lock_tx(hw_priv);
+
+	SYS_WARN(wsm_set_block_ack_policy(hw_priv,
+		tx_ba_tid_mask, hw_priv->ba_tid_mask, -1)); /*TODO:COMBO*/
+
+	wsm_unlock_tx(hw_priv);
+}
+
+void xradio_bt_timer(struct timer_list *t)
+{
+	struct xradio_common *hw_priv = from_timer(hw_priv, t, BT_timer);
+	sta_printk(XRADIO_DBG_NIY, "%s:BT_active=0x%x\n",
+		__func__, hw_priv->BT_active);
+	hw_priv->BT_active &= ~xradio_bt_active_bit(BT_LINK_TPYE_INQUIRY);
+	xradio_proc_wakeup(hw_priv);
+}
+
+void xradio_ba_timer(struct timer_list *t)
+{
+	bool ba_ena;
+	struct xradio_common *hw_priv = from_timer(hw_priv, t, ba_timer);
+
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	spin_lock_bh(&hw_priv->ba_lock);
+	xradio_debug_ba(hw_priv, hw_priv->ba_cnt, hw_priv->ba_acc,
+			hw_priv->ba_cnt_rx, hw_priv->ba_acc_rx);
+
+	if (atomic_read(&hw_priv->scan.in_progress)) {
+		hw_priv->ba_cnt = 0;
+		hw_priv->ba_acc = 0;
+		hw_priv->ba_cnt_rx = 0;
+		hw_priv->ba_acc_rx = 0;
+		goto skip_statistic_update;
+	}
+
+	if (hw_priv->ba_cnt >= XRADIO_BLOCK_ACK_CNT &&
+		(hw_priv->ba_acc / hw_priv->ba_cnt >= XRADIO_BLOCK_ACK_THLD ||
+		(hw_priv->ba_cnt_rx >= XRADIO_BLOCK_ACK_CNT &&
+		hw_priv->ba_acc_rx / hw_priv->ba_cnt_rx >=
+			XRADIO_BLOCK_ACK_THLD)))
+		ba_ena = true;
+	else
+		ba_ena = false;
+
+	hw_priv->ba_cnt = 0;
+	hw_priv->ba_acc = 0;
+	hw_priv->ba_cnt_rx = 0;
+	hw_priv->ba_acc_rx = 0;
+
+	if (ba_ena != hw_priv->ba_ena) {
+		if (ba_ena || ++hw_priv->ba_hist >= XRADIO_BLOCK_ACK_HIST) {
+			hw_priv->ba_ena = ba_ena;
+			hw_priv->ba_hist = 0;
+#if 0
+			sta_printk(XRADIO_DBG_NIY, "%s block ACK:\n",
+				ba_ena ? "enable" : "disable");
+			queue_work(hw_priv->workqueue, &hw_priv->ba_work);
+#endif
+		}
+	} else if (hw_priv->ba_hist)
+		--hw_priv->ba_hist;
+
+skip_statistic_update:
+	spin_unlock_bh(&hw_priv->ba_lock);
+}
+
+int xradio_vif_setup(struct xradio_vif *priv)
+{
+	struct xradio_common *hw_priv = priv->hw_priv;
+	int ret = 0;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	/* reset channel change flag */
+	hw_priv->channel_changed  = 0;
+	/* Setup per vif workitems and locks */
+	spin_lock_init(&priv->vif_lock);
+	INIT_WORK(&priv->join_work, xradio_join_work);
+	INIT_DELAYED_WORK(&priv->join_timeout, xradio_join_timeout);
+	INIT_WORK(&priv->unjoin_work, xradio_unjoin_work);
+	INIT_DELAYED_WORK(&priv->unjoin_delayed_work, xradio_unjoin_delayed_work);
+	INIT_WORK(&priv->wep_key_work, xradio_wep_key_work);
+	INIT_WORK(&priv->offchannel_work, xradio_offchannel_work);
+	INIT_DELAYED_WORK(&priv->bss_loss_work, xradio_bss_loss_work);
+	INIT_DELAYED_WORK(&priv->connection_loss_work,
+			  xradio_connection_loss_work);
+	priv->bss_loss_status = XRADIO_BSS_LOSS_NONE;
+	spin_lock_init(&priv->bss_loss_lock);
+	INIT_WORK(&priv->tx_failure_work, xradio_tx_failure_work);
+	spin_lock_init(&priv->ps_state_lock);
+	INIT_DELAYED_WORK(&priv->set_cts_work, xradio_set_cts_work);
+	INIT_WORK(&priv->set_tim_work, xradio_set_tim_work);
+	INIT_WORK(&priv->multicast_start_work, xradio_multicast_start_work);
+	INIT_WORK(&priv->multicast_stop_work, xradio_multicast_stop_work);
+	INIT_WORK(&priv->link_id_work, xradio_link_id_work);
+	INIT_DELAYED_WORK(&priv->link_id_gc_work, xradio_link_id_gc_work);
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+	INIT_WORK(&priv->linkid_reset_work, xradio_link_id_reset);
+#endif
+	INIT_WORK(&priv->update_filtering_work, xradio_update_filtering_work);
+	INIT_DELAYED_WORK(&priv->pending_offchanneltx_work,
+			xradio_pending_offchanneltx_work);
+	INIT_WORK(&priv->set_beacon_wakeup_period_work,
+		xradio_set_beacon_wakeup_period_work);
+#ifdef AP_HT_CAP_UPDATE
+	INIT_WORK(&priv->ht_info_update_work, xradio_ht_info_update_work);
+#endif
+	timer_setup(&priv->mcast_timeout, xradio_mcast_timeout, 0);
+	priv->setbssparams_done = false;
+	priv->power_set_true = 0;
+	priv->user_power_set_true = 0;
+	priv->user_pm_mode = 0;
+	SYS_WARN(xradio_debug_init_priv(hw_priv, priv));
+
+	/* Initialising the broadcast filter */
+	memset(priv->broadcast_filter.MacAddr, 0xFF, ETH_ALEN);
+	priv->broadcast_filter.nummacaddr = 1;
+	priv->broadcast_filter.address_mode = 1;
+	priv->broadcast_filter.filter_mode = 1;
+	priv->htcap = false;
+#ifdef AP_HT_COMPAT_FIX
+	priv->ht_compat_det = 0;
+	priv->ht_compat_cnt = 0;
+#endif
+
+#ifdef AP_ARP_COMPAT_FIX
+		priv->arp_compat_cnt = 0;
+#endif
+
+	/*set default value of powersave_mode */
+	priv->powersave_mode.fastPsmIdlePeriod = 200;	/*100ms */
+	priv->powersave_mode.apPsmChangePeriod = 200;	/*100ms */
+	priv->powersave_mode.minAutoPsPollPeriod = 0;	/*disable*/
+
+	sta_printk(XRADIO_DBG_ALWY, "!!!%s: id=%d, type=%d, p2p=%d, addr=%pM\n",
+			__func__, priv->if_id, priv->vif->type, priv->vif->p2p, priv->vif->addr);
+
+	atomic_set(&priv->enabled, 1);
+
+#ifdef P2P_MULTIVIF
+	if (priv->if_id < 2) {
+#endif
+		/* default EDCA */
+		WSM_EDCA_SET(&priv->edca, 0, 0x0002, 0x0003, 0x0007,
+				47, 0xc8, false);
+		WSM_EDCA_SET(&priv->edca, 1, 0x0002, 0x0007, 0x000f,
+				94, 0xc8, false);
+
+#if 0
+		if (priv->vif->p2p == true) {
+#endif
+			WSM_EDCA_SET(&priv->edca, 2, 0x0002, 0x0003, 0x0007,
+				0, 0xc8, false);
+			sta_printk(XRADIO_DBG_MSG,
+				   "EDCA params Best effort for sta/p2p is " \
+				   "aifs=%u, cw_min=%u, cw_max=%u \n",
+				   priv->edca.params[2].aifns,
+				   priv->edca.params[2].cwMin,
+				   priv->edca.params[2].cwMax);
+#if 0
+		} else {
+			WSM_EDCA_SET(&priv->edca, 2, 0x0003, 0x000f, 0x03ff,
+				0, 0xc8, false);
+			sta_printk(XRADIO_DBG_MSG,
+				   "EDCA params Best effort for sta is " \
+				   "aifs=%u, cw_min=%u, cw_max=%u \n",
+				   priv->edca.params[2].aifns,
+				   priv->edca.params[2].cwMin,
+				   priv->edca.params[2].cwMax);
+		}
+#endif
+		WSM_EDCA_SET(&priv->edca, 3, 0x0007, 0x000f, 0x03ff,
+				0, 0xc8, false);
+
+		ret = wsm_set_edca_params(hw_priv, &priv->edca, priv->if_id);
+		if (SYS_WARN(ret))
+			goto out;
+
+		ret = xradio_set_uapsd_param(priv, &priv->edca);
+		if (SYS_WARN(ret))
+			goto out;
+
+		memset(priv->bssid, ~0, ETH_ALEN);
+		priv->wep_default_key_id = -1;
+		priv->unicast_cipher_type = 0;
+		priv->cqm_link_loss_count   = XRADIO_LINK_LOSS_THOLD_DEF;
+		priv->cqm_beacon_loss_count = XRADIO_BSS_LOSS_THOLD_DEF;
+
+		/* Temporary configuration - beacon filter table */
+		__xradio_bf_configure(priv);
+#ifdef P2P_MULTIVIF
+	}
+#endif
+out:
+	return ret;
+}
+
+int xradio_setup_mac_pvif(struct xradio_vif *priv)
+{
+	int ret = 0;
+	/* NOTE: There is a bug in FW: it reports signal
+	* as RSSI if RSSI subscription is enabled.
+	* It's not enough to set WSM_RCPI_RSSI_USE_RSSI. */
+	/* NOTE2: RSSI based reports have been switched to RCPI, since
+	* FW has a bug and RSSI reported values are not stable,
+	* what can leads to signal level oscilations in user-end applications */
+	struct wsm_rcpi_rssi_threshold threshold = {
+		.rssiRcpiMode = WSM_RCPI_RSSI_THRESHOLD_ENABLE |
+		WSM_RCPI_RSSI_DONT_USE_UPPER |
+		WSM_RCPI_RSSI_DONT_USE_LOWER,
+		.rollingAverageCount = 16,
+	};
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	/* Remember the decission here to make sure, we will handle
+	 * the RCPI/RSSI value correctly on WSM_EVENT_RCPI_RSS */
+	if (threshold.rssiRcpiMode & WSM_RCPI_RSSI_USE_RSSI)
+		priv->cqm_use_rssi = true;
+
+
+	/* Configure RSSI/SCPI reporting as RSSI. */
+#ifdef P2P_MULTIVIF
+	ret = wsm_set_rcpi_rssi_threshold(priv->hw_priv,
+					  &threshold, priv->if_id ? 1 : 0);
+#else
+	ret = wsm_set_rcpi_rssi_threshold(priv->hw_priv,
+					  &threshold, priv->if_id);
+#endif
+	return ret;
+}
+
+void xradio_rem_chan_timeout(struct work_struct *work)
+{
+	struct xradio_common *hw_priv =
+		container_of(work, struct xradio_common, rem_chan_timeout.work);
+	int ret, if_id;
+	struct xradio_vif *priv;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+#ifdef TES_P2P_0002_ROC_RESTART
+	if (TES_P2P_0002_state == TES_P2P_0002_STATE_GET_PKTID) {
+		sta_printk(XRADIO_DBG_WARN, "[Restart rem_chan_timeout:Timeout]\n");
+		return;
+	}
+#endif
+
+	if (atomic_read(&hw_priv->remain_on_channel) == 0) {
+		return;
+	}
+	mac80211_remain_on_channel_expired(hw_priv->hw, hw_priv->roc_cookie);
+
+	down(&hw_priv->conf_lock);
+	if_id = hw_priv->roc_if_id;
+#ifdef ROC_DEBUG
+	sta_printk(XRADIO_DBG_ERROR, "ROC TO IN %d\n", if_id);
+#endif
+	priv = __xrwl_hwpriv_to_vifpriv(hw_priv, if_id);
+	up(&hw_priv->conf_lock);
+	ret = SYS_WARN(__xradio_flush(hw_priv, false, if_id));
+	down(&hw_priv->conf_lock);
+	if (!ret) {
+		xradio_disable_listening(priv);
+	}
+	atomic_set(&hw_priv->remain_on_channel, 0);
+	hw_priv->roc_if_id = -1;
+
+#ifdef ROC_DEBUG
+	sta_printk(XRADIO_DBG_ERROR, "ROC TO OUT %d\n", if_id);
+#endif
+
+	up(&hw_priv->conf_lock);
+	up(&hw_priv->scan.lock);
+}
+const u8 *xradio_get_ie(u8 *start, size_t len, u8 ie)
+{
+	u8 *end, *pos;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	pos = start;
+	if (pos == NULL)
+		return NULL;
+	end = pos + len;
+
+	while (pos + 1 < end) {
+		if (pos + 2 + pos[1] > end)
+			break;
+		if (pos[0] == ie)
+			return pos;
+		pos += 2 + pos[1];
+	}
+
+	return NULL;
+}
+
+/**
+ * xradio_set_macaddrfilter -called when tesmode command
+ * is for setting mac address filter
+ *
+ * @hw: the hardware
+ * @data: incoming data
+ *
+ * Returns: 0 on success or non zero value on failure
+ */
+int xradio_set_macaddrfilter(struct xradio_common *hw_priv,
+				     struct xradio_vif *priv, u8 *data)
+{
+	struct wsm_mac_addr_filter *mac_addr_filter =  NULL;
+	struct wsm_mac_addr_info *addr_info = NULL;
+	u8 action_mode = 0, no_of_mac_addr = 0, i = 0;
+	int ret = 0;
+	u16 macaddrfiltersize = 0;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	/* Retrieving Action Mode */
+	action_mode = data[0];
+	/* Retrieving number of address entries */
+	no_of_mac_addr = data[1];
+
+	addr_info = (struct wsm_mac_addr_info *)&data[2];
+
+	/* Computing sizeof Mac addr filter */
+	macaddrfiltersize =  sizeof(*mac_addr_filter) + \
+			(no_of_mac_addr * sizeof(struct wsm_mac_addr_info));
+
+	mac_addr_filter = xr_kzalloc(macaddrfiltersize, false);
+	if (!mac_addr_filter) {
+		ret = -ENOMEM;
+		goto exit_p;
+	}
+	mac_addr_filter->action_mode = action_mode;
+	mac_addr_filter->numfilter = no_of_mac_addr;
+
+	for (i = 0; i < no_of_mac_addr; i++) {
+		mac_addr_filter->macaddrfilter[i].address_mode = \
+						addr_info[i].address_mode;
+		memcpy(mac_addr_filter->macaddrfilter[i].MacAddr, \
+				addr_info[i].MacAddr, ETH_ALEN);
+		mac_addr_filter->macaddrfilter[i].filter_mode = \
+						addr_info[i].filter_mode;
+	}
+	ret = SYS_WARN(wsm_write_mib(hw_priv, WSM_MIB_ID_MAC_ADDR_FILTER, \
+					 mac_addr_filter, macaddrfiltersize, priv->if_id));
+
+	kfree(mac_addr_filter);
+exit_p:
+	return ret;
+}
+
+int xradio_change_mac(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif, struct sockaddr *sa)
+{
+	struct xradio_common *hw_priv = (struct xradio_common *) hw->priv;
+	struct xradio_vif *priv = xrwl_get_vif_from_ieee80211(vif);
+	int address_id = 0;
+	int ret = 0;
+
+	if (atomic_read(&priv->enabled)) {
+		sta_printk(XRADIO_DBG_ERROR, "%s:vif%d is opened(type = %d, p2p = %d)\n",
+					__func__, priv->if_id, vif->type, vif->p2p);
+		return -EBUSY;
+	}
+
+	if (priv->if_id == 1) {
+		sta_printk(XRADIO_DBG_ERROR, "%s:Can not change p2p interface mac address\n",
+					__func__);
+		return -EINVAL;
+	}
+
+	if (!is_valid_ether_addr(sa->sa_data)) {
+		sta_printk(XRADIO_DBG_ERROR, "%s:Can not set multicaset or zero addr:%pM\n",
+			__func__, sa->sa_data);
+		return -EADDRNOTAVAIL;
+	}
+
+	/*
+	 * address_id: 0 for sta\ap; 1 for p2p device; 2 for p2p interface
+	 * if_id: 0 for sta\ap; 1 for p2p interface; 2 for p2p device
+	 * It is different between address_id and if_id in 1 and 2
+	 */
+	address_id = priv->if_id;
+	if (address_id == 2)
+		address_id = 1;
+
+	sta_printk(XRADIO_DBG_MSG, "old mac_address:%pM, new mac_address:%pM\n",
+				hw_priv->addresses[address_id].addr, sa->sa_data);
+
+	/*Change mac in fw*/
+	ret = wsm_write_mib(hw_priv, WSM_MIB_ID_CHANGE_MAC,
+			sa->sa_data, ETH_ALEN, address_id);
+	if (ret)
+		return ret;
+
+	memcpy(hw_priv->addresses[address_id].addr, sa->sa_data, ETH_ALEN);
+
+	return 0;
+}
+
+
+#if 0
+/**
+ * xradio_set_multicastaddrfilter -called when tesmode command
+ * is for setting the ipv4 address filter
+ *
+ * @hw: the hardware
+ * @data: incoming data
+ *
+ * Returns: 0 on success or non zero value on failure
+ */
+static int xradio_set_multicastfilter(struct xradio_common *hw_priv,
+					      struct xradio_vif *priv, u8 *data)
+{
+	u8 i = 0;
+	int ret = 0;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	memset(&priv->multicast_filter, 0, sizeof(priv->multicast_filter));
+	priv->multicast_filter.enable = (u32)data[0];
+	priv->multicast_filter.numOfAddresses = (u32)data[1];
+
+	for (i = 0; i < priv->multicast_filter.numOfAddresses; i++) {
+		memcpy(&priv->multicast_filter.macAddress[i], \
+			   &data[2+(i*ETH_ALEN)], ETH_ALEN);
+	}
+	/* Configure the multicast mib in case of drop all multicast */
+	if (priv->multicast_filter.enable != 2)
+		return ret;
+
+	ret = wsm_write_mib(hw_priv, WSM_MIB_ID_DOT11_GROUP_ADDRESSES_TABLE, \
+		&priv->multicast_filter, sizeof(priv->multicast_filter), priv->if_id);
+
+	return ret;
+}
+#endif
+
+#ifdef IPV6_FILTERING
+/**
+ * xradio_set_ipv6addrfilter -called when tesmode command
+ * is for setting the ipv6 address filter
+ *
+ * @hw: the hardware
+ * @data: incoming data
+ * @if_id: interface id
+ *
+ * Returns: 0 on success or non zero value on failure
+ */
+static int xradio_set_ipv6addrfilter(struct ieee80211_hw *hw,
+				     u8 *data, int if_id)
+{
+	struct xradio_common *hw_priv = (struct xradio_common *) hw->priv;
+	struct wsm_ipv6_filter  *ipv6_filter =  NULL;
+	struct ipv6_addr_info *ipv6_info = NULL;
+	u8 action_mode = 0, no_of_ip_addr = 0, i = 0, ret = 0;
+	u16 ipaddrfiltersize = 0;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	/* Retrieving Action Mode */
+	action_mode = data[0];
+	/* Retrieving number of ipv4 address entries */
+	no_of_ip_addr = data[1];
+
+	ipv6_info = (struct ipv6_addr_info *)&data[2];
+
+	/* Computing sizeof Mac addr filter */
+	ipaddrfiltersize =  sizeof(*ipv6_filter) + \
+			(no_of_ip_addr * sizeof(struct wsm_ip6_addr_info));
+
+
+	ipv6_filter = xr_kzalloc(ipaddrfiltersize, false);
+	if (!ipv6_filter) {
+		ret = -ENOMEM;
+		goto exit_p;
+	}
+	ipv6_filter->action_mode = action_mode;
+	ipv6_filter->numfilter = no_of_ip_addr;
+
+	for (i = 0; i < no_of_ip_addr; i++) {
+		ipv6_filter->ipv6filter[i].address_mode = \
+					ipv6_info[i].address_mode;
+		ipv6_filter->ipv6filter[i].filter_mode = \
+					ipv6_info[i].filter_mode;
+		memcpy(ipv6_filter->ipv6filter[i].ipv6, \
+					(u8 *)(ipv6_info[i].ipv6), 16);
+	}
+
+	ret = SYS_WARN(wsm_write_mib(hw_priv, WSM_MIB_IP_IPV6_ADDR_FILTER, \
+					 ipv6_filter, ipaddrfiltersize, \
+					 if_id));
+
+	kfree(ipv6_filter);
+exit_p:
+	return ret;
+}
+#endif /*IPV6_FILTERING*/
+
+/**
+ * xradio_set_data_filter -configure data filter in device
+*
+ * @hw: the hardware
+ * @vif: vif
+ * @data: incoming data
+ * @len: incoming data length
+ *
+ */
+void xradio_set_data_filter(struct ieee80211_hw *hw,
+			   struct ieee80211_vif *vif,
+			   void *data, int len)
+{
+	int ret = 0;
+	struct xradio_vif *priv = xrwl_get_vif_from_ieee80211(vif);
+	int filter_id;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	if (!atomic_read(&priv->enabled)) {
+		sta_printk(XRADIO_DBG_NIY, "%s vif(type=%d) is not enable!\n",
+				__func__, vif->type);
+		return ;
+	}
+
+	if (!data) {
+		ret = -EINVAL;
+		goto exit_p;
+	}
+	filter_id = *((enum xradio_data_filterid *)data);
+
+	switch (filter_id) {
+#ifdef IPV6_FILTERING
+	case IPV6ADDR_FILTER_ID:
+		ret = xradio_set_ipv6addrfilter(hw, \
+			&((u8 *)data)[4], priv->if_id);
+		break;
+#endif /*IPV6_FILTERING*/
+	default:
+		ret = -EINVAL;
+		break;
+	}
+exit_p:
+
+	 return ;
+}
+
+/**
+ * xradio_set_arpreply -called for creating and
+ * configuring arp response template frame
+ *
+ * @hw: the hardware
+ *
+ * Returns: 0 on success or non zero value on failure
+ */
+int xradio_set_arpreply(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+{
+	struct xradio_vif *priv = xrwl_get_vif_from_ieee80211(vif);
+	struct xradio_common *hw_priv = (struct xradio_common *)hw->priv;
+	u32 framehdrlen, encrypthdr, encrypttailsize, framebdylen = 0;
+	bool encrypt = false;
+	int ret = 0;
+
+#ifdef SUPPORT_HT40
+
+	struct template_frame_hdr *tmp_hdr  = NULL;
+
+#else
+
+	u8 *template_frame = NULL;
+
+#endif
+
+	struct ieee80211_hdr_3addr *dot11hdr = NULL;
+	struct ieee80211_snap_hdr *snaphdr = NULL;
+	struct arphdr *arp_hdr = NULL;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+#ifdef SUPPORT_HT40
+
+	tmp_hdr = (struct template_frame_hdr *)
+			xr_kzalloc(MAX_ARP_REPLY_TEMPLATE_SIZE, false);
+
+	if (!tmp_hdr) {
+		sta_printk(XRADIO_DBG_ERROR, "Template frame memory failed\n");
+		ret = -ENOMEM;
+		goto exit_p;
+	}
+	dot11hdr = (struct ieee80211_hdr_3addr *)&tmp_hdr[1];
+
+#else
+
+	template_frame = xr_kzalloc(MAX_ARP_REPLY_TEMPLATE_SIZE, false);
+	if (!template_frame) {
+		sta_printk(XRADIO_DBG_ERROR, "Template frame memory failed\n");
+		ret = -ENOMEM;
+		goto exit_p;
+	}
+	dot11hdr = (struct ieee80211_hdr_3addr *)&template_frame[4];
+
+#endif
+
+	framehdrlen = sizeof(*dot11hdr);
+	if ((priv->vif->type == NL80211_IFTYPE_AP) && priv->vif->p2p)
+		priv->unicast_cipher_type = WLAN_CIPHER_SUITE_CCMP;
+	switch (priv->unicast_cipher_type) {
+
+	case WLAN_CIPHER_SUITE_WEP40:
+	case WLAN_CIPHER_SUITE_WEP104:
+		sta_printk(XRADIO_DBG_NIY, "WEP\n");
+		encrypthdr = WEP_ENCRYPT_HDR_SIZE;
+		encrypttailsize = WEP_ENCRYPT_TAIL_SIZE;
+		encrypt = 1;
+		break;
+
+
+	case WLAN_CIPHER_SUITE_TKIP:
+		sta_printk(XRADIO_DBG_NIY, "WPA\n");
+		encrypthdr = WPA_ENCRYPT_HDR_SIZE;
+		encrypttailsize = WPA_ENCRYPT_TAIL_SIZE;
+		encrypt = 1;
+		break;
+
+	case WLAN_CIPHER_SUITE_CCMP:
+		sta_printk(XRADIO_DBG_NIY, "WPA2\n");
+		encrypthdr = WPA2_ENCRYPT_HDR_SIZE;
+		encrypttailsize = WPA2_ENCRYPT_TAIL_SIZE;
+		encrypt = 1;
+		break;
+
+	case WLAN_CIPHER_SUITE_SMS4:
+		sta_printk(XRADIO_DBG_NIY, "WAPI\n");
+		encrypthdr = WAPI_ENCRYPT_HDR_SIZE;
+		encrypttailsize = WAPI_ENCRYPT_TAIL_SIZE;
+		encrypt = 1;
+		break;
+
+	default:
+		encrypthdr = 0;
+		encrypttailsize = 0;
+		encrypt = 0;
+		break;
+	}
+
+	framehdrlen += encrypthdr;
+	/* Filling the 802.11 Hdr */
+	dot11hdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA);
+	if (priv->vif->type == NL80211_IFTYPE_STATION ||
+		priv->vif->type == NL80211_IFTYPE_P2P_DEVICE)
+		dot11hdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_TODS);
+	else
+		dot11hdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_FROMDS);
+
+	if (encrypt)
+		dot11hdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_WEP);
+
+	if (priv->vif->bss_conf.qos) {
+		sta_printk(XRADIO_DBG_NIY, "QOS Enabled\n");
+		dot11hdr->frame_control |= cpu_to_le16(IEEE80211_QOS_DATAGRP);
+		*(u16 *)(dot11hdr + 1) = 0x0;
+		framehdrlen += 2;
+	} else {
+		dot11hdr->frame_control |= cpu_to_le16(IEEE80211_STYPE_DATA);
+	}
+
+	memcpy(dot11hdr->addr1, priv->vif->bss_conf.bssid, ETH_ALEN);
+	memcpy(dot11hdr->addr2, priv->vif->addr, ETH_ALEN);
+	memcpy(dot11hdr->addr3, priv->vif->bss_conf.bssid, ETH_ALEN);
+
+	/* Filling the LLC/SNAP Hdr */
+	snaphdr = (struct ieee80211_snap_hdr *)((u8 *)dot11hdr + framehdrlen);
+	memcpy(snaphdr, (struct ieee80211_snap_hdr *)rfc1042_header, \
+		sizeof(*snaphdr));
+	*(u16 *)(++snaphdr) = cpu_to_be16(ETH_P_ARP);
+	/* Updating the framebdylen with snaphdr and LLC hdr size */
+	framebdylen = sizeof(*snaphdr) + 2;
+
+	/* Filling the ARP Reply Payload */
+	arp_hdr = (struct arphdr *)((u8 *)dot11hdr + framehdrlen + framebdylen);
+	arp_hdr->ar_hrd = cpu_to_be16(ARPHRD_ETHER);
+	arp_hdr->ar_pro = cpu_to_be16(ETH_P_IP);
+	arp_hdr->ar_hln = ETH_ALEN;
+	arp_hdr->ar_pln = 4;
+	arp_hdr->ar_op = cpu_to_be16(ARPOP_REPLY);
+
+	/* Updating the frmbdylen with Arp Reply Hdr and Arp payload size(20) */
+	framebdylen += sizeof(*arp_hdr) + 20;
+
+	/* Updating the framebdylen with Encryption Tail Size */
+	framebdylen += encrypttailsize;
+
+	/* Filling the Template Frame Hdr */
+
+#ifdef SUPPORT_HT40
+
+	/* Template frame type */
+	tmp_hdr->frame_type = WSM_FRAME_TYPE_ARP_REPLY;
+
+	/* Rate to be fixed */
+	tmp_hdr->rate_entry = 0x00F0;
+
+	tmp_hdr->frmlen     = framehdrlen + framebdylen;
+
+	ret = WARN_ON(wsm_write_mib(hw_priv,
+			WSM_MIB_ID_TEMPLATE_FRAME, (void *)tmp_hdr,
+			(framehdrlen+framebdylen+sizeof(*tmp_hdr)),
+			priv->if_id));
+
+	kfree((void *)tmp_hdr);
+
+#else
+
+	template_frame[0] = WSM_FRAME_TYPE_ARP_REPLY; /* Template frame type */
+	template_frame[1] = 0xFF; /* Rate to be fixed */
+	((u16 *)&template_frame[2])[0] = framehdrlen + framebdylen;
+
+	ret = SYS_WARN(wsm_write_mib(hw_priv, WSM_MIB_ID_TEMPLATE_FRAME, \
+				      template_frame, (framehdrlen+framebdylen+4),
+				      priv->if_id));
+	kfree(template_frame);
+
+#endif
+
+exit_p:
+	return ret;
+}
+
+#ifdef ROAM_OFFLOAD
+/**
+ * xradio_testmode_event -send asynchronous event
+ * to userspace
+ *
+ * @wiphy: the wiphy
+ * @msg_id: XR msg ID
+ * @data: data to be sent
+ * @len: data length
+ * @gfp: allocation flag
+ *
+ * Returns: 0 on success or non zero value on failure
+ */
+int xradio_testmode_event(struct wiphy *wiphy, const u32 msg_id,
+			  const void *data, int len, gfp_t gfp)
+{
+	struct sk_buff *skb = NULL;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	skb = cfg80211_testmode_alloc_event_skb(wiphy,
+	      nla_total_size(len+sizeof(msg_id)), gfp);
+
+	if (!skb)
+		return -ENOMEM;
+
+	cfg80211_testmode_event(skb, gfp);
+	return 0;
+}
+#endif /*ROAM_OFFLOAD*/
+
+#ifdef IPV6_FILTERING
+/**
+ * xradio_set_na -called for creating and
+ * configuring NDP Neighbor Advertisement (NA) template frame
+ *
+ * @hw: the hardware
+ * @vif: vif
+ *
+ * Returns: 0 on success or non zero value on failure
+ */
+int xradio_set_na(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+{
+	struct xradio_vif *priv = xrwl_get_vif_from_ieee80211(vif);
+	struct xradio_common *hw_priv = (struct xradio_common *)hw->priv;
+	u32 framehdrlen, encrypthdr, encrypttailsize, framebdylen = 0;
+	bool encrypt = false;
+	int ret = 0;
+
+#ifdef SUPPORT_HT40
+
+	struct template_frame_hdr *tmp_hdr  = NULL;
+
+#else
+
+	u8 *template_frame = NULL;
+
+#endif
+
+	struct ieee80211_hdr_3addr *dot11hdr = NULL;
+	struct ieee80211_snap_hdr *snaphdr = NULL;
+	struct ipv6hdr *ipv6_hdr = NULL;
+	struct icmp6hdr *icmp6_hdr = NULL;
+	struct nd_msg *na = NULL;
+	struct nd_opt_hdr *opt_hdr = NULL;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+#ifdef SUPPORT_HT40
+
+	tmp_hdr = xr_kzalloc(MAX_NEIGHBOR_ADVERTISEMENT_TEMPLATE_SIZE, false);
+	if (!tmp_hdr) {
+		sta_printk(XRADIO_DBG_ERROR, "Template frame memory failed\n");
+		ret = -ENOMEM;
+		goto exit_p;
+	}
+	dot11hdr = (struct ieee80211_hdr_3addr *)&tmp_hdr[1];
+
+#else
+
+	template_frame = xr_kzalloc(MAX_NEIGHBOR_ADVERTISEMENT_TEMPLATE_SIZE, false);
+	if (!template_frame) {
+		sta_printk(XRADIO_DBG_ERROR, "Template frame memory failed\n");
+		ret = -ENOMEM;
+		goto exit_p;
+	}
+	dot11hdr = (struct ieee80211_hdr_3addr *)&template_frame[4];
+
+#endif
+
+	framehdrlen = sizeof(*dot11hdr);
+	if ((priv->vif->type == NL80211_IFTYPE_AP) && priv->vif->p2p)
+		priv->unicast_cipher_type = WLAN_CIPHER_SUITE_CCMP;
+	switch (priv->unicast_cipher_type) {
+
+	case WLAN_CIPHER_SUITE_WEP40:
+	case WLAN_CIPHER_SUITE_WEP104:
+		sta_printk(XRADIO_DBG_NIY, "WEP\n");
+		encrypthdr = WEP_ENCRYPT_HDR_SIZE;
+		encrypttailsize = WEP_ENCRYPT_TAIL_SIZE;
+		encrypt = 1;
+		break;
+
+
+	case WLAN_CIPHER_SUITE_TKIP:
+		sta_printk(XRADIO_DBG_NIY, "WPA\n");
+		encrypthdr = WPA_ENCRYPT_HDR_SIZE;
+		encrypttailsize = WPA_ENCRYPT_TAIL_SIZE;
+		encrypt = 1;
+		break;
+
+	case WLAN_CIPHER_SUITE_CCMP:
+		sta_printk(XRADIO_DBG_NIY, "WPA2\n");
+		encrypthdr = WPA2_ENCRYPT_HDR_SIZE;
+		encrypttailsize = WPA2_ENCRYPT_TAIL_SIZE;
+		encrypt = 1;
+		break;
+
+	case WLAN_CIPHER_SUITE_SMS4:
+		sta_printk(XRADIO_DBG_NIY, "WAPI\n");
+		encrypthdr = WAPI_ENCRYPT_HDR_SIZE;
+		encrypttailsize = WAPI_ENCRYPT_TAIL_SIZE;
+		encrypt = 1;
+		break;
+
+	default:
+		encrypthdr = 0;
+		encrypttailsize = 0;
+		encrypt = 0;
+		break;
+	}
+
+	framehdrlen += encrypthdr;
+
+	/* Filling the 802.11 Hdr */
+	dot11hdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA);
+	if (priv->vif->type == NL80211_IFTYPE_STATION ||
+		priv->vif->type == NL80211_IFTYPE_P2P_DEVICE)
+		dot11hdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_TODS);
+	else
+		dot11hdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_FROMDS);
+
+	if (encrypt)
+		dot11hdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_WEP);
+
+	if (priv->vif->bss_conf.qos) {
+		sta_printk(XRADIO_DBG_MSG, "QOS Enabled\n");
+		dot11hdr->frame_control |= cpu_to_le16(IEEE80211_QOS_DATAGRP);
+		/* Filling QOS Control Field */
+		 *(u16 *)(dot11hdr + 1) = 0x0;
+		 framehdrlen += 2;
+	} else {
+		dot11hdr->frame_control |= cpu_to_le16(IEEE80211_STYPE_DATA);
+	}
+
+	memcpy(dot11hdr->addr1, priv->vif->bss_conf.bssid, ETH_ALEN);
+	memcpy(dot11hdr->addr2, priv->vif->addr, ETH_ALEN);
+	memcpy(dot11hdr->addr3, priv->vif->bss_conf.bssid, ETH_ALEN);
+
+	/* Filling the LLC/SNAP Hdr */
+	snaphdr = (struct ieee80211_snap_hdr *)((u8 *)dot11hdr + framehdrlen);
+	memcpy(snaphdr, (struct ieee80211_snap_hdr *)rfc1042_header, \
+		sizeof(*snaphdr));
+	*(u16 *)(++snaphdr) = cpu_to_be16(ETH_P_IPV6);
+	/* Updating the framebdylen with snaphdr and LLC hdr size */
+	framebdylen = sizeof(*snaphdr) + 2;
+
+	/* Filling the ipv6 header */
+	ipv6_hdr = (struct ipv6hdr *)((u8 *)dot11hdr + framehdrlen + framebdylen);
+	ipv6_hdr->version = 6;
+	ipv6_hdr->priority = 0;
+	/* ??? check the be or le ??? whether to use cpu_to_be16(32)*/
+	ipv6_hdr->payload_len = cpu_to_be16(32);
+	ipv6_hdr->nexthdr = 58;
+	ipv6_hdr->hop_limit = 255;
+
+	/* Updating the framebdylen with ipv6 Hdr */
+	framebdylen += sizeof(*ipv6_hdr);
+
+	/* Filling the Neighbor Advertisement */
+	na = (struct nd_msg *)((u8 *)dot11hdr + framehdrlen + framebdylen);
+	icmp6_hdr = (struct icmp6hdr *)(&na->icmph);
+	icmp6_hdr->icmp6_type = NDISC_NEIGHBOUR_ADVERTISEMENT;
+	icmp6_hdr->icmp6_code = 0;
+	/* checksum (2 bytes), RSO fields (4 bytes) and
+	 * target IP address (16 bytes) shall be filled by firmware */
+
+	/* Filling the target link layer address in the optional field */
+	opt_hdr = (struct nd_opt_hdr *)(&na->opt[0]);
+	opt_hdr->nd_opt_type = 2;
+	opt_hdr->nd_opt_len = 1;
+	/* optional target link layer address (6 bytes)
+	 * shall be filled by firmware */
+
+	/* Updating the framebdylen with the ipv6 payload length */
+	framebdylen += 32;
+
+	/* Updating the framebdylen with Encryption Tail Size */
+	framebdylen += encrypttailsize;
+
+	/* Filling the Template Frame Hdr */
+
+#ifdef SUPPORT_HT40
+
+	tmp_hdr->frame_type = WSM_FRAME_TYPE_NA; /* Template frame type */
+	tmp_hdr->rate_entry = 0x00F0; /* Rate to be fixed */
+	tmp_hdr->frmlen = framehdrlen + framebdylen;
+
+	ret = WARN_ON(wsm_write_mib(hw_priv,
+			WSM_MIB_ID_TEMPLATE_FRAME, (void *)tmp_hdr,
+			(framehdrlen+framebdylen+sizeof(*tmp_hdr)),
+			priv->if_id));
+
+	kfree((void *)tmp_hdr);
+
+#else
+
+	template_frame[0] = WSM_FRAME_TYPE_NA; /* Template frame type */
+	template_frame[1] = 0xFF; /* Rate to be fixed */
+	((u16 *)&template_frame[2])[0] = framehdrlen + framebdylen;
+
+	ret = SYS_WARN(wsm_write_mib(hw_priv, WSM_MIB_ID_TEMPLATE_FRAME, \
+				template_frame, (framehdrlen+framebdylen+4), \
+				priv->if_id));
+
+	kfree(template_frame);
+
+#endif
+
+exit_p:
+	return ret;
+}
+#endif /*IPV6_FILTERING*/
+
+#ifdef CONFIG_XRADIO_TESTMODE
+/**
+ * xradio_set_snap_frame -Set SNAP frame format
+ *
+ * @hw: the hardware
+ * @data: data frame
+ * @len: data length
+ *
+ * Returns: 0 on success or non zero value on failure
+ */
+static int xradio_set_snap_frame(struct ieee80211_hw *hw,
+				 u8 *data, int len)
+{
+	struct xr_msg_set_snap_frame *snap_frame =
+		(struct xr_msg_set_snap_frame *) data;
+	struct xradio_common *priv = (struct xradio_common *) hw->priv;
+	u8 frame_len = snap_frame->len;
+	u8 *frame = &snap_frame->frame[0];
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	/*
+	 * Check length of incoming frame format:
+	 * SNAP + SNAP_LEN (u8)
+	 */
+	if (frame_len + sizeof(snap_frame->len) != len)
+		return -EINVAL;
+
+	if (frame_len > 0) {
+		priv->test_frame.data = (u8 *) xr_krealloc(priv->test_frame.data,
+						sizeof(u8) * frame_len, false);
+		if (priv->test_frame.data == NULL) {
+			sta_printk(XRADIO_DBG_ERROR, "xradio_set_snap_frame memory" \
+					 "allocation failed");
+			priv->test_frame.len = 0;
+			return -EINVAL;
+		}
+		memcpy(priv->test_frame.data, frame, frame_len);
+	} else {
+		kfree(priv->test_frame.data);
+		priv->test_frame.data = NULL;
+	}
+	priv->test_frame.len = frame_len;
+	return 0;
+}
+
+#ifdef CONFIG_XRADIO_TESTMODE
+/**
+ * xradio_set_txqueue_params -Set txqueue
+ * params after successful TSPEC negotiation
+ *
+ * @hw: the hardware
+ * @data: data frame
+ * @len: data length
+ *
+ * Returns: 0 on success or non zero value on failure
+ */
+static int xradio_set_txqueue_params(struct ieee80211_hw *hw,
+				     u8 *data, int len)
+{
+	struct xr_msg_set_txqueue_params *txqueue_params =
+		(struct xr_msg_set_txqueue_params *) data;
+	struct xradio_common *hw_priv = (struct xradio_common *) hw->priv;
+	struct xradio_vif *priv;
+	/* Interface ID is hard coded here, as interface is not
+	 * passed in testmode command.
+	 * Also it is assumed here that STA will be on interface
+	 * 0 always.
+	 */
+
+	int if_id = 0;
+	u16 queueId = xradio_priority_to_queueId[txqueue_params->user_priority];
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	priv = xrwl_hwpriv_to_vifpriv(hw_priv, if_id);
+
+	if (unlikely(!priv)) {
+		sta_printk(XRADIO_DBG_ERROR, "%s: Warning Priv is Null\n",
+			   __func__);
+		return 0;
+	}
+	spin_unlock(&priv->vif_lock);
+
+	/* Default Ack policy is WSM_ACK_POLICY_NORMAL */
+	WSM_TX_QUEUE_SET(&priv->tx_queue_params,
+			queueId,
+			WSM_ACK_POLICY_NORMAL,
+			txqueue_params->medium_time,
+			txqueue_params->expiry_time);
+	return SYS_WARN(wsm_set_tx_queue_params(hw_priv,
+			&priv->tx_queue_params.params[queueId], queueId,
+			priv->if_id));
+}
+#endif /*CONFIG_XRADIO_TESTMODE*/
+
+/**
+ * xradio_tesmode_reply -called inside a testmode command
+ * handler to send a response to user space
+ *
+ * @wiphy: the wiphy
+ * @data: data to be send to user space
+ * @len: data length
+ *
+ * Returns: 0 on success or non zero value on failure
+ */
+static int xradio_tesmode_reply(struct wiphy *wiphy,
+				const void *data, int len)
+{
+	int ret = 0;
+	struct sk_buff *skb = NULL;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	skb = cfg80211_testmode_alloc_reply_skb(wiphy, nla_total_size(len));
+
+	if (!skb)
+		return -ENOMEM;
+
+	ret = nla_put(skb, XR_TM_MSG_DATA, len, data);
+	if (ret) {
+		kfree_skb(skb);
+		return ret;
+	}
+
+	return cfg80211_testmode_reply(skb);
+}
+
+/**
+ * xradio_tesmode_event -send asynchronous event
+ * to userspace
+ *
+ * @wiphy: the wiphy
+ * @msg_id: XR msg ID
+ * @data: data to be sent
+ * @len: data length
+ * @gfp: allocation flag
+ *
+ * Returns: 0 on success or non zero value on failure
+ */
+int xradio_tesmode_event(struct wiphy *wiphy, const u32 msg_id,
+			 const void *data, int len, gfp_t gfp)
+{
+	struct sk_buff *skb = NULL;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	skb = cfg80211_testmode_alloc_event_skb(wiphy,
+	      nla_total_size(len+sizeof(msg_id)), gfp);
+	if (!skb)
+		return -ENOMEM;
+
+	NLA_PUT_U32(skb, XR_TM_MSG_ID, msg_id);
+	if (data)
+		NLA_PUT(skb, XR_TM_MSG_DATA, len, data);
+
+	cfg80211_testmode_event(skb, gfp);
+	return 0;
+nla_put_failure:
+	kfree_skb(skb);
+	return -ENOBUFS;
+}
+
+/**
+ * example function for test purposes
+ * sends both: synchronous reply and asynchronous event
+ */
+static int xradio_test(struct ieee80211_hw *hw,
+		       void *data, int len)
+{
+	struct xr_msg_test_t *test_p;
+	struct xr_reply_test_t reply;
+	struct xr_event_test_t event;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (sizeof(struct xr_msg_test_t)  != len)
+		return -EINVAL;
+
+	test_p = (struct xr_msg_test_t *) data;
+
+	reply.dummy = test_p->dummy + 10;
+
+	event.dummy = test_p->dummy + 20;
+
+	if (xradio_tesmode_event(hw->wiphy, XR_MSG_EVENT_TEST,
+		&event, sizeof(event), GFP_KERNEL))
+		return -1;
+
+	return xradio_tesmode_reply(hw->wiphy, &reply, sizeof(reply));
+}
+
+/**
+ * xradio_get_tx_power_level - send tx power level
+ * to userspace
+ *
+ * @hw: the hardware
+ *
+ * Returns: 0 on success or non zero value on failure
+ */
+int xradio_get_tx_power_level(struct ieee80211_hw *hw)
+{
+	struct xradio_common *hw_priv = hw->priv;
+	int get_power = 0;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	get_power = hw_priv->output_power;
+	sta_printk(XRADIO_DBG_MSG, "%s: Power set on Device : %d",
+		__func__, get_power);
+	return xradio_tesmode_reply(hw->wiphy, &get_power, sizeof(get_power));
+}
+
+/**
+ * xradio_get_tx_power_range- send tx power range
+ * to userspace for each band
+ *
+ * @hw: the hardware
+ *
+ * Returns: 0 on success or non zero value on failure
+ */
+int xradio_get_tx_power_range(struct ieee80211_hw *hw)
+{
+	struct xradio_common *hw_priv = hw->priv;
+	struct wsm_tx_power_range txPowerRange[2];
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	size_t len = sizeof(txPowerRange);
+	memcpy(txPowerRange, hw_priv->txPowerRange, len);
+	return xradio_tesmode_reply(hw->wiphy, txPowerRange, len);
+}
+
+/**
+ * xradio_set_advance_scan_elems -Set Advcance Scan
+ * elements
+ * @hw: the hardware
+ * @data: data frame
+ * @len: data length
+ *
+ * Returns: 0 on success or non zero value on failure
+ */
+static int xradio_set_advance_scan_elems(struct ieee80211_hw *hw,
+				 u8 *data, int len)
+{
+	struct advance_scan_elems *scan_elems =
+		(struct advance_scan_elems *) data;
+	struct xradio_common *hw_priv = (struct xradio_common *) hw->priv;
+	size_t elems_len = sizeof(struct advance_scan_elems);
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (elems_len != len)
+		return -EINVAL;
+
+	scan_elems = (struct advance_scan_elems *) data;
+
+	/* Locks required to prevent simultaneous scan */
+	down(&hw_priv->scan.lock);
+	down(&hw_priv->conf_lock);
+
+	hw_priv->advanceScanElems.scanMode = scan_elems->scanMode;
+	hw_priv->advanceScanElems.duration = scan_elems->duration;
+	hw_priv->enable_advance_scan = true;
+
+	up(&hw_priv->conf_lock);
+	up(&hw_priv->scan.lock);
+
+	return 0;
+}
+
+/**
+ * xradio_set_power_save -Set Power Save
+ * elements
+ * @hw: the hardware
+ * @data: data frame
+ * @len: data length
+ *
+ * Returns: 0 on success or non zero value on failure
+ */
+static int xradio_set_power_save(struct ieee80211_hw *hw,
+				 u8 *data, int len)
+{
+	struct power_save_elems *ps_elems =
+		(struct power_save_elems *) data;
+	struct xradio_common *hw_priv = (struct xradio_common *) hw->priv;
+	size_t elems_len = sizeof(struct power_save_elems);
+	struct xradio_vif *priv;
+	int if_id = 0;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	/* Interface ID is hard coded here, as interface is not
+	* passed in testmode command.
+	* Also it is assumed here that STA will be on interface
+	* 0 always. */
+
+	if (elems_len != len)
+		return -EINVAL;
+
+	priv = xrwl_hwpriv_to_vifpriv(hw_priv, if_id);
+
+	if (unlikely(!priv)) {
+		sta_printk(XRADIO_DBG_ERROR, "%s: Warning Priv is Null\n",
+			   __func__);
+		return 0;
+	}
+
+	spin_unlock(&priv->vif_lock);
+	down(&hw_priv->conf_lock);
+
+	ps_elems = (struct power_save_elems *) data;
+
+	if (ps_elems->powerSave == 1)
+		priv->user_pm_mode = WSM_PSM_PS;
+	else
+		priv->user_pm_mode = WSM_PSM_FAST_PS;
+
+	sta_printk(XRADIO_DBG_MSG, "Aid: %d, Joined: %s, Powersave: %s\n",
+		priv->bss_params.aid,
+		priv->join_status == XRADIO_JOIN_STATUS_STA ? "yes" : "no",
+		priv->user_pm_mode == WSM_PSM_ACTIVE ? "WSM_PSM_ACTIVE" :
+		priv->user_pm_mode == WSM_PSM_PS ? "WSM_PSM_PS" :
+		priv->user_pm_mode == WSM_PSM_FAST_PS ? "WSM_PSM_FAST_PS" : "UNKNOWN");
+	if (priv->join_status == XRADIO_JOIN_STATUS_STA &&
+			priv->bss_params.aid &&
+			priv->setbssparams_done &&
+			priv->filter4.enable) {
+		priv->powersave_mode.pmMode = priv->user_pm_mode;
+		xradio_set_pm(priv, &priv->powersave_mode);
+	} else {
+		priv->user_power_set_true = ps_elems->powerSave;
+	}
+	up(&hw_priv->conf_lock);
+	return 0;
+}
+/**
+ * xradio_start_stop_tsm - starts/stops collecting TSM
+ *
+ * @hw: the hardware
+ * @data: data frame
+ *
+ * Returns: 0 on success or non zero value on failure
+ */
+int xradio_start_stop_tsm(struct ieee80211_hw *hw, void *data)
+{
+	struct xr_msg_start_stop_tsm *start_stop_tsm =
+		(struct xr_msg_start_stop_tsm *) data;
+	struct xradio_common *hw_priv = hw->priv;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	hw_priv->start_stop_tsm.start = start_stop_tsm->start;
+	hw_priv->start_stop_tsm.up = start_stop_tsm->up;
+	hw_priv->start_stop_tsm.packetization_delay =
+		start_stop_tsm->packetization_delay;
+	sta_printk(XRADIO_DBG_MSG, "%s: start : %u: up : %u",
+		__func__, hw_priv->start_stop_tsm.start,
+		hw_priv->start_stop_tsm.up);
+	hw_priv->tsm_info.ac = xradio_1d_to_ac[start_stop_tsm->up];
+
+	if (!hw_priv->start_stop_tsm.start) {
+		spin_lock_bh(&hw_priv->tsm_lock);
+		memset(&hw_priv->tsm_stats, 0, sizeof(hw_priv->tsm_stats));
+		memset(&hw_priv->tsm_info, 0, sizeof(hw_priv->tsm_info));
+		spin_unlock_bh(&hw_priv->tsm_lock);
+	}
+	return 0;
+}
+
+/**
+ * xradio_get_tsm_params - Retrieves TSM parameters
+ *
+ * @hw: the hardware
+ *
+ * Returns: TSM parameters collected
+ */
+int xradio_get_tsm_params(struct ieee80211_hw *hw)
+{
+	struct xradio_common *hw_priv = hw->priv;
+	struct xr_tsm_stats tsm_stats;
+	u32 pkt_count;
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	spin_lock_bh(&hw_priv->tsm_lock);
+	pkt_count = hw_priv->tsm_stats.txed_msdu_count -
+			 hw_priv->tsm_stats.msdu_discarded_count;
+	if (pkt_count) {
+		hw_priv->tsm_stats.avg_q_delay =
+			hw_priv->tsm_info.sum_pkt_q_delay/(pkt_count * 1000);
+		hw_priv->tsm_stats.avg_transmit_delay =
+			hw_priv->tsm_info.sum_media_delay/pkt_count;
+	} else {
+		hw_priv->tsm_stats.avg_q_delay = 0;
+		hw_priv->tsm_stats.avg_transmit_delay = 0;
+	}
+	sta_printk(XRADIO_DBG_MSG, "%s: Txed MSDU count : %u",
+		__func__, hw_priv->tsm_stats.txed_msdu_count);
+	sta_printk(XRADIO_DBG_MSG, "%s: Average queue delay : %u",
+			__func__, hw_priv->tsm_stats.avg_q_delay);
+	sta_printk(XRADIO_DBG_MSG, "%s: Average transmit delay : %u",
+			__func__, hw_priv->tsm_stats.avg_transmit_delay);
+	memcpy(&tsm_stats, &hw_priv->tsm_stats, sizeof(hw_priv->tsm_stats));
+	/* Reset the TSM statistics */
+	memset(&hw_priv->tsm_stats, 0, sizeof(hw_priv->tsm_stats));
+	hw_priv->tsm_info.sum_pkt_q_delay = 0;
+	hw_priv->tsm_info.sum_media_delay = 0;
+	spin_unlock_bh(&hw_priv->tsm_lock);
+	return xradio_tesmode_reply(hw->wiphy, &tsm_stats,
+				     sizeof(hw_priv->tsm_stats));
+}
+
+/**
+ * xradio_get_roam_delay - Retrieves roam delay
+ *
+ * @hw: the hardware
+ *
+ * Returns: Returns the last measured roam delay
+ */
+int xradio_get_roam_delay(struct ieee80211_hw *hw)
+{
+	struct xradio_common *hw_priv = hw->priv;
+	u16 roam_delay = hw_priv->tsm_info.roam_delay / 1000;
+	sta_printk(XRADIO_DBG_MSG, "%s: Roam delay : %u",
+		__func__, roam_delay);
+
+	spin_lock_bh(&hw_priv->tsm_lock);
+	hw_priv->tsm_info.roam_delay = 0;
+	hw_priv->tsm_info.use_rx_roaming = 0;
+	spin_unlock_bh(&hw_priv->tsm_lock);
+	return xradio_tesmode_reply(hw->wiphy, &roam_delay, sizeof(u16));
+}
+
+/**
+ * xradio_testmode_cmd -called when tesmode command
+ * reaches xradio
+ *
+ * @hw: the hardware
+ * @data: incoming data
+ * @len: incoming data length
+ *
+ * Returns: 0 on success or non zero value on failure
+ */
+int xradio_testmode_cmd(struct ieee80211_hw *hw, void *data, int len)
+{
+	int ret = 0;
+	struct nlattr *type_p = nla_find(data, len, XR_TM_MSG_ID);
+	struct nlattr *data_p = nla_find(data, len, XR_TM_MSG_DATA);
+	sta_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (!type_p || !data_p)
+		return -EINVAL;
+
+	sta_printk(XRADIO_DBG_MSG,  "%s: type: %i",
+		   __func__, nla_get_u32(type_p));
+
+	switch (nla_get_u32(type_p)) {
+	case XR_MSG_TEST:
+		ret = xradio_test(hw,
+			nla_data(data_p), nla_len(data_p));
+		break;
+	case XR_MSG_SET_SNAP_FRAME:
+		ret = xradio_set_snap_frame(hw, (u8 *) nla_data(data_p),
+			nla_len(data_p));
+		break;
+	case XR_MSG_GET_TX_POWER_LEVEL:
+		ret = xradio_get_tx_power_level(hw);
+		break;
+	case XR_MSG_GET_TX_POWER_RANGE:
+		ret = xradio_get_tx_power_range(hw);
+		break;
+	case XR_MSG_SET_ADVANCE_SCAN_ELEMS:
+		ret = xradio_set_advance_scan_elems(hw, (u8 *) nla_data(data_p),
+			nla_len(data_p));
+		break;
+	case XR_MSG_SET_TX_QUEUE_PARAMS:
+		ret = xradio_set_txqueue_params(hw, (u8 *) nla_data(data_p),
+			nla_len(data_p));
+		break;
+	case XR_MSG_GET_TSM_PARAMS:
+		ret = xradio_get_tsm_params(hw);
+		break;
+	case XR_MSG_START_STOP_TSM:
+		ret = xradio_start_stop_tsm(hw, (u8 *) nla_data(data_p));
+		break;
+	case XR_MSG_GET_ROAM_DELAY:
+		ret = xradio_get_roam_delay(hw);
+		break;
+	case XR_MSG_SET_POWER_SAVE:
+		ret = xradio_set_power_save(hw, (u8 *) nla_data(data_p),
+			nla_len(data_p));
+		break;
+	default:
+		break;
+	}
+	return ret;
+}
+#endif /* CONFIG_XRADIO_TESTMODE */
diff -Naurp a/drivers/net/wireless/xr829/wlan/sta.h b/drivers/net/wireless/xr829/wlan/sta.h
--- a/drivers/net/wireless/xr829/wlan/sta.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/sta.h	2022-08-27 01:22:42.970539923 +0300
@@ -0,0 +1,153 @@
+/*
+ * sta interfaces for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef STA_H_INCLUDED
+#define STA_H_INCLUDED
+
+
+#ifdef XRADIO_USE_LONG_KEEP_ALIVE_PERIOD
+#define XRADIO_KEEP_ALIVE_PERIOD         (28)
+#else
+/*For Samsung, it is defined as 4*/
+#define XRADIO_KEEP_ALIVE_PERIOD         (4)
+#endif
+
+#define XRADIO_BSS_LOSS_THOLD_DEF  30 /* better than 20 */
+#define XRADIO_LINK_LOSS_THOLD_DEF 50 /* better than 40 */
+
+/* ******************************************************************** */
+/* mac80211 API								*/
+
+int xradio_start(struct ieee80211_hw *dev);
+void xradio_stop(struct ieee80211_hw *dev);
+int xradio_add_interface(struct ieee80211_hw *dev, struct ieee80211_vif *vif);
+void xradio_remove_interface(struct ieee80211_hw *dev,
+							struct ieee80211_vif *vif);
+int xradio_change_interface(struct ieee80211_hw *dev,
+							struct ieee80211_vif *vif,
+							enum nl80211_iftype new_type,
+							bool p2p);
+int xradio_config(struct ieee80211_hw *dev, u32 changed);
+int xradio_change_interface(struct ieee80211_hw *dev,
+							struct ieee80211_vif *vif,
+							enum nl80211_iftype new_type,
+							bool p2p);
+void xradio_configure_filter(struct ieee80211_hw *dev,
+							struct ieee80211_vif *vif,
+							unsigned int changed_flags,
+							unsigned int *total_flags,
+							u64 multicast);
+int xradio_conf_tx(struct ieee80211_hw *dev, struct ieee80211_vif *vif,
+				   u16 queue, const struct ieee80211_tx_queue_params *params);
+int xradio_get_stats(struct ieee80211_hw *dev,
+					 struct ieee80211_low_level_stats *stats);
+/* Not more a part of interface?
+int xradio_get_tx_stats(struct ieee80211_hw *dev,
+			struct ieee80211_tx_queue_stats *stats);
+*/
+int xradio_set_key(struct ieee80211_hw *dev, enum set_key_cmd cmd,
+				   struct ieee80211_vif *vif, struct ieee80211_sta *sta,
+				   struct ieee80211_key_conf *key);
+int xradio_set_rts_threshold(struct ieee80211_hw *hw,
+							 struct ieee80211_vif *vif, u32 value);
+void xradio_flush(struct ieee80211_hw *hw,
+				  struct ieee80211_vif *vif,
+				  bool drop);
+int xradio_remain_on_channel(struct ieee80211_hw *hw,
+							 struct ieee80211_vif *vif,
+							 struct ieee80211_channel *chan,
+							 enum nl80211_channel_type channel_type,
+							 int duration, u64 cookie);
+int xradio_cancel_remain_on_channel(struct ieee80211_hw *hw);
+int xradio_set_arpreply(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
+u64 xradio_prepare_multicast(struct ieee80211_hw *hw,
+							 struct ieee80211_vif *vif,
+							 struct netdev_hw_addr_list *mc_list);
+int xradio_set_pm(struct xradio_vif *priv, const struct wsm_set_pm *arg);
+void xradio_set_data_filter(struct ieee80211_hw *hw,
+							struct ieee80211_vif *vif,
+							void *data,
+							int len);
+int xradio_change_mac(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif, struct sockaddr *sa);
+
+
+/* ******************************************************************** */
+/* WSM callbacks							*/
+
+/* void xradio_set_pm_complete_cb(struct xradio_common *hw_priv,
+	struct wsm_set_pm_complete *arg); */
+void xradio_channel_switch_cb(struct xradio_common *hw_priv);
+
+/* ******************************************************************** */
+/* WSM events								*/
+
+void xradio_free_event_queue(struct xradio_common *hw_priv);
+void xradio_event_handler(struct work_struct *work);
+void xradio_bss_loss_work(struct work_struct *work);
+void xradio_connection_loss_work(struct work_struct *work);
+void xradio_keep_alive_work(struct work_struct *work);
+void xradio_tx_failure_work(struct work_struct *work);
+
+/* ******************************************************************** */
+/* Internal API								*/
+
+int xradio_setup_mac(struct xradio_common *hw_priv);
+void xradio_join_work(struct work_struct *work);
+void xradio_join_timeout(struct work_struct *work);
+void xradio_unjoin_work(struct work_struct *work);
+void xradio_offchannel_work(struct work_struct *work);
+void xradio_wep_key_work(struct work_struct *work);
+void xradio_update_filtering(struct xradio_vif *priv);
+void xradio_update_filtering_work(struct work_struct *work);
+int __xradio_flush(struct xradio_common *hw_priv, bool drop, int if_id);
+void xradio_set_beacon_wakeup_period_work(struct work_struct *work);
+int xradio_enable_listening(struct xradio_vif *priv,
+							struct ieee80211_channel *chan);
+int xradio_disable_listening(struct xradio_vif *priv);
+int xradio_set_uapsd_param(struct xradio_vif *priv,
+						   const struct wsm_edca_params *arg);
+void xradio_ba_work(struct work_struct *work);
+void xradio_ba_timer(struct timer_list *t);
+const u8 *xradio_get_ie(u8 *start, size_t len, u8 ie);
+int xradio_vif_setup(struct xradio_vif *priv);
+int xradio_setup_mac_pvif(struct xradio_vif *priv);
+void xradio_iterate_vifs(void *data, u8 *mac, struct ieee80211_vif *vif);
+void xradio_rem_chan_timeout(struct work_struct *work);
+int xradio_set_macaddrfilter(struct xradio_common *hw_priv,
+							 struct xradio_vif *priv, u8 *data);
+
+/* BT */
+void xradio_bt_timer(struct timer_list *t);
+
+#ifdef MONITOR_MODE
+void xradio_channel_switch(struct xradio_common *hw_priv,
+						   struct ieee80211_channel *chan);
+int xradio_enable_monitoring(struct xradio_vif *priv,
+							 struct ieee80211_channel *chan);
+int xradio_disable_monitoring(struct xradio_vif *priv);
+#endif
+#ifdef ROAM_OFFLOAD
+int xradio_testmode_event(struct wiphy *wiphy, const u32 msg_id,
+			  const void *data, int len, gfp_t gfp);
+#endif /*ROAM_OFFLOAD*/
+#ifdef IPV6_FILTERING
+int xradio_set_na(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
+#endif /*IPV6_FILTERING*/
+#ifdef CONFIG_XRADIO_TESTMODE
+void xradio_device_power_calc(struct xradio_common *priv,
+			      s16 max_output_power, s16 fe_cor, u32 band);
+int xradio_testmode_cmd(struct ieee80211_hw *hw, void *data, int len);
+int xradio_tesmode_event(struct wiphy *wiphy, const u32 msg_id,
+			 const void *data, int len, gfp_t gfp);
+int xradio_get_tx_power_range(struct ieee80211_hw *hw);
+int xradio_get_tx_power_level(struct ieee80211_hw *hw);
+#endif /* CONFIG_XRADIO_TESTMODE */
+#endif
diff -Naurp a/drivers/net/wireless/xr829/wlan/timeval.h b/drivers/net/wireless/xr829/wlan/timeval.h
--- a/drivers/net/wireless/xr829/wlan/timeval.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/timeval.h	2022-08-27 01:22:42.970539923 +0300
@@ -0,0 +1,6 @@
+#include <linux/types.h>
+#include <linux/time_types.h>
+struct timeval {
+	__kernel_old_time_t	tv_sec;		/* seconds */
+	__kernel_suseconds_t	tv_usec;	/* microseconds */
+};
diff -Naurp a/drivers/net/wireless/xr829/wlan/txrx.c b/drivers/net/wireless/xr829/wlan/txrx.c
--- a/drivers/net/wireless/xr829/wlan/txrx.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/txrx.c	2022-08-27 01:22:42.974539938 +0300
@@ -0,0 +1,3316 @@
+/*
+ * Datapath implementation for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <net/mac80211.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/time64.h>
+
+#include "xradio.h"
+#include "wsm.h"
+#include "bh.h"
+#include "ap.h"
+#include "sta.h"
+#include "sbus.h"
+
+#ifndef SUPPORT_HT40
+
+#define B_RATE_INDEX   0     /* 11b rate for important short frames in 2.4G. */
+#define AG_RATE_INDEX  6     /* 11a/g rate for important short frames in 5G. */
+#define XRADIO_INVALID_RATE_ID (0xFF)
+
+#endif
+
+/* rate should fall quickly to avoid dropping frames by aps.*/
+#ifdef ENHANCE_ANTI_INTERFERE
+#define HIGH_RATE_MAX_RETRY  9
+#else
+#define HIGH_RATE_MAX_RETRY  7
+#endif
+
+#ifdef CONFIG_XRADIO_TESTMODE
+#include "nl80211_testmode_msg_copy.h"
+#endif /* CONFIG_XRADIO_TESTMODE */
+#ifdef TES_P2P_0002_ROC_RESTART
+#include <linux/time.h>
+#endif
+static const struct ieee80211_rate *xradio_get_tx_rate(
+							const struct xradio_common *hw_priv,
+							const struct ieee80211_tx_rate *rate);
+
+#ifdef SUPPORT_HT40
+
+u32 TxedHtofdmRateMap[4][8] = { {0x0} };
+u32 TxedLegacyRateMap[2][8] = { {0x0} };
+
+u32 RxedHtofdmRateMap[4][8] = { {0x0} };
+u32 RxedLegacyRateMap[2][8] = { {0x0} };
+
+u8 LegacyRxedRateLut[2][14] = {
+	{
+		0, 1, 2, 3, 0, 0, 4, 5, 6, 7, 8, 9, 10, 11
+	},
+	{
+		0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7
+	}
+};
+
+#else
+
+u32 TxedRateIdx_Map[24] = { 0 };
+u32 RxedRateIdx_Map[24] = { 0 };
+
+#endif
+
+/* ******************************************************************** */
+/* TX policy cache implementation					*/
+
+static void tx_policy_dump(struct tx_policy *policy)
+{
+	txrx_printk(XRADIO_DBG_MSG, "[TX policy] "
+		    "%.1X%.1X%.1X%.1X%.1X%.1X%.1X%.1X"
+		    "%.1X%.1X%.1X%.1X%.1X%.1X%.1X%.1X"
+		    "%.1X%.1X%.1X%.1X%.1X%.1X%.1X%.1X: %d\n",
+		    policy->raw[0] & 0x0F, policy->raw[0] >> 4,
+		    policy->raw[1] & 0x0F, policy->raw[1] >> 4,
+		    policy->raw[2] & 0x0F, policy->raw[2] >> 4,
+		    policy->raw[3] & 0x0F, policy->raw[3] >> 4,
+		    policy->raw[4] & 0x0F, policy->raw[4] >> 4,
+		    policy->raw[5] & 0x0F, policy->raw[5] >> 4,
+		    policy->raw[6] & 0x0F, policy->raw[6] >> 4,
+		    policy->raw[7] & 0x0F, policy->raw[7] >> 4,
+		    policy->raw[8] & 0x0F, policy->raw[8] >> 4,
+		    policy->raw[9] & 0x0F, policy->raw[9] >> 4,
+		    policy->raw[10] & 0x0F, policy->raw[10] >> 4,
+		    policy->raw[11] & 0x0F, policy->raw[11] >> 4,
+		    policy->defined);
+}
+
+static void xradio_check_go_neg_conf_success(struct xradio_common *hw_priv,
+					     u8 *action)
+{
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	if (action[2] == 0x50 && action[3] == 0x6F && action[4] == 0x9A &&
+	    action[5] == 0x09 && action[6] == 0x02) {
+		if (action[17] == 0) {
+			hw_priv->is_go_thru_go_neg = true;
+		} else {
+			hw_priv->is_go_thru_go_neg = false;
+		}
+	}
+}
+
+#ifdef TES_P2P_0002_ROC_RESTART
+/*
+ * TES_P2P_0002 WorkAround:
+ * P2P GO Neg Process and P2P FIND may be collision.
+ * When P2P Device is waiting for GO NEG CFM in 30ms,
+ * P2P FIND may end with p2p listen, and then goes to p2p search.
+ * Then xradio scan will occupy phy on other channel in 3+ seconds.
+ * P2P Device will not be able to receive the GO NEG CFM.
+ * We extend the roc period to remaind phy to receive
+ * GO NEG CFM as WorkAround.
+ */
+
+s32 TES_P2P_0002_roc_dur;
+s32 TES_P2P_0002_roc_sec;
+s32 TES_P2P_0002_roc_usec;
+u32 TES_P2P_0002_packet_id;
+u32 TES_P2P_0002_state = TES_P2P_0002_STATE_IDLE;
+
+static void xradio_frame_monitor(struct xradio_common *hw_priv,
+				 struct sk_buff *skb, bool tx)
+{
+	struct ieee80211_hdr *frame = (struct ieee80211_hdr *)skb->data;
+	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;
+
+	u8 *action = (u8 *) &mgmt->u.action.category;
+	u8 *category_code = &(action[0]);
+	u8 *action_code = &(action[1]);
+	u8 *oui = &(action[2]);
+	u8 *subtype = &(action[5]);
+	u8 *oui_subtype = &(action[6]);
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (ieee80211_is_action(frame->frame_control) &&
+	   *category_code == WLAN_CATEGORY_PUBLIC &&
+	   *action_code == 0x09) {
+		if ((oui[0] == 0x50) && (oui[1] == 0x6F) &&
+		   (oui[2] == 0x9A) && (*subtype == 0x09)) {
+			/* w, GO Negotiation Response */
+			if (*oui_subtype == 0x01) {
+				if ((TES_P2P_0002_state == TES_P2P_0002_STATE_IDLE) &&
+				   (tx == true)) { /* w, p2p atturbute:status, id=0 */
+					u8 *go_neg_resp_res = &(action[17]);
+					if (*go_neg_resp_res == 0x0) {
+						TES_P2P_0002_state = TES_P2P_0002_STATE_SEND_RESP;
+						txrx_printk(XRADIO_DBG_NIY,
+							    "[ROC_RESTART_STATE_SEND_RESP]\n");
+					}
+				}
+			/* w, GO Negotiation Confirmation */
+			} else if (*oui_subtype == 0x02) {
+				if (tx == false) {
+					TES_P2P_0002_state = TES_P2P_0002_STATE_IDLE;
+					txrx_printk(XRADIO_DBG_NIY, "[ROC_RESTART_STATE_IDLE]"
+						    "[GO Negotiation Confirmation]\n");
+				}
+			/* w, Provision Discovery Response */
+			} else if (*oui_subtype == 0x08) {
+				if (tx == false) {
+					TES_P2P_0002_state = TES_P2P_0002_STATE_IDLE;
+					txrx_printk(XRADIO_DBG_NIY, "[ROC_RESTART_STATE_IDLE]"
+						    "[Provision Discovery Response]\n");
+				}
+			}
+		}
+	}
+}
+#endif
+
+static void xradio_check_prov_desc_req(struct xradio_common *hw_priv,
+						u8 *action)
+{
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	if (action[2] == 0x50 && action[3] == 0x6F && action[4] == 0x9A &&
+	    action[5] == 0x09 && action[6] == 0x07) {
+		hw_priv->is_go_thru_go_neg = false;
+	}
+}
+
+#ifdef AP_HT_COMPAT_FIX
+#define AP_COMPAT_THRESHOLD  2000
+#define AP_COMPAT_MIN_CNT    200
+u8 ap_compat_bssid[ETH_ALEN] = { 0 };
+
+#ifdef SUPPORT_HT40
+
+static int xradio_apcompat_detect(struct xradio_vif *priv, u16 rxedRateEntry)
+
+#else
+
+static int xradio_apcompat_detect(struct xradio_vif *priv, u8 rx_rate)
+
+#endif
+{
+
+#ifdef SUPPORT_HT40
+
+	if ((GET_RATE_ENTRY_MODEM(rxedRateEntry) == FW_RATE_MODEM_LEGACY)
+		&& (GET_RATE_ENTRY_RATEINDEX(rxedRateEntry) < 6)) {
+
+#else
+
+	if (rx_rate < AG_RATE_INDEX) {
+
+#endif
+		priv->ht_compat_cnt++;
+
+#ifdef SUPPORT_HT40
+
+		txrx_printk(XRADIO_DBG_MSG, "%s:rate=%d.\n",
+			__func__, GET_RATE_ENTRY_RATEINDEX(rxedRateEntry));
+
+#else
+
+		txrx_printk(XRADIO_DBG_MSG, "%s:rate=%d.\n", __func__, rx_rate);
+
+#endif
+
+	} else {
+		priv->ht_compat_det |= 1;
+		priv->ht_compat_cnt = 0;
+		txrx_printk(XRADIO_DBG_NIY, "%s:HT compat detect\n", __func__);
+		return 0;
+	}
+
+	/* Enhance compatibility with some illegal APs.*/
+	if (priv->ht_compat_cnt  > AP_COMPAT_THRESHOLD ||
+		(priv->ht_compat_cnt > AP_COMPAT_MIN_CNT &&
+		 priv->bssid[0] == 0xC8 &&
+		 priv->bssid[1] == 0x3A &&
+		 priv->bssid[2] == 0x35)) {
+		struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+		memcpy(ap_compat_bssid, priv->bssid, ETH_ALEN);
+		wsm_send_disassoc_to_self(hw_priv, priv);
+		txrx_printk(XRADIO_DBG_WARN, "%s:SSID=%s, BSSID=" \
+			    "%02x:%02x:%02x:%02x:%02x:%02x\n", __func__, priv->ssid,
+			    ap_compat_bssid[0], ap_compat_bssid[1],
+			    ap_compat_bssid[2], ap_compat_bssid[3],
+			    ap_compat_bssid[4], ap_compat_bssid[5]);
+		return 1;
+	}
+	return 0;
+}
+
+static void xradio_remove_ht_ie(struct xradio_vif *priv, struct sk_buff *skb)
+{
+	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;
+	u8 *ies        = NULL;
+	size_t ies_len = 0;
+	u8 *ht_ie      = NULL;
+
+	if (!mgmt || memcmp(ap_compat_bssid, mgmt->bssid, ETH_ALEN))
+		return;
+
+	if (ieee80211_is_probe_resp(mgmt->frame_control))
+		ies = mgmt->u.probe_resp.variable;
+	else if (ieee80211_is_beacon(mgmt->frame_control))
+		ies = mgmt->u.beacon.variable;
+	else if (ieee80211_is_assoc_resp(mgmt->frame_control))
+		ies = mgmt->u.assoc_resp.variable;
+	else if (ieee80211_is_assoc_req(mgmt->frame_control))
+		ies = mgmt->u.assoc_req.variable;
+	else
+		return;
+
+	ies_len = skb->len - (ies - (u8 *)(skb->data));
+	ht_ie   = (u8 *)xradio_get_ie(ies, ies_len, WLAN_EID_HT_CAPABILITY);
+	if (ht_ie) {
+		u8 ht_len   = *(ht_ie + 1) + 2;
+		u8 move_len = (ies + ies_len) - (ht_ie + ht_len);
+		memmove(ht_ie, (ht_ie + ht_len), move_len);
+		skb_trim(skb, skb->len - ht_len);
+		ies_len = skb->len - (ies - (u8 *)(skb->data));
+		ht_ie = (u8 *)xradio_get_ie(ies, ies_len, WLAN_EID_HT_INFORMATION);
+		if (ht_ie) {
+			ht_len   = *(ht_ie + 1) + 2;
+			move_len = (ies + ies_len) - (ht_ie + ht_len);
+			memmove(ht_ie, (ht_ie + ht_len), move_len);
+			skb_trim(skb, skb->len - ht_len);
+		}
+	}
+	txrx_printk(XRADIO_DBG_WARN, "%s: BSSID=%02x:%02x:%02x:%02x:%02x:%02x\n",
+		    __func__,
+		    mgmt->bssid[0], mgmt->bssid[1],
+		    mgmt->bssid[2], mgmt->bssid[3],
+		    mgmt->bssid[4], mgmt->bssid[5]);
+}
+#endif /*AP_HT_COMPAT_FIX*/
+
+#ifdef SUPPORT_HT40
+
+static inline u8 xradio_rate_to_entry_idx(u8 flags, u8 hw_value)
+{
+	u8 entryIndex = 0xF;
+	if (flags & IEEE80211_TX_RC_MCS)
+		entryIndex = hw_value - MCS_RATES_OFF;
+	else
+		entryIndex = hw_value;
+	return entryIndex;
+}
+
+#endif
+
+static void tx_policy_build(struct xradio_vif *priv,
+	/* [out] */ struct tx_policy *policy,
+	struct ieee80211_tx_rate *rates, size_t count)
+{
+	int i, j;
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	struct ieee80211_rate *tmp_rate = NULL;
+	unsigned limit = hw_priv->short_frame_max_tx_count;
+	unsigned max_rates_cnt = count;
+	unsigned total = 0;
+	u8 lowest_rate_idx = 0;
+	SYS_BUG(rates[0].idx < 0);
+	memset(policy, 0, sizeof(*policy));
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	txrx_printk(XRADIO_DBG_MSG, "============================");
+
+#ifdef SUPPORT_HT40
+
+	/* calculate the tx policy count and max retry times */
+	total = rates[0].count;
+	for (i = 1; i < count; ++i) {
+		if (rates[i].idx < 0 || i >= limit) {
+			count = i;
+			break;
+		} else {
+			total += rates[i].count;
+		}
+	}
+
+#else
+
+	/*
+	 * minstrel is buggy a little bit, so distille
+	 * incoming rates first.
+	 */
+	/* Sort rates in descending order. */
+	total = rates[0].count;
+	for (i = 1; i < count; ++i) {
+		if (rates[i].idx > rates[i-1].idx) {
+			rates[i].idx = rates[i-1].idx > 0 ? (rates[i-1].idx - 1) : -1;
+		}
+		if (rates[i].idx < 0 || i >= limit) {
+			count = i;
+			break;
+		} else {
+			total += rates[i].count;
+		}
+	}
+#endif
+
+	/*
+	 * Add lowest rate to the end.
+	 * TODO: it's better to do this in rate control of mac80211.
+	 */
+	if (unlikely(!(rates[0].flags & IEEE80211_TX_RC_MCS)) &&
+		hw_priv->channel->band == NL80211_BAND_2GHZ) {
+		u32 rateset = (priv->oper_rates | priv->base_rates) & ~0xf;
+		if (rateset)
+			lowest_rate_idx = __ffs(rateset);
+		else
+			lowest_rate_idx = 0xff;
+		txrx_printk(XRADIO_DBG_MSG, "rateset=0x%x, lowest_rate_idx=%d\n",
+					rateset, lowest_rate_idx);
+	}
+	if (count < max_rates_cnt && rates[count-1].idx > lowest_rate_idx) {
+		rates[count].idx   = lowest_rate_idx;
+		rates[count].count = rates[0].count;
+		rates[count].flags = rates[0].flags;
+		rates[count].flags &= (~IEEE80211_TX_RC_40_MHZ_WIDTH);
+		rates[count].flags &= (~IEEE80211_TX_RC_SHORT_GI);
+		total += rates[count].count;
+		count++;
+	}
+
+	/*
+	 * Adjust tx count to limit, rates should fall quickly
+	 * and lower rates should be more retry, because reorder
+	 * buffer of reciever will be timeout and clear probably.
+	 */
+	if (count < 2) {
+		rates[0].count = limit;
+		total = limit;
+	} else {
+		u8 end_retry = 0;  /* the retry should be add to last rate. */
+		if (limit > HIGH_RATE_MAX_RETRY) {
+			end_retry = limit - HIGH_RATE_MAX_RETRY;
+			limit     = HIGH_RATE_MAX_RETRY;
+		}
+		/* i<100 to avoid dead loop */
+		for (i = 0; (limit != total) && (i < 100); ++i) {
+			j = i % count;
+			if (limit < total) {
+				total += (rates[j].count > 1 ? -1 : 0);
+				rates[j].count += (rates[j].count > 1 ? -1 : 0);
+			} else {
+				j = count - 1 - j;
+				if (rates[j].count > 0) {
+					total++;
+					rates[j].count++;
+				}
+			}
+		}
+		if (end_retry) {
+			rates[count-1].count += end_retry;
+			limit += end_retry;
+		}
+	}
+#ifdef SUPPORT_HT40
+
+	/* Eliminate duplicates. */
+	total = rates[0].count;
+	for (i = 0, j = 1; j < count; ++j) {
+		if ((rates[j].idx == rates[i].idx) &&
+			(rates[j].flags == rates[i].flags)) {
+			rates[i].count += rates[j].count;
+		} else {
+			++i;
+			if (i != j)
+				rates[i] = rates[j];
+		}
+		total += rates[j].count;
+	}
+	for (j = i + 1; j < count; j++) {
+		rates[j].idx = -1;
+		rates[j].count = 0;
+	}
+	count = i + 1;
+
+#else
+
+	/* Eliminate duplicates. */
+	total = rates[0].count;
+	for (i = 0, j = 1; j < count; ++j) {
+		if (rates[j].idx < 0 || rates[j].idx > rates[i].idx)
+			break;
+		if (rates[j].idx == rates[i].idx) {
+			rates[i].count += rates[j].count;
+		} else {
+			++i;
+			if (i != j)
+				rates[i] = rates[j];
+		}
+		total += rates[j].count;
+	}
+	count = i + 1;
+#endif
+
+	/*
+	 * Re-fill policy trying to keep every requested rate and with
+	 * respect to the global max tx retransmission count.
+	 */
+	if (limit < count)
+		limit = count;
+	if (total > limit) {
+		for (i = 0; i < count; ++i) {
+			int left = count - i - 1;
+			if (rates[i].count > limit - left)
+				rates[i].count = limit - left;
+			limit -= rates[i].count;
+		}
+	}
+
+	/*
+	 * HACK!!! Device has problems (at least) switching from
+	 * 54Mbps CTS to 1Mbps. This switch takes enormous amount
+	 * of time (100-200 ms), leading to valuable throughput drop.
+	 * As a workaround, additional g-rates are injected to the
+	 * policy.
+	 */
+	if (count == 2 && !(rates[0].flags & IEEE80211_TX_RC_MCS) &&
+			rates[0].idx > 4 && rates[0].count > 2 &&
+			rates[1].idx < 2) {
+		/* ">> 1" is an equivalent of "/ 2", but faster */
+		int mid_rate = (rates[0].idx + 4) >> 1;
+
+		/* Decrease number of retries for the initial rate */
+		rates[0].count -= 2;
+
+		if (mid_rate != 4) {
+			/* Keep fallback rate at 1Mbps. */
+			rates[3] = rates[1];
+
+			/* Inject 1 transmission on lowest g-rate */
+			rates[2].idx = 4;
+			rates[2].count = 1;
+			rates[2].flags = rates[1].flags;
+
+			/* Inject 1 transmission on mid-rate */
+			rates[1].idx = mid_rate;
+			rates[1].count = 1;
+
+			/* Fallback to 1 Mbps is a really bad thing,
+			 * so let's try to increase probability of
+			 * successful transmission on the lowest g rate
+			 * even more */
+			if (rates[0].count >= 3) {
+				--rates[0].count;
+				++rates[2].count;
+			}
+
+			/* Adjust amount of rates defined */
+			count += 2;
+		} else {
+			/* Keep fallback rate at 1Mbps. */
+			rates[2] = rates[1];
+
+			/* Inject 2 transmissions on lowest g-rate */
+			rates[1].idx = 4;
+			rates[1].count = 2;
+
+			/* Adjust amount of rates defined */
+			count += 1;
+		}
+	}
+#ifdef SUPPORT_HT40
+
+	/* set rate_entrys */
+	for (i = 0; i < count; ++i) {
+		register u8 entry_idx = 0;
+		register u8 modem_type = RATE_MODEM_LEGACY;
+		register u8 bandwidth = RATE_BANDWIDTH_20M;
+		register u8 flag = rates[i].flags;
+		if (rates[i].idx < 0) {
+			policy->rate_entrys[i] = XRADIO_INVALID_RATE_ENTRY;
+			continue;
+		}
+
+		/* set rate index and retry counter. */
+		tmp_rate  = (struct ieee80211_rate *)xradio_get_tx_rate(hw_priv, &rates[i]);
+
+		entry_idx = xradio_rate_to_entry_idx(flag, tmp_rate->hw_value);
+
+		policy->rate_entrys[i] = ((entry_idx & 0xf) << RATEINDEX_SHIFT)
+					| (rates[i].count & 0xf);
+
+		/* set modem_type and bandwidth. */
+		if (flag & IEEE80211_TX_RC_MCS)
+			modem_type = RATE_MODEM_HTOFDM;
+
+		if (flag & IEEE80211_TX_RC_40_MHZ_WIDTH)
+			bandwidth = RATE_BANDWIDTH_40M;
+
+		policy->rate_entrys[i] |= ((modem_type << MODEMTYPE_SHIFT) |
+					(bandwidth  << BANDWIDTH_SHIFT));
+
+		/* set short preamble in DSSS */
+		policy->rate_entrys[i] |= MAKE_PREAMBLE_S(flag
+					& IEEE80211_TX_RC_USE_SHORT_PREAMBLE);
+
+		/* set short GI */
+		policy->rate_entrys[i] |= MAKE_SGI(flag
+					& IEEE80211_TX_RC_SHORT_GI);
+
+		/*
+		 * set green field mode.
+		 * there is a conflict between sgi and green field in one stream,
+		 * and we prefer to use sgi instead of green field
+		 */
+		if (priv->association_mode.PhyModeCfg.GF_Enable
+			&& (modem_type == RATE_MODEM_HTOFDM)) {
+			if (!(GET_RATE_ENTRY_FLAGS(policy->rate_entrys[i]) & FW_RATE_F_SGI))
+				policy->rate_entrys[i] |= MAKE_GF(1);
+		}
+
+		/* set STBC, but unsurported in xradio yet. */
+		policy->rate_entrys[i] |= MAKE_STBC(0);
+
+		policy->defined++;
+		policy->retry_count += (rates[i].count & 0xf);
+
+		txrx_printk(XRADIO_DBG_NIY, "[TX policy] rate_entrys=0x%04x",
+						policy->rate_entrys[i]);
+	}
+
+#else
+
+	tmp_rate = (struct ieee80211_rate *)xradio_get_tx_rate(hw_priv, &rates[0]);
+	if (tmp_rate)
+		policy->defined = tmp_rate->hw_value + 1;
+
+#ifdef ENHANCE_ANTI_INTERFERE
+	/*
+	 * We need to check if 11b rate be supported.
+	 * We only add 11bg rate when no rate below 5.5Mbps is set,
+	 * and last rate has enough reties. Add we need check fw version too.
+	 */
+	if (WSM_CAPS_11N_TO_11BG(hw_priv->wsm_caps) && !priv->vif->p2p &&
+		((priv->oper_rates | priv->base_rates) & 0xf) == 0xf &&
+		(rates[0].flags & IEEE80211_TX_RC_MCS) &&
+		rates[count-1].idx == 0 && rates[count-1].count >= 3) {
+		u8 mcs0_cnt = rates[count-1].count;
+		u8 cnt1 = (mcs0_cnt>>2);
+		u8 cnt2 = ((mcs0_cnt - (cnt1<<1))>>1);
+		if (count <= 1) {
+			mcs0_cnt -= (cnt1 + cnt1 + cnt2);
+			rates[count-1].count = 0;
+			policy->tbl[0] |= ((cnt1&0xf)<<(3<<2));
+			policy->tbl[0] |= ((cnt2&0xf)<<(2<<2));
+			policy->tbl[0] |= ((cnt1&0xf)<<(1<<2));
+			policy->tbl[0] |= ((mcs0_cnt&0xf)<<(0<<2));
+			policy->retry_count = cnt1 + cnt2 + cnt1 + mcs0_cnt;
+			txrx_printk(XRADIO_DBG_MSG,
+				"[TX policy]to11b=%d(f=%d), %d, 11=%d, 5.5=%d, 2=%d, 1=%d\n",
+				rates[count-1].idx, rates[0].flags,
+				rates[count-1].count, cnt1, cnt2, cnt1, mcs0_cnt);
+		} else {
+			mcs0_cnt -= (cnt1 + cnt1 + cnt2);
+			rates[count-1].count = cnt1;
+			policy->tbl[0] |= ((cnt1&0xf)<<(3<<2));
+			policy->tbl[0] |= ((cnt2&0xf)<<(2<<2));
+			policy->tbl[0] |= ((mcs0_cnt&0xf)<<(0<<2));
+			policy->retry_count = cnt1 + cnt2 + mcs0_cnt;
+			txrx_printk(XRADIO_DBG_MSG,
+				"[TX policy]to11b=%d(f=%d), %d, 11=%d, 5.5=%d, 2=%d, 1=%d\n",
+				rates[count-1].idx, rates[0].flags,
+				rates[count-1].count, cnt1, cnt2, 0, mcs0_cnt);
+		}
+	} else {
+		txrx_printk(XRADIO_DBG_MSG,
+			"[TX policy]WSM_CAPS to11b=%d, p2p=%d, MSC=%d, rates=0x%08x, count(%d)=%d\n",
+			!!WSM_CAPS_11N_TO_11BG(hw_priv->wsm_caps), priv->vif->p2p,
+			!!(rates[0].flags & IEEE80211_TX_RC_MCS),
+			(priv->oper_rates | priv->base_rates),
+			count-1, rates[count-1].count);
+	}
+#endif
+
+	for (i = 0; i < count; ++i) {
+		register unsigned rateid, off, shift, retries;
+
+		tmp_rate = (struct ieee80211_rate *)xradio_get_tx_rate(hw_priv, &rates[i]);
+		if (tmp_rate) {
+			rateid = tmp_rate->hw_value;
+		} else {
+			break;
+		}
+		off = rateid >> 3;		/* eq. rateid / 8 */
+		shift = (rateid & 0x07) << 2;	/* eq. (rateid % 8) * 4 */
+
+		retries = rates[i].count;
+		if (unlikely(retries > 0x0F))
+			rates[i].count = retries = 0x0F;
+		policy->tbl[off] |= __cpu_to_le32(retries << shift);
+		policy->retry_count += retries;
+		txrx_printk(XRADIO_DBG_MSG, "[TX policy] %d.%dMps=%d",
+			    tmp_rate->bitrate/10, tmp_rate->bitrate%10, retries);
+	}
+
+#endif
+
+	txrx_printk(XRADIO_DBG_MSG, "[TX policy] Dst Policy (%zu): " \
+		"%d:%d, %d:%d, %d:%d, %d:%d, %d:%d\n",
+		count,
+		rates[0].idx, rates[0].count,
+		rates[1].idx, rates[1].count,
+		rates[2].idx, rates[2].count,
+		rates[3].idx, rates[3].count,
+		rates[4].idx, rates[4].count);
+}
+
+#ifdef SUPPORT_HT40
+
+static inline bool tx_policy_is_equal(const struct tx_policy *wanted,
+					const struct tx_policy *cached)
+{
+
+	size_t count = wanted->defined << 1;
+
+	if (wanted->defined != cached->defined)
+		return false;
+
+	if (count) {
+		if (memcmp(wanted->raw, cached->raw, count))
+			return false;
+	}
+
+	return true;
+}
+
+#else
+
+static inline bool tx_policy_is_equal(const struct tx_policy *wanted,
+					const struct tx_policy *cached)
+{
+	size_t count = wanted->defined >> 1;
+
+	if (wanted->defined > cached->defined)
+		return false;
+	if (count) {
+		if (memcmp(wanted->raw, cached->raw, count))
+			return false;
+	}
+	if (wanted->defined & 1) {
+		if ((wanted->raw[count] & 0x0F) != (cached->raw[count] & 0x0F))
+			return false;
+	}
+	return true;
+}
+
+#endif
+
+static int tx_policy_find(struct tx_policy_cache *cache,
+				const struct tx_policy *wanted)
+{
+	/* O(n) complexity. Not so good, but there's only 8 entries in
+	 * the cache.
+	 * Also lru helps to reduce search time. */
+	struct tx_policy_cache_entry *it;
+	/* Search for policy in "used" list */
+	list_for_each_entry(it, &cache->used, link) {
+		if (tx_policy_is_equal(wanted, &it->policy))
+			return it - cache->cache;
+	}
+	/* Then - in "free list" */
+	list_for_each_entry(it, &cache->free, link) {
+		if (tx_policy_is_equal(wanted, &it->policy))
+			return it - cache->cache;
+	}
+	return -1;
+}
+
+static inline void tx_policy_use(struct tx_policy_cache *cache,
+				 struct tx_policy_cache_entry *entry)
+{
+	++entry->policy.usage_count;
+	list_move(&entry->link, &cache->used);
+}
+
+static inline int tx_policy_release(struct tx_policy_cache *cache,
+				    struct tx_policy_cache_entry *entry)
+{
+	int ret = --entry->policy.usage_count;
+	if (!ret)
+		list_move(&entry->link, &cache->free);
+	return ret;
+}
+
+/* ******************************************************************** */
+/* External TX policy cache API						*/
+
+void tx_policy_init(struct xradio_common *hw_priv)
+{
+	struct tx_policy_cache *cache = &hw_priv->tx_policy_cache;
+	int i;
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	memset(cache, 0, sizeof(*cache));
+
+	spin_lock_init(&cache->lock);
+	INIT_LIST_HEAD(&cache->used);
+	INIT_LIST_HEAD(&cache->free);
+
+	for (i = 0; i < TX_POLICY_CACHE_SIZE; ++i)
+		list_add(&cache->cache[i].link, &cache->free);
+}
+
+static int tx_policy_get(struct xradio_vif *priv,
+		  struct ieee80211_tx_rate *rates,
+		  u8 use_bg_rate, bool *renew)
+{
+	int idx;
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	struct tx_policy_cache *cache = &hw_priv->tx_policy_cache;
+	struct tx_policy wanted;
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (use_bg_rate) {
+
+#ifdef SUPPORT_HT40
+
+		memset(&wanted, 0, sizeof(wanted));
+		wanted.retry_count = (hw_priv->short_frame_max_tx_count&0xf);
+		wanted.defined = 1;
+
+		/* set rate index and retry counter. */
+		wanted.rate_entrys[0] = (((use_bg_rate & 0xf)<<4)
+					| (wanted.retry_count & 0xf));
+
+		/* set modem_type and bandwidth. */
+		wanted.rate_entrys[0] |=
+			((RATE_MODEM_LEGACY  << MODEMTYPE_SHIFT)
+			| (RATE_BANDWIDTH_20M << BANDWIDTH_SHIFT));
+
+		/* set short preamble in DSSS */
+		wanted.rate_entrys[0] |= MAKE_PREAMBLE_S(rates[0].flags
+					& IEEE80211_TX_RC_USE_SHORT_PREAMBLE);
+
+		txrx_printk(XRADIO_DBG_NIY, "[TX policy] robust rate=0x%04x\n",
+					wanted.rate_entrys[0]);
+
+#else
+		u8 rate  = (u8)(use_bg_rate & 0x3f);
+		u8 shitf = ((rate&0x7)<<2);
+		u8 off   = (rate>>3);
+		memset(&wanted, 0, sizeof(wanted));
+		wanted.defined = rate + 1;
+		wanted.retry_count = (hw_priv->short_frame_max_tx_count&0xf);
+		wanted.tbl[off] = wanted.retry_count<<shitf;
+		txrx_printk(XRADIO_DBG_NIY, "[TX policy] robust rate=%d\n", rate);
+
+#endif
+
+	} else
+		tx_policy_build(priv, &wanted, rates, IEEE80211_TX_MAX_RATES);
+
+	/* use rate policy instead of minstel policy in debug mode*/
+#ifdef CONFIG_XRADIO_DEBUGFS
+	if (rates_dbg_en & 0x2) {
+		memset(&wanted, 0, sizeof(wanted));
+
+#ifdef SUPPORT_HT40
+
+		wanted.defined = Ratecnt_dbg;
+		wanted.retry_count = (hw_priv->short_frame_max_tx_count&0xf);
+		memcpy(&wanted.rate_entrys[0], &rates_debug[0],
+						sizeof(wanted.rate_entrys));
+
+#else
+
+		wanted.defined = maxRate_dbg + 1;
+		wanted.retry_count = (hw_priv->short_frame_max_tx_count&0xf);
+		memcpy(&wanted.tbl[0], &rates_debug[0], sizeof(wanted.tbl));
+
+#endif
+	}
+#endif
+
+	spin_lock_bh(&cache->lock);
+	idx = tx_policy_find(cache, &wanted);
+	if (idx >= 0) {
+		txrx_printk(XRADIO_DBG_MSG, "[TX policy] Used TX policy: %d\n",
+					idx);
+		*renew = false;
+	} else if (WARN_ON_ONCE(list_empty(&cache->free))) {
+		spin_unlock_bh(&cache->lock);
+		txrx_printk(XRADIO_DBG_ERROR, "[TX policy] no policy cache\n");
+		return XRADIO_INVALID_RATE_ID;
+	} else {
+		struct tx_policy_cache_entry *entry;
+
+		/* If policy is not found create a new one
+		 * using the oldest entry in "free" list */
+		*renew = true;
+		entry = list_entry(cache->free.prev,
+			struct tx_policy_cache_entry, link);
+		entry->policy = wanted;
+		idx = entry - cache->cache;
+		txrx_printk(XRADIO_DBG_MSG, "[TX policy] New TX policy: %d\n",
+					idx);
+		tx_policy_dump(&entry->policy);
+	}
+	tx_policy_use(cache, &cache->cache[idx]);
+	if (unlikely(list_empty(&cache->free)) &&
+		!cache->queue_locked) {
+		/* Lock TX queues. */
+		DBG_INT_ADD(policy_lock_cnt);
+		txrx_printk(XRADIO_DBG_WARN, "[TX policy] policy cache used up\n");
+		xradio_tx_queues_lock(hw_priv);
+		cache->queue_locked = true;
+	}
+	spin_unlock_bh(&cache->lock);
+
+	/*force to upload retry limit when using debug rate policy */
+#ifdef CONFIG_XRADIO_DEBUGFS
+	if (retry_dbg & 0x2) {
+		retry_dbg &= ~0x2;
+		/* retry dgb need to be applied to policy. */
+		*renew = true;
+		cache->cache[idx].policy.uploaded = 0;
+	}
+#endif
+
+	return idx;
+}
+
+static void tx_policy_put(struct xradio_common *hw_priv, int idx)
+{
+	int usage;
+	/*int locked;*/
+	struct tx_policy_cache *cache = &hw_priv->tx_policy_cache;
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	spin_lock_bh(&cache->lock);
+	/*locked = list_empty(&cache->free);*/
+	usage = tx_policy_release(cache, &cache->cache[idx]);
+	if (unlikely(cache->queue_locked) && !list_empty(&cache->free)) {
+		/* Unlock TX queues. */
+		xradio_tx_queues_unlock(hw_priv);
+		cache->queue_locked = false;
+	}
+	spin_unlock_bh(&cache->lock);
+}
+
+/*
+bool tx_policy_cache_full(struct xradio_common *hw_priv)
+{
+	bool ret;
+	struct tx_policy_cache *cache = &hw_priv->tx_policy_cache;
+	spin_lock_bh(&cache->lock);
+	ret = list_empty(&cache->free);
+	spin_unlock_bh(&cache->lock);
+	return ret;
+}
+*/
+extern u32 policy_upload;
+extern u32 policy_num;
+static int tx_policy_upload(struct xradio_common *hw_priv)
+{
+	struct tx_policy_cache *cache = &hw_priv->tx_policy_cache;
+	int i;
+	struct wsm_set_tx_rate_retry_policy arg = {
+		.hdr = {
+			.numTxRatePolicies = 0,
+		}
+	};
+	int if_id = 0;
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	spin_lock_bh(&cache->lock);
+	/* Upload only modified entries. */
+	for (i = 0; i < TX_POLICY_CACHE_SIZE; ++i) {
+		struct tx_policy *src = &cache->cache[i].policy;
+		if (src->retry_count && !src->uploaded) {
+			struct wsm_set_tx_rate_retry_policy_policy *dst =
+				&arg.tbl[arg.hdr.numTxRatePolicies];
+			dst->policyIndex = i;
+			dst->shortRetryCount = hw_priv->short_frame_max_tx_count-1;
+			/* only RTS need use longRetryCount, should be short_frame. */
+			dst->longRetryCount = hw_priv->short_frame_max_tx_count-1;
+
+			/* BIT(2) - Terminate retries when Tx rate retry policy
+			 *          finishes.
+			 * BIT(3) - Count initial frame transmission as part of
+			 *          rate retry counting but not as a retry
+			 *          attempt */
+			dst->policyFlags = BIT(2) | BIT(3);
+
+#ifdef SUPPORT_HT40
+
+			memcpy(dst->rate_entrys, src->rate_entrys,
+					sizeof(dst->rate_entrys));
+
+#else
+
+			memcpy(dst->rateCountIndices, src->tbl,
+					sizeof(dst->rateCountIndices));
+
+#endif
+
+			src->uploaded = 1;
+			++arg.hdr.numTxRatePolicies;
+		}
+	}
+	spin_unlock_bh(&cache->lock);
+	atomic_set(&hw_priv->upload_count, 0);
+
+	xradio_debug_tx_cache_miss(hw_priv);
+	txrx_printk(XRADIO_DBG_MSG, "[TX policy] Upload %d policies\n",
+				arg.hdr.numTxRatePolicies);
+#ifdef CONFIG_XRADIO_DEBUGFS
+
+#ifndef SUPPORT_HT40
+
+	if (arg.tbl[0].policyIndex == 7)
+		txrx_printk(XRADIO_DBG_MSG, "rate:0x%08x, 0x%08x, 0x%08x\n",
+								arg.tbl[0].rateCountIndices[2],
+								arg.tbl[0].rateCountIndices[1],
+								arg.tbl[0].rateCountIndices[0]);
+
+#endif
+	policy_upload++;
+	policy_num += arg.hdr.numTxRatePolicies;
+#endif
+	/*TODO: COMBO*/
+	return wsm_set_tx_rate_retry_policy(hw_priv, &arg, if_id);
+}
+
+void tx_policy_upload_work(struct work_struct *work)
+{
+	struct xradio_common *hw_priv =
+		container_of(work, struct xradio_common, tx_policy_upload_work);
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	SYS_WARN(tx_policy_upload(hw_priv));
+	wsm_unlock_tx(hw_priv);
+}
+
+/* ******************************************************************** */
+/* xradio TX implementation						*/
+
+struct xradio_txinfo {
+	struct sk_buff *skb;
+	unsigned queue;
+	struct ieee80211_tx_info *tx_info;
+	const struct ieee80211_rate *rate;
+	struct ieee80211_hdr *hdr;
+	size_t hdrlen;
+	const u8 *da;
+	struct xradio_sta_priv *sta_priv;
+	struct xradio_txpriv txpriv;
+};
+
+u32 xradio_rate_mask_to_wsm(struct xradio_common *hw_priv, u32 rates)
+{
+	u32 ret = 0;
+	int i;
+	u32 n_bitrates =
+		  hw_priv->hw->wiphy->bands[hw_priv->channel->band]->n_bitrates;
+	struct ieee80211_rate *bitrates =
+		  hw_priv->hw->wiphy->bands[hw_priv->channel->band]->bitrates;
+
+	for (i = 0; i < n_bitrates; ++i) {
+		if (rates & BIT(i))
+			ret |= BIT(bitrates[i].hw_value);
+	}
+	return ret;
+}
+
+static const struct ieee80211_rate *
+xradio_get_tx_rate(const struct xradio_common *hw_priv,
+		   const struct ieee80211_tx_rate *rate)
+{
+	if (rate->idx < 0)
+		return NULL;
+	if (rate->flags & IEEE80211_TX_RC_MCS)
+		return &hw_priv->mcs_rates[rate->idx];
+	return &hw_priv->hw->wiphy->bands[hw_priv->channel->band]->
+		bitrates[rate->idx];
+}
+
+#ifdef SUPPORT_HT40
+
+u16 xradio_get_rate_entry(const struct xradio_common *hw_priv,
+			u8 Bandwidth, u16 FormatFlag, u8 hw_value)
+{
+	u16 rate_entry = XRADIO_INVALID_RATE_ENTRY;
+	u8  modem_type = 0;
+	s8  rate_idx = hw_value;
+	if (rate_idx <= MAX_RATES_IDX) {
+		if (rate_idx >= MCS_RATES_OFF) {
+			rate_idx  -= MCS_RATES_OFF;
+			modem_type = RATE_MODEM_HTOFDM;
+		}
+		rate_entry = rate_idx << RATEINDEX_SHIFT;
+		rate_entry |= (modem_type & MODEMTYPE_MASK) << MODEMTYPE_SHIFT;
+		rate_entry |= (Bandwidth  & BANDWIDTH_MASK) << BANDWIDTH_SHIFT;
+		rate_entry |= (FormatFlag & RATE_F_MASK);
+	}
+	return rate_entry;
+}
+
+#else
+
+static inline s8 xradio_get_rate_idx(const struct xradio_common *hw_priv,
+									 u8 flag, u16 hw_value)
+{
+	s16 ret = (s16)hw_value;
+	if (flag & IEEE80211_TX_RC_MCS) {  /* 11n */
+		if (hw_value <= hw_priv->mcs_rates[7].hw_value &&
+			 hw_value >= hw_priv->mcs_rates[0].hw_value)
+			ret -= hw_priv->mcs_rates[0].hw_value;
+		else
+			ret = -1;
+	} else {  /* 11b/g */
+		if (hw_value > 5 && hw_value < hw_priv->mcs_rates[0].hw_value) {
+			ret -= hw_priv->hw->wiphy-> \
+			       bands[hw_priv->channel->band]->bitrates[0].hw_value;
+			if (hw_priv->hw->wiphy-> \
+			   bands[hw_priv->channel->band]->bitrates[0].hw_value < 5) /* 11a*/
+				ret -= 2;
+		} else if (hw_value < 4) {
+			ret -= hw_priv->hw->wiphy-> \
+			       bands[hw_priv->channel->band]->bitrates[0].hw_value;
+		} else {
+			ret = -1;
+		}
+	}
+	return (s8)ret;
+}
+
+#endif
+
+static int
+xradio_tx_h_calc_link_ids(struct xradio_vif *priv,
+			  struct xradio_txinfo *t)
+{
+#ifndef P2P_MULTIVIF
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+#endif
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+#ifndef P2P_MULTIVIF
+	if ((t->tx_info->flags & IEEE80211_TX_CTL_TX_OFFCHAN) ||
+			(hw_priv->roc_if_id == priv->if_id))
+		t->txpriv.offchannel_if_id = 2;
+	else
+		t->txpriv.offchannel_if_id = 0;
+#endif
+
+	if (likely(t->tx_info->control.sta && t->sta_priv->link_id))
+		t->txpriv.raw_link_id =
+				t->txpriv.link_id =
+				t->sta_priv->link_id;
+	else if (priv->mode != NL80211_IFTYPE_AP)
+		t->txpriv.raw_link_id =
+				t->txpriv.link_id = 0;
+	else if (is_multicast_ether_addr(t->da)) {
+		if (priv->enable_beacon) {
+			t->txpriv.raw_link_id = 0;
+			t->txpriv.link_id = priv->link_id_after_dtim;
+		} else {
+			t->txpriv.raw_link_id = 0;
+			t->txpriv.link_id = 0;
+		}
+	} else {
+		t->txpriv.link_id =
+			xradio_find_link_id(priv, t->da);
+		/* Do not assign valid link id for deauth/disassoc frame being
+		transmitted to an unassociated STA */
+		if (!(t->txpriv.link_id) &&
+			(ieee80211_is_deauth(t->hdr->frame_control) ||
+			ieee80211_is_disassoc(t->hdr->frame_control))) {
+					t->txpriv.link_id = 0;
+		} else {
+			if (!t->txpriv.link_id)
+				t->txpriv.link_id = xradio_alloc_link_id(priv, t->da);
+			if (!t->txpriv.link_id) {
+				txrx_printk(XRADIO_DBG_ERROR,
+					    "%s: No more link IDs available.\n", __func__);
+				return -ENOENT;
+			}
+		}
+		t->txpriv.raw_link_id = t->txpriv.link_id;
+	}
+	if (t->txpriv.raw_link_id)
+		priv->link_id_db[t->txpriv.raw_link_id - 1].timestamp =
+				jiffies;
+
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+	if (t->tx_info->control.sta &&
+			(t->tx_info->control.sta->uapsd_queues & BIT(t->queue)))
+		t->txpriv.link_id = priv->link_id_uapsd;
+#endif /* CONFIG_XRADIO_USE_EXTENSIONS */
+	return 0;
+}
+
+static void
+xradio_tx_h_pm(struct xradio_vif *priv,
+	       struct xradio_txinfo *t)
+{
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (unlikely(ieee80211_is_auth(t->hdr->frame_control))) {
+		u32 mask = ~BIT(t->txpriv.raw_link_id);
+		spin_lock_bh(&priv->ps_state_lock);
+		priv->sta_asleep_mask &= mask;
+		priv->pspoll_mask &= mask;
+		spin_unlock_bh(&priv->ps_state_lock);
+	}
+}
+
+static void
+xradio_tx_h_calc_tid(struct xradio_vif *priv,
+		     struct xradio_txinfo *t)
+{
+	if (ieee80211_is_data_qos(t->hdr->frame_control)) {
+		u8 *qos = ieee80211_get_qos_ctl(t->hdr);
+		t->txpriv.tid = qos[0] & IEEE80211_QOS_CTL_TID_MASK;
+	} else if (ieee80211_is_data(t->hdr->frame_control)) {
+		t->txpriv.tid = 0;
+	}
+}
+
+/* IV/ICV injection. */
+/* TODO: Quite unoptimal. It's better co modify mac80211
+ * to reserve space for IV */
+static int
+xradio_tx_h_crypt(struct xradio_vif *priv,
+		  struct xradio_txinfo *t)
+{
+	size_t iv_len;
+	size_t icv_len;
+	u8 *icv;
+	u8 *newhdr;
+	int is_multi_mfp = 0;
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (ieee80211_is_mgmt(t->hdr->frame_control) &&
+		 is_multicast_ether_addr(t->hdr->addr1) &&
+		 ieee80211_is_robust_mgmt_frame(t->skb))
+		 is_multi_mfp = 1;
+
+	if (!t->tx_info->control.hw_key ||
+	    (!(t->hdr->frame_control &
+	     __cpu_to_le32(IEEE80211_FCTL_PROTECTED)) && (!is_multi_mfp)))
+		return 0;
+
+	iv_len = t->tx_info->control.hw_key->iv_len;
+	icv_len = t->tx_info->control.hw_key->icv_len;
+#ifdef AP_ARP_COMPAT_FIX
+	t->txpriv.iv_len = iv_len;
+#endif
+	if (t->tx_info->control.hw_key->cipher == WLAN_CIPHER_SUITE_TKIP)
+		icv_len += 8; /* MIC */
+
+	if ((skb_headroom(t->skb) + skb_tailroom(t->skb) <
+			 iv_len + icv_len + WSM_TX_EXTRA_HEADROOM) ||
+			(skb_headroom(t->skb) <
+			 iv_len + WSM_TX_EXTRA_HEADROOM)) {
+		txrx_printk(XRADIO_DBG_ERROR,
+			"Bug: no space allocated for crypto headers.\n"
+			"headroom: %d, tailroom: %d, "
+			"req_headroom: %zu, req_tailroom: %zu\n"
+			"Please fix it in xradio_get_skb().\n",
+			skb_headroom(t->skb), skb_tailroom(t->skb),
+			iv_len + WSM_TX_EXTRA_HEADROOM, icv_len);
+		return -ENOMEM;
+	} else if (skb_tailroom(t->skb) < icv_len) {
+		size_t offset = icv_len - skb_tailroom(t->skb);
+		u8 *p;
+		txrx_printk(XRADIO_DBG_ERROR,
+			"Slowpath: tailroom is not big enough. "
+			"Req: %zu, got: %d.\n",
+			icv_len, skb_tailroom(t->skb));
+
+		p = skb_push(t->skb, offset);
+		memmove(p, &p[offset], t->skb->len - offset);
+		skb_trim(t->skb, t->skb->len - offset);
+	}
+
+	newhdr = skb_push(t->skb, iv_len);
+	memmove(newhdr, newhdr + iv_len, t->hdrlen);
+	t->hdr = (struct ieee80211_hdr *) newhdr;
+	t->hdrlen += iv_len;
+	icv = skb_put(t->skb, icv_len);
+
+	if (t->tx_info->control.hw_key->cipher == WLAN_CIPHER_SUITE_AES_CMAC) {
+		struct ieee80211_mmie * mmie = (struct ieee80211_mmie *) icv;
+		memset(mmie, 0, sizeof(struct ieee80211_mmie));
+		mmie->element_id = WLAN_EID_MMIE;
+		mmie->length = sizeof(*mmie) - 2;
+	}
+	return 0;
+}
+#ifdef SUPPORT_HT40
+
+static int xradio_tx_h_align(struct xradio_vif *priv, struct xradio_txinfo *t)
+
+#else
+
+static int
+xradio_tx_h_align(struct xradio_vif *priv, struct xradio_txinfo *t,
+		  u8 *flags)
+
+#endif
+{
+	size_t offset = (size_t)t->skb->data & 3;
+	u8 *newhdr;
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (!offset)
+		return 0;
+
+	if (skb_headroom(t->skb) < offset) {
+		txrx_printk(XRADIO_DBG_ERROR,
+			"Bug: no space allocated "
+			"for DMA alignment.\n"
+			"headroom: %d\n",
+			skb_headroom(t->skb));
+		return -ENOMEM;
+	}
+    /* offset = 1or3 process */
+	if (offset & 1) {
+		newhdr = skb_push(t->skb, offset);
+		memmove(newhdr, newhdr + offset, t->skb->len-offset);
+		skb_trim(t->skb, t->skb->len-offset);
+		t->hdr = (struct ieee80211_hdr *) newhdr;
+		xradio_debug_tx_align(priv);
+		return 0;
+	}
+	/* offset=2 process */
+	skb_push(t->skb, offset);
+	t->hdrlen += offset;
+	t->txpriv.offset += offset;
+#ifndef SUPPORT_HT40
+	*flags |= WSM_TX_2BYTES_SHIFT;
+#endif
+	xradio_debug_tx_align(priv);
+	return 0;
+}
+
+static int
+xradio_tx_h_action(struct xradio_vif *priv, struct xradio_txinfo *t)
+{
+	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)t->hdr;
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (ieee80211_is_action(t->hdr->frame_control) &&
+			mgmt->u.action.category == WLAN_CATEGORY_BACK)
+		return 1;
+	else
+		return 0;
+}
+
+/* Add WSM header */
+static struct wsm_tx *
+xradio_tx_h_wsm(struct xradio_vif *priv, struct xradio_txinfo *t)
+{
+	struct wsm_tx *wsm;
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (skb_headroom(t->skb) < sizeof(struct wsm_tx)) {
+		txrx_printk(XRADIO_DBG_ERROR,
+			"Bug: no space allocated "
+			"for WSM header.\n"
+			"headroom: %d\n",
+			skb_headroom(t->skb));
+		return NULL;
+	}
+
+	wsm = (struct wsm_tx *)skb_push(t->skb, sizeof(struct wsm_tx));
+	t->txpriv.offset += sizeof(struct wsm_tx);
+	memset(wsm, 0, sizeof(*wsm));
+
+#ifdef SUPPORT_HT40
+
+	wsm->DataOffset = t->txpriv.offset;
+
+#endif
+
+	wsm->hdr.len = __cpu_to_le16(t->skb->len);
+	wsm->hdr.id  = __cpu_to_le16(0x0004);
+	wsm->queueId = (t->txpriv.raw_link_id << 2) | wsm_queue_id_to_wsm(t->queue);
+	if (wsm->hdr.len > hw_priv->wsm_caps.sizeInpChBuf) {
+		txrx_printk(XRADIO_DBG_ERROR, "%s, msg length too big=%d\n",
+			    __func__, wsm->hdr.len);
+		skb_pull(t->skb, sizeof(struct wsm_tx));  //skb revert.
+		wsm = NULL;
+	}
+
+	return wsm;
+}
+
+/* BT Coex specific handling */
+static void xradio_tx_h_bt(struct xradio_vif *priv, struct xradio_txinfo *t,
+						   struct wsm_tx *wsm)
+{
+	u8 priority = 0;
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (!hw_priv->is_BT_Present)
+		return;
+
+	if (unlikely(ieee80211_is_nullfunc(t->hdr->frame_control)))
+		priority = WSM_EPTA_PRIORITY_MGT;
+	else if (ieee80211_is_data(t->hdr->frame_control)) {
+		/* Skip LLC SNAP header (+6) */
+		u8 *payload = &t->skb->data[t->hdrlen];
+		u16 *ethertype = (u16 *) &payload[6];
+		if (unlikely(*ethertype == __be16_to_cpu(ETH_P_PAE)))
+			priority = WSM_EPTA_PRIORITY_EAPOL;
+	} else if (unlikely(ieee80211_is_assoc_req(t->hdr->frame_control) ||
+		ieee80211_is_reassoc_req(t->hdr->frame_control))) {
+		struct ieee80211_mgmt *mgt_frame =
+				(struct ieee80211_mgmt *)t->hdr;
+
+		if (mgt_frame->u.assoc_req.listen_interval <
+						priv->listen_interval) {
+			txrx_printk(XRADIO_DBG_MSG,
+				"Modified Listen Interval to %d from %d\n",
+				priv->listen_interval,
+				mgt_frame->u.assoc_req.listen_interval);
+			/* Replace listen interval derieved from
+			 * the one read from SDD */
+			mgt_frame->u.assoc_req.listen_interval =
+				priv->listen_interval;
+		}
+	}
+
+	if (likely(!priority)) {
+		if (ieee80211_is_action(t->hdr->frame_control))
+			priority = WSM_EPTA_PRIORITY_ACTION;
+		else if (ieee80211_is_mgmt(t->hdr->frame_control))
+			priority = WSM_EPTA_PRIORITY_MGT;
+		else if (wsm->queueId == WSM_QUEUE_VOICE)
+			priority = WSM_EPTA_PRIORITY_VOICE;
+		else if (wsm->queueId == WSM_QUEUE_VIDEO)
+			priority = WSM_EPTA_PRIORITY_VIDEO;
+		else
+			priority = WSM_EPTA_PRIORITY_DATA;
+	}
+
+	txrx_printk(XRADIO_DBG_MSG, "[TX] EPTA priority %d.\n",
+		priority);
+
+#ifdef SUPPORT_HT40
+
+	wsm->EptaPriority = priority;
+
+#else
+
+	wsm->flags |= priority << 1;
+
+#endif
+
+}
+
+static int
+xradio_tx_h_rate_policy(struct xradio_vif *priv,
+						struct xradio_txinfo *t,
+						struct wsm_tx *wsm)
+{
+	bool tx_policy_renew = false;
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	/*use debug policy for data frames only*/
+#ifdef CONFIG_XRADIO_DEBUGFS
+	if ((rates_dbg_en & 0x1) && ieee80211_is_data(t->hdr->frame_control)) {
+		rates_dbg_en |= 0x02;
+	}
+#endif
+
+	t->txpriv.rate_id = tx_policy_get(priv,
+		t->tx_info->control.rates, t->txpriv.use_bg_rate,
+		&tx_policy_renew);
+	if (t->txpriv.rate_id == XRADIO_INVALID_RATE_ID)
+		return -EFAULT;
+
+#ifdef SUPPORT_HT40
+
+	wsm->TxPolicyIndex = t->txpriv.rate_id;
+
+	wsm->TxRateEntry  =
+	hw_priv->tx_policy_cache.cache[t->txpriv.rate_id].policy.rate_entrys[0];
+
+#else
+
+	wsm->flags |= t->txpriv.rate_id << 4;
+	t->rate = xradio_get_tx_rate(hw_priv, &t->tx_info->control.rates[0]);
+	if (t->txpriv.use_bg_rate)
+		wsm->maxTxRate = (u8)(t->txpriv.use_bg_rate & 0x3f);
+	else
+		wsm->maxTxRate = t->rate->hw_value;
+
+#endif
+
+#ifdef SUPPORT_HT40
+
+	/* set the first TxRateEntry and
+	   clear the dataframe flag of rates_dbg_en */
+#ifdef CONFIG_XRADIO_DEBUGFS
+	if (rates_dbg_en & 0x02) {
+		wsm->TxRateEntry = rates_debug[0];
+		rates_dbg_en  &= ~0x2;
+	}
+#endif
+
+#else
+
+	/*set the maxTxRate and clear the dataframe flag of rates_dbg_en */
+#ifdef CONFIG_XRADIO_DEBUGFS
+	if (rates_dbg_en & 0x02) {
+		wsm->maxTxRate = maxRate_dbg;
+		rates_dbg_en  &= ~0x2;
+	}
+#endif
+
+	if (t->rate->flags & IEEE80211_TX_RC_MCS) {
+		if (priv->association_mode.greenfieldMode)
+			wsm->htTxParameters |=
+				__cpu_to_le32(WSM_HT_TX_GREENFIELD);
+		else
+			wsm->htTxParameters |=
+				__cpu_to_le32(WSM_HT_TX_MIXED);
+	}
+
+#endif
+
+	if (tx_policy_renew) {
+		txrx_printk(XRADIO_DBG_MSG, "[TX] TX policy renew.\n");
+		/* It's not so optimal to stop TX queues every now and then.
+		 * Maybe it's better to reimplement task scheduling with
+		 * a counter. */
+		/* xradio_tx_queues_lock(priv); */
+		/* Definetly better. TODO. */
+		if (atomic_add_return(1, &hw_priv->upload_count) == 1) {
+			wsm_lock_tx_async(hw_priv);
+			if (queue_work(hw_priv->workqueue,
+				  &hw_priv->tx_policy_upload_work) <= 0) {
+				atomic_set(&hw_priv->upload_count, 0);
+				wsm_unlock_tx(hw_priv);
+			}
+		}
+	}
+	return 0;
+}
+
+static bool
+xradio_tx_h_pm_state(struct xradio_vif *priv, struct xradio_txinfo *t)
+{
+	int was_buffered = 1;
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (t->txpriv.link_id == priv->link_id_after_dtim &&
+			!priv->buffered_multicasts) {
+		priv->buffered_multicasts = true;
+		if (priv->sta_asleep_mask)
+			queue_work(priv->hw_priv->workqueue,
+				&priv->multicast_start_work);
+	}
+
+	if (t->txpriv.raw_link_id && t->txpriv.tid < XRADIO_MAX_TID)
+		was_buffered = priv->link_id_db[t->txpriv.raw_link_id - 1]
+				.buffered[t->txpriv.tid]++;
+
+	return !was_buffered;
+}
+
+static void
+xradio_tx_h_ba_stat(struct xradio_vif *priv,
+		    struct xradio_txinfo *t)
+{
+	struct xradio_common *hw_priv = priv->hw_priv;
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (priv->join_status != XRADIO_JOIN_STATUS_STA)
+		return;
+	if (!xradio_is_ht(&hw_priv->ht_info))
+		return;
+	if (!priv->setbssparams_done)
+		return;
+	if (!ieee80211_is_data(t->hdr->frame_control))
+		return;
+
+	spin_lock_bh(&hw_priv->ba_lock);
+	hw_priv->ba_acc += t->skb->len - t->hdrlen;
+	if (!(hw_priv->ba_cnt_rx || hw_priv->ba_cnt)) {
+		mod_timer(&hw_priv->ba_timer,
+			jiffies + XRADIO_BLOCK_ACK_INTERVAL);
+	}
+	hw_priv->ba_cnt++;
+	spin_unlock_bh(&hw_priv->ba_lock);
+}
+
+static int
+xradio_tx_h_skb_pad(struct xradio_common *priv,
+		    struct wsm_tx *wsm,
+		    struct sk_buff *skb)
+{
+	size_t len = __le16_to_cpu(wsm->hdr.len);
+	size_t padded_len = priv->sbus_ops->align_size(priv->sbus_priv, len);
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (SYS_WARN(skb_padto(skb, padded_len) != 0)) {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* ******************************************************************** */
+#if (defined(CONFIG_XRADIO_DEBUG))
+u16  txparse_flags;
+u16  rxparse_flags;
+#endif
+
+#if PERF_INFO_TEST
+struct timeval mac_start_time;
+#endif
+
+void xradio_tx(struct ieee80211_hw *dev, struct sk_buff *skb)
+{
+	struct xradio_common *hw_priv = dev->priv;
+	struct xradio_txinfo t = {
+		.skb = skb,
+		.queue = skb_get_queue_mapping(skb),
+		.tx_info = IEEE80211_SKB_CB(skb),
+		.hdr = (struct ieee80211_hdr *)skb->data,
+		.txpriv.tid = XRADIO_MAX_TID,
+		.txpriv.rate_id = XRADIO_INVALID_RATE_ID,
+#ifdef P2P_MULTIVIF
+		.txpriv.raw_if_id = 0,
+#endif
+		.txpriv.use_bg_rate = 0,
+#ifdef AP_ARP_COMPAT_FIX
+		.txpriv.iv_len = 0,
+#endif
+	};
+	struct ieee80211_sta *sta;
+	struct wsm_tx *wsm;
+	bool tid_update = 0;
+#if PERF_INFO_TEST
+	int date_len = skb->len;
+#endif
+
+#ifndef SUPPORT_HT40
+
+	u8 flags = 0;
+
+#endif
+
+	int ret = 0;
+	struct xradio_vif *priv;
+	struct ieee80211_hdr *frame = (struct ieee80211_hdr *)skb->data;
+	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;
+
+	PERF_INFO_GETTIME(&mac_start_time);
+	if (!skb->data)
+		SYS_BUG(1);
+
+#ifdef HW_RESTART
+	if (hw_priv->hw_restart) {
+		txrx_printk(XRADIO_DBG_WARN, "%s, hw in reset.\n", __func__);
+		ret = __LINE__;
+		goto drop;
+	}
+#endif
+
+	if (!(t.tx_info->control.vif)) {
+		ret = __LINE__;
+		goto drop;
+	}
+	priv = xrwl_get_vif_from_ieee80211(t.tx_info->control.vif);
+	if (!priv) {
+		ret = __LINE__;
+		goto drop;
+	}
+
+	if (atomic_read(&priv->enabled) == 0) {
+		ret = __LINE__;
+		goto drop;
+	}
+
+#ifdef CONFIG_XRADIO_DEBUGFS
+	/* parse frame for debug. */
+	if (txparse_flags)
+		xradio_parse_frame(skb->data, 0, txparse_flags, priv->if_id);
+#endif
+
+	/*
+	 * dhcp and 8021 frames are important, use b/g rate and delay scan.
+	 * it can make sense, such as accelerate connect.
+	 */
+	if (ieee80211_is_auth(frame->frame_control)) {
+		hw_priv->scan_delay_time[priv->if_id] = jiffies;
+		hw_priv->scan_delay_status[priv->if_id] = XRADIO_SCAN_DELAY;
+	} else if (ieee80211_is_data_present(frame->frame_control)) {
+		u8 *llc = skb->data+ieee80211_hdrlen(frame->frame_control);
+		if (is_dhcp(llc) || is_8021x(llc)) {
+			t.txpriv.use_bg_rate =
+			hw_priv->hw->wiphy-> \
+			   bands[hw_priv->channel->band]->bitrates[0].hw_value;
+			if (priv->vif->p2p)
+				t.txpriv.use_bg_rate = AG_RATE_INDEX;
+			t.txpriv.use_bg_rate |= 0x80;
+		}
+		if (t.txpriv.use_bg_rate) {
+			hw_priv->scan_delay_time[priv->if_id] = jiffies;
+			hw_priv->scan_delay_status[priv->if_id] = XRADIO_SCAN_DELAY;
+		}
+	} else if (ieee80211_is_deauth(frame->frame_control) ||
+		   ieee80211_is_disassoc(frame->frame_control)) {
+		hw_priv->scan_delay_status[priv->if_id] = XRADIO_SCAN_ALLOW;
+	}
+
+#ifdef AP_HT_COMPAT_FIX
+	if (ieee80211_is_assoc_req(frame->frame_control) &&
+		priv->if_id == 0 && !(priv->ht_compat_det & 0x10)) {
+		xradio_remove_ht_ie(priv, skb);
+	}
+#endif
+
+#ifdef CONFIG_XRADIO_TESTMODE
+	spin_lock_bh(&hw_priv->tsm_lock);
+	if (hw_priv->start_stop_tsm.start) {
+		if (hw_priv->tsm_info.ac == t.queue)
+			hw_priv->tsm_stats.txed_msdu_count++;
+	}
+	spin_unlock_bh(&hw_priv->tsm_lock);
+#endif /*CONFIG_XRADIO_TESTMODE*/
+
+#ifdef TES_P2P_0002_ROC_RESTART
+	xradio_frame_monitor(hw_priv, skb, true);
+#endif
+
+	if (ieee80211_is_action(frame->frame_control) &&
+		mgmt->u.action.category == WLAN_CATEGORY_PUBLIC) {
+		u8 *action = (u8 *)&mgmt->u.action.category;
+		xradio_check_go_neg_conf_success(hw_priv, action);
+		xradio_check_prov_desc_req(hw_priv, action);
+	}
+
+	t.txpriv.if_id = priv->if_id;
+	t.hdrlen = ieee80211_hdrlen(t.hdr->frame_control);
+	t.da = ieee80211_get_DA(t.hdr);
+	t.sta_priv =
+		(struct xradio_sta_priv *)&t.tx_info->control.sta->drv_priv;
+
+	if (SYS_WARN(t.queue >= 4)) {
+		ret = __LINE__;
+		goto drop;
+	}
+
+	/*
+	spin_lock_bh(&hw_priv->tx_queue[t.queue].lock);
+	if ((priv->if_id == 0) &&
+		(hw_priv->tx_queue[t.queue].num_queued_vif[0] >=
+			hw_priv->vif0_throttle)) {
+		spin_unlock_bh(&hw_priv->tx_queue[t.queue].lock);
+		ret = __LINE__;
+		goto drop;
+	} else if ((priv->if_id == 1) &&
+		(hw_priv->tx_queue[t.queue].num_queued_vif[1] >=
+			hw_priv->vif1_throttle)) {
+		spin_unlock_bh(&hw_priv->tx_queue[t.queue].lock);
+		ret = __LINE__;
+		goto drop;
+	}
+	spin_unlock_bh(&hw_priv->tx_queue[t.queue].lock);
+	*/
+
+	ret = xradio_tx_h_calc_link_ids(priv, &t);
+	if (ret) {
+		ret = __LINE__;
+		goto drop;
+	}
+
+	txrx_printk(XRADIO_DBG_MSG, "[TX] TX %d bytes (if_id: %d, "
+			"queue: %d, link_id: %d (%d)).\n",
+			skb->len, priv->if_id, t.queue, t.txpriv.link_id,
+			t.txpriv.raw_link_id);
+
+	xradio_tx_h_pm(priv, &t);
+	xradio_tx_h_calc_tid(priv, &t);
+	ret = xradio_tx_h_crypt(priv, &t);
+	if (ret) {
+		ret = __LINE__;
+		goto drop;
+	}
+
+#ifdef SUPPORT_HT40
+
+	ret = xradio_tx_h_align(priv, &t);
+
+#else
+
+	ret = xradio_tx_h_align(priv, &t, &flags);
+
+#endif
+
+	if (ret) {
+		ret = __LINE__;
+		goto drop;
+	}
+	ret = xradio_tx_h_action(priv, &t);
+	if (ret) {
+		ret = __LINE__;
+		goto drop;
+	}
+	wsm = xradio_tx_h_wsm(priv, &t);
+	if (!wsm) {
+		ret = __LINE__;
+		goto drop;
+	}
+
+#ifdef SUPPORT_HT40
+
+#ifdef CONFIG_XRADIO_TESTMODE
+	wsm->ExpireTimeSetting = WSM_TX_FLAG_EXPIRY_TIME;
+#endif /*CONFIG_XRADIO_TESTMODE*/
+
+#else
+
+#ifdef CONFIG_XRADIO_TESTMODE
+	flags |= WSM_TX_FLAG_EXPIRY_TIME;
+#endif /*CONFIG_XRADIO_TESTMODE*/
+	wsm->flags |= flags;
+
+#endif
+	xradio_tx_h_bt(priv, &t, wsm);
+	ret = xradio_tx_h_rate_policy(priv, &t, wsm);
+	if (ret) {
+		ret = __LINE__;
+		goto drop;
+	}
+
+	ret = xradio_tx_h_skb_pad(hw_priv, wsm, skb);
+	if (ret) {
+		ret = __LINE__;
+		goto drop;
+	}
+
+	rcu_read_lock();
+	sta = rcu_dereference(t.tx_info->control.sta);
+
+	xradio_tx_h_ba_stat(priv, &t);
+	spin_lock_bh(&priv->ps_state_lock);
+	tid_update = xradio_tx_h_pm_state(priv, &t);
+	SYS_BUG(xradio_queue_put(&hw_priv->tx_queue[t.queue],
+			t.skb, &t.txpriv));
+#ifdef ROC_DEBUG
+	txrx_printk(XRADIO_DBG_ERROR, "QPUT %x, %pM, if_id - %d\n",
+		t.hdr->frame_control, t.da, priv->if_id);
+#endif
+	spin_unlock_bh(&priv->ps_state_lock);
+
+	/* To improve tcp tx in linux4.9
+	 * skb_orphan will tell tcp that driver has processed this skb,
+	 * so tcp can send other skb to driver.
+	 * If this is a retransmitted frame by umac, driver do not skb_orphan it again.
+	 */
+	if (!(t.tx_info->flags & IEEE80211_TX_INTFL_RETRANSMISSION))
+		skb_orphan(skb);
+
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+	if (tid_update && sta)
+		mac80211_sta_set_buffered(sta,
+				t.txpriv.tid, true);
+#endif /* CONFIG_XRADIO_USE_EXTENSIONS */
+
+	rcu_read_unlock();
+
+	xradio_proc_wakeup(hw_priv);
+	PERF_INFO_STAMP(&mac_start_time, &mac_tx, date_len);
+
+	return;
+
+drop:
+	txrx_printk(XRADIO_DBG_WARN, "drop=%d, fctl=0x%04x.\n",
+		    ret, frame->frame_control);
+	if (!(t.tx_info->flags & IEEE80211_TX_INTFL_RETRANSMISSION))
+		skb_orphan(skb);
+	xradio_skb_post_gc(hw_priv, skb, &t.txpriv);
+	return;
+}
+
+/* ******************************************************************** */
+
+static int xradio_handle_pspoll(struct xradio_vif *priv,
+				struct sk_buff *skb)
+{
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	struct ieee80211_sta *sta;
+	struct ieee80211_pspoll *pspoll =
+		(struct ieee80211_pspoll *) skb->data;
+	int link_id = 0;
+	u32 pspoll_mask = 0;
+	int drop = 1;
+	int i;
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (priv->join_status != XRADIO_JOIN_STATUS_AP)
+		goto done;
+	if (memcmp(priv->vif->addr, pspoll->bssid, ETH_ALEN))
+		goto done;
+
+	rcu_read_lock();
+	sta = mac80211_find_sta(priv->vif, pspoll->ta);
+	if (sta) {
+		struct xradio_sta_priv *sta_priv;
+		sta_priv = (struct xradio_sta_priv *)&sta->drv_priv;
+		link_id = sta_priv->link_id;
+		pspoll_mask = BIT(sta_priv->link_id);
+	}
+	rcu_read_unlock();
+	if (!link_id)
+		goto done;
+
+	priv->pspoll_mask |= pspoll_mask;
+	drop = 0;
+
+	/* Do not report pspols if data for given link id is
+	 * queued already. */
+	for (i = 0; i < 4; ++i) {
+		if (xradio_queue_get_num_queued(priv,
+				&hw_priv->tx_queue[i],
+				pspoll_mask)) {
+			xradio_proc_wakeup(hw_priv);
+			drop = 1;
+			break;
+		}
+	}
+	txrx_printk(XRADIO_DBG_NIY, "[RX] PSPOLL: %s\n", drop ? "local" : "fwd");
+done:
+	return drop;
+}
+
+/* ******************************************************************** */
+extern u32 tx_retrylimit;
+extern u32 tx_over_limit;
+extern u32 tx_lower_limit;
+extern int retry_mis;
+
+#ifdef SUPPORT_HT40
+
+void xradio_get_ieee80211_tx_rate(struct xradio_common *hw_priv,
+	u16 RateEntry, struct ieee80211_tx_rate *rates)
+{
+	if (GET_RATE_ENTRY_RATEINDEX(RateEntry) == FW_RATE_USE_DEFAULT) {
+		rates->idx	= -1;
+		rates->count	= 0;
+		rates->flags	= 0;
+
+		return;
+	}
+
+	if (GET_RATE_ENTRY_MODEM(RateEntry) == FW_RATE_MODEM_HTOFDM) {
+		rates->idx	= GET_RATE_ENTRY_RATEINDEX(RateEntry);
+		rates->count	= GET_RATE_ENTRY_MAXRETRY(RateEntry);
+		rates->flags	= IEEE80211_TX_RC_MCS;
+
+		if (GET_RATE_ENTRY_BANDWIDTH(RateEntry) == FW_RATE_BW_40M)
+			rates->flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;
+
+		if (GET_RATE_ENTRY_FLAGS(RateEntry) & FW_RATE_F_GF)
+			rates->flags |= IEEE80211_TX_RC_GREEN_FIELD;
+
+		if (GET_RATE_ENTRY_FLAGS(RateEntry) & FW_RATE_F_SGI)
+			rates->flags |= IEEE80211_TX_RC_SHORT_GI;
+	} else {
+		rates->idx = LegacyRxedRateLut[hw_priv->channel->band] \
+					[GET_RATE_ENTRY_RATEINDEX(RateEntry)];
+		rates->count = GET_RATE_ENTRY_MAXRETRY(RateEntry);
+
+		if (GET_RATE_ENTRY_FLAGS(RateEntry) & FW_RATE_F_SPRE)
+			rates->flags |= IEEE80211_TX_RC_USE_SHORT_PREAMBLE;
+	}
+
+	return;
+}
+
+#endif
+
+void xradio_tx_confirm_cb(struct xradio_common *hw_priv,
+			  struct wsm_tx_confirm *arg)
+{
+	u8 queue_id = xradio_queue_get_queue_id(arg->packetID);
+	struct xradio_queue *queue = &hw_priv->tx_queue[queue_id];
+	struct sk_buff *skb;
+	const struct xradio_txpriv *txpriv;
+	struct xradio_vif *priv;
+#ifndef SUPPORT_HT40
+	u32    feedback_retry = 0;
+#endif
+
+#ifdef SUPPORT_HT40
+
+	if (arg->status) {
+		txrx_printk(XRADIO_DBG_WARN, "status=%d, retry=%d, lastRate=0x%04x\n",
+			    arg->status, arg->ackFailures, arg->txedRateEntry);
+	} else {
+		txrx_printk(XRADIO_DBG_MSG, "status=%d, retry=%d, lastRate=0x%04x\n",
+			    arg->status, arg->ackFailures, arg->txedRateEntry);
+	}
+
+
+#else
+
+	if (arg->status) {
+		txrx_printk(XRADIO_DBG_NIY, "status=%d, retry=%d, lastRate=%d\n",
+			    arg->status, arg->ackFailures, arg->txedRate);
+	} else {
+		txrx_printk(XRADIO_DBG_MSG, "status=%d, retry=%d, lastRate=%d\n",
+			    arg->status, arg->ackFailures, arg->txedRate);
+	}
+
+#endif
+
+#ifdef TES_P2P_0002_ROC_RESTART
+	if ((TES_P2P_0002_state == TES_P2P_0002_STATE_GET_PKTID) &&
+		(arg->packetID == TES_P2P_0002_packet_id)) {
+		if (arg->status == 0x00) {
+
+			struct timeval TES_P2P_0002_tmval;
+			s32 TES_P2P_0002_roc_time;
+			s32 TES_P2P_0002_now_sec;
+			s32 TES_P2P_0002_now_usec;
+			bool TES_P2P_0002_roc_rst_need;
+
+			xr_do_gettimeofday(&TES_P2P_0002_tmval);
+			TES_P2P_0002_roc_rst_need	= false;
+			TES_P2P_0002_now_sec = (s32)(TES_P2P_0002_tmval.tv_sec);
+			TES_P2P_0002_now_usec = (s32)(TES_P2P_0002_tmval.tv_usec);
+			TES_P2P_0002_roc_time = TES_P2P_0002_roc_dur -
+			    (((TES_P2P_0002_now_sec - TES_P2P_0002_roc_sec) * 1000) +
+			    ((TES_P2P_0002_now_usec - TES_P2P_0002_roc_usec) / 1000));
+
+			/* tx rsp to rx cfm will need more than 60ms */
+			if (TES_P2P_0002_roc_time < 100) {
+				TES_P2P_0002_roc_time = 100;
+				TES_P2P_0002_roc_rst_need = true;
+			}
+
+			if (TES_P2P_0002_roc_rst_need == true) {
+				txrx_printk(XRADIO_DBG_WARN,
+					    "[ROC RESTART ACTIVE ON][Confirm CallBack]");
+				cancel_delayed_work_sync(&hw_priv->rem_chan_timeout);
+				if (atomic_read(&hw_priv->remain_on_channel)) {
+					queue_delayed_work(hw_priv->spare_workqueue,
+							   &hw_priv->rem_chan_timeout,
+							   (TES_P2P_0002_roc_time) * HZ / 1000);
+				}
+			}
+		}
+		TES_P2P_0002_state = TES_P2P_0002_STATE_IDLE;
+		txrx_printk(XRADIO_DBG_NIY,
+			    "[ROC_RESTART_STATE_IDLE][Confirm CallBack]");
+	}
+#endif
+
+	if (unlikely(xradio_itp_tx_running(hw_priv)))
+		return;
+
+	priv = xrwl_hwpriv_to_vifpriv(hw_priv, arg->if_id);
+	if (unlikely(!priv))
+		return;
+	if (unlikely(priv->mode == NL80211_IFTYPE_UNSPECIFIED)) {
+		/* STA is stopped. */
+		spin_unlock(&priv->vif_lock);
+		return;
+	}
+
+	if (SYS_WARN(queue_id >= 4)) {
+		spin_unlock(&priv->vif_lock);
+		return;
+	}
+
+#ifdef CONFIG_XRADIO_TESTMODE
+	spin_lock_bh(&hw_priv->tsm_lock);
+	if ((arg->status == WSM_STATUS_RETRY_EXCEEDED) ||
+	    (arg->status == WSM_STATUS_TX_LIFETIME_EXCEEDED)) {
+		hw_priv->tsm_stats.msdu_discarded_count++;
+	} else if ((hw_priv->start_stop_tsm.start) &&
+		(arg->status == WSM_STATUS_SUCCESS)) {
+		if (queue_id == hw_priv->tsm_info.ac) {
+			struct timeval tmval;
+			xr_do_gettimeofday(&tmval);
+			u16 pkt_delay =
+				hw_priv->start_stop_tsm.packetization_delay;
+			if (hw_priv->tsm_info.sta_roamed &&
+			    !hw_priv->tsm_info.use_rx_roaming) {
+				hw_priv->tsm_info.roam_delay = tmval.tv_usec -
+				hw_priv->tsm_info.txconf_timestamp_vo;
+				if (hw_priv->tsm_info.roam_delay > pkt_delay)
+					hw_priv->tsm_info.roam_delay -= pkt_delay;
+				txrx_printk(XRADIO_DBG_MSG, "[TX] txConf"
+				"Roaming: roam_delay = %u\n",
+				hw_priv->tsm_info.roam_delay);
+				hw_priv->tsm_info.sta_roamed = 0;
+			}
+			hw_priv->tsm_info.txconf_timestamp_vo = tmval.tv_usec;
+		}
+	}
+	spin_unlock_bh(&hw_priv->tsm_lock);
+#endif /*CONFIG_XRADIO_TESTMODE*/
+	if ((arg->status == WSM_REQUEUE) &&
+	    (arg->flags & WSM_TX_STATUS_REQUEUE)) {
+		/* "Requeue" means "implicit suspend" */
+		struct wsm_suspend_resume suspend = {
+			.link_id = arg->link_id,
+			.stop = 1,
+			.multicast = !arg->link_id,
+			.if_id = arg->if_id,
+		};
+		xradio_suspend_resume(priv, &suspend);
+		txrx_printk(XRADIO_DBG_NIY, "Requeue for link_id %d (try %d)."
+			" STAs asleep: 0x%.8X\n",
+			arg->link_id,
+			xradio_queue_get_generation(arg->packetID) + 1,
+			priv->sta_asleep_mask);
+#ifdef CONFIG_XRADIO_TESTMODE
+		SYS_WARN(xradio_queue_requeue(hw_priv, queue,
+				arg->packetID, true));
+#else
+		SYS_WARN(xradio_queue_requeue(queue,
+				arg->packetID, true));
+#endif
+		spin_lock_bh(&priv->ps_state_lock);
+		if (!arg->link_id) {
+			priv->buffered_multicasts = true;
+			if (priv->sta_asleep_mask) {
+				queue_work(hw_priv->workqueue,
+					&priv->multicast_start_work);
+			}
+		}
+		spin_unlock_bh(&priv->ps_state_lock);
+		spin_unlock(&priv->vif_lock);
+	} else if (!xradio_queue_get_skb(
+			queue, arg->packetID, &skb, &txpriv)) {
+		struct ieee80211_tx_info *tx = IEEE80211_SKB_CB(skb);
+		struct ieee80211_hdr *frame =
+		    (struct ieee80211_hdr *)&skb->data[txpriv->offset];
+		int tx_count = arg->ackFailures;
+		u8 ht_flags = 0;
+
+		/*
+		 * reset if_0 in firmware when STA-unjoined,
+		 * fix the errors when switch APs in combo mode.
+		 */
+		if (unlikely(ieee80211_is_disassoc(frame->frame_control) ||
+			  ieee80211_is_deauth(frame->frame_control))) {
+			if (priv->join_status == XRADIO_JOIN_STATUS_STA) {
+				wsm_send_deauth_to_self(hw_priv, priv);
+				/* Shedule unjoin work */
+				txrx_printk(XRADIO_DBG_WARN,
+					    "Issue unjoin command(TX) by self.\n");
+				if (cancel_delayed_work(&priv->unjoin_delayed_work)) {
+					wsm_lock_tx_async(hw_priv);
+					if (queue_work(hw_priv->workqueue, &priv->unjoin_work) <= 0)
+						wsm_unlock_tx(hw_priv);
+				}
+			}
+		}
+
+#ifdef ROC_DEBUG
+#ifndef P2P_MULTIVIF
+		if (txpriv->offchannel_if_id)
+			txrx_printk(XRADIO_DBG_ERROR, "TX CONFIRM %x - %d - %d\n",
+				skb->data[txpriv->offset],
+				txpriv->offchannel_if_id, arg->status);
+#else
+		if (txpriv->if_id)
+			txrx_printk(XRADIO_DBG_ERROR, "TX CONFIRM %x - %d - %d\n",
+				skb->data[txpriv->offset],
+				txpriv->raw_if_id, arg->status);
+#endif
+#endif
+
+#ifdef SUPPORT_HT40
+
+		if (priv->association_mode.PhyModeCfg.GF_Enable)
+			ht_flags |= IEEE80211_TX_RC_GREEN_FIELD;
+
+#else
+
+		if (priv->association_mode.greenfieldMode)
+			ht_flags |= IEEE80211_TX_RC_GREEN_FIELD;
+
+#endif
+
+		/* bss loss confirm. */
+		if (unlikely(priv->bss_loss_status == XRADIO_BSS_LOSS_CONFIRMING &&
+		    priv->bss_loss_confirm_id == arg->packetID)) {
+			spin_lock(&priv->bss_loss_lock);
+			priv->bss_loss_status = arg->status ? XRADIO_BSS_LOSS_CONFIRMED :
+						    XRADIO_BSS_LOSS_NONE;
+			spin_unlock(&priv->bss_loss_lock);
+		}
+
+/*when less ap can't reply arp request accidentally,
+*then disconnect actively,
+*and wait system trigger reconnect again.
+*/
+#ifdef AP_ARP_COMPAT_FIX
+		if (likely(!arg->status) &&
+			(priv->join_status == XRADIO_JOIN_STATUS_STA) &&
+			(ieee80211_is_data(frame->frame_control))) {
+				u8 machdrlen = ieee80211_hdrlen(frame->frame_control);
+				u8 *llc_data = (u8 *)frame + machdrlen + txpriv->iv_len;
+				if (is_SNAP(llc_data) && is_arp(llc_data)) {
+					u8 *arp_hdr = llc_data + LLC_LEN;
+					u16 *arp_type = (u16 *)(arp_hdr + ARP_TYPE_OFFSET);
+					if (*arp_type == cpu_to_be16(ARP_REQUEST))
+						priv->arp_compat_cnt++;
+					if (priv->arp_compat_cnt > 10) {
+						txrx_printk(XRADIO_DBG_ERROR,
+							"ap don't reply arp resp count=%d\n",
+							priv->arp_compat_cnt);
+						priv->arp_compat_cnt = 0;
+						wsm_send_disassoc_to_self(hw_priv, priv);
+					}
+				}
+		}
+#endif
+
+		if (likely(!arg->status)) {
+			tx->flags |= IEEE80211_TX_STAT_ACK;
+			priv->cqm_tx_failure_count = 0;
+			++tx_count;
+#ifdef SUPPORT_HT40
+
+			if (((arg->txedRateEntry >> MODEMTYPE_SHIFT)
+				& MODEMTYPE_MASK) == RATE_MODEM_HTOFDM) {
+
+				if (((arg->txedRateEntry >> BANDWIDTH_SHIFT)
+					& BANDWIDTH_MASK)
+					== RATE_BANDWIDTH_20M) {
+					if (arg->txedRateEntry & RATE_F_SGI) {
+						u8 index = (arg->txedRateEntry
+							>> RATEINDEX_SHIFT)
+							& RATEINDEX_MASK;
+
+						TxedHtofdmRateMap[0][index]++;
+					} else {
+						u8 index = (arg->txedRateEntry
+							>> RATEINDEX_SHIFT)
+							& RATEINDEX_MASK;
+
+						TxedHtofdmRateMap[1][index]++;
+					}
+				} else {
+					if (arg->txedRateEntry & RATE_F_SGI) {
+						u8 index = (arg->txedRateEntry
+							>> RATEINDEX_SHIFT)
+							& RATEINDEX_MASK;
+
+						TxedHtofdmRateMap[2][index]++;
+					} else {
+						u8 index = (arg->txedRateEntry
+							>> RATEINDEX_SHIFT)
+							& RATEINDEX_MASK;
+
+						TxedHtofdmRateMap[3][index]++;
+					}
+				}
+			} else {
+				u8 index =
+				(arg->txedRateEntry >> RATEINDEX_SHIFT)
+				& RATEINDEX_MASK;
+
+				if (index < 6) {
+					if (arg->txedRateEntry
+						& RATE_F_PREAMBLE_S) {
+						TxedLegacyRateMap[0] \
+								[index*2+1]++;
+					} else {
+						TxedLegacyRateMap[0] \
+								[index*2]++;
+					}
+				} else {
+					TxedLegacyRateMap[1][index-6]++;
+				}
+			}
+
+#else
+
+			if (arg->txedRate < 24)
+				TxedRateIdx_Map[arg->txedRate]++;
+			else
+				SYS_WARN(1);
+
+#endif
+
+			xradio_debug_txed(priv);
+			if (arg->flags & WSM_TX_STATUS_AGGREGATION) {
+				/* Do not report aggregation to mac80211:
+				 * it confuses minstrel a lot. */
+				/* tx->flags |= IEEE80211_TX_STAT_AMPDU; */
+				xradio_debug_txed_agg(priv);
+			}
+		} else {
+			/* TODO: Update TX failure counters */
+			if (unlikely(priv->cqm_tx_failure_thold &&
+			     (++priv->cqm_tx_failure_count >
+			      priv->cqm_tx_failure_thold))) {
+				priv->cqm_tx_failure_thold = 0;
+				queue_work(hw_priv->workqueue,
+						&priv->tx_failure_work);
+			}
+			if (tx_count)
+				++tx_count;
+		}
+		spin_unlock(&priv->vif_lock);
+
+		tx->status.ampdu_len = 1;
+		tx->status.ampdu_ack_len = 1;
+
+#if 0
+		tx_count = arg->ackFailures+1;
+		for (i = 0; i < IEEE80211_TX_MAX_RATES; ++i) {
+			if (tx->status.rates[i].count >= tx_count) {
+				tx->status.rates[i].count = tx_count;
+				if (likely(!arg->status)) {
+					s8 txed_idx = xradio_get_rate_idx(hw_priv,
+							 tx->status.rates[i].flags,
+							 arg->txedRate);
+					if (tx->status.rates[i].idx != txed_idx) {
+						if (i < (IEEE80211_TX_MAX_RATES-1)) {
+							i++;
+							tx->status.rates[i].idx   = txed_idx;
+							tx->status.rates[i].count = 1;
+						} else if (txed_idx >= 0) {
+							tx->status.rates[i].idx   = txed_idx;
+							tx->status.rates[i].count = 1;
+						}
+					}
+				}
+				break;
+			}
+			tx_count -= tx->status.rates[i].count;
+			if (tx->status.rates[i].flags & IEEE80211_TX_RC_MCS)
+				tx->status.rates[i].flags |= ht_flags;
+		}
+
+		for (++i; i < IEEE80211_TX_MAX_RATES; ++i) {
+			tx->status.rates[i].count = 0;
+			tx->status.rates[i].idx = -1;
+		}
+
+#else
+
+#ifdef SUPPORT_HT40
+
+		if (txpriv->use_bg_rate) {
+			tx->status.rates[0].count = arg->ackFailures+1;
+			tx->status.rates[0].idx = 0;
+			tx->status.rates[1].idx = -1;
+			tx->status.rates[2].idx = -1;
+			tx->status.rates[3].idx = -1;
+			tx->status.rates[4].idx = -1;
+		} else {
+			u8 RateTryIdx = 0x0;
+			u8 BreakIdx = 0x0;
+			bool IsFind = false;
+			bool IsBreak = false;
+
+			for (RateTryIdx = 0; RateTryIdx < IEEE80211_TX_MAX_RATES; RateTryIdx++) {
+
+				if (!IsBreak)
+					BreakIdx = RateTryIdx;
+
+				if (GET_RATE_ENTRY_RATEINDEX(arg->RateTry[RateTryIdx]) == FW_RATE_USE_DEFAULT)
+					IsBreak = true;
+
+				if (IsBreak) {
+					tx->status.rates[RateTryIdx].idx = -1;
+					tx->status.rates[RateTryIdx].count = 0;
+					tx->status.rates[RateTryIdx].flags = 0;
+				} else {
+					xradio_get_ieee80211_tx_rate(hw_priv,
+						arg->RateTry[RateTryIdx], &tx->status.rates[RateTryIdx]);
+					if ((!arg->status) && (!IsFind)) {
+						if ((arg->RateTry[RateTryIdx]&0xFFF0) == (arg->txedRateEntry&0xFFF0)) {
+							tx->status.rates[RateTryIdx].count++;
+							IsFind = true;
+						}
+					}
+				}
+			}
+
+			if ((!arg->status) && (!IsFind)) {
+				if (!IsBreak)
+					BreakIdx = 4;
+
+				xradio_get_ieee80211_tx_rate(hw_priv, arg->txedRateEntry, &tx->status.rates[BreakIdx]);
+				tx->status.rates[BreakIdx].count = 1;
+			}
+		}
+
+#else
+		txrx_printk(XRADIO_DBG_MSG,
+			    "feedback:%08x, %08x, %08x.\n",
+			     arg->rate_try[2], arg->rate_try[1], arg->rate_try[0]);
+		if (txpriv->use_bg_rate) {   /* bg rates */
+			tx->status.rates[0].count = arg->ackFailures+1;
+		  tx->status.rates[0].idx   = 0;
+		  tx->status.rates[1].idx   = -1;
+		  tx->status.rates[2].idx   = -1;
+		  tx->status.rates[3].idx   = -1;
+		  tx->status.rates[4].idx   = -1;
+		} else {
+			int i;
+			int j;
+			s8  txed_idx;
+			register u8 rate_num = 0, shift = 0, retries = 0;
+			u8  flag = tx->status.rates[0].flags;
+
+			/* get retry rate idx. */
+			for (i = 2; i >= 0; i--) {
+				if (arg->rate_try[i]) {
+					for (j = 7; j >= 0; j--) {
+						shift   = j<<2;
+						retries = (arg->rate_try[i]>>shift) & 0xf;
+						if (retries) {
+							feedback_retry += retries;
+							txed_idx = xradio_get_rate_idx(hw_priv, flag,
+										       ((i<<3) + j));
+							txrx_printk(XRADIO_DBG_MSG,
+								    "rate_num=%d, hw=%d, idx=%d, "
+								    "retries=%d, flag=%d",
+								    rate_num, ((i<<3)+j),
+								    txed_idx, retries, flag);
+							if (likely(txed_idx >= 0)) {
+								tx->status.rates[rate_num].idx   = txed_idx;
+								tx->status.rates[rate_num].count = retries;
+								if (tx->status.rates[rate_num].flags &
+									IEEE80211_TX_RC_MCS)
+									tx->status.rates[rate_num].flags |=
+									    ht_flags;
+								rate_num++;
+								if (rate_num >= IEEE80211_TX_MAX_RATES) {
+									i = -1;
+									break;
+								}
+							}
+						}
+					}
+				}
+			}
+
+			/* If there is 11b rates in 11n mode, put it into MCS0 */
+			if ((arg->rate_try[0]&0xffff) && (flag & IEEE80211_TX_RC_MCS)) {
+				int br_retrys = 0;
+				for (i = 0; i < 16; i += 4)
+					br_retrys += ((arg->rate_try[0]>>i)&0xf);
+				if (rate_num > 0 && tx->status.rates[rate_num-1].idx == 0) {
+					tx->status.rates[rate_num-1].count += br_retrys;
+				} else if (rate_num < IEEE80211_TX_MAX_RATES) {
+					tx->status.rates[rate_num].idx   = 0;
+					tx->status.rates[rate_num].count += br_retrys;
+					rate_num++;
+				}
+			}
+
+			/* clear other rate. */
+			for (i = rate_num; i < IEEE80211_TX_MAX_RATES; ++i) {
+				tx->status.rates[i].count = 0;
+				tx->status.rates[i].idx = -1;
+			}
+			/* get successful rate idx. */
+			if (!arg->status) {
+				txed_idx = xradio_get_rate_idx(hw_priv, flag, arg->txedRate);
+				if (rate_num == 0) {
+					tx->status.rates[0].idx = txed_idx;
+					tx->status.rates[0].count = 1;
+				} else if (rate_num <= IEEE80211_TX_MAX_RATES) {
+					--rate_num;
+					if (txed_idx == tx->status.rates[rate_num].idx) {
+						tx->status.rates[rate_num].count += 1;
+					} else if (rate_num < (IEEE80211_TX_MAX_RATES-1)) {
+						++rate_num;
+						tx->status.rates[rate_num].idx   = txed_idx;
+						tx->status.rates[rate_num].count = 1;
+					} else if (txed_idx >= 0) {
+						tx->status.rates[rate_num].idx   = txed_idx;
+						tx->status.rates[rate_num].count = 1;
+					}
+				}
+			}
+		}
+
+#endif
+
+#endif
+
+#ifdef CONFIG_XRADIO_DEBUGFS
+#ifndef SUPPORT_HT40
+		if (arg->status == WSM_STATUS_RETRY_EXCEEDED) {
+			tx_retrylimit++;
+			retry_mis += ((s32)hw_priv->short_frame_max_tx_count -
+				       arg->ackFailures-1);
+			if (arg->ackFailures != (hw_priv->short_frame_max_tx_count-1)) {
+				if (arg->ackFailures < (hw_priv->short_frame_max_tx_count-1))
+					tx_lower_limit++;
+				else
+					tx_over_limit++;
+				txrx_printk(XRADIO_DBG_NIY,
+					    "retry_err, ackFailures=%d, feedbk_retry=%d.\n",
+					    arg->ackFailures, feedback_retry);
+			}
+		} else if (feedback_retry > hw_priv->short_frame_max_tx_count-1) {
+			tx_over_limit++;
+			txrx_printk(XRADIO_DBG_WARN,
+				    "status=%d, ackFailures=%d, feedbk_retry=%d.\n",
+				    arg->status, arg->ackFailures, feedback_retry);
+		}
+#endif
+#endif
+
+		txrx_printk(XRADIO_DBG_MSG, "[TX policy] Ack: " \
+		"%d:%d, %d:%d, %d:%d, %d:%d, %d:%d\n",
+		tx->status.rates[0].idx, tx->status.rates[0].count,
+		tx->status.rates[1].idx, tx->status.rates[1].count,
+		tx->status.rates[2].idx, tx->status.rates[2].count,
+		tx->status.rates[3].idx, tx->status.rates[3].count,
+		tx->status.rates[4].idx, tx->status.rates[4].count);
+
+#ifdef CONFIG_XRADIO_TESTMODE
+		xradio_queue_remove(hw_priv, queue, arg->packetID);
+#else
+		xradio_queue_remove(queue, arg->packetID);
+#endif /*CONFIG_XRADIO_TESTMODE*/
+	} else {
+		spin_unlock(&priv->vif_lock);
+		txrx_printk(XRADIO_DBG_WARN,
+			"%s xradio_queue_get_skb failed.\n", __func__);
+	}
+}
+
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+static void xradio_set_skb_eosp(struct sk_buff *skb)
+{
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	info->flags |= IEEE80211_TX_STATUS_EOSP;
+}
+#endif
+
+static void xradio_notify_buffered_tx(struct xradio_vif *priv,
+			       struct sk_buff *skb, int link_id, int tid)
+{
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+	struct ieee80211_sta *sta;
+	struct ieee80211_hdr *hdr;
+	u8 *buffered;
+	u8 still_buffered = 0;
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (link_id && tid < XRADIO_MAX_TID) {
+		buffered = priv->link_id_db
+				[link_id - 1].buffered;
+
+		spin_lock_bh(&priv->ps_state_lock);
+		if (!SYS_WARN(!buffered[tid]))
+			still_buffered = --buffered[tid];
+		spin_unlock_bh(&priv->ps_state_lock);
+
+		if (!still_buffered && tid < XRADIO_MAX_TID) {
+			hdr = (struct ieee80211_hdr *) skb->data;
+			rcu_read_lock();
+			sta = mac80211_find_sta(priv->vif, hdr->addr1);
+			if (sta) {
+				mac80211_sta_set_buffered(sta, tid, false);
+				xradio_set_skb_eosp(skb);
+			}
+			rcu_read_unlock();
+		}
+	}
+#endif /* CONFIG_XRADIO_USE_EXTENSIONS */
+}
+
+void xradio_skb_dtor(struct xradio_common *hw_priv,
+		     struct sk_buff *skb,
+		     const struct xradio_txpriv *txpriv)
+{
+	struct xradio_vif *priv =
+		__xrwl_hwpriv_to_vifpriv(hw_priv, txpriv->if_id);
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	skb_pull(skb, txpriv->offset);
+	if (priv && txpriv->rate_id != XRADIO_INVALID_RATE_ID) {
+		xradio_notify_buffered_tx(priv, skb,
+				txpriv->raw_link_id, txpriv->tid);
+		tx_policy_put(hw_priv, txpriv->rate_id);
+	}
+	if (likely(!xradio_is_itp(hw_priv))) {
+		down(&hw_priv->dtor_lock);
+		mac80211_tx_status(hw_priv->hw, skb);
+		up(&hw_priv->dtor_lock);
+	}
+}
+#ifdef CONFIG_XRADIO_TESTMODE
+/* TODO It should be removed before official delivery */
+static void frame_hexdump(char *prefix, u8 *data, int len)
+{
+	int i;
+
+	txrx_printk(XRADIO_DBG_MSG, "%s hexdump:\n", prefix);
+	for (i = 0; i < len; i++) {
+		if (i + 10 < len) {
+			txrx_printk(XRADIO_DBG_MSG, "%.1X %.1X %.1X %.1X" \
+				"%.1X %.1X %.1X %.1X %.1X %.1X",
+				data[i], data[i+1], data[i+2],
+				data[i+3], data[i+4], data[i+5],
+				data[i+6], data[i+7], data[i+8],
+				data[i+9]);
+			i += 9;
+		} else {
+			txrx_printk(XRADIO_DBG_MSG, "%.1X ", data[i]);
+		}
+	}
+}
+/**
+ * c1200_tunnel_send_testmode_data - Send test frame to the driver
+ *
+ * @priv: pointer to xradio private structure
+ * @skb: skb with frame
+ *
+ * Returns: 0 on success or non zero value on failure
+ */
+static int xradio_tunnel_send_testmode_data(struct xradio_common *hw_priv,
+					    struct sk_buff *skb)
+{
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+	if (xradio_tesmode_event(hw_priv->hw->wiphy, XR_MSG_EVENT_FRAME_DATA,
+				 skb->data, skb->len, GFP_ATOMIC))
+		return -EINVAL;
+
+	return 0;
+}
+
+/**
+ * xradio_frame_test_detection - Detection frame_test
+ *
+ * @priv: pointer to xradio vif structure
+ * @frame: ieee80211 header
+ * @skb: skb with frame
+ *
+ * Returns: 1 - frame test detected, 0 - not detected
+ */
+static int xradio_frame_test_detection(struct xradio_vif *priv,
+				       struct ieee80211_hdr *frame,
+				       struct sk_buff *skb)
+{
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	int hdrlen = ieee80211_hdrlen(frame->frame_control);
+	int detected = 0;
+	int ret;
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (hdrlen + hw_priv->test_frame.len <= skb->len &&
+	    memcmp(skb->data + hdrlen, hw_priv->test_frame.data,
+		   hw_priv->test_frame.len) == 0) {
+		detected = 1;
+		txrx_printk(XRADIO_DBG_MSG, "TEST FRAME detected");
+		frame_hexdump("TEST FRAME original:", skb->data, skb->len);
+		ret = ieee80211_data_to_8023(skb, hw_priv->mac_addr,
+				priv->mode);
+		if (!ret) {
+			frame_hexdump("FRAME 802.3:", skb->data, skb->len);
+			ret = xradio_tunnel_send_testmode_data(hw_priv, skb);
+		}
+		if (ret)
+			txrx_printk(XRADIO_DBG_ERROR, "Send TESTFRAME failed(%d)", ret);
+	}
+	return detected;
+}
+#endif /* CONFIG_XRADIO_TESTMODE */
+
+
+static void
+xradio_rx_h_ba_stat(struct xradio_vif *priv,
+		    size_t hdrlen, size_t skb_len)
+{
+	struct xradio_common *hw_priv = priv->hw_priv;
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (priv->join_status != XRADIO_JOIN_STATUS_STA)
+		return;
+	if (!xradio_is_ht(&hw_priv->ht_info))
+		return;
+	if (!priv->setbssparams_done)
+		return;
+
+	spin_lock_bh(&hw_priv->ba_lock);
+	hw_priv->ba_acc_rx += skb_len - hdrlen;
+	if (!(hw_priv->ba_cnt_rx || hw_priv->ba_cnt)) {
+		mod_timer(&hw_priv->ba_timer,
+			jiffies + XRADIO_BLOCK_ACK_INTERVAL);
+	}
+	hw_priv->ba_cnt_rx++;
+	spin_unlock_bh(&hw_priv->ba_lock);
+}
+
+#if 0
+u8 nettest_bssid[] = {0x00, 0x02, 0x03, 0x04, 0x05, 0x06};
+u8 save_rate_ie;
+#endif
+#if PERF_INFO_TEST
+struct timeval upper_rx_time;
+size_t upper_rx_size;
+#endif
+
+void xradio_rx_cb(struct xradio_vif *priv,
+		  struct wsm_rx *arg,
+		  struct sk_buff **skb_p)
+{
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	struct sk_buff *skb = *skb_p;
+	struct ieee80211_rx_status *hdr = IEEE80211_SKB_RXCB(skb);
+	struct ieee80211_hdr *frame = (struct ieee80211_hdr *)skb->data;
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;
+#endif
+	struct xradio_link_entry *entry = NULL;
+	unsigned long grace_period = 0;
+	bool early_data = false;
+	size_t hdrlen = 0;
+	u8   parse_iv_len = 0;
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	hdr->flag = 0;
+
+	if (unlikely(priv->mode == NL80211_IFTYPE_UNSPECIFIED)) {
+		/* STA is stopped. */
+		goto drop;
+	}
+
+#ifdef TES_P2P_0002_ROC_RESTART
+	xradio_frame_monitor(hw_priv, skb, false);
+#endif
+
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+	if ((ieee80211_is_action(frame->frame_control))
+	    && (mgmt->u.action.category == WLAN_CATEGORY_PUBLIC)) {
+		u8 *action = (u8 *)&mgmt->u.action.category;
+		xradio_check_go_neg_conf_success(hw_priv, action);
+	}
+#endif
+
+#ifdef CONFIG_XRADIO_TESTMODE
+	spin_lock_bh(&hw_priv->tsm_lock);
+	if (hw_priv->start_stop_tsm.start) {
+		unsigned queue_id = skb_get_queue_mapping(skb);
+		if (queue_id == 0) {
+			struct timeval tmval;
+			xr_do_gettimeofday(&tmval);
+			if (hw_priv->tsm_info.sta_roamed &&
+			    hw_priv->tsm_info.use_rx_roaming) {
+				hw_priv->tsm_info.roam_delay = tmval.tv_usec -
+					hw_priv->tsm_info.rx_timestamp_vo;
+				txrx_printk(XRADIO_DBG_NIY, "[RX] RxInd Roaming:"
+				"roam_delay = %u\n", hw_priv->tsm_info.roam_delay);
+				hw_priv->tsm_info.sta_roamed = 0;
+			}
+			hw_priv->tsm_info.rx_timestamp_vo = tmval.tv_usec;
+		}
+	}
+	spin_unlock_bh(&hw_priv->tsm_lock);
+#endif /*CONFIG_XRADIO_TESTMODE*/
+	if (arg->link_id && (arg->link_id != XRADIO_LINK_ID_UNMAPPED)
+			&& (arg->link_id <= XRADIO_MAX_STA_IN_AP_MODE)) {
+		entry =	&priv->link_id_db[arg->link_id - 1];
+		if (entry->status == XRADIO_LINK_SOFT &&
+				ieee80211_is_data(frame->frame_control))
+			early_data = true;
+		entry->timestamp = jiffies;
+	}
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+	else if ((arg->link_id == XRADIO_LINK_ID_UNMAPPED)
+			&& (priv->vif->p2p == WSM_START_MODE_P2P_GO)
+			&& ieee80211_is_action(frame->frame_control)
+			&& (mgmt->u.action.category == WLAN_CATEGORY_PUBLIC)) {
+		txrx_printk(XRADIO_DBG_NIY, "[RX] Going to MAP&RESET link ID\n");
+
+#if defined (DEBUG_P2P_SETTING_CRASH)
+		printk(KERN_ERR "[BUG12]link ID is unmapped, go to MAP&RESET link ID\n");
+#endif
+		if (work_pending(&priv->linkid_reset_work))
+			SYS_WARN(1);
+
+		memcpy(&priv->action_frame_sa[0],
+				ieee80211_get_SA(frame), ETH_ALEN);
+		priv->action_linkid = 0;
+		schedule_work(&priv->linkid_reset_work);
+	}
+
+	if (arg->link_id && (arg->link_id != XRADIO_LINK_ID_UNMAPPED)
+			&& (priv->vif->p2p == WSM_START_MODE_P2P_GO)
+			&& ieee80211_is_action(frame->frame_control)
+			&& (mgmt->u.action.category == WLAN_CATEGORY_PUBLIC)) {
+		/* Link ID already exists for the ACTION frame.
+		 * Reset and Remap */
+		if (work_pending(&priv->linkid_reset_work))
+			SYS_WARN(1);
+		memcpy(&priv->action_frame_sa[0],
+				ieee80211_get_SA(frame), ETH_ALEN);
+		priv->action_linkid = arg->link_id;
+		schedule_work(&priv->linkid_reset_work);
+	}
+#endif
+	if (unlikely(arg->status)) {
+		if (arg->status == WSM_STATUS_MICFAILURE) {
+			txrx_printk(XRADIO_DBG_WARN, "[RX] IF=%d, MIC failure.\n",
+				    priv->if_id);
+			hdr->flag |= RX_FLAG_MMIC_ERROR;
+		} else if (arg->status == WSM_STATUS_NO_KEY_FOUND) {
+#ifdef MONITOR_MODE
+			if (hw_priv->monitor_if_id == -1) {
+#endif
+				txrx_printk(XRADIO_DBG_WARN, "[RX] IF=%d, No key found.\n",
+				    priv->if_id);
+				goto drop;
+#ifdef MONITOR_MODE
+			}
+#endif
+		} else {
+			txrx_printk(XRADIO_DBG_WARN, "[RX] IF=%d, Receive failure: %d.\n",
+				priv->if_id, arg->status);
+			goto drop;
+		}
+	}
+
+	if (skb->len < sizeof(struct ieee80211_pspoll)) {
+		txrx_printk(XRADIO_DBG_WARN, "Mailformed SDU rx'ed. "
+			    "Size is lesser than IEEE header.\n");
+		goto drop;
+	}
+
+	if (unlikely(ieee80211_is_pspoll(frame->frame_control)))
+		if (xradio_handle_pspoll(priv, skb))
+			goto drop;
+
+	hdr->mactime = 0; /* Not supported by WSM */
+	hdr->band = (arg->channelNumber > 14) ?
+			NL80211_BAND_5GHZ : NL80211_BAND_2GHZ;
+	hdr->freq = ieee80211_channel_to_frequency(
+			arg->channelNumber,
+			hdr->band);
+
+#ifdef AP_HT_COMPAT_FIX
+
+#ifdef SUPPORT_HT40
+
+	if (!priv->ht_compat_det && priv->htcap &&
+		ieee80211_is_data_qos(frame->frame_control)) {
+		if (xradio_apcompat_detect(priv, arg->rxedRateEntry))
+			goto drop;
+	}
+
+#else
+
+	if (!priv->ht_compat_det && priv->htcap &&
+		ieee80211_is_data_qos(frame->frame_control)) {
+		if (xradio_apcompat_detect(priv, arg->rxedRate))
+			goto drop;
+	}
+
+#endif
+
+#endif
+
+#ifdef SUPPORT_HT40
+
+	if (((arg->rxedRateEntry >> MODEMTYPE_SHIFT) & MODEMTYPE_MASK) ==
+		RATE_MODEM_HTOFDM) {
+		if (((arg->rxedRateEntry >> BANDWIDTH_SHIFT) & BANDWIDTH_MASK) ==
+			RATE_BANDWIDTH_20M) {
+			if (arg->rxedRateEntry & RATE_F_SGI) {
+				u8 index = (arg->rxedRateEntry >> RATEINDEX_SHIFT) & RATEINDEX_MASK;
+				RxedHtofdmRateMap[0][index]++;
+			} else {
+				u8 index = (arg->rxedRateEntry >> RATEINDEX_SHIFT) & RATEINDEX_MASK;
+				RxedHtofdmRateMap[1][index]++;
+			}
+		} else {
+			if (arg->rxedRateEntry & RATE_F_SGI) {
+				u8 index = (arg->rxedRateEntry >> RATEINDEX_SHIFT) & RATEINDEX_MASK;
+				RxedHtofdmRateMap[2][index]++;
+			} else {
+				u8 index = (arg->rxedRateEntry >> RATEINDEX_SHIFT) & RATEINDEX_MASK;
+				RxedHtofdmRateMap[3][index]++;
+			}
+		}
+	} else {
+		u8 index = (arg->rxedRateEntry >> RATEINDEX_SHIFT) & RATEINDEX_MASK;
+		if (index < 6) {
+			if (arg->rxedRateEntry & RATE_F_PREAMBLE_S)
+				RxedLegacyRateMap[0][index*2+1]++;
+			else
+				RxedLegacyRateMap[0][index*2]++;
+
+		} else {
+			RxedLegacyRateMap[1][index-6]++;
+		}
+	}
+
+	if (GET_RATE_ENTRY_MODEM(arg->rxedRateEntry) == FW_RATE_MODEM_HTOFDM) {
+		hdr->flag |= RX_FLAG_HT;
+		hdr->rate_idx = GET_RATE_ENTRY_RATEINDEX(arg->rxedRateEntry);
+
+		if (GET_RATE_ENTRY_BANDWIDTH(arg->rxedRateEntry) == FW_RATE_BW_40M)
+			hdr->flag |= RX_FLAG_40MHZ;
+
+		if (GET_RATE_ENTRY_FLAGS(arg->rxedRateEntry)&FW_RATE_F_SGI)
+			hdr->flag |= RX_FLAG_SHORT_GI;
+
+	} else {
+		hdr->rate_idx = LegacyRxedRateLut[hdr->band][GET_RATE_ENTRY_RATEINDEX(arg->rxedRateEntry)];
+
+		if (GET_RATE_ENTRY_FLAGS(arg->rxedRateEntry)&FW_RATE_F_SPRE)
+			hdr->flag |= RX_FLAG_SHORTPRE;
+
+	}
+
+#else
+
+	if (arg->rxedRate < 24)
+		RxedRateIdx_Map[arg->rxedRate]++;
+	else
+		SYS_WARN(1);
+
+	if (arg->rxedRate >= 14) {
+		hdr->flag |= RX_FLAG_HT;
+		hdr->rate_idx = arg->rxedRate - 14;
+	} else if (arg->rxedRate >= 4) {
+		if (hdr->band == NL80211_BAND_5GHZ)
+			hdr->rate_idx = arg->rxedRate - 6;
+		else
+			hdr->rate_idx = arg->rxedRate - 2;
+	} else {
+		hdr->rate_idx = arg->rxedRate;
+	}
+
+#endif
+
+	hdr->signal = (s8)arg->rcpiRssi;
+	hdr->antenna = 0;
+
+	hdrlen = ieee80211_hdrlen(frame->frame_control);
+
+	if (WSM_RX_STATUS_ENCRYPTION(arg->flags)) {
+		size_t iv_len = 0, icv_len = 0;
+
+		hdr->flag |= RX_FLAG_DECRYPTED;
+
+		/* Oops... There is no fast way to ask mac80211 about
+		 * IV/ICV lengths. Even defineas are not exposed.*/
+		switch (WSM_RX_STATUS_ENCRYPTION(arg->flags)) {
+		case WSM_RX_STATUS_WEP:
+			iv_len = 4 /* WEP_IV_LEN */;
+			icv_len = 4 /* WEP_ICV_LEN */;
+			break;
+		case WSM_RX_STATUS_TKIP:
+			iv_len = 8 /* TKIP_IV_LEN */;
+			icv_len = 4 /* TKIP_ICV_LEN */
+				+ 8 /*MICHAEL_MIC_LEN*/;
+			break;
+		case WSM_RX_STATUS_AES:
+			iv_len = 8 /* CCMP_HDR_LEN */;
+			icv_len = 8 /* CCMP_MIC_LEN */;
+			break;
+		case WSM_RX_STATUS_WAPI:
+			iv_len = 18 /* WAPI_HDR_LEN */;
+			icv_len = 16 /* WAPI_MIC_LEN */;
+			hdr->flag |= RX_FLAG_IV_STRIPPED;
+			break;
+		default:
+			SYS_WARN("Unknown encryption type");
+			goto drop;
+		}
+
+		/* Firmware strips ICV in case of MIC failure. */
+		if (arg->status == WSM_STATUS_MICFAILURE) {
+			icv_len = 0;
+			hdr->flag |= RX_FLAG_IV_STRIPPED;
+		}
+
+		if (skb->len < hdrlen + iv_len + icv_len) {
+			txrx_printk(XRADIO_DBG_WARN, "Mailformed SDU rx'ed. "
+				"Size is lesser than crypto headers.\n");
+			goto drop;
+		}
+
+		if (WSM_RX_STATUS_ENCRYPTION(arg->flags) ==
+		    WSM_RX_STATUS_TKIP) {
+			/* Remove TKIP MIC 8 bytes*/
+			memmove(skb->data + skb->len-icv_len,
+				skb->data + skb->len-icv_len+8, 4);
+			skb_trim(skb, skb->len - 8);
+			hdr->flag |= RX_FLAG_MMIC_STRIPPED;
+		} else if (unlikely(WSM_RX_STATUS_ENCRYPTION(arg->flags) ==
+			   WSM_RX_STATUS_WAPI)) {
+			/* Protocols not defined in mac80211 should be
+			   stripped/crypted in driver/firmware */
+			/* Remove IV, ICV and MIC */
+			skb_trim(skb, skb->len - icv_len);
+			memmove(skb->data + iv_len, skb->data, hdrlen);
+			skb_pull(skb, iv_len);
+		}
+		parse_iv_len = iv_len;
+	}
+
+	xradio_debug_rxed(priv);
+	if (arg->flags & WSM_RX_STATUS_AGGREGATE)
+		xradio_debug_rxed_agg(priv);
+
+#if 0
+	/*for nettest*/
+	if (ieee80211_is_probe_resp(frame->frame_control) &&
+		!arg->status &&
+		!memcmp(ieee80211_get_SA(frame), nettest_bssid, ETH_ALEN)) {
+		const u8 *supp_rate_ie;
+		u8 *ies = ((struct ieee80211_mgmt *)
+			   (skb->data))->u.probe_resp.variable;
+		size_t ies_len = skb->len - (ies - (u8 *)(skb->data));
+
+		supp_rate_ie = xradio_get_ie(ies, ies_len, WLAN_EID_SUPP_RATES);
+		save_rate_ie = supp_rate_ie[2];
+		txrx_printk(XRADIO_DBG_WARN, "[netest]: save_rate_ie=%2x\n",
+			    save_rate_ie);
+	}
+
+	if (ieee80211_is_assoc_resp(frame->frame_control) &&
+		!arg->status &&
+		!memcmp(ieee80211_get_SA(frame), nettest_bssid, ETH_ALEN)) {
+		u8 *supp_rate_ie2;
+		size_t ies_len;
+		u8 *ies = ((struct ieee80211_mgmt *)
+			   (skb->data))->u.assoc_resp.variable;
+		ies_len = skb->len - (ies - (u8 *)(skb->data));
+		supp_rate_ie2 = xradio_get_ie(ies, ies_len, WLAN_EID_SUPP_RATES);
+
+		if ((supp_rate_ie2[1] == 1) && (supp_rate_ie2[2] == 0x80)) {
+			supp_rate_ie2[2] = save_rate_ie;
+			txrx_printk(XRADIO_DBG_WARN,
+				    "[netest]: rate_ie modified=%2x\n",
+				    supp_rate_ie2[2]);
+		}
+	}
+	/*for test*/
+#endif
+
+	if (ieee80211_is_beacon(frame->frame_control) &&
+		!arg->status &&
+		!memcmp(ieee80211_get_SA(frame), priv->join_bssid, ETH_ALEN)) {
+		const u8 *tim_ie;
+		u8 *ies;
+		size_t ies_len;
+		priv->disable_beacon_filter = false;
+		queue_work(hw_priv->workqueue, &priv->update_filtering_work);
+		ies = ((struct ieee80211_mgmt *)
+			  (skb->data))->u.beacon.variable;
+		ies_len = skb->len - (ies - (u8 *)(skb->data));
+
+		tim_ie = xradio_get_ie(ies, ies_len, WLAN_EID_TIM);
+		if (tim_ie) {
+			struct ieee80211_tim_ie *tim =
+				(struct ieee80211_tim_ie *)&tim_ie[2];
+
+			if (priv->join_dtim_period != tim->dtim_period) {
+				priv->join_dtim_period = tim->dtim_period;
+				queue_work(hw_priv->workqueue,
+					&priv->set_beacon_wakeup_period_work);
+			}
+		}
+		if (unlikely(priv->disable_beacon_filter)) {
+			priv->disable_beacon_filter = false;
+			queue_work(hw_priv->workqueue,
+				&priv->update_filtering_work);
+		}
+	}
+#ifdef AP_HT_CAP_UPDATE
+    if (priv->mode == NL80211_IFTYPE_AP           &&
+	ieee80211_is_beacon(frame->frame_control) &&
+	((priv->ht_info&HT_INFO_MASK) != 0x0011)  &&
+	!arg->status) {
+	u8 *ies;
+	size_t ies_len;
+	const u8 *ht_cap;
+	ies = ((struct ieee80211_mgmt *)(skb->data))->u.beacon.variable;
+	ies_len = skb->len - (ies - (u8 *)(skb->data));
+	ht_cap = xradio_get_ie(ies, ies_len, WLAN_EID_HT_CAPABILITY);
+	if (!ht_cap) {
+	    priv->ht_info |= 0x0011;
+	    queue_work(hw_priv->workqueue, &priv->ht_info_update_work);
+	}
+    }
+#endif
+
+#ifdef AP_HT_COMPAT_FIX
+	if (ieee80211_is_mgmt(frame->frame_control) &&
+		priv->if_id == 0 && !(priv->ht_compat_det & 0x10)) {
+		xradio_remove_ht_ie(priv, skb);
+	}
+#endif
+
+#ifdef ROAM_OFFLOAD
+	if ((ieee80211_is_beacon(frame->frame_control) ||
+		 ieee80211_is_probe_resp(frame->frame_control)) &&
+			!arg->status) {
+		if (hw_priv->auto_scanning &&
+			!atomic_read(&hw_priv->scan.in_progress))
+			hw_priv->frame_rcvd = 1;
+
+		if (!memcmp(ieee80211_get_SA(frame), priv->join_bssid, ETH_ALEN)) {
+			if (hw_priv->beacon)
+				dev_kfree_skb(hw_priv->beacon);
+			hw_priv->beacon = skb_copy(skb, GFP_ATOMIC);
+			if (!hw_priv->beacon)
+				txrx_printk(XRADIO_DBG_ERROR,
+					    "sched_scan: own beacon storing failed\n");
+		}
+	}
+#endif /*ROAM_OFFLOAD*/
+
+	/*scanResult.timestamp to adapt to Framework(WiFi) on Android5.0 or advanced version.*/
+	if ((ieee80211_is_beacon(mgmt->frame_control) ||
+		ieee80211_is_probe_resp(mgmt->frame_control))
+		&& !arg->status) {
+		struct timespec64 ts;
+		u64 tv_nsec;
+		xr_get_monotonic_boottime(&ts);
+		tv_nsec = ts.tv_nsec;
+		do_div(tv_nsec, 1000);
+		if (ieee80211_is_beacon(mgmt->frame_control)) {
+			mgmt->u.beacon.timestamp =
+				((u64)ts.tv_sec * 1000000 + tv_nsec);
+		} else if (ieee80211_is_probe_resp(mgmt->frame_control)) {
+			mgmt->u.probe_resp.timestamp =
+				((u64)ts.tv_sec * 1000000 + tv_nsec);
+		}
+	}
+
+	/* don't delay scan before next connect */
+	if (ieee80211_is_deauth(frame->frame_control) ||
+	    ieee80211_is_disassoc(frame->frame_control))
+		hw_priv->scan_delay_status[priv->if_id] = XRADIO_SCAN_ALLOW;
+
+	/* Stay awake for 1sec. after frame is received to give
+	 * userspace chance to react and acquire appropriate
+	 * wakelock. */
+	if (ieee80211_is_auth(frame->frame_control))
+		grace_period = 10 * HZ;
+	else if (ieee80211_is_deauth(frame->frame_control))
+		grace_period = 5 * HZ;
+#ifndef CONFIG_XRADIO_SUSPEND_POWER_OFF
+	else
+		grace_period = 0.2 * HZ;
+#endif
+
+	if (ieee80211_is_data(frame->frame_control))
+		xradio_rx_h_ba_stat(priv, hdrlen, skb->len);
+#ifdef CONFIG_PM
+	xradio_pm_stay_awake(&hw_priv->pm_state, grace_period);
+#endif
+#ifdef CONFIG_XRADIO_TESTMODE
+	if (hw_priv->test_frame.len > 0 &&
+		priv->mode == NL80211_IFTYPE_STATION) {
+		if (xradio_frame_test_detection(priv, frame, skb) == 1) {
+			consume_skb(skb);
+			*skb_p = NULL;
+			return;
+		}
+	}
+#endif /* CONFIG_XRADIO_TESTMODE */
+
+#ifdef AP_ARP_COMPAT_FIX
+	if (priv->join_status == XRADIO_JOIN_STATUS_STA) {
+		u16 fctl = frame->frame_control;
+		if (ieee80211_is_data(fctl)) {
+			u8 machdrlen = ieee80211_hdrlen(fctl);
+			u8 *llc_data = (u8 *)frame + machdrlen + parse_iv_len;
+			if (is_SNAP(llc_data) && is_arp(llc_data)) {
+				u8 *arp_hdr = llc_data + LLC_LEN;
+				u16 *arp_type = (u16 *)(arp_hdr + ARP_TYPE_OFFSET);
+				if (*arp_type == cpu_to_be16(ARP_RESPONSE)) {
+					priv->arp_compat_cnt = 0;
+				}
+			}
+		}
+	}
+#endif
+
+#ifdef CONFIG_XRADIO_DEBUGFS
+	/* parsse frame here for debug. */
+	if (rxparse_flags)
+		xradio_parse_frame(skb->data, parse_iv_len,
+				   rxparse_flags|PF_RX, priv->if_id);
+#endif
+
+	/* Some aps change channel to inform station by sending beacon with WLAN_EID_DS_PARAMS ie,
+	 *then station needs to reconnect to ap.
+	*/
+	if (ieee80211_is_beacon(frame->frame_control) &&
+		!arg->status &&
+		(priv->join_status == XRADIO_JOIN_STATUS_STA) &&
+		!memcmp(ieee80211_get_SA(frame), priv->join_bssid, ETH_ALEN)) {
+		const u8 *ds_ie;
+		u8 *ies;
+		size_t ies_len;
+		int ds_ie_partms_chan = 0;
+		ies = ((struct ieee80211_mgmt *)
+			  (skb->data))->u.beacon.variable;
+		ies_len = skb->len - (ies - (u8 *)(skb->data));
+
+		ds_ie = xradio_get_ie(ies, ies_len, WLAN_EID_DS_PARAMS);
+		if (ds_ie && (ds_ie[1] == 1)) {
+			ds_ie_partms_chan = ds_ie[2];
+			if (ds_ie_partms_chan != hw_priv->join_chan) {
+				txrx_printk(XRADIO_DBG_WARN, "***ap changes channel by beacon with ds ie, "
+					"then station reconnects to ap, %d -> %d\n",
+					hw_priv->join_chan, ds_ie_partms_chan);
+				wsm_send_disassoc_to_self(hw_priv, priv);
+			}
+		}
+	}
+
+#if PERF_INFO_TEST
+	upper_rx_size = skb->len;
+#endif
+	PERF_INFO_GETTIME(&upper_rx_time);
+	/* Try to  a packet for the case dev_alloc_skb failed in bh.*/
+	if (unlikely(xradio_itp_rxed(hw_priv, skb)))
+		consume_skb(skb);
+	else if (unlikely(early_data)) {
+		spin_lock_bh(&priv->ps_state_lock);
+		/* Double-check status with lock held */
+		if (entry->status == XRADIO_LINK_SOFT) {
+			skb_queue_tail(&entry->rx_queue, skb);
+			txrx_printk(XRADIO_DBG_WARN, "***skb_queue_tail\n");
+		} else
+			mac80211_rx_irqsafe(priv->hw, skb);
+		spin_unlock_bh(&priv->ps_state_lock);
+	} else {
+		mac80211_rx_irqsafe(priv->hw, skb);
+	}
+	*skb_p = NULL;
+	PERF_INFO_STAMP(&upper_rx_time, &mac_rx, upper_rx_size);
+
+	return;
+
+drop:
+	/* TODO: update failure counters */
+	return;
+}
+
+/* ******************************************************************** */
+/* Security								*/
+
+int xradio_alloc_key(struct xradio_common *hw_priv)
+{
+	int idx;
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	idx = ffs(~hw_priv->key_map) - 1;
+	if (idx < 0 || idx > WSM_KEY_MAX_INDEX)
+		return -1;
+
+	hw_priv->key_map |= BIT(idx);
+	hw_priv->keys[idx].entryIndex = idx;
+	txrx_printk(XRADIO_DBG_NIY, "%s, idx=%d\n", __func__, idx);
+	return idx;
+}
+
+void xradio_free_key(struct xradio_common *hw_priv, int idx)
+{
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	SYS_BUG(!(hw_priv->key_map & BIT(idx)));
+	memset(&hw_priv->keys[idx], 0, sizeof(hw_priv->keys[idx]));
+	hw_priv->key_map &= ~BIT(idx);
+	txrx_printk(XRADIO_DBG_NIY, "%s, idx=%d\n", __func__, idx);
+}
+
+void xradio_free_keys(struct xradio_common *hw_priv)
+{
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	memset(&hw_priv->keys, 0, sizeof(hw_priv->keys));
+	hw_priv->key_map = 0;
+}
+
+int xradio_upload_keys(struct xradio_vif *priv)
+{
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	int idx, ret = 0;
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	for (idx = 0; idx <= WSM_KEY_MAX_IDX; ++idx)
+		if (hw_priv->key_map & BIT(idx)) {
+			ret = wsm_add_key(hw_priv, &hw_priv->keys[idx], priv->if_id);
+			if (ret < 0)
+				break;
+		}
+	return ret;
+}
+
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+/* Workaround for WFD test case 6.1.10 */
+void xradio_link_id_reset(struct work_struct *work)
+{
+	struct xradio_vif *priv =
+		container_of(work, struct xradio_vif, linkid_reset_work);
+	struct xradio_common *hw_priv = priv->hw_priv;
+	int temp_linkid;
+	txrx_printk(XRADIO_DBG_TRC, "%s\n", __func__);
+
+	if (!priv->action_linkid) {
+		/* In GO mode we can receive ACTION frames without a linkID */
+		temp_linkid = xradio_alloc_link_id(priv,
+				&priv->action_frame_sa[0]);
+		SYS_WARN(!temp_linkid);
+		if (temp_linkid) {
+			/* Make sure we execute the WQ */
+			flush_workqueue(hw_priv->workqueue);
+			/* Release the link ID */
+			spin_lock_bh(&priv->ps_state_lock);
+			priv->link_id_db[temp_linkid - 1].prev_status =
+				priv->link_id_db[temp_linkid - 1].status;
+			priv->link_id_db[temp_linkid - 1].status =
+				XRADIO_LINK_RESET;
+			spin_unlock_bh(&priv->ps_state_lock);
+			wsm_lock_tx_async(hw_priv);
+			if (queue_work(hw_priv->workqueue,
+				       &priv->link_id_work) <= 0)
+				wsm_unlock_tx(hw_priv);
+		}
+	} else {
+		spin_lock_bh(&priv->ps_state_lock);
+		priv->link_id_db[priv->action_linkid - 1].prev_status =
+			priv->link_id_db[priv->action_linkid - 1].status;
+		priv->link_id_db[priv->action_linkid - 1].status =
+			XRADIO_LINK_RESET_REMAP;
+		spin_unlock_bh(&priv->ps_state_lock);
+		wsm_lock_tx_async(hw_priv);
+		if (queue_work(hw_priv->workqueue, &priv->link_id_work) <= 0)
+				wsm_unlock_tx(hw_priv);
+		flush_workqueue(hw_priv->workqueue);
+	}
+}
+#endif
diff -Naurp a/drivers/net/wireless/xr829/wlan/txrx.h b/drivers/net/wireless/xr829/wlan/txrx.h
--- a/drivers/net/wireless/xr829/wlan/txrx.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/txrx.h	2022-08-27 01:22:42.974539938 +0300
@@ -0,0 +1,218 @@
+/*
+ * tx/rx interfaces for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef XRADIO_TXRX_H
+#define XRADIO_TXRX_H
+
+#include <linux/list.h>
+#include "wsm.h"
+
+/* extern */ struct ieee80211_hw;
+/* extern */ struct sk_buff;
+/* extern */ struct xradio_txpriv;
+/* extern */ struct xradio_vif;
+
+#ifdef SUPPORT_HT40
+
+#ifdef CONFIG_XRADIO_DEBUGFS
+/*for tx rates debug.*/
+extern u8  rates_dbg_en;
+extern u16 rates_debug[6];
+extern u8  Ratecnt_dbg;
+extern u8  retry_dbg;
+#endif
+
+#else
+
+#ifdef CONFIG_XRADIO_DEBUGFS
+/*for tx rates debug.*/
+extern u8 rates_dbg_en;
+extern u32 rates_debug[3];
+extern u8 maxRate_dbg;
+extern u8 retry_dbg;
+#endif
+
+#endif
+
+#ifdef SUPPORT_HT40
+
+/* ModemType in RateEntry */
+#define MODEMTYPE_SHIFT     14
+#define MODEMTYPE_MASK      0x03
+#define RATE_MODEM_LEGACY   0x00
+#define RATE_MODEM_HTOFDM   0x01
+#define RATE_MODEM_VHTOFDM  0x02
+
+/* Bandwidth in RateEntry */
+#define BANDWIDTH_SHIFT     12
+#define BANDWIDTH_MASK      0x03
+#define RATE_BANDWIDTH_20M  0x00
+#define RATE_BANDWIDTH_40M  0x01
+#define RATE_BANDWIDTH_80M  0x02
+
+/* FormatFlag in RateEntry flags */
+#define RATE_F_MASK         0x0F00
+#define RATE_F_PREAMBLE_S   0x0100
+#define RATE_F_SGI          0x0200
+#define RATE_F_GF           0x0400
+#define RATE_F_STBC         0x0800
+
+#define MAKE_PREAMBLE_S(b)   ((!!(b))<<8)
+#define MAKE_SGI(b)          ((!!(b))<<9)
+#define MAKE_GF(b)           ((!!(b))<<10)
+#define MAKE_STBC(b)         ((!!(b))<<11)
+
+#define RATEINDEX_SHIFT     4
+#define RATEINDEX_MASK      0xf
+
+#define MCS_RATES_OFF  14
+#define MAX_RATES_IDX  21
+#define A_RATES_OFF    6
+#define B_RATE_INDEX   0
+#define AG_RATE_INDEX  A_RATES_OFF
+
+#define XRADIO_INVALID_RATE_ID     (0xFF)
+#define XRADIO_INVALID_RATE_ENTRY   0x00F0
+
+/* ModemType in RateEntry */
+#define FW_RATE_MODEM_SHIFT     14
+#define FW_RATE_MODEM_MASK      0xC000
+#define FW_RATE_MODEM_LEGACY    0x00
+#define FW_RATE_MODEM_HTOFDM    0x01
+#define FW_RATE_MODEM_VHTOFDM   0x02
+
+/* Bandwidth in RateEntry */
+#define FW_RATE_BW_SHIFT        12
+#define FW_RATE_BW_MASK         0x3000
+#define FW_RATE_BW_20M          0x00
+#define FW_RATE_BW_40M          0x01
+#define FW_RATE_BW_80M          0x02
+
+/* FormatFlag in RateEntry flags */
+#define FW_RATE_F_SHIFT         8
+#define FW_RATE_F_MASK          0x0F00
+#define FW_RATE_F_SPRE          0x1
+#define FW_RATE_F_SGI           0x2
+#define FW_RATE_F_GF            0x4
+#define FW_RATE_F_STBC          0x8
+
+/* RateIndex */
+#define FW_RATE_INDEX_SHIFT     4
+#define FW_RATE_INDEX_MASK      0x00F0
+#define FW_RATE_USE_DEFAULT     0xF
+
+/* MaxRetry */
+#define FW_RATE_MAXRETRY_SHIFT  0
+#define FW_RATE_MAXRETRY_MASK   0x000F
+
+#define GET_RATE_ENTRY_MODEM(_RateEntry)	(((_RateEntry)&FW_RATE_MODEM_MASK)>>FW_RATE_MODEM_SHIFT)
+#define GET_RATE_ENTRY_BANDWIDTH(_RateEntry)	(((_RateEntry)&FW_RATE_BW_MASK)>>FW_RATE_BW_SHIFT)
+#define GET_RATE_ENTRY_FLAGS(_RateEntry)	(((_RateEntry)&FW_RATE_F_MASK)>>FW_RATE_F_SHIFT)
+#define GET_RATE_ENTRY_RATEINDEX(_RateEntry)	(((_RateEntry)&FW_RATE_INDEX_MASK)>>FW_RATE_INDEX_SHIFT)
+#define GET_RATE_ENTRY_MAXRETRY(_RateEntry)	(((_RateEntry)&FW_RATE_MAXRETRY_MASK)>>FW_RATE_MAXRETRY_SHIFT)
+
+#define PUT_RATE_ENTRY_MODEM(_Value)		(((_Value)<<FW_RATE_MODEM_SHIFT)&FW_RATE_MODEM_MASK)
+#define PUT_RATE_ENTRY_BANDWIDTH(_Value)	(((_Value)<<FW_RATE_BW_SHIFT)&FW_RATE_BW_MASK)
+#define PUT_RATE_ENTRY_FLAGS(_Value)		(((_Value)<<FW_RATE_F_SHIFT)&FW_RATE_F_MASK)
+#define PUT_RATE_ENTRY_RATEINDEX(_Value)	(((_Value)<<FW_RATE_INDEX_SHIFT)&FW_RATE_INDEX_MASK)
+#define PUT_RATE_ENTRY_MAXRETRY(_Value)		(((_Value)<<FW_RATE_MAXRETRY_SHIFT)&FW_RATE_MAXRETRY_MASK)
+
+#endif
+struct tx_policy {
+	union {
+
+#ifdef SUPPORT_HT40
+
+		__le16 rate_entrys[MAX_RATES_STAGE];
+
+#else
+
+		__le32 tbl[3];
+
+#endif
+		u8 raw[12];
+	};
+	u8  defined;		/* TODO: u32 or u8, profile and select best */
+	u8  usage_count;	/* --// -- */
+	u8  retry_count;	/* --// -- */
+	u8  uploaded;
+};
+
+struct tx_policy_cache_entry {
+	struct tx_policy policy;
+	struct list_head link;
+};
+
+struct tx_policy_cache {
+	struct tx_policy_cache_entry cache[TX_POLICY_CACHE_SIZE];
+	struct list_head used;
+	struct list_head free;
+	spinlock_t lock;
+	bool   queue_locked;
+};
+
+/* ******************************************************************** */
+/* TX policy cache							*/
+/* Intention of TX policy cache is an overcomplicated WSM API.
+ * Device does not accept per-PDU tx retry sequence.
+ * It uses "tx retry policy id" instead, so driver code has to sync
+ * linux tx retry sequences with a retry policy table in the device.
+ */
+void tx_policy_init(struct xradio_common *hw_priv);
+void tx_policy_upload_work(struct work_struct *work);
+
+/* ******************************************************************** */
+/* TX implementation							*/
+
+u32 xradio_rate_mask_to_wsm(struct xradio_common *hw_priv,
+			       u32 rates);
+void xradio_tx(struct ieee80211_hw *dev, struct sk_buff *skb);
+void xradio_skb_dtor(struct xradio_common *hw_priv,
+		     struct sk_buff *skb,
+		     const struct xradio_txpriv *txpriv);
+
+/* ******************************************************************** */
+
+#ifdef SUPPORT_HT40
+
+/* Convert hw_value to rate entry */
+u16 xradio_get_rate_entry(const struct xradio_common *hw_priv,
+			u8 Bandwidth, u16 FormatFlag, u8 hw_value);
+
+#endif
+
+/* WSM callbacks							*/
+
+void xradio_tx_confirm_cb(struct xradio_common *hw_priv,
+			  struct wsm_tx_confirm *arg);
+void xradio_rx_cb(struct xradio_vif *priv,
+		  struct wsm_rx *arg,
+		  struct sk_buff **skb_p);
+
+/* ******************************************************************** */
+/* Timeout								*/
+
+void xradio_tx_timeout(struct work_struct *work);
+
+/* ******************************************************************** */
+/* Security								*/
+int xradio_alloc_key(struct xradio_common *hw_priv);
+void xradio_free_key(struct xradio_common *hw_priv, int idx);
+void xradio_free_keys(struct xradio_common *hw_priv);
+int xradio_upload_keys(struct xradio_vif *priv);
+
+/* ******************************************************************** */
+/* Workaround for WFD test case 6.1.10					*/
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+void xradio_link_id_reset(struct work_struct *work);
+#endif
+
+#endif /* XRADIO_TXRX_H */
diff -Naurp a/drivers/net/wireless/xr829/wlan/vendor.c b/drivers/net/wireless/xr829/wlan/vendor.c
--- a/drivers/net/wireless/xr829/wlan/vendor.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/vendor.c	2022-08-27 01:22:42.974539938 +0300
@@ -0,0 +1,633 @@
+/*
+ * Main code of XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*Linux version 3.4.0 compilation*/
+#include <net/genetlink.h>
+#include <net/cfg80211.h>
+#include <linux/list.h>
+#include <linux/list_sort.h>
+#include <linux/timer.h>
+#include <linux/time64.h>
+
+#include "vendor.h"
+#include "../umac/ieee80211_i.h"
+#include "xradio.h"
+
+
+static int xradio_vendor_do_acs(struct wiphy *wiphy,
+				 struct wireless_dev *wdev,
+				 const void *data, int data_len);
+
+static int xradio_vendor_get_features(struct wiphy *wiphy,
+				 struct wireless_dev *wdev,
+				 const void *data, int data_len);
+
+static int xradio_vendor_start_mkeep_alive(struct wiphy *wiphy,
+				 struct wireless_dev *wdev,
+				 const void *data, int data_len);
+
+static int xradio_vendor_stop_mkeep_alive(struct wiphy *wiphy,
+				 struct wireless_dev *wdev,
+				 const void *data, int data_len);
+
+static int xradio_dump_interface(struct wiphy *wiphy,
+				struct wireless_dev *wdev, struct sk_buff *skb,
+				const void *data, int data_len,
+				unsigned long *storage);
+
+static const struct nla_policy
+xradio_cfg80211_do_acs_policy[WLAN_VENDOR_ATTR_ACS_MAX+1] = {
+	[WLAN_VENDOR_ATTR_ACS_HW_MODE] = { .type = NLA_U8 },
+	[WLAN_VENDOR_ATTR_ACS_HT_ENABLED] = { .type = NLA_FLAG },
+	[WLAN_VENDOR_ATTR_ACS_HT40_ENABLED] = { .type = NLA_FLAG },
+	[WLAN_VENDOR_ATTR_ACS_VHT_ENABLED] = { .type = NLA_FLAG },
+	[WLAN_VENDOR_ATTR_ACS_CHWIDTH] = { .type = NLA_U16 },
+	[WLAN_VENDOR_ATTR_ACS_CH_LIST] = { .type = NLA_UNSPEC },
+	[WLAN_VENDOR_ATTR_ACS_FREQ_LIST] = { .type = NLA_UNSPEC },
+};
+
+static const struct nla_policy
+xradio_cfg80211_mkeep_alive_policy[MKEEP_ALIVE_ATTRIBUTE_MAX+1] = {
+	[0] = {.type = NLA_UNSPEC },
+	[MKEEP_ALIVE_ATTRIBUTE_ID]		= { .type = NLA_U8 },
+	[MKEEP_ALIVE_ATTRIBUTE_IP_PKT]		= { .type = NLA_MSECS },
+	[MKEEP_ALIVE_ATTRIBUTE_IP_PKT_LEN]	= { .type = NLA_U16 },
+	[MKEEP_ALIVE_ATTRIBUTE_SRC_MAC_ADDR]	= { .type = NLA_MSECS,
+						    .len  = ETH_ALEN },
+	[MKEEP_ALIVE_ATTRIBUTE_DST_MAC_ADDR]	= { .type = NLA_MSECS,
+						    .len  = ETH_ALEN },
+	[MKEEP_ALIVE_ATTRIBUTE_PERIOD_MSEC]	= { .type = NLA_U32 },
+};
+
+static const struct wiphy_vendor_command xradio_nl80211_vendor_commands[] = {
+	[NL80211_VENDOR_SUBCMD_DO_ACS_INDEX] = {
+		.info.vendor_id = XRADIO_NL80211_VENDOR_ID,
+		.info.subcmd = NL80211_VENDOR_SUBCMD_DO_ACS,
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = xradio_vendor_do_acs,
+		.dumpit = xradio_dump_interface,
+		.policy = xradio_cfg80211_do_acs_policy
+	},
+	[NL80211_VENDOR_SUBCMD_GET_FEATURES_INDEX] = {
+		.info.vendor_id = XRADIO_NL80211_VENDOR_ID,
+		.info.subcmd = NL80211_VENDOR_SUBCMD_GET_FEATURES,
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = xradio_vendor_get_features,
+		.dumpit = xradio_dump_interface,
+		.policy = VENDOR_CMD_RAW_DATA
+	},
+	[NL80211_WIFI_OFFLOAD_SUBCMD_START_MKEEP_ALIVE_INDEX] = {
+		.info.vendor_id = XRADIO_NL80211_ANDROID_ID,
+		.info.subcmd = NL80211_WIFI_OFFLOAD_SUBCMD_START_MKEEP_ALIVE,
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = xradio_vendor_start_mkeep_alive,
+		.dumpit = xradio_dump_interface,
+		.policy = xradio_cfg80211_mkeep_alive_policy,
+		.maxattr = MKEEP_ALIVE_ATTRIBUTE_MAX
+	},
+	[NL80211_WIFI_OFFLOAD_SUBCMD_STOP_MKEEP_ALIVE_INDEX] = {
+		.info.vendor_id = XRADIO_NL80211_ANDROID_ID,
+		.info.subcmd = NL80211_WIFI_OFFLOAD_SUBCMD_STOP_MKEEP_ALIVE,
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = xradio_vendor_stop_mkeep_alive,
+		.dumpit = xradio_dump_interface,
+		.policy = xradio_cfg80211_mkeep_alive_policy,
+		.maxattr = MKEEP_ALIVE_ATTRIBUTE_MAX
+	},
+};
+
+/* vendor specific events */
+static const struct nl80211_vendor_cmd_info xradio_nl80211_vendor_events[] = {
+	[NL80211_VENDOR_SUBCMD_DO_ACS_INDEX] = {
+			.vendor_id = XRADIO_NL80211_VENDOR_ID,
+			.subcmd = NL80211_VENDOR_SUBCMD_DO_ACS
+	},
+};
+
+static unsigned int xradio_acs_calc_channel(struct wiphy *wiphy)
+{
+	/*TODO: Find a better ACS algorithm*/
+	return 5;
+}
+
+
+static void xradio_acs_report_channel(struct wiphy *wiphy, struct wireless_dev *wdev)
+{
+
+	struct sk_buff *vendor_event;
+	int ret_val;
+	struct nlattr *nla;
+	u8 channel = xradio_acs_calc_channel(wiphy);
+
+	vendor_event = cfg80211_vendor_event_alloc(wiphy, NULL,
+						   2 + 4 + NLMSG_HDRLEN,
+						   NL80211_VENDOR_SUBCMD_DO_ACS_INDEX,
+						   GFP_KERNEL);
+	if (!vendor_event) {
+		printk("cfg80211_vendor_event_alloc failed\n");
+		return;
+	}
+
+	/* Send the IF INDEX to differentiate the ACS event for each interface
+	 * TODO: To be update once cfg80211 APIs are updated to accept if_index
+	 */
+	nla_nest_cancel(vendor_event, ((void **)vendor_event->cb)[2]);
+
+	ret_val = nla_put_u32(vendor_event, NL80211_ATTR_IFINDEX,
+				  wdev->netdev->ifindex);
+	if (ret_val) {
+		printk("NL80211_ATTR_IFINDEX put fail\n");
+		kfree_skb(vendor_event);
+		return;
+	}
+
+	nla = nla_nest_start(vendor_event, NL80211_ATTR_VENDOR_DATA);
+	((void **)vendor_event->cb)[2] = nla;
+
+	/* channel indices used by fw are zero based and those used upper
+	 * layers are 1 based: must add 1
+	 */
+	ret_val = nla_put_u8(vendor_event,
+				 WLAN_VENDOR_ATTR_ACS_PRIMARY_CHANNEL,
+				 channel + 1);
+	if (ret_val) {
+		printk(
+			"WLAN_VENDOR_ATTR_ACS_PRIMARY_CHANNEL put fail\n");
+		kfree_skb(vendor_event);
+		return;
+	}
+
+	/* must report secondary channel always, 0 is harmless */
+	ret_val = nla_put_u8(vendor_event,
+				 WLAN_VENDOR_ATTR_ACS_SECONDARY_CHANNEL, 0);
+	if (ret_val) {
+		printk(
+			"WLAN_VENDOR_ATTR_ACS_SECONDARY_CHANNEL put fail\n");
+		kfree_skb(vendor_event);
+		return;
+	}
+
+	cfg80211_vendor_event(vendor_event, GFP_KERNEL);
+
+}
+
+static int xradio_vendor_do_acs(struct wiphy *wiphy,
+				 struct wireless_dev *wdev,
+				 const void *data, int data_len)
+{
+	struct sk_buff *temp_skbuff;
+	int res = 0;
+	//u8 hw_mode;
+	struct nlattr *tb[WLAN_VENDOR_ATTR_ACS_MAX + 1];
+	//struct ieee80211_channel reg_channels[ARRAY_SIZE(xradio_2ghz_chantable)];
+	//int num_channels;
+
+
+	res = nla_parse(tb, WLAN_VENDOR_ATTR_ACS_MAX, data, data_len,
+						xradio_cfg80211_do_acs_policy, NULL);
+	if (res) {
+		printk("Invalid ATTR");
+		goto out;
+	}
+
+/*
+	if (!tb[WLAN_VENDOR_ATTR_ACS_HW_MODE]) {
+		printk("%s: Attr hw_mode failed\n", __func__);
+		goto out;
+	}
+
+	hw_mode = nla_get_u8(tb[WLAN_VENDOR_ATTR_ACS_HW_MODE]);
+*/
+
+
+	if (tb[WLAN_VENDOR_ATTR_ACS_CH_LIST]) {
+
+	} else if (tb[WLAN_VENDOR_ATTR_ACS_FREQ_LIST]) {
+
+	} else {
+		res = -EINVAL;
+		goto out;
+	}
+
+
+	xradio_acs_report_channel(wiphy, wdev);
+
+
+out:
+	if (0 == res) {
+		temp_skbuff = cfg80211_vendor_cmd_alloc_reply_skb(wiphy,
+								  NLMSG_HDRLEN);
+		if (temp_skbuff)
+			return cfg80211_vendor_cmd_reply(temp_skbuff);
+	}
+
+	return res;
+}
+
+#define NUM_BITS_IN_BYTE	8
+void xradio_vendor_set_features(uint8_t *feature_flags, uint8_t feature)
+{
+	uint32_t index;
+	uint8_t bit_mask;
+
+	index = feature / NUM_BITS_IN_BYTE;
+	bit_mask = 1 << (feature % NUM_BITS_IN_BYTE);
+	feature_flags[index] |= bit_mask;
+}
+
+static int xradio_vendor_get_features(struct wiphy *wiphy,
+				 struct wireless_dev *wdev,
+				 const void *data, int data_len)
+{
+	struct sk_buff *msg;
+	uint8_t feature_flags[(NUM_WLAN_VENDOR_FEATURES + 7) / 8] = {0};
+
+	xradio_vendor_set_features(feature_flags,
+					WLAN_VENDOR_FEATURE_SUPPORT_HW_MODE_ANY);
+
+	msg = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, sizeof(feature_flags) +
+									NLMSG_HDRLEN);
+	if (!msg)
+		return -ENOMEM;
+
+	if (nla_put(msg,
+		WLAN_VENDOR_ATTR_FEATURE_FLAGS,
+		sizeof(feature_flags), feature_flags))
+		goto nla_put_failure;
+
+	return cfg80211_vendor_cmd_reply(msg);
+
+nla_put_failure:
+	kfree_skb(msg);
+	return -EINVAL;
+
+}
+
+struct keepalivenode {
+	struct list_head list;
+	u8 *pkt;
+	u16 pkt_len;
+	u8 id;
+	u32 period_msec;
+	unsigned long next_jiffies;
+	struct net_device *netdev;
+};
+
+static struct list_head keepalivelist;
+
+struct keepalive_timer {
+struct ieee80211_local *local;
+	struct timer_list kalive_timer;
+};
+
+struct keepalive_timer *keepalivetimer;
+
+static void keep_alive_send(struct ieee80211_local *local, struct net_device *dev, u8 *frame_8023,
+						u16 pkt_len)
+{
+	struct sk_buff *skb;
+	skb = dev_alloc_skb(local->hw.extra_tx_headroom + pkt_len);
+	if (!skb)
+		return;
+
+	skb_reserve(skb, local->hw.extra_tx_headroom);
+
+	skb_put(skb, pkt_len);
+	memcpy(skb->data, frame_8023, pkt_len);
+
+	mac80211_subif_start_xmit(skb, dev);
+
+}
+
+
+static int
+keep_alive_cmp(void *priv,
+	const struct list_head *a, const struct list_head *b)
+{
+	struct keepalivenode *ap = container_of(a, struct keepalivenode, list);
+	struct keepalivenode *bp = container_of(b, struct keepalivenode, list);
+	long diff;
+
+	diff = ap->next_jiffies - bp->next_jiffies;
+
+	if (diff < 0)
+		return -1;
+	if (diff > 0)
+		return 1;
+	return 0;
+}
+
+static void keep_alive_run(struct timer_list *t)
+{
+	struct keepalivenode *node;
+	struct keepalive_timer *k_timer = from_timer(k_timer, t, kalive_timer);
+	struct ieee80211_local *local = k_timer->local;
+
+	if (list_empty(&keepalivelist))
+		return;
+
+	list_for_each_entry(node, &keepalivelist, list) {
+		if (time_before(jiffies, node->next_jiffies))
+			break;
+		keep_alive_send(local, node->netdev, node->pkt, node->pkt_len);
+		node->next_jiffies += msecs_to_jiffies(node->period_msec);
+	}
+	list_sort(NULL, &keepalivelist, keep_alive_cmp);
+
+	//reset timer;
+	node = container_of(keepalivelist.next, struct keepalivenode, list);
+	mod_timer(&keepalivetimer->kalive_timer, node->next_jiffies);
+}
+
+static void keep_alive_queue_clear(void)
+{
+	struct keepalivenode *node;
+	struct keepalivenode *tmp;
+
+	if (list_empty(&keepalivelist))
+		return;
+
+	list_for_each_entry_safe(node, tmp, &keepalivelist, list) {
+		if (node->pkt != NULL) {
+			kfree(node->pkt);
+			node->pkt = NULL;
+		}
+		list_del(&node->list);
+		kfree(node);
+	}
+
+	//delete timer
+	del_timer(&keepalivetimer->kalive_timer);
+
+	kfree(keepalivetimer);
+}
+
+static int keep_alive_queue_put(u8 *dst_mac, u8 *src_mac, struct net_device *netdev,
+				u8 *ip_pkt, u16 ip_pkt_len, u32 period_msec, u8 mkeep_alive_id)
+{
+	u8 *frame_8023;
+	int len = 0;
+	int ret = 0;
+	struct keepalivenode *node;
+
+	frame_8023 = kzalloc(ip_pkt_len + 14, GFP_KERNEL);
+	if (frame_8023 == NULL) {
+		ret = -ENOMEM;
+		printk("Failed to allocate mem for frame_8023\n");
+		return ret;
+	}
+
+	node = (struct keepalivenode *)kzalloc(sizeof(struct keepalivenode), GFP_KERNEL);
+	if (node == NULL) {
+		kfree(frame_8023);
+		ret = -ENOMEM;
+		printk("Failed to allocate mem for keepalivenode\n");
+		return ret;
+	}
+
+	/*
+	 * This is the IP packet, add 14 bytes Ethernet (802.3) header
+	 * ------------------------------------------------------------
+	 * | 14 bytes Ethernet (802.3) header | IP header and payload |
+	 * ------------------------------------------------------------
+	 */
+
+	/* Mapping dest mac addr */
+	memcpy(&frame_8023[len], dst_mac, ETH_ALEN);
+	len += ETH_ALEN;
+
+	/* Mapping src mac addr */
+	memcpy(&frame_8023[len], src_mac, ETH_ALEN);
+	len += ETH_ALEN;
+
+	/* Mapping Ethernet type (ETHERTYPE_IP: 0x0800) */
+	frame_8023[len] = 0x08;
+	frame_8023[len+1] = 0x00;
+	len += 2;
+
+	/* Mapping IP pkt */
+	memcpy(&frame_8023[len], ip_pkt, ip_pkt_len);
+	len += ip_pkt_len;
+
+	node->pkt = frame_8023;
+	node->pkt_len = len;
+	node->period_msec = period_msec;
+	node->id = mkeep_alive_id;
+	node->next_jiffies = jiffies;
+	node->netdev = netdev;
+
+	list_add(&node->list, &keepalivelist);
+
+	//run timer;
+	mod_timer(&keepalivetimer->kalive_timer, jiffies);
+
+	return ret;
+
+}
+
+static void keep_alive_queue_remove(u8 mkeep_alive_id)
+{
+	struct keepalivenode *node;
+	struct keepalivenode *tmp;
+
+	list_for_each_entry_safe(node, tmp, &keepalivelist, list) {
+		if (node->id == mkeep_alive_id) {
+			if (node->pkt != NULL) {
+				kfree(node->pkt);
+				node->pkt = NULL;
+			}
+			list_del(&node->list);
+			kfree(node);
+		}
+	}
+	if (list_empty(&keepalivelist)) {
+		//delete timer;
+		del_timer(&keepalivetimer->kalive_timer);
+	}
+}
+
+static int xradio_vendor_start_mkeep_alive(struct wiphy *wiphy,
+				 struct wireless_dev *wdev,
+				 const void *data, int data_len)
+{
+	/* max size of IP packet for keep alive */
+	const int MKEEP_ALIVE_IP_PKT_MAX = 256;
+
+	int ret = 0, rem, type;
+	u8 mkeep_alive_id = 0;
+	u8 *ip_pkt = NULL;
+	u16 ip_pkt_len = 0;
+	u8 src_mac[ETH_ALEN];
+	u8 dst_mac[ETH_ALEN];
+	u32 period_msec = 0;
+	const struct nlattr *iter;
+	struct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);
+	struct xradio_vif *priv = xrwl_get_vif_from_ieee80211(&sdata->vif);
+
+	nla_for_each_attr(iter, data, data_len, rem) {
+		type = nla_type(iter);
+		switch (type) {
+		case MKEEP_ALIVE_ATTRIBUTE_ID:
+			mkeep_alive_id = nla_get_u8(iter);
+			break;
+		case MKEEP_ALIVE_ATTRIBUTE_IP_PKT_LEN:
+			ip_pkt_len = nla_get_u16(iter);
+			if (ip_pkt_len > MKEEP_ALIVE_IP_PKT_MAX) {
+				ret = -EINVAL;
+				goto exit;
+			}
+			break;
+		case MKEEP_ALIVE_ATTRIBUTE_IP_PKT:
+			if (!ip_pkt_len) {
+				ret = -EINVAL;
+				printk("ip packet length is 0\n");
+				goto exit;
+			}
+			ip_pkt = (u8 *)kzalloc(ip_pkt_len, GFP_KERNEL);
+			if (ip_pkt == NULL) {
+				ret = -ENOMEM;
+				printk("Failed to allocate mem for ip packet\n");
+				goto exit;
+			}
+			memcpy(ip_pkt, (u8 *)nla_data(iter), ip_pkt_len);
+			break;
+		case MKEEP_ALIVE_ATTRIBUTE_SRC_MAC_ADDR:
+			memcpy(src_mac, nla_data(iter), ETH_ALEN);
+			break;
+		case MKEEP_ALIVE_ATTRIBUTE_DST_MAC_ADDR:
+			memcpy(dst_mac, nla_data(iter), ETH_ALEN);
+			break;
+		case MKEEP_ALIVE_ATTRIBUTE_PERIOD_MSEC:
+			period_msec = nla_get_u32(iter);
+			break;
+		default:
+			printk("Unknown type: %d\n", type);
+			ret = -EINVAL;
+			goto exit;
+		}
+	}
+
+	if (ip_pkt == NULL) {
+		ret = -EINVAL;
+		printk(("ip packet is NULL\n"));
+		goto exit;
+	}
+
+	if (priv->join_status == XRADIO_JOIN_STATUS_PASSIVE) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	ret = keep_alive_queue_put(dst_mac, src_mac, wdev->netdev,
+			ip_pkt, ip_pkt_len, period_msec, mkeep_alive_id);
+	if (ret) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+exit:
+	if (ip_pkt) {
+		kfree(ip_pkt);
+	}
+
+	return ret;
+}
+
+static int xradio_vendor_stop_mkeep_alive(struct wiphy *wiphy,
+				 struct wireless_dev *wdev,
+				 const void *data, int data_len)
+{
+	int ret = 0, rem, type;
+	u8 mkeep_alive_id = 0;
+	const struct nlattr *iter;
+
+	nla_for_each_attr(iter, data, data_len, rem) {
+		type = nla_type(iter);
+		switch (type) {
+		case MKEEP_ALIVE_ATTRIBUTE_ID:
+			mkeep_alive_id = nla_get_u8(iter);
+			break;
+		default:
+			printk("Unknown type: %d\n", type);
+			ret = -EINVAL;
+			break;
+		}
+	}
+	if (ret < 0) {
+		printk("stop_mkeep_alive is failed ret: %d\n", ret);
+		goto exit;
+	}
+
+	keep_alive_queue_remove(mkeep_alive_id);
+
+exit:
+	return ret;
+
+}
+
+static int xradio_dump_interface(struct wiphy *wiphy,
+				struct wireless_dev *wdev, struct sk_buff *skb,
+				const void *data, int data_len,
+				unsigned long *storage)
+{
+	return 0;
+}
+
+void xradio_vendor_close_mkeep_alive(void)
+{
+	keep_alive_queue_clear();
+}
+
+void xradio_vendor_init(struct wiphy *wiphy)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+	/*int i = 0;
+	int *llocal = &i;*/
+
+	keepalivetimer = kmalloc(sizeof(struct keepalive_timer), GFP_KERNEL);
+	if (!keepalivetimer) {
+		printk(KERN_ERR "%s:init keepalivetimer error!\n", __func__);
+		return;
+	}
+
+	wiphy->n_vendor_commands = ARRAY_SIZE(xradio_nl80211_vendor_commands);
+	wiphy->vendor_commands = xradio_nl80211_vendor_commands;
+	wiphy->n_vendor_events = ARRAY_SIZE(xradio_nl80211_vendor_events);
+	wiphy->vendor_events = xradio_nl80211_vendor_events;
+
+	INIT_LIST_HEAD(&keepalivelist);
+	timer_setup(&keepalivetimer->kalive_timer, keep_alive_run, 0);
+	keepalivetimer->local = local;
+
+	return;
+}
+
+void xr_do_gettimeofday(struct timeval *tv)
+{
+	struct timespec64 now;
+
+	getnstimeofday64(&now);
+	tv->tv_sec = now.tv_sec;
+	tv->tv_usec = now.tv_nsec/1000;
+}
+
+void xr_get_monotonic_boottime(struct timespec64 *ts)
+{
+	*ts = ktime_to_timespec64(ktime_get_boottime());
+}
+
+
+
+
diff -Naurp a/drivers/net/wireless/xr829/wlan/vendor.h b/drivers/net/wireless/xr829/wlan/vendor.h
--- a/drivers/net/wireless/xr829/wlan/vendor.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/vendor.h	2022-08-27 01:22:42.974539938 +0300
@@ -0,0 +1,90 @@
+/*
+ * Common define of private data for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef VENDOR_H
+#define VENDOR_H
+
+#define XRADIO_NL80211_VENDOR_ID	0x001374
+#define XRADIO_NL80211_ANDROID_ID	0x001A11
+
+enum nl80211_vendor_subcmds {
+	NL80211_VENDOR_SUBCMD_DO_ACS = 54,
+	NL80211_VENDOR_SUBCMD_GET_FEATURES = 55,
+};
+
+enum wlan_vendor_features {
+	WLAN_VENDOR_FEATURE_KEY_MGMT_OFFLOAD	= 0,
+	WLAN_VENDOR_FEATURE_SUPPORT_HW_MODE_ANY     = 1,
+	WLAN_VENDOR_FEATURE_OFFCHANNEL_SIMULTANEOUS = 2,
+	WLAN_VENDOR_FEATURE_P2P_LISTEN_OFFLOAD	= 3,
+	WLAN_VENDOR_FEATURE_OCE_STA                 = 4,
+	WLAN_VENDOR_FEATURE_OCE_AP                  = 5,
+	WLAN_VENDOR_FEATURE_OCE_STA_CFON            = 6,
+	WLAN_VENDOR_FEATURE_SELF_MANAGED_REGULATORY = 7,
+	WLAN_VENDOR_FEATURE_TWT 			= 8,
+	NUM_WLAN_VENDOR_FEATURES /* keep last */
+};
+
+enum wlan_vendor_attr_acs_offload {
+	WLAN_VENDOR_ATTR_ACS_CHANNEL_INVALID = 0,
+	WLAN_VENDOR_ATTR_ACS_PRIMARY_CHANNEL,
+	WLAN_VENDOR_ATTR_ACS_SECONDARY_CHANNEL,
+	WLAN_VENDOR_ATTR_ACS_HW_MODE,
+	WLAN_VENDOR_ATTR_ACS_HT_ENABLED,
+	WLAN_VENDOR_ATTR_ACS_HT40_ENABLED,
+	WLAN_VENDOR_ATTR_ACS_VHT_ENABLED,
+	WLAN_VENDOR_ATTR_ACS_CHWIDTH,
+	WLAN_VENDOR_ATTR_ACS_CH_LIST,
+	WLAN_VENDOR_ATTR_ACS_VHT_SEG0_CENTER_CHANNEL,
+	WLAN_VENDOR_ATTR_ACS_VHT_SEG1_CENTER_CHANNEL,
+	WLAN_VENDOR_ATTR_ACS_FREQ_LIST,
+	/* keep last */
+	WLAN_VENDOR_ATTR_ACS_AFTER_LAST,
+	WLAN_VENDOR_ATTR_ACS_MAX =
+	WLAN_VENDOR_ATTR_ACS_AFTER_LAST - 1
+
+};
+
+enum wlan_vendor_attr {
+	/* used by NL80211_VENDOR_SUBCMD_GET_FEATURES */
+	WLAN_VENDOR_ATTR_FEATURE_FLAGS = 7,
+};
+
+enum nl80211_android_vendor_subcmds {
+	NL80211_WIFI_OFFLOAD_SUBCMD_START_MKEEP_ALIVE = 0x1600,
+	NL80211_WIFI_OFFLOAD_SUBCMD_STOP_MKEEP_ALIVE,
+};
+
+enum mkeep_alive_attributes {
+	MKEEP_ALIVE_ATTRIBUTE_ID = 0x1,
+	MKEEP_ALIVE_ATTRIBUTE_IP_PKT,
+	MKEEP_ALIVE_ATTRIBUTE_IP_PKT_LEN,
+	MKEEP_ALIVE_ATTRIBUTE_SRC_MAC_ADDR,
+	MKEEP_ALIVE_ATTRIBUTE_DST_MAC_ADDR,
+	MKEEP_ALIVE_ATTRIBUTE_PERIOD_MSEC,
+
+	MKEEP_ALIVE_ATTRIBUTE_AFTER_LAST,
+	MKEEP_ALIVE_ATTRIBUTE_MAX =
+	MKEEP_ALIVE_ATTRIBUTE_AFTER_LAST - 1
+};
+
+
+enum nl80211_vendor_subcmds_index {
+	NL80211_VENDOR_SUBCMD_DO_ACS_INDEX,
+	NL80211_VENDOR_SUBCMD_GET_FEATURES_INDEX,
+	NL80211_WIFI_OFFLOAD_SUBCMD_START_MKEEP_ALIVE_INDEX,
+	NL80211_WIFI_OFFLOAD_SUBCMD_STOP_MKEEP_ALIVE_INDEX,
+};
+
+void xradio_vendor_close_mkeep_alive(void);
+
+void xradio_vendor_init(struct wiphy *wiphy);
+
+#endif
diff -Naurp a/drivers/net/wireless/xr829/wlan/wlan_init.c b/drivers/net/wireless/xr829/wlan/wlan_init.c
--- a/drivers/net/wireless/xr829/wlan/wlan_init.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/wlan_init.c	2022-08-27 01:22:42.974539938 +0300
@@ -0,0 +1,97 @@
+/*
+ * Entry code of XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/moduleparam.h>
+
+MODULE_AUTHOR("XRadioTech");
+MODULE_DESCRIPTION("XRadioTech WLAN driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("xradio_wlan");
+
+/* external interfaces */
+extern int  xradio_core_init(void);
+extern void xradio_core_deinit(void);
+
+extern int  __init ieee80211_init(void);
+extern void ieee80211_exit(void);
+extern int  __init xradio_core_entry(void);
+extern void xradio_core_exit(void);
+
+#ifdef CONFIG_XRADIO_ETF
+void xradio_etf_to_wlan(u32 change);
+#endif
+
+static int etf_enable = -1;
+module_param(etf_enable, int, S_IRUSR);
+
+/* Init Module function -> Called by insmod */
+static int __init xradio_init(void)
+{
+	int ret = 0;
+	printk(KERN_ERR "======== XRADIO WIFI OPEN ========\n");
+	ret = ieee80211_init();
+	if (ret) {
+		printk(KERN_ERR "ieee80211_init failed (%d)!\n", ret);
+		goto ieee80211_fail;
+	}
+
+	ret = xradio_core_entry();
+	if (ret) {
+		printk(KERN_ERR "xradio_core_entry failed (%d)!\n", ret);
+		goto core_entry_fail;
+	}
+
+	if (etf_enable == 1)
+		goto ieee80211_fail;
+
+#ifdef CONFIG_XRADIO_ETF
+	xradio_etf_to_wlan(1);
+#endif
+	ret = xradio_core_init();  /* wlan driver init */
+	if (ret) {
+		printk(KERN_ERR "xradio_core_init failed (%d)!\n", ret);
+#ifdef CONFIG_XRADIO_ETF
+		xradio_etf_to_wlan(0);
+#endif
+		goto core_init_fail;
+	}
+	return ret;
+
+core_init_fail:
+	xradio_core_exit();
+core_entry_fail:
+	ieee80211_exit();
+ieee80211_fail:
+	return ret;
+}
+
+/* Called at Driver Unloading */
+static void __exit xradio_exit(void)
+{
+	if (etf_enable == 1)
+		goto exit_end;
+
+	xradio_core_deinit();
+#ifdef CONFIG_XRADIO_ETF
+	xradio_etf_to_wlan(0);
+#endif
+exit_end:
+	xradio_core_exit();
+	ieee80211_exit();
+	printk(KERN_ERR "======== XRADIO WIFI CLOSE ========\n");
+}
+
+module_init(xradio_init);
+module_exit(xradio_exit);
diff -Naurp a/drivers/net/wireless/xr829/wlan/wsm.c b/drivers/net/wireless/xr829/wlan/wsm.c
--- a/drivers/net/wireless/xr829/wlan/wsm.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/wsm.c	2022-08-27 01:22:42.974539938 +0300
@@ -0,0 +1,3796 @@
+/*
+ * WSM host interfaces for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/skbuff.h>
+#include <linux/wait.h>
+#include <linux/skbuff.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/random.h>
+
+#include "xradio.h"
+#include "wsm.h"
+#include "bh.h"
+#include "sbus.h"
+#include "itp.h"
+#ifdef ROAM_OFFLOAD
+#include "sta.h"
+#endif /*ROAM_OFFLOAD*/
+
+#ifdef SUPPORT_FW_DBG_INF
+#include "fw_dbg_inf.h"
+#endif /*SUPPORT_FW_DBG_INF*/
+
+
+/* With respect to interrupt loss, timeout in FW is 2s in some cases. */
+#define WSM_CMD_TIMEOUT		(3 * HZ)
+#define WSM_CMD_JOIN_TIMEOUT	(7 * HZ) /* Join timeout is 5 sec. in FW   */
+#define WSM_CMD_START_TIMEOUT	(7 * HZ)
+#define WSM_CMD_RESET_TIMEOUT	(7 * HZ) /* 2 sec. timeout was observed.   */
+#define WSM_CMD_DEFAULT_TIMEOUT	(3 * HZ)
+#define WSM_SKIP(buf, size)						\
+	do {								\
+		if (unlikely((buf)->data + size > (buf)->end))		\
+			goto underflow;					\
+		(buf)->data += size;					\
+	} while (0)
+
+#define WSM_GET(buf, ptr, size)						\
+	do {								\
+		if (unlikely((buf)->data + size > (buf)->end))		\
+			goto underflow;					\
+		memcpy(ptr, (buf)->data, size);				\
+		(buf)->data += size;					\
+	} while (0)
+
+#define __WSM_GET(buf, type, cvt)					\
+	({								\
+		type val;						\
+		if (unlikely((buf)->data + sizeof(type) > (buf)->end))	\
+			goto underflow;					\
+		val = cvt(*(type *)(buf)->data);			\
+		(buf)->data += sizeof(type);				\
+		val;							\
+	})
+
+#define WSM_GET8(buf)  __WSM_GET(buf, u8, (u8))
+#define WSM_GET16(buf) __WSM_GET(buf, u16, __le16_to_cpu)
+#define WSM_GET32(buf) __WSM_GET(buf, u32, __le32_to_cpu)
+
+#define WSM_PUT(buf, ptr, size)						\
+	do {								\
+		if (unlikely((buf)->data + size > (buf)->end))		\
+			if (unlikely(wsm_buf_reserve((buf), size)))	\
+				goto nomem;				\
+		memcpy((buf)->data, ptr, size);				\
+		(buf)->data += size;					\
+	} while (0)
+
+#define __WSM_PUT(buf, val, type, cvt)					\
+	do {								\
+		if (unlikely((buf)->data + sizeof(type) > (buf)->end))	\
+			if (unlikely(wsm_buf_reserve((buf), sizeof(type)))) \
+				goto nomem;				\
+		*(type *)(buf)->data = cvt(val);			\
+		(buf)->data += sizeof(type);				\
+	} while (0)
+
+#define WSM_PUT8(buf, val)  __WSM_PUT(buf, val, u8, (u8))
+#define WSM_PUT16(buf, val) __WSM_PUT(buf, val, u16, __cpu_to_le16)
+#define WSM_PUT32(buf, val) __WSM_PUT(buf, val, u32, __cpu_to_le32)
+
+static void wsm_buf_reset(struct wsm_buf *buf);
+static int wsm_buf_reserve(struct wsm_buf *buf, size_t extra_size);
+static int get_interface_id_scanning(struct xradio_common *hw_priv);
+
+static int wsm_cmd_send(struct xradio_common *hw_priv,
+			struct wsm_buf *buf,
+			void *arg, u16 cmd, long tmo, int if_id);
+
+static struct xradio_vif
+	*wsm_get_interface_for_tx(struct xradio_common *hw_priv);
+
+static inline void wsm_cmd_lock(struct xradio_common *hw_priv)
+{
+	down(&hw_priv->wsm_cmd_sema);
+}
+
+static inline void wsm_cmd_unlock(struct xradio_common *hw_priv)
+{
+	up(&hw_priv->wsm_cmd_sema);
+}
+
+static inline void wsm_oper_lock(struct xradio_common *hw_priv)
+{
+	down(&hw_priv->wsm_oper_lock);
+}
+
+static inline void wsm_oper_unlock(struct xradio_common *hw_priv)
+{
+	up(&hw_priv->wsm_oper_lock);
+}
+
+/* ******************************************************************** */
+/* WSM API implementation						*/
+
+static int wsm_generic_confirm(struct xradio_common *hw_priv,
+			     void *arg,
+			     struct wsm_buf *buf)
+{
+	u32 status = WSM_GET32(buf);
+	if (status != WSM_STATUS_SUCCESS)
+		return status;
+	return 0;
+
+underflow:
+	SYS_WARN(1);
+	return -EINVAL;
+}
+
+#if (DGB_XRADIO_HWT)
+int wsm_hwt_cmd(struct xradio_common *hw_priv, void *arg, size_t arg_size)
+{
+	int ret = 0;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+	WSM_PUT(buf, arg, arg_size);
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x0004, WSM_CMD_TIMEOUT, -1);
+	wsm_cmd_unlock(hw_priv);
+
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+#endif
+
+int wsm_fw_dbg(struct xradio_common *hw_priv, void *arg, size_t arg_size)
+{
+	int ret = 0;
+
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT(buf, arg, arg_size);
+
+	ret = wsm_cmd_send(hw_priv, buf, arg, 0x0025, WSM_CMD_TIMEOUT, -1);
+
+	wsm_cmd_unlock(hw_priv);
+
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+
+}
+
+static int wsm_fw_dbg_confirm(struct xradio_common *hw_priv,
+				void *arg, struct wsm_buf *buf)
+{
+#ifdef SUPPORT_FW_DBG_INF
+	return xradio_fw_dbg_confirm((void *)(buf->data), arg);
+#else
+	return 0;
+#endif
+}
+
+static int wsm_fw_dbg_indicate(struct xradio_common *hw_priv,
+				struct wsm_buf *buf)
+{
+#ifdef SUPPORT_FW_DBG_INF
+	return xradio_fw_dbg_indicate((void *)(buf->data));
+#else
+	return 0;
+#endif
+}
+
+#ifdef CONFIG_XRADIO_ETF
+int wsm_etf_cmd(struct xradio_common *hw_priv, struct wsm_hdr *arg)
+{
+	int ret = 0;
+	wsm_printk(XRADIO_DBG_MSG, "%s >>> 0x%.4X (%d)\n",
+				__func__, arg->id, arg->len);
+
+#ifdef HW_RESTART
+	if (unlikely(hw_priv->hw_restart)) {
+		wsm_printk(XRADIO_DBG_ERROR, "%s hw reset!>>> 0x%.4X (%d)\n",
+				   __func__, arg->id, arg->len);
+		return ETF_ERR_DRIVER_HANG;  /*return success, don't process cmd in power off.*/
+	}
+#endif
+	if (unlikely(hw_priv->bh_error)) {
+		wsm_printk(XRADIO_DBG_ERROR, "%s bh error!>>> 0x%.4X (%d)\n",
+				   __func__, arg->id, arg->len);
+		return ETF_ERR_DRIVER_HANG;
+	}
+
+	wsm_cmd_lock(hw_priv);
+	spin_lock(&hw_priv->wsm_cmd.lock);
+	SYS_BUG(hw_priv->wsm_cmd.ptr);
+	hw_priv->wsm_cmd.done = 0;
+	hw_priv->wsm_cmd.ptr = (u8 *)arg;
+	hw_priv->wsm_cmd.len = arg->len;
+	hw_priv->wsm_cmd.arg = NULL;
+	hw_priv->wsm_cmd.cmd = arg->id;
+	spin_unlock(&hw_priv->wsm_cmd.lock);
+	xradio_bh_wakeup(hw_priv);
+
+	if (unlikely(hw_priv->bh_error)) {
+		/* Do not wait for timeout if BH is dead. Exit immediately. */
+		ret = ETF_ERR_DRIVER_HANG;
+	} else {
+		/*Set max timeout.*/
+		long tmo = WSM_CMD_TIMEOUT;
+		unsigned long wsm_cmd_max_tmo = jiffies + tmo;
+		/* Firmware prioritizes data traffic over control confirm.
+		 * Loop below checks if data was RXed and increases timeout
+		 * accordingly. */
+		do {
+			/* It's safe to use unprotected access to wsm_cmd.done here */
+			ret = wait_event_timeout(hw_priv->wsm_cmd_wq,
+						 hw_priv->wsm_cmd.done, tmo);
+
+			/* check time since last rxed and max timeout.*/
+		} while (!ret &&
+			 time_before_eq(jiffies, hw_priv->rx_timestamp+tmo) &&
+			 time_before(jiffies, wsm_cmd_max_tmo));
+
+	}
+	spin_lock(&hw_priv->wsm_cmd.lock);
+	if (unlikely(hw_priv->wsm_cmd.ptr != NULL)) {
+		hw_priv->wsm_cmd.ptr = NULL;
+		wsm_printk(XRADIO_DBG_ERROR, "%s cmd didn't send!>>> 0x%.4X (%d)\n",
+				   __func__, arg->id, arg->len);
+		ret = ETF_ERR_DRIVER_HANG;
+	} else {
+		wsm_printk(XRADIO_DBG_NIY, "%s cmd send finish(%d)!>>> 0x%.4X (%d)\n",
+				   __func__, ret, arg->id, arg->len);
+		ret = 0;
+	}
+	spin_unlock(&hw_priv->wsm_cmd.lock);
+
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+}
+#endif
+
+#ifdef XR_RRM /*RadioResourceMeasurement*/
+static int wsm_start_measure_requset(struct xradio_common *hw_priv,
+						MEASUREMENT_PARAMETERS *arg,
+							      int  if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT(buf, arg, sizeof(*arg));
+	ret = wsm_cmd_send(hw_priv, buf, arg, 0x000E, WSM_CMD_TIMEOUT, if_id);
+
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+
+}
+
+int wsm_11k_measure_requset(struct xradio_common  *hw_priv,
+					       u8  measure_type,
+					      u16  ChannelNum,
+					      u16  Duration)
+{
+    int ret;
+    u8 type, sub_type;
+    MEASUREMENT_PARAMETERS rrm_paras;
+    LMAC_MEAS_REQUEST *rrm_req = &rrm_paras.MeasurementRequest;
+	/*    LMAC_MEAS_CHANNEL_LOAD_PARAMS *rrm_req = &rrm_paras.MeasurementRequest; */
+    rrm_paras.TxPowerLevel = 0x11;
+    rrm_paras.DurationMandatory = 0x22;
+    rrm_paras.MeasurementRequestLength = 0x33;
+
+    type     = (measure_type&0xf0)>>4;
+    sub_type =  measure_type&0xf;
+    rrm_paras.MeasurementType = type;
+	/*    if (measure_type == ChannelLoadMeasurement) { */
+    if (type == ChannelLoadMeasurement) {
+	rrm_req->ChannelLoadParams.Reserved = 0;
+	rrm_req->ChannelLoadParams.ChannelLoadCCA = sub_type;
+	rrm_req->ChannelLoadParams.ChannelNum = ChannelNum;
+		/*valid when channelload measure, interval bettween request&start */
+	rrm_req->ChannelLoadParams.RandomInterval = 0;
+		/*unit:1TU=1024us */
+	rrm_req->ChannelLoadParams.MeasurementDuration = Duration;
+	rrm_req->ChannelLoadParams.MeasurementStartTimel = 0;
+	rrm_req->ChannelLoadParams.MeasurementStartTimeh = 0;
+    } else if (type == NoiseHistrogramMeasurement) {
+	rrm_req->NoisHistogramParams.Reserved = 0;
+	rrm_req->NoisHistogramParams.IpiRpi = sub_type;
+	rrm_req->NoisHistogramParams.ChannelNum = ChannelNum;
+	rrm_req->NoisHistogramParams.RandomInterval = 0;
+	rrm_req->NoisHistogramParams.MeasurementDuration = Duration;
+	rrm_req->NoisHistogramParams.MeasurementStartTimel = 0;
+	rrm_req->NoisHistogramParams.MeasurementStartTimeh = 0;
+    }
+    ret = wsm_start_measure_requset(hw_priv, &rrm_paras, 0);
+
+    return ret;
+}
+
+
+#endif /*RadioResourceMeasurement */
+int wsm_configuration(struct xradio_common *hw_priv,
+		      struct wsm_configuration *arg,
+		      int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT32(buf, arg->dot11MaxTransmitMsduLifeTime);
+	WSM_PUT32(buf, arg->dot11MaxReceiveLifeTime);
+	WSM_PUT32(buf, arg->dot11RtsThreshold);
+
+	/* DPD block. */
+	WSM_PUT16(buf, arg->dpdData_size + 12);
+	WSM_PUT16(buf, 1); /* DPD version */
+	WSM_PUT(buf, arg->dot11StationId, ETH_ALEN);
+	WSM_PUT16(buf, 5); /* DPD flags */
+	WSM_PUT(buf, arg->dpdData, arg->dpdData_size);
+
+	ret = wsm_cmd_send(hw_priv, buf, arg, 0x0009, WSM_CMD_TIMEOUT, if_id);
+
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+static int wsm_configuration_confirm(struct xradio_common *hw_priv,
+				     struct wsm_configuration *arg,
+				     struct wsm_buf *buf)
+{
+	int i;
+	int status;
+
+	status = WSM_GET32(buf);
+	if (SYS_WARN(status != WSM_STATUS_SUCCESS))
+		return -EINVAL;
+
+	WSM_GET(buf, arg->dot11StationId, ETH_ALEN);
+	arg->dot11FrequencyBandsSupported = WSM_GET8(buf);
+	WSM_SKIP(buf, 1);
+	arg->supportedRateMask = WSM_GET32(buf);
+	for (i = 0; i < 2; ++i) {
+		arg->txPowerRange[i].min_power_level = WSM_GET32(buf);
+		arg->txPowerRange[i].max_power_level = WSM_GET32(buf);
+		arg->txPowerRange[i].stepping = WSM_GET32(buf);
+	}
+	return 0;
+
+underflow:
+	SYS_WARN(1);
+	return -EINVAL;
+}
+
+/* ******************************************************************** */
+/*forcing upper layer to restart wifi.*/
+void wsm_upper_restart(struct xradio_common *hw_priv)
+{
+	wsm_printk(XRADIO_DBG_ERROR, "%s\n", __func__);
+
+#ifdef ERROR_HANG_DRIVER
+	if (error_hang_driver) {
+		wsm_printk(XRADIO_DBG_ERROR, "%s error_hang_driver\n", __func__);
+		return ; /*do not restart for error debug.*/
+	}
+#endif
+
+#ifdef CONFIG_PM
+	xradio_pm_stay_awake(&hw_priv->pm_state, 3*HZ);
+#endif
+
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS) && 0
+	spin_lock(&hw_priv->vif_list_lock);
+	xradio_for_each_vif(hw_priv, priv, i) {
+		if (!priv)
+			continue;
+		/*ieee80211_driver_hang_notify(priv->vif, GFP_KERNEL); */
+		wsm_printk(XRADIO_DBG_WARN, "%s driver_hang_notify\n", __func__);
+	}
+	spin_unlock(&hw_priv->vif_list_lock);
+#elif defined(HW_RESTART)
+	/* We shall not schedule restart_work to system kthread in such case:
+	* 1. while there is a restart_work is pending
+	* 2. while driver is not ready, for the case insmod drv failed, should not restart
+	* 3. while restart_work is running
+	*/
+	if (work_pending(&hw_priv->hw_restart_work) || (!hw_priv->driver_ready) ||
+					hw_priv->hw_restart_work_running) {
+		return;
+	} else {
+		wsm_cmd_lock(hw_priv);
+		hw_priv->hw_restart = true;
+		wsm_cmd_unlock(hw_priv);
+		/* wait for scan complete.*/
+		wsm_printk(XRADIO_DBG_WARN, "Wait for scan complete!\n");
+		down(&hw_priv->scan.lock);
+		down(&hw_priv->conf_lock);
+		/* Unlock wsm_oper_lock since no confirms of wsm_oper_locks.*/
+		if (down_trylock(&hw_priv->wsm_oper_lock))
+			wsm_printk(XRADIO_DBG_WARN, "oper_lock may be locked!\n");
+		up(&hw_priv->wsm_oper_lock);
+		up(&hw_priv->conf_lock);
+		up(&hw_priv->scan.lock);
+		msleep(200);
+		wsm_cmd_lock(hw_priv);
+		if (!hw_priv->exit_sync) {
+			if (schedule_work(&hw_priv->hw_restart_work) > 0)
+				wsm_printk(XRADIO_DBG_WARN,
+					"%s schedule restart_work!\n", __func__);
+			else
+				wsm_printk(XRADIO_DBG_ERROR, "%s restart_work failed!\n",
+					__func__);
+
+		} else {
+			wsm_printk(XRADIO_DBG_WARN,
+				"%s Don't restart_work because driver exit!\n", __func__);
+		}
+		wsm_cmd_unlock(hw_priv);
+		return;
+	}
+#endif
+}
+
+void wsm_query_work(struct work_struct *work)
+{
+	struct xradio_common *hw_priv =
+		container_of(work, struct xradio_common, query_work);
+	u8 ret[100] = {0};
+	wsm_printk(XRADIO_DBG_ALWY, "%s\n", __func__);
+
+	*(u32 *)&ret[0] = hw_priv->query_packetID;
+	wsm_read_mib(hw_priv, WSM_MIB_ID_REQ_PKT_STATUS,
+		     (void *)&ret[0], sizeof(ret), 4);
+	if (!ret[4]) {
+		wsm_printk(XRADIO_DBG_ALWY,
+			   "QuerypktID=0x%08x, status=0x%x, retry=%d, flags=0x%x, " \
+			   "PktDebug=0x%x, pktqueue=0x%x, ext1=%d, ext2=%d, " \
+			   "ext3=%d, ext4=0x%x, ext5=0x%x\n",
+			   *(u32 *)&ret[0], ret[6], ret[7], *(u32 *)&ret[8],
+			   *(u32 *)&ret[12], ret[44], ret[45], ret[46],
+			   ret[47], ret[48], ret[49]);
+		wsm_printk(XRADIO_DBG_ALWY,
+			   "interdebug=0x%x, 0x%x, 0x%x, Soure=0x%x, 0x%x, 0x%x\n" \
+			   "interuse=%d, external=%d, TxOutstanding=%d, " \
+			   "QueueStatus=0x%x, BA0=0x%x, BA1=0x%x\n" \
+			   "ScanStatus=0x%x, scanNULL=0x%x, " \
+			   "wr_state=0x%x, 0x%x, 0x%x, 0x%x, " \
+			   "wr_cnt=0x%04x, 0x%04x, 0x%04x, 0x%04x\n",
+			   *(u32 *)&ret[16], *(u32 *)&ret[20], *(u32 *)&ret[24], ret[28],
+			   ret[29], ret[30], ret[32], ret[33], ret[34],
+			   ret[35], *(u32 *)&ret[36], *(u32 *)&ret[40],
+			   ret[50], ret[51], ret[52], ret[53], ret[54], ret[55],
+			   *(u16 *)&ret[56], *(u16 *)&ret[58], *(u16 *)&ret[60],
+			   *(u16 *)&ret[62]);
+		wsm_printk(XRADIO_DBG_ALWY,
+			"FW time:request=%d, now=%d, queue=%d, complete=%d\n",
+			*(u32 *)&ret[64], *(u32 *)&ret[68],
+			*(u32 *)&ret[72], *(u32 *)&ret[76]);
+	} else {
+		ret[5] = 0;
+		wsm_printk(XRADIO_DBG_ALWY, "No req packid=0x%08x!\n", *(u32 *)&ret[0]);
+	}
+	/*hardware error occurs, try to restart wifi.*/
+	if (ret[5] & 0x4) {
+		wsm_printk(XRADIO_DBG_ERROR, "Hardware need to reset 0x%x.\n", ret[5]);
+		hw_priv->bh_error = 1;
+#ifdef BH_USE_SEMAPHORE
+		up(&hw_priv->bh_sem);
+#else
+		wake_up(&hw_priv->bh_wq);
+#endif
+	}
+	hw_priv->query_packetID = 0;
+}
+
+/* ******************************************************************** */
+
+int wsm_reset(struct xradio_common *hw_priv, const struct wsm_reset *arg,
+		int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+	u16 cmd = 0x000A | WSM_TX_LINK_ID(arg->link_id);
+
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT32(buf, arg->reset_statistics ? 0 : 1);
+	ret = wsm_cmd_send(hw_priv, buf, NULL, cmd, WSM_CMD_RESET_TIMEOUT,
+				if_id);
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+/* ******************************************************************** */
+
+struct wsm_mib {
+	u16 mibId;
+	void *buf;
+	size_t buf_size;
+};
+
+int wsm_read_mib(struct xradio_common *hw_priv, u16 mibId, void *_buf,
+			size_t buf_size, size_t arg_size)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+	struct wsm_mib mib_buf = {
+		.mibId = mibId,
+		.buf = _buf,
+		.buf_size = buf_size,
+	};
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT16(buf, mibId);
+	WSM_PUT16(buf, arg_size);
+	WSM_PUT(buf, _buf, arg_size);
+
+	ret = wsm_cmd_send(hw_priv, buf, &mib_buf, 0x0005, WSM_CMD_TIMEOUT, -1);
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+static int wsm_read_mib_confirm(struct xradio_common *hw_priv,
+				struct wsm_mib *arg,
+				struct wsm_buf *buf)
+{
+	u16 size;
+	if (SYS_WARN(WSM_GET32(buf) != WSM_STATUS_SUCCESS))
+		return -EINVAL;
+
+	if (SYS_WARN(WSM_GET16(buf) != arg->mibId))
+		return -EINVAL;
+
+	size = WSM_GET16(buf);
+	if (size > arg->buf_size)
+		size = arg->buf_size;
+
+	WSM_GET(buf, arg->buf, size);
+	arg->buf_size = size;
+	return 0;
+
+underflow:
+	SYS_WARN(1);
+	return -EINVAL;
+}
+
+/* ******************************************************************** */
+
+int wsm_write_mib(struct xradio_common *hw_priv, u16 mibId, void *_buf,
+			size_t buf_size, int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+	struct wsm_mib mib_buf = {
+		.mibId = mibId,
+		.buf = _buf,
+		.buf_size = buf_size,
+	};
+
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT16(buf, mibId);
+	WSM_PUT16(buf, buf_size);
+	WSM_PUT(buf, _buf, buf_size);
+
+	ret = wsm_cmd_send(hw_priv, buf, &mib_buf, 0x0006, WSM_CMD_TIMEOUT,
+			if_id);
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+static int wsm_write_mib_confirm(struct xradio_common *hw_priv,
+				struct wsm_mib *arg,
+				struct wsm_buf *buf,
+				int interface_link_id)
+{
+	int ret;
+	int i;
+	struct xradio_vif *priv;
+	ret = wsm_generic_confirm(hw_priv, arg, buf);
+	if (ret)
+		return ret;
+
+	/*wsm_set_operational_mode confirm.*/
+	if (arg->mibId == 0x1006) {
+		const char *p = arg->buf;
+		bool powersave_enabled = (p[0] & 0x0F) ? true : false;
+
+		/* update vif PM status. */
+		priv = xrwl_hwpriv_to_vifpriv(hw_priv, interface_link_id);
+		if (priv) {
+			xradio_enable_powersave(priv, powersave_enabled);
+			spin_unlock(&priv->vif_lock);
+		}
+
+		/* HW powersave base on vif except for generic vif. */
+		spin_lock(&hw_priv->vif_list_lock);
+		xradio_for_each_vif(hw_priv, priv, i) {
+#ifdef P2P_MULTIVIF
+			if ((i == (XRWL_MAX_VIFS - 1)) || !priv)
+#else
+			if (!priv)
+#endif
+				continue;
+			powersave_enabled &= !!priv->powersave_enabled;
+		}
+		hw_priv->powersave_enabled = powersave_enabled;
+		spin_unlock(&hw_priv->vif_list_lock);
+
+	}
+	return 0;
+}
+
+/* ******************************************************************** */
+
+int wsm_scan(struct xradio_common *hw_priv, const struct wsm_scan *arg,
+		int if_id)
+{
+	int i;
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	if (unlikely(arg->numOfChannels > 48))
+		return -EINVAL;
+
+	if (unlikely(arg->numOfSSIDs > WSM_SCAN_MAX_NUM_OF_SSIDS))
+		return -EINVAL;
+
+	if (unlikely(arg->band > 1))
+		return -EINVAL;
+
+	wsm_oper_lock(hw_priv);
+	wsm_cmd_lock(hw_priv);
+
+#ifdef SUPPORT_HT40
+
+	WSM_PUT8(buf, arg->band);
+	WSM_PUT8(buf, arg->scanFlags);
+	WSM_PUT16(buf, arg->TransmitRateEntry);
+	WSM_PUT32(buf, arg->autoScanInterval);
+	WSM_PUT8(buf, arg->numOfProbeRequests);
+	WSM_PUT8(buf, arg->numOfChannels);
+	WSM_PUT8(buf, arg->numOfSSIDs);
+	WSM_PUT8(buf, arg->probeDelay);
+
+#else
+
+	WSM_PUT8(buf, arg->band);
+	WSM_PUT8(buf, arg->scanType);
+	WSM_PUT8(buf, arg->scanFlags);
+	WSM_PUT8(buf, arg->maxTransmitRate);
+	WSM_PUT32(buf, arg->autoScanInterval);
+	WSM_PUT8(buf, arg->numOfProbeRequests);
+	WSM_PUT8(buf, arg->numOfChannels);
+	WSM_PUT8(buf, arg->numOfSSIDs);
+	WSM_PUT8(buf, arg->probeDelay);
+
+#endif
+
+	for (i = 0; i < arg->numOfChannels; ++i) {
+		WSM_PUT16(buf, arg->ch[i].number);
+		WSM_PUT16(buf, 0);
+		WSM_PUT32(buf, arg->ch[i].minChannelTime);
+		WSM_PUT32(buf, arg->ch[i].maxChannelTime);
+		WSM_PUT32(buf, 0);
+	}
+
+	for (i = 0; i < arg->numOfSSIDs; ++i) {
+		WSM_PUT32(buf, arg->ssids[i].length);
+		WSM_PUT(buf, &arg->ssids[i].ssid[0],
+				sizeof(arg->ssids[i].ssid));
+	}
+
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x0007, WSM_CMD_TIMEOUT,
+			   if_id);
+	wsm_cmd_unlock(hw_priv);
+	if (ret)
+		wsm_oper_unlock(hw_priv);
+#ifdef HW_RESTART
+	else if (hw_priv->hw_restart)
+		wsm_oper_unlock(hw_priv);
+#endif
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	wsm_oper_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+/* ******************************************************************** */
+
+int wsm_stop_scan(struct xradio_common *hw_priv, int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+	wsm_cmd_lock(hw_priv);
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x0008, WSM_CMD_TIMEOUT,
+			   if_id);
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+}
+
+
+static int wsm_tx_confirm(struct xradio_common *hw_priv,
+			  struct wsm_buf *buf,
+			  int interface_link_id)
+{
+	struct wsm_tx_confirm tx_confirm;
+
+#ifdef SUPPORT_HT40
+
+	tx_confirm.packetID = WSM_GET32(buf);
+	tx_confirm.status = WSM_GET32(buf);
+	tx_confirm.txedRateEntry = WSM_GET16(buf);
+	tx_confirm.ackFailures = WSM_GET8(buf);
+	tx_confirm.flags = WSM_GET8(buf);
+	tx_confirm.RateTry[0] = WSM_GET16(buf);
+	tx_confirm.RateTry[1] = WSM_GET16(buf);
+	tx_confirm.RateTry[2] = WSM_GET16(buf);
+	tx_confirm.RateTry[3] = WSM_GET16(buf);
+	tx_confirm.RateTry[4] = WSM_GET16(buf);
+	tx_confirm.RateTry[5] = WSM_GET16(buf);
+	tx_confirm.mediaDelay = WSM_GET32(buf);
+	tx_confirm.txQueueDelay = WSM_GET32(buf);
+
+#else
+
+	tx_confirm.packetID = WSM_GET32(buf);
+	tx_confirm.status = WSM_GET32(buf);
+	tx_confirm.txedRate = WSM_GET8(buf);
+	tx_confirm.ackFailures = WSM_GET8(buf);
+	tx_confirm.flags = WSM_GET16(buf);
+	tx_confirm.rate_try[0] = WSM_GET32(buf);
+	tx_confirm.rate_try[1] = WSM_GET32(buf);
+	tx_confirm.rate_try[2] = WSM_GET32(buf);
+	tx_confirm.mediaDelay = WSM_GET32(buf);
+	tx_confirm.txQueueDelay = WSM_GET32(buf);
+
+#endif
+
+	wsm_printk(XRADIO_DBG_NIY, "mediaDelay=%d, QueueDelay=%d.\n",
+		tx_confirm.mediaDelay, tx_confirm.txQueueDelay);
+	xradio_debug_tx_delay(tx_confirm.mediaDelay, tx_confirm.txQueueDelay);
+
+	if (is_hardware_xradio(hw_priv)) {
+		/* TODO:COMBO:linkID will be stored in packetID*/
+		/* TODO:COMBO: Extract traffic resumption map */
+		tx_confirm.if_id = xradio_queue_get_if_id(tx_confirm.packetID);
+		tx_confirm.link_id = xradio_queue_get_link_id(
+				tx_confirm.packetID);
+	} else {
+		tx_confirm.link_id = interface_link_id;
+		tx_confirm.if_id = 0;
+	}
+
+#if 0
+	wsm_release_vif_tx_buffer(hw_priv, tx_confirm.if_id, 1);
+#endif
+
+	if (hw_priv->wsm_cbc.tx_confirm)
+		hw_priv->wsm_cbc.tx_confirm(hw_priv, &tx_confirm);
+	return 0;
+
+underflow:
+	SYS_WARN(1);
+	return -EINVAL;
+}
+
+static int wsm_multi_tx_confirm(struct xradio_common *hw_priv,
+				struct wsm_buf *buf, int interface_link_id)
+{
+	struct xradio_vif *priv;
+	int ret;
+	int count;
+	int i;
+
+	count = WSM_GET32(buf);
+#if 0
+	if (SYS_WARN(count <= 0))
+		return -EINVAL;
+	else if (count > 1) {
+		ret = wsm_release_tx_buffer(hw_priv, count - 1);
+		if (ret < 0)
+			return ret;
+		else if (ret > 0)
+			xradio_bh_wakeup(hw_priv);
+	}
+#endif
+
+	DBG_ARRY_ADD(dbg_txconfirm, count-1);
+
+	priv = xrwl_hwpriv_to_vifpriv(hw_priv, interface_link_id);
+	if (priv) {
+		xradio_debug_txed_multi(priv, count);
+		spin_unlock(&priv->vif_lock);
+	}
+	for (i = 0; i < count; ++i) {
+		ret = wsm_tx_confirm(hw_priv, buf, interface_link_id);
+		if (ret)
+			return ret;
+	}
+	return ret;
+
+underflow:
+	SYS_WARN(1);
+	return -EINVAL;
+}
+
+/* ******************************************************************** */
+
+static int wsm_join_confirm(struct xradio_common *hw_priv,
+			    struct wsm_join *arg,
+			    struct wsm_buf *buf)
+{
+	if (WSM_GET32(buf) != WSM_STATUS_SUCCESS)
+		return -EINVAL;
+	arg->minPowerLevel = WSM_GET32(buf);
+	arg->maxPowerLevel = WSM_GET32(buf);
+
+	return 0;
+
+underflow:
+	SYS_WARN(1);
+	return -EINVAL;
+}
+
+int wsm_join(struct xradio_common *hw_priv, struct wsm_join *arg,
+	     int if_id)
+/*TODO: combo: make it work per vif.*/
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_oper_lock(hw_priv);
+	wsm_cmd_lock(hw_priv);
+
+#ifdef SUPPORT_HT40
+
+	WSM_PUT16(buf, *(u16 *)(&arg->PhyModeCfg));
+	WSM_PUT16(buf, arg->channelNumber);
+	WSM_PUT(buf, &arg->bssid[0], sizeof(arg->bssid));
+	WSM_PUT16(buf, arg->atimWindow);
+	WSM_PUT8(buf, arg->mode);
+	WSM_PUT8(buf, arg->probeForJoin);
+	WSM_PUT8(buf, arg->dtimPeriod);
+	WSM_PUT8(buf, arg->flags);
+	WSM_PUT32(buf, arg->ssidLength);
+	WSM_PUT(buf, &arg->ssid[0], sizeof(arg->ssid));
+	WSM_PUT32(buf, arg->beaconInterval);
+	WSM_PUT32(buf, arg->basicRateSet);
+
+#else
+
+	WSM_PUT8(buf, arg->mode);
+	WSM_PUT8(buf, arg->band);
+	WSM_PUT16(buf, arg->channelNumber);
+	WSM_PUT(buf, &arg->bssid[0], sizeof(arg->bssid));
+	WSM_PUT16(buf, arg->atimWindow);
+	WSM_PUT8(buf, arg->preambleType);
+	WSM_PUT8(buf, arg->probeForJoin);
+	WSM_PUT8(buf, arg->dtimPeriod);
+	WSM_PUT8(buf, arg->flags);
+	WSM_PUT32(buf, arg->ssidLength);
+	WSM_PUT(buf, &arg->ssid[0], sizeof(arg->ssid));
+	WSM_PUT32(buf, arg->beaconInterval);
+	WSM_PUT32(buf, arg->basicRateSet);
+
+#endif
+	hw_priv->tx_burst_idx = -1;
+	ret = wsm_cmd_send(hw_priv, buf, arg, 0x000B, WSM_CMD_JOIN_TIMEOUT,
+			   if_id);
+	wsm_cmd_unlock(hw_priv);
+	wsm_oper_unlock(hw_priv); /*confirm, not indcation.*/
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	wsm_oper_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+/* ******************************************************************** */
+
+int wsm_set_bss_params(struct xradio_common *hw_priv,
+			const struct wsm_set_bss_params *arg,
+			int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT8(buf, 0);
+	WSM_PUT8(buf, arg->beaconLostCount);
+	WSM_PUT16(buf, arg->aid);
+	WSM_PUT32(buf, arg->operationalRateSet);
+
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x0011, WSM_CMD_TIMEOUT,
+			if_id);
+
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+/* ******************************************************************** */
+
+int wsm_add_key(struct xradio_common *hw_priv, const struct wsm_add_key *arg,
+			int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT(buf, arg, sizeof(*arg));
+
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x000C, WSM_CMD_TIMEOUT,
+				if_id);
+
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+/* ******************************************************************** */
+
+int wsm_remove_key(struct xradio_common *hw_priv,
+		   const struct wsm_remove_key *arg, int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT8(buf, arg->entryIndex);
+	WSM_PUT8(buf, 0);
+	WSM_PUT16(buf, 0);
+
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x000D, WSM_CMD_TIMEOUT,
+			   if_id);
+
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+/* ******************************************************************** */
+
+int wsm_set_tx_queue_params(struct xradio_common *hw_priv,
+				const struct wsm_set_tx_queue_params *arg,
+				u8 id, int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+	u8 queue_id_to_wmm_aci[] = {3, 2, 0, 1};
+
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT8(buf, queue_id_to_wmm_aci[id]);
+	WSM_PUT8(buf, 0);
+	WSM_PUT8(buf, arg->ackPolicy);
+	WSM_PUT8(buf, 0);
+	WSM_PUT32(buf, arg->maxTransmitLifetime);
+	WSM_PUT16(buf, arg->allowedMediumTime);
+	WSM_PUT16(buf, 0);
+
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x0012, WSM_CMD_TIMEOUT, if_id);
+
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+/* ******************************************************************** */
+
+int wsm_set_edca_params(struct xradio_common *hw_priv,
+				const struct wsm_edca_params *arg,
+				int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+
+	/* Implemented according to specification. */
+
+	WSM_PUT16(buf, arg->params[3].cwMin);
+	WSM_PUT16(buf, arg->params[2].cwMin);
+	WSM_PUT16(buf, arg->params[1].cwMin);
+	WSM_PUT16(buf, arg->params[0].cwMin);
+
+	WSM_PUT16(buf, arg->params[3].cwMax);
+	WSM_PUT16(buf, arg->params[2].cwMax);
+	WSM_PUT16(buf, arg->params[1].cwMax);
+	WSM_PUT16(buf, arg->params[0].cwMax);
+
+	WSM_PUT8(buf, arg->params[3].aifns);
+	WSM_PUT8(buf, arg->params[2].aifns);
+	WSM_PUT8(buf, arg->params[1].aifns);
+	WSM_PUT8(buf, arg->params[0].aifns);
+
+	WSM_PUT16(buf, arg->params[3].txOpLimit);
+	WSM_PUT16(buf, arg->params[2].txOpLimit);
+	WSM_PUT16(buf, arg->params[1].txOpLimit);
+	WSM_PUT16(buf, arg->params[0].txOpLimit);
+
+	WSM_PUT32(buf, arg->params[3].maxReceiveLifetime);
+	WSM_PUT32(buf, arg->params[2].maxReceiveLifetime);
+	WSM_PUT32(buf, arg->params[1].maxReceiveLifetime);
+	WSM_PUT32(buf, arg->params[0].maxReceiveLifetime);
+
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x0013, WSM_CMD_TIMEOUT, if_id);
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+/* ******************************************************************** */
+
+int wsm_switch_channel(struct xradio_common *hw_priv,
+		       const struct wsm_switch_channel *arg,
+		       int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_lock_tx(hw_priv);
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT8(buf, arg->channelMode);
+	WSM_PUT8(buf, arg->channelSwitchCount);
+	WSM_PUT16(buf, arg->newChannelNumber);
+
+	hw_priv->channel_switch_in_progress = 1;
+
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x0016, WSM_CMD_TIMEOUT, if_id);
+	wsm_cmd_unlock(hw_priv);
+	if (ret) {
+		wsm_unlock_tx(hw_priv);
+		hw_priv->channel_switch_in_progress = 0;
+	}
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	wsm_unlock_tx(hw_priv);
+	return -ENOMEM;
+}
+
+/* ******************************************************************** */
+
+int wsm_set_pm(struct xradio_common *hw_priv, const struct wsm_set_pm *arg,
+		int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_oper_lock(hw_priv);
+
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT8(buf, arg->pmMode);
+	WSM_PUT8(buf, arg->fastPsmIdlePeriod);
+	WSM_PUT8(buf, arg->apPsmChangePeriod);
+	WSM_PUT8(buf, arg->minAutoPsPollPeriod);
+
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x0010, WSM_CMD_TIMEOUT, if_id);
+
+	wsm_cmd_unlock(hw_priv);
+	if (ret)
+		wsm_oper_unlock(hw_priv);
+#ifdef HW_RESTART
+	else if (hw_priv->hw_restart)
+		wsm_oper_unlock(hw_priv);
+#endif
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	wsm_oper_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+/* ******************************************************************** */
+
+int wsm_start(struct xradio_common *hw_priv, const struct wsm_start *arg,
+		int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+
+#ifdef SUPPORT_HT40
+
+	WSM_PUT16(buf, *(u16 *)(&arg->PhyModeCfg));
+	WSM_PUT16(buf, arg->channelNumber);
+	WSM_PUT32(buf, arg->CTWindow);
+	WSM_PUT32(buf, arg->beaconInterval);
+	WSM_PUT8(buf, arg->mode);
+	WSM_PUT8(buf, arg->DTIMPeriod);
+	WSM_PUT8(buf, arg->probeDelay);
+	WSM_PUT8(buf, arg->ssidLength);
+	WSM_PUT(buf, arg->ssid, sizeof(arg->ssid));
+	WSM_PUT32(buf, arg->basicRateSet);
+
+#else
+
+	WSM_PUT8(buf, arg->mode);
+	WSM_PUT8(buf, arg->band);
+	WSM_PUT16(buf, arg->channelNumber);
+	WSM_PUT32(buf, arg->CTWindow);
+	WSM_PUT32(buf, arg->beaconInterval);
+	WSM_PUT8(buf, arg->DTIMPeriod);
+	WSM_PUT8(buf, arg->preambleType);
+	WSM_PUT8(buf, arg->probeDelay);
+	WSM_PUT8(buf, arg->ssidLength);
+	WSM_PUT(buf, arg->ssid, sizeof(arg->ssid));
+	WSM_PUT32(buf, arg->basicRateSet);
+
+#endif
+
+	hw_priv->tx_burst_idx = -1;
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x0017, WSM_CMD_START_TIMEOUT,
+			if_id);
+
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+#if 0
+/* This API is no longer present in WSC */
+/* ******************************************************************** */
+
+int wsm_beacon_transmit(struct xradio_common *hw_priv,
+			const struct wsm_beacon_transmit *arg,
+			int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT32(buf, arg->enableBeaconing ? 1 : 0);
+
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x0018, WSM_CMD_TIMEOUT, if_id);
+
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+#endif
+
+/* ******************************************************************** */
+
+int wsm_start_find(struct xradio_common *hw_priv, int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x0019, WSM_CMD_TIMEOUT, if_id);
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+}
+
+/* ******************************************************************** */
+
+int wsm_stop_find(struct xradio_common *hw_priv, int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x001A, WSM_CMD_TIMEOUT, if_id);
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+}
+
+/* ******************************************************************** */
+
+int wsm_map_link(struct xradio_common *hw_priv, const struct wsm_map_link *arg,
+		int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+	u16 cmd = 0x001C;
+
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT(buf, &arg->mac_addr[0], sizeof(arg->mac_addr));
+
+	if (is_hardware_xradio(hw_priv)) {
+		WSM_PUT8(buf, arg->unmap);
+		WSM_PUT8(buf, arg->link_id);
+	} else {
+		cmd |= WSM_TX_LINK_ID(arg->link_id);
+		WSM_PUT16(buf, 0);
+	}
+
+	ret = wsm_cmd_send(hw_priv, buf, NULL, cmd, WSM_CMD_TIMEOUT, if_id);
+
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+/* ******************************************************************** */
+
+int wsm_update_ie(struct xradio_common *hw_priv,
+		  const struct wsm_update_ie *arg, int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT16(buf, arg->what);
+	WSM_PUT16(buf, arg->count);
+	WSM_PUT(buf, arg->ies, arg->length);
+
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x001B, WSM_CMD_TIMEOUT, if_id);
+
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+
+}
+/* ******************************************************************** */
+#ifdef MCAST_FWDING
+/* 3.66 */
+static int wsm_give_buffer_confirm(struct xradio_common *hw_priv,
+			    struct wsm_buf *buf)
+{
+	wsm_printk(XRADIO_DBG_MSG, "HW Buf count %d\n", hw_priv->hw_bufs_used);
+	if (!hw_priv->hw_bufs_used)
+		wake_up(&hw_priv->bh_evt_wq);
+
+	return 0;
+}
+
+/* 3.65 */
+int wsm_init_release_buffer_request(struct xradio_common *hw_priv)
+{
+	struct wsm_buf *buf = &hw_priv->wsm_release_buf;
+	u16 cmd = 0x0022; /* Buffer Request */
+	size_t buf_len = sizeof(struct wsm_hdr) + 8;
+
+	wsm_buf_init(buf, buf_len);
+	WSM_PUT8(buf, 0);
+	WSM_PUT8(buf, 0);
+	WSM_PUT16(buf, 0);
+
+	buf_len = buf->data - buf->begin;
+
+	/* Fill HI message header */
+	((__le16 *)buf->begin)[0] = __cpu_to_le16(buf_len);
+	((__le16 *)buf->begin)[1] = __cpu_to_le16(cmd);
+
+	return 0;
+nomem:
+	return -ENOMEM;
+}
+
+void wsm_deinit_release_buffer(struct xradio_common *hw_priv)
+{
+	wsm_buf_deinit(&hw_priv->wsm_release_buf);
+}
+
+/* 3.68 */
+static int wsm_request_buffer_confirm(struct xradio_vif *priv,
+			    u8 *arg,
+			    struct wsm_buf *buf)
+{
+	u8 count;
+	u32 sta_asleep_mask = 0;
+	int i;
+	u32 mask = 0;
+	u32 change_mask = 0;
+	struct xradio_common *hw_priv = priv->hw_priv;
+
+	/* There is no status field in this message */
+	sta_asleep_mask = WSM_GET32(buf);
+	count = WSM_GET8(buf);
+	count -= 1; /* Current workaround for FW issue */
+
+	spin_lock_bh(&priv->ps_state_lock);
+	change_mask = (priv->sta_asleep_mask ^ sta_asleep_mask);
+	wsm_printk(XRADIO_DBG_MSG, "CM %x, HM %x, FWM %x\n",
+		   change_mask, priv->sta_asleep_mask, sta_asleep_mask);
+	spin_unlock_bh(&priv->ps_state_lock);
+
+	if (change_mask) {
+		struct ieee80211_sta *sta;
+		int ret = 0;
+
+
+		for (i = 0; i < MAX_STA_IN_AP_MODE ; ++i) {
+
+			if (XRADIO_LINK_HARD != priv->link_id_db[i].status)
+				continue;
+			mask = BIT(i + 1);
+			/* If FW state and host state for
+			 * this link are different then notify OMAC */
+			if (change_mask & mask) {
+				wsm_printk(XRADIO_DBG_MSG,
+					   "PS State Changed %d for sta %pM\n",
+					   (sta_asleep_mask & mask) ? 1 : 0,
+					    priv->link_id_db[i].mac);
+				rcu_read_lock();
+				sta = mac80211_find_sta(priv->vif, priv->link_id_db[i].mac);
+				if (!sta) {
+					wsm_printk(XRADIO_DBG_MSG,
+						   "WRBC - could not find sta %pM\n",
+						   priv->link_id_db[i].mac);
+				} else {
+					ret = mac80211_sta_ps_transition_ni(sta,
+						 (sta_asleep_mask & mask) ? true : false);
+					wsm_printk(XRADIO_DBG_MSG, "PS State NOTIFIED %d\n", ret);
+					SYS_WARN(ret);
+				}
+				rcu_read_unlock();
+			}
+		}
+		/* Replace STA mask with one reported by FW */
+		spin_lock_bh(&priv->ps_state_lock);
+		priv->sta_asleep_mask = sta_asleep_mask;
+		spin_unlock_bh(&priv->ps_state_lock);
+	}
+
+	wsm_printk(XRADIO_DBG_MSG, "WRBC - HW Buf count %d SleepMask %d\n",
+					hw_priv->hw_bufs_used, sta_asleep_mask);
+	hw_priv->buf_released = 0;
+	SYS_WARN(count != (hw_priv->wsm_caps.numInpChBufs - 1));
+
+    return 0;
+
+underflow:
+    SYS_WARN(1);
+    return -EINVAL;
+}
+
+/* 3.67 */
+int wsm_request_buffer_request(struct xradio_vif *priv,
+				u8 *arg)
+{
+	int ret;
+	struct wsm_buf *buf = &priv->hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(priv->hw_priv);
+
+	WSM_PUT8(buf, (*arg));
+	WSM_PUT8(buf, 0);
+	WSM_PUT16(buf, 0);
+
+	ret = wsm_cmd_send(priv->hw_priv, buf, arg, 0x0023,
+			   WSM_CMD_JOIN_TIMEOUT, priv->if_id);
+
+	wsm_cmd_unlock(priv->hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(priv->hw_priv);
+	return -ENOMEM;
+}
+#endif
+
+int wsm_set_keepalive_filter(struct xradio_vif *priv, bool enable)
+{
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+
+	priv->rx_filter.keepalive = enable;
+	return wsm_set_rx_filter(hw_priv, &priv->rx_filter, priv->if_id);
+}
+
+int wsm_set_probe_responder(struct xradio_vif *priv, bool enable)
+{
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+
+	priv->rx_filter.probeResponder = enable;
+	return wsm_set_rx_filter(hw_priv, &priv->rx_filter, priv->if_id);
+}
+/* ******************************************************************** */
+/* WSM indication events implementation					*/
+
+static int wsm_startup_indication(struct xradio_common *hw_priv,
+					struct wsm_buf *buf)
+{
+	u16 status;
+#ifdef CONFIG_XRADIO_DEBUG
+	static const char * const fw_types[] = {
+		"ETF",
+		"WFM",
+		"WSM",
+		"HI test",
+		"Platform test"
+	};
+#endif
+
+	hw_priv->wsm_caps.numInpChBufs	= WSM_GET16(buf);
+	hw_priv->wsm_caps.sizeInpChBuf	= WSM_GET16(buf);
+	hw_priv->wsm_caps.hardwareId	= WSM_GET16(buf);
+	hw_priv->wsm_caps.hardwareSubId	= WSM_GET16(buf);
+	status				= WSM_GET16(buf);
+	hw_priv->wsm_caps.firmwareCap	= WSM_GET16(buf);
+	hw_priv->wsm_caps.firmwareType	= WSM_GET16(buf);
+	hw_priv->wsm_caps.firmwareApiVer	= WSM_GET16(buf);
+	hw_priv->wsm_caps.firmwareBuildNumber = WSM_GET16(buf);
+	hw_priv->wsm_caps.firmwareVersion	= WSM_GET16(buf);
+	WSM_GET(buf, &hw_priv->wsm_caps.fw_label[0], WSM_FW_LABEL);
+	/* Do not trust FW too much. */
+	hw_priv->wsm_caps.fw_label[WSM_FW_LABEL+1] = 0;
+
+	hw_priv->wsm_caps.firmwareConfig[0] = WSM_GET32(buf);
+	hw_priv->wsm_caps.firmwareConfig[1] = WSM_GET32(buf);
+	hw_priv->wsm_caps.firmwareConfig[2] = WSM_GET32(buf);
+
+	if (SYS_WARN(status))
+		return -EINVAL;
+
+	if (SYS_WARN(hw_priv->wsm_caps.firmwareType > 4))
+		return -EINVAL;
+
+	wsm_printk(XRADIO_DBG_NIY, "%s\n"
+		"   Input buffers: %d x %d bytes\n"
+		"   Hardware: %d.%d\n"
+		"   %s firmware ver: %d, build: %d, "
+		    " api: %d, cap: 0x%.4X\n",
+		__func__,
+		hw_priv->wsm_caps.numInpChBufs,
+		hw_priv->wsm_caps.sizeInpChBuf,
+		hw_priv->wsm_caps.hardwareId,
+		hw_priv->wsm_caps.hardwareSubId,
+		fw_types[hw_priv->wsm_caps.firmwareType],
+		hw_priv->wsm_caps.firmwareVersion,
+		hw_priv->wsm_caps.firmwareBuildNumber,
+		hw_priv->wsm_caps.firmwareApiVer,
+		hw_priv->wsm_caps.firmwareCap);
+
+	wsm_printk(XRADIO_DBG_ALWY, "Firmware Label:%s\n",
+		   &hw_priv->wsm_caps.fw_label[0]);
+
+	hw_priv->wsm_caps.firmwareReady = 1;
+
+	wake_up(&hw_priv->wsm_startup_done);
+	return 0;
+
+underflow:
+	SYS_WARN(1);
+	return -EINVAL;
+}
+
+void wsm_send_deauth_to_self(struct xradio_common *hw_priv,
+							 struct xradio_vif *priv)
+{
+	struct sk_buff *skb = NULL;
+	struct ieee80211_mgmt *deauth = NULL;
+
+	if (priv->join_status == XRADIO_JOIN_STATUS_AP) {
+		int i = 0;
+		wsm_printk(XRADIO_DBG_WARN, "AP mode, send_deauth_to_self\n");
+		for (i = 0; i < MAX_STA_IN_AP_MODE; i++) {
+			if (priv->link_id_db[i].status == XRADIO_LINK_HARD) {
+				skb = xr_alloc_skb(sizeof(struct ieee80211_mgmt) + 64);
+				if (!skb)
+					return;
+				skb_reserve(skb, 64);
+				deauth = (struct ieee80211_mgmt *) \
+					  skb_put(skb, sizeof(struct ieee80211_mgmt));
+				if (!deauth) {
+					SYS_WARN(1);
+					return;
+				}
+				deauth->frame_control =
+				    cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_DEAUTH);
+				deauth->duration = 0;
+				memcpy(deauth->da, priv->vif->addr, ETH_ALEN);
+				memcpy(deauth->sa, priv->link_id_db[i].mac, ETH_ALEN);
+				memcpy(deauth->bssid, priv->vif->addr, ETH_ALEN);
+				deauth->seq_ctrl = 0;
+				deauth->u.deauth.reason_code = WLAN_REASON_DEAUTH_LEAVING;
+				mac80211_rx_irqsafe(priv->hw, skb);
+			}
+		}
+	} else if (priv->join_status == XRADIO_JOIN_STATUS_STA) {
+		wsm_printk(XRADIO_DBG_WARN, "STA mode, send_deauth_to_self\n");
+		skb = xr_alloc_skb(sizeof(struct ieee80211_mgmt) + 64);
+		if (!skb)
+			return;
+		skb_reserve(skb, 64);
+		deauth = (struct ieee80211_mgmt *) \
+			  skb_put(skb, sizeof(struct ieee80211_mgmt));
+		if (!deauth) {
+			SYS_WARN(1);
+			return;
+		}
+		deauth->frame_control =
+		    cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_DEAUTH);
+		deauth->duration = 0;
+		memcpy(deauth->da, priv->vif->addr, ETH_ALEN);
+		memcpy(deauth->sa, priv->join_bssid, ETH_ALEN);
+		memcpy(deauth->bssid, priv->join_bssid, ETH_ALEN);
+		deauth->seq_ctrl = 0;
+		deauth->u.deauth.reason_code = WLAN_REASON_DEAUTH_LEAVING;
+		mac80211_rx_irqsafe(priv->hw, skb);
+	}
+}
+
+void wsm_send_disassoc_to_self(struct xradio_common *hw_priv,
+							   struct xradio_vif *priv)
+{
+	struct sk_buff *skb = NULL;
+	struct ieee80211_mgmt *disassoc = NULL;
+	if (priv->join_status == XRADIO_JOIN_STATUS_AP) {
+		int i = 0;
+		wsm_printk(XRADIO_DBG_WARN, "AP mode, wsm_send_disassoc_to_self\n");
+		for (i = 0; i < MAX_STA_IN_AP_MODE; i++) {
+			if (priv->link_id_db[i].status == XRADIO_LINK_HARD) {
+				skb = xr_alloc_skb(sizeof(struct ieee80211_mgmt) + 64);
+				if (!skb)
+					return;
+				skb_reserve(skb, 64);
+				disassoc = (struct ieee80211_mgmt *) \
+					    skb_put(skb, sizeof(struct ieee80211_mgmt));
+				if (!disassoc) {
+					SYS_WARN(1);
+					return;
+				}
+				disassoc->frame_control =
+					cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_DISASSOC);
+				disassoc->duration = 0;
+				memcpy(disassoc->da, priv->vif->addr, ETH_ALEN);
+				memcpy(disassoc->sa, priv->link_id_db[i].mac, ETH_ALEN);
+				memcpy(disassoc->bssid, priv->vif->addr, ETH_ALEN);
+				disassoc->seq_ctrl = 0;
+				disassoc->u.disassoc.reason_code =
+				      WLAN_REASON_DISASSOC_STA_HAS_LEFT;
+				mac80211_rx_irqsafe(priv->hw, skb);
+			}
+		}
+	} else if (priv->join_status == XRADIO_JOIN_STATUS_STA) {
+		wsm_printk(XRADIO_DBG_WARN, "STA mode, wsm_send_disassoc_to_self\n");
+		skb = xr_alloc_skb(sizeof(struct ieee80211_mgmt) + 64);
+		if (!skb)
+			return;
+		skb_reserve(skb, 64);
+		disassoc = (struct ieee80211_mgmt *) \
+			    skb_put(skb, sizeof(struct ieee80211_mgmt));
+		if (!disassoc) {
+			SYS_WARN(1);
+			return;
+		}
+		disassoc->frame_control =
+		     cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_DISASSOC);
+		disassoc->duration = 0;
+		memcpy(disassoc->da, priv->vif->addr, ETH_ALEN);
+		memcpy(disassoc->sa, priv->join_bssid, ETH_ALEN);
+		memcpy(disassoc->bssid, priv->join_bssid, ETH_ALEN);
+		disassoc->seq_ctrl = 0;
+		disassoc->u.disassoc.reason_code =
+		     WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY;
+		mac80211_rx_irqsafe(priv->hw, skb);
+	}
+}
+
+static int wsm_receive_indication(struct xradio_common *hw_priv,
+					int interface_link_id,
+					struct wsm_buf *buf,
+					struct sk_buff **skb_p)
+{
+	struct xradio_vif *priv;
+	int if_id = interface_link_id;
+
+	hw_priv->rx_timestamp = jiffies;
+	if (hw_priv->wsm_cbc.rx) {
+		struct wsm_rx rx;
+		struct ieee80211_hdr *hdr;
+		size_t hdr_len;
+#ifdef SUPPORT_HT40
+
+		rx.status = WSM_GET32(buf);
+		rx.channelNumber = WSM_GET16(buf);
+		rx.rxedRateEntry = WSM_GET16(buf);
+		rx.Reserved[0] = WSM_GET8(buf);
+		rx.Reserved[1] = WSM_GET8(buf);
+		rx.Reserved[2] = WSM_GET8(buf);
+		rx.rcpiRssi = WSM_GET8(buf);
+		rx.flags = WSM_GET32(buf);
+
+#else
+
+		rx.status = WSM_GET32(buf);
+		rx.channelNumber = WSM_GET16(buf);
+		rx.rxedRate = WSM_GET8(buf);
+		rx.rcpiRssi = WSM_GET8(buf);
+		rx.flags = WSM_GET32(buf);
+
+#endif
+
+		/* TODO:COMBO: Frames received from scanning are received
+		* with interface ID == 2 */
+		if (is_hardware_xradio(hw_priv)) {
+			if (if_id == XRWL_GENERIC_IF_ID) {
+				/* Frames received in response to SCAN
+				 * Request */
+				if_id = get_interface_id_scanning(hw_priv);
+				if (if_id == -1) {
+					if_id = hw_priv->roc_if_id;
+				}
+#ifdef ROAM_OFFLOAD
+				if (hw_priv->auto_scanning) {
+					if_id = hw_priv->scan.if_id;
+				}
+#endif/*ROAM_OFFLOAD*/
+			}
+			/* linkid (peer sta id is encoded in bit 25-28 of
+			   flags field */
+#ifdef SUPPORT_HT40
+
+			rx.link_id = WSM_RX_LINK_ID_GET(rx.flags);
+
+#else
+
+			rx.link_id = ((rx.flags & (0xf << 25)) >> 25);
+
+#endif
+			rx.if_id = if_id;
+		} else {
+			rx.link_id = if_id;
+			rx.if_id = 0;
+		}
+#ifdef MONITOR_MODE
+		if (hw_priv->monitor_if_id != -1)
+			priv = xrwl_hwpriv_to_vifpriv(hw_priv, hw_priv->monitor_if_id);
+		else
+#endif
+			priv = xrwl_hwpriv_to_vifpriv(hw_priv, rx.if_id);
+		if (!priv) {
+			wsm_printk(XRADIO_DBG_WARN,
+				"%s: NULL priv(if=%d) drop frame, link_id=%d, "
+				"scan_id=%d, roc_id=%d, scan_req=%p, direct_probe=%d\n",
+				__func__, if_id, interface_link_id,
+				hw_priv->scan.if_id, hw_priv->roc_if_id,
+				hw_priv->scan.req, hw_priv->scan.direct_probe);
+			return 0;
+		}
+		/*remove wsm hdr of skb*/
+		hdr_len = buf->data - buf->begin;
+		skb_pull(*skb_p, hdr_len);
+
+		/* FW Workaround: Drop probe resp or
+		beacon when RSSI is 0 */
+		hdr = (struct ieee80211_hdr *) (*skb_p)->data;
+
+		if (!rx.rcpiRssi &&
+		    (ieee80211_is_probe_resp(hdr->frame_control) ||
+		    ieee80211_is_beacon(hdr->frame_control))) {
+			spin_unlock(&priv->vif_lock);
+			skb_push(*skb_p, hdr_len);
+			return 0;
+		}
+
+		/* If no RSSI subscription has been made,
+		* convert RCPI to RSSI here */
+		if (!priv->cqm_use_rssi)
+			rx.rcpiRssi = rx.rcpiRssi / 2 - 110;
+#ifdef USE_RSSI_OFFSET
+		rx.rcpiRssi = (s8)rx.rcpiRssi - WSM_RSSI_OFFSET; /* rssi offset.*/
+#endif
+		if ((s8)rx.rcpiRssi > 0)
+			rx.rcpiRssi = 0;
+
+		if (!rx.status && unlikely(ieee80211_is_deauth(hdr->frame_control))) {
+			if (ieee80211_has_protected(hdr->frame_control) || !priv->is_mfp_connect) {
+				if (priv->join_status == XRADIO_JOIN_STATUS_STA) {
+					/* Shedule unjoin work */
+					wsm_printk(XRADIO_DBG_WARN, \
+						"Issue unjoin command (RX).\n");
+					wsm_lock_tx_async(hw_priv);
+					if (queue_work(hw_priv->workqueue,
+							&priv->unjoin_work) <= 0)
+						wsm_unlock_tx(hw_priv);
+				}
+			}
+		}
+		hw_priv->wsm_cbc.rx(priv, &rx, skb_p);
+		if (*skb_p)
+			skb_push(*skb_p, hdr_len);
+		spin_unlock(&priv->vif_lock);
+	}
+	return 0;
+
+underflow:
+	return -EINVAL;
+}
+static int wsm_multi_receive_indication(struct xradio_common *hw_priv,
+					int multirxlen,
+					struct wsm_buf *buf,
+					struct sk_buff **skb_p)
+{
+	size_t wsm_len = 0;
+	int wsm_id;
+	size_t len;
+	struct wsm_hdr *wsm;
+	u8 *data = buf->begin;
+	size_t packet_len = 0;
+	int interface_link_id = 0;
+	int cloned = 0;
+	wsm_printk(XRADIO_DBG_NIY, "%s Total=%d\n",
+		__func__, multirxlen);
+
+	for (len = 0; len < multirxlen; len += packet_len) {
+		wsm = (struct wsm_hdr *)(data + len);
+		wsm_len = __le32_to_cpu(wsm->len);
+		packet_len = ROUND4(wsm_len);
+		wsm_id  = __le32_to_cpu(wsm->id) & 0xFFF;
+		interface_link_id = (wsm_id >> 6) & 0x0F;
+		wsm_printk(XRADIO_DBG_MSG, "if%d-multi-rx 0x%.4X (%zu)\n",
+			interface_link_id, wsm_id, wsm_len);
+
+		wsm_id &= ~WSM_TX_LINK_ID(WSM_TX_LINK_ID_MAX);
+		if (wsm_id == 0x0804) {
+			struct wsm_buf wsm_buffer;
+			struct sk_buff *skb = NULL;
+
+			wsm_buffer.begin = (u8 *)&wsm[0];
+			wsm_buffer.data = (u8 *)&wsm[1];
+			wsm_buffer.end =
+				&wsm_buffer.begin[__le32_to_cpu(wsm->len)];
+
+			if ((len + packet_len) < multirxlen) {
+				skb = skb_clone((*skb_p), GFP_ATOMIC);
+				if (WARN_ON(!skb))
+					break;
+
+				skb_trim(skb, 0);
+				skb_put(skb, len + wsm_len); /* set data end.*/
+				skb_pull(skb, len);  /* set data begin.*/
+				skb_trim(skb, wsm_len); /* set data length.*/
+
+				wsm_receive_indication(hw_priv,
+					interface_link_id, &wsm_buffer, &skb);
+				if (skb) {
+					dev_kfree_skb(skb);
+					skb = NULL;
+				} else {
+					++cloned;
+				}
+			} else { /*last packet*/
+				skb_trim(*skb_p, 0);
+				skb_put(*skb_p, len + wsm_len); /* set data end.*/
+				skb_pull(*skb_p, len); /* set data begin.*/
+				skb_trim(*skb_p, wsm_len); /* set data length.*/
+				wsm_receive_indication(hw_priv,
+					interface_link_id, &wsm_buffer, skb_p);
+
+				if (*skb_p) {
+					/* the skb cannot be reclaim by xradio_put_skb or
+					 * xradio_put_resv_skb if it is cloned.
+					 */
+					if (cloned) {
+						dev_kfree_skb(*skb_p);
+						*skb_p = NULL;
+					} else {
+						/* reset the data begin.*/
+						skb_push(*skb_p, len);
+					}
+				}
+			}
+		}
+	}
+	return 0;
+}
+
+static int wsm_event_indication(struct xradio_common *hw_priv,
+				struct wsm_buf *buf,
+				int interface_link_id)
+{
+	int first;
+	struct xradio_wsm_event *event = NULL;
+	struct xradio_vif *priv;
+
+	if (!is_hardware_xradio(hw_priv))
+		interface_link_id = 0;
+
+	priv = xrwl_hwpriv_to_vifpriv(hw_priv, interface_link_id);
+
+	if (unlikely(!priv)) {
+		wsm_printk(XRADIO_DBG_WARN, "Event: %d(%d) for removed "
+			   "interface, ignoring\n", __le32_to_cpu(WSM_GET32(buf)),
+			   __le32_to_cpu(WSM_GET32(buf)));
+		return 0;
+	}
+
+	if (unlikely(priv->mode == NL80211_IFTYPE_UNSPECIFIED)) {
+		/* STA is stopped. */
+		return 0;
+	}
+	spin_unlock(&priv->vif_lock);
+
+	event = xr_kzalloc(sizeof(struct xradio_wsm_event), false);
+	if (event == NULL) {
+		wsm_printk(XRADIO_DBG_ERROR, "%s:xr_kzalloc failed!", __func__);
+		return -EINVAL;
+	}
+
+	event->evt.eventId = __le32_to_cpu(WSM_GET32(buf));
+	event->evt.eventData = __le32_to_cpu(WSM_GET32(buf));
+	event->if_id = interface_link_id;
+
+	wsm_printk(XRADIO_DBG_MSG, "Event: %d(%d)\n",
+		event->evt.eventId, event->evt.eventData);
+	if (event->evt.eventId == WSM_EVENT_ERROR) {
+		int len = (int)(buf->end - buf->data);
+		int i = 0;
+		wsm_printk(XRADIO_DBG_ALWY, "FW TXERR: 0x%08x(%d)\n",
+				  event->evt.eventData, len);
+		for (i = 0; i < (len>>2); i++)
+			wsm_printk(XRADIO_DBG_ALWY, "0x%08x\n", __le32_to_cpu(WSM_GET32(buf)));
+		for (len &= 0x3; len > 0; len--)
+			wsm_printk(XRADIO_DBG_ALWY, "0x%x\n", __le32_to_cpu(WSM_GET8(buf)));
+		wsm_printk(XRADIO_DBG_ALWY, "FW TXERR END\n");
+	}
+
+	spin_lock(&hw_priv->event_queue_lock);
+	first = list_empty(&hw_priv->event_queue);
+	list_add_tail(&event->link, &hw_priv->event_queue);
+	spin_unlock(&hw_priv->event_queue_lock);
+
+	if (first)
+		queue_work(hw_priv->workqueue, &hw_priv->event_handler);
+
+	return 0;
+
+underflow:
+	kfree(event);
+	return -EINVAL;
+}
+
+#define PRINT_11K_MEASRURE 1
+static int wsm_measure_cmpl_indication(struct xradio_common *hw_priv,
+						       struct wsm_buf *buf)
+{
+	MEASUREMENT_COMPLETE measure_cmpl;
+	u8 cca_chanload;
+	u32 buf_len = 0;
+	u32 *data;
+
+	LMAC_MEAS_CHANNEL_LOAD_RESULTS *chanload_res;
+	LMAC_MEAS_NOISE_HISTOGRAM_RESULTS *noise_res;
+	WSM_GET(buf, &measure_cmpl, 12);
+
+	switch (measure_cmpl.MeasurementType) {
+	case ChannelLoadMeasurement:
+		buf_len = sizeof(LMAC_MEAS_CHANNEL_LOAD_RESULTS);
+		break;
+	case NoiseHistrogramMeasurement:
+		buf_len = sizeof(LMAC_MEAS_NOISE_HISTOGRAM_RESULTS);
+		break;
+	case BeaconReport:
+		buf_len = sizeof(LMAC_MEAS_BEACON_RESULTS);
+		break;
+	case STAstatisticsReport:
+		buf_len = sizeof(LMAC_MEAS_STA_STATS_RESULTS);
+		break;
+	case LinkMeasurement:
+		buf_len = sizeof(LMAC_MEAS_LINK_MEASUREMENT_RESULTS);
+		break;
+	}
+	wsm_printk(XRADIO_DBG_ERROR, "[11K]buf_len = %d\n", buf_len);
+	WSM_GET(buf, &measure_cmpl.MeasurementReport, buf_len);
+
+	data = (u32 *)(&measure_cmpl);
+	/*
+	wsm_printk(XRADIO_DBG_ERROR, "[***11K***]data[0]=%08x\n", data[0]);
+	wsm_printk(XRADIO_DBG_ERROR, "[***11K***]data[1]=%08x\n", data[1]);
+	wsm_printk(XRADIO_DBG_ERROR, "[***11K***]data[2]=%08x\n", data[2]);
+	wsm_printk(XRADIO_DBG_ERROR, "[***11K***]data[3]=%08x\n", data[3]);
+	wsm_printk(XRADIO_DBG_ERROR, "[***11K***]data[4]=%08x\n", data[4]);
+	wsm_printk(XRADIO_DBG_ERROR, "[***11K***]data[5]=%08x\n", data[5]);
+	wsm_printk(XRADIO_DBG_ERROR, "[***11K***]data[6]=%08x\n", data[6]);
+	*/
+	wsm_printk(XRADIO_DBG_ERROR, "[***11K***]MeasurementType=%0d\n",
+		   measure_cmpl.MeasurementType);
+
+	if (measure_cmpl.Status == WSM_STATUS_SUCCESS) {
+		switch (measure_cmpl.MeasurementType) {
+		case ChannelLoadMeasurement:
+			chanload_res = &measure_cmpl.MeasurementReport.ChannelLoadResults;
+			cca_chanload = (chanload_res->ChannelLoadCCA == MEAS_CCA) ?
+			chanload_res->CCAbusyFraction :
+			chanload_res->ChannelLoad;
+#ifdef PRINT_11K_MEASRURE
+			wsm_printk(XRADIO_DBG_ERROR,
+				   "[11K] ChannelLoadMeasurement Result:\n"\
+				   "ChannelLoadCCA = %d\n"\
+				   "ChannelNum     = %d\n"\
+				   "Duration       = %d\n"\
+				   "Fraction       = %d\n", \
+				   chanload_res->ChannelLoadCCA, \
+				   chanload_res->ChannelNum, \
+				   chanload_res->MeasurementDuration, \
+				   cca_chanload);
+#endif
+			break;
+		case NoiseHistrogramMeasurement:
+			noise_res = &measure_cmpl.MeasurementReport.NoiseHistogramResults;
+			/*
+			 IpiRpi = (noise_res->IpiRpi == MEAS_RPI) ?
+			 chanload_res->CCAbusyFraction :
+			 chanload_res->ChannelLoad;
+			 */
+#ifdef PRINT_11K_MEASRURE
+			wsm_printk(XRADIO_DBG_ERROR, "[11K] NoiseHistogramResults:\n"\
+				   "IpiRpi = %d\n"\
+				   "ChannelNum = %d\n"\
+				   "PI_0__Density = %d\n"\
+				   "PI_1__Density = %d\n"\
+				   "PI_2__Density = %d\n"\
+				   "PI_3__Density = %d\n"\
+				   "PI_4__Density = %d\n"\
+				   "PI_5__Density = %d\n"\
+				   "PI_6__Density = %d\n"\
+				   "PI_7__Density = %d\n"\
+				   "PI_8__Density = %d\n"\
+				   "PI_9__Density = %d\n"\
+				   "PI_10_Density = %d\n", \
+				   noise_res->IpiRpi, \
+				   noise_res->ChannelNum, \
+				   noise_res->PI_0_Density, \
+				   noise_res->PI_1_Density, \
+				   noise_res->PI_2_Density, \
+				   noise_res->PI_3_Density, \
+				   noise_res->PI_4_Density, \
+				   noise_res->PI_5_Density, \
+				   noise_res->PI_6_Density, \
+				   noise_res->PI_7_Density, \
+				   noise_res->PI_8_Density, \
+				   noise_res->PI_9_Density, \
+				   noise_res->PI_10_Density \
+				   );
+#endif
+			break;
+		case BeaconReport:
+			break;
+		case STAstatisticsReport:
+			break;
+		case LinkMeasurement:
+			break;
+		}
+	} else {
+		wsm_printk(XRADIO_DBG_ERROR,
+			   "11K Measure(type=%d) Fail\n",
+			   measure_cmpl.MeasurementType);
+	}
+
+	return 0;
+
+underflow:
+	return -EINVAL;
+}
+/* TODO:COMBO:Make this perVIFF once mac80211 support is available */
+static int wsm_channel_switch_indication(struct xradio_common *hw_priv,
+						struct wsm_buf *buf)
+{
+	wsm_unlock_tx(hw_priv); /* Re-enable datapath */
+	SYS_WARN(WSM_GET32(buf));
+
+	hw_priv->channel_switch_in_progress = 0;
+	wake_up(&hw_priv->channel_switch_done);
+
+	if (hw_priv->wsm_cbc.channel_switch)
+		hw_priv->wsm_cbc.channel_switch(hw_priv);
+	return 0;
+
+underflow:
+	return -EINVAL;
+}
+
+static int wsm_set_pm_indication(struct xradio_common *hw_priv,
+					struct wsm_buf *buf)
+{
+	wsm_oper_unlock(hw_priv);
+	return 0;
+}
+
+static int wsm_scan_complete_indication(struct xradio_common *hw_priv,
+					struct wsm_buf *buf)
+{
+#ifdef ROAM_OFFLOAD
+	if (hw_priv->auto_scanning == 0)
+		wsm_oper_unlock(hw_priv);
+#else
+	wsm_oper_unlock(hw_priv);
+#endif /*ROAM_OFFLOAD*/
+
+	if (hw_priv->wsm_cbc.scan_complete) {
+		struct wsm_scan_complete arg;
+		arg.status = WSM_GET32(buf);
+		arg.psm = WSM_GET8(buf);
+		arg.numChannels = WSM_GET8(buf);
+		hw_priv->wsm_cbc.scan_complete(hw_priv, &arg);
+	}
+	return 0;
+
+underflow:
+	return -EINVAL;
+}
+
+static int wsm_find_complete_indication(struct xradio_common *hw_priv,
+					struct wsm_buf *buf)
+{
+	/* TODO: Implement me. */
+	/*STUB();*/
+	return 0;
+}
+
+static int wsm_suspend_resume_indication(struct xradio_common *hw_priv,
+					 int interface_link_id,
+					 struct wsm_buf *buf)
+{
+	if (hw_priv->wsm_cbc.suspend_resume) {
+		u32 flags;
+		struct wsm_suspend_resume arg;
+		struct xradio_vif *priv;
+
+		if (is_hardware_xradio(hw_priv)) {
+			int i;
+			arg.if_id = interface_link_id;
+			/* TODO:COMBO: Extract bitmap from suspend-resume
+			* TX indication */
+			xradio_for_each_vif(hw_priv, priv, i) {
+				if (!priv)
+					continue;
+				if (priv->join_status ==
+						XRADIO_JOIN_STATUS_AP) {
+					 arg.if_id = priv->if_id;
+					 break;
+				}
+				arg.link_id = 0;
+			}
+		} else {
+			arg.if_id = 0;
+			arg.link_id = interface_link_id;
+		}
+
+		flags = WSM_GET32(buf);
+		arg.stop = !(flags & 1);
+		arg.multicast = !!(flags & 8);
+		arg.queue = (flags >> 1) & 3;
+
+		priv = xrwl_hwpriv_to_vifpriv(hw_priv, arg.if_id);
+		if (unlikely(!priv)) {
+			wsm_printk(XRADIO_DBG_MSG, "suspend-resume indication"
+				   " for removed interface!\n");
+			return 0;
+		}
+		hw_priv->wsm_cbc.suspend_resume(priv, &arg);
+		spin_unlock(&priv->vif_lock);
+	}
+	return 0;
+
+underflow:
+	return -EINVAL;
+}
+
+
+/* ******************************************************************** */
+/* WSM TX								*/
+int wsm_cmd_send(struct xradio_common *hw_priv,
+		 struct wsm_buf *buf,
+		 void *arg, u16 cmd, long tmo, int if_id)
+{
+	size_t buf_len = buf->data - buf->begin;
+	int ret;
+	u16 mib_id = 0;
+	unsigned long wsm_cmd_max_tmo = 0x0;
+
+	if (cmd == 0x0006 || cmd == 0x0005) {/* Write/Read MIB */
+		mib_id = __le16_to_cpu(((__le16 *)buf->begin)[2]);
+		wsm_printk(XRADIO_DBG_MSG, ">>> 0x%.4X [MIB: 0x%.4X] (%zu)\n",
+			cmd, mib_id, buf_len);
+	} else {
+		wsm_printk(XRADIO_DBG_MSG, ">>> 0x%.4X (%zu)\n", cmd, buf_len);
+	}
+
+#ifdef HW_RESTART
+	if (hw_priv->hw_restart) {
+		wsm_printk(XRADIO_DBG_NIY, "hw reset!>>> 0x%.4X (%zu)\n", cmd, buf_len);
+		wsm_buf_reset(buf);
+		return 0;  /*return success, don't process cmd in power off.*/
+	}
+#endif
+
+	if (unlikely(hw_priv->bh_error)) {
+		wsm_buf_reset(buf);
+		wsm_printk(XRADIO_DBG_ERROR, "bh error!>>> 0x%.4X (%zu)\n", cmd, buf_len);
+		return -ETIMEDOUT;
+	}
+
+	/* Fill HI message header */
+	/* BH will add sequence number */
+
+	/* TODO:COMBO: Add if_id from  to the WSM header */
+	/* if_id == -1 indicates that command is HW specific,
+	 * eg. wsm_configuration which is called during driver initialzation
+	 *  (mac80211 .start callback called when first ifce is created.)
+	 */
+
+	/* send hw specific commands on if 0 */
+	if (if_id == -1)
+		if_id = 0;
+
+	((__le16 *)buf->begin)[0] = __cpu_to_le16(buf_len);
+	((__le16 *)buf->begin)[1] = __cpu_to_le16(cmd |
+					((is_hardware_xradio(hw_priv)) ? (if_id << 6) : 0));
+
+	spin_lock(&hw_priv->wsm_cmd.lock);
+	SYS_BUG(hw_priv->wsm_cmd.ptr);
+	hw_priv->wsm_cmd.done = 0;
+	hw_priv->wsm_cmd.ptr = buf->begin;
+	hw_priv->wsm_cmd.len = buf_len;
+	hw_priv->wsm_cmd.arg = arg;
+	hw_priv->wsm_cmd.cmd = cmd;
+	spin_unlock(&hw_priv->wsm_cmd.lock);
+
+	xradio_bh_wakeup(hw_priv);
+	if (unlikely(hw_priv->bh_error)) {
+		/* Do not wait for timeout if BH is dead. Exit immediately. */
+		ret = 0;
+	} else {
+		/* Give start cmd a little more time */
+		if (unlikely(tmo == WSM_CMD_START_TIMEOUT))
+			wsm_cmd_max_tmo = WSM_CMD_START_TIMEOUT;
+		else
+			wsm_cmd_max_tmo = WSM_CMD_DEFAULT_TIMEOUT;
+
+		/*Set max timeout.*/
+		wsm_cmd_max_tmo = jiffies + wsm_cmd_max_tmo;
+
+		/* Firmware prioritizes data traffic over control confirm.
+		 * Loop below checks if data was RXed and increases timeout
+		 * accordingly. */
+		do {
+			/* It's safe to use unprotected access to wsm_cmd.done here */
+			ret = wait_event_timeout(hw_priv->wsm_cmd_wq,
+						 hw_priv->wsm_cmd.done, tmo);
+
+			/* check time since last rxed and max timeout.*/
+		} while (!ret &&
+			 time_before_eq(jiffies, hw_priv->rx_timestamp+tmo) &&
+			 time_before(jiffies, wsm_cmd_max_tmo));
+
+	}
+
+	if (unlikely(ret == 0 && !hw_priv->wsm_cmd.done)) {
+		u16 raceCheck;
+
+		wsm_printk(XRADIO_DBG_ERROR,
+			   "***CMD timeout(%ld, %lu, %lu)!>>> 0x%.4X [0x%.4X](%zu), "
+			   "cmd_ptr=%p, buf_use=%d, bh_state=%d\n",
+			   tmo, wsm_cmd_max_tmo, jiffies,
+				cmd | hw_priv->wsm_cmd.seq, mib_id, buf_len,
+				hw_priv->wsm_cmd.ptr, hw_priv->hw_bufs_used,
+				hw_priv->bh_error);
+
+		spin_lock(&hw_priv->wsm_cmd.lock);
+		raceCheck = hw_priv->wsm_cmd.cmd;
+		hw_priv->wsm_cmd.arg = NULL;
+		hw_priv->wsm_cmd.ptr = NULL;
+		spin_unlock(&hw_priv->wsm_cmd.lock);
+
+		/* Race condition check to make sure _confirm is not called
+		 * after exit of _send */
+		if (raceCheck == 0xFFFF) {
+			/* If wsm_handle_rx got stuck in _confirm we will hang
+			 * system there. It's better than silently currupt
+			 * stack or heap, isn't it? */
+			SYS_BUG(wait_event_timeout(
+					hw_priv->wsm_cmd_wq,
+					hw_priv->wsm_cmd.done,
+					WSM_CMD_LAST_CHANCE_TIMEOUT) <= 0);
+		}
+
+		/* Kill BH thread to report the error to the top layer. */
+		hw_priv->bh_error = 1;
+#ifdef BH_USE_SEMAPHORE
+		up(&hw_priv->bh_sem);
+#else
+		wake_up(&hw_priv->bh_wq);
+#endif
+		ret = -ETIMEDOUT;
+	} else {
+		spin_lock(&hw_priv->wsm_cmd.lock);
+		SYS_BUG(!hw_priv->wsm_cmd.done);
+		ret = hw_priv->wsm_cmd.ret;
+		spin_unlock(&hw_priv->wsm_cmd.lock);
+	}
+	wsm_buf_reset(buf);
+	return ret;
+}
+
+/* ******************************************************************** */
+/* WSM TX port control							*/
+
+void wsm_lock_tx(struct xradio_common *hw_priv)
+{
+	down(&hw_priv->tx_lock_sem);
+	atomic_add(1, &hw_priv->tx_lock);
+	/* always check event if wsm_vif_lock_tx.*/
+	if (wsm_flush_tx(hw_priv))
+		wsm_printk(XRADIO_DBG_MSG, "TX is locked.\n");
+	up(&hw_priv->tx_lock_sem);
+}
+
+void wsm_vif_lock_tx(struct xradio_vif *priv)
+{
+	struct xradio_common *hw_priv = priv->hw_priv;
+	down(&hw_priv->tx_lock_sem);
+	if (atomic_add_return(1, &hw_priv->tx_lock) == 1) {
+		if (wsm_vif_flush_tx(priv))
+			wsm_printk(XRADIO_DBG_MSG, "TX is locked for"
+					" if_id %d.\n", priv->if_id);
+	}
+	up(&hw_priv->tx_lock_sem);
+}
+
+void wsm_lock_tx_async(struct xradio_common *hw_priv)
+{
+	if (atomic_add_return(1, &hw_priv->tx_lock) == 1)
+		wsm_printk(XRADIO_DBG_MSG, "TX is locked (async).\n");
+}
+
+bool wsm_flush_tx(struct xradio_common *hw_priv)
+{
+	long timeout = WSM_CMD_LAST_CHANCE_TIMEOUT;
+
+	/* Flush must be called with TX lock held. */
+	SYS_BUG(!atomic_read(&hw_priv->tx_lock));
+
+	/* First check if we really need to do something.
+	 * It is safe to use unprotected access, as hw_bufs_used
+	 * can only decrements. */
+	if (!hw_priv->hw_bufs_used)
+		return true;
+
+	if (hw_priv->bh_error) {
+		/* In case of failure do not wait for magic. */
+		wsm_printk(XRADIO_DBG_ERROR, "Fatal error occured, "
+				"will not flush TX.\n");
+		return false;
+	} else {
+		/* Get "oldest" frame, if any frames stuck in firmware,
+		   query all of them until max timeout. */
+		int num = hw_priv->hw_bufs_used + 1;
+		while (xradio_query_txpkt_timeout(hw_priv, XRWL_ALL_IFS,
+						  0xffffffff, &timeout)) {
+			if (timeout < 0 || !num) {
+				/* Hmmm... Not good. Frame had stuck in firmware. */
+				wsm_printk(XRADIO_DBG_ERROR,
+					"%s:timeout=%ld, hw_bufs_used=%d, num=%d\n",
+					__func__, timeout, hw_priv->hw_bufs_used, num);
+				hw_priv->bh_error = 1;
+#ifdef BH_USE_SEMAPHORE
+				up(&hw_priv->bh_sem);
+#else
+				wake_up(&hw_priv->bh_wq);
+#endif
+				return false;
+			} else if (wait_event_timeout(hw_priv->bh_evt_wq,
+					       !hw_priv->hw_bufs_used, timeout) > 0) {
+				return true;
+			}
+			--num;
+		}
+		if (hw_priv->hw_bufs_used)
+			wsm_printk(XRADIO_DBG_WARN,
+				   "%s:No pengding, but hw_bufs_used=%d\n",
+				   __func__, hw_priv->hw_bufs_used);
+		/* Ok, everything is flushed. */
+		return true;
+	}
+}
+
+bool wsm_vif_flush_tx(struct xradio_vif *priv)
+{
+	struct xradio_common *hw_priv = priv->hw_priv;
+	long timeout = WSM_CMD_LAST_CHANCE_TIMEOUT;
+	int if_id = priv->if_id;
+
+	/* Flush must be called with TX lock held. */
+	SYS_BUG(!atomic_read(&hw_priv->tx_lock));
+
+	/* First check if we really need to do something.
+	 * It is safe to use unprotected access, as hw_bufs_used
+	 * can only decrements. */
+	if (!hw_priv->hw_bufs_used_vif[if_id])
+		return true;
+
+	if (hw_priv->bh_error) {
+		/* In case of failure do not wait for magic. */
+		wsm_printk(XRADIO_DBG_ERROR, "Fatal error occured, "
+				"will not flush TX.\n");
+		return false;
+	} else {
+		/* Get "oldest" frame, if any frames stuck in firmware,
+		   query all of them until max timeout. */
+		int num = hw_priv->hw_bufs_used_vif[if_id] + 1;
+		while (xradio_query_txpkt_timeout(hw_priv, if_id,
+		       0xffffffff, &timeout)) {
+			if (timeout < 0 || !num) {
+				/* Hmmm... Not good. Frame had stuck in firmware. */
+				wsm_printk(XRADIO_DBG_ERROR,
+					   "%s: if_id=%d, hw_bufs_used_vif=%d, num=%d\n",
+					   __func__, if_id,
+					   hw_priv->hw_bufs_used_vif[priv->if_id], num);
+				hw_priv->bh_error = 1;
+	#ifdef BH_USE_SEMAPHORE
+				up(&hw_priv->bh_sem);
+	#else
+				wake_up(&hw_priv->bh_wq);
+	#endif
+				return false;
+			} else if (wait_event_timeout(hw_priv->bh_evt_wq,
+				      !hw_priv->hw_bufs_used_vif[if_id], timeout) > 0) {
+				return true;
+			}
+			--num;
+		}
+		if (hw_priv->hw_bufs_used_vif[if_id])
+			wsm_printk(XRADIO_DBG_WARN,
+				   "%s:No pengding, but hw_bufs_used_vif=%d\n",
+				   __func__, hw_priv->hw_bufs_used_vif[priv->if_id]);
+		/* Ok, everything is flushed. */
+		return true;
+	}
+}
+
+
+void wsm_unlock_tx(struct xradio_common *hw_priv)
+{
+	int tx_lock;
+	if (hw_priv->bh_error)
+		wsm_printk(XRADIO_DBG_ERROR, "bh_error=%d, wsm_unlock_tx is unsafe\n",
+			   hw_priv->bh_error);
+	else {
+		tx_lock = atomic_sub_return(1, &hw_priv->tx_lock);
+		if (tx_lock < 0) {
+			SYS_BUG(1);
+		} else if (tx_lock == 0) {
+#if BH_PROC_TX
+			xradio_proc_wakeup(hw_priv);
+#endif
+			xradio_bh_wakeup(hw_priv);
+			wsm_printk(XRADIO_DBG_MSG, "TX is unlocked.\n");
+		}
+	}
+}
+
+/* ******************************************************************** */
+/* WSM RX								*/
+int wsm_handle_exception(struct xradio_common *hw_priv, u8 *data, size_t len)
+{
+	struct wsm_buf buf;
+	u32 reason;
+	u32 reg[18];
+	char fname[48];
+	int i = 0;
+
+#ifdef CONFIG_XRADIO_DEBUG
+	static const char * const reason_str[] = {
+		"undefined instruction",
+		"prefetch abort",
+		"data abort",
+		"unknown error",
+	};
+#endif
+
+	buf.begin = buf.data = data;
+	buf.end = &buf.begin[len];
+
+	reason = WSM_GET32(&buf);
+	for (i = 0; i < ARRAY_SIZE(reg); ++i)
+		reg[i] = WSM_GET32(&buf);
+	WSM_GET(&buf, fname, sizeof(fname));
+
+	if (reason < 4) {
+#ifdef SUPPORT_FW_DBG_INF
+		xradio_fw_dbg_set_dump_flag_on_fw_exception();
+#endif
+		wsm_printk(XRADIO_DBG_ERROR, "Firmware exception: %s.\n",
+			   reason_str[reason]);
+	} else {
+		wsm_printk(XRADIO_DBG_ERROR,
+			   "Firmware assert at %.*s, line %d, reason=0x%x\n",
+			       (int)sizeof(fname), fname, reg[1], reg[2]);
+	}
+
+	for (i = 0; i < 12; i += 4) {
+		wsm_printk(XRADIO_DBG_ERROR, "Firmware:" \
+			   "R%d: 0x%.8X, R%d: 0x%.8X, R%d: 0x%.8X, R%d: 0x%.8X, \n",
+			   i + 0, reg[i + 0], i + 1, reg[i + 1],
+			   i + 2, reg[i + 2], i + 3, reg[i + 3]);
+	}
+	wsm_printk(XRADIO_DBG_ERROR, "Firmware:" \
+		   "R12: 0x%.8X, SP: 0x%.8X, LR: 0x%.8X, PC: 0x%.8X, \n",
+		   reg[i + 0], reg[i + 1], reg[i + 2], reg[i + 3]);
+	i += 4;
+	wsm_printk(XRADIO_DBG_ERROR, "Firmware:CPSR: 0x%.8X, SPSR: 0x%.8X\n",
+		   reg[i + 0], reg[i + 1]);
+
+	return 0;
+
+underflow:
+	wiphy_err(hw_priv->hw->wiphy, "Firmware exception.\n");
+	print_hex_dump_bytes("Exception: ", DUMP_PREFIX_NONE, data, len);
+	return -EINVAL;
+}
+
+static int wsm_debug_indication(struct xradio_common *hw_priv,
+						struct wsm_buf *buf)
+{
+	/*for only one debug item.*/
+
+	u32 buf_data = 0;
+
+	u32 dbg_id;
+	u16 dbg_buf_len;
+	u8  dbg_len;
+	u8 *dbg_buf;
+
+	dbg_id = WSM_GET32(buf);
+
+	dbg_buf_len = buf->end - buf->data;
+
+	if (dbg_id == 5) {
+		do {
+			dbg_buf_len = buf->end - buf->data;
+			dbg_len = WSM_GET8(buf);
+			if (dbg_len > dbg_buf_len - sizeof(dbg_len)) {
+				wsm_printk(XRADIO_DBG_ERROR,
+					  "[FW]dbg_len     = %d\n", dbg_len);
+				wsm_printk(XRADIO_DBG_ERROR,
+					  "[FW]dbg_buf_len = %d\n", dbg_buf_len);
+				wsm_printk(XRADIO_DBG_ERROR, "[FW]debug ind err\n");
+				break;
+			}
+			dbg_buf = buf->data;
+			/*print it;*/
+			wsm_printk(XRADIO_DBG_ALWY,  "[FW-LOG] %s", dbg_buf);
+			buf->data += dbg_len;
+		} while (buf->data < buf->end);
+	} else {
+		wsm_printk(XRADIO_DBG_ERROR,  "[FW-DEBUG] DbgId = %d\n", dbg_id);
+		while (buf->end - buf->data >= 4) {
+			buf_data = WSM_GET32(buf);
+			wsm_printk(XRADIO_DBG_ERROR, "[FW-DEBUG] 0x%08X\n", buf_data);
+		}
+	}
+
+	return 0;
+
+underflow:
+	SYS_WARN(1);
+	return -EINVAL;
+}
+
+#if (DGB_XRADIO_HWT)
+extern u8  hwt_testing;
+extern u16 hwt_tx_len;
+extern u16 hwt_tx_num;
+extern int sent_num;
+extern struct timeval hwt_start_time;
+extern struct timeval hwt_end_time;
+int wsm_hwt_tx_confirm(struct xradio_common *hw_priv, struct wsm_buf *buf)
+{
+	u8 num = *(buf->data + 6);
+	u16 *through_put = (u16 *)(buf->data) + 3;
+
+	wsm_printk(XRADIO_DBG_NIY, "%s, num=%d, hw_bufs_used=%d, confirm[7]=%d\n",
+		   __func__, num, hw_priv->hw_bufs_used, *(buf->data+7));
+
+	/*one release is in bh.*/
+	wsm_release_vif_tx_buffer(hw_priv, 0, num - 1);
+	wsm_release_tx_buffer(hw_priv, num - 1);
+
+	/*confirm of last packet, so report the test results.*/
+	if (*(buf->data+7) & 0x01) { /*last packet*/
+		u32 time_int = 0;
+		u32 total    = hwt_tx_num*hwt_tx_len*8;
+		xr_do_gettimeofday(&hwt_end_time);
+		time_int = (hwt_end_time.tv_sec-hwt_start_time.tv_sec)*1000000 + \
+				       (hwt_end_time.tv_usec-hwt_start_time.tv_usec);
+		wsm_printk(XRADIO_DBG_ALWY,
+		    "%s, HIF TX: time=%dms, throughput=%d.%dMbps\n", __func__,
+		    time_int/1000, total/time_int, (total%time_int)*10/time_int);
+		*through_put = (u16)((total*10)/time_int);
+		hwt_tx_len = 0;
+		hwt_tx_num = 0;
+		sent_num   = 0;  /*reset the sent_num*/
+		hwt_testing = 0;
+		return 1;
+	}
+	return 0;
+}
+
+u16 recv_num;
+extern u8  hwt_rx_en;
+extern u16 hwt_rx_len;
+extern u16 hwt_rx_num;
+int wsm_hwt_rx_frames(struct xradio_common *hw_priv, struct wsm_buf *buf)
+{
+
+	wsm_printk(XRADIO_DBG_NIY, "%s, status=%d, len=%d\n", __func__,
+		   *(u16 *)(buf->data+2), *(u16 *)(buf->data+4));
+	recv_num++;
+	if (recv_num >= hwt_rx_num) {  /*last packet*/
+		u32 time_int = 0;
+		u32 total    = recv_num*hwt_rx_len*8;
+		xr_do_gettimeofday(&hwt_end_time);
+		time_int = (hwt_end_time.tv_sec-hwt_start_time.tv_sec)*1000000 + \
+				       (hwt_end_time.tv_usec-hwt_start_time.tv_usec);
+//		wsm_printk(XRADIO_DBG_ALWY,
+//			   "%s, HIF RX: time=%dms, throughput=%d.%dMbps\n",
+//			   __func__, time_int/1000, total/time_int,
+//			   (total%time_int)*10/time_int);
+		hwt_rx_en  = 0;
+		hwt_rx_num = 0;
+		recv_num   = 0;  /*reset the recv_num*/
+//		hwt_testing = 0;	 //set to 0 when 0x404 received
+	}
+
+	return 0;
+}
+
+int wsm_hwt_enc_results(struct xradio_common *hw_priv, struct wsm_buf *buf)
+{
+	wsm_printk(XRADIO_DBG_ALWY,
+		   "%s, status=%d, enc throughput=%d.%02dMbps\n", __func__,
+		   *(u16 *)(buf->data+2), *(u32 *)(buf->data+8),
+		   *(u32 *)(buf->data+12));
+	hwt_testing = 0;
+	return 0;
+}
+
+int wsm_hwt_mic_results(struct xradio_common *hw_priv, struct wsm_buf *buf)
+{
+	wsm_printk(XRADIO_DBG_ALWY,
+		   "%s, status=%d, mic throughput=%d.%02dMbps\n", __func__,
+		   *(u16 *)(buf->data+2), *(u32 *)(buf->data+8),
+		   *(u32 *)(buf->data+12));
+	hwt_testing = 0;
+	return 0;
+}
+#endif /*DGB_XRADIO_HWT*/
+
+#if PERF_INFO_TEST
+struct timeval ind_rx_time;
+
+#endif
+
+int wsm_handle_rx(struct xradio_common *hw_priv, u8 flags, struct sk_buff **skb_p)
+{
+	int ret = 0;
+	struct xradio_vif *priv = NULL;
+	int i = 0;
+	struct wsm_buf wsm_buf;
+	size_t total_len = (*skb_p)->len;
+	struct wsm_hdr *wsm = (struct wsm_hdr *)((*skb_p)->data);
+	int id = __le32_to_cpu(wsm->id) & 0xFFF;
+	int interface_link_id = (id >> 6) & 0x0F;
+#ifdef ROAM_OFFLOAD
+#if 0
+	struct xradio_vif *priv;
+	priv = xrwl_hwpriv_to_vifpriv(hw_priv, interface_link_id);
+	if (unlikely(!priv)) {
+		SYS_WARN(1);
+		return 0;
+	}
+	spin_unlock(&priv->vif_lock);
+#endif
+#endif/*ROAM_OFFLOAD*/
+
+	/* Strip link id. */
+	id &= ~WSM_TX_LINK_ID(WSM_TX_LINK_ID_MAX);
+
+	wsm_buf.begin = (u8 *)&wsm[0];
+	wsm_buf.data = (u8 *)&wsm[1];
+	wsm_buf.end = &wsm_buf.begin[__le32_to_cpu(wsm->len)];
+
+	wsm_printk(XRADIO_DBG_MSG, "<<< 0x%.4X (%zu)\n", id,
+			(size_t)(wsm_buf.end - wsm_buf.begin));
+
+#ifdef CONFIG_XRADIO_ETF
+	if (etf_is_connect()) {
+		if (id == 0x0801) {
+			/* ETF_CONTEXT_OFFSET need to consist with etf fw.*/
+			u8 *pContext = wsm_buf.data + ETF_CONTEXT_OFFSET;
+			xradio_etf_save_context(pContext, (int)(wsm_buf.end - pContext));
+			wsm_startup_indication(hw_priv, &wsm_buf);
+		}
+#if (DGB_XRADIO_HWT)
+		/***************************for HWT ********************************/
+		else if (id == 0x0404) {
+			u16 TestID = *(u16 *)(wsm_buf.data);
+			if (TestID == 1) { /*test frame confirm.*/
+				if (wsm_hwt_tx_confirm(hw_priv, &wsm_buf)) {
+					spin_lock(&hw_priv->wsm_cmd.lock);
+					hw_priv->wsm_cmd.ret = *((u16 *)(wsm_buf.data) + 3);
+					hw_priv->wsm_cmd.done = 1;
+					spin_unlock(&hw_priv->wsm_cmd.lock);
+					wake_up(&hw_priv->wsm_cmd_wq);
+					wsm_printk(XRADIO_DBG_ALWY, "%s:HWT TestID=0x%x Confirm ret=%d\n",
+						   __func__, *(u16 *)(wsm_buf.data), hw_priv->wsm_cmd.ret);
+					return xradio_etf_from_device(skb_p);
+				}
+			} else {
+				spin_lock(&hw_priv->wsm_cmd.lock);
+				hw_priv->wsm_cmd.ret = *((u16 *)(wsm_buf.data) + 1);
+				hw_priv->wsm_cmd.done = 1;
+				spin_unlock(&hw_priv->wsm_cmd.lock);
+				wake_up(&hw_priv->wsm_cmd_wq);
+				hwt_testing = 0;
+				wsm_printk(XRADIO_DBG_ALWY, "%s:HWT TestID=0x%x Confirm ret=%d\n",
+					   __func__, *(u16 *)(wsm_buf.data), hw_priv->wsm_cmd.ret);
+				return xradio_etf_from_device(skb_p);
+			}
+			return 0;
+		} else if (id == 0x0804) {
+			u16 TestID = *(u16 *)(wsm_buf.data);
+			switch (TestID) {
+			case 2:  /*recieve a test frame.*/
+				wsm_hwt_rx_frames(hw_priv, &wsm_buf);
+				break;
+			case 3:  /*enc test result.*/
+				wsm_hwt_enc_results(hw_priv, &wsm_buf);
+				break;
+			case 4:  /*mic test result.*/
+				wsm_hwt_mic_results(hw_priv, &wsm_buf);
+				break;
+			case 5:
+				break;
+			default:
+				wsm_printk(XRADIO_DBG_ERROR,
+					   "HWT ERROR Indication TestID=0x%x\n", TestID);
+				break;
+			}
+			return 0;
+		}
+		/***************************for HWT ********************************/
+#endif /*DGB_XRADIO_HWT*/
+		 else {
+			spin_lock(&hw_priv->wsm_cmd.lock);
+			hw_priv->wsm_cmd.ret  = 0;
+			hw_priv->wsm_cmd.done = 1;
+			spin_unlock(&hw_priv->wsm_cmd.lock);
+			wake_up(&hw_priv->wsm_cmd_wq);
+		}
+		return xradio_etf_from_device(skb_p);
+	}
+#endif
+
+#if (DGB_XRADIO_HWT)
+/***************************for HWT ********************************/
+	if (id == 0x0424) {
+		u16 TestID = *(u16 *)(wsm_buf.data);
+		if (TestID == 1)  /*test frame confirm.*/
+			wsm_hwt_tx_confirm(hw_priv, &wsm_buf);
+		else {
+			spin_lock(&hw_priv->wsm_cmd.lock);
+			hw_priv->wsm_cmd.ret = *((u16 *)(wsm_buf.data) + 1);
+			hw_priv->wsm_cmd.done = 1;
+			spin_unlock(&hw_priv->wsm_cmd.lock);
+			wake_up(&hw_priv->wsm_cmd_wq);
+			wsm_printk(XRADIO_DBG_ALWY, "HWT TestID=0x%x Confirm ret=%d\n",
+				   *(u16 *)(wsm_buf.data), hw_priv->wsm_cmd.ret);
+		}
+		return 0;
+	} else if (id == 0x0824) {
+		u16 TestID = *(u16 *)(wsm_buf.data);
+		switch (TestID) {
+		case 2:  /*recieve a test frame.*/
+			wsm_hwt_rx_frames(hw_priv, &wsm_buf);
+			break;
+		case 3:  /*enc test result.*/
+			wsm_hwt_enc_results(hw_priv, &wsm_buf);
+			break;
+		case 4:  /*mic test result.*/
+			wsm_hwt_mic_results(hw_priv, &wsm_buf);
+			break;
+		case 5:
+			break;
+		default:
+			wsm_printk(XRADIO_DBG_ERROR,
+				   "HWT ERROR Indication TestID=0x%x\n", TestID);
+			break;
+		}
+		return 0;
+	}
+/***************************for HWT ********************************/
+#endif /*DGB_XRADIO_HWT*/
+
+	if (id == 0x404) {
+		DBG_ARRY_ADD(dbg_txconfirm, 0);
+		ret = wsm_tx_confirm(hw_priv, &wsm_buf, interface_link_id);
+#ifdef MCAST_FWDING
+#if 1
+	} else if (id == 0x422) {
+		ret = wsm_give_buffer_confirm(hw_priv, &wsm_buf);
+#endif
+#endif
+
+	} else if (id == 0x41E) {
+		ret = wsm_multi_tx_confirm(hw_priv, &wsm_buf,
+					   interface_link_id);
+	} else if (id & 0x0400) {
+		void *wsm_arg;
+		u16 wsm_cmd;
+
+		/* Do not trust FW too much. Protection against repeated
+		 * response and race condition removal (see above). */
+		spin_lock(&hw_priv->wsm_cmd.lock);
+		wsm_arg = hw_priv->wsm_cmd.arg;
+		wsm_cmd = hw_priv->wsm_cmd.cmd &
+				~WSM_TX_LINK_ID(WSM_TX_LINK_ID_MAX);
+		hw_priv->wsm_cmd.cmd = 0xFFFF;
+		spin_unlock(&hw_priv->wsm_cmd.lock);
+
+		if (SYS_WARN((id & ~0x0400) != wsm_cmd)) {
+			/* Note that any non-zero is a fatal retcode. */
+			ret = -EINVAL;
+			goto out;
+		}
+
+		switch (id) {
+		case 0x0409:
+			/* Note that wsm_arg can be NULL in case of timeout in
+			 * wsm_cmd_send(). */
+			if (likely(wsm_arg))
+				ret = wsm_configuration_confirm(hw_priv,
+								wsm_arg,
+								&wsm_buf);
+			break;
+		case 0x0405:
+			if (likely(wsm_arg))
+				ret = wsm_read_mib_confirm(hw_priv, wsm_arg,
+								&wsm_buf);
+			break;
+		case 0x0406:
+			if (likely(wsm_arg))
+				ret = wsm_write_mib_confirm(hw_priv, wsm_arg,
+							    &wsm_buf,
+							    interface_link_id);
+			break;
+		case 0x040B:
+			if (likely(wsm_arg))
+				ret = wsm_join_confirm(hw_priv, wsm_arg, &wsm_buf);
+			if (ret)
+				wsm_printk(XRADIO_DBG_WARN, "Join confirm Failed!\n");
+			break;
+		case 0x040E: /* 11K measure*/
+			if (likely(wsm_arg))
+				ret = wsm_generic_confirm(hw_priv, wsm_arg, &wsm_buf);
+			if (ret)
+				wsm_printk(XRADIO_DBG_ERROR, "[***11K***] Confirm Error\n");
+
+			break;
+
+#ifdef MCAST_FWDING
+		case 0x0423: /* req buffer cfm*/
+			if (likely(wsm_arg)) {
+				xradio_for_each_vif(hw_priv, priv, i) {
+					if (priv && (priv->join_status == XRADIO_JOIN_STATUS_AP))
+						ret = wsm_request_buffer_confirm(priv,
+								wsm_arg, &wsm_buf);
+				}
+			}
+			break;
+#endif
+
+		case 0x0425:
+			ret = wsm_fw_dbg_confirm(hw_priv, wsm_arg, &wsm_buf);
+
+			if (ret)
+				wsm_printk(XRADIO_DBG_ERROR,
+					"[0x%04x] ret(%d): Confirm Error, msg_len:%d\n",
+					id, ret, wsm->len);
+			break;
+
+		case 0x0407: /* start-scan */
+#ifdef ROAM_OFFLOAD
+			if (hw_priv->auto_scanning) {
+				if (atomic_read(&hw_priv->scan.in_progress)) {
+					hw_priv->auto_scanning = 0;
+				} else {
+					wsm_oper_unlock(hw_priv);
+					up(&hw_priv->scan.lock);
+				}
+			}
+#endif /*ROAM_OFFLOAD*/
+		case 0x0408: /* stop-scan */
+		case 0x040A: /* wsm_reset */
+		case 0x040C: /* add_key */
+		case 0x040D: /* remove_key */
+		case 0x0410: /* wsm_set_pm */
+		case 0x0411: /* set_bss_params */
+		case 0x0412: /* set_tx_queue_params */
+		case 0x0413: /* set_edca_params */
+		case 0x0416: /* switch_channel */
+		case 0x0417: /* start */
+		case 0x0418: /* beacon_transmit */
+		case 0x0419: /* start_find */
+		case 0x041A: /* stop_find */
+		case 0x041B: /* update_ie */
+		case 0x041C: /* map_link */
+			SYS_WARN(wsm_arg != NULL);
+			ret = wsm_generic_confirm(hw_priv, wsm_arg, &wsm_buf);
+			if (ret)
+				wsm_printk(XRADIO_DBG_ERROR,
+					"wsm_generic_confirm "
+					"failed for request 0x%.4X ret=%d.\n",
+					id & ~0x0400, ret);
+			break;
+		default:
+			SYS_BUG(1);
+		}
+
+		spin_lock(&hw_priv->wsm_cmd.lock);
+		hw_priv->wsm_cmd.ret = ret;
+		hw_priv->wsm_cmd.done = 1;
+		spin_unlock(&hw_priv->wsm_cmd.lock);
+		ret = 0; /* Error response from device should ne stop BH. */
+
+		wake_up(&hw_priv->wsm_cmd_wq);
+	} else if (id & 0x0800) {
+		switch (id) {
+		case 0x0801:
+			ret = wsm_startup_indication(hw_priv, &wsm_buf);
+			break;
+		case 0x0804:
+			if (xradio_realloc_resv_skb(hw_priv, *skb_p, flags)) {
+				/* we reuse this skb, because fail to realloc.*/
+				wsm_printk(XRADIO_DBG_WARN,
+					"xradio_realloc_resv_skb drop frames, len=%d.\n",
+					(*skb_p)->len);
+				*skb_p = NULL;
+				ret = 0;
+				goto out;
+			}
+			/*
+			 * if packet len < total length - piggy back length
+			 * then multi receive indication.
+			 */
+			PERF_INFO_GETTIME(&ind_rx_time);
+			if (ROUND4(__le32_to_cpu(wsm->len)) < total_len) {
+				ret = wsm_multi_receive_indication(hw_priv, total_len,
+					&wsm_buf, skb_p);
+			} else {
+				if (__le32_to_cpu(wsm->len) != total_len)
+					wsm_printk(XRADIO_DBG_WARN,
+						"wsm->len=%u, total_len=%zu",
+						__le32_to_cpu(wsm->len), total_len);
+				ret = wsm_receive_indication(hw_priv, interface_link_id,
+					&wsm_buf, skb_p);
+			}
+			PERF_INFO_STAMP(&ind_rx_time, &ind_rx, total_len);
+			break;
+		case 0x0805:
+			ret = wsm_event_indication(hw_priv, &wsm_buf,
+					interface_link_id);
+			break;
+		case 0x0807:
+		    wsm_printk(XRADIO_DBG_ERROR, "[11K]wsm_measure_cmpl_indication\n");
+			ret = wsm_measure_cmpl_indication(hw_priv, &wsm_buf);
+			break;
+		case 0x080A:
+			ret = wsm_channel_switch_indication(hw_priv, &wsm_buf);
+			break;
+		case 0x0809:
+			ret = wsm_set_pm_indication(hw_priv, &wsm_buf);
+			break;
+		case 0x0806:
+#ifdef ROAM_OFFLOAD
+			if (hw_priv->auto_scanning && hw_priv->frame_rcvd) {
+				struct xradio_vif *priv;
+				hw_priv->frame_rcvd = 0;
+				priv = xrwl_hwpriv_to_vifpriv(hw_priv, hw_priv->scan.if_id);
+				if (unlikely(!priv)) {
+					SYS_WARN(1);
+					return 0;
+				}
+					spin_unlock(&priv->vif_lock);
+				if (hw_priv->beacon) {
+					struct wsm_scan_complete *scan_cmpl = \
+						(struct wsm_scan_complete *) \
+						((u8 *)wsm + sizeof(struct wsm_hdr));
+					struct ieee80211_rx_status *rhdr = \
+						IEEE80211_SKB_RXCB(hw_priv->beacon);
+					rhdr->signal = (s8)scan_cmpl->reserved;
+					if (!priv->cqm_use_rssi) {
+						rhdr->signal = rhdr->signal / 2 - 110;
+					}
+					if (!hw_priv->beacon_bkp)
+						hw_priv->beacon_bkp = \
+						skb_copy(hw_priv->beacon, GFP_ATOMIC);
+					mac80211_rx_irqsafe(hw_priv->hw, hw_priv->beacon);
+					hw_priv->beacon = hw_priv->beacon_bkp;
+
+					hw_priv->beacon_bkp = NULL;
+				}
+				wsm_printk(XRADIO_DBG_MSG, \
+				"Send Testmode Event.\n");
+				xradio_testmode_event(priv->hw->wiphy,
+					NL80211_CMD_NEW_SCAN_RESULTS, 0,
+					0, GFP_KERNEL);
+
+			}
+#endif /*ROAM_OFFLOAD*/
+			ret = wsm_scan_complete_indication(hw_priv, &wsm_buf);
+			break;
+		case 0x080B:
+			ret = wsm_find_complete_indication(hw_priv, &wsm_buf);
+			break;
+		case 0x080C:
+			ret = wsm_suspend_resume_indication(hw_priv,
+					interface_link_id, &wsm_buf);
+			break;
+		case 0x080E:
+			wsm_printk(XRADIO_DBG_MSG,  "wsm_debug_indication");
+			ret = wsm_debug_indication(hw_priv, &wsm_buf);
+			break;
+
+		case 0x0825:
+			ret = wsm_fw_dbg_indicate(hw_priv, &wsm_buf);
+
+			if (ret)
+				wsm_printk(XRADIO_DBG_ERROR,
+					"[0x%04x] ret(%d): indicate Error, msg_len:%d\n",
+					id, ret, wsm->len);
+			break;
+
+		default:
+			wsm_printk(XRADIO_DBG_ERROR,  "unknown Indmsg ID=0x%04x, len=%d\n",
+				   wsm->id, wsm->len);
+			break;
+		}
+	} else {
+		SYS_WARN(1);
+		ret = -EINVAL;
+	}
+out:
+	return ret;
+}
+
+static bool wsm_handle_tx_data(struct xradio_vif *priv,
+			       const struct wsm_tx *wsm,
+			       const struct ieee80211_tx_info *tx_info,
+			       struct xradio_txpriv *txpriv,
+			       struct xradio_queue *queue)
+{
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+#ifdef P2P_MULTIVIF
+	struct xradio_vif *p2p_if_vif = NULL;
+#endif
+	bool handled = false;
+	const struct ieee80211_hdr *frame =
+		(struct ieee80211_hdr *) &((u8 *)wsm)[txpriv->offset];
+	__le16 fctl = frame->frame_control;
+	enum {
+		doProbe,
+		doDrop,
+		doJoin,
+		doOffchannel,
+		doWep,
+		doTx,
+	} action = doTx;
+
+	hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+#ifdef P2P_MULTIVIF
+	if (priv->if_id == XRWL_GENERIC_IF_ID)
+		p2p_if_vif = __xrwl_hwpriv_to_vifpriv(hw_priv, 1);
+#endif
+	frame =  (struct ieee80211_hdr *) &((u8 *)wsm)[txpriv->offset];
+	fctl  = frame->frame_control;
+
+	switch (priv->mode) {
+	case NL80211_IFTYPE_STATION:
+	case NL80211_IFTYPE_P2P_DEVICE:
+		if (unlikely(priv->bss_loss_status == XRADIO_BSS_LOSS_CHECKING &&
+				 priv->join_status     == XRADIO_JOIN_STATUS_STA) &&
+				 ieee80211_is_data(fctl)) {
+			spin_lock(&priv->bss_loss_lock);
+			priv->bss_loss_confirm_id = wsm->packetID;
+			priv->bss_loss_status = XRADIO_BSS_LOSS_CONFIRMING;
+			spin_unlock(&priv->bss_loss_lock);
+		} else if (unlikely((priv->join_status <= XRADIO_JOIN_STATUS_MONITOR)
+			   || memcmp(frame->addr1, priv->join_bssid,
+				     sizeof(priv->join_bssid)))) {
+#ifdef P2P_MULTIVIF
+			if (p2p_if_vif &&
+			    (p2p_if_vif->join_status > XRADIO_JOIN_STATUS_MONITOR) &&
+			    (priv->join_status < XRADIO_JOIN_STATUS_MONITOR)) {
+
+				/* Post group formation, frame transmission on p2p0
+				 * interafce should not use offchannel/generic channel.
+				 * Instead, the frame should be transmitted on interafce
+				 * 1. This is needed by wsc fw.
+				 */
+				action = doTx;
+				txpriv->raw_if_id = 1;
+			} else
+#endif
+			if (ieee80211_is_auth(fctl))
+				action = doJoin;
+			else if ((ieee80211_is_deauth(fctl) ||
+				  ieee80211_is_disassoc(fctl)) &&
+				  priv->join_status < XRADIO_JOIN_STATUS_MONITOR)
+			    /* no need to send deauth when STA-unjoined.*/
+				action = doDrop;
+			else if (ieee80211_is_probe_req(fctl))
+				action = doTx;
+			else if (memcmp(frame->addr1, priv->join_bssid,
+					sizeof(priv->join_bssid)) &&
+					(priv->join_status ==
+					XRADIO_JOIN_STATUS_STA) &&
+					(ieee80211_is_data(fctl))) {
+				action = doDrop;
+			} else if (priv->join_status >=
+					XRADIO_JOIN_STATUS_MONITOR)
+				action = doTx;
+			else if (get_interface_id_scanning(hw_priv) != -1) {
+				wsm_printk(XRADIO_DBG_WARN, "Scan ONGOING dropping"
+					   " offchannel eligible frame.\n");
+				action = doDrop;
+			} else {
+				action = doOffchannel;
+				wsm_printk(XRADIO_DBG_WARN, "Offchannel fctl=0x%04x", fctl);
+			}
+		}
+		break;
+	case NL80211_IFTYPE_AP:
+		if (unlikely(!priv->join_status))
+			action = doDrop;
+		else if (unlikely(!(BIT(txpriv->raw_link_id) &
+				(BIT(0) | priv->link_id_map)))) {
+			wsm_printk(XRADIO_DBG_WARN,
+					"A frame with expired link id "
+					"is dropped.\n");
+			action = doDrop;
+		}
+		if (xradio_queue_get_generation(wsm->packetID) >
+				XRADIO_MAX_REQUEUE_ATTEMPTS) {
+			/* HACK!!! WSM324 firmware has tendency to requeue
+			 * multicast frames in a loop, causing performance
+			 * drop and high power consumption of the driver.
+			 * In this situation it is better just to drop
+			 * the problematic frame. */
+			wsm_printk(XRADIO_DBG_WARN,
+					"Too many attempts "
+					"to requeue a frame. "
+					"Frame is dropped, fctl=0x%04x.\n", fctl);
+			action = doDrop;
+		}
+		break;
+	case NL80211_IFTYPE_ADHOC:
+	case NL80211_IFTYPE_MESH_POINT:
+		/*STUB();*/
+	case NL80211_IFTYPE_MONITOR:
+	default:
+		action = doDrop;
+		break;
+	}
+
+	if (action == doTx) {
+		if (unlikely(ieee80211_is_probe_req(fctl))) {
+#ifdef CONFIG_XRADIO_TESTMODE
+			if (hw_priv->enable_advance_scan &&
+				(priv->join_status == XRADIO_JOIN_STATUS_STA) &&
+				(hw_priv->advanceScanElems.scanMode ==
+					XRADIO_SCAN_MEASUREMENT_ACTIVE))
+				/* If Advance Scan is Requested on Active Scan
+				 * then transmit the Probe Request */
+				action = doTx;
+			else
+#endif
+			action = doProbe;
+		} else if ((fctl & __cpu_to_le32(IEEE80211_FCTL_PROTECTED)) &&
+			tx_info->control.hw_key &&
+			unlikely(tx_info->control.hw_key->keyidx !=
+					priv->wep_default_key_id) &&
+			(tx_info->control.hw_key->cipher ==
+					WLAN_CIPHER_SUITE_WEP40 ||
+			 tx_info->control.hw_key->cipher ==
+					WLAN_CIPHER_SUITE_WEP104)) {
+			action = doWep;
+		}
+	}
+
+	switch (action) {
+	case doProbe:
+	{
+		/* An interesting FW "feature". Device filters
+		 * probe responses.
+		 * The easiest way to get it back is to convert
+		 * probe request into WSM start_scan command. */
+		wsm_printk(XRADIO_DBG_MSG, \
+			"Convert probe request to scan.\n");
+		wsm_lock_tx_async(hw_priv);
+		hw_priv->pending_frame_id = __le32_to_cpu(wsm->packetID);
+		queue_delayed_work(hw_priv->workqueue,
+				&hw_priv->scan.probe_work, 0);
+		handled = true;
+	}
+	break;
+	case doDrop:
+	{
+		/* See detailed description of "join" below.
+		 * We are dropping everything except AUTH in non-joined mode. */
+		wsm_printk(XRADIO_DBG_MSG, "Drop frame (0x%.4X).\n", fctl);
+#ifdef CONFIG_XRADIO_TESTMODE
+		SYS_BUG(xradio_queue_remove(hw_priv, queue,
+			__le32_to_cpu(wsm->packetID)));
+#else
+		SYS_BUG(xradio_queue_remove(queue,
+			__le32_to_cpu(wsm->packetID)));
+#endif /*CONFIG_XRADIO_TESTMODE*/
+		handled = true;
+	}
+	break;
+	case doJoin:
+	{
+		/* p2p should disconnect when sta try to join a different channel AP,
+		 * because no good performance in this case.
+		 */
+		struct xradio_vif *p2p_tmp_vif = __xrwl_hwpriv_to_vifpriv(hw_priv, 1);
+		if (priv->if_id == 0 && p2p_tmp_vif) {
+			if (p2p_tmp_vif->join_status >= XRADIO_JOIN_STATUS_STA &&
+			    hw_priv->channel_changed) {
+				wsm_printk(XRADIO_DBG_WARN,
+				    "combo with different channels, p2p disconnect.\n");
+				wsm_send_disassoc_to_self(hw_priv, p2p_tmp_vif);
+			}
+		}
+
+		/* There is one more interesting "feature"
+		 * in FW: it can't do RX/TX before "join".
+		 * "Join" here is not an association,
+		 * but just a syncronization between AP and STA.
+		 * priv->join_status is used only in bh thread and does
+		 * not require protection */
+		wsm_printk(XRADIO_DBG_NIY, "Issue join command.\n");
+		wsm_lock_tx_async(hw_priv);
+		hw_priv->pending_frame_id = __le32_to_cpu(wsm->packetID);
+		if (queue_work(hw_priv->workqueue, &priv->join_work) <= 0)
+			wsm_unlock_tx(hw_priv);
+		handled = true;
+	}
+	break;
+	case doOffchannel:
+	{
+		wsm_printk(XRADIO_DBG_MSG, "Offchannel TX request.\n");
+		wsm_lock_tx_async(hw_priv);
+		hw_priv->pending_frame_id = __le32_to_cpu(wsm->packetID);
+		if (queue_work(hw_priv->workqueue, &priv->offchannel_work) <= 0)
+			wsm_unlock_tx(hw_priv);
+		handled = true;
+	}
+	break;
+	case doWep:
+	{
+		wsm_printk(XRADIO_DBG_MSG, "Issue set_default_wep_key.\n");
+		wsm_lock_tx_async(hw_priv);
+		priv->wep_default_key_id = tx_info->control.hw_key->keyidx;
+		hw_priv->pending_frame_id = __le32_to_cpu(wsm->packetID);
+		if (queue_work(hw_priv->workqueue, &priv->wep_key_work) <= 0)
+			wsm_unlock_tx(hw_priv);
+		handled = true;
+	}
+	break;
+	case doTx:
+	{
+#if 0
+		/* Kept for history. If you want to implement wsm->more,
+		 * make sure you are able to send a frame after that. */
+		wsm->more = (count > 1) ? 1 : 0;
+		if (wsm->more) {
+			/* HACK!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+			 * It's undocumented in WSM spec, but XRADIO hangs
+			 * if 'more' is set and no TX is performed due to TX
+			 * buffers limitation. */
+			if (priv->hw_bufs_used + 1 ==
+					priv->wsm_caps.numInpChBufs)
+				wsm->more = 0;
+		}
+
+		/* BUG!!! FIXME: we can't use 'more' at all: we don't know
+		 * future. It could be a request from upper layer with TX lock
+		 * requirements (scan, for example). If "more" is set device
+		 * will not send data and wsm_tx_lock() will fail...
+		 * It's not obvious how to fix this deadlock. Any ideas?
+		 * As a workaround more is set to 0. */
+		wsm->more = 0;
+#endif /* 0 */
+
+		if (ieee80211_is_deauth(fctl) &&
+				priv->mode != NL80211_IFTYPE_AP) {
+			/* Shedule unjoin work */
+			wsm_printk(XRADIO_DBG_WARN, "Issue unjoin command(TX).\n");
+#if 0
+			wsm->more = 0;
+#endif /* 0 */
+			queue_delayed_work(hw_priv->workqueue, &priv->unjoin_delayed_work, 1 * HZ);
+		}
+	}
+	break;
+	}
+	return handled;
+}
+
+static int xradio_get_prio_queue(struct xradio_vif *priv,
+				 u32 link_id_map, int *total)
+{
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	static u32 urgent;
+	struct wsm_edca_queue_params *edca;
+	unsigned score, best = -1;
+	int winner = -1;
+	int queued;
+	int i;
+	urgent = BIT(priv->link_id_after_dtim) | BIT(priv->link_id_uapsd);
+
+	/* search for a winner using edca params */
+	for (i = 0; i < 4; ++i) {
+		queued = xradio_queue_get_num_queued(priv,
+				&hw_priv->tx_queue[i],
+				link_id_map);
+		if (!queued)
+			continue;
+		*total += queued;
+		edca = &priv->edca.params[i];
+		score = ((edca->aifns + edca->cwMin) << 16) +
+				(edca->cwMax - edca->cwMin) *
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0))
+				(random32() & 0xFFFF);
+#else
+				(get_random_int() & 0xFFFF);
+#endif
+		if (score < best && (winner < 0 || i != 3)) {
+			best = score;
+			winner = i;
+		}
+	}
+
+	/* override winner if bursting */
+	if (winner >= 0 && hw_priv->tx_burst_idx >= 0 &&
+			winner != hw_priv->tx_burst_idx &&
+			!xradio_queue_get_num_queued(priv,
+				&hw_priv->tx_queue[winner],
+				link_id_map & urgent) &&
+			xradio_queue_get_num_queued(priv,
+				&hw_priv->tx_queue[hw_priv->tx_burst_idx],
+				link_id_map))
+		winner = hw_priv->tx_burst_idx;
+
+	return winner;
+}
+
+static int wsm_get_tx_queue_and_mask(struct xradio_vif *priv,
+				     struct xradio_queue **queue_p,
+				     u32 *tx_allowed_mask_p,
+				     bool *more)
+{
+	struct xradio_common *hw_priv = xrwl_vifpriv_to_hwpriv(priv);
+	int idx;
+	u32 tx_allowed_mask;
+	int total = 0;
+
+	/* Search for a queue with multicast frames buffered */
+	if (priv->tx_multicast) {
+		tx_allowed_mask = BIT(priv->link_id_after_dtim);
+		idx = xradio_get_prio_queue(priv,
+				tx_allowed_mask, &total);
+		if (idx >= 0) {
+			*more = total > 1;
+			goto found;
+		}
+	}
+
+	/* Search for unicast traffic */
+	tx_allowed_mask = ~priv->sta_asleep_mask;
+	tx_allowed_mask |= BIT(priv->link_id_uapsd);
+	if (priv->sta_asleep_mask) {
+		tx_allowed_mask |= priv->pspoll_mask;
+		tx_allowed_mask &= ~BIT(priv->link_id_after_dtim);
+	} else {
+		tx_allowed_mask |= BIT(priv->link_id_after_dtim);
+	}
+	idx = xradio_get_prio_queue(priv,
+			tx_allowed_mask, &total);
+	if (idx < 0)
+		return -ENOENT;
+
+found:
+	*queue_p = &hw_priv->tx_queue[idx];
+	*tx_allowed_mask_p = tx_allowed_mask;
+	return 0;
+}
+
+int wsm_get_tx(struct xradio_common *hw_priv, u8 **data,
+	       size_t *tx_len, int *burst, int *vif_selected)
+{
+	struct wsm_tx *wsm = NULL;
+	struct ieee80211_tx_info *tx_info;
+	struct xradio_queue *queue = NULL;
+	int queue_num;
+	u32 tx_allowed_mask = 0;
+	struct xradio_txpriv *txpriv = NULL;
+#ifdef P2P_MULTIVIF
+	int first = 1;
+	int tmp_if_id = -1;
+#endif
+#if BH_PROC_TX
+	u8 *tx_item = NULL;
+#endif
+	/*
+	 * Count was intended as an input for wsm->more flag.
+	 * During implementation it was found that wsm->more
+	 * is not usable, see details above. It is kept just
+	 * in case you would like to try to implement it again.
+	 */
+	int count = 0;
+#ifdef P2P_MULTIVIF
+	int if_pending = XRWL_MAX_VIFS - 1;
+#else
+	int if_pending = 1;
+#endif
+
+	/* More is used only for broadcasts. */
+	bool more = false;
+
+	count = xradio_itp_get_tx(hw_priv, data, tx_len, burst);
+	if (count)
+		return count;
+#if !BH_PROC_TX
+	if (hw_priv->wsm_cmd.ptr) {
+		++count;
+		spin_lock(&hw_priv->wsm_cmd.lock);
+		SYS_BUG(!hw_priv->wsm_cmd.ptr);
+		*data = hw_priv->wsm_cmd.ptr;
+		*tx_len = hw_priv->wsm_cmd.len;
+		*burst = 1;
+		*vif_selected = -1;
+		spin_unlock(&hw_priv->wsm_cmd.lock);
+	} else {
+#endif
+		for (;;) {
+			int ret;
+			struct xradio_vif *priv;
+#if 0
+			int num_pending_vif0, num_pending_vif1;
+#endif
+			if (atomic_add_return(0, &hw_priv->tx_lock)) {
+				wsm_printk(XRADIO_DBG_NIY, "%s:tx_lock!", __func__);
+				break;
+			}
+			if (xradio_is_bt_block(hw_priv)) {
+				wsm_printk(XRADIO_DBG_NIY,
+					"%s:BT is busy, lock tx!", __func__);
+				break;
+			}
+			/* Keep one buffer reserved for commands. Note
+			   that, hw_bufs_used has already been incremented
+			   before reaching here. */
+			if (hw_priv->hw_bufs_used >=
+					hw_priv->wsm_caps.numInpChBufs) {
+				DBG_INT_ADD(tx_buf_limit);
+				break;
+			}
+#ifdef P2P_MULTIVIF
+			if (first) {
+				tmp_if_id = hw_priv->if_id_selected;
+				hw_priv->if_id_selected = 2;
+			}
+#endif
+			priv = wsm_get_interface_for_tx(hw_priv);
+			/* go to next interface ID to select next packet */
+#ifdef P2P_MULTIVIF
+			if (first) {
+				hw_priv->if_id_selected = tmp_if_id;
+				first = 0;
+			} else
+#endif
+				hw_priv->if_id_selected ^= 1;
+
+			/* There might be no interface before add_interface
+			 * call */
+			if (!priv) {
+				if (if_pending) {
+#ifdef P2P_MULTIVIF
+					if_pending--;
+#else
+					if_pending = 0;
+#endif
+					continue;
+				}
+				break;
+			}
+
+#if 0
+			if (((priv->if_id == 0) &&
+			(hw_priv->hw_bufs_used_vif[0] >=
+						XRWL_FW_VIF0_THROTTLE)) ||
+			((priv->if_id == 1) &&
+			(hw_priv->hw_bufs_used_vif[1] >=
+						XRWL_FW_VIF1_THROTTLE))) {
+				spin_unlock(&priv->vif_lock);
+				if (if_pending) {
+					if_pending = 0;
+					continue;
+				}
+				break;
+			}
+#endif
+
+			/* This can be removed probably: xradio_vif will not
+			 * be in hw_priv->vif_list (as returned from
+			 * wsm_get_interface_for_tx) until it's fully
+			 * enabled, so statement above will take case of that*/
+			if (!atomic_read(&priv->enabled)) {
+				spin_unlock(&priv->vif_lock);
+				break;
+			}
+
+			/* TODO:COMBO: Find the next interface for which
+			* packet needs to be found */
+			spin_lock_bh(&priv->ps_state_lock);
+			ret = wsm_get_tx_queue_and_mask(priv, &queue,
+					&tx_allowed_mask, &more);
+			queue_num = queue - hw_priv->tx_queue;
+
+			if (priv->buffered_multicasts &&
+					(ret || !more) &&
+					(priv->tx_multicast ||
+					 !priv->sta_asleep_mask)) {
+				priv->buffered_multicasts = false;
+				if (priv->tx_multicast) {
+					priv->tx_multicast = false;
+					queue_work(hw_priv->workqueue,
+						&priv->multicast_stop_work);
+				}
+			}
+
+			spin_unlock_bh(&priv->ps_state_lock);
+
+			if (ret) {
+				spin_unlock(&priv->vif_lock);
+#ifdef P2P_MULTIVIF
+				if (if_pending) {
+#else
+				if (if_pending == 1) {
+#endif
+#ifdef P2P_MULTIVIF
+					if_pending--;
+#else
+					if_pending = 0;
+#endif
+					continue;
+				}
+				break;
+			}
+#if BH_PROC_TX
+			if (xradio_queue_get(queue,
+					priv->if_id,
+					tx_allowed_mask,
+					&wsm, &tx_info, &txpriv, &tx_item)) {
+				spin_unlock(&priv->vif_lock);
+				if_pending = 0;
+				continue;
+			}
+#else
+			if (xradio_queue_get(queue,
+					priv->if_id,
+					tx_allowed_mask,
+					&wsm, &tx_info, &txpriv)) {
+				wsm_printk(XRADIO_DBG_WARN, "%s, if_id=%d(enable=%d), tx_allowed_mask=%08x, " \
+					"queue_num=%d, queued_item=%d, pending_item=%d" \
+					"link_id_after_dtim=%d, link_id_uapsd=%d, tx_multicast=%d, " \
+					"pspoll_mask=%d, sta_asleep_mask=%d\n",
+					__func__, priv->if_id, atomic_read(&priv->enabled),
+					tx_allowed_mask, queue_num, queue->num_queued, queue->num_pending,
+					priv->link_id_after_dtim, priv->link_id_uapsd,
+					priv->tx_multicast, priv->pspoll_mask, priv->sta_asleep_mask);
+				spin_unlock(&priv->vif_lock);
+				if_pending = 0;
+				continue;
+			}
+#endif
+
+#ifdef ROC_DEBUG
+#ifndef P2P_MULTIVIF
+			{
+				struct ieee80211_hdr *hdr =
+				(struct ieee80211_hdr *)
+					&((u8 *)wsm)[txpriv->offset];
+
+				wsm_printk(XRADIO_DBG_ERROR, "QGET-1 %x, off_id %d, "
+					       " if_id %d\n",
+						hdr->frame_control,
+						txpriv->offchannel_if_id,
+						priv->if_id);
+			}
+#else
+			{
+				struct ieee80211_hdr *hdr =
+				(struct ieee80211_hdr *)
+					&((u8 *)wsm)[txpriv->offset];
+
+				wsm_printk(XRADIO_DBG_ERROR, "QGET-1 %x, off_id %d, "
+						   " if_id %d\n",
+						hdr->frame_control,
+						txpriv->raw_if_id,
+						priv->if_id);
+			}
+#endif
+#endif
+
+			if (wsm_handle_tx_data(priv, wsm,
+					tx_info, txpriv, queue)) {
+				spin_unlock(&priv->vif_lock);
+				if_pending = 0;
+				continue;  /* Handled by WSM */
+			}
+
+			wsm->hdr.id &= __cpu_to_le16(
+					~WSM_TX_IF_ID(WSM_TX_IF_ID_MAX));
+#ifdef P2P_MULTIVIF
+			if (txpriv->raw_if_id)
+				wsm->hdr.id |= cpu_to_le16(
+					WSM_TX_IF_ID(txpriv->raw_if_id));
+#else
+			if (txpriv->offchannel_if_id)
+				wsm->hdr.id |= cpu_to_le16(
+					WSM_TX_IF_ID(txpriv->offchannel_if_id));
+#endif
+			else
+				wsm->hdr.id |= cpu_to_le16(
+					WSM_TX_IF_ID(priv->if_id));
+
+			*vif_selected = priv->if_id;
+#ifdef ROC_DEBUG
+#ifndef P2P_MULTIVIF
+
+			{
+				struct ieee80211_hdr *hdr =
+				(struct ieee80211_hdr *)
+					&((u8 *)wsm)[txpriv->offset];
+
+				wsm_printk(XRADIO_DBG_ERROR, "QGET-2 %x, off_id %d, "
+					       " if_id %d\n",
+						hdr->frame_control,
+						txpriv->offchannel_if_id,
+						priv->if_id);
+			}
+#else
+			{
+				struct ieee80211_hdr *hdr =
+				(struct ieee80211_hdr *)
+					&((u8 *)wsm)[txpriv->offset];
+
+				wsm_printk(XRADIO_DBG_ERROR, "QGET-2 %x, off_id %d, "
+						   " if_id %d\n",
+						hdr->frame_control,
+						txpriv->raw_if_id,
+						priv->if_id);
+			}
+#endif
+#endif
+
+			priv->pspoll_mask &= ~BIT(txpriv->raw_link_id);
+
+#if BH_PROC_TX
+			*data = tx_item;
+#else
+			*data = (u8 *)wsm;
+#endif
+			*tx_len = __le16_to_cpu(wsm->hdr.len);
+
+			/* allow bursting if txop is set */
+			if (priv->edca.params[queue_num].txOpLimit)
+				*burst = min(*burst,
+					(int)xradio_queue_get_num_queued(priv,
+						queue, tx_allowed_mask) + 1);
+			else
+				*burst = 1;
+
+			/* store index of bursting queue */
+			if (*burst > 1)
+				hw_priv->tx_burst_idx = queue_num;
+			else
+				hw_priv->tx_burst_idx = -1;
+
+			if (more) {
+				struct ieee80211_hdr *hdr =
+					(struct ieee80211_hdr *)
+					&((u8 *)wsm)[txpriv->offset];
+				if (strstr(&priv->ssid[0], "6.1.12")) {
+					if (hdr->addr1[0] & 0x01) {
+						hdr->frame_control |=
+						cpu_to_le16(IEEE80211_FCTL_MOREDATA);
+					}
+				} else {
+					/* more buffered multicast/broadcast frames
+					*  ==> set MoreData flag in IEEE 802.11 header
+					*  to inform PS STAs */
+					hdr->frame_control |=
+					cpu_to_le16(IEEE80211_FCTL_MOREDATA);
+				}
+			}
+			wsm_printk(XRADIO_DBG_MSG, ">>> 0x%.4X (%zu) %p %c\n",
+				0x0004, *tx_len, wsm,
+				wsm->more ? 'M' : ' ');
+			++count;
+			spin_unlock(&priv->vif_lock);
+			break;
+		}
+#if !BH_PROC_TX
+	}
+#endif
+
+	return count;
+}
+
+void wsm_txed(struct xradio_common *hw_priv, u8 *data)
+{
+	if (data == hw_priv->wsm_cmd.ptr) {
+		spin_lock(&hw_priv->wsm_cmd.lock);
+		hw_priv->wsm_cmd.ptr = NULL;
+		spin_unlock(&hw_priv->wsm_cmd.lock);
+	}
+}
+
+/* ******************************************************************** */
+/* WSM buffer								*/
+
+void wsm_buf_init(struct wsm_buf *buf, int size)
+{
+	SYS_BUG(buf->begin);
+	buf->begin = xr_kmalloc(size, true);
+	buf->end = buf->begin ? &buf->begin[size] : buf->begin;
+	wsm_buf_reset(buf);
+}
+
+void wsm_buf_deinit(struct wsm_buf *buf)
+{
+	if (likely(buf->begin))
+		kfree(buf->begin);
+	buf->begin = buf->data = buf->end = NULL;
+}
+
+static void wsm_buf_reset(struct wsm_buf *buf)
+{
+	if (likely(buf->begin)) {
+		buf->data = &buf->begin[4];
+		*(u32 *)buf->begin = 0;
+	} else
+		buf->data = buf->begin;
+}
+
+static int wsm_buf_reserve(struct wsm_buf *buf, size_t extra_size)
+{
+	size_t pos = buf->data - buf->begin;
+	size_t size = pos + extra_size;
+
+	size = xr_sdio_blksize_align(size);
+	buf->begin = xr_krealloc(buf->begin, size, true);
+	if (buf->begin) {
+		buf->data = &buf->begin[pos];
+		buf->end = &buf->begin[size];
+		return 0;
+	} else {
+		buf->end = buf->data = buf->begin;
+		return -ENOMEM;
+	}
+}
+
+static struct xradio_vif *
+			wsm_get_interface_for_tx(struct xradio_common *hw_priv)
+{
+	struct xradio_vif *priv = NULL, *i_priv;
+	int i = hw_priv->if_id_selected;
+
+	if (1) { /*TODO:COMBO*/
+		spin_lock(&hw_priv->vif_list_lock);
+		i_priv = hw_priv->vif_list[i] ?
+			 xrwl_get_vif_from_ieee80211(hw_priv->vif_list[i]) : NULL;
+		if (i_priv && atomic_read(&i_priv->enabled)) {
+			priv = i_priv;
+			spin_lock(&priv->vif_lock);
+		}
+		/* TODO:COMBO:
+		* Find next interface based on TX bitmap announced by the FW
+		* Find next interface based on load balancing */
+		spin_unlock(&hw_priv->vif_list_lock);
+	} else {
+		priv = xrwl_hwpriv_to_vifpriv(hw_priv, 0);
+	}
+
+	return priv;
+}
+
+static inline int get_interface_id_scanning(struct xradio_common *hw_priv)
+{
+	if (hw_priv->scan.req || hw_priv->scan.direct_probe)
+		return hw_priv->scan.if_id;
+	else
+		return -1;
+}
diff -Naurp a/drivers/net/wireless/xr829/wlan/wsm.h b/drivers/net/wireless/xr829/wlan/wsm.h
--- a/drivers/net/wireless/xr829/wlan/wsm.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/wsm.h	2022-08-27 01:22:42.974539938 +0300
@@ -0,0 +1,3100 @@
+/*
+ * wsm interfaces for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef XRADIO_WSM_H_INCLUDED
+#define XRADIO_WSM_H_INCLUDED
+
+#include <linux/spinlock.h>
+
+struct xradio_common;
+
+#define WSM_MSG_ID_MASK 	(0x0C3F)
+
+/* Bands */
+/* Radio band 2.412 -2.484 GHz. */
+#define WSM_PHY_BAND_2_4G		(0)
+
+/* Radio band 4.9375-5.8250 GHz. */
+#define WSM_PHY_BAND_5G			(1)
+
+/* Transmit rates */
+/* 1   Mbps            ERP-DSSS */
+#define WSM_TRANSMIT_RATE_1		(0)
+
+/* 2   Mbps            ERP-DSSS */
+#define WSM_TRANSMIT_RATE_2		(1)
+
+/* 5.5 Mbps            ERP-CCK, ERP-PBCC (Not supported) */
+/* #define WSM_TRANSMIT_RATE_5		(2) */
+
+/* 11  Mbps            ERP-CCK, ERP-PBCC (Not supported) */
+/* #define WSM_TRANSMIT_RATE_11		(3) */
+
+/* 22  Mbps            ERP-PBCC (Not supported) */
+/* #define WSM_TRANSMIT_RATE_22		(4) */
+
+/* 33  Mbps            ERP-PBCC (Not supported) */
+/* #define WSM_TRANSMIT_RATE_33		(5) */
+
+/* 6   Mbps   (3 Mbps) ERP-OFDM, BPSK coding rate 1/2 */
+#define WSM_TRANSMIT_RATE_6		(6)
+
+/* 9   Mbps (4.5 Mbps) ERP-OFDM, BPSK coding rate 3/4 */
+#define WSM_TRANSMIT_RATE_9		(7)
+
+/* 12  Mbps  (6 Mbps)  ERP-OFDM, QPSK coding rate 1/2 */
+#define WSM_TRANSMIT_RATE_12		(8)
+
+/* 18  Mbps  (9 Mbps)  ERP-OFDM, QPSK coding rate 3/4 */
+#define WSM_TRANSMIT_RATE_18		(9)
+
+/* 24  Mbps (12 Mbps)  ERP-OFDM, 16QAM coding rate 1/2 */
+#define WSM_TRANSMIT_RATE_24		(10)
+
+/* 36  Mbps (18 Mbps)  ERP-OFDM, 16QAM coding rate 3/4 */
+#define WSM_TRANSMIT_RATE_36		(11)
+
+/* 48  Mbps (24 Mbps)  ERP-OFDM, 64QAM coding rate 1/2 */
+#define WSM_TRANSMIT_RATE_48		(12)
+
+/* 54  Mbps (27 Mbps)  ERP-OFDM, 64QAM coding rate 3/4 */
+#define WSM_TRANSMIT_RATE_54		(13)
+
+/* 6.5 Mbps            HT-OFDM, BPSK coding rate 1/2 */
+#define WSM_TRANSMIT_RATE_HT_6		(14)
+
+/* 13  Mbps            HT-OFDM, QPSK coding rate 1/2 */
+#define WSM_TRANSMIT_RATE_HT_13		(15)
+
+/* 19.5 Mbps           HT-OFDM, QPSK coding rate 3/4 */
+#define WSM_TRANSMIT_RATE_HT_19		(16)
+
+/* 26  Mbps            HT-OFDM, 16QAM coding rate 1/2 */
+#define WSM_TRANSMIT_RATE_HT_26		(17)
+
+/* 39  Mbps            HT-OFDM, 16QAM coding rate 3/4 */
+#define WSM_TRANSMIT_RATE_HT_39		(18)
+
+/* 52  Mbps            HT-OFDM, 64QAM coding rate 2/3 */
+#define WSM_TRANSMIT_RATE_HT_52		(19)
+
+/* 58.5 Mbps           HT-OFDM, 64QAM coding rate 3/4 */
+#define WSM_TRANSMIT_RATE_HT_58		(20)
+
+/* 65  Mbps            HT-OFDM, 64QAM coding rate 5/6 */
+#define WSM_TRANSMIT_RATE_HT_65		(21)
+
+/* Scan types */
+/* Foreground scan */
+#define WSM_SCAN_TYPE_FOREGROUND	(0)
+
+/* Background scan */
+#define WSM_SCAN_TYPE_BACKGROUND	(1)
+
+/* Auto scan */
+#define WSM_SCAN_TYPE_AUTO		(2)
+
+/* Scan flags */
+/* Forced background scan means if the station cannot */
+/* enter the power-save mode, it shall force to perform a */
+/* background scan. Only valid when ScanType is */
+/* background scan. */
+#define WSM_SCAN_FLAG_FORCE_BACKGROUND	(BIT(0))
+
+/* The WLAN device scans one channel at a time so */
+/* that disturbance to the data traffic is minimized. */
+#define WSM_SCAN_FLAG_SPLIT_METHOD	(BIT(1))
+
+/* Preamble Type. Long if not set. */
+#define WSM_SCAN_FLAG_SHORT_PREAMBLE	(BIT(2))
+
+/* 11n Tx Mode. Mixed if not set. */
+#define WSM_SCAN_FLAG_11N_GREENFIELD	(BIT(3))
+
+#define WSM_FLAG_MAC_INSTANCE_1	(BIT(4))
+
+#define WSM_FLAG_MAC_INSTANCE_0	(~(BIT(4)))
+
+/* Scan constraints */
+/* Maximum number of channels to be scanned. */
+#define WSM_SCAN_MAX_NUM_OF_CHANNELS	(48)
+
+/* The maximum number of SSIDs that the device can scan for. */
+#define WSM_SCAN_MAX_NUM_OF_SSIDS	(2)
+#ifdef CONFIG_XRADIO_TESTMODE
+/* Transmit flags */
+/* Start Expiry time from the receipt of tx request */
+#define WSM_TX_FLAG_EXPIRY_TIME		(BIT(0))
+#endif /*CONFIG_XRADIO_TESTMODE*/
+
+/* Power management modes */
+/* 802.11 Active mode */
+#define WSM_PSM_ACTIVE			(0)
+
+/* 802.11 PS mode */
+#define WSM_PSM_PS			BIT(0)
+
+/* Fast Power Save bit */
+#define WSM_PSM_FAST_PS_FLAG		BIT(7)
+
+/* IP ALLOCATED bit, used to control firmware power-save state */
+#define WSM_PSM_IP_ALLOCATED		BIT(2)
+
+/* Dynamic aka Fast power save */
+#define WSM_PSM_FAST_PS			(BIT(0) | BIT(7))
+
+/* Undetermined */
+/* Note : Undetermined status is reported when the */
+/* NULL data frame used to advertise the PM mode to */
+/* the AP at Pre or Post Background Scan is not Acknowledged */
+#define WSM_PSM_UNKNOWN			BIT(1)
+
+/* Queue IDs */
+/* best effort/legacy */
+#define WSM_QUEUE_BEST_EFFORT		(0)
+
+/* background */
+#define WSM_QUEUE_BACKGROUND		(1)
+
+/* video */
+#define WSM_QUEUE_VIDEO			(2)
+
+/* voice */
+#define WSM_QUEUE_VOICE			(3)
+
+/* HT TX parameters */
+/* Non-HT */
+#define WSM_HT_TX_NON_HT		(0)
+
+/* Mixed format */
+#define WSM_HT_TX_MIXED			(1)
+
+/* Greenfield format */
+#define WSM_HT_TX_GREENFIELD		(2)
+
+/* STBC allowed */
+#define WSM_HT_TX_STBC			(BIT(7))
+
+/* EPTA prioirty flags for BT Coex */
+/* default epta priority */
+#define WSM_EPTA_PRIORITY_DEFAULT	4
+/* use for normal data */
+#define WSM_EPTA_PRIORITY_DATA		4
+/* use for connect/disconnect/roaming*/
+#define WSM_EPTA_PRIORITY_MGT		5
+/* use for action frames */
+#define WSM_EPTA_PRIORITY_ACTION	5
+/* use for AC_VI data */
+#define WSM_EPTA_PRIORITY_VIDEO		5
+/* use for AC_VO data */
+#define WSM_EPTA_PRIORITY_VOICE		6
+/* use for EAPOL exchange */
+#define WSM_EPTA_PRIORITY_EAPOL		7
+
+/* TX status */
+/* Frame was sent aggregated */
+/* Only valid for WSM_SUCCESS status. */
+#define WSM_TX_STATUS_AGGREGATION	(BIT(0))
+
+/* Host should requeue this frame later. */
+/* Valid only when status is WSM_REQUEUE. */
+#define WSM_TX_STATUS_REQUEUE		(BIT(1))
+
+/* Normal Ack */
+#define WSM_TX_STATUS_NORMAL_ACK	(0<<2)
+
+/* No Ack */
+#define WSM_TX_STATUS_NO_ACK		(1<<2)
+
+/* No explicit acknowledgement */
+#define WSM_TX_STATUS_NO_EXPLICIT_ACK	(2<<2)
+
+/* Block Ack */
+/* Only valid for WSM_SUCCESS status. */
+#define WSM_TX_STATUS_BLOCK_ACK		(3<<2)
+
+/* RX status */
+/* Unencrypted */
+#define WSM_RX_STATUS_UNENCRYPTED	(0<<0)
+
+/* WEP */
+#define WSM_RX_STATUS_WEP		(1<<0)
+
+/* TKIP */
+#define WSM_RX_STATUS_TKIP		(2<<0)
+
+/* AES */
+#define WSM_RX_STATUS_AES		(3<<0)
+
+/* WAPI */
+#define WSM_RX_STATUS_WAPI		(4<<0)
+
+/* Macro to fetch encryption subfield. */
+#define WSM_RX_STATUS_ENCRYPTION(status) ((status) & 0x07)
+
+/* Frame was part of an aggregation */
+#define WSM_RX_STATUS_AGGREGATE		(BIT(3))
+
+/* Frame was first in the aggregation */
+#define WSM_RX_STATUS_AGGREGATE_FIRST	(BIT(4))
+
+/* Frame was last in the aggregation */
+#define WSM_RX_STATUS_AGGREGATE_LAST	(BIT(5))
+
+/* Indicates a defragmented frame */
+#define WSM_RX_STATUS_DEFRAGMENTED	(BIT(6))
+
+/* Indicates a Beacon frame */
+#define WSM_RX_STATUS_BEACON		(BIT(7))
+
+/* Indicates STA bit beacon TIM field */
+#define WSM_RX_STATUS_TIM		(BIT(8))
+
+/* Indicates Beacon frame's virtual bitmap contains multicast bit */
+#define WSM_RX_STATUS_MULTICAST		(BIT(9))
+
+/* Indicates frame contains a matching SSID */
+#define WSM_RX_STATUS_MATCHING_SSID	(BIT(10))
+
+/* Indicates frame contains a matching BSSI */
+#define WSM_RX_STATUS_MATCHING_BSSI	(BIT(11))
+
+/* Indicates More bit set in Framectl field */
+#define WSM_RX_STATUS_MORE_DATA		(BIT(12))
+
+/* Indicates frame received during a measurement process */
+#define WSM_RX_STATUS_MEASUREMENT	(BIT(13))
+
+/* Indicates frame received as an HT packet */
+#define WSM_RX_STATUS_HT		(BIT(14))
+
+/* Indicates frame received with STBC */
+#define WSM_RX_STATUS_STBC		(BIT(15))
+
+/* Indicates Address 1 field matches dot11StationId */
+#define WSM_RX_STATUS_ADDRESS1		(BIT(16))
+
+/* Indicates Group address present in the Address 1 field */
+#define WSM_RX_STATUS_GROUP		(BIT(17))
+
+/* Indicates Broadcast address present in the Address 1 field */
+#define WSM_RX_STATUS_BROADCAST		(BIT(18))
+
+/* Indicates group key used with encrypted frames */
+#define WSM_RX_STATUS_GROUP_KEY		(BIT(19))
+
+/* Macro to fetch encryption key index. */
+#define WSM_RX_STATUS_KEY_IDX(status)	(((status) >> 20) & 0x0F)
+
+#ifdef SUPPORT_HT40
+
+#define WSM_RX_LINK_ID_GET(f)    (((f) >> 25) & 0x0f) /* bit28:25 */
+
+#define WSM_RX_BANDWIDTH_GET(f)  (((f) >> 29) & 0x03) /* bit30:29 */
+#define WSM_RX_BANDWIDTH_20M     0x0
+#define WSM_RX_BANDWIDTH_40M     0x1
+#define WSM_RX_BANDWIDTH_80M     0x2
+
+#endif
+
+/* Frame Control field starts at Frame offset + 2 */
+#define WSM_TX_2BYTES_SHIFT		(BIT(7))
+
+/* Join mode */
+/* IBSS */
+#define WSM_JOIN_MODE_IBSS		(0)
+
+/* BSS */
+#define WSM_JOIN_MODE_BSS		(1)
+
+/* PLCP preamble type */
+/* For long preamble */
+#define WSM_JOIN_PREAMBLE_LONG		(0)
+
+/* For short preamble (Long for 1Mbps) */
+#define WSM_JOIN_PREAMBLE_SHORT		(1)
+
+/* For short preamble (Long for 1 and 2Mbps) */
+#define WSM_JOIN_PREAMBLE_SHORT_2	(2)
+
+/* Join flags */
+/* Unsynchronized */
+#define WSM_JOIN_FLAGS_UNSYNCRONIZED	BIT(0)
+/* The BSS owner is a P2P GO */
+#define WSM_JOIN_FLAGS_P2P_GO		BIT(1)
+/* Force to join BSS with the BSSID and the
+ * SSID specified without waiting for beacons. The
+ * ProbeForJoin parameter is ignored. */
+#define WSM_JOIN_FLAGS_FORCE		BIT(2)
+/* Give probe request/response higher
+ * priority over the BT traffic */
+#define WSM_JOIN_FLAGS_PRIO		BIT(3)
+
+/* Key types */
+#define WSM_KEY_TYPE_WEP_DEFAULT	(0)
+#define WSM_KEY_TYPE_WEP_PAIRWISE	(1)
+#define WSM_KEY_TYPE_TKIP_GROUP		(2)
+#define WSM_KEY_TYPE_TKIP_PAIRWISE	(3)
+#define WSM_KEY_TYPE_AES_GROUP		(4)
+#define WSM_KEY_TYPE_AES_PAIRWISE	(5)
+#define WSM_KEY_TYPE_WAPI_GROUP		(6)
+#define WSM_KEY_TYPE_WAPI_PAIRWISE	(7)
+#define WSM_KEY_TYPE_IGTK_GROUP		(8)
+
+/* Key indexes */
+#define WSM_KEY_MAX_INDEX		(10)
+
+/* ACK policy */
+#define WSM_ACK_POLICY_NORMAL		(0)
+#define WSM_ACK_POLICY_NO_ACK		(1)
+
+/* Start modes */
+#define WSM_START_MODE_AP		(0)	/* Mini AP */
+#define WSM_START_MODE_P2P_GO		(1)	/* P2P GO */
+#define WSM_START_MODE_P2P_DEV		(2)	/* P2P device */
+#define WSM_START_MODE_MONITOR		(3)	/* Monitor */
+
+/* SetAssociationMode MIB flags */
+#ifdef SUPPORT_HT40
+
+#define WSM_ASSOCIATION_MODE_USE_PHY_MODE_CFG		(BIT(0))
+#define WSM_ASSOCIATION_MODE_USE_BASIC_RATE_SET		(BIT(1))
+#define WSM_ASSOCIATION_MODE_USE_MPDU_START_SPACING	(BIT(2))
+
+#else
+
+#define WSM_ASSOCIATION_MODE_USE_PREAMBLE_TYPE		(BIT(0))
+#define WSM_ASSOCIATION_MODE_USE_HT_MODE		(BIT(1))
+#define WSM_ASSOCIATION_MODE_USE_BASIC_RATE_SET		(BIT(2))
+#define WSM_ASSOCIATION_MODE_USE_MPDU_START_SPACING	(BIT(3))
+#define WSM_ASSOCIATION_MODE_SNOOP_ASSOC_FRAMES		(BIT(4))
+
+#endif
+
+/* RcpiRssiThreshold MIB flags */
+#define WSM_RCPI_RSSI_THRESHOLD_ENABLE	(BIT(0))
+#define WSM_RCPI_RSSI_USE_RSSI		(BIT(1))
+#define WSM_RCPI_RSSI_DONT_USE_UPPER	(BIT(2))
+#define WSM_RCPI_RSSI_DONT_USE_LOWER	(BIT(3))
+
+/* Update-ie constants */
+#define WSM_UPDATE_IE_BEACON		(BIT(0))
+#define WSM_UPDATE_IE_PROBE_RESP	(BIT(1))
+#define WSM_UPDATE_IE_PROBE_REQ		(BIT(2))
+
+/* BT defines */
+#define BT_LINK_TPYE_INQUIRY  9
+#define BT_LINK_TYPE_DEFAULT 73
+#define BT_MAX_BLOCK_TIME    15000  /* ms */
+
+/* WSM events */
+/* Error */
+#define WSM_EVENT_ERROR			(0)
+
+/* BSS lost */
+#define WSM_EVENT_BSS_LOST		(1)
+
+/* BSS regained */
+#define WSM_EVENT_BSS_REGAINED		(2)
+
+/* Radar detected */
+#define WSM_EVENT_RADAR_DETECTED	(3)
+
+/* RCPI or RSSI threshold triggered */
+#define WSM_EVENT_RCPI_RSSI		(4)
+
+/* BT inactive */
+#define WSM_EVENT_BT_INACTIVE		(5)
+
+/* BT active */
+#define WSM_EVENT_BT_ACTIVE		(6)
+
+#define WSM_EVENT_PS_MODE_ERROR         (7)
+
+#define WSM_EVENT_PAS_EVENT         (8)
+
+#define WSM_EVENT_INACTIVITY		(9)
+
+/* MAC Addr Filter */
+#define WSM_MIB_ID_MAC_ADDR_FILTER	0x1030
+
+/* MIB IDs */
+/* 4.1  dot11StationId */
+#define WSM_MIB_ID_DOT11_STATION_ID		0x0000
+
+/* 4.2  dot11MaxtransmitMsduLifeTime */
+#define WSM_MIB_ID_DOT11_MAX_TRANSMIT_LIFTIME	0x0001
+
+/* 4.3  dot11MaxReceiveLifeTime */
+#define WSM_MIB_ID_DOT11_MAX_RECEIVE_LIFETIME	0x0002
+
+/* 4.4  dot11SlotTime */
+#define WSM_MIB_ID_DOT11_SLOT_TIME		0x0003
+
+/* 4.5  dot11GroupAddressesTable */
+#define WSM_MIB_ID_DOT11_GROUP_ADDRESSES_TABLE	0x0004
+#define WSM_MAX_GRP_ADDRTABLE_ENTRIES		8
+
+/* 4.6  dot11WepDefaultKeyId */
+#define WSM_MIB_ID_DOT11_WEP_DEFAULT_KEY_ID	0x0005
+
+/* 4.7  dot11CurrentTxPowerLevel */
+#define WSM_MIB_ID_DOT11_CURRENT_TX_POWER_LEVEL	0x0006
+
+/* 4.8  dot11RTSThreshold */
+#define WSM_MIB_ID_DOT11_RTS_THRESHOLD		0x0007
+
+/* Huanglu add for firmware debug control */
+#define WSM_MIB_ID_FW_DEBUG_CONTROL		0x0008
+
+/* for read/write registers from firmware*/
+#define WSM_MIB_ID_RW_FW_REG		0x0009
+
+/* for Set max number of mpdus in a-mpdu*/
+#define WSM_MIB_ID_SET_AMPDU_NUM		0x000a
+
+/* for tx-ampdu-len-adaption */
+#define WSM_MIB_ID_SET_TALA_PARA		0x000b
+
+/* for set TPA param */
+#define WSM_MIB_ID_SET_TPA_PARAM		0x000c
+
+/* 4.9  NonErpProtection */
+#define WSM_MIB_ID_NON_ERP_PROTECTION		0x1000
+
+/* 4.10 ArpIpAddressesTable */
+#define WSM_MIB_ID_ARP_IP_ADDRESSES_TABLE	0x1001
+#define WSM_MAX_ARP_IP_ADDRTABLE_ENTRIES	1
+
+/* 4.11 TemplateFrame */
+#define WSM_MIB_ID_TEMPLATE_FRAME		0x1002
+
+/* 4.12 RxFilter */
+#define WSM_MIB_ID_RX_FILTER			0x1003
+
+/* 4.13 BeaconFilterTable */
+#define WSM_MIB_ID_BEACON_FILTER_TABLE		0x1004
+
+/* 4.14 BeaconFilterEnable */
+#define WSM_MIB_ID_BEACON_FILTER_ENABLE		0x1005
+
+/* 4.15 OperationalPowerMode */
+#define WSM_MIB_ID_OPERATIONAL_POWER_MODE	0x1006
+
+/* 4.16 BeaconWakeUpPeriod */
+#define WSM_MIB_ID_BEACON_WAKEUP_PERIOD		0x1007
+
+/* 4.17 RcpiRssiThreshold */
+#define WSM_MIB_ID_RCPI_RSSI_THRESHOLD		0x1009
+
+/* 4.18 StatisticsTable */
+#define WSM_MIB_ID_STATISTICS_TABLE		0x100A
+
+/* 4.19 IbssPsConfig */
+#define WSM_MIB_ID_IBSS_PS_CONFIG		0x100B
+
+/* 4.20 CountersTable */
+#define WSM_MIB_ID_COUNTERS_TABLE		0x100C
+#define WSM_MIB_ID_AMPDUCOUNTERS_TABLE		0x1036
+#define WSM_MIB_ID_TXPIPE_TABLE		0x1037
+#define WSM_MIB_ID_BACKOFF_DBG		0x1038
+#define WSM_MIB_ID_BACKOFF_CTRL		0x1039
+
+/*requery packet status*/
+#define WSM_MIB_ID_REQ_PKT_STATUS	0x1040
+
+/*TPA debug informations*/
+#define WSM_MIB_ID_TPA_DEBUG_INFO	0x1041
+
+/*tx power informations*/
+#define WSM_MIB_ID_TX_POWER_INFO	0x1042
+
+/*some hardware information*/
+#define WSM_MIB_ID_HW_INFO	        0x1043
+
+/*use for changing mac address of interface*/
+#define WSM_MIB_ID_CHANGE_MAC		0x1046
+
+/*epta status information*/
+#define WSM_MIB_ID_EPTA_STAT		0x1060
+#define WSM_MIB_ID_EPTA_STAT_CTRL	0x1061
+
+/*get device temperature*/
+#define WSM_MIB_ID_GET_TEMPERATURE		0x1080
+
+/* 4.21 BlockAckPolicy */
+#define WSM_MIB_ID_BLOCK_ACK_POLICY		0x100E
+
+/* 4.22 OverrideInternalTxRate */
+#define WSM_MIB_ID_OVERRIDE_INTERNAL_TX_RATE	0x100F
+
+/* 4.23 SetAssociationMode */
+#define WSM_MIB_ID_SET_ASSOCIATION_MODE		0x1010
+
+/* 4.24 UpdateEptaConfigData */
+#define WSM_MIB_ID_UPDATE_EPTA_CONFIG_DATA	0x1011
+
+/* 4.25 SelectCcaMethod */
+#define WSM_MIB_ID_SELECT_CCA_METHOD		0x1012
+
+/* 4.26 SetUpasdInformation */
+#define WSM_MIB_ID_SET_UAPSD_INFORMATION	0x1013
+
+/* 4.27 SetAutoCalibrationMode  WBF00004073 */
+#define WSM_MIB_ID_SET_AUTO_CALIBRATION_MODE	0x1015
+
+/* 4.28 SetTxRateRetryPolicy */
+#define WSM_MIB_ID_SET_TX_RATE_RETRY_POLICY	0x1016
+
+/* 4.29 SetHostMessageTypeFilter */
+#define WSM_MIB_ID_SET_HOST_MSG_TYPE_FILTER	0x1017
+
+/* 4.30 P2PFindInfo */
+#define WSM_MIB_ID_P2P_FIND_INFO		0x1018
+
+/* 4.31 P2PPsModeInfo */
+#define WSM_MIB_ID_P2P_PS_MODE_INFO		0x1019
+
+/* 4.32 SetEtherTypeDataFrameFilter */
+#define WSM_MIB_ID_SET_ETHERTYPE_DATAFRAME_FILTER 0x101A
+
+/* 4.33 SetUDPPortDataFrameFilter */
+#define WSM_MIB_ID_SET_UDPPORT_DATAFRAME_FILTER	0x101B
+
+/* 4.34 SetMagicDataFrameFilter */
+#define WSM_MIB_ID_SET_MAGIC_DATAFRAME_FILTER	0x101C
+#define WSM_MIB_ID_SET_HOST_SLEEP	0x1050
+
+/* This is the end of specification. */
+
+/* 4.35 P2PDeviceInfo */
+#define WSM_MIB_ID_P2P_DEVICE_INFO		0x101D
+
+/* 4.36 SetWCDMABand */
+#define WSM_MIB_ID_SET_WCDMA_BAND		0x101E
+
+/* 4.37 GroupTxSequenceCounter */
+#define WSM_MIB_ID_GRP_SEQ_COUNTER		0x101F
+
+/* 4.38 ProtectedMgmtPolicy */
+#define WSM_MIB_ID_PROTECTED_MGMT_POLICY	0x1020
+
+/* 4.39 SetHtProtection */
+#define WSM_MID_ID_SET_HT_PROTECTION		0x1021
+
+/* 4.40 GPIO Command */
+#define WSM_MIB_ID_GPIO_COMMAND			0x1022
+
+/* 4.41 TSF Counter Value */
+#define WSM_MIB_ID_TSF_COUNTER			0x1023
+
+/* Test Purposes Only */
+#define WSM_MIB_ID_BLOCK_ACK_INFO		0x100D
+
+/* 4.42 UseMultiTxConfMessage */
+#define WSM_MIB_USE_MULTI_TX_CONF		0x1024
+
+/* 4.43 Keep-alive period */
+#define WSM_MIB_ID_KEEP_ALIVE_PERIOD		0x1025
+
+/* 4.44 Disable BSSID filter */
+#define WSM_MIB_ID_DISABLE_BSSID_FILTER		0x1026
+
+/* Inactivity */
+#define WSM_MIB_ID_SET_INACTIVITY		0x1035
+
+/* MAC Addr Filter */
+#define WSM_MIB_ID_MAC_ADDR_FILTER		0x1030
+
+#ifdef MCAST_FWDING
+/* 4.51 Set Forwarding Offload */
+#define WSM_MIB_ID_FORWARDING_OFFLOAD		0x1033
+#endif
+
+#ifdef IPV6_FILTERING
+/* IpV6 Addr Filter */
+/* 4.52 Neighbor solicitation IPv6 address table */
+#define WSM_MIB_IP_IPV6_ADDR_FILTER		0x1032
+#define WSM_MIB_ID_NS_IP_ADDRESSES_TABLE	0x1034
+#define WSM_MAX_NDP_IP_ADDRTABLE_ENTRIES	1
+#endif /*IPV6_FILTERING*/
+
+/* Frame template types */
+#define WSM_FRAME_TYPE_PROBE_REQUEST	(0)
+#define WSM_FRAME_TYPE_BEACON		(1)
+#define WSM_FRAME_TYPE_NULL		(2)
+#define WSM_FRAME_TYPE_QOS_NULL		(3)
+#define WSM_FRAME_TYPE_PS_POLL		(4)
+#define WSM_FRAME_TYPE_PROBE_RESPONSE	(5)
+#define WSM_FRAME_TYPE_ARP_REPLY        (6)
+
+#ifdef IPV6_FILTERING
+#define WSM_FRAME_TYPE_NA               (7)
+#endif /*IPV6_FILTERING*/
+
+#define WSM_FRAME_GREENFIELD		(0x80)	/* See 4.11 */
+
+/* Status */
+/* The WSM firmware has completed a request */
+/* successfully. */
+#define WSM_STATUS_SUCCESS              (0)
+
+/* This is a generic failure code if other error codes do */
+/* not apply. */
+#define WSM_STATUS_FAILURE              (1)
+
+/* A request contains one or more invalid parameters. */
+#define WSM_INVALID_PARAMETER           (2)
+
+/* The request cannot perform because the device is in */
+/* an inappropriate mode. */
+#define WSM_ACCESS_DENIED               (3)
+
+/* The frame received includes a decryption error. */
+#define WSM_STATUS_DECRYPTFAILURE       (4)
+
+/* A MIC failure is detected in the received packets. */
+#define WSM_STATUS_MICFAILURE           (5)
+
+/* The transmit request failed due to retry limit being */
+/* exceeded. */
+#define WSM_STATUS_RETRY_EXCEEDED       (6)
+
+/* The transmit request failed due to MSDU life time */
+/* being exceeded. */
+#define WSM_STATUS_TX_LIFETIME_EXCEEDED (7)
+
+/* The link to the AP is lost. */
+#define WSM_STATUS_LINK_LOST            (8)
+
+/* No key was found for the encrypted frame */
+#define WSM_STATUS_NO_KEY_FOUND         (9)
+
+/* Jammer was detected when transmitting this frame */
+#define WSM_STATUS_JAMMER_DETECTED      (10)
+
+/* The message should be requeued later. */
+/* This is applicable only to Transmit */
+#define WSM_REQUEUE                     (11)
+
+/* Advanced filtering options */
+#define WSM_MAX_FILTER_ELEMENTS		(4)
+
+#define WSM_FILTER_ACTION_IGNORE	(0)
+#define WSM_FILTER_ACTION_FILTER_IN	(1)
+#define WSM_FILTER_ACTION_FILTER_OUT	(2)
+
+#define WSM_FILTER_PORT_TYPE_DST	(0)
+#define WSM_FILTER_PORT_TYPE_SRC	(1)
+
+
+
+struct wsm_hdr {
+	__le16 len;
+	__le16 id;
+};
+
+#define WSM_TX_SEQ_MAX			(7)
+#define WSM_TX_SEQ(seq)			\
+		((seq & WSM_TX_SEQ_MAX) << 13)
+#define WSM_TX_LINK_ID_MAX		(0x0F)
+#define WSM_TX_LINK_ID(link_id)		\
+		((link_id & WSM_TX_LINK_ID_MAX) << 6)
+
+#define WSM_TX_IF_ID_MAX		(0x0F)
+#define WSM_TX_IF_ID(if_id)		\
+		((if_id & WSM_TX_IF_ID_MAX) << 6)
+
+#define MAX_BEACON_SKIP_TIME_MS 1000
+
+#ifdef FPGA_SETUP
+#define WSM_CMD_LAST_CHANCE_TIMEOUT (HZ * 9 / 2)
+#else
+#define WSM_CMD_LAST_CHANCE_TIMEOUT (HZ * 15)
+#endif
+#define WSM_CMD_EXTENDED_TIMEOUT (HZ * 20 / 2)
+
+#define WSM_RI_GET_PEER_ID_FROM_FLAGS(_f)         (((_f)&(0xF<<25)>>25))
+
+
+/* ******************************************************************** */
+
+#ifdef SUPPORT_HT40
+
+#define MODEM_F_B_DSSS		(0x01)
+#define MODEM_F_A_OFDM		(0x02)
+#define MODEM_F_N_OFDM		(0x04)
+#define MODEM_F_V_OFDM		(0x08)
+
+#define	PRIMARY_CH_1ST		(0x00)
+#define PRIMARY_CH_2ND		(0x01)
+#define PRIMARY_CH_3RD		(0x02)
+#define PRIMARY_CH_4TH		(0x03)
+
+#define PREAMBLE_L		(0x00)
+#define PREAMBLE_S_L1		(0x01)
+#define PREAMBLE_S_L12		(0x02)
+
+#define CHAN_WIDTH_20MHz	(0x00)
+#define CHAN_WIDTH_10MHz	(0x01)
+#define CHAN_WIDTH_40MHz	(0x02)
+
+struct phy_mode_cfg {
+	u16	ModemFlags:4,
+		ChWidthCfg:2,
+		PriChCfg:2,
+		BandCfg:1,
+		Reserved:2,
+		STBC_Enable:1,
+		PreambleCfg:2,
+		SGI_Enable:1,
+		GF_Enable:1;
+};
+
+#endif
+
+/* ******************************************************************** */
+/* WSM capcbility							*/
+#define WSM_FW_LABEL 128
+struct wsm_caps {
+	u16 numInpChBufs;
+	u16 sizeInpChBuf;
+	u16 hardwareId;
+	u16 hardwareSubId;
+	u16 firmwareCap;
+	u16 firmwareType;
+	u16 firmwareApiVer;
+	u16 firmwareBuildNumber;
+	u16 firmwareVersion;
+	char fw_label[WSM_FW_LABEL+2];
+	u32 firmwareConfig[4];
+	int firmwareReady;
+};
+static inline u32 wsm_version(u32 ver, u32 build)
+{
+	return (u32)((ver<<16) | build);
+}
+#define GET_WSM_VERSION(wsm) wsm_version(wsm.firmwareVersion, wsm.firmwareBuildNumber)
+#define WSM_VERSION_BF(wsm, v, b) (GET_WSM_VERSION(wsm) < wsm_version(v, b))
+#define WSM_VERSION_AF(wsm, v, b) (GET_WSM_VERSION(wsm) > wsm_version(v, b))
+#define WSM_VERSION_EQ(wsm, v, b) (GET_WSM_VERSION(wsm) == wsm_version(v, b))
+
+#define WSM_CAPS_2_4_GHZ(wsm)      (wsm.firmwareCap & (1<<0))
+#define WSM_CAPS_5_0_GHZ(wsm)      (wsm.firmwareCap & (1<<1))
+#define WSM_CAPS_11N_TO_11BG(wsm)  (wsm.firmwareCap & (1<<5))
+
+/* ******************************************************************** */
+/* WSM commands								*/
+
+struct wsm_tx_power_range {
+	int min_power_level;
+	int max_power_level;
+	u32 stepping;
+};
+
+/* 3.1 */
+struct wsm_configuration {
+	/* [in] */ u32 dot11MaxTransmitMsduLifeTime;
+	/* [in] */ u32 dot11MaxReceiveLifeTime;
+	/* [in] */ u32 dot11RtsThreshold;
+	/* [in, out] */ u8 *dot11StationId;
+	/* [in] */ const void *dpdData;
+	/* [in] */ size_t dpdData_size;
+	/* [out] */ u8 dot11FrequencyBandsSupported;
+	/* [out] */ u32 supportedRateMask;
+	/* [out] */ struct wsm_tx_power_range txPowerRange[2];
+};
+
+int wsm_configuration(struct xradio_common *hw_priv,
+		      struct wsm_configuration *arg,
+		      int if_id);
+
+/* 3.3 */
+struct wsm_reset {
+	/* [in] */ int link_id;
+	/* [in] */ bool reset_statistics;
+};
+
+int wsm_reset(struct xradio_common *hw_priv, const struct wsm_reset *arg,
+	      int if_id);
+void wsm_upper_restart(struct xradio_common *hw_priv);
+void wsm_query_work(struct work_struct *work);
+
+/* 3.5 */
+int wsm_read_mib(struct xradio_common *hw_priv, u16 mibId, void *buf,
+		 size_t buf_size, size_t arg_size);
+
+/* 3.7 */
+int wsm_write_mib(struct xradio_common *hw_priv, u16 mibId, void *buf,
+		  size_t buf_size, int if_id);
+
+/* 3.9 */
+struct wsm_ssid {
+	u8 ssid[32];
+	u32 length;
+};
+
+struct wsm_scan_ch {
+	u16 number;
+	u32 minChannelTime;
+	u32 maxChannelTime;
+	u32 txPowerLevel;
+};
+
+/* 3.13 */
+struct wsm_scan_complete {
+	/* WSM_STATUS_... */
+	u32 status;
+
+	/* WSM_PSM_... */
+	u8 psm;
+
+	/* Number of channels that the scan operation completed. */
+	u8 numChannels;
+#ifdef ROAM_OFFLOAD
+	u16 reserved;
+#endif /*ROAM_OFFLOAD*/
+};
+
+typedef void (*wsm_scan_complete_cb) (struct xradio_common *hw_priv,
+				      struct wsm_scan_complete *arg);
+
+/* 3.9 */
+
+#ifdef SUPPORT_HT40
+
+#define SCANTYPE_MASK    0x03
+#define SCANTYPE_SHIFT   6
+#define SCANFLAG_MASK    0x3f
+
+static inline void SET_SCAN_TYPE(u8 *flag, u8 t)
+{
+	*flag &= ~(SCANTYPE_MASK << SCANTYPE_SHIFT);
+	*flag |= (t & SCANTYPE_MASK) << SCANTYPE_SHIFT;
+}
+
+static inline void SET_SCAN_FLAG(u8 *flag, u8 f)
+{
+	*flag |= (f & SCANFLAG_MASK);
+}
+
+static inline void CLR_SCAN_FLAG(u8 *flag, u8 f)
+{
+	*flag &= ~(f & SCANFLAG_MASK);
+}
+
+#endif
+
+#ifdef SUPPORT_HT40
+
+struct wsm_scan {
+	/* WSM_PHY_BAND_... */
+	/* [in] */ u8 band;
+
+    /* bit7:6--WSM_SCAN_TYPE... */
+	/* bit5:0--WSM_SCAN_FLAG... */
+	/* [in] */ u8 scanFlags;
+
+	/* WSM_TRANSMIT_RATE_... */
+	/* [in] */ u16 TransmitRateEntry;
+
+	/* Interval period in TUs that the device shall the re- */
+	/* execute the requested scan. Max value supported by the device */
+	/* is 256s. */
+	/* [in] */ u32 autoScanInterval;
+
+	/* Number of probe requests (per SSID) sent to one (1) */
+	/* channel. Zero (0) means that none is send, which */
+	/* means that a passive scan is to be done. Value */
+	/* greater than zero (0) means that an active scan is to */
+	/* be done. */
+	/* [in] */ u8 numOfProbeRequests;
+
+	/* Number of channels to be scanned. */
+	/* Maximum value is WSM_SCAN_MAX_NUM_OF_CHANNELS. */
+	/* [in] */ u8 numOfChannels;
+
+	/* Number of SSID provided in the scan command (this */
+	/* is zero (0) in broadcast scan) */
+	/* The maximum number of SSIDs is WSM_SCAN_MAX_NUM_OF_SSIDS. */
+	/* [in] */ u8 numOfSSIDs;
+
+	/* The delay time (in microseconds) period */
+	/* before sending a probe-request. */
+	/* [in] */ u8 probeDelay;
+
+	/* SSIDs to be scanned [numOfSSIDs]; */
+	/* [in] */ struct wsm_ssid *ssids;
+
+	/* Channels to be scanned [numOfChannels]; */
+	/* [in] */ struct wsm_scan_ch *ch;
+};
+
+#else
+
+struct wsm_scan {
+	/* WSM_PHY_BAND_... */
+	/* [in] */ u8 band;
+
+	/* WSM_SCAN_TYPE_... */
+	/* [in] */ u8 scanType;
+
+	/* WSM_SCAN_FLAG_... */
+	/* [in] */ u8 scanFlags;
+
+	/* WSM_TRANSMIT_RATE_... */
+	/* [in] */ u8 maxTransmitRate;
+
+	/* Interval period in TUs that the device shall the re- */
+	/* execute the requested scan. Max value supported by the device */
+	/* is 256s. */
+	/* [in] */ u32 autoScanInterval;
+
+	/* Number of probe requests (per SSID) sent to one (1) */
+	/* channel. Zero (0) means that none is send, which */
+	/* means that a passive scan is to be done. Value */
+	/* greater than zero (0) means that an active scan is to */
+	/* be done. */
+	/* [in] */ u32 numOfProbeRequests;
+
+	/* Number of channels to be scanned. */
+	/* Maximum value is WSM_SCAN_MAX_NUM_OF_CHANNELS. */
+	/* [in] */ u8 numOfChannels;
+
+	/* Number of SSID provided in the scan command (this */
+	/* is zero (0) in broadcast scan) */
+	/* The maximum number of SSIDs is WSM_SCAN_MAX_NUM_OF_SSIDS. */
+	/* [in] */ u8 numOfSSIDs;
+
+	/* The delay time (in microseconds) period */
+	/* before sending a probe-request. */
+	/* [in] */ u8 probeDelay;
+
+	/* SSIDs to be scanned [numOfSSIDs]; */
+	/* [in] */ struct wsm_ssid *ssids;
+
+	/* Channels to be scanned [numOfChannels]; */
+	/* [in] */ struct wsm_scan_ch *ch;
+};
+
+#endif
+
+int wsm_scan(struct xradio_common *hw_priv, const struct wsm_scan *arg,
+			int if_id);
+
+/* 3.11 */
+int wsm_stop_scan(struct xradio_common *hw_priv, int if_id);
+
+/* 3.14 */
+
+#ifdef SUPPORT_HT40
+
+struct wsm_tx_confirm {
+	/* Packet identifier used in wsm_tx. */
+	/* [out] */ u32 packetID;
+
+	/* WSM_STATUS_... */
+	/* [out] */ u32 status;
+
+	/* WSM_TRANSMIT_RATE_... */
+	/* [out] */ u16 txedRateEntry;
+
+	/* The number of times the frame was transmitted */
+	/* without receiving an acknowledgement. */
+	/* [out] */ u8 ackFailures;
+
+	/* WSM_TX_STATUS_... */
+	/* [out] */ u8 flags;
+
+	/* rate feed back */
+	/* [out] u32 rate_try[3]; */
+
+	u16	RateTry[6];
+
+	/* The total time in microseconds that the frame spent in */
+	/* the WLAN device before transmission as completed. */
+	/* [out] */ u32 mediaDelay;
+
+	/* The total time in microseconds that the frame spent in */
+	/* the WLAN device before transmission was started. */
+	/* [out] */ u32 txQueueDelay;
+
+	/* [out]*/ u32 link_id;
+
+	/*[out]*/ int if_id;
+};
+
+#else
+
+struct wsm_tx_confirm {
+	/* Packet identifier used in wsm_tx. */
+	/* [out] */ u32 packetID;
+
+	/* WSM_STATUS_... */
+	/* [out] */ u32 status;
+
+	/* WSM_TRANSMIT_RATE_... */
+	/* [out] */ u8 txedRate;
+
+	/* The number of times the frame was transmitted */
+	/* without receiving an acknowledgement. */
+	/* [out] */ u8 ackFailures;
+
+	/* WSM_TX_STATUS_... */
+	/* [out] */ u16 flags;
+
+	/*rate feed back*/
+	/* [out] */ u32 rate_try[3];
+
+	/* The total time in microseconds that the frame spent in */
+	/* the WLAN device before transmission as completed. */
+	/* [out] */ u32 mediaDelay;
+
+	/* The total time in microseconds that the frame spent in */
+	/* the WLAN device before transmission was started. */
+	/* [out] */ u32 txQueueDelay;
+
+	/* [out]*/ u32 link_id;
+
+	/*[out]*/ int if_id;
+};
+
+#endif
+
+/* 3.15 */
+typedef void (*wsm_tx_confirm_cb) (struct xradio_common *hw_priv,
+				   struct wsm_tx_confirm *arg);
+
+/* Note that ideology of wsm_tx struct is different against the rest of
+ * WSM API. wsm_hdr is /not/ a caller-adapted struct to be used as an input
+ * argument for WSM call, but a prepared bytestream to be sent to firmware.
+ * It is filled partly in xradio_tx, partly in low-level WSM code.
+ * Please pay attention once again: ideology is different.
+ *
+ * Legend:
+ * - [in]: xradio_tx must fill this field.
+ * - [wsm]: the field is filled by low-level WSM.
+ */
+
+#ifdef SUPPORT_HT40
+
+struct wsm_tx {
+	/* common WSM header */
+	/* [in/wsm] */ struct wsm_hdr hdr;
+
+	/* Packet identifier that meant to be used in completion. */
+	/* [in] */ __le32 packetID;
+
+	/* WSM_QUEUE_... */
+	/* [in] */ u8 queueId;
+
+	/* True: another packet is pending on the host for transmission. */
+	/* [wsm] */ u8 more;
+
+	/* [in] */ u8 DataOffset;
+
+	/* PTA Priority */
+	/* [in] */ u8 EptaPriority;
+
+	/* WSM_TRANSMIT_RATE_... */
+	/* [in] */ u16 TxRateEntry;   /* first rate entry. */
+
+	/* Tx Rate Retry Policy */
+	/* [in] */ u8 TxPolicyIndex;
+
+	/* 0 - Start expiry time from first Tx attempt (default) */
+	/* 1 - Start expiry time from receipt of Tx Request */
+	/* [in] */ u8 ExpireTimeSetting;
+
+	/* The elapsed time in TUs, after the initial transmission */
+	/* of an MSDU, after which further attempts to transmit */
+	/* the MSDU shall be terminated. Overrides the global */
+	/* dot11MaxTransmitMsduLifeTime setting [optional] */
+	/* Device will set the default value if this is 0. */
+	/* [wsm] */ __le32 expireTime;
+
+	/* Should be 0. */
+	/* [in] */ __le32 reserved;
+};
+
+#else
+
+struct wsm_tx {
+	/* common WSM header */
+	/* [in/wsm] */ struct wsm_hdr hdr;
+
+	/* Packet identifier that meant to be used in completion. */
+	/* [in] */ __le32 packetID;
+
+	/* WSM_TRANSMIT_RATE_... */
+	/* [in] */ u8 maxTxRate;
+
+	/* WSM_QUEUE_... */
+	/* [in] */ u8 queueId;
+
+	/* True: another packet is pending on the host for transmission. */
+	/* [wsm] */ u8 more;
+
+	/* Bit 0 = 0 - Start expiry time from first Tx attempt (default) */
+	/* Bit 0 = 1 - Start expiry time from receipt of Tx Request */
+	/* Bits 3:1  - PTA Priority */
+	/* Bits 6:4  - Tx Rate Retry Policy */
+	/* Bit 7 - Reserved */
+	/* [in] */ u8 flags;
+
+	/* Should be 0. */
+	/* [in] */ __le32 reserved;
+
+	/* The elapsed time in TUs, after the initial transmission */
+	/* of an MSDU, after which further attempts to transmit */
+	/* the MSDU shall be terminated. Overrides the global */
+	/* dot11MaxTransmitMsduLifeTime setting [optional] */
+	/* Device will set the default value if this is 0. */
+	/* [wsm] */ __le32 expireTime;
+
+	/* WSM_HT_TX_... */
+	/* [in] */ __le32 htTxParameters;
+};
+
+#endif
+
+/* = sizeof(generic hi hdr) + sizeof(wsm hdr) + sizeof(alignment) */
+#define WSM_TX_EXTRA_HEADROOM (28)
+
+/* 3.16 */
+struct wsm_rx {
+	/* WSM_STATUS_... */
+	/* [out] */ u32 status;
+
+	/* Specifies the channel of the received packet. */
+	/* [out] */ u16 channelNumber;
+
+#ifdef SUPPORT_HT40
+
+	/* WSM_TRANSMIT_RATE_... */
+	/* [out] */ u16 rxedRateEntry;
+		u8	Reserved[3];
+
+
+#else
+
+	/* WSM_TRANSMIT_RATE_... */
+	/* [out] */ u8 rxedRate;
+
+#endif
+
+	/* This value is expressed in signed Q8.0 format for */
+	/* RSSI and unsigned Q7.1 format for RCPI. */
+	/* [out] */ u8 rcpiRssi;
+
+	/* WSM_RX_STATUS_... */
+	/* [out] */ u32 flags;
+
+	/* An 802.11 frame. */
+	/* [out] */ void *frame;
+
+	/* Size of the frame */
+	/* [out] */ size_t frame_size;
+
+	/* Link ID */
+	/* [out] */ int link_id;
+	/* [out] */ int if_id;
+};
+
+/* = sizeof(generic hi hdr) + sizeof(wsm hdr) */
+#define WSM_RX_EXTRA_HEADROOM (16)
+#ifdef USE_RSSI_OFFSET
+#define WSM_RSSI_OFFSET  (-5)
+#endif
+
+typedef void (*wsm_rx_cb) (struct xradio_vif *priv, struct wsm_rx *arg,
+			   struct sk_buff **skb_p);
+
+/* 3.17 */
+struct wsm_event {
+	/* WSM_STATUS_... */
+	/* [out] */ u32 eventId;
+
+	/* Indication parameters. */
+	/* For error indication, this shall be a 32-bit WSM status. */
+	/* For RCPI or RSSI indication, this should be an 8-bit */
+	/* RCPI or RSSI value. */
+	/* [out] */ u32 eventData;
+};
+
+struct xradio_wsm_event {
+	struct list_head link;
+	struct wsm_event evt;
+	u8 if_id;
+};
+
+/* 3.18 - 3.22 */
+/* Measurement. Skipped for now. Irrelevent. */
+
+typedef void (*wsm_event_cb) (struct xradio_common *hw_priv,
+			      struct wsm_event *arg);
+
+/* 3.23 */
+
+#ifdef SUPPORT_HT40
+
+struct wsm_join {
+	/* Phy Mode Configuraion */
+	/* [in] */struct phy_mode_cfg PhyModeCfg;
+
+	/* Specifies the channel number to join. The channel */
+	/* number will be mapped to an actual frequency */
+	/* according to the band */
+	/* [in] */ u16 channelNumber;
+
+	/* Specifies the BSSID of the BSS or IBSS to be joined */
+	/* or the IBSS to be started. */
+	/* [in] */ u8 bssid[6];
+
+	/* ATIM window of IBSS */
+	/* When ATIM window is zero the initiated IBSS does */
+	/* not support power saving. */
+	/* [in] */ u16 atimWindow;
+
+	/* WSM_JOIN_MODE_... */
+	/* [in] */ u8 mode;
+
+	/* Specifies if a probe request should be send with the */
+	/* specified SSID when joining to the network. */
+	/* [in] */ u8 probeForJoin;
+
+	/* DTIM Period (In multiples of beacon interval) */
+	/* [in] */ u8 dtimPeriod;
+
+	/* WSM_JOIN_FLAGS_... */
+	/* [in] */ u8 flags;
+
+	/* Length of the SSID */
+	/* [in] */ u32 ssidLength;
+
+	/* Specifies the SSID of the IBSS to join or start */
+	/* [in] */ u8 ssid[32];
+
+	/* Specifies the time between TBTTs in TUs */
+	/* [in] */ u32 beaconInterval;
+
+	/* A bit mask that defines the BSS basic rate set. */
+	/* [in] */ u32 basicRateSet;
+
+	/* Minimum transmission power level in units of 0.1dBm */
+	/* [out] */ int minPowerLevel;
+
+	/* Maximum transmission power level in units of 0.1dBm */
+	/* [out] */ int maxPowerLevel;
+};
+
+#else
+
+struct wsm_join {
+	/* WSM_JOIN_MODE_... */
+	/* [in] */ u8 mode;
+
+	/* WSM_PHY_BAND_... */
+	/* [in] */ u8 band;
+
+	/* Specifies the channel number to join. The channel */
+	/* number will be mapped to an actual frequency */
+	/* according to the band */
+	/* [in] */ u16 channelNumber;
+
+	/* Specifies the BSSID of the BSS or IBSS to be joined */
+	/* or the IBSS to be started. */
+	/* [in] */ u8 bssid[6];
+
+	/* ATIM window of IBSS */
+	/* When ATIM window is zero the initiated IBSS does */
+	/* not support power saving. */
+	/* [in] */ u16 atimWindow;
+
+	/* WSM_JOIN_PREAMBLE_... */
+	/* [in] */ u8 preambleType;
+
+	/* Specifies if a probe request should be send with the */
+	/* specified SSID when joining to the network. */
+	/* [in] */ u8 probeForJoin;
+
+	/* DTIM Period (In multiples of beacon interval) */
+	/* [in] */ u8 dtimPeriod;
+
+	/* WSM_JOIN_FLAGS_... */
+	/* [in] */ u8 flags;
+
+	/* Length of the SSID */
+	/* [in] */ u32 ssidLength;
+
+	/* Specifies the SSID of the IBSS to join or start */
+	/* [in] */ u8 ssid[32];
+
+	/* Specifies the time between TBTTs in TUs */
+	/* [in] */ u32 beaconInterval;
+
+	/* A bit mask that defines the BSS basic rate set. */
+	/* [in] */ u32 basicRateSet;
+
+	/* Minimum transmission power level in units of 0.1dBm */
+	/* [out] */ int minPowerLevel;
+
+	/* Maximum transmission power level in units of 0.1dBm */
+	/* [out] */ int maxPowerLevel;
+};
+
+#endif
+
+int wsm_join(struct xradio_common *hw_priv, struct wsm_join *arg, int if_id);
+
+/* 3.25 */
+struct wsm_set_pm {
+	/* WSM_PSM_... */
+	/* [in] */ u8 pmMode;
+
+	/* in unit of 500us; 0 to use default */
+	/* [in] */ u8 fastPsmIdlePeriod;
+
+	/* in unit of 500us; 0 to use default */
+	/* [in] */ u8 apPsmChangePeriod;
+
+	/* in unit of 500us; 0 to disable auto-pspoll */
+	/* [in] */ u8 minAutoPsPollPeriod;
+};
+
+int wsm_set_pm(struct xradio_common *hw_priv, const struct wsm_set_pm *arg,
+	       int if_id);
+
+/* 3.27 */
+struct wsm_set_pm_complete {
+	u8 psm;			/* WSM_PSM_... */
+};
+
+typedef void (*wsm_set_pm_complete_cb) (struct xradio_common *hw_priv,
+					struct wsm_set_pm_complete *arg);
+
+/* 3.28 */
+struct wsm_set_bss_params {
+	/* The number of lost consecutive beacons after which */
+	/* the WLAN device should indicate the BSS-Lost event */
+	/* to the WLAN host driver. */
+	u8 beaconLostCount;
+
+	/* The AID received during the association process. */
+	u16 aid;
+
+	/* The operational rate set mask */
+	u32 operationalRateSet;
+};
+
+int wsm_set_bss_params(struct xradio_common *hw_priv,
+		       const struct wsm_set_bss_params *arg, int if_id);
+
+/* 3.30 */
+struct wsm_add_key {
+	u8 type;		/* WSM_KEY_TYPE_... */
+	u8 entryIndex;		/* Key entry index: 0 -- WSM_KEY_MAX_INDEX */
+	u16 reserved;
+	union {
+		struct {
+			u8 peerAddress[6];	/* MAC address of the
+						 * peer station */
+			u8 reserved;
+			u8 keyLength;		/* Key length in bytes */
+			u8 keyData[16];		/* Key data */
+		} __packed wepPairwiseKey;
+		struct {
+			u8 keyId;		/* Unique per key identifier
+						 * (0..3) */
+			u8 keyLength;		/* Key length in bytes */
+			u16 reserved;
+			u8 keyData[16];		/* Key data */
+		} __packed wepGroupKey;
+		struct {
+			u8 peerAddress[6];	/* MAC address of the
+						 * peer station */
+			u8 reserved[2];
+			u8 tkipKeyData[16];	/* TKIP key data */
+			u8 rxMicKey[8];		/* Rx MIC key */
+			u8 txMicKey[8];		/* Tx MIC key */
+		} __packed tkipPairwiseKey;
+		struct {
+			u8 tkipKeyData[16];	/* TKIP key data */
+			u8 rxMicKey[8];		/* Rx MIC key */
+			u8 keyId;		/* Key ID */
+			u8 reserved[3];
+			u8 rxSeqCounter[8];	/* Receive Sequence Counter */
+		} __packed tkipGroupKey;
+		struct {
+			u8 peerAddress[6];	/* MAC address of the
+						 * peer station */
+			u16 reserved;
+			u8 aesKeyData[16];	/* AES key data */
+		} __packed aesPairwiseKey;
+		struct {
+			u8 aesKeyData[16];	/* AES key data */
+			u8 keyId;		/* Key ID */
+			u8 reserved[3];
+			u8 rxSeqCounter[8];	/* Receive Sequence Counter */
+		} __packed aesGroupKey;
+		struct {
+			u8 peerAddress[6];	/* MAC address of the
+						 * peer station */
+			u8 keyId;		/* Key ID */
+			u8 reserved;
+			u8 wapiKeyData[16];	/* WAPI key data */
+			u8 micKeyData[16];	/* MIC key data */
+		} __packed wapiPairwiseKey;
+		struct {
+			u8 wapiKeyData[16];	/* WAPI key data */
+			u8 micKeyData[16];	/* MIC key data */
+			u8 keyId;		/* Key ID */
+			u8 reserved[3];
+		} __packed wapiGroupKey;
+		struct {
+			u8 igtkKeyData[16];  /* IGTK key data */
+			u8 keyId;    /* Key ID */
+			u8 reserved[3];
+			u8 ipn[8];     /* IGTK packet number */
+		} __packed igtkGroupKey;
+	} __packed;
+} __packed;
+
+int wsm_add_key(struct xradio_common *hw_priv, const struct wsm_add_key *arg,
+			int if_id);
+
+/* 3.32 */
+struct wsm_remove_key {
+	/* Key entry index : 0-10 */
+	u8 entryIndex;
+};
+
+int wsm_remove_key(struct xradio_common *hw_priv,
+		   const struct wsm_remove_key *arg, int if_id);
+
+/* 3.34 */
+struct wsm_set_tx_queue_params {
+	/* WSM_ACK_POLICY_... */
+	u8 ackPolicy;
+
+	/* Medium Time of TSPEC (in 32us units) allowed per */
+	/* One Second Averaging Period for this queue. */
+	u16 allowedMediumTime;
+
+	/* dot11MaxTransmitMsduLifetime to be used for the */
+	/* specified queue. */
+	u32 maxTransmitLifetime;
+};
+
+struct wsm_tx_queue_params {
+	/* NOTE: index is a linux queue id. */
+	struct wsm_set_tx_queue_params params[4];
+};
+
+#define WSM_TX_QUEUE_SET(queue_params, queue, ack_policy, allowed_time,     \
+			 max_life_time)					    \
+do {									    \
+	struct wsm_set_tx_queue_params *p = &(queue_params)->params[queue]; \
+	p->ackPolicy = (ack_policy);				\
+	p->allowedMediumTime = (allowed_time);				\
+	p->maxTransmitLifetime = (max_life_time);			\
+} while (0)
+
+int wsm_set_tx_queue_params(struct xradio_common *hw_priv,
+			    const struct wsm_set_tx_queue_params *arg,
+			    u8 id, int if_id);
+
+/* 3.36 */
+struct wsm_edca_queue_params {
+	/* CWmin (in slots) for the access class. */
+	/* [in] */ u16 cwMin;
+
+	/* CWmax (in slots) for the access class. */
+	/* [in] */ u16 cwMax;
+
+	/* AIFS (in slots) for the access class. */
+	/* [in] */ u8 aifns;
+
+	/* TX OP Limit (in microseconds) for the access class. */
+	/* [in] */ u16 txOpLimit;
+
+	/* dot11MaxReceiveLifetime to be used for the specified */
+	/* the access class. Overrides the global */
+	/* dot11MaxReceiveLifetime value */
+	/* [in] */ u32 maxReceiveLifetime;
+
+	/* UAPSD trigger support for the access class. */
+	/* [in] */ bool uapsdEnable;
+};
+
+struct wsm_edca_params {
+	/* NOTE: index is a linux queue id. */
+	struct wsm_edca_queue_params params[4];
+};
+
+#define TXOP_UNIT 32
+#define WSM_EDCA_SET(edca, queue, aifs, cw_min, cw_max, txop, life_time, \
+		uapsd)	\
+	do {							\
+		struct wsm_edca_queue_params *p = &(edca)->params[queue]; \
+		p->cwMin = (cw_min);				\
+		p->cwMax = (cw_max);				\
+		p->aifns = (aifs);				\
+		p->txOpLimit = ((txop) * TXOP_UNIT);		\
+		p->maxReceiveLifetime = (life_time);		\
+		p->uapsdEnable = (uapsd);			\
+	} while (0)
+
+int wsm_set_edca_params(struct xradio_common *hw_priv,
+			const struct wsm_edca_params *arg, int if_id);
+
+int wsm_set_uapsd_param(struct xradio_common *hw_priv,
+			const struct wsm_edca_params *arg);
+
+/* 3.38 */
+/* Set-System info. Skipped for now. Irrelevent. */
+
+/* 3.40 */
+struct wsm_switch_channel {
+	/* 1 - means the STA shall not transmit any further */
+	/* frames until the channel switch has completed */
+	/* [in] */ u8 channelMode;
+
+	/* Number of TBTTs until channel switch occurs. */
+	/* 0 - indicates switch shall occur at any time */
+	/* 1 - occurs immediately before the next TBTT */
+	/* [in] */ u8 channelSwitchCount;
+
+	/* The new channel number to switch to. */
+	/* Note this is defined as per section 2.7. */
+	/* [in] */ u16 newChannelNumber;
+};
+
+int wsm_switch_channel(struct xradio_common *hw_priv,
+		       const struct wsm_switch_channel *arg, int if_id);
+
+typedef void (*wsm_channel_switch_cb) (struct xradio_common *hw_priv);
+
+
+#ifdef SUPPORT_HT40
+
+struct wsm_start {
+	/* Phy Mode Configuraion */
+	/* [in] */ struct phy_mode_cfg PhyModeCfg;
+
+	/* Channel number */
+	/* [in] */ u16 channelNumber;
+
+	/* Client Traffic window in units of TU */
+	/* Valid only when mode == ..._P2P */
+	/* [in] */ u32 CTWindow;
+
+	/* Interval between two consecutive */
+	/* beacon transmissions in TU. */
+	/* [in] */ u32 beaconInterval;
+
+	/* WSM_START_MODE_... */
+	/* [in] */ u8 mode;
+
+	/* DTIM period in terms of beacon intervals */
+	/* [in] */ u8 DTIMPeriod;
+
+	/* The delay time (in microseconds) period */
+	/* before sending a probe-request. */
+	/* [in] */ u8 probeDelay;
+
+	/* Length of the SSID */
+	/* [in] */ u8 ssidLength;
+
+	/* SSID of the BSS or P2P_GO to be started now. */
+	/* [in] */ u8 ssid[32];
+
+	/* The basic supported rates for the MiniAP. */
+	/* [in] */ u32 basicRateSet;
+};
+
+#else
+
+struct wsm_start {
+	/* WSM_START_MODE_... */
+	/* [in] */ u8 mode;
+
+	/* WSM_PHY_BAND_... */
+	/* [in] */ u8 band;
+
+	/* Channel number */
+	/* [in] */ u16 channelNumber;
+
+	/* Client Traffic window in units of TU */
+	/* Valid only when mode == ..._P2P */
+	/* [in] */ u32 CTWindow;
+
+	/* Interval between two consecutive */
+	/* beacon transmissions in TU. */
+	/* [in] */ u32 beaconInterval;
+
+	/* DTIM period in terms of beacon intervals */
+	/* [in] */ u8 DTIMPeriod;
+
+	/* WSM_JOIN_PREAMBLE_... */
+	/* [in] */ u8 preambleType;
+
+	/* The delay time (in microseconds) period */
+	/* before sending a probe-request. */
+	/* [in] */ u8 probeDelay;
+
+	/* Length of the SSID */
+	/* [in] */ u8 ssidLength;
+
+	/* SSID of the BSS or P2P_GO to be started now. */
+	/* [in] */ u8 ssid[32];
+
+	/* The basic supported rates for the MiniAP. */
+	/* [in] */ u32 basicRateSet;
+};
+
+#endif
+
+int wsm_start(struct xradio_common *hw_priv, const struct wsm_start *arg,
+		int if_id);
+
+#if 0
+struct wsm_beacon_transmit {
+	/* 1: enable; 0: disable */
+	/* [in] */ u8 enableBeaconing;
+};
+
+int wsm_beacon_transmit(struct xradio_common *hw_priv,
+			const struct wsm_beacon_transmit *arg,
+			int if_id);
+#endif
+
+int wsm_start_find(struct xradio_common *hw_priv, int if_id);
+
+int wsm_stop_find(struct xradio_common *hw_priv, int if_id);
+
+typedef void (*wsm_find_complete_cb) (struct xradio_common *hw_priv,
+				      u32 status);
+
+struct wsm_suspend_resume {
+	/* See 3.52 */
+	/* Link ID */
+	/* [out] */ int link_id;
+	/* Stop sending further Tx requests down to device for this link */
+	/* [out] */ bool stop;
+	/* Transmit multicast Frames */
+	/* [out] */ bool multicast;
+	/* The AC on which Tx to be suspended /resumed. */
+	/* This is applicable only for U-APSD */
+	/* WSM_QUEUE_... */
+	/* [out] */ int queue;
+	/* [out] */ int if_id;
+};
+
+typedef void (*wsm_suspend_resume_cb) (struct xradio_vif *priv,
+				       struct wsm_suspend_resume *arg);
+
+/* 3.54 Update-IE request. */
+struct wsm_update_ie {
+	/* WSM_UPDATE_IE_... */
+	/* [in] */ u16 what;
+	/* [in] */ u16 count;
+	/* [in] */ u8 *ies;
+	/* [in] */ size_t length;
+};
+
+int wsm_update_ie(struct xradio_common *hw_priv,
+		  const struct wsm_update_ie *arg, int if_id);
+
+/* 3.56 */
+struct wsm_map_link {
+	/* MAC address of the remote device */
+	/* [in] */ u8 mac_addr[6];
+	/* [in] */ u8 unmap;
+	/* [in] */ u8 link_id;
+};
+
+int wsm_map_link(struct xradio_common *hw_priv, const struct wsm_map_link *arg,
+		int if_id);
+
+struct wsm_cbc {
+	wsm_scan_complete_cb scan_complete;
+	wsm_tx_confirm_cb tx_confirm;
+	wsm_rx_cb rx;
+	wsm_event_cb event;
+	wsm_set_pm_complete_cb set_pm_complete;
+	wsm_channel_switch_cb channel_switch;
+	wsm_find_complete_cb find_complete;
+	wsm_suspend_resume_cb suspend_resume;
+};
+#ifdef MCAST_FWDING
+
+/* 3.65	Give Buffer Request */
+int wsm_init_release_buffer_request(struct xradio_common *priv);
+
+/* 3.65 fixed memory leakage*/
+void wsm_deinit_release_buffer(struct xradio_common *hw_priv);
+
+/* 3.67	Request Buffer Request */
+int wsm_request_buffer_request(struct xradio_vif *priv,
+				u8 *arg);
+#endif
+/* ******************************************************************** */
+/* MIB shortcats							*/
+#define XR_RRM 1
+#ifdef XR_RRM /*RadioResourceMeasurement*/
+/* RadioResourceMeasurement Request*/
+#define MEAS_CCA         0
+#define MEAS_CHANNELLOAD 1
+typedef struct LMAC_MEAS_CHANNEL_LOAD_PARAMS_S {
+	u8    Reserved;
+	u8    ChannelLoadCCA;
+	u16   ChannelNum;
+	u16   RandomInterval;
+	u16   MeasurementDuration;
+	u32   MeasurementStartTimel;
+	u32   MeasurementStartTimeh;
+} LMAC_MEAS_CHANNEL_LOAD_PARAMS;
+
+#define MEAS_RPI 0
+#define MEAS_IPI 1
+
+typedef struct LMAC_MEAS_NOISE_HISTOGRAM_PARAMS_S {
+	u8    Reserved;
+	u8    IpiRpi;
+	u16   ChannelNum;
+	u16   RandomInterval;
+	u16   MeasurementDuration;
+	u32   MeasurementStartTimel;
+	u32   MeasurementStartTimeh;
+} LMAC_MEAS_NOISE_HISTOGRAM_PARAMS;
+
+#define LMAC_MAX_SSIDS       16
+#define LMAC_MAX_SSID_LENGTH 32
+typedef struct LMAC_CHANNELS_S {
+	u32  ChannelNum;
+	u32  MinChannelTime;
+	u32  MaxChannelTime;
+	s32  TxPowerLevel;
+} LMAC_CHANNELS;
+
+typedef struct LMAC_SSIDS_S {
+	u32  SSIDLength;
+	u8   SSID[LMAC_MAX_SSID_LENGTH];
+} LMAC_SSIDS;
+
+#ifdef SUPPORT_HT40
+
+typedef struct LMAC_MEAS_BEACON_PARAMS_S {
+	/*u8    RegulatoryClass;*/
+	/*u8    MeasurementMode;*/
+	/*u16   ChannelNum;*/
+	u16   RandomInterval;
+	/*u16   MeasurementDuration;*/
+	/*u8    Bssid[6];*/
+	u16   Reserved;
+	/*SCAN_PARAMETERS ScanParameters;*/
+	u8   Band;
+	/* bit7:6--WSM_SCAN_TYPE... */
+	/* bit5:0--WSM_SCAN_FLAG... */
+	u8   ScanFlags;
+	u16  TransmitRateEntry;
+	u32  AutoScanInterval;
+	u8   NumOfProbeRequests;
+	u8   NumOfChannels;
+	u8   NumOfSSIDs;
+	u8   ProbeDelay;
+	LMAC_CHANNELS Channels;
+	LMAC_SSIDS    Ssids; /*here for SCAN_PARAMETER sizing purposes*/
+} LMAC_MEAS_BEACON_PARAMS;
+
+#else
+
+typedef struct LMAC_MEAS_BEACON_PARAMS_S {
+	/*u8    RegulatoryClass;*/
+	/*u8    MeasurementMode;*/
+	/*u16   ChannelNum;*/
+	u16   RandomInterval;
+	/*u16   MeasurementDuration;*/
+	/*u8    Bssid[6];*/
+	u16   Reserved;
+	/*SCAN_PARAMETERS ScanParameters;*/
+	u8   Band;
+	u8   ScanType;
+	u8   ScanFlags;
+	u8   MaxTransmitRate;
+	u32  AutoScanInterval;
+	u8   NumOfProbeRequests;
+	u8   NumOfChannels;
+	u8   NumOfSSIDs;
+	u8   ProbeDelay;
+	LMAC_CHANNELS Channels;
+	LMAC_SSIDS    Ssids; /*here for SCAN_PARAMETER sizing purposes*/
+} LMAC_MEAS_BEACON_PARAMS;
+
+#endif
+
+typedef struct LMAC_MEAS_STA_STATS_PARAMS_S {
+	u8    PeerMacAddress[6];
+	u16   RandomInterval;
+	u16   MeasurementDuration;
+	u8    GroupId;
+	u8    Reserved;
+} LMAC_MEAS_STA_STATS_PARAMS;
+
+typedef struct LMAC_MEAS_LINK_MEASUREMENT_PARAMS_S {
+	u8    Reserved[4];
+} LMAC_MEAS_LINK_MEASUREMENT_PARAMS;
+
+typedef union LMAC_MEAS_REQUEST_U {
+	LMAC_MEAS_CHANNEL_LOAD_PARAMS     ChannelLoadParams;
+	LMAC_MEAS_NOISE_HISTOGRAM_PARAMS  NoisHistogramParams;
+	LMAC_MEAS_BEACON_PARAMS           BeaconParams;
+	LMAC_MEAS_STA_STATS_PARAMS        StaStatsParams;
+	LMAC_MEAS_LINK_MEASUREMENT_PARAMS LinkMeasurementParams;
+} LMAC_MEAS_REQUEST;
+
+/*
+ * This struct is a copy of WSM_HI_START_MEASUREMENT_REQ,
+ * except that MsgLen and MsgId is not included.
+ */
+typedef struct MEASUREMENT_PARAMETERS_S {
+	s32           TxPowerLevel;
+	u8            DurationMandatory;
+	u8            MeasurementType;
+	u8            MeasurementRequestLength;
+	u8            Reserved[5];
+	LMAC_MEAS_REQUEST MeasurementRequest;
+} MEASUREMENT_PARAMETERS;
+
+/* RadioResourceMeasurement Result*/
+ typedef struct LMAC_MEAS_CHANNEL_LOAD_RESULTS_S {
+	u8   Reserved;
+	u8   ChannelLoadCCA;
+	u16  ChannelNum;
+	u32  ActualMeasurementStartTimel;
+	u32  ActualMeasurementStartTimeh;
+	u16  MeasurementDuration;
+	u8   CCAbusyFraction;
+	u8   ChannelLoad;
+} LMAC_MEAS_CHANNEL_LOAD_RESULTS;
+
+typedef struct LMAC_MEAS_NOISE_HISTOGRAM_RESULTS_S {
+	u16  Reserved;
+	u16  ChannelNum;
+	u32  ActualMeasurementStartTimel;
+	u32  ActualMeasurementStartTimeh;
+	u16  MeasurementDuration;
+	u8   AntennaID;
+	u8   IpiRpi;
+	u8   PI_0_Density;
+	u8   PI_1_Density;
+	u8   PI_2_Density;
+	u8   PI_3_Density;
+	u8   PI_4_Density;
+	u8   PI_5_Density;
+	u8   PI_6_Density;
+	u8   PI_7_Density;
+	u8   PI_8_Density;
+	u8   PI_9_Density;
+	u8   PI_10_Density;
+	u8   Reserved2;
+} LMAC_MEAS_NOISE_HISTOGRAM_RESULTS;
+
+#ifdef SUPPORT_HT40
+
+typedef struct LMAC_MEAS_BEACON_RESULTS_S {
+	u16  MeasurementDuration;
+	u16  Reserved;
+	u32  StartTsfl;
+	u32  StartTsfh;
+	u32  Durationl;
+	u32  Durationh;
+	/*SCAN_PARAMETERS ScanParameters;*/
+	u8   Band;
+	/* bit7:6--WSM_SCAN_TYPE... */
+	/* bit5:0--WSM_SCAN_FLAG... */
+	u8   ScanFlags;
+	u16  TransmitRateEntry;
+	u32  AutoScanInterval;
+	u8   NumOfProbeRequests;
+	u8   NumOfChannels;
+	u8   NumOfSSIDs;
+	u8   ProbeDelay;
+	LMAC_CHANNELS Channels;
+	LMAC_SSIDS    Ssids;
+} LMAC_MEAS_BEACON_RESULTS;
+
+#else
+
+typedef struct LMAC_MEAS_BEACON_RESULTS_S {
+	u16  MeasurementDuration;
+	u16  Reserved;
+	u32  StartTsfl;
+	u32  StartTsfh;
+	u32  Durationl;
+	u32  Durationh;
+	/*SCAN_PARAMETERS ScanParameters;*/
+	u8   Band;
+	u8   ScanType;
+	u8   ScanFlags;
+	u8   MaxTransmitRate;
+	u32  AutoScanInterval;
+	u8   NumOfProbeRequests;
+	u8   NumOfChannels;
+	u8   NumOfSSIDs;
+	u8   ProbeDelay;
+	LMAC_CHANNELS Channels;
+	LMAC_SSIDS    Ssids;
+} LMAC_MEAS_BEACON_RESULTS;
+
+#endif
+
+typedef struct LMAC_MEAS_STA_STATS_RESULTS_S {
+	u16  MeasurementDuration;
+	u8   GroupId;
+	u8   StatisticsGroupDataLength;
+	u8   StatisticsGroupData[52];
+} LMAC_MEAS_STA_STATS_RESULTS;
+
+typedef struct LMAC_MEAS_LINK_MEASUREMENT_RESULTS_S {
+	s16  TransmitPower;
+	u8   RxAntennaID;
+	u8   TxAntennaID;
+	s32  NoiseLeveldBm;
+	s8   LatestRssi;
+	u8   Reserved1;
+	u8   Reserved2;
+	u8   Reserved3;
+} LMAC_MEAS_LINK_MEASUREMENT_RESULTS;
+
+typedef union LMAC_MEAS_REPORT_U {
+	LMAC_MEAS_CHANNEL_LOAD_RESULTS     ChannelLoadResults;
+	LMAC_MEAS_NOISE_HISTOGRAM_RESULTS  NoiseHistogramResults;
+	LMAC_MEAS_BEACON_RESULTS           BeaconResults;
+	LMAC_MEAS_STA_STATS_RESULTS        StaStatsResults;
+	LMAC_MEAS_LINK_MEASUREMENT_RESULTS LinkMeasurementResults;
+} LMAC_MEAS_REPORT;
+/*
+ * Note: eMeasurementTypes MUST match the
+ * #define WSM_MEASURE_TYPE_XXX from wsm_api.h.
+ */
+typedef enum {
+	ChannelLoadMeasurement = 0,
+	NoiseHistrogramMeasurement,
+	BeaconReport,
+	STAstatisticsReport,
+	LinkMeasurement
+} eMeasurementTypes;
+
+typedef struct MEASUREMENT_COMPLETE_S {
+	/*u16          RandomInterval;*/
+	/*u16          Reserved0;*/
+	/* From here WSM_HI_MEASURE_CMPL_IND and
+	 * MEASUREMENT_COMPLETE_S must be identical.
+	 */
+	u8           Dot11PowerMgmtMode;
+	u8           MeasurementType;
+
+	/* Set to 1 if more indications are to follow
+	 * for this measurement, otherwise 0; */
+	u16          MoreInd;
+	u32          Status;
+	u8           MeasurementReportLength;
+	u8           Reserved2[3];
+	LMAC_MEAS_REPORT MeasurementReport;
+} MEASUREMENT_COMPLETE; /*Note: must be 32 bit aligned*/
+
+#endif
+int wsm_11k_measure_requset(struct xradio_common  *hw_priv,
+					       u8  measure_type,
+					      u16  ChannelNum,
+					      u16  Duration);
+
+
+static inline int wsm_set_fw_debug_control(struct xradio_common *hw_priv,
+				       int debug_control, int if_id)
+{
+	__le32 val = __cpu_to_le32(debug_control);
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_FW_DEBUG_CONTROL,
+			     &val, sizeof(val), if_id);
+}
+
+static inline int wsm_set_host_sleep(struct xradio_common *hw_priv,
+				       u8 host_sleep, int if_id)
+{
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_SET_HOST_SLEEP,
+			     &host_sleep, sizeof(host_sleep), if_id);
+}
+
+static inline int wsm_set_output_power(struct xradio_common *hw_priv,
+				       int power_level, int if_id)
+{
+	__le32 val = __cpu_to_le32(power_level);
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_DOT11_CURRENT_TX_POWER_LEVEL,
+			     &val, sizeof(val), if_id);
+}
+
+static inline int wsm_set_beacon_wakeup_period(struct xradio_common *hw_priv,
+					       unsigned dtim_interval,
+					       unsigned listen_interval,
+					       int if_id)
+{
+	struct {
+		u8 numBeaconPeriods;
+		u8 reserved;
+		__le16 listenInterval;
+	} val = {
+	dtim_interval, 0, __cpu_to_le16(listen_interval)};
+	if (dtim_interval > 0xFF || listen_interval > 0xFFFF)
+		return -EINVAL;
+	else
+		return wsm_write_mib(hw_priv, WSM_MIB_ID_BEACON_WAKEUP_PERIOD,
+				     &val, sizeof(val), if_id);
+}
+
+struct wsm_rcpi_rssi_threshold {
+	u8 rssiRcpiMode;	/* WSM_RCPI_RSSI_... */
+	u8 lowerThreshold;
+	u8 upperThreshold;
+	u8 rollingAverageCount;
+};
+
+static inline int wsm_set_rcpi_rssi_threshold(struct xradio_common *hw_priv,
+					struct wsm_rcpi_rssi_threshold *arg,
+					int if_id)
+{
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_RCPI_RSSI_THRESHOLD, arg,
+			     sizeof(*arg), if_id);
+}
+
+struct wsm_counters_table {
+	__le32 countPlcpErrors;
+	__le32 countFcsErrors;
+	__le32 countTxPackets;
+	__le32 countRxPackets;
+	__le32 countRxPacketErrors;
+	__le32 countRtsSuccess;
+	__le32 countRtsFailures;
+	__le32 countRxFramesSuccess;
+	__le32 countRxDecryptionFailures;
+	__le32 countRxMicFailures;
+	__le32 countRxNoKeyFailures;
+	__le32 countTxMulticastFrames;
+	__le32 countTxFramesSuccess;
+	__le32 countTxFrameFailures;
+	__le32 countTxFramesRetried;
+	__le32 countTxFramesMultiRetried;
+	__le32 countRxFrameDuplicates;
+	__le32 countAckFailures;
+	__le32 countRxMulticastFrames;
+	__le32 countRxCMACICVErrors;
+	__le32 countRxCMACReplays;
+	__le32 countRxMgmtCCMPReplays;
+	__le32 countRxBIPMICErrors;
+
+	__le32 countAllBeacons;
+	__le32 countScanBeacons;
+	__le32 countScanProbeRsps;
+	__le32 countOutChanBeacons;
+	__le32 countOutChanProbeRsps;
+	__le32 countBssBeacons;
+	__le32 countHostBeacons;
+	__le32 countMissBeacons;
+	__le32 countDTIMBeacons;
+};
+
+
+struct wsm_ampducounters_table {
+	u32 countTxAMPDUs;
+	u32 countTxMPDUsInAMPDUs;
+	u32 countTxOctetsInAMPDUs_l32;
+	u32 countTxOctetsInAMPDUs_h32;
+	u32 countRxAMPDUs;
+	u32 countRxMPDUsInAMPDUs;
+	u32 countRxOctetsInAMPDUs_l32;
+	u32 countRxOctetsInAMPDUs_h32;
+	u32 countRxDelimeterCRCErrorCount;
+	u32 countImplictBARFailures;
+	u32 countExplictBARFailures;
+};
+
+struct wsm_txpipe_counter {
+	u32 count1;
+	u32 count2;
+	u32 count3;
+	u32 count4;
+	u32 count5;
+	u32 count6;
+	u32 count7;
+	u32 count8;
+	u32 count9;
+	u32 counta;
+};
+
+struct wsm_backoff_counter {
+	u32 count0;
+	u32 count1;
+	u32 count2;
+	u32 count3;
+	u32 count4;
+	u32 count5;
+	u32 count6;
+	u32 count7;
+	u32 count8;
+	u32 count9;
+};
+
+#if (SUPPORT_EPTA)
+struct xradio_epta_bt_link_info {
+	u8  link_id;
+	u8  traffic_priority;
+	u8  traffic_type;
+	u8  master_or_slave;
+	u8  curr_req_ongoing;
+	u8  pad[3];
+	u32 time_diff_req_start; //refer to curr_req_ongoing
+	u32 rt_si;
+	u32 rt_sw;
+	u32 msg_si;
+	u32 msg_sw;
+	u32 requests;
+	u32 granted_requests;
+	u32 bt_tx_retry_num;
+	u32 bt_caton_num;
+} __packed;
+struct xradio_epta_wl_req_info {
+	u32 cnt_win;
+	u32 cnt_lose;
+	u16 cnt_grant_med_ret;
+	u16 cnt_grant_timeout;
+	u16 cnt_abort_miss_rx;
+	u16 cnt_abort_expired;
+	u32 granted_time;
+	u32 gr_used_time;
+} __packed;
+
+struct xradio_epta_stat {
+	u16 msg_len;
+	u16 msg_id;
+	u32 status;
+	u8  medium_state;
+	u8  wlan_req_ongoing;
+	u8  wlan_req_type;
+	u8  wlan_req_priority;
+	u32 wlan_req_request_dur;
+
+//	u32 grant_or_wait_time; //refer to medium_state
+
+	struct xradio_epta_wl_req_info wl_req_info[4];
+
+	u16 cnt_ex_grant_uapsd;
+	u16 cnt_ex_abort_pspoll;
+	u16 cnt_ex_abort_rx_bcn;
+	u16 cnt_bt_abort;
+	u16 cnt_bt_abort_tx;
+	u16 cnt_bt_abort_tx_fix;
+//	u8  pad1[2];
+
+	u32 nrt_wlan_quota_used;
+	u32 nrt_bt_quota_used;
+	u32 nrt_bt_requests;
+	u32 nrt_bt_granted_requestd;
+	u32 nrt_bt_granted_req_max_gap;
+	u16 cnt_bt_tx_poll_pkt_req;
+	u16 cnt_bt_tx_dm1_pkt_req;
+	u16 cnt_bt_tx_br_pkt_req;
+	u16 cnt_bt_tx_edr_pkt_req;
+	u16 cnt_bt_tx_sco_pkt_req;
+	u16 cnt_reserved;
+	u8  num_active_rt_bt_links;
+	u8  pad2[3];
+	struct xradio_epta_bt_link_info bt_link_info[7];
+} __packed;
+
+extern struct xradio_epta_stat debug_epta_stat;
+
+#endif  //SUPPORT_EPTA
+
+/*for read/write fw registers*/
+#define WSM_REG_RW_F   BIT(0)   /*0:read, 1:write*/
+#define WSM_REG_RET_F   BIT(1)  /*results is valid.*/
+#define WSM_REG_BK_F   BIT(4)   /*operate in block mode.*/
+
+struct reg_data {
+	u32 reg_addr;
+	u32 reg_val;
+};
+
+typedef struct tag_wsm_reg_w {
+	u16 flag;
+	u16 data_size;
+	struct reg_data arg[16];
+} WSM_REG_W;
+
+typedef struct tag_wsm_reg_r {
+	u16 flag;
+	u16 data_size;
+	u32 arg[16];
+} WSM_REG_R;
+
+struct wsm_backoff_ctrl {
+	u32 enable;
+	u32 min;
+	u32 max;
+};
+struct wsm_tala_para {
+	u32 para;
+	u32 thresh;
+};
+static inline int wsm_get_counters_table(struct xradio_common *hw_priv,
+					 struct wsm_counters_table *arg)
+{
+	return wsm_read_mib(hw_priv, WSM_MIB_ID_COUNTERS_TABLE,
+			arg, sizeof(*arg), 0);
+}
+
+static inline int wsm_get_ampducounters_table(struct xradio_common *hw_priv,
+					 struct wsm_ampducounters_table *arg)
+{
+	return wsm_read_mib(hw_priv, WSM_MIB_ID_AMPDUCOUNTERS_TABLE,
+			arg, sizeof(*arg), 0);
+}
+
+static inline int wsm_get_txpipe_table(struct xradio_common *hw_priv,
+					 struct wsm_txpipe_counter *arg)
+{
+	return wsm_read_mib(hw_priv, WSM_MIB_ID_TXPIPE_TABLE,
+			arg, sizeof(*arg), 0);
+}
+
+#if (SUPPORT_EPTA)
+static inline int wsm_get_epta_statistics(struct xradio_common *hw_priv,
+						 struct xradio_epta_stat *arg)
+{
+	return wsm_read_mib(hw_priv, WSM_MIB_ID_EPTA_STAT,
+			arg, sizeof(*arg), 0);
+}
+
+static inline int count_ones(int n)
+{
+	int i = 0;
+	while (n != 0) {
+		i++;
+		n = n & (n-1);
+	}
+	return i;
+}
+static inline int wsm_set_epta_stat_dbg_ctrl(struct xradio_common *hw_priv, int epta_stat_ctrl)
+{
+	__le32 val = __cpu_to_le32(epta_stat_ctrl);
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_EPTA_STAT_CTRL, &val, sizeof(val), 0);
+}
+#endif
+
+static inline int wsm_get_backoff_dbg(struct xradio_common *hw_priv,
+					 struct wsm_backoff_counter *arg)
+{
+	return wsm_read_mib(hw_priv, WSM_MIB_ID_BACKOFF_DBG,
+			arg, sizeof(*arg), 0);
+}
+
+static inline int wsm_set_backoff_ctrl(struct xradio_common *hw_priv,
+					 struct wsm_backoff_ctrl *arg)
+{
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_BACKOFF_CTRL,
+			arg, sizeof(*arg), 0);
+}
+
+static inline int wsm_set_tala(struct xradio_common *hw_priv,
+					 struct wsm_tala_para *arg)
+{
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_SET_TALA_PARA,
+			arg, sizeof(*arg), 0);
+}
+static inline int wsm_get_station_id(struct xradio_common *hw_priv, u8 *mac)
+{
+	return wsm_read_mib(hw_priv, WSM_MIB_ID_DOT11_STATION_ID, mac,
+			    ETH_ALEN, 0);
+}
+
+struct wsm_rx_filter {
+	bool promiscuous;
+	bool bssid;
+	bool fcs;
+	bool probeResponder;
+	bool keepalive;
+};
+
+static inline int wsm_set_rx_filter(struct xradio_common *hw_priv,
+				    const struct wsm_rx_filter *arg,
+				    int if_id)
+{
+	__le32 val = 0;
+	if (arg->promiscuous)
+		val |= __cpu_to_le32(BIT(0));
+	if (arg->bssid)
+		val |= __cpu_to_le32(BIT(1));
+	if (arg->fcs)
+		val |= __cpu_to_le32(BIT(2));
+	if (arg->probeResponder)
+		val |= __cpu_to_le32(BIT(3));
+	if (arg->keepalive)
+		val |= __cpu_to_le32(BIT(4));
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_RX_FILTER, &val, sizeof(val),
+			if_id);
+}
+
+int wsm_set_probe_responder(struct xradio_vif *priv, bool enable);
+int wsm_set_keepalive_filter(struct xradio_vif *priv, bool enable);
+
+#define WSM_BEACON_FILTER_IE_HAS_CHANGED	BIT(0)
+#define WSM_BEACON_FILTER_IE_NO_LONGER_PRESENT	BIT(1)
+#define WSM_BEACON_FILTER_IE_HAS_APPEARED	BIT(2)
+
+struct wsm_beacon_filter_table_entry {
+	u8	ieId;
+	u8	actionFlags;
+	u8	oui[3];
+	u8	matchData[3];
+} __packed;
+
+struct wsm_beacon_filter_table {
+	__le32 numOfIEs;
+	struct wsm_beacon_filter_table_entry entry[10];
+} __packed;
+
+static inline int wsm_set_beacon_filter_table(struct xradio_common *hw_priv,
+					struct wsm_beacon_filter_table *ft,
+					int if_id)
+{
+	size_t size = __le32_to_cpu(ft->numOfIEs) *
+		     sizeof(struct wsm_beacon_filter_table_entry) +
+		     sizeof(__le32);
+
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_BEACON_FILTER_TABLE, ft, size,
+			if_id);
+}
+
+/* Enable/disable beacon filtering */
+#define WSM_BEACON_FILTER_ENABLE	BIT(0)
+/* If 1 FW will handle ERP IE changes internally */
+#define WSM_BEACON_FILTER_AUTO_ERP	BIT(1)
+
+#ifdef SUPPORT_HT40
+
+#define WSM_BEACON_FILTER_AUTO_HT	BIT(2)
+
+#endif
+
+struct wsm_beacon_filter_control {
+	int enabled;
+	int bcn_count;
+};
+
+static inline int wsm_beacon_filter_control(struct xradio_common *hw_priv,
+					struct wsm_beacon_filter_control *arg,
+					int if_id)
+{
+	struct {
+		__le32 enabled;
+		__le32 bcn_count;
+	} val;
+	val.enabled = __cpu_to_le32(arg->enabled);
+	val.bcn_count = __cpu_to_le32(arg->bcn_count);
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_BEACON_FILTER_ENABLE, &val,
+			     sizeof(val), if_id);
+}
+
+enum wsm_power_mode {
+	wsm_power_mode_active = 0,
+	wsm_power_mode_doze = 1,
+	wsm_power_mode_quiescent = 2,
+};
+
+struct wsm_operational_mode {
+	enum wsm_power_mode power_mode;
+	int disableMoreFlagUsage;
+	int performAntDiversity;
+};
+
+#ifdef CONFIG_XRADIO_DEBUGFS
+extern u8 low_pwr_disable;
+#endif
+
+static inline int wsm_set_operational_mode(struct xradio_common *hw_priv,
+					const struct wsm_operational_mode *arg,
+					int if_id)
+{
+	u32 val = arg->power_mode;
+
+#ifdef CONFIG_XRADIO_DEBUGFS
+	if (low_pwr_disable) /*disable low_power mode.*/
+		val = wsm_power_mode_active;
+#endif
+
+	if (arg->disableMoreFlagUsage)
+		val |= BIT(4);
+	if (arg->performAntDiversity)
+		val |= BIT(5);
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_OPERATIONAL_POWER_MODE, &val,
+			     sizeof(val), if_id);
+}
+
+struct wsm_inactivity {
+	u8 max_inactivity;
+	u8 min_inactivity;
+};
+
+static inline int wsm_set_inactivity(struct xradio_common *hw_priv,
+					const struct wsm_inactivity *arg,
+					int if_id)
+{
+	struct {
+	       u8	min_inactive;
+	       u8	max_inactive;
+	       u16	reserved;
+	} val;
+
+	val.max_inactive = arg->max_inactivity;
+	val.min_inactive = arg->min_inactivity;
+	val.reserved = 0;
+
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_SET_INACTIVITY, &val,
+			     sizeof(val), if_id);
+}
+
+#ifdef SUPPORT_HT40
+
+struct template_frame_hdr {
+	u16 frame_type;
+	u16 rate_entry;
+	u32 frmlen; /* not include itself. */
+};
+
+#endif
+
+#ifdef SUPPORT_HT40
+
+struct wsm_template_frame {
+	u16  frame_type;
+	u16  rate;
+	bool disable;
+	struct sk_buff *skb;
+};
+
+#else
+
+struct wsm_template_frame {
+	u8 frame_type;
+	u8 rate;
+	bool disable;
+	struct sk_buff *skb;
+};
+
+#endif
+
+#ifdef SUPPORT_HT40
+
+static inline int wsm_set_template_frame(struct xradio_common *hw_priv,
+					 struct wsm_template_frame *arg,
+					 int if_id)
+{
+	int ret;
+	struct template_frame_hdr *tmp_hdr = NULL;
+	tmp_hdr = (struct template_frame_hdr *)
+			skb_push(arg->skb, sizeof(*tmp_hdr));
+	tmp_hdr->frame_type = arg->frame_type;
+	tmp_hdr->rate_entry = arg->rate;
+	if (arg->disable)
+		tmp_hdr->frmlen = 0;
+	else
+		tmp_hdr->frmlen =
+			__cpu_to_le32(arg->skb->len - sizeof(*tmp_hdr));
+
+	ret = wsm_write_mib(hw_priv, WSM_MIB_ID_TEMPLATE_FRAME, (void *)tmp_hdr,
+			    arg->skb->len, if_id);
+	skb_pull(arg->skb, sizeof(*tmp_hdr));
+	return ret;
+}
+
+#else
+
+static inline int wsm_set_template_frame(struct xradio_common *hw_priv,
+					 struct wsm_template_frame *arg,
+					 int if_id)
+{
+	int ret;
+	u8 *p = skb_push(arg->skb, 4);
+	p[0] = arg->frame_type;
+	p[1] = arg->rate;
+	if (arg->disable)
+		((u16 *) p)[1] = 0;
+	else
+		((u16 *) p)[1] = __cpu_to_le16(arg->skb->len - 4);
+	ret = wsm_write_mib(hw_priv, WSM_MIB_ID_TEMPLATE_FRAME, p,
+			    arg->skb->len, if_id);
+	skb_pull(arg->skb, 4);
+	return ret;
+}
+
+#endif
+
+struct wsm_protected_mgmt_policy {
+	bool protectedMgmtEnable;
+	bool unprotectedMgmtFramesAllowed;
+	bool encryptionForAuthFrame;
+};
+
+static inline int
+wsm_set_protected_mgmt_policy(struct xradio_common *hw_priv,
+			      struct wsm_protected_mgmt_policy *arg,
+			      int if_id)
+{
+	__le32 val = 0;
+	int ret;
+	if (arg->protectedMgmtEnable)
+		val |= __cpu_to_le32(BIT(0));
+	if (arg->unprotectedMgmtFramesAllowed)
+		val |= __cpu_to_le32(BIT(1));
+	if (arg->encryptionForAuthFrame)
+		val |= __cpu_to_le32(BIT(2));
+	ret = wsm_write_mib(hw_priv, WSM_MIB_ID_PROTECTED_MGMT_POLICY, &val,
+			    sizeof(val), if_id);
+	return ret;
+}
+
+static inline int wsm_set_block_ack_policy(struct xradio_common *hw_priv,
+					   u8 blockAckTxTidPolicy,
+					   u8 blockAckRxTidPolicy,
+					   int if_id)
+{
+	struct {
+		u8 blockAckTxTidPolicy;
+		u8 reserved1;
+		u8 blockAckRxTidPolicy;
+		u8 reserved2;
+	} val = {
+		.blockAckTxTidPolicy = blockAckTxTidPolicy,
+		.blockAckRxTidPolicy = blockAckRxTidPolicy,
+	};
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_BLOCK_ACK_POLICY, &val,
+			     sizeof(val), if_id);
+}
+
+#ifdef SUPPORT_HT40
+
+struct wsm_association_mode {
+	u8 flags;		/* WSM_ASSOCIATION_MODE_... */
+	/*u8 preambleType;*/	/* WSM_JOIN_PREAMBLE_... */
+	/*u8 greenfieldMode;*/	/* 1 for greenfield */
+	struct phy_mode_cfg PhyModeCfg;
+	u8 mpduStartSpacing;
+	__le32 basicRateSet;
+};
+
+#else
+
+struct wsm_association_mode {
+	u8 flags;		/* WSM_ASSOCIATION_MODE_... */
+	u8 preambleType;	/* WSM_JOIN_PREAMBLE_... */
+	u8 greenfieldMode;	/* 1 for greenfield */
+	u8 mpduStartSpacing;
+	__le32 basicRateSet;
+};
+
+#endif
+
+static inline int wsm_set_association_mode(struct xradio_common *hw_priv,
+					   struct wsm_association_mode *arg,
+					   int if_id)
+{
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_SET_ASSOCIATION_MODE, arg,
+			     sizeof(*arg), if_id);
+}
+
+struct wsm_set_tx_rate_retry_policy_header {
+	u8 numTxRatePolicies;
+	u8 reserved[3];
+} __packed;
+
+struct wsm_set_tx_rate_retry_policy_policy {
+	u8 policyIndex;
+	u8 shortRetryCount;
+	u8 longRetryCount;
+	u8 policyFlags;
+	u8 rateRecoveryCount;
+	u8 reserved[3];
+
+#ifdef SUPPORT_HT40
+
+	/* [15, 14]:ModemType, [13, 12]:Bandwidth, [11, 8]:FormatFlag,
+	 * [7, 4]:  RateIndex, [3:0]:  MaxRetry*/
+	__le16 rate_entrys[MAX_RATES_STAGE];
+
+#else
+
+	__le32 rateCountIndices[3];
+
+#endif
+} __packed;
+
+#ifdef SUPPORT_HT40
+#define TX_POLICY_CACHE_SIZE	(16)
+#else
+#define TX_POLICY_CACHE_SIZE	(8)
+#endif
+
+struct wsm_set_tx_rate_retry_policy {
+	struct wsm_set_tx_rate_retry_policy_header hdr;
+	struct wsm_set_tx_rate_retry_policy_policy tbl[TX_POLICY_CACHE_SIZE];
+} __packed;
+
+static inline int wsm_set_tx_rate_retry_policy(struct xradio_common *hw_priv,
+				struct wsm_set_tx_rate_retry_policy *arg,
+				int if_id)
+{
+	size_t size = sizeof(struct wsm_set_tx_rate_retry_policy_header) +
+	    arg->hdr.numTxRatePolicies *
+	    sizeof(struct wsm_set_tx_rate_retry_policy_policy);
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_SET_TX_RATE_RETRY_POLICY, arg,
+			     size, if_id);
+}
+
+/* 4.32 SetEtherTypeDataFrameFilter */
+struct wsm_ether_type_filter_hdr {
+	u8 nrFilters;		/* Up to WSM_MAX_FILTER_ELEMENTS */
+	u8 reserved[3];
+} __packed;
+
+struct wsm_ether_type_filter {
+	u8 filterAction;	/* WSM_FILTER_ACTION_XXX */
+	u8 reserved;
+	__le16 etherType;	/* Type of ethernet frame */
+} __packed;
+
+static inline int wsm_set_ether_type_filter(struct xradio_common *hw_priv,
+				struct wsm_ether_type_filter_hdr *arg,
+				int if_id)
+{
+	size_t size = sizeof(struct wsm_ether_type_filter_hdr) +
+		arg->nrFilters * sizeof(struct wsm_ether_type_filter);
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_SET_ETHERTYPE_DATAFRAME_FILTER,
+		arg, size, if_id);
+}
+
+
+/* 4.33 SetUDPPortDataFrameFilter */
+struct wsm_udp_port_filter_hdr {
+	u8 nrFilters;		/* Up to WSM_MAX_FILTER_ELEMENTS */
+	u8 reserved[3];
+} __packed;
+
+struct wsm_udp_port_filter {
+	u8 filterAction;	/* WSM_FILTER_ACTION_XXX */
+	u8 portType;		/* WSM_FILTER_PORT_TYPE_XXX */
+	__le16 udpPort;		/* Port number */
+} __packed;
+
+static inline int wsm_set_udp_port_filter(struct xradio_common *hw_priv,
+				struct wsm_udp_port_filter_hdr *arg,
+				int if_id)
+{
+	size_t size = sizeof(struct wsm_udp_port_filter_hdr) +
+		arg->nrFilters * sizeof(struct wsm_udp_port_filter);
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_SET_UDPPORT_DATAFRAME_FILTER,
+		arg, size, if_id);
+}
+
+/* Undocumented MIBs: */
+/* 4.35 P2PDeviceInfo */
+#define D11_MAX_SSID_LEN		(32)
+
+struct wsm_p2p_device_type {
+	__le16 categoryId;
+	u8 oui[4];
+	__le16 subCategoryId;
+} __packed;
+
+struct wsm_p2p_device_info {
+	struct wsm_p2p_device_type primaryDevice;
+	u8 reserved1[3];
+	u8 devNameSize;
+	u8 localDevName[D11_MAX_SSID_LEN];
+	u8 reserved2[3];
+	u8 numSecDevSupported;
+	struct wsm_p2p_device_type secondaryDevices[0];
+} __packed;
+
+/* 4.36 SetWCDMABand - WO */
+struct wsm_cdma_band {
+	u8 WCDMA_Band;
+	u8 reserved[3];
+} __packed;
+
+/* 4.37 GroupTxSequenceCounter - RO */
+struct wsm_group_tx_seq {
+	__le32 bits_47_16;
+	__le16 bits_15_00;
+	__le16 reserved;
+} __packed;
+
+/* 4.39 SetHtProtection - WO */
+#define WSM_DUAL_CTS_PROT_ENB		(1 << 0)
+#define WSM_NON_GREENFIELD_STA		(1 << 1)
+#define WSM_HT_PROT_MODE__NO_PROT	(0 << 2)
+#define WSM_HT_PROT_MODE__NON_MEMBER	(1 << 2)
+#define WSM_HT_PROT_MODE__20_MHZ	(2 << 2)
+#define WSM_HT_PROT_MODE__NON_HT_MIXED	(3 << 2)
+#define WSM_LSIG_TXOP_PROT_FULL		(1 << 4)
+#define WSM_LARGE_L_LENGTH_PROT		(1 << 5)
+
+struct wsm_ht_protection {
+	__le32 flags;
+} __packed;
+
+/* 4.40 GPIO Command - R/W */
+#define WSM_GPIO_COMMAND_SETUP	0
+#define WSM_GPIO_COMMAND_READ	1
+#define WSM_GPIO_COMMAND_WRITE	2
+#define WSM_GPIO_COMMAND_RESET	3
+#define WSM_GPIO_ALL_PINS	0xFF
+
+struct wsm_gpio_command {
+	u8 GPIO_Command;
+	u8 pin;
+	__le16 config;
+} __packed;
+
+/* 4.41 TSFCounter - RO */
+struct wsm_tsf_counter {
+	__le64 TSF_Counter;
+} __packed;
+
+/* 4.43 Keep alive period */
+struct wsm_keep_alive_period {
+	__le16 keepAlivePeriod;
+	u8 reserved[2];
+} __packed;
+
+static inline int wsm_keep_alive_period(struct xradio_common *hw_priv,
+					int period, int if_id)
+{
+	struct wsm_keep_alive_period arg = {
+		.keepAlivePeriod = __cpu_to_le16(period),
+	};
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_KEEP_ALIVE_PERIOD,
+			&arg, sizeof(arg), if_id);
+};
+
+/* BSSID filtering */
+struct wsm_set_bssid_filtering {
+	u8 filter;
+	u8 reserved[3];
+} __packed;
+
+static inline int wsm_set_bssid_filtering(struct xradio_common *hw_priv,
+					  bool enabled, int if_id)
+{
+	struct wsm_set_bssid_filtering arg = {
+		.filter = !enabled,
+	};
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_DISABLE_BSSID_FILTER,
+			&arg, sizeof(arg), if_id);
+}
+
+/* Multicat filtering - 4.5 */
+struct wsm_multicast_filter {
+	__le32 enable;
+	__le32 numOfAddresses;
+	u8 macAddress[WSM_MAX_GRP_ADDRTABLE_ENTRIES][ETH_ALEN];
+} __packed;
+
+/* Mac Addr Filter Info */
+struct wsm_mac_addr_info {
+	u8 filter_mode;
+	u8 address_mode;
+	u8 MacAddr[6];
+} __packed;
+
+/* Mac Addr Filter */
+struct wsm_mac_addr_filter {
+	u8 numfilter;
+	u8 action_mode;
+	u8 Reserved[2];
+	struct wsm_mac_addr_info macaddrfilter[0];
+} __packed;
+
+/* Broadcast Addr Filter */
+struct wsm_broadcast_addr_filter {
+	u8 action_mode;
+	u8 nummacaddr;
+	u8 filter_mode;
+	u8 address_mode;
+	u8 MacAddr[6];
+} __packed;
+
+static inline int wsm_set_multicast_filter(struct xradio_common *hw_priv,
+					   struct wsm_multicast_filter *fp,
+					   int if_id)
+{
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_DOT11_GROUP_ADDRESSES_TABLE,
+			     fp, sizeof(*fp), if_id);
+}
+
+/* ARP IPv4 filtering - 4.10 */
+struct wsm_arp_ipv4_filter {
+	__le32 enable;
+	__be32 ipv4Address[WSM_MAX_ARP_IP_ADDRTABLE_ENTRIES];
+} __packed;
+
+#ifdef IPV6_FILTERING
+/* NDP IPv6 filtering */
+struct wsm_ndp_ipv6_filter {
+	__le32 enable;
+	struct in6_addr ipv6Address[WSM_MAX_NDP_IP_ADDRTABLE_ENTRIES];
+} __packed;
+/* IPV6 Addr Filter Info */
+struct wsm_ip6_addr_info {
+	u8 filter_mode;
+	u8 address_mode;
+	u8 Reserved[2];
+	u8 ipv6[16];
+};
+
+/* IPV6 Addr Filter */
+struct wsm_ipv6_filter {
+	u8 numfilter;
+	u8 action_mode;
+	u8 Reserved[2];
+	struct wsm_ip6_addr_info ipv6filter[0];
+} __packed;
+#endif /*IPV6_FILTERING*/
+
+static inline int wsm_set_arp_ipv4_filter(struct xradio_common *hw_priv,
+					  struct wsm_arp_ipv4_filter *fp,
+					  int if_id)
+{
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_ARP_IP_ADDRESSES_TABLE,
+			    fp, sizeof(*fp), if_id);
+}
+
+#ifdef IPV6_FILTERING
+static inline int wsm_set_ndp_ipv6_filter(struct xradio_common *priv,
+					  struct wsm_ndp_ipv6_filter *fp,
+					  int if_id)
+{
+	return wsm_write_mib(priv, WSM_MIB_ID_NS_IP_ADDRESSES_TABLE,
+			    fp, sizeof(*fp), if_id);
+}
+#endif /*IPV6_FILTERING*/
+
+/* P2P Power Save Mode Info - 4.31 */
+struct wsm_p2p_ps_modeinfo {
+	u8	oppPsCTWindow;
+	u8	count;
+	u8	reserved;
+	u8	dtimCount;
+	__le32	duration;
+	__le32	interval;
+	__le32	startTime;
+} __packed;
+
+static inline int wsm_set_p2p_ps_modeinfo(struct xradio_common *hw_priv,
+					  struct wsm_p2p_ps_modeinfo *mi,
+					  int if_id)
+{
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_P2P_PS_MODE_INFO,
+			     mi, sizeof(*mi), if_id);
+}
+
+static inline int wsm_get_p2p_ps_modeinfo(struct xradio_common *hw_priv,
+					  struct wsm_p2p_ps_modeinfo *mi)
+{
+	return wsm_read_mib(hw_priv, WSM_MIB_ID_P2P_PS_MODE_INFO,
+			    mi, sizeof(*mi), 0);
+}
+
+/* UseMultiTxConfMessage */
+
+static inline int wsm_use_multi_tx_conf(struct xradio_common *hw_priv,
+					u32 enable, int if_id)
+{
+	__le32 arg = enable;
+	return wsm_write_mib(hw_priv, WSM_MIB_USE_MULTI_TX_CONF,
+			&arg, sizeof(arg), if_id);
+}
+
+
+/* 4.26 SetUpasdInformation */
+struct wsm_uapsd_info {
+	__le16 uapsdFlags;
+	__le16 minAutoTriggerInterval;
+	__le16 maxAutoTriggerInterval;
+	__le16 autoTriggerStep;
+};
+
+static inline int wsm_set_uapsd_info(struct xradio_common *hw_priv,
+				     struct wsm_uapsd_info *arg,
+				     int if_id)
+{
+	/* TODO:COMBO:UAPSD will be supported only on one interface */
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_SET_UAPSD_INFORMATION,
+				arg, sizeof(*arg), if_id);
+}
+
+/* 4.22 OverrideInternalTxRate */
+#ifdef SUPPORT_HT40
+
+struct wsm_override_internal_txrate {
+	u16 internalTxRateEntry;
+	u16 nonErpInterTxRateEntry;
+} __packed;
+
+#else
+
+struct wsm_override_internal_txrate {
+	u8 internalTxRate;
+	u8 nonErpInternalTxRate;
+	u8 reserved[2];
+} __packed;
+
+#endif
+
+static inline int
+wsm_set_override_internal_txrate(struct xradio_common *hw_priv,
+				     struct wsm_override_internal_txrate *arg,
+				     int if_id)
+{
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_OVERRIDE_INTERNAL_TX_RATE,
+				arg, sizeof(*arg), if_id);
+}
+#ifdef MCAST_FWDING
+/* 4.51 SetForwardingOffload */
+struct wsm_forwarding_offload {
+	u8 fwenable;
+	u8 flags;
+	u8 reserved[2];
+} __packed;
+
+static inline int wsm_set_forwarding_offlad(struct xradio_common *hw_priv,
+				     struct wsm_forwarding_offload *arg, int if_id)
+{
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_FORWARDING_OFFLOAD,
+				arg, sizeof(*arg), if_id);
+}
+
+#endif
+/* ******************************************************************** */
+/* WSM TX port control							*/
+
+void wsm_lock_tx(struct xradio_common *hw_priv);
+void wsm_vif_lock_tx(struct xradio_vif *priv);
+void wsm_lock_tx_async(struct xradio_common *hw_priv);
+bool wsm_flush_tx(struct xradio_common *hw_priv);
+bool wsm_vif_flush_tx(struct xradio_vif *priv);
+void wsm_unlock_tx(struct xradio_common *hw_priv);
+
+/* ******************************************************************** */
+/* WSM / BH API								*/
+
+int wsm_handle_exception(struct xradio_common *hw_priv, u8 *data, size_t len);
+int wsm_handle_rx(struct xradio_common *hw_priv, u8 flags, struct sk_buff **skb_p);
+void wsm_send_deauth_to_self(struct xradio_common *hw_priv,
+							 struct xradio_vif *priv);
+void wsm_send_disassoc_to_self(struct xradio_common *hw_priv,
+							   struct xradio_vif *priv);
+
+/* ******************************************************************** */
+/* wsm_buf API								*/
+
+struct wsm_buf {
+	u8 *begin;
+	u8 *data;
+	u8 *end;
+};
+
+void wsm_buf_init(struct wsm_buf *buf, int size);
+void wsm_buf_deinit(struct wsm_buf *buf);
+
+/* ******************************************************************** */
+/* wsm_cmd API								*/
+
+struct wsm_cmd {
+	spinlock_t lock;
+	int done;
+	u8 *ptr;
+	size_t len;
+	void *arg;
+	int ret;
+	u16 cmd;
+	u16 seq;
+};
+
+/* ******************************************************************** */
+/* WSM TX buffer access							*/
+
+int wsm_get_tx(struct xradio_common *hw_priv, u8 **data,
+	       size_t *tx_len, int *burst, int *vif_selected);
+void wsm_txed(struct xradio_common *hw_priv, u8 *data);
+
+/* ******************************************************************** */
+/* Queue mapping: WSM <---> linux					*/
+/* Linux: VO VI BE BK							*/
+/* WSM:   BE BK VI VO							*/
+
+static inline u8 wsm_queue_id_to_linux(u8 queueId)
+{
+	static const u8 queue_mapping[] = {
+		2, 3, 1, 0
+	};
+	return queue_mapping[queueId];
+}
+
+static inline u8 wsm_queue_id_to_wsm(u8 queueId)
+{
+	static const u8 queue_mapping[] = {
+		3, 2, 0, 1
+	};
+	return queue_mapping[queueId];
+}
+
+/***********WSM API**************/
+
+/*
+ * return the length of wsm frame
+ */
+static inline u16 wsm_get_len(struct wsm_hdr *wsm)
+{
+	return wsm->len;
+}
+
+/*
+ * return the id of wsm frame
+ */
+static inline u16 wsm_get_id(struct wsm_hdr *wsm)
+{
+	return ((wsm->id) & WSM_MSG_ID_MASK);
+}
+
+/*
+ * return the 80211 frame ptr in wsm tx frame
+ * only use it in a complete wsm tx frame.
+ */
+static inline u8 *wsm_get_80211_frame(struct wsm_hdr *wsm)
+{
+	struct wsm_tx *wsm_frame = (struct wsm_tx *)wsm;
+
+	/*Todo: When HT40 is undefine, how to get frame?*/
+	return (u8 *)wsm_frame + wsm_frame->DataOffset;
+}
+
+#endif /* XRADIO_HWIO_H_INCLUDED */
diff -Naurp a/drivers/net/wireless/xr829/wlan/xr_version.h b/drivers/net/wireless/xr829/wlan/xr_version.h
--- a/drivers/net/wireless/xr829/wlan/xr_version.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/xr_version.h	2022-08-27 01:22:42.974539938 +0300
@@ -0,0 +1,20 @@
+/*
+ * version for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef XR_VERSION_H
+#define XR_VERSION_H
+
+#define XRADIO_VERSION  "XR_V02.16.85_P2P"
+
+#define XRADIO_MAIN_VER 2
+#define XRADIO_SUB_VER  16
+#define XRADIO_REV_VER  85
+
+#endif
diff -Naurp a/drivers/net/wireless/xr829/wlan/xradio.h b/drivers/net/wireless/xr829/wlan/xradio.h
--- a/drivers/net/wireless/xr829/wlan/xradio.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/net/wireless/xr829/wlan/xradio.h	2022-08-27 01:22:42.974539938 +0300
@@ -0,0 +1,801 @@
+/*
+ * Common define of private data for XRadio drivers
+ *
+ * Copyright (c) 2013
+ * Xradio Technology Co., Ltd. <www.xradiotech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef XRADIO_H
+#define XRADIO_H
+
+#include <linux/wait.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include <linux/sched.h>
+#include <linux/atomic.h>
+#include <net/mac80211.h>
+#include <asm/bitops.h>
+#include <linux/time64.h>
+
+/*Macroses for Driver parameters.*/
+#define XRWL_MAX_QUEUE_SZ    (128)
+#define AC_QUEUE_NUM           4
+
+#ifdef P2P_MULTIVIF
+#define XRWL_MAX_VIFS        (3)
+#else
+#define XRWL_MAX_VIFS        (2)
+#endif
+#define XRWL_GENERIC_IF_ID   (2)
+/* (XRWL_MAX_QUEUE_SZ/(XRWL_MAX_VIFS-1))*0.9 */
+#define XRWL_HOST_VIF0_11N_THROTTLE   (58)
+/* (XRWL_MAX_QUEUE_SZ/(XRWL_MAX_VIFS-1))*0.9 */
+#define XRWL_HOST_VIF1_11N_THROTTLE   (58)
+/* XRWL_HOST_VIF0_11N_THROTTLE*0.6 = 35 */
+#define XRWL_HOST_VIF0_11BG_THROTTLE  (35)
+/* XRWL_HOST_VIF0_11N_THROTTLE*0.6 = 35 */
+#define XRWL_HOST_VIF1_11BG_THROTTLE  (35)
+
+#if 0
+#define XRWL_FW_VIF0_THROTTLE         (15)
+#define XRWL_FW_VIF1_THROTTLE         (15)
+#endif
+
+#ifdef SUPPORT_HT40
+
+#define MAX_RATES_STAGE   6
+
+#else
+
+#define MAX_RATES_STAGE   8
+
+#endif
+
+#define MAX_RATES_RETRY   15
+
+#define IEEE80211_FCTL_WEP      0x4000
+#define IEEE80211_QOS_DATAGRP   0x0080
+#define WSM_KEY_MAX_IDX         20
+
+#ifdef BH_PROC_THREAD
+/*process tx in proc thread*/
+#define BH_PROC_TX       1
+/*process rx in proc thread*/
+#define BH_PROC_RX       1
+/*Dynamic priority adjust*/
+#define BH_PROC_DPA      0
+#else
+#define BH_PROC_TX       0
+#define BH_PROC_RX       0
+#define BH_PROC_DPA      0
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0))
+// #include <uapi/linux/time.h>
+#include <linux/timekeeping.h>
+#include "timeval.h"
+
+void xr_do_gettimeofday(struct timeval *tv);
+void xr_get_monotonic_boottime(struct timespec64 *ts);
+
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)) */
+
+#include "common.h"
+#include "queue.h"
+#include "wsm.h"
+#include "scan.h"
+#include "txrx.h"
+#include "bh.h"
+#include "ht.h"
+#include "pm.h"
+#include "fwio.h"
+#ifdef CONFIG_XRADIO_TESTMODE
+#include "nl80211_testmode_msg_copy.h"
+#endif /*CONFIG_XRADIO_TESTMODE*/
+#ifdef CONFIG_XRADIO_ETF
+#include "etf.h"
+#endif
+
+/* #define ROC_DEBUG */
+/* hidden ssid is only supported when separate probe resp IE
+   configuration is supported */
+#ifdef PROBE_RESP_EXTRA_IE
+#define HIDDEN_SSID   1
+#endif
+
+#define XRADIO_MAX_CTRL_FRAME_LEN  (0x1000)
+
+#define MAX_STA_IN_AP_MODE         (14)
+#define WLAN_LINK_ID_MAX           (MAX_STA_IN_AP_MODE + 3)
+
+#define XRADIO_MAX_STA_IN_AP_MODE   (5)
+#define XRADIO_MAX_REQUEUE_ATTEMPTS (5)
+#define XRADIO_LINK_ID_UNMAPPED     (15)
+#define XRADIO_MAX_TID              (8)
+
+#define XRADIO_TX_BLOCK_ACK_ENABLED_FOR_ALL_TID    (0x3F)
+#define XRADIO_RX_BLOCK_ACK_ENABLED_FOR_ALL_TID    (0x3F)
+#define XRADIO_RX_BLOCK_ACK_ENABLED_FOR_BE_TID \
+       (XRADIO_TX_BLOCK_ACK_ENABLED_FOR_ALL_TID & 0x01)
+#define XRADIO_TX_BLOCK_ACK_DISABLED_FOR_ALL_TID   (0)
+#define XRADIO_RX_BLOCK_ACK_DISABLED_FOR_ALL_TID   (0)
+
+#define XRADIO_BLOCK_ACK_CNT    (30)
+#define XRADIO_BLOCK_ACK_THLD   (800)
+#define XRADIO_BLOCK_ACK_HIST   (3)
+#define XRADIO_BLOCK_ACK_INTERVAL	(1 * HZ / XRADIO_BLOCK_ACK_HIST)
+#define XRWL_ALL_IFS           (-1)
+
+#ifdef ROAM_OFFLOAD
+#define XRADIO_SCAN_TYPE_ACTIVE 0x1000
+#define XRADIO_SCAN_BAND_5G     0x2000
+#endif /*ROAM_OFFLOAD*/
+
+#define IEEE80211_FCTL_WEP      0x4000
+#define IEEE80211_QOS_DATAGRP   0x0080
+#ifdef CONFIG_XRADIO_TESTMODE
+#define XRADIO_SCAN_MEASUREMENT_PASSIVE (0)
+#define XRADIO_SCAN_MEASUREMENT_ACTIVE  (1)
+#endif
+
+#ifdef MCAST_FWDING
+#define WSM_MAX_BUF		30
+#endif
+
+#define XRADIO_PLAT_DEVICE   "xradio_device"
+#define XRADIO_WORKQUEUE   "xradio_wq"
+#define XRADIO_SPARE_WORKQUEUE   "xradio_spare_wq"
+#define WIFI_CONF_PATH    "/data/vendor/wifi/xr_wifi.conf"
+#define XRADIO_HWINFO_FILE  "/data/vendor/wifi/hwinfo.bin"
+
+extern char *drv_version;
+extern char *drv_buildtime;
+#define DRV_VERSION    drv_version
+#define DRV_BUILDTIME  drv_buildtime
+
+/* extern */ struct sbus_ops;
+/* extern */ struct task_struct;
+/* extern */ struct xradio_debug_priv;
+/* extern */ struct xradio_debug_common;
+/* extern */ struct firmware;
+
+/* Please keep order */
+enum xradio_join_status {
+	XRADIO_JOIN_STATUS_PASSIVE = 0,
+	XRADIO_JOIN_STATUS_MONITOR,
+	XRADIO_JOIN_STATUS_STA,
+	XRADIO_JOIN_STATUS_AP,
+};
+
+enum xradio_link_status {
+	XRADIO_LINK_OFF,
+	XRADIO_LINK_RESERVE,
+	XRADIO_LINK_SOFT,
+	XRADIO_LINK_HARD,
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+	XRADIO_LINK_RESET,
+	XRADIO_LINK_RESET_REMAP,
+#endif
+};
+
+enum xradio_bss_loss_status {
+	XRADIO_BSS_LOSS_NONE,
+	XRADIO_BSS_LOSS_CHECKING,
+	XRADIO_BSS_LOSS_CONFIRMING,
+	XRADIO_BSS_LOSS_CONFIRMED,
+};
+
+struct xradio_link_entry {
+	unsigned long			timestamp;
+	enum xradio_link_status		status;
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+	enum xradio_link_status		prev_status;
+#endif
+	u8				mac[ETH_ALEN];
+	u8				buffered[XRADIO_MAX_TID];
+	struct sk_buff_head		rx_queue;
+};
+
+#if defined(ROAM_OFFLOAD) || defined(CONFIG_XRADIO_TESTMODE)
+struct xradio_testframe {
+	u8 len;
+	u8 *data;
+};
+#endif
+#ifdef CONFIG_XRADIO_TESTMODE
+struct advance_scan_elems {
+	u8 scanMode;
+	u16 duration;
+};
+/**
+ * xradio_tsm_info - Keeps information about ongoing TSM collection
+ * @ac: Access category for which metrics to be collected
+ * @use_rx_roaming: Use received voice packets to compute roam delay
+ * @sta_associated: Set to 1 after association
+ * @sta_roamed: Set to 1 after successful roaming
+ * @roam_delay: Roam delay
+ * @rx_timestamp_vo: Timestamp of received voice packet
+ * @txconf_timestamp_vo: Timestamp of received tx confirmation for
+ * successfully transmitted VO packet
+ * @sum_pkt_q_delay: Sum of packet queue delay
+ * @sum_media_delay: Sum of media delay
+ *
+ */
+struct xradio_tsm_info {
+	u8 ac;
+	u8 use_rx_roaming;
+	u8 sta_associated;
+	u8 sta_roamed;
+	u16 roam_delay;
+	u32 rx_timestamp_vo;
+	u32 txconf_timestamp_vo;
+	u32 sum_pkt_q_delay;
+	u32 sum_media_delay;
+};
+
+/**
+ * xradio_start_stop_tsm - To start or stop collecting TSM metrics in
+ * xradio driver
+ * @start: To start or stop collecting TSM metrics
+ * @up: up for which metrics to be collected
+ * @packetization_delay: Packetization delay for this TID
+ *
+ */
+struct xradio_start_stop_tsm {
+	u8 start;       /*1: To start, 0: To stop*/
+	u8 up;
+	u16 packetization_delay;
+};
+
+#endif /* CONFIG_XRADIO_TESTMODE */
+struct xradio_common {
+	struct xradio_debug_common	*debug;
+	struct xradio_queue		tx_queue[AC_QUEUE_NUM];
+	struct xradio_queue_stats	tx_queue_stats;
+
+	struct platform_device  *plat_device;
+	struct ieee80211_hw		*hw;
+	/*
+	 * 0 for sta or ap
+	 * 1 for p2p device
+	 * 2 for p2p interface
+	 */
+	struct mac_address		addresses[XRWL_MAX_VIFS];
+
+	/*Will be a pointer to a list of VIFs - Dynamically allocated */
+	struct ieee80211_vif		*vif_list[XRWL_MAX_VIFS];
+	atomic_t			num_vifs;
+	spinlock_t			vif_list_lock;
+	u32				if_id_slot;
+	struct device			*pdev;
+	struct workqueue_struct		*workqueue;
+
+	struct semaphore		conf_lock;
+
+	/* some works can not push into a same workqueue, so create a
+	 * spare workqueue to separate them.
+	 */
+	struct workqueue_struct 	*spare_workqueue;
+
+	const struct sbus_ops		*sbus_ops;
+	struct sbus_priv		*sbus_priv;
+	int 			driver_ready;
+
+	/* HW/FW type (HIF_...) */
+	int				hw_type;
+	int				hw_revision;
+	int				fw_revision;
+
+	/* firmware/hardware info */
+	unsigned int tx_hdr_len;
+
+	/* Radio data */
+	int output_power;
+	int noise;
+
+	/* calibration, output power limit and rssi<->dBm conversation data */
+
+	/* BBP/MAC state */
+	const struct firmware		*sdd;
+	struct ieee80211_rate		*rates;
+	struct ieee80211_rate		*mcs_rates;
+	u8 mac_addr[ETH_ALEN];
+	/*TODO:COMBO: To be made per VIFF after mac80211 support */
+	struct ieee80211_channel	*channel;
+	int				channel_switch_in_progress;
+	wait_queue_head_t		channel_switch_done;
+	u8				channel_changed;
+	u8				long_frame_max_tx_count;
+	u8				short_frame_max_tx_count;
+	/* TODO:COMBO: According to Hong aggregation will happen per VIFF.
+	* Keeping in common structure for the time being. Will be moved to VIFF
+	* after the mechanism is clear */
+	u8				ba_tid_mask;
+	int				ba_acc; /*TODO: Same as above */
+	int				ba_cnt; /*TODO: Same as above */
+	int				ba_cnt_rx; /*TODO: Same as above */
+	int				ba_acc_rx; /*TODO: Same as above */
+	int				ba_hist; /*TODO: Same as above */
+	struct timer_list		ba_timer;/*TODO: Same as above */
+	spinlock_t			ba_lock; /*TODO: Same as above */
+	bool				ba_ena; /*TODO: Same as above */
+	struct work_struct              ba_work; /*TODO: Same as above */
+#ifdef CONFIG_PM
+	struct xradio_pm_state		pm_state;
+#endif
+	/* BT status*/
+	bool				is_BT_Present;
+	u16                 BT_active;
+	unsigned long       BT_duration;  /*timer jiffies*/
+	struct timer_list   BT_timer;
+	bool				is_go_thru_go_neg;
+	u8				conf_listen_interval;
+
+	/* BH */
+	atomic_t			bh_rx;
+	atomic_t			bh_tx;
+	atomic_t			bh_term;
+	atomic_t			bh_suspend;
+	struct task_struct		*bh_thread;
+	int				bh_error;
+#ifdef BH_USE_SEMAPHORE
+	struct semaphore		bh_sem;
+	atomic_t			    bh_wk;
+#else
+	wait_queue_head_t		bh_wq;
+#endif
+	wait_queue_head_t		bh_evt_wq;
+#ifdef BH_PROC_THREAD
+	struct bh_proc      proc;
+#endif
+
+	int				buf_id_tx;	/* byte */
+	int				buf_id_rx;	/* byte */
+	int				wsm_rx_seq;	/* byte */
+	int				wsm_tx_seq;	/* byte */
+	int				hw_bufs_used;
+	int				hw_bufs_used_vif[XRWL_MAX_VIFS];
+	struct sk_buff			*skb_cache;
+	struct sk_buff			*skb_reserved;
+	int						 skb_resv_len;
+	spinlock_t				 cache_lock;
+	bool				powersave_enabled;
+	bool				device_can_sleep;
+	/* Keep xradio awake (WUP = 1) 1 second after each scan to avoid
+	 * FW issue with sleeping/waking up. */
+	atomic_t            recent_scan;
+	atomic_t            suspend_state;
+	atomic_t            suspend_lock_state;
+	wait_queue_head_t		wsm_wakeup_done;
+#ifdef HW_RESTART
+	bool                exit_sync;
+	int			hw_restart_work_running;
+	bool                hw_restart;
+	struct work_struct  hw_restart_work;
+#endif
+
+	/* WSM */
+	struct wsm_caps			wsm_caps;
+	struct semaphore                wsm_cmd_sema;
+	struct wsm_buf			wsm_cmd_buf;
+	struct wsm_cmd			wsm_cmd;
+	wait_queue_head_t		wsm_cmd_wq;
+	wait_queue_head_t		wsm_startup_done;
+	struct wsm_cbc			wsm_cbc;
+	struct semaphore		tx_lock_sem;
+	atomic_t			tx_lock;
+	struct semaphore		dtor_lock;
+	u32				pending_frame_id;
+#ifdef CONFIG_XRADIO_TESTMODE
+	/* Device Power Range */
+	struct wsm_tx_power_range       txPowerRange[2];
+	/* Advance Scan */
+	struct advance_scan_elems	advanceScanElems;
+	bool				enable_advance_scan;
+	struct delayed_work		advance_scan_timeout;
+#endif /* CONFIG_XRADIO_TESTMODE */
+
+	/* WSM debug */
+	int                 wsm_enable_wsm_dumps;
+	u32                 wsm_dump_max_size;
+	u32                 query_packetID;
+	atomic_t            query_cnt;
+	struct work_struct  query_work; /* for query packet */
+
+	/* Scan status */
+	struct xradio_scan scan;
+	int scan_delay_status[XRWL_MAX_VIFS];
+	unsigned long scan_delay_time[XRWL_MAX_VIFS];
+
+	/* TX/RX */
+	unsigned long		rx_timestamp;
+
+	/* WSM events */
+	spinlock_t		event_queue_lock;
+	struct list_head	event_queue;
+	struct work_struct	event_handler;
+
+	/* TX rate policy cache */
+	struct tx_policy_cache tx_policy_cache;
+	struct work_struct tx_policy_upload_work;
+	atomic_t upload_count;
+
+	/* cryptographic engine information */
+
+	/* bit field of glowing LEDs */
+	u16 softled_state;
+
+	/* statistics */
+	struct ieee80211_low_level_stats stats;
+
+	struct xradio_ht_info		ht_info;
+	int				tx_burst_idx;
+
+	struct ieee80211_iface_limit		if_limits1[2];
+	struct ieee80211_iface_limit		if_limits2[2];
+	struct ieee80211_iface_limit		if_limits3[2];
+	struct ieee80211_iface_combination	if_combs[3];
+
+	struct semaphore		wsm_oper_lock;
+	struct delayed_work		rem_chan_timeout;
+	atomic_t			remain_on_channel;
+	int				roc_if_id;
+	u64				roc_cookie;
+	wait_queue_head_t		offchannel_wq;
+	u16				offchannel_done;
+	u16				prev_channel;
+	int       if_id_selected;
+	u32				key_map;
+	struct wsm_add_key		keys[WSM_KEY_MAX_INDEX + 1];
+#ifdef MCAST_FWDING
+	struct wsm_buf		wsm_release_buf;
+	u8			buf_released;
+#endif
+#ifdef ROAM_OFFLOAD
+	u8				auto_scanning;
+	u8				frame_rcvd;
+	u8				num_scanchannels;
+	u8				num_2g_channels;
+	u8				num_5g_channels;
+	struct wsm_scan_ch		scan_channels[48];
+	struct sk_buff 			*beacon;
+	struct sk_buff 			*beacon_bkp;
+	struct xradio_testframe 	testframe;
+#endif /*ROAM_OFFLOAD*/
+#ifdef CONFIG_XRADIO_TESTMODE
+	struct xradio_testframe test_frame;
+	struct xr_tsm_stats		tsm_stats;
+	struct xradio_tsm_info		tsm_info;
+	spinlock_t			tsm_lock;
+	struct xradio_start_stop_tsm	start_stop_tsm;
+#endif /* CONFIG_XRADIO_TESTMODE */
+	u8          connected_sta_cnt;
+	u16			vif0_throttle;
+	u16			vif1_throttle;
+#ifdef	MONITOR_MODE
+	int			monitor_if_id;
+	bool			monitor_running;
+#endif
+#ifdef BOOT_NOT_READY_FIX
+	u8          boot_not_ready_cnt;
+	u8          boot_not_ready;
+#endif
+	u8          join_chan;
+};
+
+/* Virtual Interface State. One copy per VIF */
+struct xradio_vif {
+	atomic_t			enabled;
+	spinlock_t			vif_lock;
+	int				if_id;
+	/*TODO: Split into Common and VIF parts */
+	struct xradio_debug_priv	*debug;
+	/* BBP/MAC state */
+	u8 bssid[ETH_ALEN];
+	struct wsm_edca_params		edca;
+	struct wsm_tx_queue_params	tx_queue_params;
+	struct wsm_association_mode	association_mode;
+	struct wsm_set_bss_params	bss_params;
+	struct wsm_set_pm		powersave_mode;
+	struct wsm_set_pm		firmware_ps_mode;
+	int				power_set_true;
+	int				user_power_set_true;
+	u8				user_pm_mode;
+	int				cqm_rssi_thold;
+	unsigned			cqm_rssi_hyst;
+	unsigned			cqm_tx_failure_thold;
+	unsigned			cqm_tx_failure_count;
+	bool				cqm_use_rssi;
+	int				cqm_link_loss_count;
+	int				cqm_beacon_loss_count;
+	int				mode;
+	bool				enable_beacon;
+	int				beacon_int;
+	size_t				ssid_length;
+	u8				ssid[IEEE80211_MAX_SSID_LEN];
+#ifdef HIDDEN_SSID
+	bool				hidden_ssid;
+#endif
+	bool				listening;
+	struct wsm_rx_filter		rx_filter;
+	struct wsm_beacon_filter_table	bf_table;
+	struct wsm_beacon_filter_control bf_control;
+	struct wsm_multicast_filter	multicast_filter;
+	bool				has_multicast_subscription;
+	struct wsm_broadcast_addr_filter	broadcast_filter;
+	bool				disable_beacon_filter;
+	struct wsm_arp_ipv4_filter      filter4;
+#ifdef IPV6_FILTERING
+	struct wsm_ndp_ipv6_filter 	filter6;
+#endif /*IPV6_FILTERING*/
+	struct work_struct		update_filtering_work;
+	struct work_struct		set_beacon_wakeup_period_work;
+#ifdef CONFIG_PM
+	struct xradio_pm_state_vif	pm_state_vif;
+#endif
+	/*TODO: Add support in mac80211 for psmode info per VIF */
+	struct wsm_p2p_ps_modeinfo	p2p_ps_modeinfo;
+	struct wsm_uapsd_info		uapsd_info;
+	bool				setbssparams_done;
+	u32				listen_interval;
+	u32				erp_info;
+	bool				powersave_enabled;
+
+	/* WSM Join */
+	enum xradio_join_status	join_status;
+	u8			join_bssid[ETH_ALEN];
+	struct work_struct	join_work;
+	struct delayed_work	join_timeout;
+	struct work_struct	unjoin_work;
+	struct delayed_work	unjoin_delayed_work;
+	struct work_struct	offchannel_work;
+	int			join_dtim_period;
+	atomic_t	delayed_unjoin;
+
+	/* Security */
+	s8			wep_default_key_id;
+	struct work_struct	wep_key_work;
+	unsigned long           rx_timestamp;
+	u32                     unicast_cipher_type;
+
+
+	/* AP powersave */
+	u32			link_id_map;
+	u32			max_sta_ap_mode;
+	u32			link_id_after_dtim;
+	u32			link_id_uapsd;
+	u32			link_id_max;
+	u32			wsm_key_max_idx;
+	struct xradio_link_entry link_id_db[MAX_STA_IN_AP_MODE];
+	struct work_struct	link_id_work;
+	struct delayed_work	link_id_gc_work;
+	u32			sta_asleep_mask;
+	u32			pspoll_mask;
+	bool			aid0_bit_set;
+	spinlock_t		ps_state_lock;
+	bool			buffered_multicasts;
+	bool			tx_multicast;
+	u8     last_tim[8];  /*for softap dtim*/
+	struct work_struct	set_tim_work;
+	struct delayed_work	set_cts_work;
+	struct work_struct	multicast_start_work;
+	struct work_struct	multicast_stop_work;
+	struct timer_list	mcast_timeout;
+
+	/* CQM Implementation */
+	struct delayed_work	bss_loss_work;
+	struct delayed_work	connection_loss_work;
+	struct work_struct	tx_failure_work;
+	int			delayed_link_loss;
+	spinlock_t		bss_loss_lock;
+	int			bss_loss_status;
+	int			bss_loss_confirm_id;
+
+	struct ieee80211_vif	*vif;
+	struct xradio_common	*hw_priv;
+	struct ieee80211_hw	*hw;
+
+	/* ROC implementation */
+	struct delayed_work		pending_offchanneltx_work;
+#if defined(CONFIG_XRADIO_USE_EXTENSIONS)
+	/* Workaround for WFD testcase 6.1.10*/
+	struct work_struct	linkid_reset_work;
+	u8			action_frame_sa[ETH_ALEN];
+	u8			action_linkid;
+#endif
+	/* Some optimizations for tx rate build.*/
+	u32          base_rates;
+	u32          oper_rates;
+
+	bool			htcap;
+#ifdef AP_HT_CAP_UPDATE
+	u16                     ht_info;
+	struct work_struct      ht_info_update_work;
+#endif
+
+#ifdef AP_HT_COMPAT_FIX
+	u16    ht_compat_cnt;
+	u16    ht_compat_det;
+#endif
+
+#ifdef AP_ARP_COMPAT_FIX
+	u16    arp_compat_cnt;
+#endif
+	bool	is_mfp_connect;
+};
+struct xradio_sta_priv {
+	int link_id;
+	struct xradio_vif *priv;
+};
+enum xradio_data_filterid {
+	IPV4ADDR_FILTER_ID = 0,
+#ifdef IPV6_FILTERING
+	IPV6ADDR_FILTER_ID,
+#endif /*IPV6_FILTERING*/
+};
+
+#ifdef IPV6_FILTERING
+/* IPV6 host addr info */
+struct ipv6_addr_info {
+	u8 filter_mode;
+	u8 address_mode;
+	u16 ipv6[8];
+};
+#endif /*IPV6_FILTERING*/
+
+/* Datastructure for LLC-SNAP HDR */
+#define P80211_OUI_LEN  3
+struct ieee80211_snap_hdr {
+	u8    dsap;   /* always 0xAA */
+	u8    ssap;   /* always 0xAA */
+	u8    ctrl;   /* always 0x03 */
+	u8    oui[P80211_OUI_LEN];    /* organizational universal id */
+} __packed;
+
+
+#ifdef TES_P2P_0002_ROC_RESTART
+extern s32  TES_P2P_0002_roc_dur;
+extern s32  TES_P2P_0002_roc_sec;
+extern s32  TES_P2P_0002_roc_usec;
+extern u32  TES_P2P_0002_packet_id;
+extern u32  TES_P2P_0002_state;
+
+#define TES_P2P_0002_STATE_IDLE       0x00
+#define TES_P2P_0002_STATE_SEND_RESP  0x01
+#define TES_P2P_0002_STATE_GET_PKTID  0x02
+#endif
+
+/* debug.h must be here because refer to struct xradio_vif and
+   struct xradio_common.*/
+#include "debug.h"
+
+/*******************************************************
+ interfaces for operations of vif.
+********************************************************/
+static inline
+struct xradio_common *xrwl_vifpriv_to_hwpriv(struct xradio_vif *priv)
+{
+	return priv->hw_priv;
+}
+static inline
+struct xradio_vif *xrwl_get_vif_from_ieee80211(struct ieee80211_vif *vif)
+{
+	return  (struct xradio_vif *)vif->drv_priv;
+}
+
+static inline
+struct xradio_vif *xrwl_hwpriv_to_vifpriv(struct xradio_common *hw_priv,
+						int if_id)
+{
+	struct xradio_vif *vif;
+
+	if (SYS_WARN((-1 == if_id) || (if_id > XRWL_MAX_VIFS)))
+		return NULL;
+	/* TODO:COMBO: During scanning frames can be received
+	 * on interface ID 3 */
+	spin_lock(&hw_priv->vif_list_lock);
+	if (!hw_priv->vif_list[if_id]) {
+		spin_unlock(&hw_priv->vif_list_lock);
+		return NULL;
+	}
+
+	vif = xrwl_get_vif_from_ieee80211(hw_priv->vif_list[if_id]);
+	SYS_WARN(!vif);
+	if (vif && atomic_read(&vif->enabled))
+		spin_lock(&vif->vif_lock);
+	else
+		vif = NULL;
+	spin_unlock(&hw_priv->vif_list_lock);
+	return vif;
+}
+
+static inline
+struct xradio_vif *__xrwl_hwpriv_to_vifpriv(struct xradio_common *hw_priv,
+					      int if_id)
+{
+	SYS_WARN((-1 == if_id) || (if_id > XRWL_MAX_VIFS));
+	/* TODO:COMBO: During scanning frames can be received
+	 * on interface ID 3 */
+	if (!hw_priv->vif_list[if_id]) {
+		return NULL;
+	}
+
+	return xrwl_get_vif_from_ieee80211(hw_priv->vif_list[if_id]);
+}
+
+static inline
+struct xradio_vif *xrwl_get_activevif(struct xradio_common *hw_priv)
+{
+	return xrwl_hwpriv_to_vifpriv(hw_priv, ffs(hw_priv->if_id_slot)-1);
+}
+
+static inline bool is_hardware_xradio(struct xradio_common *hw_priv)
+{
+	return (hw_priv->hw_revision == XR829_HW_REV0);
+}
+
+static inline int xrwl_get_nr_hw_ifaces(struct xradio_common *hw_priv)
+{
+	switch (hw_priv->hw_revision) {
+	case XR829_HW_REV0:
+	default:
+		return 1;
+	}
+}
+
+#define xradio_for_each_vif(_hw_priv, _priv, _i) \
+	for ( \
+		_i = 0; \
+		(_i < XRWL_MAX_VIFS)  \
+		&& ((_priv = _hw_priv->vif_list[_i] ? \
+		xrwl_get_vif_from_ieee80211(_hw_priv->vif_list[_i]) : NULL), 1); \
+		_i++ \
+	)
+
+/*******************************************************
+ interfaces for operations of queue.
+********************************************************/
+static inline void xradio_tx_queues_lock(struct xradio_common *hw_priv)
+{
+	int i;
+	for (i = 0; i < 4; ++i)
+		xradio_queue_lock(&hw_priv->tx_queue[i]);
+}
+
+static inline void xradio_tx_queues_unlock(struct xradio_common *hw_priv)
+{
+	int i;
+	for (i = 0; i < 4; ++i)
+		xradio_queue_unlock(&hw_priv->tx_queue[i]);
+}
+
+/*******************************************************
+ interfaces for BT.
+********************************************************/
+static inline u16 xradio_bt_active_bit(u8 link_type)
+{
+	if (link_type == BT_LINK_TPYE_INQUIRY)
+		return BIT(1);
+	else
+		return BIT(0);
+}
+
+static inline bool xradio_bt_block_type(u8 link_type)
+{
+	if (link_type == BT_LINK_TPYE_INQUIRY)
+		return 1;
+	else
+		return 0;
+}
+
+static inline bool xradio_is_bt_block(struct xradio_common *hw_priv)
+{
+	return (hw_priv->BT_active &
+			xradio_bt_active_bit(BT_LINK_TPYE_INQUIRY));
+}
+
+#endif /* XRADIO_H */
